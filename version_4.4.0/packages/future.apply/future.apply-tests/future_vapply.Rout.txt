
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:38:06.375] plan(): Setting new future strategy stack:
[17:38:06.375] List of future strategies:
[17:38:06.375] 1. sequential:
[17:38:06.375]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.375]    - tweaked: FALSE
[17:38:06.375]    - call: future::plan("sequential")
[17:38:06.389] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:38:06.494] plan(): Setting new future strategy stack:
[17:38:06.494] List of future strategies:
[17:38:06.494] 1. sequential:
[17:38:06.494]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.494]    - tweaked: FALSE
[17:38:06.494]    - call: plan(strategy)
[17:38:06.505] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[17:38:06.512] future_lapply() ...
[17:38:06.517] Number of chunks: 1
[17:38:06.518] getGlobalsAndPackagesXApply() ...
[17:38:06.518]  - future.globals: TRUE
[17:38:06.518] getGlobalsAndPackages() ...
[17:38:06.519] Searching for globals...
[17:38:06.522] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:06.523] Searching for globals ... DONE
[17:38:06.523] Resolving globals: FALSE
[17:38:06.524] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[17:38:06.525] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:06.525] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.525] - packages: [1] ‘future.apply’
[17:38:06.525] getGlobalsAndPackages() ... DONE
[17:38:06.525]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.525]  - needed namespaces: [n=1] ‘future.apply’
[17:38:06.526] Finding globals ... DONE
[17:38:06.526]  - use_args: TRUE
[17:38:06.526]  - Getting '...' globals ...
[17:38:06.526] resolve() on list ...
[17:38:06.527]  recursive: 0
[17:38:06.527]  length: 1
[17:38:06.527]  elements: ‘...’
[17:38:06.527]  length: 0 (resolved future 1)
[17:38:06.527] resolve() on list ... DONE
[17:38:06.527]    - '...' content: [n=0] 
[17:38:06.527] List of 1
[17:38:06.527]  $ ...: list()
[17:38:06.527]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.527]  - attr(*, "where")=List of 1
[17:38:06.527]   ..$ ...:<environment: 0x560800d0bad8> 
[17:38:06.527]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.527]  - attr(*, "resolved")= logi TRUE
[17:38:06.527]  - attr(*, "total_size")= num NA
[17:38:06.530]  - Getting '...' globals ... DONE
[17:38:06.530] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:06.530] List of 8
[17:38:06.530]  $ ...future.FUN:function (x, ...)  
[17:38:06.530]  $ x_FUN        :function (x)  
[17:38:06.530]  $ times        : int 1
[17:38:06.530]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.530]  $ stop_if_not  :function (...)  
[17:38:06.530]  $ dim          : NULL
[17:38:06.530]  $ valid_types  : chr "character"
[17:38:06.530]  $ ...          : list()
[17:38:06.530]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.530]  - attr(*, "where")=List of 8
[17:38:06.530]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:06.530]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:06.530]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:06.530]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:06.530]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:06.530]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:06.530]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:06.530]   ..$ ...          :<environment: 0x560800d0bad8> 
[17:38:06.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.530]  - attr(*, "resolved")= logi FALSE
[17:38:06.530]  - attr(*, "total_size")= num 94208
[17:38:06.535] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:06.536] getGlobalsAndPackagesXApply() ... DONE
[17:38:06.536] Number of futures (= number of chunks): 1
[17:38:06.536] Launching 1 futures (chunks) ...
[17:38:06.536] Chunk #1 of 1 ...
[17:38:06.536]  - Finding globals in 'X' for chunk #1 ...
[17:38:06.537] getGlobalsAndPackages() ...
[17:38:06.537] Searching for globals...
[17:38:06.537] 
[17:38:06.537] Searching for globals ... DONE
[17:38:06.537] - globals: [0] <none>
[17:38:06.537] getGlobalsAndPackages() ... DONE
[17:38:06.537]    + additional globals found: [n=0] 
[17:38:06.537]    + additional namespaces needed: [n=0] 
[17:38:06.537]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:06.538]  - seeds: <none>
[17:38:06.538]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.538] getGlobalsAndPackages() ...
[17:38:06.538] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.538] Resolving globals: FALSE
[17:38:06.538] Tweak future expression to call with '...' arguments ...
[17:38:06.538] {
[17:38:06.538]     do.call(function(...) {
[17:38:06.538]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.538]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.538]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.538]             on.exit(options(oopts), add = TRUE)
[17:38:06.538]         }
[17:38:06.538]         {
[17:38:06.538]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.538]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.538]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.538]             })
[17:38:06.538]         }
[17:38:06.538]     }, args = future.call.arguments)
[17:38:06.538] }
[17:38:06.539] Tweak future expression to call with '...' arguments ... DONE
[17:38:06.539] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.539] - packages: [1] ‘future.apply’
[17:38:06.539] getGlobalsAndPackages() ... DONE
[17:38:06.540] run() for ‘Future’ ...
[17:38:06.540] - state: ‘created’
[17:38:06.540] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:06.541] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.541] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:06.541]   - Field: ‘label’
[17:38:06.541]   - Field: ‘local’
[17:38:06.541]   - Field: ‘owner’
[17:38:06.541]   - Field: ‘envir’
[17:38:06.541]   - Field: ‘packages’
[17:38:06.541]   - Field: ‘gc’
[17:38:06.541]   - Field: ‘conditions’
[17:38:06.542]   - Field: ‘expr’
[17:38:06.542]   - Field: ‘uuid’
[17:38:06.542]   - Field: ‘seed’
[17:38:06.542]   - Field: ‘version’
[17:38:06.542]   - Field: ‘result’
[17:38:06.542]   - Field: ‘asynchronous’
[17:38:06.542]   - Field: ‘calls’
[17:38:06.542]   - Field: ‘globals’
[17:38:06.542]   - Field: ‘stdout’
[17:38:06.542]   - Field: ‘earlySignal’
[17:38:06.542]   - Field: ‘lazy’
[17:38:06.543]   - Field: ‘state’
[17:38:06.543] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:06.543] - Launch lazy future ...
[17:38:06.543] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:06.547] Packages needed by future strategies (n = 0): <none>
[17:38:06.548] {
[17:38:06.548]     {
[17:38:06.548]         {
[17:38:06.548]             ...future.startTime <- base::Sys.time()
[17:38:06.548]             {
[17:38:06.548]                 {
[17:38:06.548]                   {
[17:38:06.548]                     {
[17:38:06.548]                       base::local({
[17:38:06.548]                         has_future <- base::requireNamespace("future", 
[17:38:06.548]                           quietly = TRUE)
[17:38:06.548]                         if (has_future) {
[17:38:06.548]                           ns <- base::getNamespace("future")
[17:38:06.548]                           version <- ns[[".package"]][["version"]]
[17:38:06.548]                           if (is.null(version)) 
[17:38:06.548]                             version <- utils::packageVersion("future")
[17:38:06.548]                         }
[17:38:06.548]                         else {
[17:38:06.548]                           version <- NULL
[17:38:06.548]                         }
[17:38:06.548]                         if (!has_future || version < "1.8.0") {
[17:38:06.548]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:06.548]                             "", base::R.version$version.string), 
[17:38:06.548]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:06.548]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:06.548]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:06.548]                               "release", "version")], collapse = " "), 
[17:38:06.548]                             hostname = base::Sys.info()[["nodename"]])
[17:38:06.548]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:06.548]                             info)
[17:38:06.548]                           info <- base::paste(info, collapse = "; ")
[17:38:06.548]                           if (!has_future) {
[17:38:06.548]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:06.548]                               info)
[17:38:06.548]                           }
[17:38:06.548]                           else {
[17:38:06.548]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:06.548]                               info, version)
[17:38:06.548]                           }
[17:38:06.548]                           base::stop(msg)
[17:38:06.548]                         }
[17:38:06.548]                       })
[17:38:06.548]                     }
[17:38:06.548]                     base::local({
[17:38:06.548]                       for (pkg in "future.apply") {
[17:38:06.548]                         base::loadNamespace(pkg)
[17:38:06.548]                         base::library(pkg, character.only = TRUE)
[17:38:06.548]                       }
[17:38:06.548]                     })
[17:38:06.548]                   }
[17:38:06.548]                   ...future.strategy.old <- future::plan("list")
[17:38:06.548]                   options(future.plan = NULL)
[17:38:06.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:06.548]                 }
[17:38:06.548]                 ...future.workdir <- getwd()
[17:38:06.548]             }
[17:38:06.548]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:06.548]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:06.548]         }
[17:38:06.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:06.548]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:06.548]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:06.548]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:06.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:06.548]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:06.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:06.548]             base::names(...future.oldOptions))
[17:38:06.548]     }
[17:38:06.548]     if (FALSE) {
[17:38:06.548]     }
[17:38:06.548]     else {
[17:38:06.548]         if (TRUE) {
[17:38:06.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:06.548]                 open = "w")
[17:38:06.548]         }
[17:38:06.548]         else {
[17:38:06.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:06.548]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:06.548]         }
[17:38:06.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:06.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:06.548]             base::sink(type = "output", split = FALSE)
[17:38:06.548]             base::close(...future.stdout)
[17:38:06.548]         }, add = TRUE)
[17:38:06.548]     }
[17:38:06.548]     ...future.frame <- base::sys.nframe()
[17:38:06.548]     ...future.conditions <- base::list()
[17:38:06.548]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:06.548]     if (FALSE) {
[17:38:06.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:06.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:06.548]     }
[17:38:06.548]     ...future.result <- base::tryCatch({
[17:38:06.548]         base::withCallingHandlers({
[17:38:06.548]             ...future.value <- base::withVisible(base::local({
[17:38:06.548]                 do.call(function(...) {
[17:38:06.548]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.548]                   if (!identical(...future.globals.maxSize.org, 
[17:38:06.548]                     ...future.globals.maxSize)) {
[17:38:06.548]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.548]                     on.exit(options(oopts), add = TRUE)
[17:38:06.548]                   }
[17:38:06.548]                   {
[17:38:06.548]                     lapply(seq_along(...future.elements_ii), 
[17:38:06.548]                       FUN = function(jj) {
[17:38:06.548]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.548]                         ...future.FUN(...future.X_jj, ...)
[17:38:06.548]                       })
[17:38:06.548]                   }
[17:38:06.548]                 }, args = future.call.arguments)
[17:38:06.548]             }))
[17:38:06.548]             future::FutureResult(value = ...future.value$value, 
[17:38:06.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.548]                   ...future.rng), globalenv = if (FALSE) 
[17:38:06.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:06.548]                     ...future.globalenv.names))
[17:38:06.548]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:06.548]         }, condition = base::local({
[17:38:06.548]             c <- base::c
[17:38:06.548]             inherits <- base::inherits
[17:38:06.548]             invokeRestart <- base::invokeRestart
[17:38:06.548]             length <- base::length
[17:38:06.548]             list <- base::list
[17:38:06.548]             seq.int <- base::seq.int
[17:38:06.548]             signalCondition <- base::signalCondition
[17:38:06.548]             sys.calls <- base::sys.calls
[17:38:06.548]             `[[` <- base::`[[`
[17:38:06.548]             `+` <- base::`+`
[17:38:06.548]             `<<-` <- base::`<<-`
[17:38:06.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:06.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:06.548]                   3L)]
[17:38:06.548]             }
[17:38:06.548]             function(cond) {
[17:38:06.548]                 is_error <- inherits(cond, "error")
[17:38:06.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:06.548]                   NULL)
[17:38:06.548]                 if (is_error) {
[17:38:06.548]                   sessionInformation <- function() {
[17:38:06.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:06.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:06.548]                       search = base::search(), system = base::Sys.info())
[17:38:06.548]                   }
[17:38:06.548]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:06.548]                     cond$call), session = sessionInformation(), 
[17:38:06.548]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:06.548]                   signalCondition(cond)
[17:38:06.548]                 }
[17:38:06.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:06.548]                 "immediateCondition"))) {
[17:38:06.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:06.548]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:06.548]                   if (TRUE && !signal) {
[17:38:06.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.548]                     {
[17:38:06.548]                       inherits <- base::inherits
[17:38:06.548]                       invokeRestart <- base::invokeRestart
[17:38:06.548]                       is.null <- base::is.null
[17:38:06.548]                       muffled <- FALSE
[17:38:06.548]                       if (inherits(cond, "message")) {
[17:38:06.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.548]                         if (muffled) 
[17:38:06.548]                           invokeRestart("muffleMessage")
[17:38:06.548]                       }
[17:38:06.548]                       else if (inherits(cond, "warning")) {
[17:38:06.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.548]                         if (muffled) 
[17:38:06.548]                           invokeRestart("muffleWarning")
[17:38:06.548]                       }
[17:38:06.548]                       else if (inherits(cond, "condition")) {
[17:38:06.548]                         if (!is.null(pattern)) {
[17:38:06.548]                           computeRestarts <- base::computeRestarts
[17:38:06.548]                           grepl <- base::grepl
[17:38:06.548]                           restarts <- computeRestarts(cond)
[17:38:06.548]                           for (restart in restarts) {
[17:38:06.548]                             name <- restart$name
[17:38:06.548]                             if (is.null(name)) 
[17:38:06.548]                               next
[17:38:06.548]                             if (!grepl(pattern, name)) 
[17:38:06.548]                               next
[17:38:06.548]                             invokeRestart(restart)
[17:38:06.548]                             muffled <- TRUE
[17:38:06.548]                             break
[17:38:06.548]                           }
[17:38:06.548]                         }
[17:38:06.548]                       }
[17:38:06.548]                       invisible(muffled)
[17:38:06.548]                     }
[17:38:06.548]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.548]                   }
[17:38:06.548]                 }
[17:38:06.548]                 else {
[17:38:06.548]                   if (TRUE) {
[17:38:06.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.548]                     {
[17:38:06.548]                       inherits <- base::inherits
[17:38:06.548]                       invokeRestart <- base::invokeRestart
[17:38:06.548]                       is.null <- base::is.null
[17:38:06.548]                       muffled <- FALSE
[17:38:06.548]                       if (inherits(cond, "message")) {
[17:38:06.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.548]                         if (muffled) 
[17:38:06.548]                           invokeRestart("muffleMessage")
[17:38:06.548]                       }
[17:38:06.548]                       else if (inherits(cond, "warning")) {
[17:38:06.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.548]                         if (muffled) 
[17:38:06.548]                           invokeRestart("muffleWarning")
[17:38:06.548]                       }
[17:38:06.548]                       else if (inherits(cond, "condition")) {
[17:38:06.548]                         if (!is.null(pattern)) {
[17:38:06.548]                           computeRestarts <- base::computeRestarts
[17:38:06.548]                           grepl <- base::grepl
[17:38:06.548]                           restarts <- computeRestarts(cond)
[17:38:06.548]                           for (restart in restarts) {
[17:38:06.548]                             name <- restart$name
[17:38:06.548]                             if (is.null(name)) 
[17:38:06.548]                               next
[17:38:06.548]                             if (!grepl(pattern, name)) 
[17:38:06.548]                               next
[17:38:06.548]                             invokeRestart(restart)
[17:38:06.548]                             muffled <- TRUE
[17:38:06.548]                             break
[17:38:06.548]                           }
[17:38:06.548]                         }
[17:38:06.548]                       }
[17:38:06.548]                       invisible(muffled)
[17:38:06.548]                     }
[17:38:06.548]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.548]                   }
[17:38:06.548]                 }
[17:38:06.548]             }
[17:38:06.548]         }))
[17:38:06.548]     }, error = function(ex) {
[17:38:06.548]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:06.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.548]                 ...future.rng), started = ...future.startTime, 
[17:38:06.548]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:06.548]             version = "1.8"), class = "FutureResult")
[17:38:06.548]     }, finally = {
[17:38:06.548]         if (!identical(...future.workdir, getwd())) 
[17:38:06.548]             setwd(...future.workdir)
[17:38:06.548]         {
[17:38:06.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:06.548]                 ...future.oldOptions$nwarnings <- NULL
[17:38:06.548]             }
[17:38:06.548]             base::options(...future.oldOptions)
[17:38:06.548]             if (.Platform$OS.type == "windows") {
[17:38:06.548]                 old_names <- names(...future.oldEnvVars)
[17:38:06.548]                 envs <- base::Sys.getenv()
[17:38:06.548]                 names <- names(envs)
[17:38:06.548]                 common <- intersect(names, old_names)
[17:38:06.548]                 added <- setdiff(names, old_names)
[17:38:06.548]                 removed <- setdiff(old_names, names)
[17:38:06.548]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:06.548]                   envs[common]]
[17:38:06.548]                 NAMES <- toupper(changed)
[17:38:06.548]                 args <- list()
[17:38:06.548]                 for (kk in seq_along(NAMES)) {
[17:38:06.548]                   name <- changed[[kk]]
[17:38:06.548]                   NAME <- NAMES[[kk]]
[17:38:06.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.548]                     next
[17:38:06.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.548]                 }
[17:38:06.548]                 NAMES <- toupper(added)
[17:38:06.548]                 for (kk in seq_along(NAMES)) {
[17:38:06.548]                   name <- added[[kk]]
[17:38:06.548]                   NAME <- NAMES[[kk]]
[17:38:06.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.548]                     next
[17:38:06.548]                   args[[name]] <- ""
[17:38:06.548]                 }
[17:38:06.548]                 NAMES <- toupper(removed)
[17:38:06.548]                 for (kk in seq_along(NAMES)) {
[17:38:06.548]                   name <- removed[[kk]]
[17:38:06.548]                   NAME <- NAMES[[kk]]
[17:38:06.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.548]                     next
[17:38:06.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.548]                 }
[17:38:06.548]                 if (length(args) > 0) 
[17:38:06.548]                   base::do.call(base::Sys.setenv, args = args)
[17:38:06.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:06.548]             }
[17:38:06.548]             else {
[17:38:06.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:06.548]             }
[17:38:06.548]             {
[17:38:06.548]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:06.548]                   0L) {
[17:38:06.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:06.548]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:06.548]                   base::options(opts)
[17:38:06.548]                 }
[17:38:06.548]                 {
[17:38:06.548]                   {
[17:38:06.548]                     NULL
[17:38:06.548]                     RNGkind("Mersenne-Twister")
[17:38:06.548]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:06.548]                       inherits = FALSE)
[17:38:06.548]                   }
[17:38:06.548]                   options(future.plan = NULL)
[17:38:06.548]                   if (is.na(NA_character_)) 
[17:38:06.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:06.548]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:06.548]                     .init = FALSE)
[17:38:06.548]                 }
[17:38:06.548]             }
[17:38:06.548]         }
[17:38:06.548]     })
[17:38:06.548]     if (TRUE) {
[17:38:06.548]         base::sink(type = "output", split = FALSE)
[17:38:06.548]         if (TRUE) {
[17:38:06.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:06.548]         }
[17:38:06.548]         else {
[17:38:06.548]             ...future.result["stdout"] <- base::list(NULL)
[17:38:06.548]         }
[17:38:06.548]         base::close(...future.stdout)
[17:38:06.548]         ...future.stdout <- NULL
[17:38:06.548]     }
[17:38:06.548]     ...future.result$conditions <- ...future.conditions
[17:38:06.548]     ...future.result$finished <- base::Sys.time()
[17:38:06.548]     ...future.result
[17:38:06.548] }
[17:38:06.550] assign_globals() ...
[17:38:06.550] List of 11
[17:38:06.550]  $ ...future.FUN            :function (x, ...)  
[17:38:06.550]  $ x_FUN                    :function (x)  
[17:38:06.550]  $ times                    : int 1
[17:38:06.550]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.550]  $ stop_if_not              :function (...)  
[17:38:06.550]  $ dim                      : NULL
[17:38:06.550]  $ valid_types              : chr "character"
[17:38:06.550]  $ future.call.arguments    : list()
[17:38:06.550]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.550]  $ ...future.elements_ii    :List of 2
[17:38:06.550]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:38:06.550]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[17:38:06.550]  $ ...future.seeds_ii       : NULL
[17:38:06.550]  $ ...future.globals.maxSize: NULL
[17:38:06.550]  - attr(*, "where")=List of 11
[17:38:06.550]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:06.550]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:06.550]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:06.550]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:06.550]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:06.550]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:06.550]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:06.550]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:06.550]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:06.550]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:06.550]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:06.550]  - attr(*, "resolved")= logi FALSE
[17:38:06.550]  - attr(*, "total_size")= num 94208
[17:38:06.550]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.550]  - attr(*, "already-done")= logi TRUE
[17:38:06.558] - copied ‘...future.FUN’ to environment
[17:38:06.558] - copied ‘x_FUN’ to environment
[17:38:06.558] - copied ‘times’ to environment
[17:38:06.558] - copied ‘stopf’ to environment
[17:38:06.558] - copied ‘stop_if_not’ to environment
[17:38:06.558] - copied ‘dim’ to environment
[17:38:06.558] - copied ‘valid_types’ to environment
[17:38:06.558] - copied ‘future.call.arguments’ to environment
[17:38:06.558] - copied ‘...future.elements_ii’ to environment
[17:38:06.559] - copied ‘...future.seeds_ii’ to environment
[17:38:06.559] - copied ‘...future.globals.maxSize’ to environment
[17:38:06.559] assign_globals() ... done
[17:38:06.559] plan(): Setting new future strategy stack:
[17:38:06.559] List of future strategies:
[17:38:06.559] 1. sequential:
[17:38:06.559]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.559]    - tweaked: FALSE
[17:38:06.559]    - call: NULL
[17:38:06.560] plan(): nbrOfWorkers() = 1
[17:38:06.561] plan(): Setting new future strategy stack:
[17:38:06.561] List of future strategies:
[17:38:06.561] 1. sequential:
[17:38:06.561]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.561]    - tweaked: FALSE
[17:38:06.561]    - call: plan(strategy)
[17:38:06.562] plan(): nbrOfWorkers() = 1
[17:38:06.562] SequentialFuture started (and completed)
[17:38:06.562] - Launch lazy future ... done
[17:38:06.562] run() for ‘SequentialFuture’ ... done
[17:38:06.562] Created future:
[17:38:06.562] SequentialFuture:
[17:38:06.562] Label: ‘future_vapply-1’
[17:38:06.562] Expression:
[17:38:06.562] {
[17:38:06.562]     do.call(function(...) {
[17:38:06.562]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.562]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.562]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.562]             on.exit(options(oopts), add = TRUE)
[17:38:06.562]         }
[17:38:06.562]         {
[17:38:06.562]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.562]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.562]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.562]             })
[17:38:06.562]         }
[17:38:06.562]     }, args = future.call.arguments)
[17:38:06.562] }
[17:38:06.562] Lazy evaluation: FALSE
[17:38:06.562] Asynchronous evaluation: FALSE
[17:38:06.562] Local evaluation: TRUE
[17:38:06.562] Environment: R_GlobalEnv
[17:38:06.562] Capture standard output: TRUE
[17:38:06.562] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:06.562] Globals: 11 objects totaling 92.81 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:06.562] Packages: 1 packages (‘future.apply’)
[17:38:06.562] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:06.562] Resolved: TRUE
[17:38:06.562] Value: 232 bytes of class ‘list’
[17:38:06.562] Early signaling: FALSE
[17:38:06.562] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:06.562] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.564] Chunk #1 of 1 ... DONE
[17:38:06.564] Launching 1 futures (chunks) ... DONE
[17:38:06.564] Resolving 1 futures (chunks) ...
[17:38:06.564] resolve() on list ...
[17:38:06.565]  recursive: 0
[17:38:06.565]  length: 1
[17:38:06.565] 
[17:38:06.565] resolved() for ‘SequentialFuture’ ...
[17:38:06.565] - state: ‘finished’
[17:38:06.565] - run: TRUE
[17:38:06.565] - result: ‘FutureResult’
[17:38:06.565] resolved() for ‘SequentialFuture’ ... done
[17:38:06.565] Future #1
[17:38:06.566] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:06.566] - nx: 1
[17:38:06.566] - relay: TRUE
[17:38:06.566] - stdout: TRUE
[17:38:06.566] - signal: TRUE
[17:38:06.566] - resignal: FALSE
[17:38:06.566] - force: TRUE
[17:38:06.566] - relayed: [n=1] FALSE
[17:38:06.566] - queued futures: [n=1] FALSE
[17:38:06.567]  - until=1
[17:38:06.567]  - relaying element #1
[17:38:06.567] - relayed: [n=1] TRUE
[17:38:06.567] - queued futures: [n=1] TRUE
[17:38:06.567] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:06.567]  length: 0 (resolved future 1)
[17:38:06.567] Relaying remaining futures
[17:38:06.567] signalConditionsASAP(NULL, pos=0) ...
[17:38:06.567] - nx: 1
[17:38:06.568] - relay: TRUE
[17:38:06.568] - stdout: TRUE
[17:38:06.568] - signal: TRUE
[17:38:06.568] - resignal: FALSE
[17:38:06.568] - force: TRUE
[17:38:06.568] - relayed: [n=1] TRUE
[17:38:06.568] - queued futures: [n=1] TRUE
 - flush all
[17:38:06.568] - relayed: [n=1] TRUE
[17:38:06.568] - queued futures: [n=1] TRUE
[17:38:06.568] signalConditionsASAP(NULL, pos=0) ... done
[17:38:06.569] resolve() on list ... DONE
[17:38:06.569]  - Number of value chunks collected: 1
[17:38:06.569] Resolving 1 futures (chunks) ... DONE
[17:38:06.569] Reducing values from 1 chunks ...
[17:38:06.569]  - Number of values collected after concatenation: 2
[17:38:06.569]  - Number of values expected: 2
[17:38:06.569] Reducing values from 1 chunks ... DONE
[17:38:06.569] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[17:38:06.570] future_lapply() ...
[17:38:06.572] Number of chunks: 1
[17:38:06.572] getGlobalsAndPackagesXApply() ...
[17:38:06.572]  - future.globals: TRUE
[17:38:06.572] getGlobalsAndPackages() ...
[17:38:06.572] Searching for globals...
[17:38:06.578] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[17:38:06.578] Searching for globals ... DONE
[17:38:06.578] Resolving globals: FALSE
[17:38:06.579] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[17:38:06.579] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:06.579] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.579] - packages: [1] ‘future.apply’
[17:38:06.579] getGlobalsAndPackages() ... DONE
[17:38:06.579]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.580]  - needed namespaces: [n=1] ‘future.apply’
[17:38:06.580] Finding globals ... DONE
[17:38:06.580]  - use_args: TRUE
[17:38:06.580]  - Getting '...' globals ...
[17:38:06.580] resolve() on list ...
[17:38:06.580]  recursive: 0
[17:38:06.580]  length: 1
[17:38:06.580]  elements: ‘...’
[17:38:06.581]  length: 0 (resolved future 1)
[17:38:06.581] resolve() on list ... DONE
[17:38:06.581]    - '...' content: [n=0] 
[17:38:06.581] List of 1
[17:38:06.581]  $ ...: list()
[17:38:06.581]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.581]  - attr(*, "where")=List of 1
[17:38:06.581]   ..$ ...:<environment: 0x560801b2f730> 
[17:38:06.581]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.581]  - attr(*, "resolved")= logi TRUE
[17:38:06.581]  - attr(*, "total_size")= num NA
[17:38:06.583]  - Getting '...' globals ... DONE
[17:38:06.583] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:06.584] List of 8
[17:38:06.584]  $ ...future.FUN:function (x, ...)  
[17:38:06.584]  $ x_FUN        :function (x)  
[17:38:06.584]  $ times        : int 0
[17:38:06.584]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.584]  $ stop_if_not  :function (...)  
[17:38:06.584]  $ dim          : NULL
[17:38:06.584]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:06.584]  $ ...          : list()
[17:38:06.584]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.584]  - attr(*, "where")=List of 8
[17:38:06.584]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:06.584]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:06.584]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:06.584]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:06.584]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:06.584]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:06.584]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:06.584]   ..$ ...          :<environment: 0x560801b2f730> 
[17:38:06.584]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.584]  - attr(*, "resolved")= logi FALSE
[17:38:06.584]  - attr(*, "total_size")= num 95472
[17:38:06.589] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:06.589] getGlobalsAndPackagesXApply() ... DONE
[17:38:06.589] Number of futures (= number of chunks): 1
[17:38:06.589] Launching 1 futures (chunks) ...
[17:38:06.589] Chunk #1 of 1 ...
[17:38:06.589]  - Finding globals in 'X' for chunk #1 ...
[17:38:06.590] getGlobalsAndPackages() ...
[17:38:06.590] Searching for globals...
[17:38:06.590] 
[17:38:06.590] Searching for globals ... DONE
[17:38:06.590] - globals: [0] <none>
[17:38:06.590] getGlobalsAndPackages() ... DONE
[17:38:06.590]    + additional globals found: [n=0] 
[17:38:06.590]    + additional namespaces needed: [n=0] 
[17:38:06.590]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:06.590]  - seeds: <none>
[17:38:06.591]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.591] getGlobalsAndPackages() ...
[17:38:06.591] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.591] Resolving globals: FALSE
[17:38:06.591] Tweak future expression to call with '...' arguments ...
[17:38:06.591] {
[17:38:06.591]     do.call(function(...) {
[17:38:06.591]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.591]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.591]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.591]             on.exit(options(oopts), add = TRUE)
[17:38:06.591]         }
[17:38:06.591]         {
[17:38:06.591]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.591]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.591]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.591]             })
[17:38:06.591]         }
[17:38:06.591]     }, args = future.call.arguments)
[17:38:06.591] }
[17:38:06.591] Tweak future expression to call with '...' arguments ... DONE
[17:38:06.592] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.592] - packages: [1] ‘future.apply’
[17:38:06.592] getGlobalsAndPackages() ... DONE
[17:38:06.592] run() for ‘Future’ ...
[17:38:06.592] - state: ‘created’
[17:38:06.593] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:06.593] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.593] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:06.593]   - Field: ‘label’
[17:38:06.593]   - Field: ‘local’
[17:38:06.593]   - Field: ‘owner’
[17:38:06.593]   - Field: ‘envir’
[17:38:06.593]   - Field: ‘packages’
[17:38:06.594]   - Field: ‘gc’
[17:38:06.594]   - Field: ‘conditions’
[17:38:06.594]   - Field: ‘expr’
[17:38:06.594]   - Field: ‘uuid’
[17:38:06.594]   - Field: ‘seed’
[17:38:06.594]   - Field: ‘version’
[17:38:06.594]   - Field: ‘result’
[17:38:06.594]   - Field: ‘asynchronous’
[17:38:06.594]   - Field: ‘calls’
[17:38:06.594]   - Field: ‘globals’
[17:38:06.594]   - Field: ‘stdout’
[17:38:06.595]   - Field: ‘earlySignal’
[17:38:06.595]   - Field: ‘lazy’
[17:38:06.595]   - Field: ‘state’
[17:38:06.595] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:06.595] - Launch lazy future ...
[17:38:06.595] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:06.595] Packages needed by future strategies (n = 0): <none>
[17:38:06.596] {
[17:38:06.596]     {
[17:38:06.596]         {
[17:38:06.596]             ...future.startTime <- base::Sys.time()
[17:38:06.596]             {
[17:38:06.596]                 {
[17:38:06.596]                   {
[17:38:06.596]                     {
[17:38:06.596]                       base::local({
[17:38:06.596]                         has_future <- base::requireNamespace("future", 
[17:38:06.596]                           quietly = TRUE)
[17:38:06.596]                         if (has_future) {
[17:38:06.596]                           ns <- base::getNamespace("future")
[17:38:06.596]                           version <- ns[[".package"]][["version"]]
[17:38:06.596]                           if (is.null(version)) 
[17:38:06.596]                             version <- utils::packageVersion("future")
[17:38:06.596]                         }
[17:38:06.596]                         else {
[17:38:06.596]                           version <- NULL
[17:38:06.596]                         }
[17:38:06.596]                         if (!has_future || version < "1.8.0") {
[17:38:06.596]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:06.596]                             "", base::R.version$version.string), 
[17:38:06.596]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:06.596]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:06.596]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:06.596]                               "release", "version")], collapse = " "), 
[17:38:06.596]                             hostname = base::Sys.info()[["nodename"]])
[17:38:06.596]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:06.596]                             info)
[17:38:06.596]                           info <- base::paste(info, collapse = "; ")
[17:38:06.596]                           if (!has_future) {
[17:38:06.596]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:06.596]                               info)
[17:38:06.596]                           }
[17:38:06.596]                           else {
[17:38:06.596]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:06.596]                               info, version)
[17:38:06.596]                           }
[17:38:06.596]                           base::stop(msg)
[17:38:06.596]                         }
[17:38:06.596]                       })
[17:38:06.596]                     }
[17:38:06.596]                     base::local({
[17:38:06.596]                       for (pkg in "future.apply") {
[17:38:06.596]                         base::loadNamespace(pkg)
[17:38:06.596]                         base::library(pkg, character.only = TRUE)
[17:38:06.596]                       }
[17:38:06.596]                     })
[17:38:06.596]                   }
[17:38:06.596]                   ...future.strategy.old <- future::plan("list")
[17:38:06.596]                   options(future.plan = NULL)
[17:38:06.596]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.596]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:06.596]                 }
[17:38:06.596]                 ...future.workdir <- getwd()
[17:38:06.596]             }
[17:38:06.596]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:06.596]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:06.596]         }
[17:38:06.596]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:06.596]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:06.596]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:06.596]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:06.596]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:06.596]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:06.596]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:06.596]             base::names(...future.oldOptions))
[17:38:06.596]     }
[17:38:06.596]     if (FALSE) {
[17:38:06.596]     }
[17:38:06.596]     else {
[17:38:06.596]         if (TRUE) {
[17:38:06.596]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:06.596]                 open = "w")
[17:38:06.596]         }
[17:38:06.596]         else {
[17:38:06.596]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:06.596]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:06.596]         }
[17:38:06.596]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:06.596]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:06.596]             base::sink(type = "output", split = FALSE)
[17:38:06.596]             base::close(...future.stdout)
[17:38:06.596]         }, add = TRUE)
[17:38:06.596]     }
[17:38:06.596]     ...future.frame <- base::sys.nframe()
[17:38:06.596]     ...future.conditions <- base::list()
[17:38:06.596]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:06.596]     if (FALSE) {
[17:38:06.596]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:06.596]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:06.596]     }
[17:38:06.596]     ...future.result <- base::tryCatch({
[17:38:06.596]         base::withCallingHandlers({
[17:38:06.596]             ...future.value <- base::withVisible(base::local({
[17:38:06.596]                 do.call(function(...) {
[17:38:06.596]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.596]                   if (!identical(...future.globals.maxSize.org, 
[17:38:06.596]                     ...future.globals.maxSize)) {
[17:38:06.596]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.596]                     on.exit(options(oopts), add = TRUE)
[17:38:06.596]                   }
[17:38:06.596]                   {
[17:38:06.596]                     lapply(seq_along(...future.elements_ii), 
[17:38:06.596]                       FUN = function(jj) {
[17:38:06.596]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.596]                         ...future.FUN(...future.X_jj, ...)
[17:38:06.596]                       })
[17:38:06.596]                   }
[17:38:06.596]                 }, args = future.call.arguments)
[17:38:06.596]             }))
[17:38:06.596]             future::FutureResult(value = ...future.value$value, 
[17:38:06.596]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.596]                   ...future.rng), globalenv = if (FALSE) 
[17:38:06.596]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:06.596]                     ...future.globalenv.names))
[17:38:06.596]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:06.596]         }, condition = base::local({
[17:38:06.596]             c <- base::c
[17:38:06.596]             inherits <- base::inherits
[17:38:06.596]             invokeRestart <- base::invokeRestart
[17:38:06.596]             length <- base::length
[17:38:06.596]             list <- base::list
[17:38:06.596]             seq.int <- base::seq.int
[17:38:06.596]             signalCondition <- base::signalCondition
[17:38:06.596]             sys.calls <- base::sys.calls
[17:38:06.596]             `[[` <- base::`[[`
[17:38:06.596]             `+` <- base::`+`
[17:38:06.596]             `<<-` <- base::`<<-`
[17:38:06.596]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:06.596]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:06.596]                   3L)]
[17:38:06.596]             }
[17:38:06.596]             function(cond) {
[17:38:06.596]                 is_error <- inherits(cond, "error")
[17:38:06.596]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:06.596]                   NULL)
[17:38:06.596]                 if (is_error) {
[17:38:06.596]                   sessionInformation <- function() {
[17:38:06.596]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:06.596]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:06.596]                       search = base::search(), system = base::Sys.info())
[17:38:06.596]                   }
[17:38:06.596]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.596]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:06.596]                     cond$call), session = sessionInformation(), 
[17:38:06.596]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:06.596]                   signalCondition(cond)
[17:38:06.596]                 }
[17:38:06.596]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:06.596]                 "immediateCondition"))) {
[17:38:06.596]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:06.596]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.596]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:06.596]                   if (TRUE && !signal) {
[17:38:06.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.596]                     {
[17:38:06.596]                       inherits <- base::inherits
[17:38:06.596]                       invokeRestart <- base::invokeRestart
[17:38:06.596]                       is.null <- base::is.null
[17:38:06.596]                       muffled <- FALSE
[17:38:06.596]                       if (inherits(cond, "message")) {
[17:38:06.596]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.596]                         if (muffled) 
[17:38:06.596]                           invokeRestart("muffleMessage")
[17:38:06.596]                       }
[17:38:06.596]                       else if (inherits(cond, "warning")) {
[17:38:06.596]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.596]                         if (muffled) 
[17:38:06.596]                           invokeRestart("muffleWarning")
[17:38:06.596]                       }
[17:38:06.596]                       else if (inherits(cond, "condition")) {
[17:38:06.596]                         if (!is.null(pattern)) {
[17:38:06.596]                           computeRestarts <- base::computeRestarts
[17:38:06.596]                           grepl <- base::grepl
[17:38:06.596]                           restarts <- computeRestarts(cond)
[17:38:06.596]                           for (restart in restarts) {
[17:38:06.596]                             name <- restart$name
[17:38:06.596]                             if (is.null(name)) 
[17:38:06.596]                               next
[17:38:06.596]                             if (!grepl(pattern, name)) 
[17:38:06.596]                               next
[17:38:06.596]                             invokeRestart(restart)
[17:38:06.596]                             muffled <- TRUE
[17:38:06.596]                             break
[17:38:06.596]                           }
[17:38:06.596]                         }
[17:38:06.596]                       }
[17:38:06.596]                       invisible(muffled)
[17:38:06.596]                     }
[17:38:06.596]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.596]                   }
[17:38:06.596]                 }
[17:38:06.596]                 else {
[17:38:06.596]                   if (TRUE) {
[17:38:06.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.596]                     {
[17:38:06.596]                       inherits <- base::inherits
[17:38:06.596]                       invokeRestart <- base::invokeRestart
[17:38:06.596]                       is.null <- base::is.null
[17:38:06.596]                       muffled <- FALSE
[17:38:06.596]                       if (inherits(cond, "message")) {
[17:38:06.596]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.596]                         if (muffled) 
[17:38:06.596]                           invokeRestart("muffleMessage")
[17:38:06.596]                       }
[17:38:06.596]                       else if (inherits(cond, "warning")) {
[17:38:06.596]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.596]                         if (muffled) 
[17:38:06.596]                           invokeRestart("muffleWarning")
[17:38:06.596]                       }
[17:38:06.596]                       else if (inherits(cond, "condition")) {
[17:38:06.596]                         if (!is.null(pattern)) {
[17:38:06.596]                           computeRestarts <- base::computeRestarts
[17:38:06.596]                           grepl <- base::grepl
[17:38:06.596]                           restarts <- computeRestarts(cond)
[17:38:06.596]                           for (restart in restarts) {
[17:38:06.596]                             name <- restart$name
[17:38:06.596]                             if (is.null(name)) 
[17:38:06.596]                               next
[17:38:06.596]                             if (!grepl(pattern, name)) 
[17:38:06.596]                               next
[17:38:06.596]                             invokeRestart(restart)
[17:38:06.596]                             muffled <- TRUE
[17:38:06.596]                             break
[17:38:06.596]                           }
[17:38:06.596]                         }
[17:38:06.596]                       }
[17:38:06.596]                       invisible(muffled)
[17:38:06.596]                     }
[17:38:06.596]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.596]                   }
[17:38:06.596]                 }
[17:38:06.596]             }
[17:38:06.596]         }))
[17:38:06.596]     }, error = function(ex) {
[17:38:06.596]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:06.596]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.596]                 ...future.rng), started = ...future.startTime, 
[17:38:06.596]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:06.596]             version = "1.8"), class = "FutureResult")
[17:38:06.596]     }, finally = {
[17:38:06.596]         if (!identical(...future.workdir, getwd())) 
[17:38:06.596]             setwd(...future.workdir)
[17:38:06.596]         {
[17:38:06.596]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:06.596]                 ...future.oldOptions$nwarnings <- NULL
[17:38:06.596]             }
[17:38:06.596]             base::options(...future.oldOptions)
[17:38:06.596]             if (.Platform$OS.type == "windows") {
[17:38:06.596]                 old_names <- names(...future.oldEnvVars)
[17:38:06.596]                 envs <- base::Sys.getenv()
[17:38:06.596]                 names <- names(envs)
[17:38:06.596]                 common <- intersect(names, old_names)
[17:38:06.596]                 added <- setdiff(names, old_names)
[17:38:06.596]                 removed <- setdiff(old_names, names)
[17:38:06.596]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:06.596]                   envs[common]]
[17:38:06.596]                 NAMES <- toupper(changed)
[17:38:06.596]                 args <- list()
[17:38:06.596]                 for (kk in seq_along(NAMES)) {
[17:38:06.596]                   name <- changed[[kk]]
[17:38:06.596]                   NAME <- NAMES[[kk]]
[17:38:06.596]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.596]                     next
[17:38:06.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.596]                 }
[17:38:06.596]                 NAMES <- toupper(added)
[17:38:06.596]                 for (kk in seq_along(NAMES)) {
[17:38:06.596]                   name <- added[[kk]]
[17:38:06.596]                   NAME <- NAMES[[kk]]
[17:38:06.596]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.596]                     next
[17:38:06.596]                   args[[name]] <- ""
[17:38:06.596]                 }
[17:38:06.596]                 NAMES <- toupper(removed)
[17:38:06.596]                 for (kk in seq_along(NAMES)) {
[17:38:06.596]                   name <- removed[[kk]]
[17:38:06.596]                   NAME <- NAMES[[kk]]
[17:38:06.596]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.596]                     next
[17:38:06.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.596]                 }
[17:38:06.596]                 if (length(args) > 0) 
[17:38:06.596]                   base::do.call(base::Sys.setenv, args = args)
[17:38:06.596]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:06.596]             }
[17:38:06.596]             else {
[17:38:06.596]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:06.596]             }
[17:38:06.596]             {
[17:38:06.596]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:06.596]                   0L) {
[17:38:06.596]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:06.596]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:06.596]                   base::options(opts)
[17:38:06.596]                 }
[17:38:06.596]                 {
[17:38:06.596]                   {
[17:38:06.596]                     NULL
[17:38:06.596]                     RNGkind("Mersenne-Twister")
[17:38:06.596]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:06.596]                       inherits = FALSE)
[17:38:06.596]                   }
[17:38:06.596]                   options(future.plan = NULL)
[17:38:06.596]                   if (is.na(NA_character_)) 
[17:38:06.596]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.596]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:06.596]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:06.596]                     .init = FALSE)
[17:38:06.596]                 }
[17:38:06.596]             }
[17:38:06.596]         }
[17:38:06.596]     })
[17:38:06.596]     if (TRUE) {
[17:38:06.596]         base::sink(type = "output", split = FALSE)
[17:38:06.596]         if (TRUE) {
[17:38:06.596]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:06.596]         }
[17:38:06.596]         else {
[17:38:06.596]             ...future.result["stdout"] <- base::list(NULL)
[17:38:06.596]         }
[17:38:06.596]         base::close(...future.stdout)
[17:38:06.596]         ...future.stdout <- NULL
[17:38:06.596]     }
[17:38:06.596]     ...future.result$conditions <- ...future.conditions
[17:38:06.596]     ...future.result$finished <- base::Sys.time()
[17:38:06.596]     ...future.result
[17:38:06.596] }
[17:38:06.597] assign_globals() ...
[17:38:06.597] List of 11
[17:38:06.597]  $ ...future.FUN            :function (x, ...)  
[17:38:06.597]  $ x_FUN                    :function (x)  
[17:38:06.597]  $ times                    : int 0
[17:38:06.597]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.597]  $ stop_if_not              :function (...)  
[17:38:06.597]  $ dim                      : NULL
[17:38:06.597]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:06.597]  $ future.call.arguments    : list()
[17:38:06.597]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.597]  $ ...future.elements_ii    :List of 10
[17:38:06.597]   ..$ : int 1
[17:38:06.597]   ..$ : int 2
[17:38:06.597]   ..$ : int 3
[17:38:06.597]   ..$ : int 4
[17:38:06.597]   ..$ : int 5
[17:38:06.597]   ..$ : int 6
[17:38:06.597]   ..$ : int 7
[17:38:06.597]   ..$ : int 8
[17:38:06.597]   ..$ : int 9
[17:38:06.597]   ..$ : int 10
[17:38:06.597]  $ ...future.seeds_ii       : NULL
[17:38:06.597]  $ ...future.globals.maxSize: NULL
[17:38:06.597]  - attr(*, "where")=List of 11
[17:38:06.597]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:06.597]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:06.597]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:06.597]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:06.597]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:06.597]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:06.597]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:06.597]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:06.597]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:06.597]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:06.597]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:06.597]  - attr(*, "resolved")= logi FALSE
[17:38:06.597]  - attr(*, "total_size")= num 95472
[17:38:06.597]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.597]  - attr(*, "already-done")= logi TRUE
[17:38:06.609] - copied ‘...future.FUN’ to environment
[17:38:06.609] - reassign environment for ‘x_FUN’
[17:38:06.609] - copied ‘x_FUN’ to environment
[17:38:06.609] - copied ‘times’ to environment
[17:38:06.609] - copied ‘stopf’ to environment
[17:38:06.609] - copied ‘stop_if_not’ to environment
[17:38:06.609] - copied ‘dim’ to environment
[17:38:06.609] - copied ‘valid_types’ to environment
[17:38:06.609] - copied ‘future.call.arguments’ to environment
[17:38:06.609] - copied ‘...future.elements_ii’ to environment
[17:38:06.610] - copied ‘...future.seeds_ii’ to environment
[17:38:06.610] - copied ‘...future.globals.maxSize’ to environment
[17:38:06.610] assign_globals() ... done
[17:38:06.610] plan(): Setting new future strategy stack:
[17:38:06.610] List of future strategies:
[17:38:06.610] 1. sequential:
[17:38:06.610]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.610]    - tweaked: FALSE
[17:38:06.610]    - call: NULL
[17:38:06.611] plan(): nbrOfWorkers() = 1
[17:38:06.611] plan(): Setting new future strategy stack:
[17:38:06.612] List of future strategies:
[17:38:06.612] 1. sequential:
[17:38:06.612]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.612]    - tweaked: FALSE
[17:38:06.612]    - call: plan(strategy)
[17:38:06.612] plan(): nbrOfWorkers() = 1
[17:38:06.612] SequentialFuture started (and completed)
[17:38:06.612] - Launch lazy future ... done
[17:38:06.612] run() for ‘SequentialFuture’ ... done
[17:38:06.612] Created future:
[17:38:06.613] SequentialFuture:
[17:38:06.613] Label: ‘future_vapply-1’
[17:38:06.613] Expression:
[17:38:06.613] {
[17:38:06.613]     do.call(function(...) {
[17:38:06.613]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.613]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.613]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.613]             on.exit(options(oopts), add = TRUE)
[17:38:06.613]         }
[17:38:06.613]         {
[17:38:06.613]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.613]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.613]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.613]             })
[17:38:06.613]         }
[17:38:06.613]     }, args = future.call.arguments)
[17:38:06.613] }
[17:38:06.613] Lazy evaluation: FALSE
[17:38:06.613] Asynchronous evaluation: FALSE
[17:38:06.613] Local evaluation: TRUE
[17:38:06.613] Environment: R_GlobalEnv
[17:38:06.613] Capture standard output: TRUE
[17:38:06.613] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:06.613] Globals: 11 objects totaling 93.78 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:06.613] Packages: 1 packages (‘future.apply’)
[17:38:06.613] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:06.613] Resolved: TRUE
[17:38:06.613] Value: 480 bytes of class ‘list’
[17:38:06.613] Early signaling: FALSE
[17:38:06.613] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:06.613] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.614] Chunk #1 of 1 ... DONE
[17:38:06.614] Launching 1 futures (chunks) ... DONE
[17:38:06.614] Resolving 1 futures (chunks) ...
[17:38:06.614] resolve() on list ...
[17:38:06.614]  recursive: 0
[17:38:06.614]  length: 1
[17:38:06.614] 
[17:38:06.614] resolved() for ‘SequentialFuture’ ...
[17:38:06.614] - state: ‘finished’
[17:38:06.615] - run: TRUE
[17:38:06.615] - result: ‘FutureResult’
[17:38:06.615] resolved() for ‘SequentialFuture’ ... done
[17:38:06.615] Future #1
[17:38:06.615] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:06.615] - nx: 1
[17:38:06.615] - relay: TRUE
[17:38:06.615] - stdout: TRUE
[17:38:06.615] - signal: TRUE
[17:38:06.615] - resignal: FALSE
[17:38:06.615] - force: TRUE
[17:38:06.616] - relayed: [n=1] FALSE
[17:38:06.616] - queued futures: [n=1] FALSE
[17:38:06.616]  - until=1
[17:38:06.616]  - relaying element #1
[17:38:06.616] - relayed: [n=1] TRUE
[17:38:06.616] - queued futures: [n=1] TRUE
[17:38:06.616] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:06.616]  length: 0 (resolved future 1)
[17:38:06.616] Relaying remaining futures
[17:38:06.616] signalConditionsASAP(NULL, pos=0) ...
[17:38:06.617] - nx: 1
[17:38:06.617] - relay: TRUE
[17:38:06.617] - stdout: TRUE
[17:38:06.617] - signal: TRUE
[17:38:06.617] - resignal: FALSE
[17:38:06.617] - force: TRUE
[17:38:06.617] - relayed: [n=1] TRUE
[17:38:06.617] - queued futures: [n=1] TRUE
 - flush all
[17:38:06.617] - relayed: [n=1] TRUE
[17:38:06.617] - queued futures: [n=1] TRUE
[17:38:06.617] signalConditionsASAP(NULL, pos=0) ... done
[17:38:06.618] resolve() on list ... DONE
[17:38:06.618]  - Number of value chunks collected: 1
[17:38:06.618] Resolving 1 futures (chunks) ... DONE
[17:38:06.618] Reducing values from 1 chunks ...
[17:38:06.618]  - Number of values collected after concatenation: 10
[17:38:06.618]  - Number of values expected: 10
[17:38:06.618] Reducing values from 1 chunks ... DONE
[17:38:06.618] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[17:38:06.619] future_lapply() ...
[17:38:06.621] Number of chunks: 1
[17:38:06.621] getGlobalsAndPackagesXApply() ...
[17:38:06.621]  - future.globals: TRUE
[17:38:06.621] getGlobalsAndPackages() ...
[17:38:06.621] Searching for globals...
[17:38:06.626] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[17:38:06.626] Searching for globals ... DONE
[17:38:06.626] Resolving globals: FALSE
[17:38:06.627] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[17:38:06.627] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:06.627] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.628] - packages: [1] ‘future.apply’
[17:38:06.628] getGlobalsAndPackages() ... DONE
[17:38:06.628]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.628]  - needed namespaces: [n=1] ‘future.apply’
[17:38:06.628] Finding globals ... DONE
[17:38:06.628]  - use_args: TRUE
[17:38:06.628]  - Getting '...' globals ...
[17:38:06.628] resolve() on list ...
[17:38:06.628]  recursive: 0
[17:38:06.629]  length: 1
[17:38:06.629]  elements: ‘...’
[17:38:06.629]  length: 0 (resolved future 1)
[17:38:06.629] resolve() on list ... DONE
[17:38:06.629]    - '...' content: [n=0] 
[17:38:06.629] List of 1
[17:38:06.629]  $ ...: list()
[17:38:06.629]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.629]  - attr(*, "where")=List of 1
[17:38:06.629]   ..$ ...:<environment: 0x560801b28f88> 
[17:38:06.629]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.629]  - attr(*, "resolved")= logi TRUE
[17:38:06.629]  - attr(*, "total_size")= num NA
[17:38:06.631]  - Getting '...' globals ... DONE
[17:38:06.632] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:06.632] List of 8
[17:38:06.632]  $ ...future.FUN:function (x, ...)  
[17:38:06.632]  $ x_FUN        :function (x)  
[17:38:06.632]  $ times        : int 0
[17:38:06.632]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.632]  $ stop_if_not  :function (...)  
[17:38:06.632]  $ dim          : NULL
[17:38:06.632]  $ valid_types  : chr [1:2] "logical" "integer"
[17:38:06.632]  $ ...          : list()
[17:38:06.632]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.632]  - attr(*, "where")=List of 8
[17:38:06.632]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:06.632]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:06.632]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:06.632]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:06.632]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:06.632]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:06.632]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:06.632]   ..$ ...          :<environment: 0x560801b28f88> 
[17:38:06.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.632]  - attr(*, "resolved")= logi FALSE
[17:38:06.632]  - attr(*, "total_size")= num 95400
[17:38:06.637] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:06.637] getGlobalsAndPackagesXApply() ... DONE
[17:38:06.637] Number of futures (= number of chunks): 1
[17:38:06.637] Launching 1 futures (chunks) ...
[17:38:06.637] Chunk #1 of 1 ...
[17:38:06.637]  - Finding globals in 'X' for chunk #1 ...
[17:38:06.637] getGlobalsAndPackages() ...
[17:38:06.638] Searching for globals...
[17:38:06.638] 
[17:38:06.638] Searching for globals ... DONE
[17:38:06.638] - globals: [0] <none>
[17:38:06.638] getGlobalsAndPackages() ... DONE
[17:38:06.638]    + additional globals found: [n=0] 
[17:38:06.638]    + additional namespaces needed: [n=0] 
[17:38:06.638]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:06.638]  - seeds: <none>
[17:38:06.638]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.639] getGlobalsAndPackages() ...
[17:38:06.639] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.639] Resolving globals: FALSE
[17:38:06.639] Tweak future expression to call with '...' arguments ...
[17:38:06.639] {
[17:38:06.639]     do.call(function(...) {
[17:38:06.639]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.639]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.639]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.639]             on.exit(options(oopts), add = TRUE)
[17:38:06.639]         }
[17:38:06.639]         {
[17:38:06.639]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.639]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.639]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.639]             })
[17:38:06.639]         }
[17:38:06.639]     }, args = future.call.arguments)
[17:38:06.639] }
[17:38:06.639] Tweak future expression to call with '...' arguments ... DONE
[17:38:06.640] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.640] - packages: [1] ‘future.apply’
[17:38:06.640] getGlobalsAndPackages() ... DONE
[17:38:06.640] run() for ‘Future’ ...
[17:38:06.640] - state: ‘created’
[17:38:06.640] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:06.641] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.641] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:06.641]   - Field: ‘label’
[17:38:06.641]   - Field: ‘local’
[17:38:06.641]   - Field: ‘owner’
[17:38:06.641]   - Field: ‘envir’
[17:38:06.641]   - Field: ‘packages’
[17:38:06.641]   - Field: ‘gc’
[17:38:06.641]   - Field: ‘conditions’
[17:38:06.642]   - Field: ‘expr’
[17:38:06.642]   - Field: ‘uuid’
[17:38:06.642]   - Field: ‘seed’
[17:38:06.642]   - Field: ‘version’
[17:38:06.642]   - Field: ‘result’
[17:38:06.642]   - Field: ‘asynchronous’
[17:38:06.642]   - Field: ‘calls’
[17:38:06.642]   - Field: ‘globals’
[17:38:06.642]   - Field: ‘stdout’
[17:38:06.642]   - Field: ‘earlySignal’
[17:38:06.642]   - Field: ‘lazy’
[17:38:06.643]   - Field: ‘state’
[17:38:06.643] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:06.643] - Launch lazy future ...
[17:38:06.643] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:06.643] Packages needed by future strategies (n = 0): <none>
[17:38:06.643] {
[17:38:06.643]     {
[17:38:06.643]         {
[17:38:06.643]             ...future.startTime <- base::Sys.time()
[17:38:06.643]             {
[17:38:06.643]                 {
[17:38:06.643]                   {
[17:38:06.643]                     {
[17:38:06.643]                       base::local({
[17:38:06.643]                         has_future <- base::requireNamespace("future", 
[17:38:06.643]                           quietly = TRUE)
[17:38:06.643]                         if (has_future) {
[17:38:06.643]                           ns <- base::getNamespace("future")
[17:38:06.643]                           version <- ns[[".package"]][["version"]]
[17:38:06.643]                           if (is.null(version)) 
[17:38:06.643]                             version <- utils::packageVersion("future")
[17:38:06.643]                         }
[17:38:06.643]                         else {
[17:38:06.643]                           version <- NULL
[17:38:06.643]                         }
[17:38:06.643]                         if (!has_future || version < "1.8.0") {
[17:38:06.643]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:06.643]                             "", base::R.version$version.string), 
[17:38:06.643]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:06.643]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:06.643]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:06.643]                               "release", "version")], collapse = " "), 
[17:38:06.643]                             hostname = base::Sys.info()[["nodename"]])
[17:38:06.643]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:06.643]                             info)
[17:38:06.643]                           info <- base::paste(info, collapse = "; ")
[17:38:06.643]                           if (!has_future) {
[17:38:06.643]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:06.643]                               info)
[17:38:06.643]                           }
[17:38:06.643]                           else {
[17:38:06.643]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:06.643]                               info, version)
[17:38:06.643]                           }
[17:38:06.643]                           base::stop(msg)
[17:38:06.643]                         }
[17:38:06.643]                       })
[17:38:06.643]                     }
[17:38:06.643]                     base::local({
[17:38:06.643]                       for (pkg in "future.apply") {
[17:38:06.643]                         base::loadNamespace(pkg)
[17:38:06.643]                         base::library(pkg, character.only = TRUE)
[17:38:06.643]                       }
[17:38:06.643]                     })
[17:38:06.643]                   }
[17:38:06.643]                   ...future.strategy.old <- future::plan("list")
[17:38:06.643]                   options(future.plan = NULL)
[17:38:06.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:06.643]                 }
[17:38:06.643]                 ...future.workdir <- getwd()
[17:38:06.643]             }
[17:38:06.643]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:06.643]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:06.643]         }
[17:38:06.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:06.643]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:06.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:06.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:06.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:06.643]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:06.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:06.643]             base::names(...future.oldOptions))
[17:38:06.643]     }
[17:38:06.643]     if (FALSE) {
[17:38:06.643]     }
[17:38:06.643]     else {
[17:38:06.643]         if (TRUE) {
[17:38:06.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:06.643]                 open = "w")
[17:38:06.643]         }
[17:38:06.643]         else {
[17:38:06.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:06.643]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:06.643]         }
[17:38:06.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:06.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:06.643]             base::sink(type = "output", split = FALSE)
[17:38:06.643]             base::close(...future.stdout)
[17:38:06.643]         }, add = TRUE)
[17:38:06.643]     }
[17:38:06.643]     ...future.frame <- base::sys.nframe()
[17:38:06.643]     ...future.conditions <- base::list()
[17:38:06.643]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:06.643]     if (FALSE) {
[17:38:06.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:06.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:06.643]     }
[17:38:06.643]     ...future.result <- base::tryCatch({
[17:38:06.643]         base::withCallingHandlers({
[17:38:06.643]             ...future.value <- base::withVisible(base::local({
[17:38:06.643]                 do.call(function(...) {
[17:38:06.643]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.643]                   if (!identical(...future.globals.maxSize.org, 
[17:38:06.643]                     ...future.globals.maxSize)) {
[17:38:06.643]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.643]                     on.exit(options(oopts), add = TRUE)
[17:38:06.643]                   }
[17:38:06.643]                   {
[17:38:06.643]                     lapply(seq_along(...future.elements_ii), 
[17:38:06.643]                       FUN = function(jj) {
[17:38:06.643]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.643]                         ...future.FUN(...future.X_jj, ...)
[17:38:06.643]                       })
[17:38:06.643]                   }
[17:38:06.643]                 }, args = future.call.arguments)
[17:38:06.643]             }))
[17:38:06.643]             future::FutureResult(value = ...future.value$value, 
[17:38:06.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.643]                   ...future.rng), globalenv = if (FALSE) 
[17:38:06.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:06.643]                     ...future.globalenv.names))
[17:38:06.643]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:06.643]         }, condition = base::local({
[17:38:06.643]             c <- base::c
[17:38:06.643]             inherits <- base::inherits
[17:38:06.643]             invokeRestart <- base::invokeRestart
[17:38:06.643]             length <- base::length
[17:38:06.643]             list <- base::list
[17:38:06.643]             seq.int <- base::seq.int
[17:38:06.643]             signalCondition <- base::signalCondition
[17:38:06.643]             sys.calls <- base::sys.calls
[17:38:06.643]             `[[` <- base::`[[`
[17:38:06.643]             `+` <- base::`+`
[17:38:06.643]             `<<-` <- base::`<<-`
[17:38:06.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:06.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:06.643]                   3L)]
[17:38:06.643]             }
[17:38:06.643]             function(cond) {
[17:38:06.643]                 is_error <- inherits(cond, "error")
[17:38:06.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:06.643]                   NULL)
[17:38:06.643]                 if (is_error) {
[17:38:06.643]                   sessionInformation <- function() {
[17:38:06.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:06.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:06.643]                       search = base::search(), system = base::Sys.info())
[17:38:06.643]                   }
[17:38:06.643]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:06.643]                     cond$call), session = sessionInformation(), 
[17:38:06.643]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:06.643]                   signalCondition(cond)
[17:38:06.643]                 }
[17:38:06.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:06.643]                 "immediateCondition"))) {
[17:38:06.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:06.643]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:06.643]                   if (TRUE && !signal) {
[17:38:06.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.643]                     {
[17:38:06.643]                       inherits <- base::inherits
[17:38:06.643]                       invokeRestart <- base::invokeRestart
[17:38:06.643]                       is.null <- base::is.null
[17:38:06.643]                       muffled <- FALSE
[17:38:06.643]                       if (inherits(cond, "message")) {
[17:38:06.643]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.643]                         if (muffled) 
[17:38:06.643]                           invokeRestart("muffleMessage")
[17:38:06.643]                       }
[17:38:06.643]                       else if (inherits(cond, "warning")) {
[17:38:06.643]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.643]                         if (muffled) 
[17:38:06.643]                           invokeRestart("muffleWarning")
[17:38:06.643]                       }
[17:38:06.643]                       else if (inherits(cond, "condition")) {
[17:38:06.643]                         if (!is.null(pattern)) {
[17:38:06.643]                           computeRestarts <- base::computeRestarts
[17:38:06.643]                           grepl <- base::grepl
[17:38:06.643]                           restarts <- computeRestarts(cond)
[17:38:06.643]                           for (restart in restarts) {
[17:38:06.643]                             name <- restart$name
[17:38:06.643]                             if (is.null(name)) 
[17:38:06.643]                               next
[17:38:06.643]                             if (!grepl(pattern, name)) 
[17:38:06.643]                               next
[17:38:06.643]                             invokeRestart(restart)
[17:38:06.643]                             muffled <- TRUE
[17:38:06.643]                             break
[17:38:06.643]                           }
[17:38:06.643]                         }
[17:38:06.643]                       }
[17:38:06.643]                       invisible(muffled)
[17:38:06.643]                     }
[17:38:06.643]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.643]                   }
[17:38:06.643]                 }
[17:38:06.643]                 else {
[17:38:06.643]                   if (TRUE) {
[17:38:06.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.643]                     {
[17:38:06.643]                       inherits <- base::inherits
[17:38:06.643]                       invokeRestart <- base::invokeRestart
[17:38:06.643]                       is.null <- base::is.null
[17:38:06.643]                       muffled <- FALSE
[17:38:06.643]                       if (inherits(cond, "message")) {
[17:38:06.643]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.643]                         if (muffled) 
[17:38:06.643]                           invokeRestart("muffleMessage")
[17:38:06.643]                       }
[17:38:06.643]                       else if (inherits(cond, "warning")) {
[17:38:06.643]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.643]                         if (muffled) 
[17:38:06.643]                           invokeRestart("muffleWarning")
[17:38:06.643]                       }
[17:38:06.643]                       else if (inherits(cond, "condition")) {
[17:38:06.643]                         if (!is.null(pattern)) {
[17:38:06.643]                           computeRestarts <- base::computeRestarts
[17:38:06.643]                           grepl <- base::grepl
[17:38:06.643]                           restarts <- computeRestarts(cond)
[17:38:06.643]                           for (restart in restarts) {
[17:38:06.643]                             name <- restart$name
[17:38:06.643]                             if (is.null(name)) 
[17:38:06.643]                               next
[17:38:06.643]                             if (!grepl(pattern, name)) 
[17:38:06.643]                               next
[17:38:06.643]                             invokeRestart(restart)
[17:38:06.643]                             muffled <- TRUE
[17:38:06.643]                             break
[17:38:06.643]                           }
[17:38:06.643]                         }
[17:38:06.643]                       }
[17:38:06.643]                       invisible(muffled)
[17:38:06.643]                     }
[17:38:06.643]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.643]                   }
[17:38:06.643]                 }
[17:38:06.643]             }
[17:38:06.643]         }))
[17:38:06.643]     }, error = function(ex) {
[17:38:06.643]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:06.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.643]                 ...future.rng), started = ...future.startTime, 
[17:38:06.643]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:06.643]             version = "1.8"), class = "FutureResult")
[17:38:06.643]     }, finally = {
[17:38:06.643]         if (!identical(...future.workdir, getwd())) 
[17:38:06.643]             setwd(...future.workdir)
[17:38:06.643]         {
[17:38:06.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:06.643]                 ...future.oldOptions$nwarnings <- NULL
[17:38:06.643]             }
[17:38:06.643]             base::options(...future.oldOptions)
[17:38:06.643]             if (.Platform$OS.type == "windows") {
[17:38:06.643]                 old_names <- names(...future.oldEnvVars)
[17:38:06.643]                 envs <- base::Sys.getenv()
[17:38:06.643]                 names <- names(envs)
[17:38:06.643]                 common <- intersect(names, old_names)
[17:38:06.643]                 added <- setdiff(names, old_names)
[17:38:06.643]                 removed <- setdiff(old_names, names)
[17:38:06.643]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:06.643]                   envs[common]]
[17:38:06.643]                 NAMES <- toupper(changed)
[17:38:06.643]                 args <- list()
[17:38:06.643]                 for (kk in seq_along(NAMES)) {
[17:38:06.643]                   name <- changed[[kk]]
[17:38:06.643]                   NAME <- NAMES[[kk]]
[17:38:06.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.643]                     next
[17:38:06.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.643]                 }
[17:38:06.643]                 NAMES <- toupper(added)
[17:38:06.643]                 for (kk in seq_along(NAMES)) {
[17:38:06.643]                   name <- added[[kk]]
[17:38:06.643]                   NAME <- NAMES[[kk]]
[17:38:06.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.643]                     next
[17:38:06.643]                   args[[name]] <- ""
[17:38:06.643]                 }
[17:38:06.643]                 NAMES <- toupper(removed)
[17:38:06.643]                 for (kk in seq_along(NAMES)) {
[17:38:06.643]                   name <- removed[[kk]]
[17:38:06.643]                   NAME <- NAMES[[kk]]
[17:38:06.643]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.643]                     next
[17:38:06.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.643]                 }
[17:38:06.643]                 if (length(args) > 0) 
[17:38:06.643]                   base::do.call(base::Sys.setenv, args = args)
[17:38:06.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:06.643]             }
[17:38:06.643]             else {
[17:38:06.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:06.643]             }
[17:38:06.643]             {
[17:38:06.643]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:06.643]                   0L) {
[17:38:06.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:06.643]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:06.643]                   base::options(opts)
[17:38:06.643]                 }
[17:38:06.643]                 {
[17:38:06.643]                   {
[17:38:06.643]                     NULL
[17:38:06.643]                     RNGkind("Mersenne-Twister")
[17:38:06.643]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:06.643]                       inherits = FALSE)
[17:38:06.643]                   }
[17:38:06.643]                   options(future.plan = NULL)
[17:38:06.643]                   if (is.na(NA_character_)) 
[17:38:06.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:06.643]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:06.643]                     .init = FALSE)
[17:38:06.643]                 }
[17:38:06.643]             }
[17:38:06.643]         }
[17:38:06.643]     })
[17:38:06.643]     if (TRUE) {
[17:38:06.643]         base::sink(type = "output", split = FALSE)
[17:38:06.643]         if (TRUE) {
[17:38:06.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:06.643]         }
[17:38:06.643]         else {
[17:38:06.643]             ...future.result["stdout"] <- base::list(NULL)
[17:38:06.643]         }
[17:38:06.643]         base::close(...future.stdout)
[17:38:06.643]         ...future.stdout <- NULL
[17:38:06.643]     }
[17:38:06.643]     ...future.result$conditions <- ...future.conditions
[17:38:06.643]     ...future.result$finished <- base::Sys.time()
[17:38:06.643]     ...future.result
[17:38:06.643] }
[17:38:06.645] assign_globals() ...
[17:38:06.645] List of 11
[17:38:06.645]  $ ...future.FUN            :function (x, ...)  
[17:38:06.645]  $ x_FUN                    :function (x)  
[17:38:06.645]  $ times                    : int 0
[17:38:06.645]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.645]  $ stop_if_not              :function (...)  
[17:38:06.645]  $ dim                      : NULL
[17:38:06.645]  $ valid_types              : chr [1:2] "logical" "integer"
[17:38:06.645]  $ future.call.arguments    : list()
[17:38:06.645]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.645]  $ ...future.elements_ii    :List of 10
[17:38:06.645]   ..$ : int 1
[17:38:06.645]   ..$ : int 2
[17:38:06.645]   ..$ : int 3
[17:38:06.645]   ..$ : int 4
[17:38:06.645]   ..$ : int 5
[17:38:06.645]   ..$ : int 6
[17:38:06.645]   ..$ : int 7
[17:38:06.645]   ..$ : int 8
[17:38:06.645]   ..$ : int 9
[17:38:06.645]   ..$ : int 10
[17:38:06.645]  $ ...future.seeds_ii       : NULL
[17:38:06.645]  $ ...future.globals.maxSize: NULL
[17:38:06.645]  - attr(*, "where")=List of 11
[17:38:06.645]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:06.645]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:06.645]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:06.645]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:06.645]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:06.645]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:06.645]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:06.645]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:06.645]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:06.645]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:06.645]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:06.645]  - attr(*, "resolved")= logi FALSE
[17:38:06.645]  - attr(*, "total_size")= num 95400
[17:38:06.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.645]  - attr(*, "already-done")= logi TRUE
[17:38:06.656] - copied ‘...future.FUN’ to environment
[17:38:06.656] - reassign environment for ‘x_FUN’
[17:38:06.656] - copied ‘x_FUN’ to environment
[17:38:06.656] - copied ‘times’ to environment
[17:38:06.656] - copied ‘stopf’ to environment
[17:38:06.657] - copied ‘stop_if_not’ to environment
[17:38:06.657] - copied ‘dim’ to environment
[17:38:06.657] - copied ‘valid_types’ to environment
[17:38:06.657] - copied ‘future.call.arguments’ to environment
[17:38:06.657] - copied ‘...future.elements_ii’ to environment
[17:38:06.657] - copied ‘...future.seeds_ii’ to environment
[17:38:06.657] - copied ‘...future.globals.maxSize’ to environment
[17:38:06.657] assign_globals() ... done
[17:38:06.658] plan(): Setting new future strategy stack:
[17:38:06.658] List of future strategies:
[17:38:06.658] 1. sequential:
[17:38:06.658]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.658]    - tweaked: FALSE
[17:38:06.658]    - call: NULL
[17:38:06.658] plan(): nbrOfWorkers() = 1
[17:38:06.659] plan(): Setting new future strategy stack:
[17:38:06.659] List of future strategies:
[17:38:06.659] 1. sequential:
[17:38:06.659]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.659]    - tweaked: FALSE
[17:38:06.659]    - call: plan(strategy)
[17:38:06.659] plan(): nbrOfWorkers() = 1
[17:38:06.660] SequentialFuture started (and completed)
[17:38:06.660] - Launch lazy future ... done
[17:38:06.660] run() for ‘SequentialFuture’ ... done
[17:38:06.660] Created future:
[17:38:06.660] SequentialFuture:
[17:38:06.660] Label: ‘future_vapply-1’
[17:38:06.660] Expression:
[17:38:06.660] {
[17:38:06.660]     do.call(function(...) {
[17:38:06.660]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.660]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.660]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.660]             on.exit(options(oopts), add = TRUE)
[17:38:06.660]         }
[17:38:06.660]         {
[17:38:06.660]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.660]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.660]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.660]             })
[17:38:06.660]         }
[17:38:06.660]     }, args = future.call.arguments)
[17:38:06.660] }
[17:38:06.660] Lazy evaluation: FALSE
[17:38:06.660] Asynchronous evaluation: FALSE
[17:38:06.660] Local evaluation: TRUE
[17:38:06.660] Environment: R_GlobalEnv
[17:38:06.660] Capture standard output: TRUE
[17:38:06.660] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:06.660] Globals: 11 objects totaling 93.71 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:06.660] Packages: 1 packages (‘future.apply’)
[17:38:06.660] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:06.660] Resolved: TRUE
[17:38:06.660] Value: 480 bytes of class ‘list’
[17:38:06.660] Early signaling: FALSE
[17:38:06.660] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:06.660] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.661] Chunk #1 of 1 ... DONE
[17:38:06.661] Launching 1 futures (chunks) ... DONE
[17:38:06.661] Resolving 1 futures (chunks) ...
[17:38:06.661] resolve() on list ...
[17:38:06.661]  recursive: 0
[17:38:06.662]  length: 1
[17:38:06.662] 
[17:38:06.662] resolved() for ‘SequentialFuture’ ...
[17:38:06.662] - state: ‘finished’
[17:38:06.662] - run: TRUE
[17:38:06.662] - result: ‘FutureResult’
[17:38:06.662] resolved() for ‘SequentialFuture’ ... done
[17:38:06.662] Future #1
[17:38:06.662] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:06.662] - nx: 1
[17:38:06.663] - relay: TRUE
[17:38:06.663] - stdout: TRUE
[17:38:06.663] - signal: TRUE
[17:38:06.663] - resignal: FALSE
[17:38:06.663] - force: TRUE
[17:38:06.663] - relayed: [n=1] FALSE
[17:38:06.663] - queued futures: [n=1] FALSE
[17:38:06.663]  - until=1
[17:38:06.663]  - relaying element #1
[17:38:06.663] - relayed: [n=1] TRUE
[17:38:06.663] - queued futures: [n=1] TRUE
[17:38:06.664] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:06.664]  length: 0 (resolved future 1)
[17:38:06.664] Relaying remaining futures
[17:38:06.664] signalConditionsASAP(NULL, pos=0) ...
[17:38:06.664] - nx: 1
[17:38:06.664] - relay: TRUE
[17:38:06.664] - stdout: TRUE
[17:38:06.664] - signal: TRUE
[17:38:06.664] - resignal: FALSE
[17:38:06.664] - force: TRUE
[17:38:06.664] - relayed: [n=1] TRUE
[17:38:06.664] - queued futures: [n=1] TRUE
 - flush all
[17:38:06.665] - relayed: [n=1] TRUE
[17:38:06.665] - queued futures: [n=1] TRUE
[17:38:06.665] signalConditionsASAP(NULL, pos=0) ... done
[17:38:06.665] resolve() on list ... DONE
[17:38:06.665]  - Number of value chunks collected: 1
[17:38:06.665] Resolving 1 futures (chunks) ... DONE
[17:38:06.665] Reducing values from 1 chunks ...
[17:38:06.665]  - Number of values collected after concatenation: 10
[17:38:06.665]  - Number of values expected: 10
[17:38:06.665] Reducing values from 1 chunks ... DONE
[17:38:06.666] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[17:38:06.666] future_lapply() ...
[17:38:06.668] Number of chunks: 1
[17:38:06.668] getGlobalsAndPackagesXApply() ...
[17:38:06.668]  - future.globals: TRUE
[17:38:06.668] getGlobalsAndPackages() ...
[17:38:06.668] Searching for globals...
[17:38:06.673] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:06.673] Searching for globals ... DONE
[17:38:06.673] Resolving globals: FALSE
[17:38:06.674] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[17:38:06.674] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:06.675] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.675] - packages: [1] ‘future.apply’
[17:38:06.675] getGlobalsAndPackages() ... DONE
[17:38:06.675]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.675]  - needed namespaces: [n=1] ‘future.apply’
[17:38:06.675] Finding globals ... DONE
[17:38:06.675]  - use_args: TRUE
[17:38:06.675]  - Getting '...' globals ...
[17:38:06.676] resolve() on list ...
[17:38:06.676]  recursive: 0
[17:38:06.676]  length: 1
[17:38:06.676]  elements: ‘...’
[17:38:06.676]  length: 0 (resolved future 1)
[17:38:06.676] resolve() on list ... DONE
[17:38:06.676]    - '...' content: [n=0] 
[17:38:06.676] List of 1
[17:38:06.676]  $ ...: list()
[17:38:06.676]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.676]  - attr(*, "where")=List of 1
[17:38:06.676]   ..$ ...:<environment: 0x560801b6cf88> 
[17:38:06.676]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.676]  - attr(*, "resolved")= logi TRUE
[17:38:06.676]  - attr(*, "total_size")= num NA
[17:38:06.679]  - Getting '...' globals ... DONE
[17:38:06.679] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:06.679] List of 8
[17:38:06.679]  $ ...future.FUN:function (x, ...)  
[17:38:06.679]  $ x_FUN        :function (x)  
[17:38:06.679]  $ times        : int 1
[17:38:06.679]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.679]  $ stop_if_not  :function (...)  
[17:38:06.679]  $ dim          : NULL
[17:38:06.679]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:06.679]  $ ...          : list()
[17:38:06.679]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.679]  - attr(*, "where")=List of 8
[17:38:06.679]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:06.679]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:06.679]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:06.679]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:06.679]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:06.679]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:06.679]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:06.679]   ..$ ...          :<environment: 0x560801b6cf88> 
[17:38:06.679]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.679]  - attr(*, "resolved")= logi FALSE
[17:38:06.679]  - attr(*, "total_size")= num 94336
[17:38:06.684] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:06.684] getGlobalsAndPackagesXApply() ... DONE
[17:38:06.685] Number of futures (= number of chunks): 1
[17:38:06.685] Launching 1 futures (chunks) ...
[17:38:06.685] Chunk #1 of 1 ...
[17:38:06.685]  - Finding globals in 'X' for chunk #1 ...
[17:38:06.685] getGlobalsAndPackages() ...
[17:38:06.685] Searching for globals...
[17:38:06.685] 
[17:38:06.685] Searching for globals ... DONE
[17:38:06.686] - globals: [0] <none>
[17:38:06.686] getGlobalsAndPackages() ... DONE
[17:38:06.686]    + additional globals found: [n=0] 
[17:38:06.686]    + additional namespaces needed: [n=0] 
[17:38:06.686]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:06.686]  - seeds: <none>
[17:38:06.686]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.686] getGlobalsAndPackages() ...
[17:38:06.686] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.686] Resolving globals: FALSE
[17:38:06.687] Tweak future expression to call with '...' arguments ...
[17:38:06.687] {
[17:38:06.687]     do.call(function(...) {
[17:38:06.687]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.687]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.687]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.687]             on.exit(options(oopts), add = TRUE)
[17:38:06.687]         }
[17:38:06.687]         {
[17:38:06.687]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.687]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.687]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.687]             })
[17:38:06.687]         }
[17:38:06.687]     }, args = future.call.arguments)
[17:38:06.687] }
[17:38:06.687] Tweak future expression to call with '...' arguments ... DONE
[17:38:06.687] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.687] - packages: [1] ‘future.apply’
[17:38:06.688] getGlobalsAndPackages() ... DONE
[17:38:06.688] run() for ‘Future’ ...
[17:38:06.688] - state: ‘created’
[17:38:06.688] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:06.688] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.689] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:06.689]   - Field: ‘label’
[17:38:06.689]   - Field: ‘local’
[17:38:06.689]   - Field: ‘owner’
[17:38:06.689]   - Field: ‘envir’
[17:38:06.689]   - Field: ‘packages’
[17:38:06.689]   - Field: ‘gc’
[17:38:06.689]   - Field: ‘conditions’
[17:38:06.689]   - Field: ‘expr’
[17:38:06.689]   - Field: ‘uuid’
[17:38:06.690]   - Field: ‘seed’
[17:38:06.690]   - Field: ‘version’
[17:38:06.690]   - Field: ‘result’
[17:38:06.690]   - Field: ‘asynchronous’
[17:38:06.690]   - Field: ‘calls’
[17:38:06.690]   - Field: ‘globals’
[17:38:06.690]   - Field: ‘stdout’
[17:38:06.690]   - Field: ‘earlySignal’
[17:38:06.690]   - Field: ‘lazy’
[17:38:06.690]   - Field: ‘state’
[17:38:06.690] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:06.691] - Launch lazy future ...
[17:38:06.691] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:06.691] Packages needed by future strategies (n = 0): <none>
[17:38:06.691] {
[17:38:06.691]     {
[17:38:06.691]         {
[17:38:06.691]             ...future.startTime <- base::Sys.time()
[17:38:06.691]             {
[17:38:06.691]                 {
[17:38:06.691]                   {
[17:38:06.691]                     {
[17:38:06.691]                       base::local({
[17:38:06.691]                         has_future <- base::requireNamespace("future", 
[17:38:06.691]                           quietly = TRUE)
[17:38:06.691]                         if (has_future) {
[17:38:06.691]                           ns <- base::getNamespace("future")
[17:38:06.691]                           version <- ns[[".package"]][["version"]]
[17:38:06.691]                           if (is.null(version)) 
[17:38:06.691]                             version <- utils::packageVersion("future")
[17:38:06.691]                         }
[17:38:06.691]                         else {
[17:38:06.691]                           version <- NULL
[17:38:06.691]                         }
[17:38:06.691]                         if (!has_future || version < "1.8.0") {
[17:38:06.691]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:06.691]                             "", base::R.version$version.string), 
[17:38:06.691]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:06.691]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:06.691]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:06.691]                               "release", "version")], collapse = " "), 
[17:38:06.691]                             hostname = base::Sys.info()[["nodename"]])
[17:38:06.691]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:06.691]                             info)
[17:38:06.691]                           info <- base::paste(info, collapse = "; ")
[17:38:06.691]                           if (!has_future) {
[17:38:06.691]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:06.691]                               info)
[17:38:06.691]                           }
[17:38:06.691]                           else {
[17:38:06.691]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:06.691]                               info, version)
[17:38:06.691]                           }
[17:38:06.691]                           base::stop(msg)
[17:38:06.691]                         }
[17:38:06.691]                       })
[17:38:06.691]                     }
[17:38:06.691]                     base::local({
[17:38:06.691]                       for (pkg in "future.apply") {
[17:38:06.691]                         base::loadNamespace(pkg)
[17:38:06.691]                         base::library(pkg, character.only = TRUE)
[17:38:06.691]                       }
[17:38:06.691]                     })
[17:38:06.691]                   }
[17:38:06.691]                   ...future.strategy.old <- future::plan("list")
[17:38:06.691]                   options(future.plan = NULL)
[17:38:06.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:06.691]                 }
[17:38:06.691]                 ...future.workdir <- getwd()
[17:38:06.691]             }
[17:38:06.691]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:06.691]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:06.691]         }
[17:38:06.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:06.691]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:06.691]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:06.691]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:06.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:06.691]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:06.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:06.691]             base::names(...future.oldOptions))
[17:38:06.691]     }
[17:38:06.691]     if (FALSE) {
[17:38:06.691]     }
[17:38:06.691]     else {
[17:38:06.691]         if (TRUE) {
[17:38:06.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:06.691]                 open = "w")
[17:38:06.691]         }
[17:38:06.691]         else {
[17:38:06.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:06.691]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:06.691]         }
[17:38:06.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:06.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:06.691]             base::sink(type = "output", split = FALSE)
[17:38:06.691]             base::close(...future.stdout)
[17:38:06.691]         }, add = TRUE)
[17:38:06.691]     }
[17:38:06.691]     ...future.frame <- base::sys.nframe()
[17:38:06.691]     ...future.conditions <- base::list()
[17:38:06.691]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:06.691]     if (FALSE) {
[17:38:06.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:06.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:06.691]     }
[17:38:06.691]     ...future.result <- base::tryCatch({
[17:38:06.691]         base::withCallingHandlers({
[17:38:06.691]             ...future.value <- base::withVisible(base::local({
[17:38:06.691]                 do.call(function(...) {
[17:38:06.691]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.691]                   if (!identical(...future.globals.maxSize.org, 
[17:38:06.691]                     ...future.globals.maxSize)) {
[17:38:06.691]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.691]                     on.exit(options(oopts), add = TRUE)
[17:38:06.691]                   }
[17:38:06.691]                   {
[17:38:06.691]                     lapply(seq_along(...future.elements_ii), 
[17:38:06.691]                       FUN = function(jj) {
[17:38:06.691]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.691]                         ...future.FUN(...future.X_jj, ...)
[17:38:06.691]                       })
[17:38:06.691]                   }
[17:38:06.691]                 }, args = future.call.arguments)
[17:38:06.691]             }))
[17:38:06.691]             future::FutureResult(value = ...future.value$value, 
[17:38:06.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.691]                   ...future.rng), globalenv = if (FALSE) 
[17:38:06.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:06.691]                     ...future.globalenv.names))
[17:38:06.691]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:06.691]         }, condition = base::local({
[17:38:06.691]             c <- base::c
[17:38:06.691]             inherits <- base::inherits
[17:38:06.691]             invokeRestart <- base::invokeRestart
[17:38:06.691]             length <- base::length
[17:38:06.691]             list <- base::list
[17:38:06.691]             seq.int <- base::seq.int
[17:38:06.691]             signalCondition <- base::signalCondition
[17:38:06.691]             sys.calls <- base::sys.calls
[17:38:06.691]             `[[` <- base::`[[`
[17:38:06.691]             `+` <- base::`+`
[17:38:06.691]             `<<-` <- base::`<<-`
[17:38:06.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:06.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:06.691]                   3L)]
[17:38:06.691]             }
[17:38:06.691]             function(cond) {
[17:38:06.691]                 is_error <- inherits(cond, "error")
[17:38:06.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:06.691]                   NULL)
[17:38:06.691]                 if (is_error) {
[17:38:06.691]                   sessionInformation <- function() {
[17:38:06.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:06.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:06.691]                       search = base::search(), system = base::Sys.info())
[17:38:06.691]                   }
[17:38:06.691]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:06.691]                     cond$call), session = sessionInformation(), 
[17:38:06.691]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:06.691]                   signalCondition(cond)
[17:38:06.691]                 }
[17:38:06.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:06.691]                 "immediateCondition"))) {
[17:38:06.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:06.691]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:06.691]                   if (TRUE && !signal) {
[17:38:06.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.691]                     {
[17:38:06.691]                       inherits <- base::inherits
[17:38:06.691]                       invokeRestart <- base::invokeRestart
[17:38:06.691]                       is.null <- base::is.null
[17:38:06.691]                       muffled <- FALSE
[17:38:06.691]                       if (inherits(cond, "message")) {
[17:38:06.691]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.691]                         if (muffled) 
[17:38:06.691]                           invokeRestart("muffleMessage")
[17:38:06.691]                       }
[17:38:06.691]                       else if (inherits(cond, "warning")) {
[17:38:06.691]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.691]                         if (muffled) 
[17:38:06.691]                           invokeRestart("muffleWarning")
[17:38:06.691]                       }
[17:38:06.691]                       else if (inherits(cond, "condition")) {
[17:38:06.691]                         if (!is.null(pattern)) {
[17:38:06.691]                           computeRestarts <- base::computeRestarts
[17:38:06.691]                           grepl <- base::grepl
[17:38:06.691]                           restarts <- computeRestarts(cond)
[17:38:06.691]                           for (restart in restarts) {
[17:38:06.691]                             name <- restart$name
[17:38:06.691]                             if (is.null(name)) 
[17:38:06.691]                               next
[17:38:06.691]                             if (!grepl(pattern, name)) 
[17:38:06.691]                               next
[17:38:06.691]                             invokeRestart(restart)
[17:38:06.691]                             muffled <- TRUE
[17:38:06.691]                             break
[17:38:06.691]                           }
[17:38:06.691]                         }
[17:38:06.691]                       }
[17:38:06.691]                       invisible(muffled)
[17:38:06.691]                     }
[17:38:06.691]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.691]                   }
[17:38:06.691]                 }
[17:38:06.691]                 else {
[17:38:06.691]                   if (TRUE) {
[17:38:06.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.691]                     {
[17:38:06.691]                       inherits <- base::inherits
[17:38:06.691]                       invokeRestart <- base::invokeRestart
[17:38:06.691]                       is.null <- base::is.null
[17:38:06.691]                       muffled <- FALSE
[17:38:06.691]                       if (inherits(cond, "message")) {
[17:38:06.691]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.691]                         if (muffled) 
[17:38:06.691]                           invokeRestart("muffleMessage")
[17:38:06.691]                       }
[17:38:06.691]                       else if (inherits(cond, "warning")) {
[17:38:06.691]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.691]                         if (muffled) 
[17:38:06.691]                           invokeRestart("muffleWarning")
[17:38:06.691]                       }
[17:38:06.691]                       else if (inherits(cond, "condition")) {
[17:38:06.691]                         if (!is.null(pattern)) {
[17:38:06.691]                           computeRestarts <- base::computeRestarts
[17:38:06.691]                           grepl <- base::grepl
[17:38:06.691]                           restarts <- computeRestarts(cond)
[17:38:06.691]                           for (restart in restarts) {
[17:38:06.691]                             name <- restart$name
[17:38:06.691]                             if (is.null(name)) 
[17:38:06.691]                               next
[17:38:06.691]                             if (!grepl(pattern, name)) 
[17:38:06.691]                               next
[17:38:06.691]                             invokeRestart(restart)
[17:38:06.691]                             muffled <- TRUE
[17:38:06.691]                             break
[17:38:06.691]                           }
[17:38:06.691]                         }
[17:38:06.691]                       }
[17:38:06.691]                       invisible(muffled)
[17:38:06.691]                     }
[17:38:06.691]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.691]                   }
[17:38:06.691]                 }
[17:38:06.691]             }
[17:38:06.691]         }))
[17:38:06.691]     }, error = function(ex) {
[17:38:06.691]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:06.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.691]                 ...future.rng), started = ...future.startTime, 
[17:38:06.691]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:06.691]             version = "1.8"), class = "FutureResult")
[17:38:06.691]     }, finally = {
[17:38:06.691]         if (!identical(...future.workdir, getwd())) 
[17:38:06.691]             setwd(...future.workdir)
[17:38:06.691]         {
[17:38:06.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:06.691]                 ...future.oldOptions$nwarnings <- NULL
[17:38:06.691]             }
[17:38:06.691]             base::options(...future.oldOptions)
[17:38:06.691]             if (.Platform$OS.type == "windows") {
[17:38:06.691]                 old_names <- names(...future.oldEnvVars)
[17:38:06.691]                 envs <- base::Sys.getenv()
[17:38:06.691]                 names <- names(envs)
[17:38:06.691]                 common <- intersect(names, old_names)
[17:38:06.691]                 added <- setdiff(names, old_names)
[17:38:06.691]                 removed <- setdiff(old_names, names)
[17:38:06.691]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:06.691]                   envs[common]]
[17:38:06.691]                 NAMES <- toupper(changed)
[17:38:06.691]                 args <- list()
[17:38:06.691]                 for (kk in seq_along(NAMES)) {
[17:38:06.691]                   name <- changed[[kk]]
[17:38:06.691]                   NAME <- NAMES[[kk]]
[17:38:06.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.691]                     next
[17:38:06.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.691]                 }
[17:38:06.691]                 NAMES <- toupper(added)
[17:38:06.691]                 for (kk in seq_along(NAMES)) {
[17:38:06.691]                   name <- added[[kk]]
[17:38:06.691]                   NAME <- NAMES[[kk]]
[17:38:06.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.691]                     next
[17:38:06.691]                   args[[name]] <- ""
[17:38:06.691]                 }
[17:38:06.691]                 NAMES <- toupper(removed)
[17:38:06.691]                 for (kk in seq_along(NAMES)) {
[17:38:06.691]                   name <- removed[[kk]]
[17:38:06.691]                   NAME <- NAMES[[kk]]
[17:38:06.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.691]                     next
[17:38:06.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.691]                 }
[17:38:06.691]                 if (length(args) > 0) 
[17:38:06.691]                   base::do.call(base::Sys.setenv, args = args)
[17:38:06.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:06.691]             }
[17:38:06.691]             else {
[17:38:06.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:06.691]             }
[17:38:06.691]             {
[17:38:06.691]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:06.691]                   0L) {
[17:38:06.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:06.691]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:06.691]                   base::options(opts)
[17:38:06.691]                 }
[17:38:06.691]                 {
[17:38:06.691]                   {
[17:38:06.691]                     NULL
[17:38:06.691]                     RNGkind("Mersenne-Twister")
[17:38:06.691]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:06.691]                       inherits = FALSE)
[17:38:06.691]                   }
[17:38:06.691]                   options(future.plan = NULL)
[17:38:06.691]                   if (is.na(NA_character_)) 
[17:38:06.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:06.691]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:06.691]                     .init = FALSE)
[17:38:06.691]                 }
[17:38:06.691]             }
[17:38:06.691]         }
[17:38:06.691]     })
[17:38:06.691]     if (TRUE) {
[17:38:06.691]         base::sink(type = "output", split = FALSE)
[17:38:06.691]         if (TRUE) {
[17:38:06.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:06.691]         }
[17:38:06.691]         else {
[17:38:06.691]             ...future.result["stdout"] <- base::list(NULL)
[17:38:06.691]         }
[17:38:06.691]         base::close(...future.stdout)
[17:38:06.691]         ...future.stdout <- NULL
[17:38:06.691]     }
[17:38:06.691]     ...future.result$conditions <- ...future.conditions
[17:38:06.691]     ...future.result$finished <- base::Sys.time()
[17:38:06.691]     ...future.result
[17:38:06.691] }
[17:38:06.693] assign_globals() ...
[17:38:06.693] List of 11
[17:38:06.693]  $ ...future.FUN            :function (x, ...)  
[17:38:06.693]  $ x_FUN                    :function (x)  
[17:38:06.693]  $ times                    : int 1
[17:38:06.693]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.693]  $ stop_if_not              :function (...)  
[17:38:06.693]  $ dim                      : NULL
[17:38:06.693]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:06.693]  $ future.call.arguments    : list()
[17:38:06.693]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.693]  $ ...future.elements_ii    :List of 10
[17:38:06.693]   ..$ : int 1
[17:38:06.693]   ..$ : int 2
[17:38:06.693]   ..$ : int 3
[17:38:06.693]   ..$ : int 4
[17:38:06.693]   ..$ : int 5
[17:38:06.693]   ..$ : int 6
[17:38:06.693]   ..$ : int 7
[17:38:06.693]   ..$ : int 8
[17:38:06.693]   ..$ : int 9
[17:38:06.693]   ..$ : int 10
[17:38:06.693]  $ ...future.seeds_ii       : NULL
[17:38:06.693]  $ ...future.globals.maxSize: NULL
[17:38:06.693]  - attr(*, "where")=List of 11
[17:38:06.693]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:06.693]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:06.693]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:06.693]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:06.693]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:06.693]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:06.693]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:06.693]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:06.693]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:06.693]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:06.693]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:06.693]  - attr(*, "resolved")= logi FALSE
[17:38:06.693]  - attr(*, "total_size")= num 94336
[17:38:06.693]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.693]  - attr(*, "already-done")= logi TRUE
[17:38:06.704] - copied ‘...future.FUN’ to environment
[17:38:06.704] - copied ‘x_FUN’ to environment
[17:38:06.705] - copied ‘times’ to environment
[17:38:06.705] - copied ‘stopf’ to environment
[17:38:06.705] - copied ‘stop_if_not’ to environment
[17:38:06.705] - copied ‘dim’ to environment
[17:38:06.705] - copied ‘valid_types’ to environment
[17:38:06.705] - copied ‘future.call.arguments’ to environment
[17:38:06.705] - copied ‘...future.elements_ii’ to environment
[17:38:06.705] - copied ‘...future.seeds_ii’ to environment
[17:38:06.705] - copied ‘...future.globals.maxSize’ to environment
[17:38:06.705] assign_globals() ... done
[17:38:06.706] plan(): Setting new future strategy stack:
[17:38:06.706] List of future strategies:
[17:38:06.706] 1. sequential:
[17:38:06.706]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.706]    - tweaked: FALSE
[17:38:06.706]    - call: NULL
[17:38:06.706] plan(): nbrOfWorkers() = 1
[17:38:06.707] plan(): Setting new future strategy stack:
[17:38:06.707] List of future strategies:
[17:38:06.707] 1. sequential:
[17:38:06.707]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.707]    - tweaked: FALSE
[17:38:06.707]    - call: plan(strategy)
[17:38:06.708] plan(): nbrOfWorkers() = 1
[17:38:06.708] SequentialFuture started (and completed)
[17:38:06.708] - Launch lazy future ... done
[17:38:06.708] run() for ‘SequentialFuture’ ... done
[17:38:06.708] Created future:
[17:38:06.708] SequentialFuture:
[17:38:06.708] Label: ‘future_vapply-1’
[17:38:06.708] Expression:
[17:38:06.708] {
[17:38:06.708]     do.call(function(...) {
[17:38:06.708]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.708]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.708]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.708]             on.exit(options(oopts), add = TRUE)
[17:38:06.708]         }
[17:38:06.708]         {
[17:38:06.708]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.708]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.708]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.708]             })
[17:38:06.708]         }
[17:38:06.708]     }, args = future.call.arguments)
[17:38:06.708] }
[17:38:06.708] Lazy evaluation: FALSE
[17:38:06.708] Asynchronous evaluation: FALSE
[17:38:06.708] Local evaluation: TRUE
[17:38:06.708] Environment: R_GlobalEnv
[17:38:06.708] Capture standard output: TRUE
[17:38:06.708] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:06.708] Globals: 11 objects totaling 92.67 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:06.708] Packages: 1 packages (‘future.apply’)
[17:38:06.708] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:06.708] Resolved: TRUE
[17:38:06.708] Value: 560 bytes of class ‘list’
[17:38:06.708] Early signaling: FALSE
[17:38:06.708] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:06.708] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.709] Chunk #1 of 1 ... DONE
[17:38:06.710] Launching 1 futures (chunks) ... DONE
[17:38:06.710] Resolving 1 futures (chunks) ...
[17:38:06.710] resolve() on list ...
[17:38:06.710]  recursive: 0
[17:38:06.710]  length: 1
[17:38:06.710] 
[17:38:06.710] resolved() for ‘SequentialFuture’ ...
[17:38:06.710] - state: ‘finished’
[17:38:06.710] - run: TRUE
[17:38:06.710] - result: ‘FutureResult’
[17:38:06.710] resolved() for ‘SequentialFuture’ ... done
[17:38:06.711] Future #1
[17:38:06.711] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:06.711] - nx: 1
[17:38:06.711] - relay: TRUE
[17:38:06.711] - stdout: TRUE
[17:38:06.711] - signal: TRUE
[17:38:06.711] - resignal: FALSE
[17:38:06.711] - force: TRUE
[17:38:06.711] - relayed: [n=1] FALSE
[17:38:06.711] - queued futures: [n=1] FALSE
[17:38:06.711]  - until=1
[17:38:06.712]  - relaying element #1
[17:38:06.712] - relayed: [n=1] TRUE
[17:38:06.712] - queued futures: [n=1] TRUE
[17:38:06.712] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:06.712]  length: 0 (resolved future 1)
[17:38:06.712] Relaying remaining futures
[17:38:06.712] signalConditionsASAP(NULL, pos=0) ...
[17:38:06.712] - nx: 1
[17:38:06.712] - relay: TRUE
[17:38:06.712] - stdout: TRUE
[17:38:06.712] - signal: TRUE
[17:38:06.713] - resignal: FALSE
[17:38:06.713] - force: TRUE
[17:38:06.713] - relayed: [n=1] TRUE
[17:38:06.713] - queued futures: [n=1] TRUE
 - flush all
[17:38:06.713] - relayed: [n=1] TRUE
[17:38:06.713] - queued futures: [n=1] TRUE
[17:38:06.713] signalConditionsASAP(NULL, pos=0) ... done
[17:38:06.713] resolve() on list ... DONE
[17:38:06.713]  - Number of value chunks collected: 1
[17:38:06.713] Resolving 1 futures (chunks) ... DONE
[17:38:06.714] Reducing values from 1 chunks ...
[17:38:06.714]  - Number of values collected after concatenation: 10
[17:38:06.714]  - Number of values expected: 10
[17:38:06.714] Reducing values from 1 chunks ... DONE
[17:38:06.714] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[17:38:06.715] future_lapply() ...
[17:38:06.716] Number of chunks: 1
[17:38:06.716] getGlobalsAndPackagesXApply() ...
[17:38:06.717]  - future.globals: TRUE
[17:38:06.717] getGlobalsAndPackages() ...
[17:38:06.717] Searching for globals...
[17:38:06.722] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[17:38:06.722] Searching for globals ... DONE
[17:38:06.722] Resolving globals: FALSE
[17:38:06.723] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[17:38:06.723] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:06.723] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.723] - packages: [1] ‘future.apply’
[17:38:06.723] getGlobalsAndPackages() ... DONE
[17:38:06.723]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.724]  - needed namespaces: [n=1] ‘future.apply’
[17:38:06.724] Finding globals ... DONE
[17:38:06.724]  - use_args: TRUE
[17:38:06.724]  - Getting '...' globals ...
[17:38:06.724] resolve() on list ...
[17:38:06.724]  recursive: 0
[17:38:06.724]  length: 1
[17:38:06.724]  elements: ‘...’
[17:38:06.725]  length: 0 (resolved future 1)
[17:38:06.725] resolve() on list ... DONE
[17:38:06.725]    - '...' content: [n=0] 
[17:38:06.725] List of 1
[17:38:06.725]  $ ...: list()
[17:38:06.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.725]  - attr(*, "where")=List of 1
[17:38:06.725]   ..$ ...:<environment: 0x560801b9beb0> 
[17:38:06.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.725]  - attr(*, "resolved")= logi TRUE
[17:38:06.725]  - attr(*, "total_size")= num NA
[17:38:06.727]  - Getting '...' globals ... DONE
[17:38:06.727] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:06.728] List of 8
[17:38:06.728]  $ ...future.FUN:function (x, ...)  
[17:38:06.728]  $ x_FUN        :function (x)  
[17:38:06.728]  $ times        : int 2
[17:38:06.728]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.728]  $ stop_if_not  :function (...)  
[17:38:06.728]  $ dim          : NULL
[17:38:06.728]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:06.728]  $ ...          : list()
[17:38:06.728]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.728]  - attr(*, "where")=List of 8
[17:38:06.728]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:06.728]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:06.728]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:06.728]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:06.728]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:06.728]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:06.728]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:06.728]   ..$ ...          :<environment: 0x560801b9beb0> 
[17:38:06.728]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.728]  - attr(*, "resolved")= logi FALSE
[17:38:06.728]  - attr(*, "total_size")= num 96456
[17:38:06.733] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:06.733] getGlobalsAndPackagesXApply() ... DONE
[17:38:06.733] Number of futures (= number of chunks): 1
[17:38:06.733] Launching 1 futures (chunks) ...
[17:38:06.733] Chunk #1 of 1 ...
[17:38:06.733]  - Finding globals in 'X' for chunk #1 ...
[17:38:06.733] getGlobalsAndPackages() ...
[17:38:06.733] Searching for globals...
[17:38:06.734] 
[17:38:06.734] Searching for globals ... DONE
[17:38:06.734] - globals: [0] <none>
[17:38:06.734] getGlobalsAndPackages() ... DONE
[17:38:06.734]    + additional globals found: [n=0] 
[17:38:06.734]    + additional namespaces needed: [n=0] 
[17:38:06.734]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:06.734]  - seeds: <none>
[17:38:06.734]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.735] getGlobalsAndPackages() ...
[17:38:06.735] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.735] Resolving globals: FALSE
[17:38:06.735] Tweak future expression to call with '...' arguments ...
[17:38:06.735] {
[17:38:06.735]     do.call(function(...) {
[17:38:06.735]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.735]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.735]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.735]             on.exit(options(oopts), add = TRUE)
[17:38:06.735]         }
[17:38:06.735]         {
[17:38:06.735]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.735]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.735]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.735]             })
[17:38:06.735]         }
[17:38:06.735]     }, args = future.call.arguments)
[17:38:06.735] }
[17:38:06.735] Tweak future expression to call with '...' arguments ... DONE
[17:38:06.736] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.736] - packages: [1] ‘future.apply’
[17:38:06.736] getGlobalsAndPackages() ... DONE
[17:38:06.736] run() for ‘Future’ ...
[17:38:06.736] - state: ‘created’
[17:38:06.736] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:06.737] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.737] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:06.737]   - Field: ‘label’
[17:38:06.737]   - Field: ‘local’
[17:38:06.737]   - Field: ‘owner’
[17:38:06.737]   - Field: ‘envir’
[17:38:06.737]   - Field: ‘packages’
[17:38:06.737]   - Field: ‘gc’
[17:38:06.738]   - Field: ‘conditions’
[17:38:06.738]   - Field: ‘expr’
[17:38:06.738]   - Field: ‘uuid’
[17:38:06.738]   - Field: ‘seed’
[17:38:06.738]   - Field: ‘version’
[17:38:06.738]   - Field: ‘result’
[17:38:06.738]   - Field: ‘asynchronous’
[17:38:06.738]   - Field: ‘calls’
[17:38:06.738]   - Field: ‘globals’
[17:38:06.738]   - Field: ‘stdout’
[17:38:06.738]   - Field: ‘earlySignal’
[17:38:06.738]   - Field: ‘lazy’
[17:38:06.739]   - Field: ‘state’
[17:38:06.739] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:06.739] - Launch lazy future ...
[17:38:06.739] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:06.739] Packages needed by future strategies (n = 0): <none>
[17:38:06.741] {
[17:38:06.741]     {
[17:38:06.741]         {
[17:38:06.741]             ...future.startTime <- base::Sys.time()
[17:38:06.741]             {
[17:38:06.741]                 {
[17:38:06.741]                   {
[17:38:06.741]                     {
[17:38:06.741]                       base::local({
[17:38:06.741]                         has_future <- base::requireNamespace("future", 
[17:38:06.741]                           quietly = TRUE)
[17:38:06.741]                         if (has_future) {
[17:38:06.741]                           ns <- base::getNamespace("future")
[17:38:06.741]                           version <- ns[[".package"]][["version"]]
[17:38:06.741]                           if (is.null(version)) 
[17:38:06.741]                             version <- utils::packageVersion("future")
[17:38:06.741]                         }
[17:38:06.741]                         else {
[17:38:06.741]                           version <- NULL
[17:38:06.741]                         }
[17:38:06.741]                         if (!has_future || version < "1.8.0") {
[17:38:06.741]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:06.741]                             "", base::R.version$version.string), 
[17:38:06.741]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:06.741]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:06.741]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:06.741]                               "release", "version")], collapse = " "), 
[17:38:06.741]                             hostname = base::Sys.info()[["nodename"]])
[17:38:06.741]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:06.741]                             info)
[17:38:06.741]                           info <- base::paste(info, collapse = "; ")
[17:38:06.741]                           if (!has_future) {
[17:38:06.741]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:06.741]                               info)
[17:38:06.741]                           }
[17:38:06.741]                           else {
[17:38:06.741]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:06.741]                               info, version)
[17:38:06.741]                           }
[17:38:06.741]                           base::stop(msg)
[17:38:06.741]                         }
[17:38:06.741]                       })
[17:38:06.741]                     }
[17:38:06.741]                     base::local({
[17:38:06.741]                       for (pkg in "future.apply") {
[17:38:06.741]                         base::loadNamespace(pkg)
[17:38:06.741]                         base::library(pkg, character.only = TRUE)
[17:38:06.741]                       }
[17:38:06.741]                     })
[17:38:06.741]                   }
[17:38:06.741]                   ...future.strategy.old <- future::plan("list")
[17:38:06.741]                   options(future.plan = NULL)
[17:38:06.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:06.741]                 }
[17:38:06.741]                 ...future.workdir <- getwd()
[17:38:06.741]             }
[17:38:06.741]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:06.741]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:06.741]         }
[17:38:06.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:06.741]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:06.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:06.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:06.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:06.741]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:06.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:06.741]             base::names(...future.oldOptions))
[17:38:06.741]     }
[17:38:06.741]     if (FALSE) {
[17:38:06.741]     }
[17:38:06.741]     else {
[17:38:06.741]         if (TRUE) {
[17:38:06.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:06.741]                 open = "w")
[17:38:06.741]         }
[17:38:06.741]         else {
[17:38:06.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:06.741]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:06.741]         }
[17:38:06.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:06.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:06.741]             base::sink(type = "output", split = FALSE)
[17:38:06.741]             base::close(...future.stdout)
[17:38:06.741]         }, add = TRUE)
[17:38:06.741]     }
[17:38:06.741]     ...future.frame <- base::sys.nframe()
[17:38:06.741]     ...future.conditions <- base::list()
[17:38:06.741]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:06.741]     if (FALSE) {
[17:38:06.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:06.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:06.741]     }
[17:38:06.741]     ...future.result <- base::tryCatch({
[17:38:06.741]         base::withCallingHandlers({
[17:38:06.741]             ...future.value <- base::withVisible(base::local({
[17:38:06.741]                 do.call(function(...) {
[17:38:06.741]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.741]                   if (!identical(...future.globals.maxSize.org, 
[17:38:06.741]                     ...future.globals.maxSize)) {
[17:38:06.741]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.741]                     on.exit(options(oopts), add = TRUE)
[17:38:06.741]                   }
[17:38:06.741]                   {
[17:38:06.741]                     lapply(seq_along(...future.elements_ii), 
[17:38:06.741]                       FUN = function(jj) {
[17:38:06.741]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.741]                         ...future.FUN(...future.X_jj, ...)
[17:38:06.741]                       })
[17:38:06.741]                   }
[17:38:06.741]                 }, args = future.call.arguments)
[17:38:06.741]             }))
[17:38:06.741]             future::FutureResult(value = ...future.value$value, 
[17:38:06.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.741]                   ...future.rng), globalenv = if (FALSE) 
[17:38:06.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:06.741]                     ...future.globalenv.names))
[17:38:06.741]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:06.741]         }, condition = base::local({
[17:38:06.741]             c <- base::c
[17:38:06.741]             inherits <- base::inherits
[17:38:06.741]             invokeRestart <- base::invokeRestart
[17:38:06.741]             length <- base::length
[17:38:06.741]             list <- base::list
[17:38:06.741]             seq.int <- base::seq.int
[17:38:06.741]             signalCondition <- base::signalCondition
[17:38:06.741]             sys.calls <- base::sys.calls
[17:38:06.741]             `[[` <- base::`[[`
[17:38:06.741]             `+` <- base::`+`
[17:38:06.741]             `<<-` <- base::`<<-`
[17:38:06.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:06.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:06.741]                   3L)]
[17:38:06.741]             }
[17:38:06.741]             function(cond) {
[17:38:06.741]                 is_error <- inherits(cond, "error")
[17:38:06.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:06.741]                   NULL)
[17:38:06.741]                 if (is_error) {
[17:38:06.741]                   sessionInformation <- function() {
[17:38:06.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:06.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:06.741]                       search = base::search(), system = base::Sys.info())
[17:38:06.741]                   }
[17:38:06.741]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:06.741]                     cond$call), session = sessionInformation(), 
[17:38:06.741]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:06.741]                   signalCondition(cond)
[17:38:06.741]                 }
[17:38:06.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:06.741]                 "immediateCondition"))) {
[17:38:06.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:06.741]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:06.741]                   if (TRUE && !signal) {
[17:38:06.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.741]                     {
[17:38:06.741]                       inherits <- base::inherits
[17:38:06.741]                       invokeRestart <- base::invokeRestart
[17:38:06.741]                       is.null <- base::is.null
[17:38:06.741]                       muffled <- FALSE
[17:38:06.741]                       if (inherits(cond, "message")) {
[17:38:06.741]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.741]                         if (muffled) 
[17:38:06.741]                           invokeRestart("muffleMessage")
[17:38:06.741]                       }
[17:38:06.741]                       else if (inherits(cond, "warning")) {
[17:38:06.741]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.741]                         if (muffled) 
[17:38:06.741]                           invokeRestart("muffleWarning")
[17:38:06.741]                       }
[17:38:06.741]                       else if (inherits(cond, "condition")) {
[17:38:06.741]                         if (!is.null(pattern)) {
[17:38:06.741]                           computeRestarts <- base::computeRestarts
[17:38:06.741]                           grepl <- base::grepl
[17:38:06.741]                           restarts <- computeRestarts(cond)
[17:38:06.741]                           for (restart in restarts) {
[17:38:06.741]                             name <- restart$name
[17:38:06.741]                             if (is.null(name)) 
[17:38:06.741]                               next
[17:38:06.741]                             if (!grepl(pattern, name)) 
[17:38:06.741]                               next
[17:38:06.741]                             invokeRestart(restart)
[17:38:06.741]                             muffled <- TRUE
[17:38:06.741]                             break
[17:38:06.741]                           }
[17:38:06.741]                         }
[17:38:06.741]                       }
[17:38:06.741]                       invisible(muffled)
[17:38:06.741]                     }
[17:38:06.741]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.741]                   }
[17:38:06.741]                 }
[17:38:06.741]                 else {
[17:38:06.741]                   if (TRUE) {
[17:38:06.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.741]                     {
[17:38:06.741]                       inherits <- base::inherits
[17:38:06.741]                       invokeRestart <- base::invokeRestart
[17:38:06.741]                       is.null <- base::is.null
[17:38:06.741]                       muffled <- FALSE
[17:38:06.741]                       if (inherits(cond, "message")) {
[17:38:06.741]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.741]                         if (muffled) 
[17:38:06.741]                           invokeRestart("muffleMessage")
[17:38:06.741]                       }
[17:38:06.741]                       else if (inherits(cond, "warning")) {
[17:38:06.741]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.741]                         if (muffled) 
[17:38:06.741]                           invokeRestart("muffleWarning")
[17:38:06.741]                       }
[17:38:06.741]                       else if (inherits(cond, "condition")) {
[17:38:06.741]                         if (!is.null(pattern)) {
[17:38:06.741]                           computeRestarts <- base::computeRestarts
[17:38:06.741]                           grepl <- base::grepl
[17:38:06.741]                           restarts <- computeRestarts(cond)
[17:38:06.741]                           for (restart in restarts) {
[17:38:06.741]                             name <- restart$name
[17:38:06.741]                             if (is.null(name)) 
[17:38:06.741]                               next
[17:38:06.741]                             if (!grepl(pattern, name)) 
[17:38:06.741]                               next
[17:38:06.741]                             invokeRestart(restart)
[17:38:06.741]                             muffled <- TRUE
[17:38:06.741]                             break
[17:38:06.741]                           }
[17:38:06.741]                         }
[17:38:06.741]                       }
[17:38:06.741]                       invisible(muffled)
[17:38:06.741]                     }
[17:38:06.741]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.741]                   }
[17:38:06.741]                 }
[17:38:06.741]             }
[17:38:06.741]         }))
[17:38:06.741]     }, error = function(ex) {
[17:38:06.741]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:06.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.741]                 ...future.rng), started = ...future.startTime, 
[17:38:06.741]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:06.741]             version = "1.8"), class = "FutureResult")
[17:38:06.741]     }, finally = {
[17:38:06.741]         if (!identical(...future.workdir, getwd())) 
[17:38:06.741]             setwd(...future.workdir)
[17:38:06.741]         {
[17:38:06.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:06.741]                 ...future.oldOptions$nwarnings <- NULL
[17:38:06.741]             }
[17:38:06.741]             base::options(...future.oldOptions)
[17:38:06.741]             if (.Platform$OS.type == "windows") {
[17:38:06.741]                 old_names <- names(...future.oldEnvVars)
[17:38:06.741]                 envs <- base::Sys.getenv()
[17:38:06.741]                 names <- names(envs)
[17:38:06.741]                 common <- intersect(names, old_names)
[17:38:06.741]                 added <- setdiff(names, old_names)
[17:38:06.741]                 removed <- setdiff(old_names, names)
[17:38:06.741]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:06.741]                   envs[common]]
[17:38:06.741]                 NAMES <- toupper(changed)
[17:38:06.741]                 args <- list()
[17:38:06.741]                 for (kk in seq_along(NAMES)) {
[17:38:06.741]                   name <- changed[[kk]]
[17:38:06.741]                   NAME <- NAMES[[kk]]
[17:38:06.741]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.741]                     next
[17:38:06.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.741]                 }
[17:38:06.741]                 NAMES <- toupper(added)
[17:38:06.741]                 for (kk in seq_along(NAMES)) {
[17:38:06.741]                   name <- added[[kk]]
[17:38:06.741]                   NAME <- NAMES[[kk]]
[17:38:06.741]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.741]                     next
[17:38:06.741]                   args[[name]] <- ""
[17:38:06.741]                 }
[17:38:06.741]                 NAMES <- toupper(removed)
[17:38:06.741]                 for (kk in seq_along(NAMES)) {
[17:38:06.741]                   name <- removed[[kk]]
[17:38:06.741]                   NAME <- NAMES[[kk]]
[17:38:06.741]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.741]                     next
[17:38:06.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.741]                 }
[17:38:06.741]                 if (length(args) > 0) 
[17:38:06.741]                   base::do.call(base::Sys.setenv, args = args)
[17:38:06.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:06.741]             }
[17:38:06.741]             else {
[17:38:06.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:06.741]             }
[17:38:06.741]             {
[17:38:06.741]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:06.741]                   0L) {
[17:38:06.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:06.741]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:06.741]                   base::options(opts)
[17:38:06.741]                 }
[17:38:06.741]                 {
[17:38:06.741]                   {
[17:38:06.741]                     NULL
[17:38:06.741]                     RNGkind("Mersenne-Twister")
[17:38:06.741]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:06.741]                       inherits = FALSE)
[17:38:06.741]                   }
[17:38:06.741]                   options(future.plan = NULL)
[17:38:06.741]                   if (is.na(NA_character_)) 
[17:38:06.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:06.741]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:06.741]                     .init = FALSE)
[17:38:06.741]                 }
[17:38:06.741]             }
[17:38:06.741]         }
[17:38:06.741]     })
[17:38:06.741]     if (TRUE) {
[17:38:06.741]         base::sink(type = "output", split = FALSE)
[17:38:06.741]         if (TRUE) {
[17:38:06.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:06.741]         }
[17:38:06.741]         else {
[17:38:06.741]             ...future.result["stdout"] <- base::list(NULL)
[17:38:06.741]         }
[17:38:06.741]         base::close(...future.stdout)
[17:38:06.741]         ...future.stdout <- NULL
[17:38:06.741]     }
[17:38:06.741]     ...future.result$conditions <- ...future.conditions
[17:38:06.741]     ...future.result$finished <- base::Sys.time()
[17:38:06.741]     ...future.result
[17:38:06.741] }
[17:38:06.743] assign_globals() ...
[17:38:06.743] List of 11
[17:38:06.743]  $ ...future.FUN            :function (x, ...)  
[17:38:06.743]  $ x_FUN                    :function (x)  
[17:38:06.743]  $ times                    : int 2
[17:38:06.743]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.743]  $ stop_if_not              :function (...)  
[17:38:06.743]  $ dim                      : NULL
[17:38:06.743]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:06.743]  $ future.call.arguments    : list()
[17:38:06.743]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.743]  $ ...future.elements_ii    :List of 10
[17:38:06.743]   ..$ : int 1
[17:38:06.743]   ..$ : int 2
[17:38:06.743]   ..$ : int 3
[17:38:06.743]   ..$ : int 4
[17:38:06.743]   ..$ : int 5
[17:38:06.743]   ..$ : int 6
[17:38:06.743]   ..$ : int 7
[17:38:06.743]   ..$ : int 8
[17:38:06.743]   ..$ : int 9
[17:38:06.743]   ..$ : int 10
[17:38:06.743]  $ ...future.seeds_ii       : NULL
[17:38:06.743]  $ ...future.globals.maxSize: NULL
[17:38:06.743]  - attr(*, "where")=List of 11
[17:38:06.743]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:06.743]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:06.743]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:06.743]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:06.743]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:06.743]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:06.743]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:06.743]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:06.743]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:06.743]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:06.743]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:06.743]  - attr(*, "resolved")= logi FALSE
[17:38:06.743]  - attr(*, "total_size")= num 96456
[17:38:06.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.743]  - attr(*, "already-done")= logi TRUE
[17:38:06.752] - copied ‘...future.FUN’ to environment
[17:38:06.753] - reassign environment for ‘x_FUN’
[17:38:06.753] - copied ‘x_FUN’ to environment
[17:38:06.753] - copied ‘times’ to environment
[17:38:06.753] - copied ‘stopf’ to environment
[17:38:06.753] - copied ‘stop_if_not’ to environment
[17:38:06.753] - copied ‘dim’ to environment
[17:38:06.753] - copied ‘valid_types’ to environment
[17:38:06.753] - copied ‘future.call.arguments’ to environment
[17:38:06.753] - copied ‘...future.elements_ii’ to environment
[17:38:06.753] - copied ‘...future.seeds_ii’ to environment
[17:38:06.753] - copied ‘...future.globals.maxSize’ to environment
[17:38:06.754] assign_globals() ... done
[17:38:06.754] plan(): Setting new future strategy stack:
[17:38:06.754] List of future strategies:
[17:38:06.754] 1. sequential:
[17:38:06.754]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.754]    - tweaked: FALSE
[17:38:06.754]    - call: NULL
[17:38:06.754] plan(): nbrOfWorkers() = 1
[17:38:06.755] plan(): Setting new future strategy stack:
[17:38:06.755] List of future strategies:
[17:38:06.755] 1. sequential:
[17:38:06.755]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.755]    - tweaked: FALSE
[17:38:06.755]    - call: plan(strategy)
[17:38:06.756] plan(): nbrOfWorkers() = 1
[17:38:06.756] SequentialFuture started (and completed)
[17:38:06.756] - Launch lazy future ... done
[17:38:06.756] run() for ‘SequentialFuture’ ... done
[17:38:06.756] Created future:
[17:38:06.756] SequentialFuture:
[17:38:06.756] Label: ‘future_vapply-1’
[17:38:06.756] Expression:
[17:38:06.756] {
[17:38:06.756]     do.call(function(...) {
[17:38:06.756]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.756]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.756]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.756]             on.exit(options(oopts), add = TRUE)
[17:38:06.756]         }
[17:38:06.756]         {
[17:38:06.756]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.756]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.756]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.756]             })
[17:38:06.756]         }
[17:38:06.756]     }, args = future.call.arguments)
[17:38:06.756] }
[17:38:06.756] Lazy evaluation: FALSE
[17:38:06.756] Asynchronous evaluation: FALSE
[17:38:06.756] Local evaluation: TRUE
[17:38:06.756] Environment: R_GlobalEnv
[17:38:06.756] Capture standard output: TRUE
[17:38:06.756] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:06.756] Globals: 11 objects totaling 94.74 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:06.756] Packages: 1 packages (‘future.apply’)
[17:38:06.756] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:06.756] Resolved: TRUE
[17:38:06.756] Value: 640 bytes of class ‘list’
[17:38:06.756] Early signaling: FALSE
[17:38:06.756] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:06.756] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.758] Chunk #1 of 1 ... DONE
[17:38:06.758] Launching 1 futures (chunks) ... DONE
[17:38:06.758] Resolving 1 futures (chunks) ...
[17:38:06.758] resolve() on list ...
[17:38:06.758]  recursive: 0
[17:38:06.758]  length: 1
[17:38:06.758] 
[17:38:06.758] resolved() for ‘SequentialFuture’ ...
[17:38:06.758] - state: ‘finished’
[17:38:06.758] - run: TRUE
[17:38:06.759] - result: ‘FutureResult’
[17:38:06.759] resolved() for ‘SequentialFuture’ ... done
[17:38:06.759] Future #1
[17:38:06.759] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:06.759] - nx: 1
[17:38:06.759] - relay: TRUE
[17:38:06.759] - stdout: TRUE
[17:38:06.759] - signal: TRUE
[17:38:06.759] - resignal: FALSE
[17:38:06.759] - force: TRUE
[17:38:06.759] - relayed: [n=1] FALSE
[17:38:06.760] - queued futures: [n=1] FALSE
[17:38:06.760]  - until=1
[17:38:06.760]  - relaying element #1
[17:38:06.760] - relayed: [n=1] TRUE
[17:38:06.760] - queued futures: [n=1] TRUE
[17:38:06.760] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:06.760]  length: 0 (resolved future 1)
[17:38:06.760] Relaying remaining futures
[17:38:06.760] signalConditionsASAP(NULL, pos=0) ...
[17:38:06.760] - nx: 1
[17:38:06.761] - relay: TRUE
[17:38:06.761] - stdout: TRUE
[17:38:06.761] - signal: TRUE
[17:38:06.761] - resignal: FALSE
[17:38:06.761] - force: TRUE
[17:38:06.761] - relayed: [n=1] TRUE
[17:38:06.761] - queued futures: [n=1] TRUE
 - flush all
[17:38:06.761] - relayed: [n=1] TRUE
[17:38:06.761] - queued futures: [n=1] TRUE
[17:38:06.761] signalConditionsASAP(NULL, pos=0) ... done
[17:38:06.761] resolve() on list ... DONE
[17:38:06.762]  - Number of value chunks collected: 1
[17:38:06.762] Resolving 1 futures (chunks) ... DONE
[17:38:06.762] Reducing values from 1 chunks ...
[17:38:06.762]  - Number of values collected after concatenation: 10
[17:38:06.762]  - Number of values expected: 10
[17:38:06.762] Reducing values from 1 chunks ... DONE
[17:38:06.762] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:38:06.763] future_lapply() ...
[17:38:06.766] Number of chunks: 1
[17:38:06.766] getGlobalsAndPackagesXApply() ...
[17:38:06.766]  - future.globals: TRUE
[17:38:06.766] getGlobalsAndPackages() ...
[17:38:06.767] Searching for globals...
[17:38:06.770] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:38:06.770] Searching for globals ... DONE
[17:38:06.770] Resolving globals: FALSE
[17:38:06.771] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[17:38:06.771] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:06.771] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.772] - packages: [1] ‘future.apply’
[17:38:06.772] getGlobalsAndPackages() ... DONE
[17:38:06.772]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.772]  - needed namespaces: [n=1] ‘future.apply’
[17:38:06.772] Finding globals ... DONE
[17:38:06.772]  - use_args: TRUE
[17:38:06.772]  - Getting '...' globals ...
[17:38:06.772] resolve() on list ...
[17:38:06.773]  recursive: 0
[17:38:06.773]  length: 1
[17:38:06.773]  elements: ‘...’
[17:38:06.773]  length: 0 (resolved future 1)
[17:38:06.773] resolve() on list ... DONE
[17:38:06.773]    - '...' content: [n=0] 
[17:38:06.773] List of 1
[17:38:06.773]  $ ...: list()
[17:38:06.773]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.773]  - attr(*, "where")=List of 1
[17:38:06.773]   ..$ ...:<environment: 0x560801d4c128> 
[17:38:06.773]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.773]  - attr(*, "resolved")= logi TRUE
[17:38:06.773]  - attr(*, "total_size")= num NA
[17:38:06.776]  - Getting '...' globals ... DONE
[17:38:06.776] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:06.776] List of 8
[17:38:06.776]  $ ...future.FUN:function (x, ...)  
[17:38:06.776]  $ x_FUN        :function (x)  
[17:38:06.776]  $ times        : int 4
[17:38:06.776]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.776]  $ stop_if_not  :function (...)  
[17:38:06.776]  $ dim          : int [1:2] 2 2
[17:38:06.776]  $ valid_types  : chr [1:2] "logical" "integer"
[17:38:06.776]  $ ...          : list()
[17:38:06.776]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.776]  - attr(*, "where")=List of 8
[17:38:06.776]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:06.776]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:06.776]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:06.776]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:06.776]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:06.776]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:06.776]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:06.776]   ..$ ...          :<environment: 0x560801d4c128> 
[17:38:06.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.776]  - attr(*, "resolved")= logi FALSE
[17:38:06.776]  - attr(*, "total_size")= num 97232
[17:38:06.781] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:06.781] getGlobalsAndPackagesXApply() ... DONE
[17:38:06.781] Number of futures (= number of chunks): 1
[17:38:06.782] Launching 1 futures (chunks) ...
[17:38:06.782] Chunk #1 of 1 ...
[17:38:06.782]  - Finding globals in 'X' for chunk #1 ...
[17:38:06.782] getGlobalsAndPackages() ...
[17:38:06.782] Searching for globals...
[17:38:06.782] 
[17:38:06.782] Searching for globals ... DONE
[17:38:06.782] - globals: [0] <none>
[17:38:06.782] getGlobalsAndPackages() ... DONE
[17:38:06.783]    + additional globals found: [n=0] 
[17:38:06.783]    + additional namespaces needed: [n=0] 
[17:38:06.783]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:06.783]  - seeds: <none>
[17:38:06.783]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.783] getGlobalsAndPackages() ...
[17:38:06.783] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.783] Resolving globals: FALSE
[17:38:06.783] Tweak future expression to call with '...' arguments ...
[17:38:06.783] {
[17:38:06.783]     do.call(function(...) {
[17:38:06.783]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.783]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.783]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.783]             on.exit(options(oopts), add = TRUE)
[17:38:06.783]         }
[17:38:06.783]         {
[17:38:06.783]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.783]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.783]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.783]             })
[17:38:06.783]         }
[17:38:06.783]     }, args = future.call.arguments)
[17:38:06.783] }
[17:38:06.784] Tweak future expression to call with '...' arguments ... DONE
[17:38:06.784] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.784] - packages: [1] ‘future.apply’
[17:38:06.784] getGlobalsAndPackages() ... DONE
[17:38:06.785] run() for ‘Future’ ...
[17:38:06.785] - state: ‘created’
[17:38:06.785] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:06.785] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.785] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:06.787]   - Field: ‘label’
[17:38:06.787]   - Field: ‘local’
[17:38:06.787]   - Field: ‘owner’
[17:38:06.787]   - Field: ‘envir’
[17:38:06.787]   - Field: ‘packages’
[17:38:06.787]   - Field: ‘gc’
[17:38:06.788]   - Field: ‘conditions’
[17:38:06.788]   - Field: ‘expr’
[17:38:06.788]   - Field: ‘uuid’
[17:38:06.788]   - Field: ‘seed’
[17:38:06.788]   - Field: ‘version’
[17:38:06.788]   - Field: ‘result’
[17:38:06.788]   - Field: ‘asynchronous’
[17:38:06.788]   - Field: ‘calls’
[17:38:06.788]   - Field: ‘globals’
[17:38:06.788]   - Field: ‘stdout’
[17:38:06.788]   - Field: ‘earlySignal’
[17:38:06.789]   - Field: ‘lazy’
[17:38:06.789]   - Field: ‘state’
[17:38:06.789] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:06.789] - Launch lazy future ...
[17:38:06.789] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:06.789] Packages needed by future strategies (n = 0): <none>
[17:38:06.790] {
[17:38:06.790]     {
[17:38:06.790]         {
[17:38:06.790]             ...future.startTime <- base::Sys.time()
[17:38:06.790]             {
[17:38:06.790]                 {
[17:38:06.790]                   {
[17:38:06.790]                     {
[17:38:06.790]                       base::local({
[17:38:06.790]                         has_future <- base::requireNamespace("future", 
[17:38:06.790]                           quietly = TRUE)
[17:38:06.790]                         if (has_future) {
[17:38:06.790]                           ns <- base::getNamespace("future")
[17:38:06.790]                           version <- ns[[".package"]][["version"]]
[17:38:06.790]                           if (is.null(version)) 
[17:38:06.790]                             version <- utils::packageVersion("future")
[17:38:06.790]                         }
[17:38:06.790]                         else {
[17:38:06.790]                           version <- NULL
[17:38:06.790]                         }
[17:38:06.790]                         if (!has_future || version < "1.8.0") {
[17:38:06.790]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:06.790]                             "", base::R.version$version.string), 
[17:38:06.790]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:06.790]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:06.790]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:06.790]                               "release", "version")], collapse = " "), 
[17:38:06.790]                             hostname = base::Sys.info()[["nodename"]])
[17:38:06.790]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:06.790]                             info)
[17:38:06.790]                           info <- base::paste(info, collapse = "; ")
[17:38:06.790]                           if (!has_future) {
[17:38:06.790]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:06.790]                               info)
[17:38:06.790]                           }
[17:38:06.790]                           else {
[17:38:06.790]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:06.790]                               info, version)
[17:38:06.790]                           }
[17:38:06.790]                           base::stop(msg)
[17:38:06.790]                         }
[17:38:06.790]                       })
[17:38:06.790]                     }
[17:38:06.790]                     base::local({
[17:38:06.790]                       for (pkg in "future.apply") {
[17:38:06.790]                         base::loadNamespace(pkg)
[17:38:06.790]                         base::library(pkg, character.only = TRUE)
[17:38:06.790]                       }
[17:38:06.790]                     })
[17:38:06.790]                   }
[17:38:06.790]                   ...future.strategy.old <- future::plan("list")
[17:38:06.790]                   options(future.plan = NULL)
[17:38:06.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:06.790]                 }
[17:38:06.790]                 ...future.workdir <- getwd()
[17:38:06.790]             }
[17:38:06.790]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:06.790]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:06.790]         }
[17:38:06.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:06.790]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:06.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:06.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:06.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:06.790]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:06.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:06.790]             base::names(...future.oldOptions))
[17:38:06.790]     }
[17:38:06.790]     if (FALSE) {
[17:38:06.790]     }
[17:38:06.790]     else {
[17:38:06.790]         if (TRUE) {
[17:38:06.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:06.790]                 open = "w")
[17:38:06.790]         }
[17:38:06.790]         else {
[17:38:06.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:06.790]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:06.790]         }
[17:38:06.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:06.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:06.790]             base::sink(type = "output", split = FALSE)
[17:38:06.790]             base::close(...future.stdout)
[17:38:06.790]         }, add = TRUE)
[17:38:06.790]     }
[17:38:06.790]     ...future.frame <- base::sys.nframe()
[17:38:06.790]     ...future.conditions <- base::list()
[17:38:06.790]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:06.790]     if (FALSE) {
[17:38:06.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:06.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:06.790]     }
[17:38:06.790]     ...future.result <- base::tryCatch({
[17:38:06.790]         base::withCallingHandlers({
[17:38:06.790]             ...future.value <- base::withVisible(base::local({
[17:38:06.790]                 do.call(function(...) {
[17:38:06.790]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.790]                   if (!identical(...future.globals.maxSize.org, 
[17:38:06.790]                     ...future.globals.maxSize)) {
[17:38:06.790]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.790]                     on.exit(options(oopts), add = TRUE)
[17:38:06.790]                   }
[17:38:06.790]                   {
[17:38:06.790]                     lapply(seq_along(...future.elements_ii), 
[17:38:06.790]                       FUN = function(jj) {
[17:38:06.790]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.790]                         ...future.FUN(...future.X_jj, ...)
[17:38:06.790]                       })
[17:38:06.790]                   }
[17:38:06.790]                 }, args = future.call.arguments)
[17:38:06.790]             }))
[17:38:06.790]             future::FutureResult(value = ...future.value$value, 
[17:38:06.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.790]                   ...future.rng), globalenv = if (FALSE) 
[17:38:06.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:06.790]                     ...future.globalenv.names))
[17:38:06.790]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:06.790]         }, condition = base::local({
[17:38:06.790]             c <- base::c
[17:38:06.790]             inherits <- base::inherits
[17:38:06.790]             invokeRestart <- base::invokeRestart
[17:38:06.790]             length <- base::length
[17:38:06.790]             list <- base::list
[17:38:06.790]             seq.int <- base::seq.int
[17:38:06.790]             signalCondition <- base::signalCondition
[17:38:06.790]             sys.calls <- base::sys.calls
[17:38:06.790]             `[[` <- base::`[[`
[17:38:06.790]             `+` <- base::`+`
[17:38:06.790]             `<<-` <- base::`<<-`
[17:38:06.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:06.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:06.790]                   3L)]
[17:38:06.790]             }
[17:38:06.790]             function(cond) {
[17:38:06.790]                 is_error <- inherits(cond, "error")
[17:38:06.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:06.790]                   NULL)
[17:38:06.790]                 if (is_error) {
[17:38:06.790]                   sessionInformation <- function() {
[17:38:06.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:06.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:06.790]                       search = base::search(), system = base::Sys.info())
[17:38:06.790]                   }
[17:38:06.790]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:06.790]                     cond$call), session = sessionInformation(), 
[17:38:06.790]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:06.790]                   signalCondition(cond)
[17:38:06.790]                 }
[17:38:06.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:06.790]                 "immediateCondition"))) {
[17:38:06.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:06.790]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:06.790]                   if (TRUE && !signal) {
[17:38:06.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.790]                     {
[17:38:06.790]                       inherits <- base::inherits
[17:38:06.790]                       invokeRestart <- base::invokeRestart
[17:38:06.790]                       is.null <- base::is.null
[17:38:06.790]                       muffled <- FALSE
[17:38:06.790]                       if (inherits(cond, "message")) {
[17:38:06.790]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.790]                         if (muffled) 
[17:38:06.790]                           invokeRestart("muffleMessage")
[17:38:06.790]                       }
[17:38:06.790]                       else if (inherits(cond, "warning")) {
[17:38:06.790]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.790]                         if (muffled) 
[17:38:06.790]                           invokeRestart("muffleWarning")
[17:38:06.790]                       }
[17:38:06.790]                       else if (inherits(cond, "condition")) {
[17:38:06.790]                         if (!is.null(pattern)) {
[17:38:06.790]                           computeRestarts <- base::computeRestarts
[17:38:06.790]                           grepl <- base::grepl
[17:38:06.790]                           restarts <- computeRestarts(cond)
[17:38:06.790]                           for (restart in restarts) {
[17:38:06.790]                             name <- restart$name
[17:38:06.790]                             if (is.null(name)) 
[17:38:06.790]                               next
[17:38:06.790]                             if (!grepl(pattern, name)) 
[17:38:06.790]                               next
[17:38:06.790]                             invokeRestart(restart)
[17:38:06.790]                             muffled <- TRUE
[17:38:06.790]                             break
[17:38:06.790]                           }
[17:38:06.790]                         }
[17:38:06.790]                       }
[17:38:06.790]                       invisible(muffled)
[17:38:06.790]                     }
[17:38:06.790]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.790]                   }
[17:38:06.790]                 }
[17:38:06.790]                 else {
[17:38:06.790]                   if (TRUE) {
[17:38:06.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.790]                     {
[17:38:06.790]                       inherits <- base::inherits
[17:38:06.790]                       invokeRestart <- base::invokeRestart
[17:38:06.790]                       is.null <- base::is.null
[17:38:06.790]                       muffled <- FALSE
[17:38:06.790]                       if (inherits(cond, "message")) {
[17:38:06.790]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.790]                         if (muffled) 
[17:38:06.790]                           invokeRestart("muffleMessage")
[17:38:06.790]                       }
[17:38:06.790]                       else if (inherits(cond, "warning")) {
[17:38:06.790]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.790]                         if (muffled) 
[17:38:06.790]                           invokeRestart("muffleWarning")
[17:38:06.790]                       }
[17:38:06.790]                       else if (inherits(cond, "condition")) {
[17:38:06.790]                         if (!is.null(pattern)) {
[17:38:06.790]                           computeRestarts <- base::computeRestarts
[17:38:06.790]                           grepl <- base::grepl
[17:38:06.790]                           restarts <- computeRestarts(cond)
[17:38:06.790]                           for (restart in restarts) {
[17:38:06.790]                             name <- restart$name
[17:38:06.790]                             if (is.null(name)) 
[17:38:06.790]                               next
[17:38:06.790]                             if (!grepl(pattern, name)) 
[17:38:06.790]                               next
[17:38:06.790]                             invokeRestart(restart)
[17:38:06.790]                             muffled <- TRUE
[17:38:06.790]                             break
[17:38:06.790]                           }
[17:38:06.790]                         }
[17:38:06.790]                       }
[17:38:06.790]                       invisible(muffled)
[17:38:06.790]                     }
[17:38:06.790]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.790]                   }
[17:38:06.790]                 }
[17:38:06.790]             }
[17:38:06.790]         }))
[17:38:06.790]     }, error = function(ex) {
[17:38:06.790]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:06.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.790]                 ...future.rng), started = ...future.startTime, 
[17:38:06.790]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:06.790]             version = "1.8"), class = "FutureResult")
[17:38:06.790]     }, finally = {
[17:38:06.790]         if (!identical(...future.workdir, getwd())) 
[17:38:06.790]             setwd(...future.workdir)
[17:38:06.790]         {
[17:38:06.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:06.790]                 ...future.oldOptions$nwarnings <- NULL
[17:38:06.790]             }
[17:38:06.790]             base::options(...future.oldOptions)
[17:38:06.790]             if (.Platform$OS.type == "windows") {
[17:38:06.790]                 old_names <- names(...future.oldEnvVars)
[17:38:06.790]                 envs <- base::Sys.getenv()
[17:38:06.790]                 names <- names(envs)
[17:38:06.790]                 common <- intersect(names, old_names)
[17:38:06.790]                 added <- setdiff(names, old_names)
[17:38:06.790]                 removed <- setdiff(old_names, names)
[17:38:06.790]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:06.790]                   envs[common]]
[17:38:06.790]                 NAMES <- toupper(changed)
[17:38:06.790]                 args <- list()
[17:38:06.790]                 for (kk in seq_along(NAMES)) {
[17:38:06.790]                   name <- changed[[kk]]
[17:38:06.790]                   NAME <- NAMES[[kk]]
[17:38:06.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.790]                     next
[17:38:06.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.790]                 }
[17:38:06.790]                 NAMES <- toupper(added)
[17:38:06.790]                 for (kk in seq_along(NAMES)) {
[17:38:06.790]                   name <- added[[kk]]
[17:38:06.790]                   NAME <- NAMES[[kk]]
[17:38:06.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.790]                     next
[17:38:06.790]                   args[[name]] <- ""
[17:38:06.790]                 }
[17:38:06.790]                 NAMES <- toupper(removed)
[17:38:06.790]                 for (kk in seq_along(NAMES)) {
[17:38:06.790]                   name <- removed[[kk]]
[17:38:06.790]                   NAME <- NAMES[[kk]]
[17:38:06.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.790]                     next
[17:38:06.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.790]                 }
[17:38:06.790]                 if (length(args) > 0) 
[17:38:06.790]                   base::do.call(base::Sys.setenv, args = args)
[17:38:06.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:06.790]             }
[17:38:06.790]             else {
[17:38:06.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:06.790]             }
[17:38:06.790]             {
[17:38:06.790]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:06.790]                   0L) {
[17:38:06.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:06.790]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:06.790]                   base::options(opts)
[17:38:06.790]                 }
[17:38:06.790]                 {
[17:38:06.790]                   {
[17:38:06.790]                     NULL
[17:38:06.790]                     RNGkind("Mersenne-Twister")
[17:38:06.790]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:06.790]                       inherits = FALSE)
[17:38:06.790]                   }
[17:38:06.790]                   options(future.plan = NULL)
[17:38:06.790]                   if (is.na(NA_character_)) 
[17:38:06.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:06.790]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:06.790]                     .init = FALSE)
[17:38:06.790]                 }
[17:38:06.790]             }
[17:38:06.790]         }
[17:38:06.790]     })
[17:38:06.790]     if (TRUE) {
[17:38:06.790]         base::sink(type = "output", split = FALSE)
[17:38:06.790]         if (TRUE) {
[17:38:06.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:06.790]         }
[17:38:06.790]         else {
[17:38:06.790]             ...future.result["stdout"] <- base::list(NULL)
[17:38:06.790]         }
[17:38:06.790]         base::close(...future.stdout)
[17:38:06.790]         ...future.stdout <- NULL
[17:38:06.790]     }
[17:38:06.790]     ...future.result$conditions <- ...future.conditions
[17:38:06.790]     ...future.result$finished <- base::Sys.time()
[17:38:06.790]     ...future.result
[17:38:06.790] }
[17:38:06.791] assign_globals() ...
[17:38:06.791] List of 11
[17:38:06.791]  $ ...future.FUN            :function (x, ...)  
[17:38:06.791]  $ x_FUN                    :function (x)  
[17:38:06.791]  $ times                    : int 4
[17:38:06.791]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.791]  $ stop_if_not              :function (...)  
[17:38:06.791]  $ dim                      : int [1:2] 2 2
[17:38:06.791]  $ valid_types              : chr [1:2] "logical" "integer"
[17:38:06.791]  $ future.call.arguments    : list()
[17:38:06.791]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.791]  $ ...future.elements_ii    :List of 10
[17:38:06.791]   ..$ : int 1
[17:38:06.791]   ..$ : int 2
[17:38:06.791]   ..$ : int 3
[17:38:06.791]   ..$ : int 4
[17:38:06.791]   ..$ : int 5
[17:38:06.791]   ..$ : int 6
[17:38:06.791]   ..$ : int 7
[17:38:06.791]   ..$ : int 8
[17:38:06.791]   ..$ : int 9
[17:38:06.791]   ..$ : int 10
[17:38:06.791]  $ ...future.seeds_ii       : NULL
[17:38:06.791]  $ ...future.globals.maxSize: NULL
[17:38:06.791]  - attr(*, "where")=List of 11
[17:38:06.791]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:06.791]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:06.791]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:06.791]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:06.791]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:06.791]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:06.791]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:06.791]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:06.791]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:06.791]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:06.791]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:06.791]  - attr(*, "resolved")= logi FALSE
[17:38:06.791]  - attr(*, "total_size")= num 97232
[17:38:06.791]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.791]  - attr(*, "already-done")= logi TRUE
[17:38:06.801] - copied ‘...future.FUN’ to environment
[17:38:06.801] - reassign environment for ‘x_FUN’
[17:38:06.801] - copied ‘x_FUN’ to environment
[17:38:06.801] - copied ‘times’ to environment
[17:38:06.801] - copied ‘stopf’ to environment
[17:38:06.802] - copied ‘stop_if_not’ to environment
[17:38:06.802] - copied ‘dim’ to environment
[17:38:06.802] - copied ‘valid_types’ to environment
[17:38:06.802] - copied ‘future.call.arguments’ to environment
[17:38:06.802] - copied ‘...future.elements_ii’ to environment
[17:38:06.802] - copied ‘...future.seeds_ii’ to environment
[17:38:06.802] - copied ‘...future.globals.maxSize’ to environment
[17:38:06.802] assign_globals() ... done
[17:38:06.803] plan(): Setting new future strategy stack:
[17:38:06.803] List of future strategies:
[17:38:06.803] 1. sequential:
[17:38:06.803]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.803]    - tweaked: FALSE
[17:38:06.803]    - call: NULL
[17:38:06.803] plan(): nbrOfWorkers() = 1
[17:38:06.804] plan(): Setting new future strategy stack:
[17:38:06.804] List of future strategies:
[17:38:06.804] 1. sequential:
[17:38:06.804]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.804]    - tweaked: FALSE
[17:38:06.804]    - call: plan(strategy)
[17:38:06.804] plan(): nbrOfWorkers() = 1
[17:38:06.805] SequentialFuture started (and completed)
[17:38:06.805] - Launch lazy future ... done
[17:38:06.805] run() for ‘SequentialFuture’ ... done
[17:38:06.805] Created future:
[17:38:06.805] SequentialFuture:
[17:38:06.805] Label: ‘future_vapply-1’
[17:38:06.805] Expression:
[17:38:06.805] {
[17:38:06.805]     do.call(function(...) {
[17:38:06.805]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.805]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.805]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.805]             on.exit(options(oopts), add = TRUE)
[17:38:06.805]         }
[17:38:06.805]         {
[17:38:06.805]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.805]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.805]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.805]             })
[17:38:06.805]         }
[17:38:06.805]     }, args = future.call.arguments)
[17:38:06.805] }
[17:38:06.805] Lazy evaluation: FALSE
[17:38:06.805] Asynchronous evaluation: FALSE
[17:38:06.805] Local evaluation: TRUE
[17:38:06.805] Environment: R_GlobalEnv
[17:38:06.805] Capture standard output: TRUE
[17:38:06.805] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:06.805] Globals: 11 objects totaling 95.50 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:06.805] Packages: 1 packages (‘future.apply’)
[17:38:06.805] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:06.805] Resolved: TRUE
[17:38:06.805] Value: 2.27 KiB of class ‘list’
[17:38:06.805] Early signaling: FALSE
[17:38:06.805] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:06.805] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.806] Chunk #1 of 1 ... DONE
[17:38:06.806] Launching 1 futures (chunks) ... DONE
[17:38:06.806] Resolving 1 futures (chunks) ...
[17:38:06.807] resolve() on list ...
[17:38:06.807]  recursive: 0
[17:38:06.807]  length: 1
[17:38:06.807] 
[17:38:06.807] resolved() for ‘SequentialFuture’ ...
[17:38:06.807] - state: ‘finished’
[17:38:06.807] - run: TRUE
[17:38:06.807] - result: ‘FutureResult’
[17:38:06.807] resolved() for ‘SequentialFuture’ ... done
[17:38:06.807] Future #1
[17:38:06.808] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:06.808] - nx: 1
[17:38:06.808] - relay: TRUE
[17:38:06.808] - stdout: TRUE
[17:38:06.808] - signal: TRUE
[17:38:06.808] - resignal: FALSE
[17:38:06.808] - force: TRUE
[17:38:06.808] - relayed: [n=1] FALSE
[17:38:06.808] - queued futures: [n=1] FALSE
[17:38:06.808]  - until=1
[17:38:06.808]  - relaying element #1
[17:38:06.809] - relayed: [n=1] TRUE
[17:38:06.809] - queued futures: [n=1] TRUE
[17:38:06.809] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:06.809]  length: 0 (resolved future 1)
[17:38:06.809] Relaying remaining futures
[17:38:06.809] signalConditionsASAP(NULL, pos=0) ...
[17:38:06.811] - nx: 1
[17:38:06.811] - relay: TRUE
[17:38:06.811] - stdout: TRUE
[17:38:06.811] - signal: TRUE
[17:38:06.811] - resignal: FALSE
[17:38:06.811] - force: TRUE
[17:38:06.812] - relayed: [n=1] TRUE
[17:38:06.812] - queued futures: [n=1] TRUE
 - flush all
[17:38:06.812] - relayed: [n=1] TRUE
[17:38:06.812] - queued futures: [n=1] TRUE
[17:38:06.812] signalConditionsASAP(NULL, pos=0) ... done
[17:38:06.812] resolve() on list ... DONE
[17:38:06.812]  - Number of value chunks collected: 1
[17:38:06.812] Resolving 1 futures (chunks) ... DONE
[17:38:06.812] Reducing values from 1 chunks ...
[17:38:06.813]  - Number of values collected after concatenation: 10
[17:38:06.813]  - Number of values expected: 10
[17:38:06.813] Reducing values from 1 chunks ... DONE
[17:38:06.813] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:38:06.814] future_lapply() ...
[17:38:06.815] Number of chunks: 1
[17:38:06.815] getGlobalsAndPackagesXApply() ...
[17:38:06.816]  - future.globals: TRUE
[17:38:06.816] getGlobalsAndPackages() ...
[17:38:06.816] Searching for globals...
[17:38:06.819] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:38:06.819] Searching for globals ... DONE
[17:38:06.819] Resolving globals: FALSE
[17:38:06.820] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[17:38:06.821] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:06.821] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.821] - packages: [1] ‘future.apply’
[17:38:06.821] getGlobalsAndPackages() ... DONE
[17:38:06.821]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.821]  - needed namespaces: [n=1] ‘future.apply’
[17:38:06.821] Finding globals ... DONE
[17:38:06.821]  - use_args: TRUE
[17:38:06.822]  - Getting '...' globals ...
[17:38:06.822] resolve() on list ...
[17:38:06.822]  recursive: 0
[17:38:06.822]  length: 1
[17:38:06.822]  elements: ‘...’
[17:38:06.822]  length: 0 (resolved future 1)
[17:38:06.822] resolve() on list ... DONE
[17:38:06.822]    - '...' content: [n=0] 
[17:38:06.823] List of 1
[17:38:06.823]  $ ...: list()
[17:38:06.823]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.823]  - attr(*, "where")=List of 1
[17:38:06.823]   ..$ ...:<environment: 0x5607ff636780> 
[17:38:06.823]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.823]  - attr(*, "resolved")= logi TRUE
[17:38:06.823]  - attr(*, "total_size")= num NA
[17:38:06.825]  - Getting '...' globals ... DONE
[17:38:06.825] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:06.825] List of 8
[17:38:06.825]  $ ...future.FUN:function (x, ...)  
[17:38:06.825]  $ x_FUN        :function (x)  
[17:38:06.825]  $ times        : int 4
[17:38:06.825]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.825]  $ stop_if_not  :function (...)  
[17:38:06.825]  $ dim          : int [1:2] 2 2
[17:38:06.825]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:06.825]  $ ...          : list()
[17:38:06.825]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.825]  - attr(*, "where")=List of 8
[17:38:06.825]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:06.825]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:06.825]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:06.825]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:06.825]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:06.825]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:06.825]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:06.825]   ..$ ...          :<environment: 0x5607ff636780> 
[17:38:06.825]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.825]  - attr(*, "resolved")= logi FALSE
[17:38:06.825]  - attr(*, "total_size")= num 97304
[17:38:06.831] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:06.831] getGlobalsAndPackagesXApply() ... DONE
[17:38:06.831] Number of futures (= number of chunks): 1
[17:38:06.831] Launching 1 futures (chunks) ...
[17:38:06.831] Chunk #1 of 1 ...
[17:38:06.831]  - Finding globals in 'X' for chunk #1 ...
[17:38:06.831] getGlobalsAndPackages() ...
[17:38:06.831] Searching for globals...
[17:38:06.833] 
[17:38:06.833] Searching for globals ... DONE
[17:38:06.833] - globals: [0] <none>
[17:38:06.833] getGlobalsAndPackages() ... DONE
[17:38:06.833]    + additional globals found: [n=0] 
[17:38:06.834]    + additional namespaces needed: [n=0] 
[17:38:06.834]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:06.834]  - seeds: <none>
[17:38:06.834]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.834] getGlobalsAndPackages() ...
[17:38:06.834] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.834] Resolving globals: FALSE
[17:38:06.834] Tweak future expression to call with '...' arguments ...
[17:38:06.834] {
[17:38:06.834]     do.call(function(...) {
[17:38:06.834]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.834]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.834]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.834]             on.exit(options(oopts), add = TRUE)
[17:38:06.834]         }
[17:38:06.834]         {
[17:38:06.834]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.834]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.834]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.834]             })
[17:38:06.834]         }
[17:38:06.834]     }, args = future.call.arguments)
[17:38:06.834] }
[17:38:06.835] Tweak future expression to call with '...' arguments ... DONE
[17:38:06.835] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.835] - packages: [1] ‘future.apply’
[17:38:06.835] getGlobalsAndPackages() ... DONE
[17:38:06.836] run() for ‘Future’ ...
[17:38:06.836] - state: ‘created’
[17:38:06.836] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:06.836] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.836] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:06.836]   - Field: ‘label’
[17:38:06.836]   - Field: ‘local’
[17:38:06.837]   - Field: ‘owner’
[17:38:06.837]   - Field: ‘envir’
[17:38:06.837]   - Field: ‘packages’
[17:38:06.837]   - Field: ‘gc’
[17:38:06.837]   - Field: ‘conditions’
[17:38:06.837]   - Field: ‘expr’
[17:38:06.837]   - Field: ‘uuid’
[17:38:06.837]   - Field: ‘seed’
[17:38:06.837]   - Field: ‘version’
[17:38:06.837]   - Field: ‘result’
[17:38:06.837]   - Field: ‘asynchronous’
[17:38:06.838]   - Field: ‘calls’
[17:38:06.838]   - Field: ‘globals’
[17:38:06.838]   - Field: ‘stdout’
[17:38:06.838]   - Field: ‘earlySignal’
[17:38:06.838]   - Field: ‘lazy’
[17:38:06.838]   - Field: ‘state’
[17:38:06.838] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:06.838] - Launch lazy future ...
[17:38:06.838] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:06.838] Packages needed by future strategies (n = 0): <none>
[17:38:06.839] {
[17:38:06.839]     {
[17:38:06.839]         {
[17:38:06.839]             ...future.startTime <- base::Sys.time()
[17:38:06.839]             {
[17:38:06.839]                 {
[17:38:06.839]                   {
[17:38:06.839]                     {
[17:38:06.839]                       base::local({
[17:38:06.839]                         has_future <- base::requireNamespace("future", 
[17:38:06.839]                           quietly = TRUE)
[17:38:06.839]                         if (has_future) {
[17:38:06.839]                           ns <- base::getNamespace("future")
[17:38:06.839]                           version <- ns[[".package"]][["version"]]
[17:38:06.839]                           if (is.null(version)) 
[17:38:06.839]                             version <- utils::packageVersion("future")
[17:38:06.839]                         }
[17:38:06.839]                         else {
[17:38:06.839]                           version <- NULL
[17:38:06.839]                         }
[17:38:06.839]                         if (!has_future || version < "1.8.0") {
[17:38:06.839]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:06.839]                             "", base::R.version$version.string), 
[17:38:06.839]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:06.839]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:06.839]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:06.839]                               "release", "version")], collapse = " "), 
[17:38:06.839]                             hostname = base::Sys.info()[["nodename"]])
[17:38:06.839]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:06.839]                             info)
[17:38:06.839]                           info <- base::paste(info, collapse = "; ")
[17:38:06.839]                           if (!has_future) {
[17:38:06.839]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:06.839]                               info)
[17:38:06.839]                           }
[17:38:06.839]                           else {
[17:38:06.839]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:06.839]                               info, version)
[17:38:06.839]                           }
[17:38:06.839]                           base::stop(msg)
[17:38:06.839]                         }
[17:38:06.839]                       })
[17:38:06.839]                     }
[17:38:06.839]                     base::local({
[17:38:06.839]                       for (pkg in "future.apply") {
[17:38:06.839]                         base::loadNamespace(pkg)
[17:38:06.839]                         base::library(pkg, character.only = TRUE)
[17:38:06.839]                       }
[17:38:06.839]                     })
[17:38:06.839]                   }
[17:38:06.839]                   ...future.strategy.old <- future::plan("list")
[17:38:06.839]                   options(future.plan = NULL)
[17:38:06.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.839]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:06.839]                 }
[17:38:06.839]                 ...future.workdir <- getwd()
[17:38:06.839]             }
[17:38:06.839]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:06.839]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:06.839]         }
[17:38:06.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:06.839]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:06.839]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:06.839]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:06.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:06.839]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:06.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:06.839]             base::names(...future.oldOptions))
[17:38:06.839]     }
[17:38:06.839]     if (FALSE) {
[17:38:06.839]     }
[17:38:06.839]     else {
[17:38:06.839]         if (TRUE) {
[17:38:06.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:06.839]                 open = "w")
[17:38:06.839]         }
[17:38:06.839]         else {
[17:38:06.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:06.839]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:06.839]         }
[17:38:06.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:06.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:06.839]             base::sink(type = "output", split = FALSE)
[17:38:06.839]             base::close(...future.stdout)
[17:38:06.839]         }, add = TRUE)
[17:38:06.839]     }
[17:38:06.839]     ...future.frame <- base::sys.nframe()
[17:38:06.839]     ...future.conditions <- base::list()
[17:38:06.839]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:06.839]     if (FALSE) {
[17:38:06.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:06.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:06.839]     }
[17:38:06.839]     ...future.result <- base::tryCatch({
[17:38:06.839]         base::withCallingHandlers({
[17:38:06.839]             ...future.value <- base::withVisible(base::local({
[17:38:06.839]                 do.call(function(...) {
[17:38:06.839]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.839]                   if (!identical(...future.globals.maxSize.org, 
[17:38:06.839]                     ...future.globals.maxSize)) {
[17:38:06.839]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.839]                     on.exit(options(oopts), add = TRUE)
[17:38:06.839]                   }
[17:38:06.839]                   {
[17:38:06.839]                     lapply(seq_along(...future.elements_ii), 
[17:38:06.839]                       FUN = function(jj) {
[17:38:06.839]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.839]                         ...future.FUN(...future.X_jj, ...)
[17:38:06.839]                       })
[17:38:06.839]                   }
[17:38:06.839]                 }, args = future.call.arguments)
[17:38:06.839]             }))
[17:38:06.839]             future::FutureResult(value = ...future.value$value, 
[17:38:06.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.839]                   ...future.rng), globalenv = if (FALSE) 
[17:38:06.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:06.839]                     ...future.globalenv.names))
[17:38:06.839]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:06.839]         }, condition = base::local({
[17:38:06.839]             c <- base::c
[17:38:06.839]             inherits <- base::inherits
[17:38:06.839]             invokeRestart <- base::invokeRestart
[17:38:06.839]             length <- base::length
[17:38:06.839]             list <- base::list
[17:38:06.839]             seq.int <- base::seq.int
[17:38:06.839]             signalCondition <- base::signalCondition
[17:38:06.839]             sys.calls <- base::sys.calls
[17:38:06.839]             `[[` <- base::`[[`
[17:38:06.839]             `+` <- base::`+`
[17:38:06.839]             `<<-` <- base::`<<-`
[17:38:06.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:06.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:06.839]                   3L)]
[17:38:06.839]             }
[17:38:06.839]             function(cond) {
[17:38:06.839]                 is_error <- inherits(cond, "error")
[17:38:06.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:06.839]                   NULL)
[17:38:06.839]                 if (is_error) {
[17:38:06.839]                   sessionInformation <- function() {
[17:38:06.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:06.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:06.839]                       search = base::search(), system = base::Sys.info())
[17:38:06.839]                   }
[17:38:06.839]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:06.839]                     cond$call), session = sessionInformation(), 
[17:38:06.839]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:06.839]                   signalCondition(cond)
[17:38:06.839]                 }
[17:38:06.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:06.839]                 "immediateCondition"))) {
[17:38:06.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:06.839]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:06.839]                   if (TRUE && !signal) {
[17:38:06.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.839]                     {
[17:38:06.839]                       inherits <- base::inherits
[17:38:06.839]                       invokeRestart <- base::invokeRestart
[17:38:06.839]                       is.null <- base::is.null
[17:38:06.839]                       muffled <- FALSE
[17:38:06.839]                       if (inherits(cond, "message")) {
[17:38:06.839]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.839]                         if (muffled) 
[17:38:06.839]                           invokeRestart("muffleMessage")
[17:38:06.839]                       }
[17:38:06.839]                       else if (inherits(cond, "warning")) {
[17:38:06.839]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.839]                         if (muffled) 
[17:38:06.839]                           invokeRestart("muffleWarning")
[17:38:06.839]                       }
[17:38:06.839]                       else if (inherits(cond, "condition")) {
[17:38:06.839]                         if (!is.null(pattern)) {
[17:38:06.839]                           computeRestarts <- base::computeRestarts
[17:38:06.839]                           grepl <- base::grepl
[17:38:06.839]                           restarts <- computeRestarts(cond)
[17:38:06.839]                           for (restart in restarts) {
[17:38:06.839]                             name <- restart$name
[17:38:06.839]                             if (is.null(name)) 
[17:38:06.839]                               next
[17:38:06.839]                             if (!grepl(pattern, name)) 
[17:38:06.839]                               next
[17:38:06.839]                             invokeRestart(restart)
[17:38:06.839]                             muffled <- TRUE
[17:38:06.839]                             break
[17:38:06.839]                           }
[17:38:06.839]                         }
[17:38:06.839]                       }
[17:38:06.839]                       invisible(muffled)
[17:38:06.839]                     }
[17:38:06.839]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.839]                   }
[17:38:06.839]                 }
[17:38:06.839]                 else {
[17:38:06.839]                   if (TRUE) {
[17:38:06.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.839]                     {
[17:38:06.839]                       inherits <- base::inherits
[17:38:06.839]                       invokeRestart <- base::invokeRestart
[17:38:06.839]                       is.null <- base::is.null
[17:38:06.839]                       muffled <- FALSE
[17:38:06.839]                       if (inherits(cond, "message")) {
[17:38:06.839]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.839]                         if (muffled) 
[17:38:06.839]                           invokeRestart("muffleMessage")
[17:38:06.839]                       }
[17:38:06.839]                       else if (inherits(cond, "warning")) {
[17:38:06.839]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.839]                         if (muffled) 
[17:38:06.839]                           invokeRestart("muffleWarning")
[17:38:06.839]                       }
[17:38:06.839]                       else if (inherits(cond, "condition")) {
[17:38:06.839]                         if (!is.null(pattern)) {
[17:38:06.839]                           computeRestarts <- base::computeRestarts
[17:38:06.839]                           grepl <- base::grepl
[17:38:06.839]                           restarts <- computeRestarts(cond)
[17:38:06.839]                           for (restart in restarts) {
[17:38:06.839]                             name <- restart$name
[17:38:06.839]                             if (is.null(name)) 
[17:38:06.839]                               next
[17:38:06.839]                             if (!grepl(pattern, name)) 
[17:38:06.839]                               next
[17:38:06.839]                             invokeRestart(restart)
[17:38:06.839]                             muffled <- TRUE
[17:38:06.839]                             break
[17:38:06.839]                           }
[17:38:06.839]                         }
[17:38:06.839]                       }
[17:38:06.839]                       invisible(muffled)
[17:38:06.839]                     }
[17:38:06.839]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.839]                   }
[17:38:06.839]                 }
[17:38:06.839]             }
[17:38:06.839]         }))
[17:38:06.839]     }, error = function(ex) {
[17:38:06.839]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:06.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.839]                 ...future.rng), started = ...future.startTime, 
[17:38:06.839]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:06.839]             version = "1.8"), class = "FutureResult")
[17:38:06.839]     }, finally = {
[17:38:06.839]         if (!identical(...future.workdir, getwd())) 
[17:38:06.839]             setwd(...future.workdir)
[17:38:06.839]         {
[17:38:06.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:06.839]                 ...future.oldOptions$nwarnings <- NULL
[17:38:06.839]             }
[17:38:06.839]             base::options(...future.oldOptions)
[17:38:06.839]             if (.Platform$OS.type == "windows") {
[17:38:06.839]                 old_names <- names(...future.oldEnvVars)
[17:38:06.839]                 envs <- base::Sys.getenv()
[17:38:06.839]                 names <- names(envs)
[17:38:06.839]                 common <- intersect(names, old_names)
[17:38:06.839]                 added <- setdiff(names, old_names)
[17:38:06.839]                 removed <- setdiff(old_names, names)
[17:38:06.839]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:06.839]                   envs[common]]
[17:38:06.839]                 NAMES <- toupper(changed)
[17:38:06.839]                 args <- list()
[17:38:06.839]                 for (kk in seq_along(NAMES)) {
[17:38:06.839]                   name <- changed[[kk]]
[17:38:06.839]                   NAME <- NAMES[[kk]]
[17:38:06.839]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.839]                     next
[17:38:06.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.839]                 }
[17:38:06.839]                 NAMES <- toupper(added)
[17:38:06.839]                 for (kk in seq_along(NAMES)) {
[17:38:06.839]                   name <- added[[kk]]
[17:38:06.839]                   NAME <- NAMES[[kk]]
[17:38:06.839]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.839]                     next
[17:38:06.839]                   args[[name]] <- ""
[17:38:06.839]                 }
[17:38:06.839]                 NAMES <- toupper(removed)
[17:38:06.839]                 for (kk in seq_along(NAMES)) {
[17:38:06.839]                   name <- removed[[kk]]
[17:38:06.839]                   NAME <- NAMES[[kk]]
[17:38:06.839]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.839]                     next
[17:38:06.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.839]                 }
[17:38:06.839]                 if (length(args) > 0) 
[17:38:06.839]                   base::do.call(base::Sys.setenv, args = args)
[17:38:06.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:06.839]             }
[17:38:06.839]             else {
[17:38:06.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:06.839]             }
[17:38:06.839]             {
[17:38:06.839]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:06.839]                   0L) {
[17:38:06.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:06.839]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:06.839]                   base::options(opts)
[17:38:06.839]                 }
[17:38:06.839]                 {
[17:38:06.839]                   {
[17:38:06.839]                     NULL
[17:38:06.839]                     RNGkind("Mersenne-Twister")
[17:38:06.839]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:06.839]                       inherits = FALSE)
[17:38:06.839]                   }
[17:38:06.839]                   options(future.plan = NULL)
[17:38:06.839]                   if (is.na(NA_character_)) 
[17:38:06.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:06.839]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:06.839]                     .init = FALSE)
[17:38:06.839]                 }
[17:38:06.839]             }
[17:38:06.839]         }
[17:38:06.839]     })
[17:38:06.839]     if (TRUE) {
[17:38:06.839]         base::sink(type = "output", split = FALSE)
[17:38:06.839]         if (TRUE) {
[17:38:06.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:06.839]         }
[17:38:06.839]         else {
[17:38:06.839]             ...future.result["stdout"] <- base::list(NULL)
[17:38:06.839]         }
[17:38:06.839]         base::close(...future.stdout)
[17:38:06.839]         ...future.stdout <- NULL
[17:38:06.839]     }
[17:38:06.839]     ...future.result$conditions <- ...future.conditions
[17:38:06.839]     ...future.result$finished <- base::Sys.time()
[17:38:06.839]     ...future.result
[17:38:06.839] }
[17:38:06.841] assign_globals() ...
[17:38:06.841] List of 11
[17:38:06.841]  $ ...future.FUN            :function (x, ...)  
[17:38:06.841]  $ x_FUN                    :function (x)  
[17:38:06.841]  $ times                    : int 4
[17:38:06.841]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.841]  $ stop_if_not              :function (...)  
[17:38:06.841]  $ dim                      : int [1:2] 2 2
[17:38:06.841]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:06.841]  $ future.call.arguments    : list()
[17:38:06.841]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.841]  $ ...future.elements_ii    :List of 10
[17:38:06.841]   ..$ : int 1
[17:38:06.841]   ..$ : int 2
[17:38:06.841]   ..$ : int 3
[17:38:06.841]   ..$ : int 4
[17:38:06.841]   ..$ : int 5
[17:38:06.841]   ..$ : int 6
[17:38:06.841]   ..$ : int 7
[17:38:06.841]   ..$ : int 8
[17:38:06.841]   ..$ : int 9
[17:38:06.841]   ..$ : int 10
[17:38:06.841]  $ ...future.seeds_ii       : NULL
[17:38:06.841]  $ ...future.globals.maxSize: NULL
[17:38:06.841]  - attr(*, "where")=List of 11
[17:38:06.841]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:06.841]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:06.841]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:06.841]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:06.841]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:06.841]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:06.841]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:06.841]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:06.841]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:06.841]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:06.841]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:06.841]  - attr(*, "resolved")= logi FALSE
[17:38:06.841]  - attr(*, "total_size")= num 97304
[17:38:06.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.841]  - attr(*, "already-done")= logi TRUE
[17:38:06.850] - copied ‘...future.FUN’ to environment
[17:38:06.850] - reassign environment for ‘x_FUN’
[17:38:06.850] - copied ‘x_FUN’ to environment
[17:38:06.851] - copied ‘times’ to environment
[17:38:06.851] - copied ‘stopf’ to environment
[17:38:06.851] - copied ‘stop_if_not’ to environment
[17:38:06.851] - copied ‘dim’ to environment
[17:38:06.851] - copied ‘valid_types’ to environment
[17:38:06.851] - copied ‘future.call.arguments’ to environment
[17:38:06.851] - copied ‘...future.elements_ii’ to environment
[17:38:06.851] - copied ‘...future.seeds_ii’ to environment
[17:38:06.851] - copied ‘...future.globals.maxSize’ to environment
[17:38:06.851] assign_globals() ... done
[17:38:06.852] plan(): Setting new future strategy stack:
[17:38:06.852] List of future strategies:
[17:38:06.852] 1. sequential:
[17:38:06.852]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.852]    - tweaked: FALSE
[17:38:06.852]    - call: NULL
[17:38:06.852] plan(): nbrOfWorkers() = 1
[17:38:06.853] plan(): Setting new future strategy stack:
[17:38:06.853] List of future strategies:
[17:38:06.853] 1. sequential:
[17:38:06.853]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.853]    - tweaked: FALSE
[17:38:06.853]    - call: plan(strategy)
[17:38:06.854] plan(): nbrOfWorkers() = 1
[17:38:06.854] SequentialFuture started (and completed)
[17:38:06.854] - Launch lazy future ... done
[17:38:06.854] run() for ‘SequentialFuture’ ... done
[17:38:06.854] Created future:
[17:38:06.854] SequentialFuture:
[17:38:06.854] Label: ‘future_vapply-1’
[17:38:06.854] Expression:
[17:38:06.854] {
[17:38:06.854]     do.call(function(...) {
[17:38:06.854]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.854]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.854]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.854]             on.exit(options(oopts), add = TRUE)
[17:38:06.854]         }
[17:38:06.854]         {
[17:38:06.854]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.854]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.854]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.854]             })
[17:38:06.854]         }
[17:38:06.854]     }, args = future.call.arguments)
[17:38:06.854] }
[17:38:06.854] Lazy evaluation: FALSE
[17:38:06.854] Asynchronous evaluation: FALSE
[17:38:06.854] Local evaluation: TRUE
[17:38:06.854] Environment: R_GlobalEnv
[17:38:06.854] Capture standard output: TRUE
[17:38:06.854] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:06.854] Globals: 11 objects totaling 95.57 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:06.854] Packages: 1 packages (‘future.apply’)
[17:38:06.854] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:06.854] Resolved: TRUE
[17:38:06.854] Value: 2.27 KiB of class ‘list’
[17:38:06.854] Early signaling: FALSE
[17:38:06.854] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:06.854] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.857] Chunk #1 of 1 ... DONE
[17:38:06.857] Launching 1 futures (chunks) ... DONE
[17:38:06.857] Resolving 1 futures (chunks) ...
[17:38:06.857] resolve() on list ...
[17:38:06.857]  recursive: 0
[17:38:06.857]  length: 1
[17:38:06.858] 
[17:38:06.858] resolved() for ‘SequentialFuture’ ...
[17:38:06.858] - state: ‘finished’
[17:38:06.858] - run: TRUE
[17:38:06.858] - result: ‘FutureResult’
[17:38:06.858] resolved() for ‘SequentialFuture’ ... done
[17:38:06.858] Future #1
[17:38:06.858] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:06.858] - nx: 1
[17:38:06.858] - relay: TRUE
[17:38:06.859] - stdout: TRUE
[17:38:06.859] - signal: TRUE
[17:38:06.859] - resignal: FALSE
[17:38:06.859] - force: TRUE
[17:38:06.859] - relayed: [n=1] FALSE
[17:38:06.859] - queued futures: [n=1] FALSE
[17:38:06.859]  - until=1
[17:38:06.859]  - relaying element #1
[17:38:06.859] - relayed: [n=1] TRUE
[17:38:06.859] - queued futures: [n=1] TRUE
[17:38:06.859] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:06.860]  length: 0 (resolved future 1)
[17:38:06.860] Relaying remaining futures
[17:38:06.860] signalConditionsASAP(NULL, pos=0) ...
[17:38:06.860] - nx: 1
[17:38:06.860] - relay: TRUE
[17:38:06.860] - stdout: TRUE
[17:38:06.860] - signal: TRUE
[17:38:06.860] - resignal: FALSE
[17:38:06.860] - force: TRUE
[17:38:06.860] - relayed: [n=1] TRUE
[17:38:06.860] - queued futures: [n=1] TRUE
 - flush all
[17:38:06.861] - relayed: [n=1] TRUE
[17:38:06.861] - queued futures: [n=1] TRUE
[17:38:06.861] signalConditionsASAP(NULL, pos=0) ... done
[17:38:06.861] resolve() on list ... DONE
[17:38:06.861]  - Number of value chunks collected: 1
[17:38:06.861] Resolving 1 futures (chunks) ... DONE
[17:38:06.861] Reducing values from 1 chunks ...
[17:38:06.861]  - Number of values collected after concatenation: 10
[17:38:06.861]  - Number of values expected: 10
[17:38:06.861] Reducing values from 1 chunks ... DONE
[17:38:06.862] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[17:38:06.863] future_lapply() ...
[17:38:06.865] Number of chunks: 1
[17:38:06.865] getGlobalsAndPackagesXApply() ...
[17:38:06.865]  - future.globals: TRUE
[17:38:06.865] getGlobalsAndPackages() ...
[17:38:06.865] Searching for globals...
[17:38:06.869] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[17:38:06.869] Searching for globals ... DONE
[17:38:06.869] Resolving globals: FALSE
[17:38:06.870] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[17:38:06.871] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:06.871] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.871] - packages: [1] ‘future.apply’
[17:38:06.871] getGlobalsAndPackages() ... DONE
[17:38:06.871]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.871]  - needed namespaces: [n=1] ‘future.apply’
[17:38:06.871] Finding globals ... DONE
[17:38:06.871]  - use_args: TRUE
[17:38:06.871]  - Getting '...' globals ...
[17:38:06.872] resolve() on list ...
[17:38:06.872]  recursive: 0
[17:38:06.872]  length: 1
[17:38:06.872]  elements: ‘...’
[17:38:06.872]  length: 0 (resolved future 1)
[17:38:06.872] resolve() on list ... DONE
[17:38:06.872]    - '...' content: [n=0] 
[17:38:06.872] List of 1
[17:38:06.872]  $ ...: list()
[17:38:06.872]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.872]  - attr(*, "where")=List of 1
[17:38:06.872]   ..$ ...:<environment: 0x56080004e448> 
[17:38:06.872]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.872]  - attr(*, "resolved")= logi TRUE
[17:38:06.872]  - attr(*, "total_size")= num NA
[17:38:06.875]  - Getting '...' globals ... DONE
[17:38:06.875] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:06.875] List of 8
[17:38:06.875]  $ ...future.FUN:function (x, ...)  
[17:38:06.875]  $ x_FUN        :function (x)  
[17:38:06.875]  $ times        : int 4
[17:38:06.875]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.875]  $ stop_if_not  :function (...)  
[17:38:06.875]  $ dim          : int [1:2] 2 2
[17:38:06.875]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:06.875]  $ ...          : list()
[17:38:06.875]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.875]  - attr(*, "where")=List of 8
[17:38:06.875]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:06.875]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:06.875]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:06.875]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:06.875]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:06.875]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:06.875]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:06.875]   ..$ ...          :<environment: 0x56080004e448> 
[17:38:06.875]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.875]  - attr(*, "resolved")= logi FALSE
[17:38:06.875]  - attr(*, "total_size")= num 105552
[17:38:06.908] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:06.909] getGlobalsAndPackagesXApply() ... DONE
[17:38:06.909] Number of futures (= number of chunks): 1
[17:38:06.909] Launching 1 futures (chunks) ...
[17:38:06.909] Chunk #1 of 1 ...
[17:38:06.909]  - Finding globals in 'X' for chunk #1 ...
[17:38:06.909] getGlobalsAndPackages() ...
[17:38:06.909] Searching for globals...
[17:38:06.910] 
[17:38:06.910] Searching for globals ... DONE
[17:38:06.910] - globals: [0] <none>
[17:38:06.910] getGlobalsAndPackages() ... DONE
[17:38:06.910]    + additional globals found: [n=0] 
[17:38:06.910]    + additional namespaces needed: [n=0] 
[17:38:06.910]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:06.910]  - seeds: <none>
[17:38:06.910]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.910] getGlobalsAndPackages() ...
[17:38:06.910] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.911] Resolving globals: FALSE
[17:38:06.911] Tweak future expression to call with '...' arguments ...
[17:38:06.911] {
[17:38:06.911]     do.call(function(...) {
[17:38:06.911]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.911]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.911]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.911]             on.exit(options(oopts), add = TRUE)
[17:38:06.911]         }
[17:38:06.911]         {
[17:38:06.911]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.911]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.911]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.911]             })
[17:38:06.911]         }
[17:38:06.911]     }, args = future.call.arguments)
[17:38:06.911] }
[17:38:06.911] Tweak future expression to call with '...' arguments ... DONE
[17:38:06.912] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.912] - packages: [1] ‘future.apply’
[17:38:06.912] getGlobalsAndPackages() ... DONE
[17:38:06.912] run() for ‘Future’ ...
[17:38:06.912] - state: ‘created’
[17:38:06.912] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:06.913] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.913] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:06.913]   - Field: ‘label’
[17:38:06.913]   - Field: ‘local’
[17:38:06.913]   - Field: ‘owner’
[17:38:06.913]   - Field: ‘envir’
[17:38:06.913]   - Field: ‘packages’
[17:38:06.913]   - Field: ‘gc’
[17:38:06.913]   - Field: ‘conditions’
[17:38:06.914]   - Field: ‘expr’
[17:38:06.914]   - Field: ‘uuid’
[17:38:06.914]   - Field: ‘seed’
[17:38:06.914]   - Field: ‘version’
[17:38:06.914]   - Field: ‘result’
[17:38:06.914]   - Field: ‘asynchronous’
[17:38:06.914]   - Field: ‘calls’
[17:38:06.914]   - Field: ‘globals’
[17:38:06.914]   - Field: ‘stdout’
[17:38:06.914]   - Field: ‘earlySignal’
[17:38:06.914]   - Field: ‘lazy’
[17:38:06.915]   - Field: ‘state’
[17:38:06.915] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:06.915] - Launch lazy future ...
[17:38:06.915] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:06.915] Packages needed by future strategies (n = 0): <none>
[17:38:06.916] {
[17:38:06.916]     {
[17:38:06.916]         {
[17:38:06.916]             ...future.startTime <- base::Sys.time()
[17:38:06.916]             {
[17:38:06.916]                 {
[17:38:06.916]                   {
[17:38:06.916]                     {
[17:38:06.916]                       base::local({
[17:38:06.916]                         has_future <- base::requireNamespace("future", 
[17:38:06.916]                           quietly = TRUE)
[17:38:06.916]                         if (has_future) {
[17:38:06.916]                           ns <- base::getNamespace("future")
[17:38:06.916]                           version <- ns[[".package"]][["version"]]
[17:38:06.916]                           if (is.null(version)) 
[17:38:06.916]                             version <- utils::packageVersion("future")
[17:38:06.916]                         }
[17:38:06.916]                         else {
[17:38:06.916]                           version <- NULL
[17:38:06.916]                         }
[17:38:06.916]                         if (!has_future || version < "1.8.0") {
[17:38:06.916]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:06.916]                             "", base::R.version$version.string), 
[17:38:06.916]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:06.916]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:06.916]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:06.916]                               "release", "version")], collapse = " "), 
[17:38:06.916]                             hostname = base::Sys.info()[["nodename"]])
[17:38:06.916]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:06.916]                             info)
[17:38:06.916]                           info <- base::paste(info, collapse = "; ")
[17:38:06.916]                           if (!has_future) {
[17:38:06.916]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:06.916]                               info)
[17:38:06.916]                           }
[17:38:06.916]                           else {
[17:38:06.916]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:06.916]                               info, version)
[17:38:06.916]                           }
[17:38:06.916]                           base::stop(msg)
[17:38:06.916]                         }
[17:38:06.916]                       })
[17:38:06.916]                     }
[17:38:06.916]                     base::local({
[17:38:06.916]                       for (pkg in "future.apply") {
[17:38:06.916]                         base::loadNamespace(pkg)
[17:38:06.916]                         base::library(pkg, character.only = TRUE)
[17:38:06.916]                       }
[17:38:06.916]                     })
[17:38:06.916]                   }
[17:38:06.916]                   ...future.strategy.old <- future::plan("list")
[17:38:06.916]                   options(future.plan = NULL)
[17:38:06.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:06.916]                 }
[17:38:06.916]                 ...future.workdir <- getwd()
[17:38:06.916]             }
[17:38:06.916]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:06.916]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:06.916]         }
[17:38:06.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:06.916]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:06.916]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:06.916]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:06.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:06.916]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:06.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:06.916]             base::names(...future.oldOptions))
[17:38:06.916]     }
[17:38:06.916]     if (FALSE) {
[17:38:06.916]     }
[17:38:06.916]     else {
[17:38:06.916]         if (TRUE) {
[17:38:06.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:06.916]                 open = "w")
[17:38:06.916]         }
[17:38:06.916]         else {
[17:38:06.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:06.916]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:06.916]         }
[17:38:06.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:06.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:06.916]             base::sink(type = "output", split = FALSE)
[17:38:06.916]             base::close(...future.stdout)
[17:38:06.916]         }, add = TRUE)
[17:38:06.916]     }
[17:38:06.916]     ...future.frame <- base::sys.nframe()
[17:38:06.916]     ...future.conditions <- base::list()
[17:38:06.916]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:06.916]     if (FALSE) {
[17:38:06.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:06.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:06.916]     }
[17:38:06.916]     ...future.result <- base::tryCatch({
[17:38:06.916]         base::withCallingHandlers({
[17:38:06.916]             ...future.value <- base::withVisible(base::local({
[17:38:06.916]                 do.call(function(...) {
[17:38:06.916]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.916]                   if (!identical(...future.globals.maxSize.org, 
[17:38:06.916]                     ...future.globals.maxSize)) {
[17:38:06.916]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.916]                     on.exit(options(oopts), add = TRUE)
[17:38:06.916]                   }
[17:38:06.916]                   {
[17:38:06.916]                     lapply(seq_along(...future.elements_ii), 
[17:38:06.916]                       FUN = function(jj) {
[17:38:06.916]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.916]                         ...future.FUN(...future.X_jj, ...)
[17:38:06.916]                       })
[17:38:06.916]                   }
[17:38:06.916]                 }, args = future.call.arguments)
[17:38:06.916]             }))
[17:38:06.916]             future::FutureResult(value = ...future.value$value, 
[17:38:06.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.916]                   ...future.rng), globalenv = if (FALSE) 
[17:38:06.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:06.916]                     ...future.globalenv.names))
[17:38:06.916]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:06.916]         }, condition = base::local({
[17:38:06.916]             c <- base::c
[17:38:06.916]             inherits <- base::inherits
[17:38:06.916]             invokeRestart <- base::invokeRestart
[17:38:06.916]             length <- base::length
[17:38:06.916]             list <- base::list
[17:38:06.916]             seq.int <- base::seq.int
[17:38:06.916]             signalCondition <- base::signalCondition
[17:38:06.916]             sys.calls <- base::sys.calls
[17:38:06.916]             `[[` <- base::`[[`
[17:38:06.916]             `+` <- base::`+`
[17:38:06.916]             `<<-` <- base::`<<-`
[17:38:06.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:06.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:06.916]                   3L)]
[17:38:06.916]             }
[17:38:06.916]             function(cond) {
[17:38:06.916]                 is_error <- inherits(cond, "error")
[17:38:06.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:06.916]                   NULL)
[17:38:06.916]                 if (is_error) {
[17:38:06.916]                   sessionInformation <- function() {
[17:38:06.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:06.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:06.916]                       search = base::search(), system = base::Sys.info())
[17:38:06.916]                   }
[17:38:06.916]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:06.916]                     cond$call), session = sessionInformation(), 
[17:38:06.916]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:06.916]                   signalCondition(cond)
[17:38:06.916]                 }
[17:38:06.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:06.916]                 "immediateCondition"))) {
[17:38:06.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:06.916]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:06.916]                   if (TRUE && !signal) {
[17:38:06.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.916]                     {
[17:38:06.916]                       inherits <- base::inherits
[17:38:06.916]                       invokeRestart <- base::invokeRestart
[17:38:06.916]                       is.null <- base::is.null
[17:38:06.916]                       muffled <- FALSE
[17:38:06.916]                       if (inherits(cond, "message")) {
[17:38:06.916]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.916]                         if (muffled) 
[17:38:06.916]                           invokeRestart("muffleMessage")
[17:38:06.916]                       }
[17:38:06.916]                       else if (inherits(cond, "warning")) {
[17:38:06.916]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.916]                         if (muffled) 
[17:38:06.916]                           invokeRestart("muffleWarning")
[17:38:06.916]                       }
[17:38:06.916]                       else if (inherits(cond, "condition")) {
[17:38:06.916]                         if (!is.null(pattern)) {
[17:38:06.916]                           computeRestarts <- base::computeRestarts
[17:38:06.916]                           grepl <- base::grepl
[17:38:06.916]                           restarts <- computeRestarts(cond)
[17:38:06.916]                           for (restart in restarts) {
[17:38:06.916]                             name <- restart$name
[17:38:06.916]                             if (is.null(name)) 
[17:38:06.916]                               next
[17:38:06.916]                             if (!grepl(pattern, name)) 
[17:38:06.916]                               next
[17:38:06.916]                             invokeRestart(restart)
[17:38:06.916]                             muffled <- TRUE
[17:38:06.916]                             break
[17:38:06.916]                           }
[17:38:06.916]                         }
[17:38:06.916]                       }
[17:38:06.916]                       invisible(muffled)
[17:38:06.916]                     }
[17:38:06.916]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.916]                   }
[17:38:06.916]                 }
[17:38:06.916]                 else {
[17:38:06.916]                   if (TRUE) {
[17:38:06.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.916]                     {
[17:38:06.916]                       inherits <- base::inherits
[17:38:06.916]                       invokeRestart <- base::invokeRestart
[17:38:06.916]                       is.null <- base::is.null
[17:38:06.916]                       muffled <- FALSE
[17:38:06.916]                       if (inherits(cond, "message")) {
[17:38:06.916]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.916]                         if (muffled) 
[17:38:06.916]                           invokeRestart("muffleMessage")
[17:38:06.916]                       }
[17:38:06.916]                       else if (inherits(cond, "warning")) {
[17:38:06.916]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.916]                         if (muffled) 
[17:38:06.916]                           invokeRestart("muffleWarning")
[17:38:06.916]                       }
[17:38:06.916]                       else if (inherits(cond, "condition")) {
[17:38:06.916]                         if (!is.null(pattern)) {
[17:38:06.916]                           computeRestarts <- base::computeRestarts
[17:38:06.916]                           grepl <- base::grepl
[17:38:06.916]                           restarts <- computeRestarts(cond)
[17:38:06.916]                           for (restart in restarts) {
[17:38:06.916]                             name <- restart$name
[17:38:06.916]                             if (is.null(name)) 
[17:38:06.916]                               next
[17:38:06.916]                             if (!grepl(pattern, name)) 
[17:38:06.916]                               next
[17:38:06.916]                             invokeRestart(restart)
[17:38:06.916]                             muffled <- TRUE
[17:38:06.916]                             break
[17:38:06.916]                           }
[17:38:06.916]                         }
[17:38:06.916]                       }
[17:38:06.916]                       invisible(muffled)
[17:38:06.916]                     }
[17:38:06.916]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.916]                   }
[17:38:06.916]                 }
[17:38:06.916]             }
[17:38:06.916]         }))
[17:38:06.916]     }, error = function(ex) {
[17:38:06.916]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:06.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.916]                 ...future.rng), started = ...future.startTime, 
[17:38:06.916]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:06.916]             version = "1.8"), class = "FutureResult")
[17:38:06.916]     }, finally = {
[17:38:06.916]         if (!identical(...future.workdir, getwd())) 
[17:38:06.916]             setwd(...future.workdir)
[17:38:06.916]         {
[17:38:06.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:06.916]                 ...future.oldOptions$nwarnings <- NULL
[17:38:06.916]             }
[17:38:06.916]             base::options(...future.oldOptions)
[17:38:06.916]             if (.Platform$OS.type == "windows") {
[17:38:06.916]                 old_names <- names(...future.oldEnvVars)
[17:38:06.916]                 envs <- base::Sys.getenv()
[17:38:06.916]                 names <- names(envs)
[17:38:06.916]                 common <- intersect(names, old_names)
[17:38:06.916]                 added <- setdiff(names, old_names)
[17:38:06.916]                 removed <- setdiff(old_names, names)
[17:38:06.916]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:06.916]                   envs[common]]
[17:38:06.916]                 NAMES <- toupper(changed)
[17:38:06.916]                 args <- list()
[17:38:06.916]                 for (kk in seq_along(NAMES)) {
[17:38:06.916]                   name <- changed[[kk]]
[17:38:06.916]                   NAME <- NAMES[[kk]]
[17:38:06.916]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.916]                     next
[17:38:06.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.916]                 }
[17:38:06.916]                 NAMES <- toupper(added)
[17:38:06.916]                 for (kk in seq_along(NAMES)) {
[17:38:06.916]                   name <- added[[kk]]
[17:38:06.916]                   NAME <- NAMES[[kk]]
[17:38:06.916]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.916]                     next
[17:38:06.916]                   args[[name]] <- ""
[17:38:06.916]                 }
[17:38:06.916]                 NAMES <- toupper(removed)
[17:38:06.916]                 for (kk in seq_along(NAMES)) {
[17:38:06.916]                   name <- removed[[kk]]
[17:38:06.916]                   NAME <- NAMES[[kk]]
[17:38:06.916]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.916]                     next
[17:38:06.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.916]                 }
[17:38:06.916]                 if (length(args) > 0) 
[17:38:06.916]                   base::do.call(base::Sys.setenv, args = args)
[17:38:06.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:06.916]             }
[17:38:06.916]             else {
[17:38:06.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:06.916]             }
[17:38:06.916]             {
[17:38:06.916]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:06.916]                   0L) {
[17:38:06.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:06.916]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:06.916]                   base::options(opts)
[17:38:06.916]                 }
[17:38:06.916]                 {
[17:38:06.916]                   {
[17:38:06.916]                     NULL
[17:38:06.916]                     RNGkind("Mersenne-Twister")
[17:38:06.916]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:06.916]                       inherits = FALSE)
[17:38:06.916]                   }
[17:38:06.916]                   options(future.plan = NULL)
[17:38:06.916]                   if (is.na(NA_character_)) 
[17:38:06.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:06.916]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:06.916]                     .init = FALSE)
[17:38:06.916]                 }
[17:38:06.916]             }
[17:38:06.916]         }
[17:38:06.916]     })
[17:38:06.916]     if (TRUE) {
[17:38:06.916]         base::sink(type = "output", split = FALSE)
[17:38:06.916]         if (TRUE) {
[17:38:06.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:06.916]         }
[17:38:06.916]         else {
[17:38:06.916]             ...future.result["stdout"] <- base::list(NULL)
[17:38:06.916]         }
[17:38:06.916]         base::close(...future.stdout)
[17:38:06.916]         ...future.stdout <- NULL
[17:38:06.916]     }
[17:38:06.916]     ...future.result$conditions <- ...future.conditions
[17:38:06.916]     ...future.result$finished <- base::Sys.time()
[17:38:06.916]     ...future.result
[17:38:06.916] }
[17:38:06.917] assign_globals() ...
[17:38:06.917] List of 11
[17:38:06.917]  $ ...future.FUN            :function (x, ...)  
[17:38:06.917]  $ x_FUN                    :function (x)  
[17:38:06.917]  $ times                    : int 4
[17:38:06.917]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.917]  $ stop_if_not              :function (...)  
[17:38:06.917]  $ dim                      : int [1:2] 2 2
[17:38:06.917]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:06.917]  $ future.call.arguments    : list()
[17:38:06.917]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.917]  $ ...future.elements_ii    :List of 10
[17:38:06.917]   ..$ : int 1
[17:38:06.917]   ..$ : int 2
[17:38:06.917]   ..$ : int 3
[17:38:06.917]   ..$ : int 4
[17:38:06.917]   ..$ : int 5
[17:38:06.917]   ..$ : int 6
[17:38:06.917]   ..$ : int 7
[17:38:06.917]   ..$ : int 8
[17:38:06.917]   ..$ : int 9
[17:38:06.917]   ..$ : int 10
[17:38:06.917]  $ ...future.seeds_ii       : NULL
[17:38:06.917]  $ ...future.globals.maxSize: NULL
[17:38:06.917]  - attr(*, "where")=List of 11
[17:38:06.917]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:06.917]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:06.917]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:06.917]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:06.917]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:06.917]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:06.917]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:06.917]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:06.917]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:06.917]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:06.917]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:06.917]  - attr(*, "resolved")= logi FALSE
[17:38:06.917]  - attr(*, "total_size")= num 105552
[17:38:06.917]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.917]  - attr(*, "already-done")= logi TRUE
[17:38:06.927] - copied ‘...future.FUN’ to environment
[17:38:06.927] - reassign environment for ‘x_FUN’
[17:38:06.927] - copied ‘x_FUN’ to environment
[17:38:06.927] - copied ‘times’ to environment
[17:38:06.928] - copied ‘stopf’ to environment
[17:38:06.928] - copied ‘stop_if_not’ to environment
[17:38:06.928] - copied ‘dim’ to environment
[17:38:06.928] - copied ‘valid_types’ to environment
[17:38:06.928] - copied ‘future.call.arguments’ to environment
[17:38:06.928] - copied ‘...future.elements_ii’ to environment
[17:38:06.928] - copied ‘...future.seeds_ii’ to environment
[17:38:06.928] - copied ‘...future.globals.maxSize’ to environment
[17:38:06.928] assign_globals() ... done
[17:38:06.929] plan(): Setting new future strategy stack:
[17:38:06.929] List of future strategies:
[17:38:06.929] 1. sequential:
[17:38:06.929]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.929]    - tweaked: FALSE
[17:38:06.929]    - call: NULL
[17:38:06.929] plan(): nbrOfWorkers() = 1
[17:38:06.932] plan(): Setting new future strategy stack:
[17:38:06.932] List of future strategies:
[17:38:06.932] 1. sequential:
[17:38:06.932]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.932]    - tweaked: FALSE
[17:38:06.932]    - call: plan(strategy)
[17:38:06.932] plan(): nbrOfWorkers() = 1
[17:38:06.932] SequentialFuture started (and completed)
[17:38:06.933] - Launch lazy future ... done
[17:38:06.933] run() for ‘SequentialFuture’ ... done
[17:38:06.933] Created future:
[17:38:06.933] SequentialFuture:
[17:38:06.933] Label: ‘future_vapply-1’
[17:38:06.933] Expression:
[17:38:06.933] {
[17:38:06.933]     do.call(function(...) {
[17:38:06.933]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.933]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.933]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.933]             on.exit(options(oopts), add = TRUE)
[17:38:06.933]         }
[17:38:06.933]         {
[17:38:06.933]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.933]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.933]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.933]             })
[17:38:06.933]         }
[17:38:06.933]     }, args = future.call.arguments)
[17:38:06.933] }
[17:38:06.933] Lazy evaluation: FALSE
[17:38:06.933] Asynchronous evaluation: FALSE
[17:38:06.933] Local evaluation: TRUE
[17:38:06.933] Environment: R_GlobalEnv
[17:38:06.933] Capture standard output: TRUE
[17:38:06.933] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:06.933] Globals: 11 objects totaling 103.62 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:06.933] Packages: 1 packages (‘future.apply’)
[17:38:06.933] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:06.933] Resolved: TRUE
[17:38:06.933] Value: 7.42 KiB of class ‘list’
[17:38:06.933] Early signaling: FALSE
[17:38:06.933] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:06.933] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.934] Chunk #1 of 1 ... DONE
[17:38:06.934] Launching 1 futures (chunks) ... DONE
[17:38:06.934] Resolving 1 futures (chunks) ...
[17:38:06.934] resolve() on list ...
[17:38:06.934]  recursive: 0
[17:38:06.935]  length: 1
[17:38:06.935] 
[17:38:06.935] resolved() for ‘SequentialFuture’ ...
[17:38:06.935] - state: ‘finished’
[17:38:06.935] - run: TRUE
[17:38:06.935] - result: ‘FutureResult’
[17:38:06.935] resolved() for ‘SequentialFuture’ ... done
[17:38:06.935] Future #1
[17:38:06.935] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:06.936] - nx: 1
[17:38:06.936] - relay: TRUE
[17:38:06.936] - stdout: TRUE
[17:38:06.936] - signal: TRUE
[17:38:06.936] - resignal: FALSE
[17:38:06.936] - force: TRUE
[17:38:06.936] - relayed: [n=1] FALSE
[17:38:06.936] - queued futures: [n=1] FALSE
[17:38:06.936]  - until=1
[17:38:06.936]  - relaying element #1
[17:38:06.936] - relayed: [n=1] TRUE
[17:38:06.937] - queued futures: [n=1] TRUE
[17:38:06.937] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:06.937]  length: 0 (resolved future 1)
[17:38:06.937] Relaying remaining futures
[17:38:06.937] signalConditionsASAP(NULL, pos=0) ...
[17:38:06.937] - nx: 1
[17:38:06.937] - relay: TRUE
[17:38:06.937] - stdout: TRUE
[17:38:06.937] - signal: TRUE
[17:38:06.937] - resignal: FALSE
[17:38:06.937] - force: TRUE
[17:38:06.938] - relayed: [n=1] TRUE
[17:38:06.938] - queued futures: [n=1] TRUE
 - flush all
[17:38:06.938] - relayed: [n=1] TRUE
[17:38:06.938] - queued futures: [n=1] TRUE
[17:38:06.938] signalConditionsASAP(NULL, pos=0) ... done
[17:38:06.938] resolve() on list ... DONE
[17:38:06.938]  - Number of value chunks collected: 1
[17:38:06.938] Resolving 1 futures (chunks) ... DONE
[17:38:06.938] Reducing values from 1 chunks ...
[17:38:06.938]  - Number of values collected after concatenation: 10
[17:38:06.939]  - Number of values expected: 10
[17:38:06.939] Reducing values from 1 chunks ... DONE
[17:38:06.939] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[17:38:06.942] future_lapply() ...
[17:38:06.944] Number of chunks: 1
[17:38:06.944] getGlobalsAndPackagesXApply() ...
[17:38:06.944]  - future.globals: TRUE
[17:38:06.944] getGlobalsAndPackages() ...
[17:38:06.945] Searching for globals...
[17:38:06.948] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[17:38:06.948] Searching for globals ... DONE
[17:38:06.948] Resolving globals: FALSE
[17:38:06.949] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[17:38:06.949] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:06.950] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.950] - packages: [2] ‘stats’, ‘future.apply’
[17:38:06.950] getGlobalsAndPackages() ... DONE
[17:38:06.950]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:06.950]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:38:06.950] Finding globals ... DONE
[17:38:06.950]  - use_args: TRUE
[17:38:06.950]  - Getting '...' globals ...
[17:38:06.951] resolve() on list ...
[17:38:06.951]  recursive: 0
[17:38:06.951]  length: 1
[17:38:06.951]  elements: ‘...’
[17:38:06.951]  length: 0 (resolved future 1)
[17:38:06.951] resolve() on list ... DONE
[17:38:06.951]    - '...' content: [n=0] 
[17:38:06.951] List of 1
[17:38:06.951]  $ ...: list()
[17:38:06.951]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.951]  - attr(*, "where")=List of 1
[17:38:06.951]   ..$ ...:<environment: 0x56080107b880> 
[17:38:06.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.951]  - attr(*, "resolved")= logi TRUE
[17:38:06.951]  - attr(*, "total_size")= num NA
[17:38:06.954]  - Getting '...' globals ... DONE
[17:38:06.954] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:06.954] List of 8
[17:38:06.954]  $ ...future.FUN:function (x, ...)  
[17:38:06.954]  $ x_FUN        :function (x, ...)  
[17:38:06.954]  $ times        : int 5
[17:38:06.954]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.954]  $ stop_if_not  :function (...)  
[17:38:06.954]  $ dim          : NULL
[17:38:06.954]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:06.954]  $ ...          : list()
[17:38:06.954]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.954]  - attr(*, "where")=List of 8
[17:38:06.954]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:06.954]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:06.954]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:06.954]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:06.954]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:06.954]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:06.954]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:06.954]   ..$ ...          :<environment: 0x56080107b880> 
[17:38:06.954]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.954]  - attr(*, "resolved")= logi FALSE
[17:38:06.954]  - attr(*, "total_size")= num 95528
[17:38:06.961] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:38:06.962] getGlobalsAndPackagesXApply() ... DONE
[17:38:06.962] Number of futures (= number of chunks): 1
[17:38:06.962] Launching 1 futures (chunks) ...
[17:38:06.962] Chunk #1 of 1 ...
[17:38:06.962]  - Finding globals in 'X' for chunk #1 ...
[17:38:06.962] getGlobalsAndPackages() ...
[17:38:06.962] Searching for globals...
[17:38:06.963] 
[17:38:06.963] Searching for globals ... DONE
[17:38:06.963] - globals: [0] <none>
[17:38:06.963] getGlobalsAndPackages() ... DONE
[17:38:06.963]    + additional globals found: [n=0] 
[17:38:06.963]    + additional namespaces needed: [n=0] 
[17:38:06.963]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:06.963]  - seeds: <none>
[17:38:06.963]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.963] getGlobalsAndPackages() ...
[17:38:06.963] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.964] Resolving globals: FALSE
[17:38:06.964] Tweak future expression to call with '...' arguments ...
[17:38:06.964] {
[17:38:06.964]     do.call(function(...) {
[17:38:06.964]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.964]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.964]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.964]             on.exit(options(oopts), add = TRUE)
[17:38:06.964]         }
[17:38:06.964]         {
[17:38:06.964]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.964]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.964]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.964]             })
[17:38:06.964]         }
[17:38:06.964]     }, args = future.call.arguments)
[17:38:06.964] }
[17:38:06.964] Tweak future expression to call with '...' arguments ... DONE
[17:38:06.965] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:06.965] - packages: [2] ‘stats’, ‘future.apply’
[17:38:06.965] getGlobalsAndPackages() ... DONE
[17:38:06.965] run() for ‘Future’ ...
[17:38:06.965] - state: ‘created’
[17:38:06.965] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:06.966] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.966] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:06.966]   - Field: ‘label’
[17:38:06.966]   - Field: ‘local’
[17:38:06.966]   - Field: ‘owner’
[17:38:06.966]   - Field: ‘envir’
[17:38:06.966]   - Field: ‘packages’
[17:38:06.966]   - Field: ‘gc’
[17:38:06.966]   - Field: ‘conditions’
[17:38:06.966]   - Field: ‘expr’
[17:38:06.967]   - Field: ‘uuid’
[17:38:06.967]   - Field: ‘seed’
[17:38:06.967]   - Field: ‘version’
[17:38:06.967]   - Field: ‘result’
[17:38:06.967]   - Field: ‘asynchronous’
[17:38:06.967]   - Field: ‘calls’
[17:38:06.967]   - Field: ‘globals’
[17:38:06.967]   - Field: ‘stdout’
[17:38:06.967]   - Field: ‘earlySignal’
[17:38:06.967]   - Field: ‘lazy’
[17:38:06.967]   - Field: ‘state’
[17:38:06.967] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:06.968] - Launch lazy future ...
[17:38:06.968] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:38:06.968] Packages needed by future strategies (n = 0): <none>
[17:38:06.968] {
[17:38:06.968]     {
[17:38:06.968]         {
[17:38:06.968]             ...future.startTime <- base::Sys.time()
[17:38:06.968]             {
[17:38:06.968]                 {
[17:38:06.968]                   {
[17:38:06.968]                     {
[17:38:06.968]                       base::local({
[17:38:06.968]                         has_future <- base::requireNamespace("future", 
[17:38:06.968]                           quietly = TRUE)
[17:38:06.968]                         if (has_future) {
[17:38:06.968]                           ns <- base::getNamespace("future")
[17:38:06.968]                           version <- ns[[".package"]][["version"]]
[17:38:06.968]                           if (is.null(version)) 
[17:38:06.968]                             version <- utils::packageVersion("future")
[17:38:06.968]                         }
[17:38:06.968]                         else {
[17:38:06.968]                           version <- NULL
[17:38:06.968]                         }
[17:38:06.968]                         if (!has_future || version < "1.8.0") {
[17:38:06.968]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:06.968]                             "", base::R.version$version.string), 
[17:38:06.968]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:06.968]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:06.968]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:06.968]                               "release", "version")], collapse = " "), 
[17:38:06.968]                             hostname = base::Sys.info()[["nodename"]])
[17:38:06.968]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:06.968]                             info)
[17:38:06.968]                           info <- base::paste(info, collapse = "; ")
[17:38:06.968]                           if (!has_future) {
[17:38:06.968]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:06.968]                               info)
[17:38:06.968]                           }
[17:38:06.968]                           else {
[17:38:06.968]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:06.968]                               info, version)
[17:38:06.968]                           }
[17:38:06.968]                           base::stop(msg)
[17:38:06.968]                         }
[17:38:06.968]                       })
[17:38:06.968]                     }
[17:38:06.968]                     base::local({
[17:38:06.968]                       for (pkg in c("stats", "future.apply")) {
[17:38:06.968]                         base::loadNamespace(pkg)
[17:38:06.968]                         base::library(pkg, character.only = TRUE)
[17:38:06.968]                       }
[17:38:06.968]                     })
[17:38:06.968]                   }
[17:38:06.968]                   ...future.strategy.old <- future::plan("list")
[17:38:06.968]                   options(future.plan = NULL)
[17:38:06.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:06.968]                 }
[17:38:06.968]                 ...future.workdir <- getwd()
[17:38:06.968]             }
[17:38:06.968]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:06.968]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:06.968]         }
[17:38:06.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:06.968]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:06.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:06.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:06.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:06.968]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:06.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:06.968]             base::names(...future.oldOptions))
[17:38:06.968]     }
[17:38:06.968]     if (FALSE) {
[17:38:06.968]     }
[17:38:06.968]     else {
[17:38:06.968]         if (TRUE) {
[17:38:06.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:06.968]                 open = "w")
[17:38:06.968]         }
[17:38:06.968]         else {
[17:38:06.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:06.968]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:06.968]         }
[17:38:06.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:06.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:06.968]             base::sink(type = "output", split = FALSE)
[17:38:06.968]             base::close(...future.stdout)
[17:38:06.968]         }, add = TRUE)
[17:38:06.968]     }
[17:38:06.968]     ...future.frame <- base::sys.nframe()
[17:38:06.968]     ...future.conditions <- base::list()
[17:38:06.968]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:06.968]     if (FALSE) {
[17:38:06.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:06.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:06.968]     }
[17:38:06.968]     ...future.result <- base::tryCatch({
[17:38:06.968]         base::withCallingHandlers({
[17:38:06.968]             ...future.value <- base::withVisible(base::local({
[17:38:06.968]                 do.call(function(...) {
[17:38:06.968]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.968]                   if (!identical(...future.globals.maxSize.org, 
[17:38:06.968]                     ...future.globals.maxSize)) {
[17:38:06.968]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.968]                     on.exit(options(oopts), add = TRUE)
[17:38:06.968]                   }
[17:38:06.968]                   {
[17:38:06.968]                     lapply(seq_along(...future.elements_ii), 
[17:38:06.968]                       FUN = function(jj) {
[17:38:06.968]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.968]                         ...future.FUN(...future.X_jj, ...)
[17:38:06.968]                       })
[17:38:06.968]                   }
[17:38:06.968]                 }, args = future.call.arguments)
[17:38:06.968]             }))
[17:38:06.968]             future::FutureResult(value = ...future.value$value, 
[17:38:06.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.968]                   ...future.rng), globalenv = if (FALSE) 
[17:38:06.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:06.968]                     ...future.globalenv.names))
[17:38:06.968]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:06.968]         }, condition = base::local({
[17:38:06.968]             c <- base::c
[17:38:06.968]             inherits <- base::inherits
[17:38:06.968]             invokeRestart <- base::invokeRestart
[17:38:06.968]             length <- base::length
[17:38:06.968]             list <- base::list
[17:38:06.968]             seq.int <- base::seq.int
[17:38:06.968]             signalCondition <- base::signalCondition
[17:38:06.968]             sys.calls <- base::sys.calls
[17:38:06.968]             `[[` <- base::`[[`
[17:38:06.968]             `+` <- base::`+`
[17:38:06.968]             `<<-` <- base::`<<-`
[17:38:06.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:06.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:06.968]                   3L)]
[17:38:06.968]             }
[17:38:06.968]             function(cond) {
[17:38:06.968]                 is_error <- inherits(cond, "error")
[17:38:06.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:06.968]                   NULL)
[17:38:06.968]                 if (is_error) {
[17:38:06.968]                   sessionInformation <- function() {
[17:38:06.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:06.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:06.968]                       search = base::search(), system = base::Sys.info())
[17:38:06.968]                   }
[17:38:06.968]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:06.968]                     cond$call), session = sessionInformation(), 
[17:38:06.968]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:06.968]                   signalCondition(cond)
[17:38:06.968]                 }
[17:38:06.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:06.968]                 "immediateCondition"))) {
[17:38:06.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:06.968]                   ...future.conditions[[length(...future.conditions) + 
[17:38:06.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:06.968]                   if (TRUE && !signal) {
[17:38:06.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.968]                     {
[17:38:06.968]                       inherits <- base::inherits
[17:38:06.968]                       invokeRestart <- base::invokeRestart
[17:38:06.968]                       is.null <- base::is.null
[17:38:06.968]                       muffled <- FALSE
[17:38:06.968]                       if (inherits(cond, "message")) {
[17:38:06.968]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.968]                         if (muffled) 
[17:38:06.968]                           invokeRestart("muffleMessage")
[17:38:06.968]                       }
[17:38:06.968]                       else if (inherits(cond, "warning")) {
[17:38:06.968]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.968]                         if (muffled) 
[17:38:06.968]                           invokeRestart("muffleWarning")
[17:38:06.968]                       }
[17:38:06.968]                       else if (inherits(cond, "condition")) {
[17:38:06.968]                         if (!is.null(pattern)) {
[17:38:06.968]                           computeRestarts <- base::computeRestarts
[17:38:06.968]                           grepl <- base::grepl
[17:38:06.968]                           restarts <- computeRestarts(cond)
[17:38:06.968]                           for (restart in restarts) {
[17:38:06.968]                             name <- restart$name
[17:38:06.968]                             if (is.null(name)) 
[17:38:06.968]                               next
[17:38:06.968]                             if (!grepl(pattern, name)) 
[17:38:06.968]                               next
[17:38:06.968]                             invokeRestart(restart)
[17:38:06.968]                             muffled <- TRUE
[17:38:06.968]                             break
[17:38:06.968]                           }
[17:38:06.968]                         }
[17:38:06.968]                       }
[17:38:06.968]                       invisible(muffled)
[17:38:06.968]                     }
[17:38:06.968]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.968]                   }
[17:38:06.968]                 }
[17:38:06.968]                 else {
[17:38:06.968]                   if (TRUE) {
[17:38:06.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:06.968]                     {
[17:38:06.968]                       inherits <- base::inherits
[17:38:06.968]                       invokeRestart <- base::invokeRestart
[17:38:06.968]                       is.null <- base::is.null
[17:38:06.968]                       muffled <- FALSE
[17:38:06.968]                       if (inherits(cond, "message")) {
[17:38:06.968]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:06.968]                         if (muffled) 
[17:38:06.968]                           invokeRestart("muffleMessage")
[17:38:06.968]                       }
[17:38:06.968]                       else if (inherits(cond, "warning")) {
[17:38:06.968]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:06.968]                         if (muffled) 
[17:38:06.968]                           invokeRestart("muffleWarning")
[17:38:06.968]                       }
[17:38:06.968]                       else if (inherits(cond, "condition")) {
[17:38:06.968]                         if (!is.null(pattern)) {
[17:38:06.968]                           computeRestarts <- base::computeRestarts
[17:38:06.968]                           grepl <- base::grepl
[17:38:06.968]                           restarts <- computeRestarts(cond)
[17:38:06.968]                           for (restart in restarts) {
[17:38:06.968]                             name <- restart$name
[17:38:06.968]                             if (is.null(name)) 
[17:38:06.968]                               next
[17:38:06.968]                             if (!grepl(pattern, name)) 
[17:38:06.968]                               next
[17:38:06.968]                             invokeRestart(restart)
[17:38:06.968]                             muffled <- TRUE
[17:38:06.968]                             break
[17:38:06.968]                           }
[17:38:06.968]                         }
[17:38:06.968]                       }
[17:38:06.968]                       invisible(muffled)
[17:38:06.968]                     }
[17:38:06.968]                     muffleCondition(cond, pattern = "^muffle")
[17:38:06.968]                   }
[17:38:06.968]                 }
[17:38:06.968]             }
[17:38:06.968]         }))
[17:38:06.968]     }, error = function(ex) {
[17:38:06.968]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:06.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:06.968]                 ...future.rng), started = ...future.startTime, 
[17:38:06.968]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:06.968]             version = "1.8"), class = "FutureResult")
[17:38:06.968]     }, finally = {
[17:38:06.968]         if (!identical(...future.workdir, getwd())) 
[17:38:06.968]             setwd(...future.workdir)
[17:38:06.968]         {
[17:38:06.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:06.968]                 ...future.oldOptions$nwarnings <- NULL
[17:38:06.968]             }
[17:38:06.968]             base::options(...future.oldOptions)
[17:38:06.968]             if (.Platform$OS.type == "windows") {
[17:38:06.968]                 old_names <- names(...future.oldEnvVars)
[17:38:06.968]                 envs <- base::Sys.getenv()
[17:38:06.968]                 names <- names(envs)
[17:38:06.968]                 common <- intersect(names, old_names)
[17:38:06.968]                 added <- setdiff(names, old_names)
[17:38:06.968]                 removed <- setdiff(old_names, names)
[17:38:06.968]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:06.968]                   envs[common]]
[17:38:06.968]                 NAMES <- toupper(changed)
[17:38:06.968]                 args <- list()
[17:38:06.968]                 for (kk in seq_along(NAMES)) {
[17:38:06.968]                   name <- changed[[kk]]
[17:38:06.968]                   NAME <- NAMES[[kk]]
[17:38:06.968]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.968]                     next
[17:38:06.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.968]                 }
[17:38:06.968]                 NAMES <- toupper(added)
[17:38:06.968]                 for (kk in seq_along(NAMES)) {
[17:38:06.968]                   name <- added[[kk]]
[17:38:06.968]                   NAME <- NAMES[[kk]]
[17:38:06.968]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.968]                     next
[17:38:06.968]                   args[[name]] <- ""
[17:38:06.968]                 }
[17:38:06.968]                 NAMES <- toupper(removed)
[17:38:06.968]                 for (kk in seq_along(NAMES)) {
[17:38:06.968]                   name <- removed[[kk]]
[17:38:06.968]                   NAME <- NAMES[[kk]]
[17:38:06.968]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:06.968]                     next
[17:38:06.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:06.968]                 }
[17:38:06.968]                 if (length(args) > 0) 
[17:38:06.968]                   base::do.call(base::Sys.setenv, args = args)
[17:38:06.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:06.968]             }
[17:38:06.968]             else {
[17:38:06.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:06.968]             }
[17:38:06.968]             {
[17:38:06.968]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:06.968]                   0L) {
[17:38:06.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:06.968]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:06.968]                   base::options(opts)
[17:38:06.968]                 }
[17:38:06.968]                 {
[17:38:06.968]                   {
[17:38:06.968]                     NULL
[17:38:06.968]                     RNGkind("Mersenne-Twister")
[17:38:06.968]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:06.968]                       inherits = FALSE)
[17:38:06.968]                   }
[17:38:06.968]                   options(future.plan = NULL)
[17:38:06.968]                   if (is.na(NA_character_)) 
[17:38:06.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:06.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:06.968]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:06.968]                     .init = FALSE)
[17:38:06.968]                 }
[17:38:06.968]             }
[17:38:06.968]         }
[17:38:06.968]     })
[17:38:06.968]     if (TRUE) {
[17:38:06.968]         base::sink(type = "output", split = FALSE)
[17:38:06.968]         if (TRUE) {
[17:38:06.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:06.968]         }
[17:38:06.968]         else {
[17:38:06.968]             ...future.result["stdout"] <- base::list(NULL)
[17:38:06.968]         }
[17:38:06.968]         base::close(...future.stdout)
[17:38:06.968]         ...future.stdout <- NULL
[17:38:06.968]     }
[17:38:06.968]     ...future.result$conditions <- ...future.conditions
[17:38:06.968]     ...future.result$finished <- base::Sys.time()
[17:38:06.968]     ...future.result
[17:38:06.968] }
[17:38:06.970] assign_globals() ...
[17:38:06.970] List of 11
[17:38:06.970]  $ ...future.FUN            :function (x, ...)  
[17:38:06.970]  $ x_FUN                    :function (x, ...)  
[17:38:06.970]  $ times                    : int 5
[17:38:06.970]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:06.970]  $ stop_if_not              :function (...)  
[17:38:06.970]  $ dim                      : NULL
[17:38:06.970]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:06.970]  $ future.call.arguments    : list()
[17:38:06.970]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:06.970]  $ ...future.elements_ii    :List of 3
[17:38:06.970]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:38:06.970]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:38:06.970]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:38:06.970]  $ ...future.seeds_ii       : NULL
[17:38:06.970]  $ ...future.globals.maxSize: NULL
[17:38:06.970]  - attr(*, "where")=List of 11
[17:38:06.970]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:06.970]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:06.970]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:06.970]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:06.970]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:06.970]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:06.970]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:06.970]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:06.970]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:06.970]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:06.970]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:06.970]  - attr(*, "resolved")= logi FALSE
[17:38:06.970]  - attr(*, "total_size")= num 95528
[17:38:06.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:06.970]  - attr(*, "already-done")= logi TRUE
[17:38:06.978] - copied ‘...future.FUN’ to environment
[17:38:06.978] - copied ‘x_FUN’ to environment
[17:38:06.978] - copied ‘times’ to environment
[17:38:06.978] - copied ‘stopf’ to environment
[17:38:06.978] - copied ‘stop_if_not’ to environment
[17:38:06.978] - copied ‘dim’ to environment
[17:38:06.979] - copied ‘valid_types’ to environment
[17:38:06.979] - copied ‘future.call.arguments’ to environment
[17:38:06.979] - copied ‘...future.elements_ii’ to environment
[17:38:06.979] - copied ‘...future.seeds_ii’ to environment
[17:38:06.979] - copied ‘...future.globals.maxSize’ to environment
[17:38:06.979] assign_globals() ... done
[17:38:06.979] plan(): Setting new future strategy stack:
[17:38:06.980] List of future strategies:
[17:38:06.980] 1. sequential:
[17:38:06.980]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.980]    - tweaked: FALSE
[17:38:06.980]    - call: NULL
[17:38:06.980] plan(): nbrOfWorkers() = 1
[17:38:06.983] plan(): Setting new future strategy stack:
[17:38:06.983] List of future strategies:
[17:38:06.983] 1. sequential:
[17:38:06.983]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:06.983]    - tweaked: FALSE
[17:38:06.983]    - call: plan(strategy)
[17:38:06.983] plan(): nbrOfWorkers() = 1
[17:38:06.983] SequentialFuture started (and completed)
[17:38:06.983] - Launch lazy future ... done
[17:38:06.984] run() for ‘SequentialFuture’ ... done
[17:38:06.984] Created future:
[17:38:06.984] SequentialFuture:
[17:38:06.984] Label: ‘future_vapply-1’
[17:38:06.984] Expression:
[17:38:06.984] {
[17:38:06.984]     do.call(function(...) {
[17:38:06.984]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:06.984]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:06.984]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:06.984]             on.exit(options(oopts), add = TRUE)
[17:38:06.984]         }
[17:38:06.984]         {
[17:38:06.984]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:06.984]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:06.984]                 ...future.FUN(...future.X_jj, ...)
[17:38:06.984]             })
[17:38:06.984]         }
[17:38:06.984]     }, args = future.call.arguments)
[17:38:06.984] }
[17:38:06.984] Lazy evaluation: FALSE
[17:38:06.984] Asynchronous evaluation: FALSE
[17:38:06.984] Local evaluation: TRUE
[17:38:06.984] Environment: R_GlobalEnv
[17:38:06.984] Capture standard output: TRUE
[17:38:06.984] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:06.984] Globals: 11 objects totaling 93.55 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:06.984] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:38:06.984] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:06.984] Resolved: TRUE
[17:38:06.984] Value: 1.71 KiB of class ‘list’
[17:38:06.984] Early signaling: FALSE
[17:38:06.984] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:06.984] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:06.985] Chunk #1 of 1 ... DONE
[17:38:06.985] Launching 1 futures (chunks) ... DONE
[17:38:06.985] Resolving 1 futures (chunks) ...
[17:38:06.985] resolve() on list ...
[17:38:06.985]  recursive: 0
[17:38:06.985]  length: 1
[17:38:06.986] 
[17:38:06.986] resolved() for ‘SequentialFuture’ ...
[17:38:06.986] - state: ‘finished’
[17:38:06.986] - run: TRUE
[17:38:06.986] - result: ‘FutureResult’
[17:38:06.986] resolved() for ‘SequentialFuture’ ... done
[17:38:06.986] Future #1
[17:38:06.986] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:06.986] - nx: 1
[17:38:06.986] - relay: TRUE
[17:38:06.987] - stdout: TRUE
[17:38:06.987] - signal: TRUE
[17:38:06.987] - resignal: FALSE
[17:38:06.987] - force: TRUE
[17:38:06.987] - relayed: [n=1] FALSE
[17:38:06.987] - queued futures: [n=1] FALSE
[17:38:06.987]  - until=1
[17:38:06.987]  - relaying element #1
[17:38:06.987] - relayed: [n=1] TRUE
[17:38:06.987] - queued futures: [n=1] TRUE
[17:38:06.987] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:06.988]  length: 0 (resolved future 1)
[17:38:06.988] Relaying remaining futures
[17:38:06.988] signalConditionsASAP(NULL, pos=0) ...
[17:38:06.988] - nx: 1
[17:38:06.988] - relay: TRUE
[17:38:06.988] - stdout: TRUE
[17:38:06.988] - signal: TRUE
[17:38:06.988] - resignal: FALSE
[17:38:06.988] - force: TRUE
[17:38:06.988] - relayed: [n=1] TRUE
[17:38:06.988] - queued futures: [n=1] TRUE
 - flush all
[17:38:06.989] - relayed: [n=1] TRUE
[17:38:06.989] - queued futures: [n=1] TRUE
[17:38:06.989] signalConditionsASAP(NULL, pos=0) ... done
[17:38:06.989] resolve() on list ... DONE
[17:38:06.989]  - Number of value chunks collected: 1
[17:38:06.989] Resolving 1 futures (chunks) ... DONE
[17:38:06.989] Reducing values from 1 chunks ...
[17:38:06.989]  - Number of values collected after concatenation: 3
[17:38:06.989]  - Number of values expected: 3
[17:38:06.989] Reducing values from 1 chunks ... DONE
[17:38:06.990] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[17:38:06.991] future_lapply() ...
[17:38:06.995] Number of chunks: 1
[17:38:06.995] getGlobalsAndPackagesXApply() ...
[17:38:06.995]  - future.globals: TRUE
[17:38:06.995] getGlobalsAndPackages() ...
[17:38:06.995] Searching for globals...
[17:38:07.000] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:38:07.000] Searching for globals ... DONE
[17:38:07.000] Resolving globals: FALSE
[17:38:07.001] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[17:38:07.001] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[17:38:07.002] - globals: [1] ‘FUN’
[17:38:07.002] - packages: [1] ‘stats’
[17:38:07.002] getGlobalsAndPackages() ... DONE
[17:38:07.002]  - globals found/used: [n=1] ‘FUN’
[17:38:07.002]  - needed namespaces: [n=1] ‘stats’
[17:38:07.002] Finding globals ... DONE
[17:38:07.002]  - use_args: TRUE
[17:38:07.002]  - Getting '...' globals ...
[17:38:07.003] resolve() on list ...
[17:38:07.003]  recursive: 0
[17:38:07.003]  length: 1
[17:38:07.003]  elements: ‘...’
[17:38:07.003]  length: 0 (resolved future 1)
[17:38:07.003] resolve() on list ... DONE
[17:38:07.003]    - '...' content: [n=0] 
[17:38:07.003] List of 1
[17:38:07.003]  $ ...: list()
[17:38:07.003]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.003]  - attr(*, "where")=List of 1
[17:38:07.003]   ..$ ...:<environment: 0x5607ffcb5a30> 
[17:38:07.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.003]  - attr(*, "resolved")= logi TRUE
[17:38:07.003]  - attr(*, "total_size")= num NA
[17:38:07.008]  - Getting '...' globals ... DONE
[17:38:07.008] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:07.009] List of 2
[17:38:07.009]  $ ...future.FUN:function (x, na.rm = TRUE)  
[17:38:07.009]  $ ...          : list()
[17:38:07.009]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.009]  - attr(*, "where")=List of 2
[17:38:07.009]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:07.009]   ..$ ...          :<environment: 0x5607ffcb5a30> 
[17:38:07.009]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.009]  - attr(*, "resolved")= logi FALSE
[17:38:07.009]  - attr(*, "total_size")= num 46960
[17:38:07.011] Packages to be attached in all futures: [n=1] ‘stats’
[17:38:07.011] getGlobalsAndPackagesXApply() ... DONE
[17:38:07.012] Number of futures (= number of chunks): 1
[17:38:07.012] Launching 1 futures (chunks) ...
[17:38:07.012] Chunk #1 of 1 ...
[17:38:07.012]  - Finding globals in 'X' for chunk #1 ...
[17:38:07.012] getGlobalsAndPackages() ...
[17:38:07.012] Searching for globals...
[17:38:07.012] 
[17:38:07.013] Searching for globals ... DONE
[17:38:07.013] - globals: [0] <none>
[17:38:07.013] getGlobalsAndPackages() ... DONE
[17:38:07.013]    + additional globals found: [n=0] 
[17:38:07.013]    + additional namespaces needed: [n=0] 
[17:38:07.013]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:07.013]  - seeds: <none>
[17:38:07.013]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.013] getGlobalsAndPackages() ...
[17:38:07.013] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.013] Resolving globals: FALSE
[17:38:07.014] Tweak future expression to call with '...' arguments ...
[17:38:07.014] {
[17:38:07.014]     do.call(function(...) {
[17:38:07.014]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.014]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.014]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.014]             on.exit(options(oopts), add = TRUE)
[17:38:07.014]         }
[17:38:07.014]         {
[17:38:07.014]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.014]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.014]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.014]             })
[17:38:07.014]         }
[17:38:07.014]     }, args = future.call.arguments)
[17:38:07.014] }
[17:38:07.014] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.014] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.014] - packages: [1] ‘stats’
[17:38:07.015] getGlobalsAndPackages() ... DONE
[17:38:07.015] run() for ‘Future’ ...
[17:38:07.015] - state: ‘created’
[17:38:07.015] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:07.015] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:07.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:07.016]   - Field: ‘label’
[17:38:07.016]   - Field: ‘local’
[17:38:07.016]   - Field: ‘owner’
[17:38:07.016]   - Field: ‘envir’
[17:38:07.016]   - Field: ‘packages’
[17:38:07.016]   - Field: ‘gc’
[17:38:07.016]   - Field: ‘conditions’
[17:38:07.016]   - Field: ‘expr’
[17:38:07.016]   - Field: ‘uuid’
[17:38:07.016]   - Field: ‘seed’
[17:38:07.017]   - Field: ‘version’
[17:38:07.017]   - Field: ‘result’
[17:38:07.017]   - Field: ‘asynchronous’
[17:38:07.017]   - Field: ‘calls’
[17:38:07.017]   - Field: ‘globals’
[17:38:07.017]   - Field: ‘stdout’
[17:38:07.017]   - Field: ‘earlySignal’
[17:38:07.017]   - Field: ‘lazy’
[17:38:07.017]   - Field: ‘state’
[17:38:07.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:07.018] - Launch lazy future ...
[17:38:07.018] Packages needed by the future expression (n = 1): ‘stats’
[17:38:07.018] Packages needed by future strategies (n = 0): <none>
[17:38:07.018] {
[17:38:07.018]     {
[17:38:07.018]         {
[17:38:07.018]             ...future.startTime <- base::Sys.time()
[17:38:07.018]             {
[17:38:07.018]                 {
[17:38:07.018]                   {
[17:38:07.018]                     {
[17:38:07.018]                       base::local({
[17:38:07.018]                         has_future <- base::requireNamespace("future", 
[17:38:07.018]                           quietly = TRUE)
[17:38:07.018]                         if (has_future) {
[17:38:07.018]                           ns <- base::getNamespace("future")
[17:38:07.018]                           version <- ns[[".package"]][["version"]]
[17:38:07.018]                           if (is.null(version)) 
[17:38:07.018]                             version <- utils::packageVersion("future")
[17:38:07.018]                         }
[17:38:07.018]                         else {
[17:38:07.018]                           version <- NULL
[17:38:07.018]                         }
[17:38:07.018]                         if (!has_future || version < "1.8.0") {
[17:38:07.018]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.018]                             "", base::R.version$version.string), 
[17:38:07.018]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:07.018]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:07.018]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.018]                               "release", "version")], collapse = " "), 
[17:38:07.018]                             hostname = base::Sys.info()[["nodename"]])
[17:38:07.018]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.018]                             info)
[17:38:07.018]                           info <- base::paste(info, collapse = "; ")
[17:38:07.018]                           if (!has_future) {
[17:38:07.018]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.018]                               info)
[17:38:07.018]                           }
[17:38:07.018]                           else {
[17:38:07.018]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.018]                               info, version)
[17:38:07.018]                           }
[17:38:07.018]                           base::stop(msg)
[17:38:07.018]                         }
[17:38:07.018]                       })
[17:38:07.018]                     }
[17:38:07.018]                     base::local({
[17:38:07.018]                       for (pkg in "stats") {
[17:38:07.018]                         base::loadNamespace(pkg)
[17:38:07.018]                         base::library(pkg, character.only = TRUE)
[17:38:07.018]                       }
[17:38:07.018]                     })
[17:38:07.018]                   }
[17:38:07.018]                   ...future.strategy.old <- future::plan("list")
[17:38:07.018]                   options(future.plan = NULL)
[17:38:07.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.018]                 }
[17:38:07.018]                 ...future.workdir <- getwd()
[17:38:07.018]             }
[17:38:07.018]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.018]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.018]         }
[17:38:07.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:07.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.018]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.018]             base::names(...future.oldOptions))
[17:38:07.018]     }
[17:38:07.018]     if (FALSE) {
[17:38:07.018]     }
[17:38:07.018]     else {
[17:38:07.018]         if (TRUE) {
[17:38:07.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.018]                 open = "w")
[17:38:07.018]         }
[17:38:07.018]         else {
[17:38:07.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.018]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.018]         }
[17:38:07.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.018]             base::sink(type = "output", split = FALSE)
[17:38:07.018]             base::close(...future.stdout)
[17:38:07.018]         }, add = TRUE)
[17:38:07.018]     }
[17:38:07.018]     ...future.frame <- base::sys.nframe()
[17:38:07.018]     ...future.conditions <- base::list()
[17:38:07.018]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.018]     if (FALSE) {
[17:38:07.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.018]     }
[17:38:07.018]     ...future.result <- base::tryCatch({
[17:38:07.018]         base::withCallingHandlers({
[17:38:07.018]             ...future.value <- base::withVisible(base::local({
[17:38:07.018]                 do.call(function(...) {
[17:38:07.018]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.018]                   if (!identical(...future.globals.maxSize.org, 
[17:38:07.018]                     ...future.globals.maxSize)) {
[17:38:07.018]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.018]                     on.exit(options(oopts), add = TRUE)
[17:38:07.018]                   }
[17:38:07.018]                   {
[17:38:07.018]                     lapply(seq_along(...future.elements_ii), 
[17:38:07.018]                       FUN = function(jj) {
[17:38:07.018]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.018]                         ...future.FUN(...future.X_jj, ...)
[17:38:07.018]                       })
[17:38:07.018]                   }
[17:38:07.018]                 }, args = future.call.arguments)
[17:38:07.018]             }))
[17:38:07.018]             future::FutureResult(value = ...future.value$value, 
[17:38:07.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.018]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.018]                     ...future.globalenv.names))
[17:38:07.018]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.018]         }, condition = base::local({
[17:38:07.018]             c <- base::c
[17:38:07.018]             inherits <- base::inherits
[17:38:07.018]             invokeRestart <- base::invokeRestart
[17:38:07.018]             length <- base::length
[17:38:07.018]             list <- base::list
[17:38:07.018]             seq.int <- base::seq.int
[17:38:07.018]             signalCondition <- base::signalCondition
[17:38:07.018]             sys.calls <- base::sys.calls
[17:38:07.018]             `[[` <- base::`[[`
[17:38:07.018]             `+` <- base::`+`
[17:38:07.018]             `<<-` <- base::`<<-`
[17:38:07.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.018]                   3L)]
[17:38:07.018]             }
[17:38:07.018]             function(cond) {
[17:38:07.018]                 is_error <- inherits(cond, "error")
[17:38:07.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.018]                   NULL)
[17:38:07.018]                 if (is_error) {
[17:38:07.018]                   sessionInformation <- function() {
[17:38:07.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.018]                       search = base::search(), system = base::Sys.info())
[17:38:07.018]                   }
[17:38:07.018]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.018]                     cond$call), session = sessionInformation(), 
[17:38:07.018]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.018]                   signalCondition(cond)
[17:38:07.018]                 }
[17:38:07.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.018]                 "immediateCondition"))) {
[17:38:07.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.018]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.018]                   if (TRUE && !signal) {
[17:38:07.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.018]                     {
[17:38:07.018]                       inherits <- base::inherits
[17:38:07.018]                       invokeRestart <- base::invokeRestart
[17:38:07.018]                       is.null <- base::is.null
[17:38:07.018]                       muffled <- FALSE
[17:38:07.018]                       if (inherits(cond, "message")) {
[17:38:07.018]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.018]                         if (muffled) 
[17:38:07.018]                           invokeRestart("muffleMessage")
[17:38:07.018]                       }
[17:38:07.018]                       else if (inherits(cond, "warning")) {
[17:38:07.018]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.018]                         if (muffled) 
[17:38:07.018]                           invokeRestart("muffleWarning")
[17:38:07.018]                       }
[17:38:07.018]                       else if (inherits(cond, "condition")) {
[17:38:07.018]                         if (!is.null(pattern)) {
[17:38:07.018]                           computeRestarts <- base::computeRestarts
[17:38:07.018]                           grepl <- base::grepl
[17:38:07.018]                           restarts <- computeRestarts(cond)
[17:38:07.018]                           for (restart in restarts) {
[17:38:07.018]                             name <- restart$name
[17:38:07.018]                             if (is.null(name)) 
[17:38:07.018]                               next
[17:38:07.018]                             if (!grepl(pattern, name)) 
[17:38:07.018]                               next
[17:38:07.018]                             invokeRestart(restart)
[17:38:07.018]                             muffled <- TRUE
[17:38:07.018]                             break
[17:38:07.018]                           }
[17:38:07.018]                         }
[17:38:07.018]                       }
[17:38:07.018]                       invisible(muffled)
[17:38:07.018]                     }
[17:38:07.018]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.018]                   }
[17:38:07.018]                 }
[17:38:07.018]                 else {
[17:38:07.018]                   if (TRUE) {
[17:38:07.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.018]                     {
[17:38:07.018]                       inherits <- base::inherits
[17:38:07.018]                       invokeRestart <- base::invokeRestart
[17:38:07.018]                       is.null <- base::is.null
[17:38:07.018]                       muffled <- FALSE
[17:38:07.018]                       if (inherits(cond, "message")) {
[17:38:07.018]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.018]                         if (muffled) 
[17:38:07.018]                           invokeRestart("muffleMessage")
[17:38:07.018]                       }
[17:38:07.018]                       else if (inherits(cond, "warning")) {
[17:38:07.018]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.018]                         if (muffled) 
[17:38:07.018]                           invokeRestart("muffleWarning")
[17:38:07.018]                       }
[17:38:07.018]                       else if (inherits(cond, "condition")) {
[17:38:07.018]                         if (!is.null(pattern)) {
[17:38:07.018]                           computeRestarts <- base::computeRestarts
[17:38:07.018]                           grepl <- base::grepl
[17:38:07.018]                           restarts <- computeRestarts(cond)
[17:38:07.018]                           for (restart in restarts) {
[17:38:07.018]                             name <- restart$name
[17:38:07.018]                             if (is.null(name)) 
[17:38:07.018]                               next
[17:38:07.018]                             if (!grepl(pattern, name)) 
[17:38:07.018]                               next
[17:38:07.018]                             invokeRestart(restart)
[17:38:07.018]                             muffled <- TRUE
[17:38:07.018]                             break
[17:38:07.018]                           }
[17:38:07.018]                         }
[17:38:07.018]                       }
[17:38:07.018]                       invisible(muffled)
[17:38:07.018]                     }
[17:38:07.018]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.018]                   }
[17:38:07.018]                 }
[17:38:07.018]             }
[17:38:07.018]         }))
[17:38:07.018]     }, error = function(ex) {
[17:38:07.018]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.018]                 ...future.rng), started = ...future.startTime, 
[17:38:07.018]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.018]             version = "1.8"), class = "FutureResult")
[17:38:07.018]     }, finally = {
[17:38:07.018]         if (!identical(...future.workdir, getwd())) 
[17:38:07.018]             setwd(...future.workdir)
[17:38:07.018]         {
[17:38:07.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.018]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.018]             }
[17:38:07.018]             base::options(...future.oldOptions)
[17:38:07.018]             if (.Platform$OS.type == "windows") {
[17:38:07.018]                 old_names <- names(...future.oldEnvVars)
[17:38:07.018]                 envs <- base::Sys.getenv()
[17:38:07.018]                 names <- names(envs)
[17:38:07.018]                 common <- intersect(names, old_names)
[17:38:07.018]                 added <- setdiff(names, old_names)
[17:38:07.018]                 removed <- setdiff(old_names, names)
[17:38:07.018]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.018]                   envs[common]]
[17:38:07.018]                 NAMES <- toupper(changed)
[17:38:07.018]                 args <- list()
[17:38:07.018]                 for (kk in seq_along(NAMES)) {
[17:38:07.018]                   name <- changed[[kk]]
[17:38:07.018]                   NAME <- NAMES[[kk]]
[17:38:07.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.018]                     next
[17:38:07.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.018]                 }
[17:38:07.018]                 NAMES <- toupper(added)
[17:38:07.018]                 for (kk in seq_along(NAMES)) {
[17:38:07.018]                   name <- added[[kk]]
[17:38:07.018]                   NAME <- NAMES[[kk]]
[17:38:07.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.018]                     next
[17:38:07.018]                   args[[name]] <- ""
[17:38:07.018]                 }
[17:38:07.018]                 NAMES <- toupper(removed)
[17:38:07.018]                 for (kk in seq_along(NAMES)) {
[17:38:07.018]                   name <- removed[[kk]]
[17:38:07.018]                   NAME <- NAMES[[kk]]
[17:38:07.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.018]                     next
[17:38:07.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.018]                 }
[17:38:07.018]                 if (length(args) > 0) 
[17:38:07.018]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.018]             }
[17:38:07.018]             else {
[17:38:07.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.018]             }
[17:38:07.018]             {
[17:38:07.018]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.018]                   0L) {
[17:38:07.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.018]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.018]                   base::options(opts)
[17:38:07.018]                 }
[17:38:07.018]                 {
[17:38:07.018]                   {
[17:38:07.018]                     NULL
[17:38:07.018]                     RNGkind("Mersenne-Twister")
[17:38:07.018]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:07.018]                       inherits = FALSE)
[17:38:07.018]                   }
[17:38:07.018]                   options(future.plan = NULL)
[17:38:07.018]                   if (is.na(NA_character_)) 
[17:38:07.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.018]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.018]                     .init = FALSE)
[17:38:07.018]                 }
[17:38:07.018]             }
[17:38:07.018]         }
[17:38:07.018]     })
[17:38:07.018]     if (TRUE) {
[17:38:07.018]         base::sink(type = "output", split = FALSE)
[17:38:07.018]         if (TRUE) {
[17:38:07.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.018]         }
[17:38:07.018]         else {
[17:38:07.018]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.018]         }
[17:38:07.018]         base::close(...future.stdout)
[17:38:07.018]         ...future.stdout <- NULL
[17:38:07.018]     }
[17:38:07.018]     ...future.result$conditions <- ...future.conditions
[17:38:07.018]     ...future.result$finished <- base::Sys.time()
[17:38:07.018]     ...future.result
[17:38:07.018] }
[17:38:07.020] assign_globals() ...
[17:38:07.020] List of 5
[17:38:07.020]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[17:38:07.020]  $ future.call.arguments    : list()
[17:38:07.020]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.020]  $ ...future.elements_ii    :List of 7
[17:38:07.020]   ..$ : int [1:3] 1 2 3
[17:38:07.020]   ..$ : int [1:4] 1 2 3 4
[17:38:07.020]   ..$ : int [1:5] 1 2 3 4 5
[17:38:07.020]   ..$ : int [1:6] 1 2 3 4 5 6
[17:38:07.020]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:38:07.020]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:38:07.020]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:38:07.020]  $ ...future.seeds_ii       : NULL
[17:38:07.020]  $ ...future.globals.maxSize: NULL
[17:38:07.020]  - attr(*, "where")=List of 5
[17:38:07.020]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.020]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.020]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.020]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.020]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.020]  - attr(*, "resolved")= logi FALSE
[17:38:07.020]  - attr(*, "total_size")= num 46960
[17:38:07.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.020]  - attr(*, "already-done")= logi TRUE
[17:38:07.026] - copied ‘...future.FUN’ to environment
[17:38:07.027] - copied ‘future.call.arguments’ to environment
[17:38:07.027] - copied ‘...future.elements_ii’ to environment
[17:38:07.027] - copied ‘...future.seeds_ii’ to environment
[17:38:07.027] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.027] assign_globals() ... done
[17:38:07.027] plan(): Setting new future strategy stack:
[17:38:07.027] List of future strategies:
[17:38:07.027] 1. sequential:
[17:38:07.027]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.027]    - tweaked: FALSE
[17:38:07.027]    - call: NULL
[17:38:07.028] plan(): nbrOfWorkers() = 1
[17:38:07.029] plan(): Setting new future strategy stack:
[17:38:07.029] List of future strategies:
[17:38:07.029] 1. sequential:
[17:38:07.029]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.029]    - tweaked: FALSE
[17:38:07.029]    - call: plan(strategy)
[17:38:07.029] plan(): nbrOfWorkers() = 1
[17:38:07.029] SequentialFuture started (and completed)
[17:38:07.030] - Launch lazy future ... done
[17:38:07.030] run() for ‘SequentialFuture’ ... done
[17:38:07.030] Created future:
[17:38:07.030] SequentialFuture:
[17:38:07.030] Label: ‘future_sapply-1’
[17:38:07.030] Expression:
[17:38:07.030] {
[17:38:07.030]     do.call(function(...) {
[17:38:07.030]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.030]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.030]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.030]             on.exit(options(oopts), add = TRUE)
[17:38:07.030]         }
[17:38:07.030]         {
[17:38:07.030]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.030]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.030]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.030]             })
[17:38:07.030]         }
[17:38:07.030]     }, args = future.call.arguments)
[17:38:07.030] }
[17:38:07.030] Lazy evaluation: FALSE
[17:38:07.030] Asynchronous evaluation: FALSE
[17:38:07.030] Local evaluation: TRUE
[17:38:07.030] Environment: R_GlobalEnv
[17:38:07.030] Capture standard output: TRUE
[17:38:07.030] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.030] Globals: 5 objects totaling 46.39 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 544 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:07.030] Packages: 1 packages (‘stats’)
[17:38:07.030] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.030] Resolved: TRUE
[17:38:07.030] Value: 672 bytes of class ‘list’
[17:38:07.030] Early signaling: FALSE
[17:38:07.030] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.030] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:07.033] Chunk #1 of 1 ... DONE
[17:38:07.033] Launching 1 futures (chunks) ... DONE
[17:38:07.033] Resolving 1 futures (chunks) ...
[17:38:07.033] resolve() on list ...
[17:38:07.033]  recursive: 0
[17:38:07.033]  length: 1
[17:38:07.033] 
[17:38:07.033] resolved() for ‘SequentialFuture’ ...
[17:38:07.033] - state: ‘finished’
[17:38:07.034] - run: TRUE
[17:38:07.034] - result: ‘FutureResult’
[17:38:07.034] resolved() for ‘SequentialFuture’ ... done
[17:38:07.034] Future #1
[17:38:07.034] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:07.034] - nx: 1
[17:38:07.034] - relay: TRUE
[17:38:07.034] - stdout: TRUE
[17:38:07.034] - signal: TRUE
[17:38:07.035] - resignal: FALSE
[17:38:07.035] - force: TRUE
[17:38:07.035] - relayed: [n=1] FALSE
[17:38:07.035] - queued futures: [n=1] FALSE
[17:38:07.035]  - until=1
[17:38:07.035]  - relaying element #1
[17:38:07.035] - relayed: [n=1] TRUE
[17:38:07.035] - queued futures: [n=1] TRUE
[17:38:07.035] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:07.036]  length: 0 (resolved future 1)
[17:38:07.036] Relaying remaining futures
[17:38:07.036] signalConditionsASAP(NULL, pos=0) ...
[17:38:07.036] - nx: 1
[17:38:07.036] - relay: TRUE
[17:38:07.036] - stdout: TRUE
[17:38:07.036] - signal: TRUE
[17:38:07.036] - resignal: FALSE
[17:38:07.036] - force: TRUE
[17:38:07.036] - relayed: [n=1] TRUE
[17:38:07.036] - queued futures: [n=1] TRUE
 - flush all
[17:38:07.037] - relayed: [n=1] TRUE
[17:38:07.037] - queued futures: [n=1] TRUE
[17:38:07.037] signalConditionsASAP(NULL, pos=0) ... done
[17:38:07.037] resolve() on list ... DONE
[17:38:07.037]  - Number of value chunks collected: 1
[17:38:07.037] Resolving 1 futures (chunks) ... DONE
[17:38:07.037] Reducing values from 1 chunks ...
[17:38:07.037]  - Number of values collected after concatenation: 7
[17:38:07.037]  - Number of values expected: 7
[17:38:07.037] Reducing values from 1 chunks ... DONE
[17:38:07.038] future_lapply() ... DONE
[17:38:07.038] future_lapply() ...
[17:38:07.040] Number of chunks: 1
[17:38:07.040] getGlobalsAndPackagesXApply() ...
[17:38:07.040]  - future.globals: TRUE
[17:38:07.040] getGlobalsAndPackages() ...
[17:38:07.040] Searching for globals...
[17:38:07.047] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:38:07.047] Searching for globals ... DONE
[17:38:07.047] Resolving globals: FALSE
[17:38:07.048] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[17:38:07.049] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[17:38:07.049] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.049] - packages: [2] ‘stats’, ‘future.apply’
[17:38:07.049] getGlobalsAndPackages() ... DONE
[17:38:07.049]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.049]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:38:07.049] Finding globals ... DONE
[17:38:07.049]  - use_args: TRUE
[17:38:07.049]  - Getting '...' globals ...
[17:38:07.050] resolve() on list ...
[17:38:07.050]  recursive: 0
[17:38:07.050]  length: 1
[17:38:07.050]  elements: ‘...’
[17:38:07.050]  length: 0 (resolved future 1)
[17:38:07.050] resolve() on list ... DONE
[17:38:07.050]    - '...' content: [n=0] 
[17:38:07.050] List of 1
[17:38:07.050]  $ ...: list()
[17:38:07.050]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.050]  - attr(*, "where")=List of 1
[17:38:07.050]   ..$ ...:<environment: 0x5607ff4aaa70> 
[17:38:07.050]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.050]  - attr(*, "resolved")= logi TRUE
[17:38:07.050]  - attr(*, "total_size")= num NA
[17:38:07.053]  - Getting '...' globals ... DONE
[17:38:07.055] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:07.055] List of 8
[17:38:07.055]  $ ...future.FUN:function (x, ...)  
[17:38:07.055]  $ x_FUN        :function (x, na.rm = TRUE)  
[17:38:07.055]  $ times        : int 5
[17:38:07.055]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.055]  $ stop_if_not  :function (...)  
[17:38:07.055]  $ dim          : NULL
[17:38:07.055]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:07.055]  $ ...          : list()
[17:38:07.055]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.055]  - attr(*, "where")=List of 8
[17:38:07.055]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:07.055]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:07.055]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:07.055]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:07.055]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:07.055]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:07.055]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:07.055]   ..$ ...          :<environment: 0x5607ff4aaa70> 
[17:38:07.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.055]  - attr(*, "resolved")= logi FALSE
[17:38:07.055]  - attr(*, "total_size")= num 141240
[17:38:07.061] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:38:07.061] getGlobalsAndPackagesXApply() ... DONE
[17:38:07.061] Number of futures (= number of chunks): 1
[17:38:07.061] Launching 1 futures (chunks) ...
[17:38:07.061] Chunk #1 of 1 ...
[17:38:07.061]  - Finding globals in 'X' for chunk #1 ...
[17:38:07.061] getGlobalsAndPackages() ...
[17:38:07.061] Searching for globals...
[17:38:07.062] 
[17:38:07.062] Searching for globals ... DONE
[17:38:07.062] - globals: [0] <none>
[17:38:07.062] getGlobalsAndPackages() ... DONE
[17:38:07.062]    + additional globals found: [n=0] 
[17:38:07.062]    + additional namespaces needed: [n=0] 
[17:38:07.062]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:07.062]  - seeds: <none>
[17:38:07.062]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.063] getGlobalsAndPackages() ...
[17:38:07.063] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.063] Resolving globals: FALSE
[17:38:07.063] Tweak future expression to call with '...' arguments ...
[17:38:07.063] {
[17:38:07.063]     do.call(function(...) {
[17:38:07.063]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.063]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.063]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.063]             on.exit(options(oopts), add = TRUE)
[17:38:07.063]         }
[17:38:07.063]         {
[17:38:07.063]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.063]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.063]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.063]             })
[17:38:07.063]         }
[17:38:07.063]     }, args = future.call.arguments)
[17:38:07.063] }
[17:38:07.063] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.064] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.064] - packages: [2] ‘stats’, ‘future.apply’
[17:38:07.064] getGlobalsAndPackages() ... DONE
[17:38:07.064] run() for ‘Future’ ...
[17:38:07.064] - state: ‘created’
[17:38:07.065] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:07.065] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:07.065] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:07.065]   - Field: ‘label’
[17:38:07.065]   - Field: ‘local’
[17:38:07.065]   - Field: ‘owner’
[17:38:07.065]   - Field: ‘envir’
[17:38:07.065]   - Field: ‘packages’
[17:38:07.066]   - Field: ‘gc’
[17:38:07.066]   - Field: ‘conditions’
[17:38:07.066]   - Field: ‘expr’
[17:38:07.066]   - Field: ‘uuid’
[17:38:07.066]   - Field: ‘seed’
[17:38:07.066]   - Field: ‘version’
[17:38:07.066]   - Field: ‘result’
[17:38:07.066]   - Field: ‘asynchronous’
[17:38:07.066]   - Field: ‘calls’
[17:38:07.066]   - Field: ‘globals’
[17:38:07.066]   - Field: ‘stdout’
[17:38:07.067]   - Field: ‘earlySignal’
[17:38:07.067]   - Field: ‘lazy’
[17:38:07.067]   - Field: ‘state’
[17:38:07.067] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:07.067] - Launch lazy future ...
[17:38:07.067] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:38:07.067] Packages needed by future strategies (n = 0): <none>
[17:38:07.068] {
[17:38:07.068]     {
[17:38:07.068]         {
[17:38:07.068]             ...future.startTime <- base::Sys.time()
[17:38:07.068]             {
[17:38:07.068]                 {
[17:38:07.068]                   {
[17:38:07.068]                     {
[17:38:07.068]                       base::local({
[17:38:07.068]                         has_future <- base::requireNamespace("future", 
[17:38:07.068]                           quietly = TRUE)
[17:38:07.068]                         if (has_future) {
[17:38:07.068]                           ns <- base::getNamespace("future")
[17:38:07.068]                           version <- ns[[".package"]][["version"]]
[17:38:07.068]                           if (is.null(version)) 
[17:38:07.068]                             version <- utils::packageVersion("future")
[17:38:07.068]                         }
[17:38:07.068]                         else {
[17:38:07.068]                           version <- NULL
[17:38:07.068]                         }
[17:38:07.068]                         if (!has_future || version < "1.8.0") {
[17:38:07.068]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.068]                             "", base::R.version$version.string), 
[17:38:07.068]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:07.068]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:07.068]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.068]                               "release", "version")], collapse = " "), 
[17:38:07.068]                             hostname = base::Sys.info()[["nodename"]])
[17:38:07.068]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.068]                             info)
[17:38:07.068]                           info <- base::paste(info, collapse = "; ")
[17:38:07.068]                           if (!has_future) {
[17:38:07.068]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.068]                               info)
[17:38:07.068]                           }
[17:38:07.068]                           else {
[17:38:07.068]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.068]                               info, version)
[17:38:07.068]                           }
[17:38:07.068]                           base::stop(msg)
[17:38:07.068]                         }
[17:38:07.068]                       })
[17:38:07.068]                     }
[17:38:07.068]                     base::local({
[17:38:07.068]                       for (pkg in c("stats", "future.apply")) {
[17:38:07.068]                         base::loadNamespace(pkg)
[17:38:07.068]                         base::library(pkg, character.only = TRUE)
[17:38:07.068]                       }
[17:38:07.068]                     })
[17:38:07.068]                   }
[17:38:07.068]                   ...future.strategy.old <- future::plan("list")
[17:38:07.068]                   options(future.plan = NULL)
[17:38:07.068]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.068]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.068]                 }
[17:38:07.068]                 ...future.workdir <- getwd()
[17:38:07.068]             }
[17:38:07.068]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.068]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.068]         }
[17:38:07.068]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.068]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:07.068]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.068]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.068]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.068]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.068]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.068]             base::names(...future.oldOptions))
[17:38:07.068]     }
[17:38:07.068]     if (FALSE) {
[17:38:07.068]     }
[17:38:07.068]     else {
[17:38:07.068]         if (TRUE) {
[17:38:07.068]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.068]                 open = "w")
[17:38:07.068]         }
[17:38:07.068]         else {
[17:38:07.068]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.068]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.068]         }
[17:38:07.068]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.068]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.068]             base::sink(type = "output", split = FALSE)
[17:38:07.068]             base::close(...future.stdout)
[17:38:07.068]         }, add = TRUE)
[17:38:07.068]     }
[17:38:07.068]     ...future.frame <- base::sys.nframe()
[17:38:07.068]     ...future.conditions <- base::list()
[17:38:07.068]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.068]     if (FALSE) {
[17:38:07.068]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.068]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.068]     }
[17:38:07.068]     ...future.result <- base::tryCatch({
[17:38:07.068]         base::withCallingHandlers({
[17:38:07.068]             ...future.value <- base::withVisible(base::local({
[17:38:07.068]                 do.call(function(...) {
[17:38:07.068]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.068]                   if (!identical(...future.globals.maxSize.org, 
[17:38:07.068]                     ...future.globals.maxSize)) {
[17:38:07.068]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.068]                     on.exit(options(oopts), add = TRUE)
[17:38:07.068]                   }
[17:38:07.068]                   {
[17:38:07.068]                     lapply(seq_along(...future.elements_ii), 
[17:38:07.068]                       FUN = function(jj) {
[17:38:07.068]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.068]                         ...future.FUN(...future.X_jj, ...)
[17:38:07.068]                       })
[17:38:07.068]                   }
[17:38:07.068]                 }, args = future.call.arguments)
[17:38:07.068]             }))
[17:38:07.068]             future::FutureResult(value = ...future.value$value, 
[17:38:07.068]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.068]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.068]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.068]                     ...future.globalenv.names))
[17:38:07.068]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.068]         }, condition = base::local({
[17:38:07.068]             c <- base::c
[17:38:07.068]             inherits <- base::inherits
[17:38:07.068]             invokeRestart <- base::invokeRestart
[17:38:07.068]             length <- base::length
[17:38:07.068]             list <- base::list
[17:38:07.068]             seq.int <- base::seq.int
[17:38:07.068]             signalCondition <- base::signalCondition
[17:38:07.068]             sys.calls <- base::sys.calls
[17:38:07.068]             `[[` <- base::`[[`
[17:38:07.068]             `+` <- base::`+`
[17:38:07.068]             `<<-` <- base::`<<-`
[17:38:07.068]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.068]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.068]                   3L)]
[17:38:07.068]             }
[17:38:07.068]             function(cond) {
[17:38:07.068]                 is_error <- inherits(cond, "error")
[17:38:07.068]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.068]                   NULL)
[17:38:07.068]                 if (is_error) {
[17:38:07.068]                   sessionInformation <- function() {
[17:38:07.068]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.068]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.068]                       search = base::search(), system = base::Sys.info())
[17:38:07.068]                   }
[17:38:07.068]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.068]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.068]                     cond$call), session = sessionInformation(), 
[17:38:07.068]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.068]                   signalCondition(cond)
[17:38:07.068]                 }
[17:38:07.068]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.068]                 "immediateCondition"))) {
[17:38:07.068]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.068]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.068]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.068]                   if (TRUE && !signal) {
[17:38:07.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.068]                     {
[17:38:07.068]                       inherits <- base::inherits
[17:38:07.068]                       invokeRestart <- base::invokeRestart
[17:38:07.068]                       is.null <- base::is.null
[17:38:07.068]                       muffled <- FALSE
[17:38:07.068]                       if (inherits(cond, "message")) {
[17:38:07.068]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.068]                         if (muffled) 
[17:38:07.068]                           invokeRestart("muffleMessage")
[17:38:07.068]                       }
[17:38:07.068]                       else if (inherits(cond, "warning")) {
[17:38:07.068]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.068]                         if (muffled) 
[17:38:07.068]                           invokeRestart("muffleWarning")
[17:38:07.068]                       }
[17:38:07.068]                       else if (inherits(cond, "condition")) {
[17:38:07.068]                         if (!is.null(pattern)) {
[17:38:07.068]                           computeRestarts <- base::computeRestarts
[17:38:07.068]                           grepl <- base::grepl
[17:38:07.068]                           restarts <- computeRestarts(cond)
[17:38:07.068]                           for (restart in restarts) {
[17:38:07.068]                             name <- restart$name
[17:38:07.068]                             if (is.null(name)) 
[17:38:07.068]                               next
[17:38:07.068]                             if (!grepl(pattern, name)) 
[17:38:07.068]                               next
[17:38:07.068]                             invokeRestart(restart)
[17:38:07.068]                             muffled <- TRUE
[17:38:07.068]                             break
[17:38:07.068]                           }
[17:38:07.068]                         }
[17:38:07.068]                       }
[17:38:07.068]                       invisible(muffled)
[17:38:07.068]                     }
[17:38:07.068]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.068]                   }
[17:38:07.068]                 }
[17:38:07.068]                 else {
[17:38:07.068]                   if (TRUE) {
[17:38:07.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.068]                     {
[17:38:07.068]                       inherits <- base::inherits
[17:38:07.068]                       invokeRestart <- base::invokeRestart
[17:38:07.068]                       is.null <- base::is.null
[17:38:07.068]                       muffled <- FALSE
[17:38:07.068]                       if (inherits(cond, "message")) {
[17:38:07.068]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.068]                         if (muffled) 
[17:38:07.068]                           invokeRestart("muffleMessage")
[17:38:07.068]                       }
[17:38:07.068]                       else if (inherits(cond, "warning")) {
[17:38:07.068]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.068]                         if (muffled) 
[17:38:07.068]                           invokeRestart("muffleWarning")
[17:38:07.068]                       }
[17:38:07.068]                       else if (inherits(cond, "condition")) {
[17:38:07.068]                         if (!is.null(pattern)) {
[17:38:07.068]                           computeRestarts <- base::computeRestarts
[17:38:07.068]                           grepl <- base::grepl
[17:38:07.068]                           restarts <- computeRestarts(cond)
[17:38:07.068]                           for (restart in restarts) {
[17:38:07.068]                             name <- restart$name
[17:38:07.068]                             if (is.null(name)) 
[17:38:07.068]                               next
[17:38:07.068]                             if (!grepl(pattern, name)) 
[17:38:07.068]                               next
[17:38:07.068]                             invokeRestart(restart)
[17:38:07.068]                             muffled <- TRUE
[17:38:07.068]                             break
[17:38:07.068]                           }
[17:38:07.068]                         }
[17:38:07.068]                       }
[17:38:07.068]                       invisible(muffled)
[17:38:07.068]                     }
[17:38:07.068]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.068]                   }
[17:38:07.068]                 }
[17:38:07.068]             }
[17:38:07.068]         }))
[17:38:07.068]     }, error = function(ex) {
[17:38:07.068]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.068]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.068]                 ...future.rng), started = ...future.startTime, 
[17:38:07.068]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.068]             version = "1.8"), class = "FutureResult")
[17:38:07.068]     }, finally = {
[17:38:07.068]         if (!identical(...future.workdir, getwd())) 
[17:38:07.068]             setwd(...future.workdir)
[17:38:07.068]         {
[17:38:07.068]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.068]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.068]             }
[17:38:07.068]             base::options(...future.oldOptions)
[17:38:07.068]             if (.Platform$OS.type == "windows") {
[17:38:07.068]                 old_names <- names(...future.oldEnvVars)
[17:38:07.068]                 envs <- base::Sys.getenv()
[17:38:07.068]                 names <- names(envs)
[17:38:07.068]                 common <- intersect(names, old_names)
[17:38:07.068]                 added <- setdiff(names, old_names)
[17:38:07.068]                 removed <- setdiff(old_names, names)
[17:38:07.068]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.068]                   envs[common]]
[17:38:07.068]                 NAMES <- toupper(changed)
[17:38:07.068]                 args <- list()
[17:38:07.068]                 for (kk in seq_along(NAMES)) {
[17:38:07.068]                   name <- changed[[kk]]
[17:38:07.068]                   NAME <- NAMES[[kk]]
[17:38:07.068]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.068]                     next
[17:38:07.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.068]                 }
[17:38:07.068]                 NAMES <- toupper(added)
[17:38:07.068]                 for (kk in seq_along(NAMES)) {
[17:38:07.068]                   name <- added[[kk]]
[17:38:07.068]                   NAME <- NAMES[[kk]]
[17:38:07.068]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.068]                     next
[17:38:07.068]                   args[[name]] <- ""
[17:38:07.068]                 }
[17:38:07.068]                 NAMES <- toupper(removed)
[17:38:07.068]                 for (kk in seq_along(NAMES)) {
[17:38:07.068]                   name <- removed[[kk]]
[17:38:07.068]                   NAME <- NAMES[[kk]]
[17:38:07.068]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.068]                     next
[17:38:07.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.068]                 }
[17:38:07.068]                 if (length(args) > 0) 
[17:38:07.068]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.068]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.068]             }
[17:38:07.068]             else {
[17:38:07.068]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.068]             }
[17:38:07.068]             {
[17:38:07.068]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.068]                   0L) {
[17:38:07.068]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.068]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.068]                   base::options(opts)
[17:38:07.068]                 }
[17:38:07.068]                 {
[17:38:07.068]                   {
[17:38:07.068]                     NULL
[17:38:07.068]                     RNGkind("Mersenne-Twister")
[17:38:07.068]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:07.068]                       inherits = FALSE)
[17:38:07.068]                   }
[17:38:07.068]                   options(future.plan = NULL)
[17:38:07.068]                   if (is.na(NA_character_)) 
[17:38:07.068]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.068]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.068]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.068]                     .init = FALSE)
[17:38:07.068]                 }
[17:38:07.068]             }
[17:38:07.068]         }
[17:38:07.068]     })
[17:38:07.068]     if (TRUE) {
[17:38:07.068]         base::sink(type = "output", split = FALSE)
[17:38:07.068]         if (TRUE) {
[17:38:07.068]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.068]         }
[17:38:07.068]         else {
[17:38:07.068]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.068]         }
[17:38:07.068]         base::close(...future.stdout)
[17:38:07.068]         ...future.stdout <- NULL
[17:38:07.068]     }
[17:38:07.068]     ...future.result$conditions <- ...future.conditions
[17:38:07.068]     ...future.result$finished <- base::Sys.time()
[17:38:07.068]     ...future.result
[17:38:07.068] }
[17:38:07.070] assign_globals() ...
[17:38:07.070] List of 11
[17:38:07.070]  $ ...future.FUN            :function (x, ...)  
[17:38:07.070]  $ x_FUN                    :function (x, na.rm = TRUE)  
[17:38:07.070]  $ times                    : int 5
[17:38:07.070]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.070]  $ stop_if_not              :function (...)  
[17:38:07.070]  $ dim                      : NULL
[17:38:07.070]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:07.070]  $ future.call.arguments    : list()
[17:38:07.070]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.070]  $ ...future.elements_ii    :List of 7
[17:38:07.070]   ..$ : int [1:3] 1 2 3
[17:38:07.070]   ..$ : int [1:4] 1 2 3 4
[17:38:07.070]   ..$ : int [1:5] 1 2 3 4 5
[17:38:07.070]   ..$ : int [1:6] 1 2 3 4 5 6
[17:38:07.070]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:38:07.070]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:38:07.070]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:38:07.070]  $ ...future.seeds_ii       : NULL
[17:38:07.070]  $ ...future.globals.maxSize: NULL
[17:38:07.070]  - attr(*, "where")=List of 11
[17:38:07.070]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.070]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.070]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.070]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.070]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.070]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.070]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.070]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.070]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.070]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.070]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.070]  - attr(*, "resolved")= logi FALSE
[17:38:07.070]  - attr(*, "total_size")= num 141240
[17:38:07.070]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.070]  - attr(*, "already-done")= logi TRUE
[17:38:07.080] - copied ‘...future.FUN’ to environment
[17:38:07.080] - copied ‘x_FUN’ to environment
[17:38:07.081] - copied ‘times’ to environment
[17:38:07.081] - copied ‘stopf’ to environment
[17:38:07.081] - copied ‘stop_if_not’ to environment
[17:38:07.081] - copied ‘dim’ to environment
[17:38:07.081] - copied ‘valid_types’ to environment
[17:38:07.081] - copied ‘future.call.arguments’ to environment
[17:38:07.081] - copied ‘...future.elements_ii’ to environment
[17:38:07.081] - copied ‘...future.seeds_ii’ to environment
[17:38:07.081] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.082] assign_globals() ... done
[17:38:07.082] plan(): Setting new future strategy stack:
[17:38:07.082] List of future strategies:
[17:38:07.082] 1. sequential:
[17:38:07.082]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.082]    - tweaked: FALSE
[17:38:07.082]    - call: NULL
[17:38:07.083] plan(): nbrOfWorkers() = 1
[17:38:07.084] plan(): Setting new future strategy stack:
[17:38:07.084] List of future strategies:
[17:38:07.084] 1. sequential:
[17:38:07.084]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.084]    - tweaked: FALSE
[17:38:07.084]    - call: plan(strategy)
[17:38:07.084] plan(): nbrOfWorkers() = 1
[17:38:07.084] SequentialFuture started (and completed)
[17:38:07.084] - Launch lazy future ... done
[17:38:07.084] run() for ‘SequentialFuture’ ... done
[17:38:07.085] Created future:
[17:38:07.085] SequentialFuture:
[17:38:07.085] Label: ‘future_vapply-1’
[17:38:07.085] Expression:
[17:38:07.085] {
[17:38:07.085]     do.call(function(...) {
[17:38:07.085]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.085]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.085]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.085]             on.exit(options(oopts), add = TRUE)
[17:38:07.085]         }
[17:38:07.085]         {
[17:38:07.085]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.085]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.085]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.085]             })
[17:38:07.085]         }
[17:38:07.085]     }, args = future.call.arguments)
[17:38:07.085] }
[17:38:07.085] Lazy evaluation: FALSE
[17:38:07.085] Asynchronous evaluation: FALSE
[17:38:07.085] Local evaluation: TRUE
[17:38:07.085] Environment: R_GlobalEnv
[17:38:07.085] Capture standard output: TRUE
[17:38:07.085] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.085] Globals: 11 objects totaling 138.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.085] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:38:07.085] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.085] Resolved: TRUE
[17:38:07.085] Value: 672 bytes of class ‘list’
[17:38:07.085] Early signaling: FALSE
[17:38:07.085] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.085] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:07.086] Chunk #1 of 1 ... DONE
[17:38:07.086] Launching 1 futures (chunks) ... DONE
[17:38:07.086] Resolving 1 futures (chunks) ...
[17:38:07.086] resolve() on list ...
[17:38:07.086]  recursive: 0
[17:38:07.086]  length: 1
[17:38:07.087] 
[17:38:07.087] resolved() for ‘SequentialFuture’ ...
[17:38:07.087] - state: ‘finished’
[17:38:07.087] - run: TRUE
[17:38:07.087] - result: ‘FutureResult’
[17:38:07.087] resolved() for ‘SequentialFuture’ ... done
[17:38:07.087] Future #1
[17:38:07.087] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:07.087] - nx: 1
[17:38:07.087] - relay: TRUE
[17:38:07.088] - stdout: TRUE
[17:38:07.088] - signal: TRUE
[17:38:07.088] - resignal: FALSE
[17:38:07.088] - force: TRUE
[17:38:07.088] - relayed: [n=1] FALSE
[17:38:07.088] - queued futures: [n=1] FALSE
[17:38:07.088]  - until=1
[17:38:07.088]  - relaying element #1
[17:38:07.088] - relayed: [n=1] TRUE
[17:38:07.088] - queued futures: [n=1] TRUE
[17:38:07.089] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:07.089]  length: 0 (resolved future 1)
[17:38:07.089] Relaying remaining futures
[17:38:07.089] signalConditionsASAP(NULL, pos=0) ...
[17:38:07.089] - nx: 1
[17:38:07.089] - relay: TRUE
[17:38:07.089] - stdout: TRUE
[17:38:07.089] - signal: TRUE
[17:38:07.089] - resignal: FALSE
[17:38:07.089] - force: TRUE
[17:38:07.089] - relayed: [n=1] TRUE
[17:38:07.089] - queued futures: [n=1] TRUE
 - flush all
[17:38:07.090] - relayed: [n=1] TRUE
[17:38:07.090] - queued futures: [n=1] TRUE
[17:38:07.090] signalConditionsASAP(NULL, pos=0) ... done
[17:38:07.090] resolve() on list ... DONE
[17:38:07.090]  - Number of value chunks collected: 1
[17:38:07.090] Resolving 1 futures (chunks) ... DONE
[17:38:07.090] Reducing values from 1 chunks ...
[17:38:07.090]  - Number of values collected after concatenation: 7
[17:38:07.090]  - Number of values expected: 7
[17:38:07.091] Reducing values from 1 chunks ... DONE
[17:38:07.091] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[17:38:07.092] future_lapply() ...
[17:38:07.093] Number of chunks: 1
[17:38:07.093] getGlobalsAndPackagesXApply() ...
[17:38:07.093]  - future.globals: TRUE
[17:38:07.093] getGlobalsAndPackages() ...
[17:38:07.093] Searching for globals...
[17:38:07.094] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[17:38:07.095] Searching for globals ... DONE
[17:38:07.095] Resolving globals: FALSE
[17:38:07.095] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[17:38:07.095] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[17:38:07.095] - globals: [1] ‘FUN’
[17:38:07.096] 
[17:38:07.096] getGlobalsAndPackages() ... DONE
[17:38:07.096]  - globals found/used: [n=1] ‘FUN’
[17:38:07.096]  - needed namespaces: [n=0] 
[17:38:07.096] Finding globals ... DONE
[17:38:07.096]  - use_args: TRUE
[17:38:07.096]  - Getting '...' globals ...
[17:38:07.096] resolve() on list ...
[17:38:07.097]  recursive: 0
[17:38:07.097]  length: 1
[17:38:07.097]  elements: ‘...’
[17:38:07.097]  length: 0 (resolved future 1)
[17:38:07.097] resolve() on list ... DONE
[17:38:07.097]    - '...' content: [n=1] ‘y’
[17:38:07.097] List of 1
[17:38:07.097]  $ ...:List of 1
[17:38:07.097]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:07.097]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.097]  - attr(*, "where")=List of 1
[17:38:07.097]   ..$ ...:<environment: 0x5608015ae048> 
[17:38:07.097]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.097]  - attr(*, "resolved")= logi TRUE
[17:38:07.097]  - attr(*, "total_size")= num NA
[17:38:07.100]  - Getting '...' globals ... DONE
[17:38:07.100] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:07.100] List of 2
[17:38:07.100]  $ ...future.FUN:function (x, y)  
[17:38:07.100]  $ ...          :List of 1
[17:38:07.100]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:07.100]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.100]  - attr(*, "where")=List of 2
[17:38:07.100]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:07.100]   ..$ ...          :<environment: 0x5608015ae048> 
[17:38:07.100]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.100]  - attr(*, "resolved")= logi FALSE
[17:38:07.100]  - attr(*, "total_size")= num 4264
[17:38:07.105] Packages to be attached in all futures: [n=0] 
[17:38:07.105] getGlobalsAndPackagesXApply() ... DONE
[17:38:07.105] Number of futures (= number of chunks): 1
[17:38:07.105] Launching 1 futures (chunks) ...
[17:38:07.105] Chunk #1 of 1 ...
[17:38:07.106]  - Finding globals in 'X' for chunk #1 ...
[17:38:07.106] getGlobalsAndPackages() ...
[17:38:07.106] Searching for globals...
[17:38:07.106] 
[17:38:07.106] Searching for globals ... DONE
[17:38:07.106] - globals: [0] <none>
[17:38:07.106] getGlobalsAndPackages() ... DONE
[17:38:07.106]    + additional globals found: [n=0] 
[17:38:07.106]    + additional namespaces needed: [n=0] 
[17:38:07.107]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:07.107]  - seeds: <none>
[17:38:07.107]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.107] getGlobalsAndPackages() ...
[17:38:07.107] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.107] Resolving globals: FALSE
[17:38:07.107] Tweak future expression to call with '...' arguments ...
[17:38:07.107] {
[17:38:07.107]     do.call(function(...) {
[17:38:07.107]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.107]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.107]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.107]             on.exit(options(oopts), add = TRUE)
[17:38:07.107]         }
[17:38:07.107]         {
[17:38:07.107]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.107]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.107]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.107]             })
[17:38:07.107]         }
[17:38:07.107]     }, args = future.call.arguments)
[17:38:07.107] }
[17:38:07.108] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.108] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.108] 
[17:38:07.108] getGlobalsAndPackages() ... DONE
[17:38:07.108] run() for ‘Future’ ...
[17:38:07.108] - state: ‘created’
[17:38:07.109] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:07.109] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:07.109] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:07.109]   - Field: ‘label’
[17:38:07.109]   - Field: ‘local’
[17:38:07.109]   - Field: ‘owner’
[17:38:07.109]   - Field: ‘envir’
[17:38:07.109]   - Field: ‘packages’
[17:38:07.110]   - Field: ‘gc’
[17:38:07.110]   - Field: ‘conditions’
[17:38:07.110]   - Field: ‘expr’
[17:38:07.110]   - Field: ‘uuid’
[17:38:07.110]   - Field: ‘seed’
[17:38:07.110]   - Field: ‘version’
[17:38:07.110]   - Field: ‘result’
[17:38:07.110]   - Field: ‘asynchronous’
[17:38:07.110]   - Field: ‘calls’
[17:38:07.110]   - Field: ‘globals’
[17:38:07.110]   - Field: ‘stdout’
[17:38:07.111]   - Field: ‘earlySignal’
[17:38:07.111]   - Field: ‘lazy’
[17:38:07.111]   - Field: ‘state’
[17:38:07.111] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:07.111] - Launch lazy future ...
[17:38:07.111] Packages needed by the future expression (n = 0): <none>
[17:38:07.111] Packages needed by future strategies (n = 0): <none>
[17:38:07.112] {
[17:38:07.112]     {
[17:38:07.112]         {
[17:38:07.112]             ...future.startTime <- base::Sys.time()
[17:38:07.112]             {
[17:38:07.112]                 {
[17:38:07.112]                   {
[17:38:07.112]                     base::local({
[17:38:07.112]                       has_future <- base::requireNamespace("future", 
[17:38:07.112]                         quietly = TRUE)
[17:38:07.112]                       if (has_future) {
[17:38:07.112]                         ns <- base::getNamespace("future")
[17:38:07.112]                         version <- ns[[".package"]][["version"]]
[17:38:07.112]                         if (is.null(version)) 
[17:38:07.112]                           version <- utils::packageVersion("future")
[17:38:07.112]                       }
[17:38:07.112]                       else {
[17:38:07.112]                         version <- NULL
[17:38:07.112]                       }
[17:38:07.112]                       if (!has_future || version < "1.8.0") {
[17:38:07.112]                         info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.112]                           "", base::R.version$version.string), 
[17:38:07.112]                           platform = base::sprintf("%s (%s-bit)", 
[17:38:07.112]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:07.112]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.112]                             "release", "version")], collapse = " "), 
[17:38:07.112]                           hostname = base::Sys.info()[["nodename"]])
[17:38:07.112]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.112]                           info)
[17:38:07.112]                         info <- base::paste(info, collapse = "; ")
[17:38:07.112]                         if (!has_future) {
[17:38:07.112]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.112]                             info)
[17:38:07.112]                         }
[17:38:07.112]                         else {
[17:38:07.112]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.112]                             info, version)
[17:38:07.112]                         }
[17:38:07.112]                         base::stop(msg)
[17:38:07.112]                       }
[17:38:07.112]                     })
[17:38:07.112]                   }
[17:38:07.112]                   ...future.strategy.old <- future::plan("list")
[17:38:07.112]                   options(future.plan = NULL)
[17:38:07.112]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.112]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.112]                 }
[17:38:07.112]                 ...future.workdir <- getwd()
[17:38:07.112]             }
[17:38:07.112]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.112]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.112]         }
[17:38:07.112]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.112]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:07.112]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.112]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.112]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.112]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.112]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.112]             base::names(...future.oldOptions))
[17:38:07.112]     }
[17:38:07.112]     if (FALSE) {
[17:38:07.112]     }
[17:38:07.112]     else {
[17:38:07.112]         if (TRUE) {
[17:38:07.112]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.112]                 open = "w")
[17:38:07.112]         }
[17:38:07.112]         else {
[17:38:07.112]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.112]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.112]         }
[17:38:07.112]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.112]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.112]             base::sink(type = "output", split = FALSE)
[17:38:07.112]             base::close(...future.stdout)
[17:38:07.112]         }, add = TRUE)
[17:38:07.112]     }
[17:38:07.112]     ...future.frame <- base::sys.nframe()
[17:38:07.112]     ...future.conditions <- base::list()
[17:38:07.112]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.112]     if (FALSE) {
[17:38:07.112]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.112]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.112]     }
[17:38:07.112]     ...future.result <- base::tryCatch({
[17:38:07.112]         base::withCallingHandlers({
[17:38:07.112]             ...future.value <- base::withVisible(base::local({
[17:38:07.112]                 do.call(function(...) {
[17:38:07.112]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.112]                   if (!identical(...future.globals.maxSize.org, 
[17:38:07.112]                     ...future.globals.maxSize)) {
[17:38:07.112]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.112]                     on.exit(options(oopts), add = TRUE)
[17:38:07.112]                   }
[17:38:07.112]                   {
[17:38:07.112]                     lapply(seq_along(...future.elements_ii), 
[17:38:07.112]                       FUN = function(jj) {
[17:38:07.112]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.112]                         ...future.FUN(...future.X_jj, ...)
[17:38:07.112]                       })
[17:38:07.112]                   }
[17:38:07.112]                 }, args = future.call.arguments)
[17:38:07.112]             }))
[17:38:07.112]             future::FutureResult(value = ...future.value$value, 
[17:38:07.112]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.112]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.112]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.112]                     ...future.globalenv.names))
[17:38:07.112]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.112]         }, condition = base::local({
[17:38:07.112]             c <- base::c
[17:38:07.112]             inherits <- base::inherits
[17:38:07.112]             invokeRestart <- base::invokeRestart
[17:38:07.112]             length <- base::length
[17:38:07.112]             list <- base::list
[17:38:07.112]             seq.int <- base::seq.int
[17:38:07.112]             signalCondition <- base::signalCondition
[17:38:07.112]             sys.calls <- base::sys.calls
[17:38:07.112]             `[[` <- base::`[[`
[17:38:07.112]             `+` <- base::`+`
[17:38:07.112]             `<<-` <- base::`<<-`
[17:38:07.112]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.112]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.112]                   3L)]
[17:38:07.112]             }
[17:38:07.112]             function(cond) {
[17:38:07.112]                 is_error <- inherits(cond, "error")
[17:38:07.112]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.112]                   NULL)
[17:38:07.112]                 if (is_error) {
[17:38:07.112]                   sessionInformation <- function() {
[17:38:07.112]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.112]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.112]                       search = base::search(), system = base::Sys.info())
[17:38:07.112]                   }
[17:38:07.112]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.112]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.112]                     cond$call), session = sessionInformation(), 
[17:38:07.112]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.112]                   signalCondition(cond)
[17:38:07.112]                 }
[17:38:07.112]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.112]                 "immediateCondition"))) {
[17:38:07.112]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.112]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.112]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.112]                   if (TRUE && !signal) {
[17:38:07.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.112]                     {
[17:38:07.112]                       inherits <- base::inherits
[17:38:07.112]                       invokeRestart <- base::invokeRestart
[17:38:07.112]                       is.null <- base::is.null
[17:38:07.112]                       muffled <- FALSE
[17:38:07.112]                       if (inherits(cond, "message")) {
[17:38:07.112]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.112]                         if (muffled) 
[17:38:07.112]                           invokeRestart("muffleMessage")
[17:38:07.112]                       }
[17:38:07.112]                       else if (inherits(cond, "warning")) {
[17:38:07.112]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.112]                         if (muffled) 
[17:38:07.112]                           invokeRestart("muffleWarning")
[17:38:07.112]                       }
[17:38:07.112]                       else if (inherits(cond, "condition")) {
[17:38:07.112]                         if (!is.null(pattern)) {
[17:38:07.112]                           computeRestarts <- base::computeRestarts
[17:38:07.112]                           grepl <- base::grepl
[17:38:07.112]                           restarts <- computeRestarts(cond)
[17:38:07.112]                           for (restart in restarts) {
[17:38:07.112]                             name <- restart$name
[17:38:07.112]                             if (is.null(name)) 
[17:38:07.112]                               next
[17:38:07.112]                             if (!grepl(pattern, name)) 
[17:38:07.112]                               next
[17:38:07.112]                             invokeRestart(restart)
[17:38:07.112]                             muffled <- TRUE
[17:38:07.112]                             break
[17:38:07.112]                           }
[17:38:07.112]                         }
[17:38:07.112]                       }
[17:38:07.112]                       invisible(muffled)
[17:38:07.112]                     }
[17:38:07.112]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.112]                   }
[17:38:07.112]                 }
[17:38:07.112]                 else {
[17:38:07.112]                   if (TRUE) {
[17:38:07.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.112]                     {
[17:38:07.112]                       inherits <- base::inherits
[17:38:07.112]                       invokeRestart <- base::invokeRestart
[17:38:07.112]                       is.null <- base::is.null
[17:38:07.112]                       muffled <- FALSE
[17:38:07.112]                       if (inherits(cond, "message")) {
[17:38:07.112]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.112]                         if (muffled) 
[17:38:07.112]                           invokeRestart("muffleMessage")
[17:38:07.112]                       }
[17:38:07.112]                       else if (inherits(cond, "warning")) {
[17:38:07.112]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.112]                         if (muffled) 
[17:38:07.112]                           invokeRestart("muffleWarning")
[17:38:07.112]                       }
[17:38:07.112]                       else if (inherits(cond, "condition")) {
[17:38:07.112]                         if (!is.null(pattern)) {
[17:38:07.112]                           computeRestarts <- base::computeRestarts
[17:38:07.112]                           grepl <- base::grepl
[17:38:07.112]                           restarts <- computeRestarts(cond)
[17:38:07.112]                           for (restart in restarts) {
[17:38:07.112]                             name <- restart$name
[17:38:07.112]                             if (is.null(name)) 
[17:38:07.112]                               next
[17:38:07.112]                             if (!grepl(pattern, name)) 
[17:38:07.112]                               next
[17:38:07.112]                             invokeRestart(restart)
[17:38:07.112]                             muffled <- TRUE
[17:38:07.112]                             break
[17:38:07.112]                           }
[17:38:07.112]                         }
[17:38:07.112]                       }
[17:38:07.112]                       invisible(muffled)
[17:38:07.112]                     }
[17:38:07.112]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.112]                   }
[17:38:07.112]                 }
[17:38:07.112]             }
[17:38:07.112]         }))
[17:38:07.112]     }, error = function(ex) {
[17:38:07.112]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.112]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.112]                 ...future.rng), started = ...future.startTime, 
[17:38:07.112]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.112]             version = "1.8"), class = "FutureResult")
[17:38:07.112]     }, finally = {
[17:38:07.112]         if (!identical(...future.workdir, getwd())) 
[17:38:07.112]             setwd(...future.workdir)
[17:38:07.112]         {
[17:38:07.112]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.112]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.112]             }
[17:38:07.112]             base::options(...future.oldOptions)
[17:38:07.112]             if (.Platform$OS.type == "windows") {
[17:38:07.112]                 old_names <- names(...future.oldEnvVars)
[17:38:07.112]                 envs <- base::Sys.getenv()
[17:38:07.112]                 names <- names(envs)
[17:38:07.112]                 common <- intersect(names, old_names)
[17:38:07.112]                 added <- setdiff(names, old_names)
[17:38:07.112]                 removed <- setdiff(old_names, names)
[17:38:07.112]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.112]                   envs[common]]
[17:38:07.112]                 NAMES <- toupper(changed)
[17:38:07.112]                 args <- list()
[17:38:07.112]                 for (kk in seq_along(NAMES)) {
[17:38:07.112]                   name <- changed[[kk]]
[17:38:07.112]                   NAME <- NAMES[[kk]]
[17:38:07.112]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.112]                     next
[17:38:07.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.112]                 }
[17:38:07.112]                 NAMES <- toupper(added)
[17:38:07.112]                 for (kk in seq_along(NAMES)) {
[17:38:07.112]                   name <- added[[kk]]
[17:38:07.112]                   NAME <- NAMES[[kk]]
[17:38:07.112]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.112]                     next
[17:38:07.112]                   args[[name]] <- ""
[17:38:07.112]                 }
[17:38:07.112]                 NAMES <- toupper(removed)
[17:38:07.112]                 for (kk in seq_along(NAMES)) {
[17:38:07.112]                   name <- removed[[kk]]
[17:38:07.112]                   NAME <- NAMES[[kk]]
[17:38:07.112]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.112]                     next
[17:38:07.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.112]                 }
[17:38:07.112]                 if (length(args) > 0) 
[17:38:07.112]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.112]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.112]             }
[17:38:07.112]             else {
[17:38:07.112]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.112]             }
[17:38:07.112]             {
[17:38:07.112]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.112]                   0L) {
[17:38:07.112]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.112]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.112]                   base::options(opts)
[17:38:07.112]                 }
[17:38:07.112]                 {
[17:38:07.112]                   {
[17:38:07.112]                     NULL
[17:38:07.112]                     RNGkind("Mersenne-Twister")
[17:38:07.112]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:07.112]                       inherits = FALSE)
[17:38:07.112]                   }
[17:38:07.112]                   options(future.plan = NULL)
[17:38:07.112]                   if (is.na(NA_character_)) 
[17:38:07.112]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.112]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.112]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.112]                     .init = FALSE)
[17:38:07.112]                 }
[17:38:07.112]             }
[17:38:07.112]         }
[17:38:07.112]     })
[17:38:07.112]     if (TRUE) {
[17:38:07.112]         base::sink(type = "output", split = FALSE)
[17:38:07.112]         if (TRUE) {
[17:38:07.112]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.112]         }
[17:38:07.112]         else {
[17:38:07.112]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.112]         }
[17:38:07.112]         base::close(...future.stdout)
[17:38:07.112]         ...future.stdout <- NULL
[17:38:07.112]     }
[17:38:07.112]     ...future.result$conditions <- ...future.conditions
[17:38:07.112]     ...future.result$finished <- base::Sys.time()
[17:38:07.112]     ...future.result
[17:38:07.112] }
[17:38:07.113] assign_globals() ...
[17:38:07.113] List of 5
[17:38:07.113]  $ ...future.FUN            :function (x, y)  
[17:38:07.113]  $ future.call.arguments    :List of 1
[17:38:07.113]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:07.113]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.113]  $ ...future.elements_ii    :List of 4
[17:38:07.113]   ..$ A: num 50
[17:38:07.113]   ..$ B: num 60
[17:38:07.113]   ..$ C: num 70
[17:38:07.113]   ..$ D: num 80
[17:38:07.113]  $ ...future.seeds_ii       : NULL
[17:38:07.113]  $ ...future.globals.maxSize: NULL
[17:38:07.113]  - attr(*, "where")=List of 5
[17:38:07.113]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.113]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.113]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.113]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.113]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.113]  - attr(*, "resolved")= logi FALSE
[17:38:07.113]  - attr(*, "total_size")= num 4264
[17:38:07.113]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.113]  - attr(*, "already-done")= logi TRUE
[17:38:07.119] - reassign environment for ‘...future.FUN’
[17:38:07.119] - copied ‘...future.FUN’ to environment
[17:38:07.119] - copied ‘future.call.arguments’ to environment
[17:38:07.119] - copied ‘...future.elements_ii’ to environment
[17:38:07.119] - copied ‘...future.seeds_ii’ to environment
[17:38:07.120] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.120] assign_globals() ... done
[17:38:07.120] plan(): Setting new future strategy stack:
[17:38:07.120] List of future strategies:
[17:38:07.120] 1. sequential:
[17:38:07.120]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.120]    - tweaked: FALSE
[17:38:07.120]    - call: NULL
[17:38:07.120] plan(): nbrOfWorkers() = 1
[17:38:07.121] plan(): Setting new future strategy stack:
[17:38:07.121] List of future strategies:
[17:38:07.121] 1. sequential:
[17:38:07.121]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.121]    - tweaked: FALSE
[17:38:07.121]    - call: plan(strategy)
[17:38:07.122] plan(): nbrOfWorkers() = 1
[17:38:07.122] SequentialFuture started (and completed)
[17:38:07.122] - Launch lazy future ... done
[17:38:07.122] run() for ‘SequentialFuture’ ... done
[17:38:07.122] Created future:
[17:38:07.122] SequentialFuture:
[17:38:07.122] Label: ‘future_sapply-1’
[17:38:07.122] Expression:
[17:38:07.122] {
[17:38:07.122]     do.call(function(...) {
[17:38:07.122]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.122]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.122]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.122]             on.exit(options(oopts), add = TRUE)
[17:38:07.122]         }
[17:38:07.122]         {
[17:38:07.122]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.122]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.122]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.122]             })
[17:38:07.122]         }
[17:38:07.122]     }, args = future.call.arguments)
[17:38:07.122] }
[17:38:07.122] Lazy evaluation: FALSE
[17:38:07.122] Asynchronous evaluation: FALSE
[17:38:07.122] Local evaluation: TRUE
[17:38:07.122] Environment: R_GlobalEnv
[17:38:07.122] Capture standard output: TRUE
[17:38:07.122] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.122] Globals: 5 objects totaling 4.38 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:07.122] Packages: <none>
[17:38:07.122] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.122] Resolved: TRUE
[17:38:07.122] Value: 1.34 KiB of class ‘list’
[17:38:07.122] Early signaling: FALSE
[17:38:07.122] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.122] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:07.123] Chunk #1 of 1 ... DONE
[17:38:07.123] Launching 1 futures (chunks) ... DONE
[17:38:07.124] Resolving 1 futures (chunks) ...
[17:38:07.124] resolve() on list ...
[17:38:07.124]  recursive: 0
[17:38:07.124]  length: 1
[17:38:07.124] 
[17:38:07.124] resolved() for ‘SequentialFuture’ ...
[17:38:07.124] - state: ‘finished’
[17:38:07.124] - run: TRUE
[17:38:07.124] - result: ‘FutureResult’
[17:38:07.124] resolved() for ‘SequentialFuture’ ... done
[17:38:07.125] Future #1
[17:38:07.125] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:07.125] - nx: 1
[17:38:07.125] - relay: TRUE
[17:38:07.125] - stdout: TRUE
[17:38:07.125] - signal: TRUE
[17:38:07.125] - resignal: FALSE
[17:38:07.125] - force: TRUE
[17:38:07.125] - relayed: [n=1] FALSE
[17:38:07.125] - queued futures: [n=1] FALSE
[17:38:07.126]  - until=1
[17:38:07.126]  - relaying element #1
[17:38:07.126] - relayed: [n=1] TRUE
[17:38:07.126] - queued futures: [n=1] TRUE
[17:38:07.126] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:07.126]  length: 0 (resolved future 1)
[17:38:07.126] Relaying remaining futures
[17:38:07.126] signalConditionsASAP(NULL, pos=0) ...
[17:38:07.126] - nx: 1
[17:38:07.126] - relay: TRUE
[17:38:07.126] - stdout: TRUE
[17:38:07.127] - signal: TRUE
[17:38:07.127] - resignal: FALSE
[17:38:07.127] - force: TRUE
[17:38:07.127] - relayed: [n=1] TRUE
[17:38:07.127] - queued futures: [n=1] TRUE
 - flush all
[17:38:07.127] - relayed: [n=1] TRUE
[17:38:07.127] - queued futures: [n=1] TRUE
[17:38:07.127] signalConditionsASAP(NULL, pos=0) ... done
[17:38:07.127] resolve() on list ... DONE
[17:38:07.127]  - Number of value chunks collected: 1
[17:38:07.128] Resolving 1 futures (chunks) ... DONE
[17:38:07.128] Reducing values from 1 chunks ...
[17:38:07.128]  - Number of values collected after concatenation: 4
[17:38:07.128]  - Number of values expected: 4
[17:38:07.128] Reducing values from 1 chunks ... DONE
[17:38:07.128] future_lapply() ... DONE
[17:38:07.130] future_lapply() ...
[17:38:07.132] Number of chunks: 1
[17:38:07.132] getGlobalsAndPackagesXApply() ...
[17:38:07.132]  - future.globals: TRUE
[17:38:07.132] getGlobalsAndPackages() ...
[17:38:07.133] Searching for globals...
[17:38:07.136] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[17:38:07.136] Searching for globals ... DONE
[17:38:07.136] Resolving globals: FALSE
[17:38:07.137] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[17:38:07.138] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:07.138] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.138] - packages: [1] ‘future.apply’
[17:38:07.138] getGlobalsAndPackages() ... DONE
[17:38:07.138]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.138]  - needed namespaces: [n=1] ‘future.apply’
[17:38:07.138] Finding globals ... DONE
[17:38:07.139]  - use_args: TRUE
[17:38:07.139]  - Getting '...' globals ...
[17:38:07.139] resolve() on list ...
[17:38:07.139]  recursive: 0
[17:38:07.139]  length: 1
[17:38:07.139]  elements: ‘...’
[17:38:07.139]  length: 0 (resolved future 1)
[17:38:07.139] resolve() on list ... DONE
[17:38:07.140]    - '...' content: [n=1] ‘y’
[17:38:07.140] List of 1
[17:38:07.140]  $ ...:List of 1
[17:38:07.140]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:07.140]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.140]  - attr(*, "where")=List of 1
[17:38:07.140]   ..$ ...:<environment: 0x5607ff71fa50> 
[17:38:07.140]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.140]  - attr(*, "resolved")= logi TRUE
[17:38:07.140]  - attr(*, "total_size")= num NA
[17:38:07.143]  - Getting '...' globals ... DONE
[17:38:07.143] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:07.143] List of 8
[17:38:07.143]  $ ...future.FUN:function (x, ...)  
[17:38:07.143]  $ x_FUN        :function (x, y)  
[17:38:07.143]  $ times        : int 15
[17:38:07.143]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.143]  $ stop_if_not  :function (...)  
[17:38:07.143]  $ dim          : int [1:2] 3 5
[17:38:07.143]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:07.143]  $ ...          :List of 1
[17:38:07.143]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:07.143]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.143]  - attr(*, "where")=List of 8
[17:38:07.143]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:07.143]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:07.143]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:07.143]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:07.143]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:07.143]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:07.143]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:07.143]   ..$ ...          :<environment: 0x5607ff71fa50> 
[17:38:07.143]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.143]  - attr(*, "resolved")= logi FALSE
[17:38:07.143]  - attr(*, "total_size")= num 98600
[17:38:07.149] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:07.149] getGlobalsAndPackagesXApply() ... DONE
[17:38:07.150] Number of futures (= number of chunks): 1
[17:38:07.150] Launching 1 futures (chunks) ...
[17:38:07.150] Chunk #1 of 1 ...
[17:38:07.150]  - Finding globals in 'X' for chunk #1 ...
[17:38:07.150] getGlobalsAndPackages() ...
[17:38:07.150] Searching for globals...
[17:38:07.151] 
[17:38:07.151] Searching for globals ... DONE
[17:38:07.151] - globals: [0] <none>
[17:38:07.151] getGlobalsAndPackages() ... DONE
[17:38:07.151]    + additional globals found: [n=0] 
[17:38:07.151]    + additional namespaces needed: [n=0] 
[17:38:07.151]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:07.151]  - seeds: <none>
[17:38:07.151]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.151] getGlobalsAndPackages() ...
[17:38:07.152] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.152] Resolving globals: FALSE
[17:38:07.152] Tweak future expression to call with '...' arguments ...
[17:38:07.152] {
[17:38:07.152]     do.call(function(...) {
[17:38:07.152]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.152]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.152]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.152]             on.exit(options(oopts), add = TRUE)
[17:38:07.152]         }
[17:38:07.152]         {
[17:38:07.152]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.152]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.152]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.152]             })
[17:38:07.152]         }
[17:38:07.152]     }, args = future.call.arguments)
[17:38:07.152] }
[17:38:07.154] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.155] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.155] - packages: [1] ‘future.apply’
[17:38:07.155] getGlobalsAndPackages() ... DONE
[17:38:07.156] run() for ‘Future’ ...
[17:38:07.156] - state: ‘created’
[17:38:07.156] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:07.156] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:07.156] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:07.157]   - Field: ‘label’
[17:38:07.157]   - Field: ‘local’
[17:38:07.157]   - Field: ‘owner’
[17:38:07.157]   - Field: ‘envir’
[17:38:07.157]   - Field: ‘packages’
[17:38:07.157]   - Field: ‘gc’
[17:38:07.157]   - Field: ‘conditions’
[17:38:07.157]   - Field: ‘expr’
[17:38:07.157]   - Field: ‘uuid’
[17:38:07.158]   - Field: ‘seed’
[17:38:07.158]   - Field: ‘version’
[17:38:07.158]   - Field: ‘result’
[17:38:07.158]   - Field: ‘asynchronous’
[17:38:07.158]   - Field: ‘calls’
[17:38:07.158]   - Field: ‘globals’
[17:38:07.158]   - Field: ‘stdout’
[17:38:07.158]   - Field: ‘earlySignal’
[17:38:07.158]   - Field: ‘lazy’
[17:38:07.158]   - Field: ‘state’
[17:38:07.159] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:07.159] - Launch lazy future ...
[17:38:07.159] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:07.159] Packages needed by future strategies (n = 0): <none>
[17:38:07.159] {
[17:38:07.159]     {
[17:38:07.159]         {
[17:38:07.159]             ...future.startTime <- base::Sys.time()
[17:38:07.159]             {
[17:38:07.159]                 {
[17:38:07.159]                   {
[17:38:07.159]                     {
[17:38:07.159]                       base::local({
[17:38:07.159]                         has_future <- base::requireNamespace("future", 
[17:38:07.159]                           quietly = TRUE)
[17:38:07.159]                         if (has_future) {
[17:38:07.159]                           ns <- base::getNamespace("future")
[17:38:07.159]                           version <- ns[[".package"]][["version"]]
[17:38:07.159]                           if (is.null(version)) 
[17:38:07.159]                             version <- utils::packageVersion("future")
[17:38:07.159]                         }
[17:38:07.159]                         else {
[17:38:07.159]                           version <- NULL
[17:38:07.159]                         }
[17:38:07.159]                         if (!has_future || version < "1.8.0") {
[17:38:07.159]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.159]                             "", base::R.version$version.string), 
[17:38:07.159]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:07.159]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:07.159]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.159]                               "release", "version")], collapse = " "), 
[17:38:07.159]                             hostname = base::Sys.info()[["nodename"]])
[17:38:07.159]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.159]                             info)
[17:38:07.159]                           info <- base::paste(info, collapse = "; ")
[17:38:07.159]                           if (!has_future) {
[17:38:07.159]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.159]                               info)
[17:38:07.159]                           }
[17:38:07.159]                           else {
[17:38:07.159]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.159]                               info, version)
[17:38:07.159]                           }
[17:38:07.159]                           base::stop(msg)
[17:38:07.159]                         }
[17:38:07.159]                       })
[17:38:07.159]                     }
[17:38:07.159]                     base::local({
[17:38:07.159]                       for (pkg in "future.apply") {
[17:38:07.159]                         base::loadNamespace(pkg)
[17:38:07.159]                         base::library(pkg, character.only = TRUE)
[17:38:07.159]                       }
[17:38:07.159]                     })
[17:38:07.159]                   }
[17:38:07.159]                   ...future.strategy.old <- future::plan("list")
[17:38:07.159]                   options(future.plan = NULL)
[17:38:07.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.159]                 }
[17:38:07.159]                 ...future.workdir <- getwd()
[17:38:07.159]             }
[17:38:07.159]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.159]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.159]         }
[17:38:07.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.159]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:07.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.159]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.159]             base::names(...future.oldOptions))
[17:38:07.159]     }
[17:38:07.159]     if (FALSE) {
[17:38:07.159]     }
[17:38:07.159]     else {
[17:38:07.159]         if (TRUE) {
[17:38:07.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.159]                 open = "w")
[17:38:07.159]         }
[17:38:07.159]         else {
[17:38:07.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.159]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.159]         }
[17:38:07.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.159]             base::sink(type = "output", split = FALSE)
[17:38:07.159]             base::close(...future.stdout)
[17:38:07.159]         }, add = TRUE)
[17:38:07.159]     }
[17:38:07.159]     ...future.frame <- base::sys.nframe()
[17:38:07.159]     ...future.conditions <- base::list()
[17:38:07.159]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.159]     if (FALSE) {
[17:38:07.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.159]     }
[17:38:07.159]     ...future.result <- base::tryCatch({
[17:38:07.159]         base::withCallingHandlers({
[17:38:07.159]             ...future.value <- base::withVisible(base::local({
[17:38:07.159]                 do.call(function(...) {
[17:38:07.159]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.159]                   if (!identical(...future.globals.maxSize.org, 
[17:38:07.159]                     ...future.globals.maxSize)) {
[17:38:07.159]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.159]                     on.exit(options(oopts), add = TRUE)
[17:38:07.159]                   }
[17:38:07.159]                   {
[17:38:07.159]                     lapply(seq_along(...future.elements_ii), 
[17:38:07.159]                       FUN = function(jj) {
[17:38:07.159]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.159]                         ...future.FUN(...future.X_jj, ...)
[17:38:07.159]                       })
[17:38:07.159]                   }
[17:38:07.159]                 }, args = future.call.arguments)
[17:38:07.159]             }))
[17:38:07.159]             future::FutureResult(value = ...future.value$value, 
[17:38:07.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.159]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.159]                     ...future.globalenv.names))
[17:38:07.159]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.159]         }, condition = base::local({
[17:38:07.159]             c <- base::c
[17:38:07.159]             inherits <- base::inherits
[17:38:07.159]             invokeRestart <- base::invokeRestart
[17:38:07.159]             length <- base::length
[17:38:07.159]             list <- base::list
[17:38:07.159]             seq.int <- base::seq.int
[17:38:07.159]             signalCondition <- base::signalCondition
[17:38:07.159]             sys.calls <- base::sys.calls
[17:38:07.159]             `[[` <- base::`[[`
[17:38:07.159]             `+` <- base::`+`
[17:38:07.159]             `<<-` <- base::`<<-`
[17:38:07.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.159]                   3L)]
[17:38:07.159]             }
[17:38:07.159]             function(cond) {
[17:38:07.159]                 is_error <- inherits(cond, "error")
[17:38:07.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.159]                   NULL)
[17:38:07.159]                 if (is_error) {
[17:38:07.159]                   sessionInformation <- function() {
[17:38:07.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.159]                       search = base::search(), system = base::Sys.info())
[17:38:07.159]                   }
[17:38:07.159]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.159]                     cond$call), session = sessionInformation(), 
[17:38:07.159]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.159]                   signalCondition(cond)
[17:38:07.159]                 }
[17:38:07.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.159]                 "immediateCondition"))) {
[17:38:07.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.159]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.159]                   if (TRUE && !signal) {
[17:38:07.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.159]                     {
[17:38:07.159]                       inherits <- base::inherits
[17:38:07.159]                       invokeRestart <- base::invokeRestart
[17:38:07.159]                       is.null <- base::is.null
[17:38:07.159]                       muffled <- FALSE
[17:38:07.159]                       if (inherits(cond, "message")) {
[17:38:07.159]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.159]                         if (muffled) 
[17:38:07.159]                           invokeRestart("muffleMessage")
[17:38:07.159]                       }
[17:38:07.159]                       else if (inherits(cond, "warning")) {
[17:38:07.159]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.159]                         if (muffled) 
[17:38:07.159]                           invokeRestart("muffleWarning")
[17:38:07.159]                       }
[17:38:07.159]                       else if (inherits(cond, "condition")) {
[17:38:07.159]                         if (!is.null(pattern)) {
[17:38:07.159]                           computeRestarts <- base::computeRestarts
[17:38:07.159]                           grepl <- base::grepl
[17:38:07.159]                           restarts <- computeRestarts(cond)
[17:38:07.159]                           for (restart in restarts) {
[17:38:07.159]                             name <- restart$name
[17:38:07.159]                             if (is.null(name)) 
[17:38:07.159]                               next
[17:38:07.159]                             if (!grepl(pattern, name)) 
[17:38:07.159]                               next
[17:38:07.159]                             invokeRestart(restart)
[17:38:07.159]                             muffled <- TRUE
[17:38:07.159]                             break
[17:38:07.159]                           }
[17:38:07.159]                         }
[17:38:07.159]                       }
[17:38:07.159]                       invisible(muffled)
[17:38:07.159]                     }
[17:38:07.159]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.159]                   }
[17:38:07.159]                 }
[17:38:07.159]                 else {
[17:38:07.159]                   if (TRUE) {
[17:38:07.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.159]                     {
[17:38:07.159]                       inherits <- base::inherits
[17:38:07.159]                       invokeRestart <- base::invokeRestart
[17:38:07.159]                       is.null <- base::is.null
[17:38:07.159]                       muffled <- FALSE
[17:38:07.159]                       if (inherits(cond, "message")) {
[17:38:07.159]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.159]                         if (muffled) 
[17:38:07.159]                           invokeRestart("muffleMessage")
[17:38:07.159]                       }
[17:38:07.159]                       else if (inherits(cond, "warning")) {
[17:38:07.159]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.159]                         if (muffled) 
[17:38:07.159]                           invokeRestart("muffleWarning")
[17:38:07.159]                       }
[17:38:07.159]                       else if (inherits(cond, "condition")) {
[17:38:07.159]                         if (!is.null(pattern)) {
[17:38:07.159]                           computeRestarts <- base::computeRestarts
[17:38:07.159]                           grepl <- base::grepl
[17:38:07.159]                           restarts <- computeRestarts(cond)
[17:38:07.159]                           for (restart in restarts) {
[17:38:07.159]                             name <- restart$name
[17:38:07.159]                             if (is.null(name)) 
[17:38:07.159]                               next
[17:38:07.159]                             if (!grepl(pattern, name)) 
[17:38:07.159]                               next
[17:38:07.159]                             invokeRestart(restart)
[17:38:07.159]                             muffled <- TRUE
[17:38:07.159]                             break
[17:38:07.159]                           }
[17:38:07.159]                         }
[17:38:07.159]                       }
[17:38:07.159]                       invisible(muffled)
[17:38:07.159]                     }
[17:38:07.159]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.159]                   }
[17:38:07.159]                 }
[17:38:07.159]             }
[17:38:07.159]         }))
[17:38:07.159]     }, error = function(ex) {
[17:38:07.159]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.159]                 ...future.rng), started = ...future.startTime, 
[17:38:07.159]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.159]             version = "1.8"), class = "FutureResult")
[17:38:07.159]     }, finally = {
[17:38:07.159]         if (!identical(...future.workdir, getwd())) 
[17:38:07.159]             setwd(...future.workdir)
[17:38:07.159]         {
[17:38:07.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.159]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.159]             }
[17:38:07.159]             base::options(...future.oldOptions)
[17:38:07.159]             if (.Platform$OS.type == "windows") {
[17:38:07.159]                 old_names <- names(...future.oldEnvVars)
[17:38:07.159]                 envs <- base::Sys.getenv()
[17:38:07.159]                 names <- names(envs)
[17:38:07.159]                 common <- intersect(names, old_names)
[17:38:07.159]                 added <- setdiff(names, old_names)
[17:38:07.159]                 removed <- setdiff(old_names, names)
[17:38:07.159]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.159]                   envs[common]]
[17:38:07.159]                 NAMES <- toupper(changed)
[17:38:07.159]                 args <- list()
[17:38:07.159]                 for (kk in seq_along(NAMES)) {
[17:38:07.159]                   name <- changed[[kk]]
[17:38:07.159]                   NAME <- NAMES[[kk]]
[17:38:07.159]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.159]                     next
[17:38:07.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.159]                 }
[17:38:07.159]                 NAMES <- toupper(added)
[17:38:07.159]                 for (kk in seq_along(NAMES)) {
[17:38:07.159]                   name <- added[[kk]]
[17:38:07.159]                   NAME <- NAMES[[kk]]
[17:38:07.159]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.159]                     next
[17:38:07.159]                   args[[name]] <- ""
[17:38:07.159]                 }
[17:38:07.159]                 NAMES <- toupper(removed)
[17:38:07.159]                 for (kk in seq_along(NAMES)) {
[17:38:07.159]                   name <- removed[[kk]]
[17:38:07.159]                   NAME <- NAMES[[kk]]
[17:38:07.159]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.159]                     next
[17:38:07.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.159]                 }
[17:38:07.159]                 if (length(args) > 0) 
[17:38:07.159]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.159]             }
[17:38:07.159]             else {
[17:38:07.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.159]             }
[17:38:07.159]             {
[17:38:07.159]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.159]                   0L) {
[17:38:07.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.159]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.159]                   base::options(opts)
[17:38:07.159]                 }
[17:38:07.159]                 {
[17:38:07.159]                   {
[17:38:07.159]                     NULL
[17:38:07.159]                     RNGkind("Mersenne-Twister")
[17:38:07.159]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:07.159]                       inherits = FALSE)
[17:38:07.159]                   }
[17:38:07.159]                   options(future.plan = NULL)
[17:38:07.159]                   if (is.na(NA_character_)) 
[17:38:07.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.159]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.159]                     .init = FALSE)
[17:38:07.159]                 }
[17:38:07.159]             }
[17:38:07.159]         }
[17:38:07.159]     })
[17:38:07.159]     if (TRUE) {
[17:38:07.159]         base::sink(type = "output", split = FALSE)
[17:38:07.159]         if (TRUE) {
[17:38:07.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.159]         }
[17:38:07.159]         else {
[17:38:07.159]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.159]         }
[17:38:07.159]         base::close(...future.stdout)
[17:38:07.159]         ...future.stdout <- NULL
[17:38:07.159]     }
[17:38:07.159]     ...future.result$conditions <- ...future.conditions
[17:38:07.159]     ...future.result$finished <- base::Sys.time()
[17:38:07.159]     ...future.result
[17:38:07.159] }
[17:38:07.161] assign_globals() ...
[17:38:07.161] List of 11
[17:38:07.161]  $ ...future.FUN            :function (x, ...)  
[17:38:07.161]  $ x_FUN                    :function (x, y)  
[17:38:07.161]  $ times                    : int 15
[17:38:07.161]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.161]  $ stop_if_not              :function (...)  
[17:38:07.161]  $ dim                      : int [1:2] 3 5
[17:38:07.161]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:07.161]  $ future.call.arguments    :List of 1
[17:38:07.161]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:07.161]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.161]  $ ...future.elements_ii    :List of 4
[17:38:07.161]   ..$ A: num 50
[17:38:07.161]   ..$ B: num 60
[17:38:07.161]   ..$ C: num 70
[17:38:07.161]   ..$ D: num 80
[17:38:07.161]  $ ...future.seeds_ii       : NULL
[17:38:07.161]  $ ...future.globals.maxSize: NULL
[17:38:07.161]  - attr(*, "where")=List of 11
[17:38:07.161]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.161]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.161]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.161]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.161]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.161]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.161]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.161]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.161]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.161]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.161]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.161]  - attr(*, "resolved")= logi FALSE
[17:38:07.161]  - attr(*, "total_size")= num 98600
[17:38:07.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.161]  - attr(*, "already-done")= logi TRUE
[17:38:07.170] - copied ‘...future.FUN’ to environment
[17:38:07.171] - reassign environment for ‘x_FUN’
[17:38:07.171] - copied ‘x_FUN’ to environment
[17:38:07.171] - copied ‘times’ to environment
[17:38:07.171] - copied ‘stopf’ to environment
[17:38:07.171] - copied ‘stop_if_not’ to environment
[17:38:07.171] - copied ‘dim’ to environment
[17:38:07.171] - copied ‘valid_types’ to environment
[17:38:07.171] - copied ‘future.call.arguments’ to environment
[17:38:07.171] - copied ‘...future.elements_ii’ to environment
[17:38:07.171] - copied ‘...future.seeds_ii’ to environment
[17:38:07.171] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.172] assign_globals() ... done
[17:38:07.172] plan(): Setting new future strategy stack:
[17:38:07.172] List of future strategies:
[17:38:07.172] 1. sequential:
[17:38:07.172]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.172]    - tweaked: FALSE
[17:38:07.172]    - call: NULL
[17:38:07.173] plan(): nbrOfWorkers() = 1
[17:38:07.173] plan(): Setting new future strategy stack:
[17:38:07.174] List of future strategies:
[17:38:07.174] 1. sequential:
[17:38:07.174]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.174]    - tweaked: FALSE
[17:38:07.174]    - call: plan(strategy)
[17:38:07.174] plan(): nbrOfWorkers() = 1
[17:38:07.174] SequentialFuture started (and completed)
[17:38:07.174] - Launch lazy future ... done
[17:38:07.174] run() for ‘SequentialFuture’ ... done
[17:38:07.175] Created future:
[17:38:07.175] SequentialFuture:
[17:38:07.175] Label: ‘future_vapply-1’
[17:38:07.175] Expression:
[17:38:07.175] {
[17:38:07.175]     do.call(function(...) {
[17:38:07.175]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.175]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.175]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.175]             on.exit(options(oopts), add = TRUE)
[17:38:07.175]         }
[17:38:07.175]         {
[17:38:07.175]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.175]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.175]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.175]             })
[17:38:07.175]         }
[17:38:07.175]     }, args = future.call.arguments)
[17:38:07.175] }
[17:38:07.175] Lazy evaluation: FALSE
[17:38:07.175] Asynchronous evaluation: FALSE
[17:38:07.175] Local evaluation: TRUE
[17:38:07.175] Environment: R_GlobalEnv
[17:38:07.175] Capture standard output: TRUE
[17:38:07.175] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.175] Globals: 11 objects totaling 96.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.175] Packages: 1 packages (‘future.apply’)
[17:38:07.175] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.175] Resolved: TRUE
[17:38:07.175] Value: 1.34 KiB of class ‘list’
[17:38:07.175] Early signaling: FALSE
[17:38:07.175] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.175] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:07.176] Chunk #1 of 1 ... DONE
[17:38:07.176] Launching 1 futures (chunks) ... DONE
[17:38:07.176] Resolving 1 futures (chunks) ...
[17:38:07.176] resolve() on list ...
[17:38:07.176]  recursive: 0
[17:38:07.176]  length: 1
[17:38:07.177] 
[17:38:07.177] resolved() for ‘SequentialFuture’ ...
[17:38:07.177] - state: ‘finished’
[17:38:07.177] - run: TRUE
[17:38:07.177] - result: ‘FutureResult’
[17:38:07.177] resolved() for ‘SequentialFuture’ ... done
[17:38:07.177] Future #1
[17:38:07.177] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:07.177] - nx: 1
[17:38:07.177] - relay: TRUE
[17:38:07.178] - stdout: TRUE
[17:38:07.178] - signal: TRUE
[17:38:07.178] - resignal: FALSE
[17:38:07.178] - force: TRUE
[17:38:07.178] - relayed: [n=1] FALSE
[17:38:07.178] - queued futures: [n=1] FALSE
[17:38:07.178]  - until=1
[17:38:07.178]  - relaying element #1
[17:38:07.178] - relayed: [n=1] TRUE
[17:38:07.178] - queued futures: [n=1] TRUE
[17:38:07.179] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:07.179]  length: 0 (resolved future 1)
[17:38:07.179] Relaying remaining futures
[17:38:07.179] signalConditionsASAP(NULL, pos=0) ...
[17:38:07.179] - nx: 1
[17:38:07.179] - relay: TRUE
[17:38:07.179] - stdout: TRUE
[17:38:07.181] - signal: TRUE
[17:38:07.181] - resignal: FALSE
[17:38:07.181] - force: TRUE
[17:38:07.181] - relayed: [n=1] TRUE
[17:38:07.182] - queued futures: [n=1] TRUE
 - flush all
[17:38:07.182] - relayed: [n=1] TRUE
[17:38:07.182] - queued futures: [n=1] TRUE
[17:38:07.182] signalConditionsASAP(NULL, pos=0) ... done
[17:38:07.182] resolve() on list ... DONE
[17:38:07.182]  - Number of value chunks collected: 1
[17:38:07.182] Resolving 1 futures (chunks) ... DONE
[17:38:07.183] Reducing values from 1 chunks ...
[17:38:07.183]  - Number of values collected after concatenation: 4
[17:38:07.183]  - Number of values expected: 4
[17:38:07.183] Reducing values from 1 chunks ... DONE
[17:38:07.183] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[17:38:07.185] future_lapply() ...
[17:38:07.187] Number of chunks: 1
[17:38:07.187] getGlobalsAndPackagesXApply() ...
[17:38:07.187]  - future.globals: TRUE
[17:38:07.187] getGlobalsAndPackages() ...
[17:38:07.187] Searching for globals...
[17:38:07.190] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:07.191] Searching for globals ... DONE
[17:38:07.191] Resolving globals: FALSE
[17:38:07.191] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[17:38:07.192] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:07.192] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.192] - packages: [1] ‘future.apply’
[17:38:07.192] getGlobalsAndPackages() ... DONE
[17:38:07.192]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.193]  - needed namespaces: [n=1] ‘future.apply’
[17:38:07.193] Finding globals ... DONE
[17:38:07.193]  - use_args: TRUE
[17:38:07.193]  - Getting '...' globals ...
[17:38:07.193] resolve() on list ...
[17:38:07.193]  recursive: 0
[17:38:07.193]  length: 1
[17:38:07.193]  elements: ‘...’
[17:38:07.194]  length: 0 (resolved future 1)
[17:38:07.194] resolve() on list ... DONE
[17:38:07.194]    - '...' content: [n=0] 
[17:38:07.194] List of 1
[17:38:07.194]  $ ...: list()
[17:38:07.194]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.194]  - attr(*, "where")=List of 1
[17:38:07.194]   ..$ ...:<environment: 0x56080000d098> 
[17:38:07.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.194]  - attr(*, "resolved")= logi TRUE
[17:38:07.194]  - attr(*, "total_size")= num NA
[17:38:07.196]  - Getting '...' globals ... DONE
[17:38:07.197] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:07.197] List of 8
[17:38:07.197]  $ ...future.FUN:function (x, ...)  
[17:38:07.197]  $ x_FUN        :function (x)  
[17:38:07.197]  $ times        : int 1
[17:38:07.197]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.197]  $ stop_if_not  :function (...)  
[17:38:07.197]  $ dim          : NULL
[17:38:07.197]  $ valid_types  : chr "logical"
[17:38:07.197]  $ ...          : list()
[17:38:07.197]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.197]  - attr(*, "where")=List of 8
[17:38:07.197]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:07.197]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:07.197]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:07.197]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:07.197]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:07.197]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:07.197]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:07.197]   ..$ ...          :<environment: 0x56080000d098> 
[17:38:07.197]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.197]  - attr(*, "resolved")= logi FALSE
[17:38:07.197]  - attr(*, "total_size")= num 94200
[17:38:07.202] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:07.202] getGlobalsAndPackagesXApply() ... DONE
[17:38:07.202] Number of futures (= number of chunks): 1
[17:38:07.202] Launching 1 futures (chunks) ...
[17:38:07.203] Chunk #1 of 1 ...
[17:38:07.203]  - Finding globals in 'X' for chunk #1 ...
[17:38:07.203] getGlobalsAndPackages() ...
[17:38:07.203] Searching for globals...
[17:38:07.203] 
[17:38:07.203] Searching for globals ... DONE
[17:38:07.203] - globals: [0] <none>
[17:38:07.205] getGlobalsAndPackages() ... DONE
[17:38:07.205]    + additional globals found: [n=0] 
[17:38:07.205]    + additional namespaces needed: [n=0] 
[17:38:07.206]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:07.206]  - seeds: <none>
[17:38:07.206]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.206] getGlobalsAndPackages() ...
[17:38:07.206] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.206] Resolving globals: FALSE
[17:38:07.206] Tweak future expression to call with '...' arguments ...
[17:38:07.206] {
[17:38:07.206]     do.call(function(...) {
[17:38:07.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.206]             on.exit(options(oopts), add = TRUE)
[17:38:07.206]         }
[17:38:07.206]         {
[17:38:07.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.206]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.206]             })
[17:38:07.206]         }
[17:38:07.206]     }, args = future.call.arguments)
[17:38:07.206] }
[17:38:07.207] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.207] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.207] - packages: [1] ‘future.apply’
[17:38:07.208] getGlobalsAndPackages() ... DONE
[17:38:07.208] run() for ‘Future’ ...
[17:38:07.208] - state: ‘created’
[17:38:07.208] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:07.208] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:07.209] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:07.209]   - Field: ‘label’
[17:38:07.209]   - Field: ‘local’
[17:38:07.209]   - Field: ‘owner’
[17:38:07.209]   - Field: ‘envir’
[17:38:07.209]   - Field: ‘packages’
[17:38:07.209]   - Field: ‘gc’
[17:38:07.209]   - Field: ‘conditions’
[17:38:07.209]   - Field: ‘expr’
[17:38:07.209]   - Field: ‘uuid’
[17:38:07.209]   - Field: ‘seed’
[17:38:07.210]   - Field: ‘version’
[17:38:07.210]   - Field: ‘result’
[17:38:07.210]   - Field: ‘asynchronous’
[17:38:07.210]   - Field: ‘calls’
[17:38:07.210]   - Field: ‘globals’
[17:38:07.210]   - Field: ‘stdout’
[17:38:07.210]   - Field: ‘earlySignal’
[17:38:07.210]   - Field: ‘lazy’
[17:38:07.210]   - Field: ‘state’
[17:38:07.210] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:07.211] - Launch lazy future ...
[17:38:07.211] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:07.211] Packages needed by future strategies (n = 0): <none>
[17:38:07.211] {
[17:38:07.211]     {
[17:38:07.211]         {
[17:38:07.211]             ...future.startTime <- base::Sys.time()
[17:38:07.211]             {
[17:38:07.211]                 {
[17:38:07.211]                   {
[17:38:07.211]                     {
[17:38:07.211]                       base::local({
[17:38:07.211]                         has_future <- base::requireNamespace("future", 
[17:38:07.211]                           quietly = TRUE)
[17:38:07.211]                         if (has_future) {
[17:38:07.211]                           ns <- base::getNamespace("future")
[17:38:07.211]                           version <- ns[[".package"]][["version"]]
[17:38:07.211]                           if (is.null(version)) 
[17:38:07.211]                             version <- utils::packageVersion("future")
[17:38:07.211]                         }
[17:38:07.211]                         else {
[17:38:07.211]                           version <- NULL
[17:38:07.211]                         }
[17:38:07.211]                         if (!has_future || version < "1.8.0") {
[17:38:07.211]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.211]                             "", base::R.version$version.string), 
[17:38:07.211]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:07.211]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:07.211]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.211]                               "release", "version")], collapse = " "), 
[17:38:07.211]                             hostname = base::Sys.info()[["nodename"]])
[17:38:07.211]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.211]                             info)
[17:38:07.211]                           info <- base::paste(info, collapse = "; ")
[17:38:07.211]                           if (!has_future) {
[17:38:07.211]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.211]                               info)
[17:38:07.211]                           }
[17:38:07.211]                           else {
[17:38:07.211]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.211]                               info, version)
[17:38:07.211]                           }
[17:38:07.211]                           base::stop(msg)
[17:38:07.211]                         }
[17:38:07.211]                       })
[17:38:07.211]                     }
[17:38:07.211]                     base::local({
[17:38:07.211]                       for (pkg in "future.apply") {
[17:38:07.211]                         base::loadNamespace(pkg)
[17:38:07.211]                         base::library(pkg, character.only = TRUE)
[17:38:07.211]                       }
[17:38:07.211]                     })
[17:38:07.211]                   }
[17:38:07.211]                   ...future.strategy.old <- future::plan("list")
[17:38:07.211]                   options(future.plan = NULL)
[17:38:07.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.211]                 }
[17:38:07.211]                 ...future.workdir <- getwd()
[17:38:07.211]             }
[17:38:07.211]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.211]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.211]         }
[17:38:07.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.211]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:07.211]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.211]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.211]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.211]             base::names(...future.oldOptions))
[17:38:07.211]     }
[17:38:07.211]     if (FALSE) {
[17:38:07.211]     }
[17:38:07.211]     else {
[17:38:07.211]         if (TRUE) {
[17:38:07.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.211]                 open = "w")
[17:38:07.211]         }
[17:38:07.211]         else {
[17:38:07.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.211]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.211]         }
[17:38:07.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.211]             base::sink(type = "output", split = FALSE)
[17:38:07.211]             base::close(...future.stdout)
[17:38:07.211]         }, add = TRUE)
[17:38:07.211]     }
[17:38:07.211]     ...future.frame <- base::sys.nframe()
[17:38:07.211]     ...future.conditions <- base::list()
[17:38:07.211]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.211]     if (FALSE) {
[17:38:07.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.211]     }
[17:38:07.211]     ...future.result <- base::tryCatch({
[17:38:07.211]         base::withCallingHandlers({
[17:38:07.211]             ...future.value <- base::withVisible(base::local({
[17:38:07.211]                 do.call(function(...) {
[17:38:07.211]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.211]                   if (!identical(...future.globals.maxSize.org, 
[17:38:07.211]                     ...future.globals.maxSize)) {
[17:38:07.211]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.211]                     on.exit(options(oopts), add = TRUE)
[17:38:07.211]                   }
[17:38:07.211]                   {
[17:38:07.211]                     lapply(seq_along(...future.elements_ii), 
[17:38:07.211]                       FUN = function(jj) {
[17:38:07.211]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.211]                         ...future.FUN(...future.X_jj, ...)
[17:38:07.211]                       })
[17:38:07.211]                   }
[17:38:07.211]                 }, args = future.call.arguments)
[17:38:07.211]             }))
[17:38:07.211]             future::FutureResult(value = ...future.value$value, 
[17:38:07.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.211]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.211]                     ...future.globalenv.names))
[17:38:07.211]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.211]         }, condition = base::local({
[17:38:07.211]             c <- base::c
[17:38:07.211]             inherits <- base::inherits
[17:38:07.211]             invokeRestart <- base::invokeRestart
[17:38:07.211]             length <- base::length
[17:38:07.211]             list <- base::list
[17:38:07.211]             seq.int <- base::seq.int
[17:38:07.211]             signalCondition <- base::signalCondition
[17:38:07.211]             sys.calls <- base::sys.calls
[17:38:07.211]             `[[` <- base::`[[`
[17:38:07.211]             `+` <- base::`+`
[17:38:07.211]             `<<-` <- base::`<<-`
[17:38:07.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.211]                   3L)]
[17:38:07.211]             }
[17:38:07.211]             function(cond) {
[17:38:07.211]                 is_error <- inherits(cond, "error")
[17:38:07.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.211]                   NULL)
[17:38:07.211]                 if (is_error) {
[17:38:07.211]                   sessionInformation <- function() {
[17:38:07.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.211]                       search = base::search(), system = base::Sys.info())
[17:38:07.211]                   }
[17:38:07.211]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.211]                     cond$call), session = sessionInformation(), 
[17:38:07.211]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.211]                   signalCondition(cond)
[17:38:07.211]                 }
[17:38:07.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.211]                 "immediateCondition"))) {
[17:38:07.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.211]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.211]                   if (TRUE && !signal) {
[17:38:07.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.211]                     {
[17:38:07.211]                       inherits <- base::inherits
[17:38:07.211]                       invokeRestart <- base::invokeRestart
[17:38:07.211]                       is.null <- base::is.null
[17:38:07.211]                       muffled <- FALSE
[17:38:07.211]                       if (inherits(cond, "message")) {
[17:38:07.211]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.211]                         if (muffled) 
[17:38:07.211]                           invokeRestart("muffleMessage")
[17:38:07.211]                       }
[17:38:07.211]                       else if (inherits(cond, "warning")) {
[17:38:07.211]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.211]                         if (muffled) 
[17:38:07.211]                           invokeRestart("muffleWarning")
[17:38:07.211]                       }
[17:38:07.211]                       else if (inherits(cond, "condition")) {
[17:38:07.211]                         if (!is.null(pattern)) {
[17:38:07.211]                           computeRestarts <- base::computeRestarts
[17:38:07.211]                           grepl <- base::grepl
[17:38:07.211]                           restarts <- computeRestarts(cond)
[17:38:07.211]                           for (restart in restarts) {
[17:38:07.211]                             name <- restart$name
[17:38:07.211]                             if (is.null(name)) 
[17:38:07.211]                               next
[17:38:07.211]                             if (!grepl(pattern, name)) 
[17:38:07.211]                               next
[17:38:07.211]                             invokeRestart(restart)
[17:38:07.211]                             muffled <- TRUE
[17:38:07.211]                             break
[17:38:07.211]                           }
[17:38:07.211]                         }
[17:38:07.211]                       }
[17:38:07.211]                       invisible(muffled)
[17:38:07.211]                     }
[17:38:07.211]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.211]                   }
[17:38:07.211]                 }
[17:38:07.211]                 else {
[17:38:07.211]                   if (TRUE) {
[17:38:07.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.211]                     {
[17:38:07.211]                       inherits <- base::inherits
[17:38:07.211]                       invokeRestart <- base::invokeRestart
[17:38:07.211]                       is.null <- base::is.null
[17:38:07.211]                       muffled <- FALSE
[17:38:07.211]                       if (inherits(cond, "message")) {
[17:38:07.211]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.211]                         if (muffled) 
[17:38:07.211]                           invokeRestart("muffleMessage")
[17:38:07.211]                       }
[17:38:07.211]                       else if (inherits(cond, "warning")) {
[17:38:07.211]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.211]                         if (muffled) 
[17:38:07.211]                           invokeRestart("muffleWarning")
[17:38:07.211]                       }
[17:38:07.211]                       else if (inherits(cond, "condition")) {
[17:38:07.211]                         if (!is.null(pattern)) {
[17:38:07.211]                           computeRestarts <- base::computeRestarts
[17:38:07.211]                           grepl <- base::grepl
[17:38:07.211]                           restarts <- computeRestarts(cond)
[17:38:07.211]                           for (restart in restarts) {
[17:38:07.211]                             name <- restart$name
[17:38:07.211]                             if (is.null(name)) 
[17:38:07.211]                               next
[17:38:07.211]                             if (!grepl(pattern, name)) 
[17:38:07.211]                               next
[17:38:07.211]                             invokeRestart(restart)
[17:38:07.211]                             muffled <- TRUE
[17:38:07.211]                             break
[17:38:07.211]                           }
[17:38:07.211]                         }
[17:38:07.211]                       }
[17:38:07.211]                       invisible(muffled)
[17:38:07.211]                     }
[17:38:07.211]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.211]                   }
[17:38:07.211]                 }
[17:38:07.211]             }
[17:38:07.211]         }))
[17:38:07.211]     }, error = function(ex) {
[17:38:07.211]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.211]                 ...future.rng), started = ...future.startTime, 
[17:38:07.211]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.211]             version = "1.8"), class = "FutureResult")
[17:38:07.211]     }, finally = {
[17:38:07.211]         if (!identical(...future.workdir, getwd())) 
[17:38:07.211]             setwd(...future.workdir)
[17:38:07.211]         {
[17:38:07.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.211]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.211]             }
[17:38:07.211]             base::options(...future.oldOptions)
[17:38:07.211]             if (.Platform$OS.type == "windows") {
[17:38:07.211]                 old_names <- names(...future.oldEnvVars)
[17:38:07.211]                 envs <- base::Sys.getenv()
[17:38:07.211]                 names <- names(envs)
[17:38:07.211]                 common <- intersect(names, old_names)
[17:38:07.211]                 added <- setdiff(names, old_names)
[17:38:07.211]                 removed <- setdiff(old_names, names)
[17:38:07.211]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.211]                   envs[common]]
[17:38:07.211]                 NAMES <- toupper(changed)
[17:38:07.211]                 args <- list()
[17:38:07.211]                 for (kk in seq_along(NAMES)) {
[17:38:07.211]                   name <- changed[[kk]]
[17:38:07.211]                   NAME <- NAMES[[kk]]
[17:38:07.211]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.211]                     next
[17:38:07.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.211]                 }
[17:38:07.211]                 NAMES <- toupper(added)
[17:38:07.211]                 for (kk in seq_along(NAMES)) {
[17:38:07.211]                   name <- added[[kk]]
[17:38:07.211]                   NAME <- NAMES[[kk]]
[17:38:07.211]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.211]                     next
[17:38:07.211]                   args[[name]] <- ""
[17:38:07.211]                 }
[17:38:07.211]                 NAMES <- toupper(removed)
[17:38:07.211]                 for (kk in seq_along(NAMES)) {
[17:38:07.211]                   name <- removed[[kk]]
[17:38:07.211]                   NAME <- NAMES[[kk]]
[17:38:07.211]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.211]                     next
[17:38:07.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.211]                 }
[17:38:07.211]                 if (length(args) > 0) 
[17:38:07.211]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.211]             }
[17:38:07.211]             else {
[17:38:07.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.211]             }
[17:38:07.211]             {
[17:38:07.211]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.211]                   0L) {
[17:38:07.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.211]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.211]                   base::options(opts)
[17:38:07.211]                 }
[17:38:07.211]                 {
[17:38:07.211]                   {
[17:38:07.211]                     NULL
[17:38:07.211]                     RNGkind("Mersenne-Twister")
[17:38:07.211]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:07.211]                       inherits = FALSE)
[17:38:07.211]                   }
[17:38:07.211]                   options(future.plan = NULL)
[17:38:07.211]                   if (is.na(NA_character_)) 
[17:38:07.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.211]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.211]                     .init = FALSE)
[17:38:07.211]                 }
[17:38:07.211]             }
[17:38:07.211]         }
[17:38:07.211]     })
[17:38:07.211]     if (TRUE) {
[17:38:07.211]         base::sink(type = "output", split = FALSE)
[17:38:07.211]         if (TRUE) {
[17:38:07.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.211]         }
[17:38:07.211]         else {
[17:38:07.211]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.211]         }
[17:38:07.211]         base::close(...future.stdout)
[17:38:07.211]         ...future.stdout <- NULL
[17:38:07.211]     }
[17:38:07.211]     ...future.result$conditions <- ...future.conditions
[17:38:07.211]     ...future.result$finished <- base::Sys.time()
[17:38:07.211]     ...future.result
[17:38:07.211] }
[17:38:07.213] assign_globals() ...
[17:38:07.213] List of 11
[17:38:07.213]  $ ...future.FUN            :function (x, ...)  
[17:38:07.213]  $ x_FUN                    :function (x)  
[17:38:07.213]  $ times                    : int 1
[17:38:07.213]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.213]  $ stop_if_not              :function (...)  
[17:38:07.213]  $ dim                      : NULL
[17:38:07.213]  $ valid_types              : chr "logical"
[17:38:07.213]  $ future.call.arguments    : list()
[17:38:07.213]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.213]  $ ...future.elements_ii    :List of 11
[17:38:07.213]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[17:38:07.213]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[17:38:07.213]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[17:38:07.213]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[17:38:07.213]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[17:38:07.213]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[17:38:07.213]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[17:38:07.213]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[17:38:07.213]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[17:38:07.213]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[17:38:07.213]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[17:38:07.213]  $ ...future.seeds_ii       : NULL
[17:38:07.213]  $ ...future.globals.maxSize: NULL
[17:38:07.213]  - attr(*, "where")=List of 11
[17:38:07.213]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.213]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.213]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.213]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.213]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.213]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.213]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.213]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.213]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.213]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.213]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.213]  - attr(*, "resolved")= logi FALSE
[17:38:07.213]  - attr(*, "total_size")= num 94200
[17:38:07.213]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.213]  - attr(*, "already-done")= logi TRUE
[17:38:07.223] - copied ‘...future.FUN’ to environment
[17:38:07.223] - copied ‘x_FUN’ to environment
[17:38:07.223] - copied ‘times’ to environment
[17:38:07.224] - copied ‘stopf’ to environment
[17:38:07.224] - copied ‘stop_if_not’ to environment
[17:38:07.224] - copied ‘dim’ to environment
[17:38:07.224] - copied ‘valid_types’ to environment
[17:38:07.224] - copied ‘future.call.arguments’ to environment
[17:38:07.224] - copied ‘...future.elements_ii’ to environment
[17:38:07.224] - copied ‘...future.seeds_ii’ to environment
[17:38:07.224] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.224] assign_globals() ... done
[17:38:07.225] plan(): Setting new future strategy stack:
[17:38:07.225] List of future strategies:
[17:38:07.225] 1. sequential:
[17:38:07.225]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.225]    - tweaked: FALSE
[17:38:07.225]    - call: NULL
[17:38:07.225] plan(): nbrOfWorkers() = 1
[17:38:07.226] plan(): Setting new future strategy stack:
[17:38:07.226] List of future strategies:
[17:38:07.226] 1. sequential:
[17:38:07.226]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.226]    - tweaked: FALSE
[17:38:07.226]    - call: plan(strategy)
[17:38:07.227] plan(): nbrOfWorkers() = 1
[17:38:07.227] SequentialFuture started (and completed)
[17:38:07.227] - Launch lazy future ... done
[17:38:07.227] run() for ‘SequentialFuture’ ... done
[17:38:07.227] Created future:
[17:38:07.227] SequentialFuture:
[17:38:07.227] Label: ‘future_vapply-1’
[17:38:07.227] Expression:
[17:38:07.227] {
[17:38:07.227]     do.call(function(...) {
[17:38:07.227]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.227]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.227]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.227]             on.exit(options(oopts), add = TRUE)
[17:38:07.227]         }
[17:38:07.227]         {
[17:38:07.227]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.227]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.227]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.227]             })
[17:38:07.227]         }
[17:38:07.227]     }, args = future.call.arguments)
[17:38:07.227] }
[17:38:07.227] Lazy evaluation: FALSE
[17:38:07.227] Asynchronous evaluation: FALSE
[17:38:07.227] Local evaluation: TRUE
[17:38:07.227] Environment: R_GlobalEnv
[17:38:07.227] Capture standard output: TRUE
[17:38:07.227] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.227] Globals: 11 objects totaling 95.26 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.227] Packages: 1 packages (‘future.apply’)
[17:38:07.227] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.227] Resolved: TRUE
[17:38:07.227] Value: 616 bytes of class ‘list’
[17:38:07.227] Early signaling: FALSE
[17:38:07.227] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.227] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:07.230] Chunk #1 of 1 ... DONE
[17:38:07.230] Launching 1 futures (chunks) ... DONE
[17:38:07.230] Resolving 1 futures (chunks) ...
[17:38:07.230] resolve() on list ...
[17:38:07.231]  recursive: 0
[17:38:07.231]  length: 1
[17:38:07.231] 
[17:38:07.231] resolved() for ‘SequentialFuture’ ...
[17:38:07.231] - state: ‘finished’
[17:38:07.231] - run: TRUE
[17:38:07.231] - result: ‘FutureResult’
[17:38:07.231] resolved() for ‘SequentialFuture’ ... done
[17:38:07.231] Future #1
[17:38:07.232] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:07.232] - nx: 1
[17:38:07.232] - relay: TRUE
[17:38:07.232] - stdout: TRUE
[17:38:07.232] - signal: TRUE
[17:38:07.232] - resignal: FALSE
[17:38:07.232] - force: TRUE
[17:38:07.232] - relayed: [n=1] FALSE
[17:38:07.232] - queued futures: [n=1] FALSE
[17:38:07.232]  - until=1
[17:38:07.233]  - relaying element #1
[17:38:07.233] - relayed: [n=1] TRUE
[17:38:07.233] - queued futures: [n=1] TRUE
[17:38:07.233] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:07.233]  length: 0 (resolved future 1)
[17:38:07.233] Relaying remaining futures
[17:38:07.233] signalConditionsASAP(NULL, pos=0) ...
[17:38:07.233] - nx: 1
[17:38:07.233] - relay: TRUE
[17:38:07.233] - stdout: TRUE
[17:38:07.234] - signal: TRUE
[17:38:07.234] - resignal: FALSE
[17:38:07.234] - force: TRUE
[17:38:07.234] - relayed: [n=1] TRUE
[17:38:07.234] - queued futures: [n=1] TRUE
 - flush all
[17:38:07.234] - relayed: [n=1] TRUE
[17:38:07.234] - queued futures: [n=1] TRUE
[17:38:07.234] signalConditionsASAP(NULL, pos=0) ... done
[17:38:07.234] resolve() on list ... DONE
[17:38:07.234]  - Number of value chunks collected: 1
[17:38:07.234] Resolving 1 futures (chunks) ... DONE
[17:38:07.235] Reducing values from 1 chunks ...
[17:38:07.235]  - Number of values collected after concatenation: 11
[17:38:07.235]  - Number of values expected: 11
[17:38:07.235] Reducing values from 1 chunks ... DONE
[17:38:07.235] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[17:38:07.236] future_lapply() ...
[17:38:07.237] Number of chunks: 1
[17:38:07.238] getGlobalsAndPackagesXApply() ...
[17:38:07.238]  - future.globals: TRUE
[17:38:07.238] getGlobalsAndPackages() ...
[17:38:07.238] Searching for globals...
[17:38:07.241] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:07.241] Searching for globals ... DONE
[17:38:07.241] Resolving globals: FALSE
[17:38:07.242] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[17:38:07.242] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:07.242] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.242] - packages: [1] ‘future.apply’
[17:38:07.242] getGlobalsAndPackages() ... DONE
[17:38:07.243]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.243]  - needed namespaces: [n=1] ‘future.apply’
[17:38:07.243] Finding globals ... DONE
[17:38:07.243]  - use_args: TRUE
[17:38:07.243]  - Getting '...' globals ...
[17:38:07.243] resolve() on list ...
[17:38:07.243]  recursive: 0
[17:38:07.243]  length: 1
[17:38:07.243]  elements: ‘...’
[17:38:07.244]  length: 0 (resolved future 1)
[17:38:07.244] resolve() on list ... DONE
[17:38:07.244]    - '...' content: [n=0] 
[17:38:07.244] List of 1
[17:38:07.244]  $ ...: list()
[17:38:07.244]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.244]  - attr(*, "where")=List of 1
[17:38:07.244]   ..$ ...:<environment: 0x5607ff463568> 
[17:38:07.244]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.244]  - attr(*, "resolved")= logi TRUE
[17:38:07.244]  - attr(*, "total_size")= num NA
[17:38:07.246]  - Getting '...' globals ... DONE
[17:38:07.246] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:07.247] List of 8
[17:38:07.247]  $ ...future.FUN:function (x, ...)  
[17:38:07.247]  $ x_FUN        :function (x)  
[17:38:07.247]  $ times        : int 1
[17:38:07.247]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.247]  $ stop_if_not  :function (...)  
[17:38:07.247]  $ dim          : NULL
[17:38:07.247]  $ valid_types  : chr [1:2] "logical" "integer"
[17:38:07.247]  $ ...          : list()
[17:38:07.247]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.247]  - attr(*, "where")=List of 8
[17:38:07.247]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:07.247]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:07.247]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:07.247]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:07.247]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:07.247]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:07.247]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:07.247]   ..$ ...          :<environment: 0x5607ff463568> 
[17:38:07.247]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.247]  - attr(*, "resolved")= logi FALSE
[17:38:07.247]  - attr(*, "total_size")= num 94264
[17:38:07.254] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:07.254] getGlobalsAndPackagesXApply() ... DONE
[17:38:07.254] Number of futures (= number of chunks): 1
[17:38:07.254] Launching 1 futures (chunks) ...
[17:38:07.254] Chunk #1 of 1 ...
[17:38:07.254]  - Finding globals in 'X' for chunk #1 ...
[17:38:07.255] getGlobalsAndPackages() ...
[17:38:07.255] Searching for globals...
[17:38:07.255] 
[17:38:07.255] Searching for globals ... DONE
[17:38:07.255] - globals: [0] <none>
[17:38:07.255] getGlobalsAndPackages() ... DONE
[17:38:07.255]    + additional globals found: [n=0] 
[17:38:07.255]    + additional namespaces needed: [n=0] 
[17:38:07.255]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:07.256]  - seeds: <none>
[17:38:07.256]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.256] getGlobalsAndPackages() ...
[17:38:07.256] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.256] Resolving globals: FALSE
[17:38:07.256] Tweak future expression to call with '...' arguments ...
[17:38:07.256] {
[17:38:07.256]     do.call(function(...) {
[17:38:07.256]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.256]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.256]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.256]             on.exit(options(oopts), add = TRUE)
[17:38:07.256]         }
[17:38:07.256]         {
[17:38:07.256]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.256]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.256]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.256]             })
[17:38:07.256]         }
[17:38:07.256]     }, args = future.call.arguments)
[17:38:07.256] }
[17:38:07.256] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.257] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.257] - packages: [1] ‘future.apply’
[17:38:07.257] getGlobalsAndPackages() ... DONE
[17:38:07.257] run() for ‘Future’ ...
[17:38:07.258] - state: ‘created’
[17:38:07.258] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:07.258] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:07.258] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:07.258]   - Field: ‘label’
[17:38:07.258]   - Field: ‘local’
[17:38:07.258]   - Field: ‘owner’
[17:38:07.259]   - Field: ‘envir’
[17:38:07.259]   - Field: ‘packages’
[17:38:07.259]   - Field: ‘gc’
[17:38:07.259]   - Field: ‘conditions’
[17:38:07.259]   - Field: ‘expr’
[17:38:07.259]   - Field: ‘uuid’
[17:38:07.259]   - Field: ‘seed’
[17:38:07.259]   - Field: ‘version’
[17:38:07.259]   - Field: ‘result’
[17:38:07.259]   - Field: ‘asynchronous’
[17:38:07.259]   - Field: ‘calls’
[17:38:07.260]   - Field: ‘globals’
[17:38:07.260]   - Field: ‘stdout’
[17:38:07.260]   - Field: ‘earlySignal’
[17:38:07.260]   - Field: ‘lazy’
[17:38:07.260]   - Field: ‘state’
[17:38:07.260] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:07.260] - Launch lazy future ...
[17:38:07.260] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:07.260] Packages needed by future strategies (n = 0): <none>
[17:38:07.261] {
[17:38:07.261]     {
[17:38:07.261]         {
[17:38:07.261]             ...future.startTime <- base::Sys.time()
[17:38:07.261]             {
[17:38:07.261]                 {
[17:38:07.261]                   {
[17:38:07.261]                     {
[17:38:07.261]                       base::local({
[17:38:07.261]                         has_future <- base::requireNamespace("future", 
[17:38:07.261]                           quietly = TRUE)
[17:38:07.261]                         if (has_future) {
[17:38:07.261]                           ns <- base::getNamespace("future")
[17:38:07.261]                           version <- ns[[".package"]][["version"]]
[17:38:07.261]                           if (is.null(version)) 
[17:38:07.261]                             version <- utils::packageVersion("future")
[17:38:07.261]                         }
[17:38:07.261]                         else {
[17:38:07.261]                           version <- NULL
[17:38:07.261]                         }
[17:38:07.261]                         if (!has_future || version < "1.8.0") {
[17:38:07.261]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.261]                             "", base::R.version$version.string), 
[17:38:07.261]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:07.261]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:07.261]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.261]                               "release", "version")], collapse = " "), 
[17:38:07.261]                             hostname = base::Sys.info()[["nodename"]])
[17:38:07.261]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.261]                             info)
[17:38:07.261]                           info <- base::paste(info, collapse = "; ")
[17:38:07.261]                           if (!has_future) {
[17:38:07.261]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.261]                               info)
[17:38:07.261]                           }
[17:38:07.261]                           else {
[17:38:07.261]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.261]                               info, version)
[17:38:07.261]                           }
[17:38:07.261]                           base::stop(msg)
[17:38:07.261]                         }
[17:38:07.261]                       })
[17:38:07.261]                     }
[17:38:07.261]                     base::local({
[17:38:07.261]                       for (pkg in "future.apply") {
[17:38:07.261]                         base::loadNamespace(pkg)
[17:38:07.261]                         base::library(pkg, character.only = TRUE)
[17:38:07.261]                       }
[17:38:07.261]                     })
[17:38:07.261]                   }
[17:38:07.261]                   ...future.strategy.old <- future::plan("list")
[17:38:07.261]                   options(future.plan = NULL)
[17:38:07.261]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.261]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.261]                 }
[17:38:07.261]                 ...future.workdir <- getwd()
[17:38:07.261]             }
[17:38:07.261]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.261]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.261]         }
[17:38:07.261]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.261]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:07.261]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.261]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.261]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.261]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.261]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.261]             base::names(...future.oldOptions))
[17:38:07.261]     }
[17:38:07.261]     if (FALSE) {
[17:38:07.261]     }
[17:38:07.261]     else {
[17:38:07.261]         if (TRUE) {
[17:38:07.261]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.261]                 open = "w")
[17:38:07.261]         }
[17:38:07.261]         else {
[17:38:07.261]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.261]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.261]         }
[17:38:07.261]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.261]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.261]             base::sink(type = "output", split = FALSE)
[17:38:07.261]             base::close(...future.stdout)
[17:38:07.261]         }, add = TRUE)
[17:38:07.261]     }
[17:38:07.261]     ...future.frame <- base::sys.nframe()
[17:38:07.261]     ...future.conditions <- base::list()
[17:38:07.261]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.261]     if (FALSE) {
[17:38:07.261]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.261]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.261]     }
[17:38:07.261]     ...future.result <- base::tryCatch({
[17:38:07.261]         base::withCallingHandlers({
[17:38:07.261]             ...future.value <- base::withVisible(base::local({
[17:38:07.261]                 do.call(function(...) {
[17:38:07.261]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.261]                   if (!identical(...future.globals.maxSize.org, 
[17:38:07.261]                     ...future.globals.maxSize)) {
[17:38:07.261]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.261]                     on.exit(options(oopts), add = TRUE)
[17:38:07.261]                   }
[17:38:07.261]                   {
[17:38:07.261]                     lapply(seq_along(...future.elements_ii), 
[17:38:07.261]                       FUN = function(jj) {
[17:38:07.261]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.261]                         ...future.FUN(...future.X_jj, ...)
[17:38:07.261]                       })
[17:38:07.261]                   }
[17:38:07.261]                 }, args = future.call.arguments)
[17:38:07.261]             }))
[17:38:07.261]             future::FutureResult(value = ...future.value$value, 
[17:38:07.261]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.261]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.261]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.261]                     ...future.globalenv.names))
[17:38:07.261]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.261]         }, condition = base::local({
[17:38:07.261]             c <- base::c
[17:38:07.261]             inherits <- base::inherits
[17:38:07.261]             invokeRestart <- base::invokeRestart
[17:38:07.261]             length <- base::length
[17:38:07.261]             list <- base::list
[17:38:07.261]             seq.int <- base::seq.int
[17:38:07.261]             signalCondition <- base::signalCondition
[17:38:07.261]             sys.calls <- base::sys.calls
[17:38:07.261]             `[[` <- base::`[[`
[17:38:07.261]             `+` <- base::`+`
[17:38:07.261]             `<<-` <- base::`<<-`
[17:38:07.261]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.261]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.261]                   3L)]
[17:38:07.261]             }
[17:38:07.261]             function(cond) {
[17:38:07.261]                 is_error <- inherits(cond, "error")
[17:38:07.261]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.261]                   NULL)
[17:38:07.261]                 if (is_error) {
[17:38:07.261]                   sessionInformation <- function() {
[17:38:07.261]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.261]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.261]                       search = base::search(), system = base::Sys.info())
[17:38:07.261]                   }
[17:38:07.261]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.261]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.261]                     cond$call), session = sessionInformation(), 
[17:38:07.261]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.261]                   signalCondition(cond)
[17:38:07.261]                 }
[17:38:07.261]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.261]                 "immediateCondition"))) {
[17:38:07.261]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.261]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.261]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.261]                   if (TRUE && !signal) {
[17:38:07.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.261]                     {
[17:38:07.261]                       inherits <- base::inherits
[17:38:07.261]                       invokeRestart <- base::invokeRestart
[17:38:07.261]                       is.null <- base::is.null
[17:38:07.261]                       muffled <- FALSE
[17:38:07.261]                       if (inherits(cond, "message")) {
[17:38:07.261]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.261]                         if (muffled) 
[17:38:07.261]                           invokeRestart("muffleMessage")
[17:38:07.261]                       }
[17:38:07.261]                       else if (inherits(cond, "warning")) {
[17:38:07.261]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.261]                         if (muffled) 
[17:38:07.261]                           invokeRestart("muffleWarning")
[17:38:07.261]                       }
[17:38:07.261]                       else if (inherits(cond, "condition")) {
[17:38:07.261]                         if (!is.null(pattern)) {
[17:38:07.261]                           computeRestarts <- base::computeRestarts
[17:38:07.261]                           grepl <- base::grepl
[17:38:07.261]                           restarts <- computeRestarts(cond)
[17:38:07.261]                           for (restart in restarts) {
[17:38:07.261]                             name <- restart$name
[17:38:07.261]                             if (is.null(name)) 
[17:38:07.261]                               next
[17:38:07.261]                             if (!grepl(pattern, name)) 
[17:38:07.261]                               next
[17:38:07.261]                             invokeRestart(restart)
[17:38:07.261]                             muffled <- TRUE
[17:38:07.261]                             break
[17:38:07.261]                           }
[17:38:07.261]                         }
[17:38:07.261]                       }
[17:38:07.261]                       invisible(muffled)
[17:38:07.261]                     }
[17:38:07.261]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.261]                   }
[17:38:07.261]                 }
[17:38:07.261]                 else {
[17:38:07.261]                   if (TRUE) {
[17:38:07.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.261]                     {
[17:38:07.261]                       inherits <- base::inherits
[17:38:07.261]                       invokeRestart <- base::invokeRestart
[17:38:07.261]                       is.null <- base::is.null
[17:38:07.261]                       muffled <- FALSE
[17:38:07.261]                       if (inherits(cond, "message")) {
[17:38:07.261]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.261]                         if (muffled) 
[17:38:07.261]                           invokeRestart("muffleMessage")
[17:38:07.261]                       }
[17:38:07.261]                       else if (inherits(cond, "warning")) {
[17:38:07.261]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.261]                         if (muffled) 
[17:38:07.261]                           invokeRestart("muffleWarning")
[17:38:07.261]                       }
[17:38:07.261]                       else if (inherits(cond, "condition")) {
[17:38:07.261]                         if (!is.null(pattern)) {
[17:38:07.261]                           computeRestarts <- base::computeRestarts
[17:38:07.261]                           grepl <- base::grepl
[17:38:07.261]                           restarts <- computeRestarts(cond)
[17:38:07.261]                           for (restart in restarts) {
[17:38:07.261]                             name <- restart$name
[17:38:07.261]                             if (is.null(name)) 
[17:38:07.261]                               next
[17:38:07.261]                             if (!grepl(pattern, name)) 
[17:38:07.261]                               next
[17:38:07.261]                             invokeRestart(restart)
[17:38:07.261]                             muffled <- TRUE
[17:38:07.261]                             break
[17:38:07.261]                           }
[17:38:07.261]                         }
[17:38:07.261]                       }
[17:38:07.261]                       invisible(muffled)
[17:38:07.261]                     }
[17:38:07.261]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.261]                   }
[17:38:07.261]                 }
[17:38:07.261]             }
[17:38:07.261]         }))
[17:38:07.261]     }, error = function(ex) {
[17:38:07.261]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.261]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.261]                 ...future.rng), started = ...future.startTime, 
[17:38:07.261]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.261]             version = "1.8"), class = "FutureResult")
[17:38:07.261]     }, finally = {
[17:38:07.261]         if (!identical(...future.workdir, getwd())) 
[17:38:07.261]             setwd(...future.workdir)
[17:38:07.261]         {
[17:38:07.261]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.261]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.261]             }
[17:38:07.261]             base::options(...future.oldOptions)
[17:38:07.261]             if (.Platform$OS.type == "windows") {
[17:38:07.261]                 old_names <- names(...future.oldEnvVars)
[17:38:07.261]                 envs <- base::Sys.getenv()
[17:38:07.261]                 names <- names(envs)
[17:38:07.261]                 common <- intersect(names, old_names)
[17:38:07.261]                 added <- setdiff(names, old_names)
[17:38:07.261]                 removed <- setdiff(old_names, names)
[17:38:07.261]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.261]                   envs[common]]
[17:38:07.261]                 NAMES <- toupper(changed)
[17:38:07.261]                 args <- list()
[17:38:07.261]                 for (kk in seq_along(NAMES)) {
[17:38:07.261]                   name <- changed[[kk]]
[17:38:07.261]                   NAME <- NAMES[[kk]]
[17:38:07.261]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.261]                     next
[17:38:07.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.261]                 }
[17:38:07.261]                 NAMES <- toupper(added)
[17:38:07.261]                 for (kk in seq_along(NAMES)) {
[17:38:07.261]                   name <- added[[kk]]
[17:38:07.261]                   NAME <- NAMES[[kk]]
[17:38:07.261]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.261]                     next
[17:38:07.261]                   args[[name]] <- ""
[17:38:07.261]                 }
[17:38:07.261]                 NAMES <- toupper(removed)
[17:38:07.261]                 for (kk in seq_along(NAMES)) {
[17:38:07.261]                   name <- removed[[kk]]
[17:38:07.261]                   NAME <- NAMES[[kk]]
[17:38:07.261]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.261]                     next
[17:38:07.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.261]                 }
[17:38:07.261]                 if (length(args) > 0) 
[17:38:07.261]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.261]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.261]             }
[17:38:07.261]             else {
[17:38:07.261]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.261]             }
[17:38:07.261]             {
[17:38:07.261]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.261]                   0L) {
[17:38:07.261]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.261]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.261]                   base::options(opts)
[17:38:07.261]                 }
[17:38:07.261]                 {
[17:38:07.261]                   {
[17:38:07.261]                     NULL
[17:38:07.261]                     RNGkind("Mersenne-Twister")
[17:38:07.261]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:07.261]                       inherits = FALSE)
[17:38:07.261]                   }
[17:38:07.261]                   options(future.plan = NULL)
[17:38:07.261]                   if (is.na(NA_character_)) 
[17:38:07.261]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.261]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.261]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.261]                     .init = FALSE)
[17:38:07.261]                 }
[17:38:07.261]             }
[17:38:07.261]         }
[17:38:07.261]     })
[17:38:07.261]     if (TRUE) {
[17:38:07.261]         base::sink(type = "output", split = FALSE)
[17:38:07.261]         if (TRUE) {
[17:38:07.261]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.261]         }
[17:38:07.261]         else {
[17:38:07.261]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.261]         }
[17:38:07.261]         base::close(...future.stdout)
[17:38:07.261]         ...future.stdout <- NULL
[17:38:07.261]     }
[17:38:07.261]     ...future.result$conditions <- ...future.conditions
[17:38:07.261]     ...future.result$finished <- base::Sys.time()
[17:38:07.261]     ...future.result
[17:38:07.261] }
[17:38:07.263] assign_globals() ...
[17:38:07.263] List of 11
[17:38:07.263]  $ ...future.FUN            :function (x, ...)  
[17:38:07.263]  $ x_FUN                    :function (x)  
[17:38:07.263]  $ times                    : int 1
[17:38:07.263]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.263]  $ stop_if_not              :function (...)  
[17:38:07.263]  $ dim                      : NULL
[17:38:07.263]  $ valid_types              : chr [1:2] "logical" "integer"
[17:38:07.263]  $ future.call.arguments    : list()
[17:38:07.263]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.263]  $ ...future.elements_ii    :List of 3
[17:38:07.263]   ..$ a: num 1
[17:38:07.263]   ..$ b: num 2
[17:38:07.263]   ..$ c: num 3
[17:38:07.263]  $ ...future.seeds_ii       : NULL
[17:38:07.263]  $ ...future.globals.maxSize: NULL
[17:38:07.263]  - attr(*, "where")=List of 11
[17:38:07.263]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.263]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.263]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.263]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.263]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.263]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.263]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.263]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.263]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.263]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.263]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.263]  - attr(*, "resolved")= logi FALSE
[17:38:07.263]  - attr(*, "total_size")= num 94264
[17:38:07.263]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.263]  - attr(*, "already-done")= logi TRUE
[17:38:07.270] - copied ‘...future.FUN’ to environment
[17:38:07.270] - copied ‘x_FUN’ to environment
[17:38:07.271] - copied ‘times’ to environment
[17:38:07.271] - copied ‘stopf’ to environment
[17:38:07.271] - copied ‘stop_if_not’ to environment
[17:38:07.271] - copied ‘dim’ to environment
[17:38:07.271] - copied ‘valid_types’ to environment
[17:38:07.271] - copied ‘future.call.arguments’ to environment
[17:38:07.271] - copied ‘...future.elements_ii’ to environment
[17:38:07.271] - copied ‘...future.seeds_ii’ to environment
[17:38:07.271] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.271] assign_globals() ... done
[17:38:07.272] plan(): Setting new future strategy stack:
[17:38:07.272] List of future strategies:
[17:38:07.272] 1. sequential:
[17:38:07.272]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.272]    - tweaked: FALSE
[17:38:07.272]    - call: NULL
[17:38:07.272] plan(): nbrOfWorkers() = 1
[17:38:07.273] plan(): Setting new future strategy stack:
[17:38:07.273] List of future strategies:
[17:38:07.273] 1. sequential:
[17:38:07.273]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.273]    - tweaked: FALSE
[17:38:07.273]    - call: plan(strategy)
[17:38:07.274] plan(): nbrOfWorkers() = 1
[17:38:07.274] SequentialFuture started (and completed)
[17:38:07.274] - Launch lazy future ... done
[17:38:07.274] run() for ‘SequentialFuture’ ... done
[17:38:07.274] Created future:
[17:38:07.274] SequentialFuture:
[17:38:07.274] Label: ‘future_vapply-1’
[17:38:07.274] Expression:
[17:38:07.274] {
[17:38:07.274]     do.call(function(...) {
[17:38:07.274]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.274]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.274]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.274]             on.exit(options(oopts), add = TRUE)
[17:38:07.274]         }
[17:38:07.274]         {
[17:38:07.274]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.274]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.274]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.274]             })
[17:38:07.274]         }
[17:38:07.274]     }, args = future.call.arguments)
[17:38:07.274] }
[17:38:07.274] Lazy evaluation: FALSE
[17:38:07.274] Asynchronous evaluation: FALSE
[17:38:07.274] Local evaluation: TRUE
[17:38:07.274] Environment: R_GlobalEnv
[17:38:07.274] Capture standard output: TRUE
[17:38:07.274] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.274] Globals: 11 objects totaling 92.22 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.274] Packages: 1 packages (‘future.apply’)
[17:38:07.274] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.274] Resolved: TRUE
[17:38:07.274] Value: 168 bytes of class ‘list’
[17:38:07.274] Early signaling: FALSE
[17:38:07.274] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.274] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:07.277] Chunk #1 of 1 ... DONE
[17:38:07.277] Launching 1 futures (chunks) ... DONE
[17:38:07.277] Resolving 1 futures (chunks) ...
[17:38:07.277] resolve() on list ...
[17:38:07.277]  recursive: 0
[17:38:07.277]  length: 1
[17:38:07.277] 
[17:38:07.278] resolved() for ‘SequentialFuture’ ...
[17:38:07.278] - state: ‘finished’
[17:38:07.278] - run: TRUE
[17:38:07.278] - result: ‘FutureResult’
[17:38:07.278] resolved() for ‘SequentialFuture’ ... done
[17:38:07.278] Future #1
[17:38:07.278] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:07.278] - nx: 1
[17:38:07.279] - relay: TRUE
[17:38:07.279] - stdout: TRUE
[17:38:07.279] - signal: TRUE
[17:38:07.279] - resignal: FALSE
[17:38:07.279] - force: TRUE
[17:38:07.279] - relayed: [n=1] FALSE
[17:38:07.279] - queued futures: [n=1] FALSE
[17:38:07.279]  - until=1
[17:38:07.279]  - relaying element #1
[17:38:07.279] - relayed: [n=1] TRUE
[17:38:07.279] - queued futures: [n=1] TRUE
[17:38:07.280] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:07.280]  length: 0 (resolved future 1)
[17:38:07.280] Relaying remaining futures
[17:38:07.280] signalConditionsASAP(NULL, pos=0) ...
[17:38:07.280] - nx: 1
[17:38:07.280] - relay: TRUE
[17:38:07.280] - stdout: TRUE
[17:38:07.280] - signal: TRUE
[17:38:07.280] - resignal: FALSE
[17:38:07.280] - force: TRUE
[17:38:07.281] - relayed: [n=1] TRUE
[17:38:07.281] - queued futures: [n=1] TRUE
 - flush all
[17:38:07.281] - relayed: [n=1] TRUE
[17:38:07.281] - queued futures: [n=1] TRUE
[17:38:07.281] signalConditionsASAP(NULL, pos=0) ... done
[17:38:07.281] resolve() on list ... DONE
[17:38:07.281]  - Number of value chunks collected: 1
[17:38:07.281] Resolving 1 futures (chunks) ... DONE
[17:38:07.281] Reducing values from 1 chunks ...
[17:38:07.281]  - Number of values collected after concatenation: 3
[17:38:07.282]  - Number of values expected: 3
[17:38:07.282] Reducing values from 1 chunks ... DONE
[17:38:07.282] future_lapply() ... DONE
- exceptions ...
[17:38:07.282] future_lapply() ...
[17:38:07.284] Number of chunks: 1
[17:38:07.284] getGlobalsAndPackagesXApply() ...
[17:38:07.284]  - future.globals: TRUE
[17:38:07.284] getGlobalsAndPackages() ...
[17:38:07.284] Searching for globals...
[17:38:07.287] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:07.287] Searching for globals ... DONE
[17:38:07.288] Resolving globals: FALSE
[17:38:07.288] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[17:38:07.289] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:07.289] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.289] - packages: [1] ‘future.apply’
[17:38:07.289] getGlobalsAndPackages() ... DONE
[17:38:07.289]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.289]  - needed namespaces: [n=1] ‘future.apply’
[17:38:07.289] Finding globals ... DONE
[17:38:07.289]  - use_args: TRUE
[17:38:07.290]  - Getting '...' globals ...
[17:38:07.290] resolve() on list ...
[17:38:07.290]  recursive: 0
[17:38:07.290]  length: 1
[17:38:07.290]  elements: ‘...’
[17:38:07.290]  length: 0 (resolved future 1)
[17:38:07.290] resolve() on list ... DONE
[17:38:07.290]    - '...' content: [n=0] 
[17:38:07.290] List of 1
[17:38:07.290]  $ ...: list()
[17:38:07.290]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.290]  - attr(*, "where")=List of 1
[17:38:07.290]   ..$ ...:<environment: 0x5607ff4c1618> 
[17:38:07.290]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.290]  - attr(*, "resolved")= logi TRUE
[17:38:07.290]  - attr(*, "total_size")= num NA
[17:38:07.293]  - Getting '...' globals ... DONE
[17:38:07.293] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:07.293] List of 8
[17:38:07.293]  $ ...future.FUN:function (x, ...)  
[17:38:07.293]  $ x_FUN        :function (x)  
[17:38:07.293]  $ times        : int 2
[17:38:07.293]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.293]  $ stop_if_not  :function (...)  
[17:38:07.293]  $ dim          : NULL
[17:38:07.293]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:07.293]  $ ...          : list()
[17:38:07.293]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.293]  - attr(*, "where")=List of 8
[17:38:07.293]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:07.293]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:07.293]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:07.293]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:07.293]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:07.293]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:07.293]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:07.293]   ..$ ...          :<environment: 0x5607ff4c1618> 
[17:38:07.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.293]  - attr(*, "resolved")= logi FALSE
[17:38:07.293]  - attr(*, "total_size")= num 95128
[17:38:07.300] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:07.300] getGlobalsAndPackagesXApply() ... DONE
[17:38:07.300] Number of futures (= number of chunks): 1
[17:38:07.300] Launching 1 futures (chunks) ...
[17:38:07.300] Chunk #1 of 1 ...
[17:38:07.300]  - Finding globals in 'X' for chunk #1 ...
[17:38:07.301] getGlobalsAndPackages() ...
[17:38:07.301] Searching for globals...
[17:38:07.301] 
[17:38:07.301] Searching for globals ... DONE
[17:38:07.301] - globals: [0] <none>
[17:38:07.301] getGlobalsAndPackages() ... DONE
[17:38:07.301]    + additional globals found: [n=0] 
[17:38:07.301]    + additional namespaces needed: [n=0] 
[17:38:07.301]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:07.302]  - seeds: <none>
[17:38:07.302]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.302] getGlobalsAndPackages() ...
[17:38:07.302] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.302] Resolving globals: FALSE
[17:38:07.302] Tweak future expression to call with '...' arguments ...
[17:38:07.302] {
[17:38:07.302]     do.call(function(...) {
[17:38:07.302]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.302]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.302]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.302]             on.exit(options(oopts), add = TRUE)
[17:38:07.302]         }
[17:38:07.302]         {
[17:38:07.302]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.302]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.302]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.302]             })
[17:38:07.302]         }
[17:38:07.302]     }, args = future.call.arguments)
[17:38:07.302] }
[17:38:07.302] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.303] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.303] - packages: [1] ‘future.apply’
[17:38:07.303] getGlobalsAndPackages() ... DONE
[17:38:07.303] run() for ‘Future’ ...
[17:38:07.303] - state: ‘created’
[17:38:07.304] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:38:07.304] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:07.304] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:38:07.304]   - Field: ‘label’
[17:38:07.304]   - Field: ‘local’
[17:38:07.304]   - Field: ‘owner’
[17:38:07.304]   - Field: ‘envir’
[17:38:07.305]   - Field: ‘packages’
[17:38:07.305]   - Field: ‘gc’
[17:38:07.305]   - Field: ‘conditions’
[17:38:07.305]   - Field: ‘expr’
[17:38:07.305]   - Field: ‘uuid’
[17:38:07.305]   - Field: ‘seed’
[17:38:07.305]   - Field: ‘version’
[17:38:07.305]   - Field: ‘result’
[17:38:07.305]   - Field: ‘asynchronous’
[17:38:07.305]   - Field: ‘calls’
[17:38:07.305]   - Field: ‘globals’
[17:38:07.305]   - Field: ‘stdout’
[17:38:07.306]   - Field: ‘earlySignal’
[17:38:07.306]   - Field: ‘lazy’
[17:38:07.306]   - Field: ‘state’
[17:38:07.306] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:38:07.306] - Launch lazy future ...
[17:38:07.306] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:07.306] Packages needed by future strategies (n = 0): <none>
[17:38:07.307] {
[17:38:07.307]     {
[17:38:07.307]         {
[17:38:07.307]             ...future.startTime <- base::Sys.time()
[17:38:07.307]             {
[17:38:07.307]                 {
[17:38:07.307]                   {
[17:38:07.307]                     {
[17:38:07.307]                       base::local({
[17:38:07.307]                         has_future <- base::requireNamespace("future", 
[17:38:07.307]                           quietly = TRUE)
[17:38:07.307]                         if (has_future) {
[17:38:07.307]                           ns <- base::getNamespace("future")
[17:38:07.307]                           version <- ns[[".package"]][["version"]]
[17:38:07.307]                           if (is.null(version)) 
[17:38:07.307]                             version <- utils::packageVersion("future")
[17:38:07.307]                         }
[17:38:07.307]                         else {
[17:38:07.307]                           version <- NULL
[17:38:07.307]                         }
[17:38:07.307]                         if (!has_future || version < "1.8.0") {
[17:38:07.307]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.307]                             "", base::R.version$version.string), 
[17:38:07.307]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:07.307]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:07.307]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.307]                               "release", "version")], collapse = " "), 
[17:38:07.307]                             hostname = base::Sys.info()[["nodename"]])
[17:38:07.307]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.307]                             info)
[17:38:07.307]                           info <- base::paste(info, collapse = "; ")
[17:38:07.307]                           if (!has_future) {
[17:38:07.307]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.307]                               info)
[17:38:07.307]                           }
[17:38:07.307]                           else {
[17:38:07.307]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.307]                               info, version)
[17:38:07.307]                           }
[17:38:07.307]                           base::stop(msg)
[17:38:07.307]                         }
[17:38:07.307]                       })
[17:38:07.307]                     }
[17:38:07.307]                     base::local({
[17:38:07.307]                       for (pkg in "future.apply") {
[17:38:07.307]                         base::loadNamespace(pkg)
[17:38:07.307]                         base::library(pkg, character.only = TRUE)
[17:38:07.307]                       }
[17:38:07.307]                     })
[17:38:07.307]                   }
[17:38:07.307]                   ...future.strategy.old <- future::plan("list")
[17:38:07.307]                   options(future.plan = NULL)
[17:38:07.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.307]                 }
[17:38:07.307]                 ...future.workdir <- getwd()
[17:38:07.307]             }
[17:38:07.307]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.307]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.307]         }
[17:38:07.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.307]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:07.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.307]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.307]             base::names(...future.oldOptions))
[17:38:07.307]     }
[17:38:07.307]     if (FALSE) {
[17:38:07.307]     }
[17:38:07.307]     else {
[17:38:07.307]         if (TRUE) {
[17:38:07.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.307]                 open = "w")
[17:38:07.307]         }
[17:38:07.307]         else {
[17:38:07.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.307]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.307]         }
[17:38:07.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.307]             base::sink(type = "output", split = FALSE)
[17:38:07.307]             base::close(...future.stdout)
[17:38:07.307]         }, add = TRUE)
[17:38:07.307]     }
[17:38:07.307]     ...future.frame <- base::sys.nframe()
[17:38:07.307]     ...future.conditions <- base::list()
[17:38:07.307]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.307]     if (FALSE) {
[17:38:07.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.307]     }
[17:38:07.307]     ...future.result <- base::tryCatch({
[17:38:07.307]         base::withCallingHandlers({
[17:38:07.307]             ...future.value <- base::withVisible(base::local({
[17:38:07.307]                 do.call(function(...) {
[17:38:07.307]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.307]                   if (!identical(...future.globals.maxSize.org, 
[17:38:07.307]                     ...future.globals.maxSize)) {
[17:38:07.307]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.307]                     on.exit(options(oopts), add = TRUE)
[17:38:07.307]                   }
[17:38:07.307]                   {
[17:38:07.307]                     lapply(seq_along(...future.elements_ii), 
[17:38:07.307]                       FUN = function(jj) {
[17:38:07.307]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.307]                         ...future.FUN(...future.X_jj, ...)
[17:38:07.307]                       })
[17:38:07.307]                   }
[17:38:07.307]                 }, args = future.call.arguments)
[17:38:07.307]             }))
[17:38:07.307]             future::FutureResult(value = ...future.value$value, 
[17:38:07.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.307]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.307]                     ...future.globalenv.names))
[17:38:07.307]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.307]         }, condition = base::local({
[17:38:07.307]             c <- base::c
[17:38:07.307]             inherits <- base::inherits
[17:38:07.307]             invokeRestart <- base::invokeRestart
[17:38:07.307]             length <- base::length
[17:38:07.307]             list <- base::list
[17:38:07.307]             seq.int <- base::seq.int
[17:38:07.307]             signalCondition <- base::signalCondition
[17:38:07.307]             sys.calls <- base::sys.calls
[17:38:07.307]             `[[` <- base::`[[`
[17:38:07.307]             `+` <- base::`+`
[17:38:07.307]             `<<-` <- base::`<<-`
[17:38:07.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.307]                   3L)]
[17:38:07.307]             }
[17:38:07.307]             function(cond) {
[17:38:07.307]                 is_error <- inherits(cond, "error")
[17:38:07.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.307]                   NULL)
[17:38:07.307]                 if (is_error) {
[17:38:07.307]                   sessionInformation <- function() {
[17:38:07.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.307]                       search = base::search(), system = base::Sys.info())
[17:38:07.307]                   }
[17:38:07.307]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.307]                     cond$call), session = sessionInformation(), 
[17:38:07.307]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.307]                   signalCondition(cond)
[17:38:07.307]                 }
[17:38:07.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.307]                 "immediateCondition"))) {
[17:38:07.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.307]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.307]                   if (TRUE && !signal) {
[17:38:07.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.307]                     {
[17:38:07.307]                       inherits <- base::inherits
[17:38:07.307]                       invokeRestart <- base::invokeRestart
[17:38:07.307]                       is.null <- base::is.null
[17:38:07.307]                       muffled <- FALSE
[17:38:07.307]                       if (inherits(cond, "message")) {
[17:38:07.307]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.307]                         if (muffled) 
[17:38:07.307]                           invokeRestart("muffleMessage")
[17:38:07.307]                       }
[17:38:07.307]                       else if (inherits(cond, "warning")) {
[17:38:07.307]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.307]                         if (muffled) 
[17:38:07.307]                           invokeRestart("muffleWarning")
[17:38:07.307]                       }
[17:38:07.307]                       else if (inherits(cond, "condition")) {
[17:38:07.307]                         if (!is.null(pattern)) {
[17:38:07.307]                           computeRestarts <- base::computeRestarts
[17:38:07.307]                           grepl <- base::grepl
[17:38:07.307]                           restarts <- computeRestarts(cond)
[17:38:07.307]                           for (restart in restarts) {
[17:38:07.307]                             name <- restart$name
[17:38:07.307]                             if (is.null(name)) 
[17:38:07.307]                               next
[17:38:07.307]                             if (!grepl(pattern, name)) 
[17:38:07.307]                               next
[17:38:07.307]                             invokeRestart(restart)
[17:38:07.307]                             muffled <- TRUE
[17:38:07.307]                             break
[17:38:07.307]                           }
[17:38:07.307]                         }
[17:38:07.307]                       }
[17:38:07.307]                       invisible(muffled)
[17:38:07.307]                     }
[17:38:07.307]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.307]                   }
[17:38:07.307]                 }
[17:38:07.307]                 else {
[17:38:07.307]                   if (TRUE) {
[17:38:07.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.307]                     {
[17:38:07.307]                       inherits <- base::inherits
[17:38:07.307]                       invokeRestart <- base::invokeRestart
[17:38:07.307]                       is.null <- base::is.null
[17:38:07.307]                       muffled <- FALSE
[17:38:07.307]                       if (inherits(cond, "message")) {
[17:38:07.307]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.307]                         if (muffled) 
[17:38:07.307]                           invokeRestart("muffleMessage")
[17:38:07.307]                       }
[17:38:07.307]                       else if (inherits(cond, "warning")) {
[17:38:07.307]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.307]                         if (muffled) 
[17:38:07.307]                           invokeRestart("muffleWarning")
[17:38:07.307]                       }
[17:38:07.307]                       else if (inherits(cond, "condition")) {
[17:38:07.307]                         if (!is.null(pattern)) {
[17:38:07.307]                           computeRestarts <- base::computeRestarts
[17:38:07.307]                           grepl <- base::grepl
[17:38:07.307]                           restarts <- computeRestarts(cond)
[17:38:07.307]                           for (restart in restarts) {
[17:38:07.307]                             name <- restart$name
[17:38:07.307]                             if (is.null(name)) 
[17:38:07.307]                               next
[17:38:07.307]                             if (!grepl(pattern, name)) 
[17:38:07.307]                               next
[17:38:07.307]                             invokeRestart(restart)
[17:38:07.307]                             muffled <- TRUE
[17:38:07.307]                             break
[17:38:07.307]                           }
[17:38:07.307]                         }
[17:38:07.307]                       }
[17:38:07.307]                       invisible(muffled)
[17:38:07.307]                     }
[17:38:07.307]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.307]                   }
[17:38:07.307]                 }
[17:38:07.307]             }
[17:38:07.307]         }))
[17:38:07.307]     }, error = function(ex) {
[17:38:07.307]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.307]                 ...future.rng), started = ...future.startTime, 
[17:38:07.307]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.307]             version = "1.8"), class = "FutureResult")
[17:38:07.307]     }, finally = {
[17:38:07.307]         if (!identical(...future.workdir, getwd())) 
[17:38:07.307]             setwd(...future.workdir)
[17:38:07.307]         {
[17:38:07.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.307]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.307]             }
[17:38:07.307]             base::options(...future.oldOptions)
[17:38:07.307]             if (.Platform$OS.type == "windows") {
[17:38:07.307]                 old_names <- names(...future.oldEnvVars)
[17:38:07.307]                 envs <- base::Sys.getenv()
[17:38:07.307]                 names <- names(envs)
[17:38:07.307]                 common <- intersect(names, old_names)
[17:38:07.307]                 added <- setdiff(names, old_names)
[17:38:07.307]                 removed <- setdiff(old_names, names)
[17:38:07.307]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.307]                   envs[common]]
[17:38:07.307]                 NAMES <- toupper(changed)
[17:38:07.307]                 args <- list()
[17:38:07.307]                 for (kk in seq_along(NAMES)) {
[17:38:07.307]                   name <- changed[[kk]]
[17:38:07.307]                   NAME <- NAMES[[kk]]
[17:38:07.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.307]                     next
[17:38:07.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.307]                 }
[17:38:07.307]                 NAMES <- toupper(added)
[17:38:07.307]                 for (kk in seq_along(NAMES)) {
[17:38:07.307]                   name <- added[[kk]]
[17:38:07.307]                   NAME <- NAMES[[kk]]
[17:38:07.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.307]                     next
[17:38:07.307]                   args[[name]] <- ""
[17:38:07.307]                 }
[17:38:07.307]                 NAMES <- toupper(removed)
[17:38:07.307]                 for (kk in seq_along(NAMES)) {
[17:38:07.307]                   name <- removed[[kk]]
[17:38:07.307]                   NAME <- NAMES[[kk]]
[17:38:07.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.307]                     next
[17:38:07.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.307]                 }
[17:38:07.307]                 if (length(args) > 0) 
[17:38:07.307]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.307]             }
[17:38:07.307]             else {
[17:38:07.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.307]             }
[17:38:07.307]             {
[17:38:07.307]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.307]                   0L) {
[17:38:07.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.307]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.307]                   base::options(opts)
[17:38:07.307]                 }
[17:38:07.307]                 {
[17:38:07.307]                   {
[17:38:07.307]                     NULL
[17:38:07.307]                     RNGkind("Mersenne-Twister")
[17:38:07.307]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:38:07.307]                       inherits = FALSE)
[17:38:07.307]                   }
[17:38:07.307]                   options(future.plan = NULL)
[17:38:07.307]                   if (is.na(NA_character_)) 
[17:38:07.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.307]                     .init = FALSE)
[17:38:07.307]                 }
[17:38:07.307]             }
[17:38:07.307]         }
[17:38:07.307]     })
[17:38:07.307]     if (TRUE) {
[17:38:07.307]         base::sink(type = "output", split = FALSE)
[17:38:07.307]         if (TRUE) {
[17:38:07.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.307]         }
[17:38:07.307]         else {
[17:38:07.307]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.307]         }
[17:38:07.307]         base::close(...future.stdout)
[17:38:07.307]         ...future.stdout <- NULL
[17:38:07.307]     }
[17:38:07.307]     ...future.result$conditions <- ...future.conditions
[17:38:07.307]     ...future.result$finished <- base::Sys.time()
[17:38:07.307]     ...future.result
[17:38:07.307] }
[17:38:07.308] assign_globals() ...
[17:38:07.308] List of 11
[17:38:07.308]  $ ...future.FUN            :function (x, ...)  
[17:38:07.308]  $ x_FUN                    :function (x)  
[17:38:07.308]  $ times                    : int 2
[17:38:07.308]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.308]  $ stop_if_not              :function (...)  
[17:38:07.308]  $ dim                      : NULL
[17:38:07.308]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:07.308]  $ future.call.arguments    : list()
[17:38:07.308]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.308]  $ ...future.elements_ii    :List of 3
[17:38:07.308]   ..$ : int 1
[17:38:07.308]   ..$ : int 2
[17:38:07.308]   ..$ : int 3
[17:38:07.308]  $ ...future.seeds_ii       : NULL
[17:38:07.308]  $ ...future.globals.maxSize: NULL
[17:38:07.308]  - attr(*, "where")=List of 11
[17:38:07.308]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.308]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.308]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.308]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.308]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.308]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.308]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.308]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.308]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.308]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.308]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.308]  - attr(*, "resolved")= logi FALSE
[17:38:07.308]  - attr(*, "total_size")= num 95128
[17:38:07.308]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.308]  - attr(*, "already-done")= logi TRUE
[17:38:07.316] - copied ‘...future.FUN’ to environment
[17:38:07.316] - copied ‘x_FUN’ to environment
[17:38:07.316] - copied ‘times’ to environment
[17:38:07.316] - copied ‘stopf’ to environment
[17:38:07.316] - copied ‘stop_if_not’ to environment
[17:38:07.316] - copied ‘dim’ to environment
[17:38:07.317] - copied ‘valid_types’ to environment
[17:38:07.317] - copied ‘future.call.arguments’ to environment
[17:38:07.317] - copied ‘...future.elements_ii’ to environment
[17:38:07.317] - copied ‘...future.seeds_ii’ to environment
[17:38:07.317] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.317] assign_globals() ... done
[17:38:07.317] plan(): Setting new future strategy stack:
[17:38:07.318] List of future strategies:
[17:38:07.318] 1. sequential:
[17:38:07.318]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.318]    - tweaked: FALSE
[17:38:07.318]    - call: NULL
[17:38:07.318] plan(): nbrOfWorkers() = 1
[17:38:07.319] plan(): Setting new future strategy stack:
[17:38:07.319] List of future strategies:
[17:38:07.319] 1. sequential:
[17:38:07.319]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.319]    - tweaked: FALSE
[17:38:07.319]    - call: plan(strategy)
[17:38:07.319] plan(): nbrOfWorkers() = 1
[17:38:07.320] SequentialFuture started (and completed)
[17:38:07.320] signalConditions() ...
[17:38:07.320]  - include = ‘immediateCondition’
[17:38:07.320]  - exclude = 
[17:38:07.320]  - resignal = FALSE
[17:38:07.320]  - Number of conditions: 1
[17:38:07.320] signalConditions() ... done
[17:38:07.320] - Launch lazy future ... done
[17:38:07.322] run() for ‘SequentialFuture’ ... done
[17:38:07.322] Created future:
[17:38:07.322] SequentialFuture:
[17:38:07.322] Label: ‘future_vapply-1’
[17:38:07.322] Expression:
[17:38:07.322] {
[17:38:07.322]     do.call(function(...) {
[17:38:07.322]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.322]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.322]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.322]             on.exit(options(oopts), add = TRUE)
[17:38:07.322]         }
[17:38:07.322]         {
[17:38:07.322]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.322]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.322]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.322]             })
[17:38:07.322]         }
[17:38:07.322]     }, args = future.call.arguments)
[17:38:07.322] }
[17:38:07.322] Lazy evaluation: FALSE
[17:38:07.322] Asynchronous evaluation: FALSE
[17:38:07.322] Local evaluation: TRUE
[17:38:07.322] Environment: R_GlobalEnv
[17:38:07.322] Capture standard output: TRUE
[17:38:07.322] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.322] Globals: 11 objects totaling 93.06 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.322] Packages: 1 packages (‘future.apply’)
[17:38:07.322] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.322] Resolved: TRUE
[17:38:07.322] Value: 0 bytes of class ‘NULL’
[17:38:07.322] Conditions captured: [n=1] ‘simpleError’
[17:38:07.322] Early signaling: FALSE
[17:38:07.322] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.322] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:38:07.323] Chunk #1 of 1 ... DONE
[17:38:07.324] Launching 1 futures (chunks) ... DONE
[17:38:07.324] Resolving 1 futures (chunks) ...
[17:38:07.324] resolve() on list ...
[17:38:07.324]  recursive: 0
[17:38:07.324]  length: 1
[17:38:07.324] 
[17:38:07.324] resolved() for ‘SequentialFuture’ ...
[17:38:07.324] - state: ‘finished’
[17:38:07.324] - run: TRUE
[17:38:07.325] - result: ‘FutureResult’
[17:38:07.325] resolved() for ‘SequentialFuture’ ... done
[17:38:07.325] Future #1
[17:38:07.325] signalConditions() ...
[17:38:07.325]  - include = ‘immediateCondition’
[17:38:07.325]  - exclude = 
[17:38:07.325]  - resignal = FALSE
[17:38:07.325]  - Number of conditions: 1
[17:38:07.325] signalConditions() ... done
[17:38:07.325] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:38:07.326] - nx: 1
[17:38:07.326] - relay: TRUE
[17:38:07.326] - stdout: TRUE
[17:38:07.326] - signal: TRUE
[17:38:07.326] - resignal: FALSE
[17:38:07.326] - force: TRUE
[17:38:07.326] - relayed: [n=1] FALSE
[17:38:07.326] - queued futures: [n=1] FALSE
[17:38:07.326]  - until=1
[17:38:07.326]  - relaying element #1
[17:38:07.326] signalConditions() ...
[17:38:07.326]  - include = ‘immediateCondition’
[17:38:07.327]  - exclude = 
[17:38:07.327]  - resignal = FALSE
[17:38:07.327]  - Number of conditions: 1
[17:38:07.327] signalConditions() ... done
[17:38:07.327] signalConditions() ...
[17:38:07.327]  - include = ‘immediateCondition’
[17:38:07.327]  - exclude = 
[17:38:07.327]  - resignal = FALSE
[17:38:07.327]  - Number of conditions: 1
[17:38:07.327] signalConditions() ... done
[17:38:07.328] signalConditions() ...
[17:38:07.328]  - include = ‘condition’
[17:38:07.328]  - exclude = ‘immediateCondition’
[17:38:07.328]  - resignal = TRUE
[17:38:07.328]  - Number of conditions: 1
[17:38:07.328]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:38:07.328] signalConditions() ... done
[17:38:07.328] - relayed: [n=1] FALSE
[17:38:07.328] - queued futures: [n=1] TRUE
[17:38:07.328] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:38:07.329] plan(): Setting new future strategy stack:
[17:38:07.329] List of future strategies:
[17:38:07.329] 1. sequential:
[17:38:07.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.329]    - tweaked: FALSE
[17:38:07.329]    - call: plan(sequential)
[17:38:07.329] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:38:07.330] plan(): Setting new future strategy stack:
[17:38:07.330] List of future strategies:
[17:38:07.330] 1. multicore:
[17:38:07.330]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:07.330]    - tweaked: FALSE
[17:38:07.330]    - call: plan(strategy)
[17:38:07.333] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[17:38:07.336] future_lapply() ...
[17:38:07.341] Number of chunks: 2
[17:38:07.341] getGlobalsAndPackagesXApply() ...
[17:38:07.341]  - future.globals: TRUE
[17:38:07.341] getGlobalsAndPackages() ...
[17:38:07.342] Searching for globals...
[17:38:07.344] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:07.345] Searching for globals ... DONE
[17:38:07.345] Resolving globals: FALSE
[17:38:07.346] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[17:38:07.346] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:07.346] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.346] - packages: [1] ‘future.apply’
[17:38:07.346] getGlobalsAndPackages() ... DONE
[17:38:07.346]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.347]  - needed namespaces: [n=1] ‘future.apply’
[17:38:07.347] Finding globals ... DONE
[17:38:07.347]  - use_args: TRUE
[17:38:07.347]  - Getting '...' globals ...
[17:38:07.347] resolve() on list ...
[17:38:07.347]  recursive: 0
[17:38:07.347]  length: 1
[17:38:07.347]  elements: ‘...’
[17:38:07.348]  length: 0 (resolved future 1)
[17:38:07.348] resolve() on list ... DONE
[17:38:07.348]    - '...' content: [n=0] 
[17:38:07.348] List of 1
[17:38:07.348]  $ ...: list()
[17:38:07.348]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.348]  - attr(*, "where")=List of 1
[17:38:07.348]   ..$ ...:<environment: 0x56080141ad88> 
[17:38:07.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.348]  - attr(*, "resolved")= logi TRUE
[17:38:07.348]  - attr(*, "total_size")= num NA
[17:38:07.352]  - Getting '...' globals ... DONE
[17:38:07.353] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:07.353] List of 8
[17:38:07.353]  $ ...future.FUN:function (x, ...)  
[17:38:07.353]  $ x_FUN        :function (x)  
[17:38:07.353]  $ times        : int 1
[17:38:07.353]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.353]  $ stop_if_not  :function (...)  
[17:38:07.353]  $ dim          : NULL
[17:38:07.353]  $ valid_types  : chr "character"
[17:38:07.353]  $ ...          : list()
[17:38:07.353]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.353]  - attr(*, "where")=List of 8
[17:38:07.353]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:07.353]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:07.353]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:07.353]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:07.353]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:07.353]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:07.353]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:07.353]   ..$ ...          :<environment: 0x56080141ad88> 
[17:38:07.353]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.353]  - attr(*, "resolved")= logi FALSE
[17:38:07.353]  - attr(*, "total_size")= num 94208
[17:38:07.358] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:07.358] getGlobalsAndPackagesXApply() ... DONE
[17:38:07.358] Number of futures (= number of chunks): 2
[17:38:07.358] Launching 2 futures (chunks) ...
[17:38:07.358] Chunk #1 of 2 ...
[17:38:07.359]  - Finding globals in 'X' for chunk #1 ...
[17:38:07.359] getGlobalsAndPackages() ...
[17:38:07.359] Searching for globals...
[17:38:07.359] 
[17:38:07.359] Searching for globals ... DONE
[17:38:07.359] - globals: [0] <none>
[17:38:07.359] getGlobalsAndPackages() ... DONE
[17:38:07.359]    + additional globals found: [n=0] 
[17:38:07.359]    + additional namespaces needed: [n=0] 
[17:38:07.359]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:07.360]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:07.360]  - seeds: <none>
[17:38:07.360]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.360] getGlobalsAndPackages() ...
[17:38:07.360] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.360] Resolving globals: FALSE
[17:38:07.360] Tweak future expression to call with '...' arguments ...
[17:38:07.360] {
[17:38:07.360]     do.call(function(...) {
[17:38:07.360]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.360]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.360]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.360]             on.exit(options(oopts), add = TRUE)
[17:38:07.360]         }
[17:38:07.360]         {
[17:38:07.360]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.360]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.360]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.360]             })
[17:38:07.360]         }
[17:38:07.360]     }, args = future.call.arguments)
[17:38:07.360] }
[17:38:07.361] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.361] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.361] - packages: [1] ‘future.apply’
[17:38:07.361] getGlobalsAndPackages() ... DONE
[17:38:07.362] run() for ‘Future’ ...
[17:38:07.362] - state: ‘created’
[17:38:07.362] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:07.366] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.366] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:07.366]   - Field: ‘label’
[17:38:07.366]   - Field: ‘local’
[17:38:07.366]   - Field: ‘owner’
[17:38:07.366]   - Field: ‘envir’
[17:38:07.366]   - Field: ‘workers’
[17:38:07.366]   - Field: ‘packages’
[17:38:07.366]   - Field: ‘gc’
[17:38:07.367]   - Field: ‘job’
[17:38:07.367]   - Field: ‘conditions’
[17:38:07.367]   - Field: ‘expr’
[17:38:07.367]   - Field: ‘uuid’
[17:38:07.367]   - Field: ‘seed’
[17:38:07.367]   - Field: ‘version’
[17:38:07.367]   - Field: ‘result’
[17:38:07.367]   - Field: ‘asynchronous’
[17:38:07.367]   - Field: ‘calls’
[17:38:07.367]   - Field: ‘globals’
[17:38:07.367]   - Field: ‘stdout’
[17:38:07.368]   - Field: ‘earlySignal’
[17:38:07.368]   - Field: ‘lazy’
[17:38:07.368]   - Field: ‘state’
[17:38:07.368] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:07.368] - Launch lazy future ...
[17:38:07.369] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:07.369] Packages needed by future strategies (n = 0): <none>
[17:38:07.370] {
[17:38:07.370]     {
[17:38:07.370]         {
[17:38:07.370]             ...future.startTime <- base::Sys.time()
[17:38:07.370]             {
[17:38:07.370]                 {
[17:38:07.370]                   {
[17:38:07.370]                     {
[17:38:07.370]                       {
[17:38:07.370]                         base::local({
[17:38:07.370]                           has_future <- base::requireNamespace("future", 
[17:38:07.370]                             quietly = TRUE)
[17:38:07.370]                           if (has_future) {
[17:38:07.370]                             ns <- base::getNamespace("future")
[17:38:07.370]                             version <- ns[[".package"]][["version"]]
[17:38:07.370]                             if (is.null(version)) 
[17:38:07.370]                               version <- utils::packageVersion("future")
[17:38:07.370]                           }
[17:38:07.370]                           else {
[17:38:07.370]                             version <- NULL
[17:38:07.370]                           }
[17:38:07.370]                           if (!has_future || version < "1.8.0") {
[17:38:07.370]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.370]                               "", base::R.version$version.string), 
[17:38:07.370]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:07.370]                                 base::R.version$platform, 8 * 
[17:38:07.370]                                   base::.Machine$sizeof.pointer), 
[17:38:07.370]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.370]                                 "release", "version")], collapse = " "), 
[17:38:07.370]                               hostname = base::Sys.info()[["nodename"]])
[17:38:07.370]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.370]                               info)
[17:38:07.370]                             info <- base::paste(info, collapse = "; ")
[17:38:07.370]                             if (!has_future) {
[17:38:07.370]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.370]                                 info)
[17:38:07.370]                             }
[17:38:07.370]                             else {
[17:38:07.370]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.370]                                 info, version)
[17:38:07.370]                             }
[17:38:07.370]                             base::stop(msg)
[17:38:07.370]                           }
[17:38:07.370]                         })
[17:38:07.370]                       }
[17:38:07.370]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:07.370]                       base::options(mc.cores = 1L)
[17:38:07.370]                     }
[17:38:07.370]                     base::local({
[17:38:07.370]                       for (pkg in "future.apply") {
[17:38:07.370]                         base::loadNamespace(pkg)
[17:38:07.370]                         base::library(pkg, character.only = TRUE)
[17:38:07.370]                       }
[17:38:07.370]                     })
[17:38:07.370]                   }
[17:38:07.370]                   ...future.strategy.old <- future::plan("list")
[17:38:07.370]                   options(future.plan = NULL)
[17:38:07.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.370]                 }
[17:38:07.370]                 ...future.workdir <- getwd()
[17:38:07.370]             }
[17:38:07.370]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.370]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.370]         }
[17:38:07.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.370]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:07.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.370]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.370]             base::names(...future.oldOptions))
[17:38:07.370]     }
[17:38:07.370]     if (FALSE) {
[17:38:07.370]     }
[17:38:07.370]     else {
[17:38:07.370]         if (TRUE) {
[17:38:07.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.370]                 open = "w")
[17:38:07.370]         }
[17:38:07.370]         else {
[17:38:07.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.370]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.370]         }
[17:38:07.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.370]             base::sink(type = "output", split = FALSE)
[17:38:07.370]             base::close(...future.stdout)
[17:38:07.370]         }, add = TRUE)
[17:38:07.370]     }
[17:38:07.370]     ...future.frame <- base::sys.nframe()
[17:38:07.370]     ...future.conditions <- base::list()
[17:38:07.370]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.370]     if (FALSE) {
[17:38:07.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.370]     }
[17:38:07.370]     ...future.result <- base::tryCatch({
[17:38:07.370]         base::withCallingHandlers({
[17:38:07.370]             ...future.value <- base::withVisible(base::local({
[17:38:07.370]                 withCallingHandlers({
[17:38:07.370]                   {
[17:38:07.370]                     do.call(function(...) {
[17:38:07.370]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.370]                       if (!identical(...future.globals.maxSize.org, 
[17:38:07.370]                         ...future.globals.maxSize)) {
[17:38:07.370]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.370]                         on.exit(options(oopts), add = TRUE)
[17:38:07.370]                       }
[17:38:07.370]                       {
[17:38:07.370]                         lapply(seq_along(...future.elements_ii), 
[17:38:07.370]                           FUN = function(jj) {
[17:38:07.370]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.370]                             ...future.FUN(...future.X_jj, ...)
[17:38:07.370]                           })
[17:38:07.370]                       }
[17:38:07.370]                     }, args = future.call.arguments)
[17:38:07.370]                   }
[17:38:07.370]                 }, immediateCondition = function(cond) {
[17:38:07.370]                   save_rds <- function (object, pathname, ...) 
[17:38:07.370]                   {
[17:38:07.370]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:07.370]                     if (file_test("-f", pathname_tmp)) {
[17:38:07.370]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.370]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:07.370]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.370]                         fi_tmp[["mtime"]])
[17:38:07.370]                     }
[17:38:07.370]                     tryCatch({
[17:38:07.370]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:07.370]                     }, error = function(ex) {
[17:38:07.370]                       msg <- conditionMessage(ex)
[17:38:07.370]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.370]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:07.370]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.370]                         fi_tmp[["mtime"]], msg)
[17:38:07.370]                       ex$message <- msg
[17:38:07.370]                       stop(ex)
[17:38:07.370]                     })
[17:38:07.370]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:07.370]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:07.370]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:07.370]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.370]                       fi <- file.info(pathname)
[17:38:07.370]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:07.370]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.370]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:07.370]                         fi[["size"]], fi[["mtime"]])
[17:38:07.370]                       stop(msg)
[17:38:07.370]                     }
[17:38:07.370]                     invisible(pathname)
[17:38:07.370]                   }
[17:38:07.370]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:07.370]                     rootPath = tempdir()) 
[17:38:07.370]                   {
[17:38:07.370]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:07.370]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:07.370]                       tmpdir = path, fileext = ".rds")
[17:38:07.370]                     save_rds(obj, file)
[17:38:07.370]                   }
[17:38:07.370]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:07.370]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.370]                   {
[17:38:07.370]                     inherits <- base::inherits
[17:38:07.370]                     invokeRestart <- base::invokeRestart
[17:38:07.370]                     is.null <- base::is.null
[17:38:07.370]                     muffled <- FALSE
[17:38:07.370]                     if (inherits(cond, "message")) {
[17:38:07.370]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:07.370]                       if (muffled) 
[17:38:07.370]                         invokeRestart("muffleMessage")
[17:38:07.370]                     }
[17:38:07.370]                     else if (inherits(cond, "warning")) {
[17:38:07.370]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:07.370]                       if (muffled) 
[17:38:07.370]                         invokeRestart("muffleWarning")
[17:38:07.370]                     }
[17:38:07.370]                     else if (inherits(cond, "condition")) {
[17:38:07.370]                       if (!is.null(pattern)) {
[17:38:07.370]                         computeRestarts <- base::computeRestarts
[17:38:07.370]                         grepl <- base::grepl
[17:38:07.370]                         restarts <- computeRestarts(cond)
[17:38:07.370]                         for (restart in restarts) {
[17:38:07.370]                           name <- restart$name
[17:38:07.370]                           if (is.null(name)) 
[17:38:07.370]                             next
[17:38:07.370]                           if (!grepl(pattern, name)) 
[17:38:07.370]                             next
[17:38:07.370]                           invokeRestart(restart)
[17:38:07.370]                           muffled <- TRUE
[17:38:07.370]                           break
[17:38:07.370]                         }
[17:38:07.370]                       }
[17:38:07.370]                     }
[17:38:07.370]                     invisible(muffled)
[17:38:07.370]                   }
[17:38:07.370]                   muffleCondition(cond)
[17:38:07.370]                 })
[17:38:07.370]             }))
[17:38:07.370]             future::FutureResult(value = ...future.value$value, 
[17:38:07.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.370]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.370]                     ...future.globalenv.names))
[17:38:07.370]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.370]         }, condition = base::local({
[17:38:07.370]             c <- base::c
[17:38:07.370]             inherits <- base::inherits
[17:38:07.370]             invokeRestart <- base::invokeRestart
[17:38:07.370]             length <- base::length
[17:38:07.370]             list <- base::list
[17:38:07.370]             seq.int <- base::seq.int
[17:38:07.370]             signalCondition <- base::signalCondition
[17:38:07.370]             sys.calls <- base::sys.calls
[17:38:07.370]             `[[` <- base::`[[`
[17:38:07.370]             `+` <- base::`+`
[17:38:07.370]             `<<-` <- base::`<<-`
[17:38:07.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.370]                   3L)]
[17:38:07.370]             }
[17:38:07.370]             function(cond) {
[17:38:07.370]                 is_error <- inherits(cond, "error")
[17:38:07.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.370]                   NULL)
[17:38:07.370]                 if (is_error) {
[17:38:07.370]                   sessionInformation <- function() {
[17:38:07.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.370]                       search = base::search(), system = base::Sys.info())
[17:38:07.370]                   }
[17:38:07.370]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.370]                     cond$call), session = sessionInformation(), 
[17:38:07.370]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.370]                   signalCondition(cond)
[17:38:07.370]                 }
[17:38:07.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.370]                 "immediateCondition"))) {
[17:38:07.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.370]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.370]                   if (TRUE && !signal) {
[17:38:07.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.370]                     {
[17:38:07.370]                       inherits <- base::inherits
[17:38:07.370]                       invokeRestart <- base::invokeRestart
[17:38:07.370]                       is.null <- base::is.null
[17:38:07.370]                       muffled <- FALSE
[17:38:07.370]                       if (inherits(cond, "message")) {
[17:38:07.370]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.370]                         if (muffled) 
[17:38:07.370]                           invokeRestart("muffleMessage")
[17:38:07.370]                       }
[17:38:07.370]                       else if (inherits(cond, "warning")) {
[17:38:07.370]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.370]                         if (muffled) 
[17:38:07.370]                           invokeRestart("muffleWarning")
[17:38:07.370]                       }
[17:38:07.370]                       else if (inherits(cond, "condition")) {
[17:38:07.370]                         if (!is.null(pattern)) {
[17:38:07.370]                           computeRestarts <- base::computeRestarts
[17:38:07.370]                           grepl <- base::grepl
[17:38:07.370]                           restarts <- computeRestarts(cond)
[17:38:07.370]                           for (restart in restarts) {
[17:38:07.370]                             name <- restart$name
[17:38:07.370]                             if (is.null(name)) 
[17:38:07.370]                               next
[17:38:07.370]                             if (!grepl(pattern, name)) 
[17:38:07.370]                               next
[17:38:07.370]                             invokeRestart(restart)
[17:38:07.370]                             muffled <- TRUE
[17:38:07.370]                             break
[17:38:07.370]                           }
[17:38:07.370]                         }
[17:38:07.370]                       }
[17:38:07.370]                       invisible(muffled)
[17:38:07.370]                     }
[17:38:07.370]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.370]                   }
[17:38:07.370]                 }
[17:38:07.370]                 else {
[17:38:07.370]                   if (TRUE) {
[17:38:07.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.370]                     {
[17:38:07.370]                       inherits <- base::inherits
[17:38:07.370]                       invokeRestart <- base::invokeRestart
[17:38:07.370]                       is.null <- base::is.null
[17:38:07.370]                       muffled <- FALSE
[17:38:07.370]                       if (inherits(cond, "message")) {
[17:38:07.370]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.370]                         if (muffled) 
[17:38:07.370]                           invokeRestart("muffleMessage")
[17:38:07.370]                       }
[17:38:07.370]                       else if (inherits(cond, "warning")) {
[17:38:07.370]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.370]                         if (muffled) 
[17:38:07.370]                           invokeRestart("muffleWarning")
[17:38:07.370]                       }
[17:38:07.370]                       else if (inherits(cond, "condition")) {
[17:38:07.370]                         if (!is.null(pattern)) {
[17:38:07.370]                           computeRestarts <- base::computeRestarts
[17:38:07.370]                           grepl <- base::grepl
[17:38:07.370]                           restarts <- computeRestarts(cond)
[17:38:07.370]                           for (restart in restarts) {
[17:38:07.370]                             name <- restart$name
[17:38:07.370]                             if (is.null(name)) 
[17:38:07.370]                               next
[17:38:07.370]                             if (!grepl(pattern, name)) 
[17:38:07.370]                               next
[17:38:07.370]                             invokeRestart(restart)
[17:38:07.370]                             muffled <- TRUE
[17:38:07.370]                             break
[17:38:07.370]                           }
[17:38:07.370]                         }
[17:38:07.370]                       }
[17:38:07.370]                       invisible(muffled)
[17:38:07.370]                     }
[17:38:07.370]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.370]                   }
[17:38:07.370]                 }
[17:38:07.370]             }
[17:38:07.370]         }))
[17:38:07.370]     }, error = function(ex) {
[17:38:07.370]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.370]                 ...future.rng), started = ...future.startTime, 
[17:38:07.370]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.370]             version = "1.8"), class = "FutureResult")
[17:38:07.370]     }, finally = {
[17:38:07.370]         if (!identical(...future.workdir, getwd())) 
[17:38:07.370]             setwd(...future.workdir)
[17:38:07.370]         {
[17:38:07.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.370]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.370]             }
[17:38:07.370]             base::options(...future.oldOptions)
[17:38:07.370]             if (.Platform$OS.type == "windows") {
[17:38:07.370]                 old_names <- names(...future.oldEnvVars)
[17:38:07.370]                 envs <- base::Sys.getenv()
[17:38:07.370]                 names <- names(envs)
[17:38:07.370]                 common <- intersect(names, old_names)
[17:38:07.370]                 added <- setdiff(names, old_names)
[17:38:07.370]                 removed <- setdiff(old_names, names)
[17:38:07.370]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.370]                   envs[common]]
[17:38:07.370]                 NAMES <- toupper(changed)
[17:38:07.370]                 args <- list()
[17:38:07.370]                 for (kk in seq_along(NAMES)) {
[17:38:07.370]                   name <- changed[[kk]]
[17:38:07.370]                   NAME <- NAMES[[kk]]
[17:38:07.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.370]                     next
[17:38:07.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.370]                 }
[17:38:07.370]                 NAMES <- toupper(added)
[17:38:07.370]                 for (kk in seq_along(NAMES)) {
[17:38:07.370]                   name <- added[[kk]]
[17:38:07.370]                   NAME <- NAMES[[kk]]
[17:38:07.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.370]                     next
[17:38:07.370]                   args[[name]] <- ""
[17:38:07.370]                 }
[17:38:07.370]                 NAMES <- toupper(removed)
[17:38:07.370]                 for (kk in seq_along(NAMES)) {
[17:38:07.370]                   name <- removed[[kk]]
[17:38:07.370]                   NAME <- NAMES[[kk]]
[17:38:07.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.370]                     next
[17:38:07.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.370]                 }
[17:38:07.370]                 if (length(args) > 0) 
[17:38:07.370]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.370]             }
[17:38:07.370]             else {
[17:38:07.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.370]             }
[17:38:07.370]             {
[17:38:07.370]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.370]                   0L) {
[17:38:07.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.370]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.370]                   base::options(opts)
[17:38:07.370]                 }
[17:38:07.370]                 {
[17:38:07.370]                   {
[17:38:07.370]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:07.370]                     NULL
[17:38:07.370]                   }
[17:38:07.370]                   options(future.plan = NULL)
[17:38:07.370]                   if (is.na(NA_character_)) 
[17:38:07.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.370]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.370]                     .init = FALSE)
[17:38:07.370]                 }
[17:38:07.370]             }
[17:38:07.370]         }
[17:38:07.370]     })
[17:38:07.370]     if (TRUE) {
[17:38:07.370]         base::sink(type = "output", split = FALSE)
[17:38:07.370]         if (TRUE) {
[17:38:07.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.370]         }
[17:38:07.370]         else {
[17:38:07.370]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.370]         }
[17:38:07.370]         base::close(...future.stdout)
[17:38:07.370]         ...future.stdout <- NULL
[17:38:07.370]     }
[17:38:07.370]     ...future.result$conditions <- ...future.conditions
[17:38:07.370]     ...future.result$finished <- base::Sys.time()
[17:38:07.370]     ...future.result
[17:38:07.370] }
[17:38:07.372] assign_globals() ...
[17:38:07.372] List of 11
[17:38:07.372]  $ ...future.FUN            :function (x, ...)  
[17:38:07.372]  $ x_FUN                    :function (x)  
[17:38:07.372]  $ times                    : int 1
[17:38:07.372]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.372]  $ stop_if_not              :function (...)  
[17:38:07.372]  $ dim                      : NULL
[17:38:07.372]  $ valid_types              : chr "character"
[17:38:07.372]  $ future.call.arguments    : list()
[17:38:07.372]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.372]  $ ...future.elements_ii    :List of 1
[17:38:07.372]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:38:07.372]  $ ...future.seeds_ii       : NULL
[17:38:07.372]  $ ...future.globals.maxSize: NULL
[17:38:07.372]  - attr(*, "where")=List of 11
[17:38:07.372]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.372]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.372]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.372]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.372]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.372]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.372]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.372]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.372]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.372]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.372]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.372]  - attr(*, "resolved")= logi FALSE
[17:38:07.372]  - attr(*, "total_size")= num 94208
[17:38:07.372]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.372]  - attr(*, "already-done")= logi TRUE
[17:38:07.381] - copied ‘...future.FUN’ to environment
[17:38:07.381] - copied ‘x_FUN’ to environment
[17:38:07.381] - copied ‘times’ to environment
[17:38:07.382] - copied ‘stopf’ to environment
[17:38:07.382] - copied ‘stop_if_not’ to environment
[17:38:07.382] - copied ‘dim’ to environment
[17:38:07.382] - copied ‘valid_types’ to environment
[17:38:07.382] - copied ‘future.call.arguments’ to environment
[17:38:07.382] - copied ‘...future.elements_ii’ to environment
[17:38:07.382] - copied ‘...future.seeds_ii’ to environment
[17:38:07.382] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.382] assign_globals() ... done
[17:38:07.383] requestCore(): workers = 2
[17:38:07.386] MulticoreFuture started
[17:38:07.386] - Launch lazy future ... done
[17:38:07.386] run() for ‘MulticoreFuture’ ... done
[17:38:07.387] Created future:
[17:38:07.387] plan(): Setting new future strategy stack:
[17:38:07.387] List of future strategies:
[17:38:07.387] 1. sequential:
[17:38:07.387]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.387]    - tweaked: FALSE
[17:38:07.387]    - call: NULL
[17:38:07.388] plan(): nbrOfWorkers() = 1
[17:38:07.390] plan(): Setting new future strategy stack:
[17:38:07.390] List of future strategies:
[17:38:07.390] 1. multicore:
[17:38:07.390]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:07.390]    - tweaked: FALSE
[17:38:07.390]    - call: plan(strategy)
[17:38:07.395] plan(): nbrOfWorkers() = 2
[17:38:07.387] MulticoreFuture:
[17:38:07.387] Label: ‘future_vapply-1’
[17:38:07.387] Expression:
[17:38:07.387] {
[17:38:07.387]     do.call(function(...) {
[17:38:07.387]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.387]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.387]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.387]             on.exit(options(oopts), add = TRUE)
[17:38:07.387]         }
[17:38:07.387]         {
[17:38:07.387]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.387]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.387]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.387]             })
[17:38:07.387]         }
[17:38:07.387]     }, args = future.call.arguments)
[17:38:07.387] }
[17:38:07.387] Lazy evaluation: FALSE
[17:38:07.387] Asynchronous evaluation: TRUE
[17:38:07.387] Local evaluation: TRUE
[17:38:07.387] Environment: R_GlobalEnv
[17:38:07.387] Capture standard output: TRUE
[17:38:07.387] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.387] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.387] Packages: 1 packages (‘future.apply’)
[17:38:07.387] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.387] Resolved: TRUE
[17:38:07.387] Value: <not collected>
[17:38:07.387] Conditions captured: <none>
[17:38:07.387] Early signaling: FALSE
[17:38:07.387] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.387] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.397] Chunk #1 of 2 ... DONE
[17:38:07.397] Chunk #2 of 2 ...
[17:38:07.397]  - Finding globals in 'X' for chunk #2 ...
[17:38:07.397] getGlobalsAndPackages() ...
[17:38:07.397] Searching for globals...
[17:38:07.398] 
[17:38:07.398] Searching for globals ... DONE
[17:38:07.398] - globals: [0] <none>
[17:38:07.398] getGlobalsAndPackages() ... DONE
[17:38:07.398]    + additional globals found: [n=0] 
[17:38:07.398]    + additional namespaces needed: [n=0] 
[17:38:07.399]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:07.399]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:07.399]  - seeds: <none>
[17:38:07.399]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.399] getGlobalsAndPackages() ...
[17:38:07.399] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.400] Resolving globals: FALSE
[17:38:07.400] Tweak future expression to call with '...' arguments ...
[17:38:07.400] {
[17:38:07.400]     do.call(function(...) {
[17:38:07.400]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.400]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.400]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.400]             on.exit(options(oopts), add = TRUE)
[17:38:07.400]         }
[17:38:07.400]         {
[17:38:07.400]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.400]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.400]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.400]             })
[17:38:07.400]         }
[17:38:07.400]     }, args = future.call.arguments)
[17:38:07.400] }
[17:38:07.400] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.401] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.401] - packages: [1] ‘future.apply’
[17:38:07.402] getGlobalsAndPackages() ... DONE
[17:38:07.402] run() for ‘Future’ ...
[17:38:07.402] - state: ‘created’
[17:38:07.402] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:07.408] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.408] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:07.408]   - Field: ‘label’
[17:38:07.408]   - Field: ‘local’
[17:38:07.408]   - Field: ‘owner’
[17:38:07.409]   - Field: ‘envir’
[17:38:07.409]   - Field: ‘workers’
[17:38:07.409]   - Field: ‘packages’
[17:38:07.409]   - Field: ‘gc’
[17:38:07.409]   - Field: ‘job’
[17:38:07.409]   - Field: ‘conditions’
[17:38:07.410]   - Field: ‘expr’
[17:38:07.410]   - Field: ‘uuid’
[17:38:07.410]   - Field: ‘seed’
[17:38:07.410]   - Field: ‘version’
[17:38:07.410]   - Field: ‘result’
[17:38:07.410]   - Field: ‘asynchronous’
[17:38:07.410]   - Field: ‘calls’
[17:38:07.411]   - Field: ‘globals’
[17:38:07.411]   - Field: ‘stdout’
[17:38:07.411]   - Field: ‘earlySignal’
[17:38:07.411]   - Field: ‘lazy’
[17:38:07.411]   - Field: ‘state’
[17:38:07.411] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:07.411] - Launch lazy future ...
[17:38:07.412] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:07.412] Packages needed by future strategies (n = 0): <none>
[17:38:07.413] {
[17:38:07.413]     {
[17:38:07.413]         {
[17:38:07.413]             ...future.startTime <- base::Sys.time()
[17:38:07.413]             {
[17:38:07.413]                 {
[17:38:07.413]                   {
[17:38:07.413]                     {
[17:38:07.413]                       {
[17:38:07.413]                         base::local({
[17:38:07.413]                           has_future <- base::requireNamespace("future", 
[17:38:07.413]                             quietly = TRUE)
[17:38:07.413]                           if (has_future) {
[17:38:07.413]                             ns <- base::getNamespace("future")
[17:38:07.413]                             version <- ns[[".package"]][["version"]]
[17:38:07.413]                             if (is.null(version)) 
[17:38:07.413]                               version <- utils::packageVersion("future")
[17:38:07.413]                           }
[17:38:07.413]                           else {
[17:38:07.413]                             version <- NULL
[17:38:07.413]                           }
[17:38:07.413]                           if (!has_future || version < "1.8.0") {
[17:38:07.413]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.413]                               "", base::R.version$version.string), 
[17:38:07.413]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:07.413]                                 base::R.version$platform, 8 * 
[17:38:07.413]                                   base::.Machine$sizeof.pointer), 
[17:38:07.413]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.413]                                 "release", "version")], collapse = " "), 
[17:38:07.413]                               hostname = base::Sys.info()[["nodename"]])
[17:38:07.413]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.413]                               info)
[17:38:07.413]                             info <- base::paste(info, collapse = "; ")
[17:38:07.413]                             if (!has_future) {
[17:38:07.413]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.413]                                 info)
[17:38:07.413]                             }
[17:38:07.413]                             else {
[17:38:07.413]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.413]                                 info, version)
[17:38:07.413]                             }
[17:38:07.413]                             base::stop(msg)
[17:38:07.413]                           }
[17:38:07.413]                         })
[17:38:07.413]                       }
[17:38:07.413]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:07.413]                       base::options(mc.cores = 1L)
[17:38:07.413]                     }
[17:38:07.413]                     base::local({
[17:38:07.413]                       for (pkg in "future.apply") {
[17:38:07.413]                         base::loadNamespace(pkg)
[17:38:07.413]                         base::library(pkg, character.only = TRUE)
[17:38:07.413]                       }
[17:38:07.413]                     })
[17:38:07.413]                   }
[17:38:07.413]                   ...future.strategy.old <- future::plan("list")
[17:38:07.413]                   options(future.plan = NULL)
[17:38:07.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.413]                 }
[17:38:07.413]                 ...future.workdir <- getwd()
[17:38:07.413]             }
[17:38:07.413]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.413]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.413]         }
[17:38:07.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.413]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:07.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.413]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.413]             base::names(...future.oldOptions))
[17:38:07.413]     }
[17:38:07.413]     if (FALSE) {
[17:38:07.413]     }
[17:38:07.413]     else {
[17:38:07.413]         if (TRUE) {
[17:38:07.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.413]                 open = "w")
[17:38:07.413]         }
[17:38:07.413]         else {
[17:38:07.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.413]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.413]         }
[17:38:07.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.413]             base::sink(type = "output", split = FALSE)
[17:38:07.413]             base::close(...future.stdout)
[17:38:07.413]         }, add = TRUE)
[17:38:07.413]     }
[17:38:07.413]     ...future.frame <- base::sys.nframe()
[17:38:07.413]     ...future.conditions <- base::list()
[17:38:07.413]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.413]     if (FALSE) {
[17:38:07.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.413]     }
[17:38:07.413]     ...future.result <- base::tryCatch({
[17:38:07.413]         base::withCallingHandlers({
[17:38:07.413]             ...future.value <- base::withVisible(base::local({
[17:38:07.413]                 withCallingHandlers({
[17:38:07.413]                   {
[17:38:07.413]                     do.call(function(...) {
[17:38:07.413]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.413]                       if (!identical(...future.globals.maxSize.org, 
[17:38:07.413]                         ...future.globals.maxSize)) {
[17:38:07.413]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.413]                         on.exit(options(oopts), add = TRUE)
[17:38:07.413]                       }
[17:38:07.413]                       {
[17:38:07.413]                         lapply(seq_along(...future.elements_ii), 
[17:38:07.413]                           FUN = function(jj) {
[17:38:07.413]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.413]                             ...future.FUN(...future.X_jj, ...)
[17:38:07.413]                           })
[17:38:07.413]                       }
[17:38:07.413]                     }, args = future.call.arguments)
[17:38:07.413]                   }
[17:38:07.413]                 }, immediateCondition = function(cond) {
[17:38:07.413]                   save_rds <- function (object, pathname, ...) 
[17:38:07.413]                   {
[17:38:07.413]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:07.413]                     if (file_test("-f", pathname_tmp)) {
[17:38:07.413]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.413]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:07.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.413]                         fi_tmp[["mtime"]])
[17:38:07.413]                     }
[17:38:07.413]                     tryCatch({
[17:38:07.413]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:07.413]                     }, error = function(ex) {
[17:38:07.413]                       msg <- conditionMessage(ex)
[17:38:07.413]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.413]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:07.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.413]                         fi_tmp[["mtime"]], msg)
[17:38:07.413]                       ex$message <- msg
[17:38:07.413]                       stop(ex)
[17:38:07.413]                     })
[17:38:07.413]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:07.413]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:07.413]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:07.413]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.413]                       fi <- file.info(pathname)
[17:38:07.413]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:07.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.413]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:07.413]                         fi[["size"]], fi[["mtime"]])
[17:38:07.413]                       stop(msg)
[17:38:07.413]                     }
[17:38:07.413]                     invisible(pathname)
[17:38:07.413]                   }
[17:38:07.413]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:07.413]                     rootPath = tempdir()) 
[17:38:07.413]                   {
[17:38:07.413]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:07.413]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:07.413]                       tmpdir = path, fileext = ".rds")
[17:38:07.413]                     save_rds(obj, file)
[17:38:07.413]                   }
[17:38:07.413]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:07.413]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.413]                   {
[17:38:07.413]                     inherits <- base::inherits
[17:38:07.413]                     invokeRestart <- base::invokeRestart
[17:38:07.413]                     is.null <- base::is.null
[17:38:07.413]                     muffled <- FALSE
[17:38:07.413]                     if (inherits(cond, "message")) {
[17:38:07.413]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:07.413]                       if (muffled) 
[17:38:07.413]                         invokeRestart("muffleMessage")
[17:38:07.413]                     }
[17:38:07.413]                     else if (inherits(cond, "warning")) {
[17:38:07.413]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:07.413]                       if (muffled) 
[17:38:07.413]                         invokeRestart("muffleWarning")
[17:38:07.413]                     }
[17:38:07.413]                     else if (inherits(cond, "condition")) {
[17:38:07.413]                       if (!is.null(pattern)) {
[17:38:07.413]                         computeRestarts <- base::computeRestarts
[17:38:07.413]                         grepl <- base::grepl
[17:38:07.413]                         restarts <- computeRestarts(cond)
[17:38:07.413]                         for (restart in restarts) {
[17:38:07.413]                           name <- restart$name
[17:38:07.413]                           if (is.null(name)) 
[17:38:07.413]                             next
[17:38:07.413]                           if (!grepl(pattern, name)) 
[17:38:07.413]                             next
[17:38:07.413]                           invokeRestart(restart)
[17:38:07.413]                           muffled <- TRUE
[17:38:07.413]                           break
[17:38:07.413]                         }
[17:38:07.413]                       }
[17:38:07.413]                     }
[17:38:07.413]                     invisible(muffled)
[17:38:07.413]                   }
[17:38:07.413]                   muffleCondition(cond)
[17:38:07.413]                 })
[17:38:07.413]             }))
[17:38:07.413]             future::FutureResult(value = ...future.value$value, 
[17:38:07.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.413]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.413]                     ...future.globalenv.names))
[17:38:07.413]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.413]         }, condition = base::local({
[17:38:07.413]             c <- base::c
[17:38:07.413]             inherits <- base::inherits
[17:38:07.413]             invokeRestart <- base::invokeRestart
[17:38:07.413]             length <- base::length
[17:38:07.413]             list <- base::list
[17:38:07.413]             seq.int <- base::seq.int
[17:38:07.413]             signalCondition <- base::signalCondition
[17:38:07.413]             sys.calls <- base::sys.calls
[17:38:07.413]             `[[` <- base::`[[`
[17:38:07.413]             `+` <- base::`+`
[17:38:07.413]             `<<-` <- base::`<<-`
[17:38:07.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.413]                   3L)]
[17:38:07.413]             }
[17:38:07.413]             function(cond) {
[17:38:07.413]                 is_error <- inherits(cond, "error")
[17:38:07.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.413]                   NULL)
[17:38:07.413]                 if (is_error) {
[17:38:07.413]                   sessionInformation <- function() {
[17:38:07.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.413]                       search = base::search(), system = base::Sys.info())
[17:38:07.413]                   }
[17:38:07.413]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.413]                     cond$call), session = sessionInformation(), 
[17:38:07.413]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.413]                   signalCondition(cond)
[17:38:07.413]                 }
[17:38:07.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.413]                 "immediateCondition"))) {
[17:38:07.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.413]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.413]                   if (TRUE && !signal) {
[17:38:07.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.413]                     {
[17:38:07.413]                       inherits <- base::inherits
[17:38:07.413]                       invokeRestart <- base::invokeRestart
[17:38:07.413]                       is.null <- base::is.null
[17:38:07.413]                       muffled <- FALSE
[17:38:07.413]                       if (inherits(cond, "message")) {
[17:38:07.413]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.413]                         if (muffled) 
[17:38:07.413]                           invokeRestart("muffleMessage")
[17:38:07.413]                       }
[17:38:07.413]                       else if (inherits(cond, "warning")) {
[17:38:07.413]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.413]                         if (muffled) 
[17:38:07.413]                           invokeRestart("muffleWarning")
[17:38:07.413]                       }
[17:38:07.413]                       else if (inherits(cond, "condition")) {
[17:38:07.413]                         if (!is.null(pattern)) {
[17:38:07.413]                           computeRestarts <- base::computeRestarts
[17:38:07.413]                           grepl <- base::grepl
[17:38:07.413]                           restarts <- computeRestarts(cond)
[17:38:07.413]                           for (restart in restarts) {
[17:38:07.413]                             name <- restart$name
[17:38:07.413]                             if (is.null(name)) 
[17:38:07.413]                               next
[17:38:07.413]                             if (!grepl(pattern, name)) 
[17:38:07.413]                               next
[17:38:07.413]                             invokeRestart(restart)
[17:38:07.413]                             muffled <- TRUE
[17:38:07.413]                             break
[17:38:07.413]                           }
[17:38:07.413]                         }
[17:38:07.413]                       }
[17:38:07.413]                       invisible(muffled)
[17:38:07.413]                     }
[17:38:07.413]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.413]                   }
[17:38:07.413]                 }
[17:38:07.413]                 else {
[17:38:07.413]                   if (TRUE) {
[17:38:07.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.413]                     {
[17:38:07.413]                       inherits <- base::inherits
[17:38:07.413]                       invokeRestart <- base::invokeRestart
[17:38:07.413]                       is.null <- base::is.null
[17:38:07.413]                       muffled <- FALSE
[17:38:07.413]                       if (inherits(cond, "message")) {
[17:38:07.413]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.413]                         if (muffled) 
[17:38:07.413]                           invokeRestart("muffleMessage")
[17:38:07.413]                       }
[17:38:07.413]                       else if (inherits(cond, "warning")) {
[17:38:07.413]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.413]                         if (muffled) 
[17:38:07.413]                           invokeRestart("muffleWarning")
[17:38:07.413]                       }
[17:38:07.413]                       else if (inherits(cond, "condition")) {
[17:38:07.413]                         if (!is.null(pattern)) {
[17:38:07.413]                           computeRestarts <- base::computeRestarts
[17:38:07.413]                           grepl <- base::grepl
[17:38:07.413]                           restarts <- computeRestarts(cond)
[17:38:07.413]                           for (restart in restarts) {
[17:38:07.413]                             name <- restart$name
[17:38:07.413]                             if (is.null(name)) 
[17:38:07.413]                               next
[17:38:07.413]                             if (!grepl(pattern, name)) 
[17:38:07.413]                               next
[17:38:07.413]                             invokeRestart(restart)
[17:38:07.413]                             muffled <- TRUE
[17:38:07.413]                             break
[17:38:07.413]                           }
[17:38:07.413]                         }
[17:38:07.413]                       }
[17:38:07.413]                       invisible(muffled)
[17:38:07.413]                     }
[17:38:07.413]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.413]                   }
[17:38:07.413]                 }
[17:38:07.413]             }
[17:38:07.413]         }))
[17:38:07.413]     }, error = function(ex) {
[17:38:07.413]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.413]                 ...future.rng), started = ...future.startTime, 
[17:38:07.413]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.413]             version = "1.8"), class = "FutureResult")
[17:38:07.413]     }, finally = {
[17:38:07.413]         if (!identical(...future.workdir, getwd())) 
[17:38:07.413]             setwd(...future.workdir)
[17:38:07.413]         {
[17:38:07.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.413]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.413]             }
[17:38:07.413]             base::options(...future.oldOptions)
[17:38:07.413]             if (.Platform$OS.type == "windows") {
[17:38:07.413]                 old_names <- names(...future.oldEnvVars)
[17:38:07.413]                 envs <- base::Sys.getenv()
[17:38:07.413]                 names <- names(envs)
[17:38:07.413]                 common <- intersect(names, old_names)
[17:38:07.413]                 added <- setdiff(names, old_names)
[17:38:07.413]                 removed <- setdiff(old_names, names)
[17:38:07.413]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.413]                   envs[common]]
[17:38:07.413]                 NAMES <- toupper(changed)
[17:38:07.413]                 args <- list()
[17:38:07.413]                 for (kk in seq_along(NAMES)) {
[17:38:07.413]                   name <- changed[[kk]]
[17:38:07.413]                   NAME <- NAMES[[kk]]
[17:38:07.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.413]                     next
[17:38:07.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.413]                 }
[17:38:07.413]                 NAMES <- toupper(added)
[17:38:07.413]                 for (kk in seq_along(NAMES)) {
[17:38:07.413]                   name <- added[[kk]]
[17:38:07.413]                   NAME <- NAMES[[kk]]
[17:38:07.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.413]                     next
[17:38:07.413]                   args[[name]] <- ""
[17:38:07.413]                 }
[17:38:07.413]                 NAMES <- toupper(removed)
[17:38:07.413]                 for (kk in seq_along(NAMES)) {
[17:38:07.413]                   name <- removed[[kk]]
[17:38:07.413]                   NAME <- NAMES[[kk]]
[17:38:07.413]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.413]                     next
[17:38:07.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.413]                 }
[17:38:07.413]                 if (length(args) > 0) 
[17:38:07.413]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.413]             }
[17:38:07.413]             else {
[17:38:07.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.413]             }
[17:38:07.413]             {
[17:38:07.413]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.413]                   0L) {
[17:38:07.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.413]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.413]                   base::options(opts)
[17:38:07.413]                 }
[17:38:07.413]                 {
[17:38:07.413]                   {
[17:38:07.413]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:07.413]                     NULL
[17:38:07.413]                   }
[17:38:07.413]                   options(future.plan = NULL)
[17:38:07.413]                   if (is.na(NA_character_)) 
[17:38:07.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.413]                     .init = FALSE)
[17:38:07.413]                 }
[17:38:07.413]             }
[17:38:07.413]         }
[17:38:07.413]     })
[17:38:07.413]     if (TRUE) {
[17:38:07.413]         base::sink(type = "output", split = FALSE)
[17:38:07.413]         if (TRUE) {
[17:38:07.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.413]         }
[17:38:07.413]         else {
[17:38:07.413]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.413]         }
[17:38:07.413]         base::close(...future.stdout)
[17:38:07.413]         ...future.stdout <- NULL
[17:38:07.413]     }
[17:38:07.413]     ...future.result$conditions <- ...future.conditions
[17:38:07.413]     ...future.result$finished <- base::Sys.time()
[17:38:07.413]     ...future.result
[17:38:07.413] }
[17:38:07.416] assign_globals() ...
[17:38:07.416] List of 11
[17:38:07.416]  $ ...future.FUN            :function (x, ...)  
[17:38:07.416]  $ x_FUN                    :function (x)  
[17:38:07.416]  $ times                    : int 1
[17:38:07.416]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.416]  $ stop_if_not              :function (...)  
[17:38:07.416]  $ dim                      : NULL
[17:38:07.416]  $ valid_types              : chr "character"
[17:38:07.416]  $ future.call.arguments    : list()
[17:38:07.416]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.416]  $ ...future.elements_ii    :List of 1
[17:38:07.416]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[17:38:07.416]  $ ...future.seeds_ii       : NULL
[17:38:07.416]  $ ...future.globals.maxSize: NULL
[17:38:07.416]  - attr(*, "where")=List of 11
[17:38:07.416]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.416]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.416]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.416]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.416]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.416]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.416]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.416]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.416]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.416]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.416]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.416]  - attr(*, "resolved")= logi FALSE
[17:38:07.416]  - attr(*, "total_size")= num 94208
[17:38:07.416]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.416]  - attr(*, "already-done")= logi TRUE
[17:38:07.431] - copied ‘...future.FUN’ to environment
[17:38:07.432] - copied ‘x_FUN’ to environment
[17:38:07.432] - copied ‘times’ to environment
[17:38:07.432] - copied ‘stopf’ to environment
[17:38:07.432] - copied ‘stop_if_not’ to environment
[17:38:07.432] - copied ‘dim’ to environment
[17:38:07.432] - copied ‘valid_types’ to environment
[17:38:07.432] - copied ‘future.call.arguments’ to environment
[17:38:07.433] - copied ‘...future.elements_ii’ to environment
[17:38:07.433] - copied ‘...future.seeds_ii’ to environment
[17:38:07.433] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.433] assign_globals() ... done
[17:38:07.433] requestCore(): workers = 2
[17:38:07.438] MulticoreFuture started
[17:38:07.439] - Launch lazy future ... done
[17:38:07.439] run() for ‘MulticoreFuture’ ... done
[17:38:07.439] Created future:
[17:38:07.439] plan(): Setting new future strategy stack:
[17:38:07.440] List of future strategies:
[17:38:07.440] 1. sequential:
[17:38:07.440]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.440]    - tweaked: FALSE
[17:38:07.440]    - call: NULL
[17:38:07.441] plan(): nbrOfWorkers() = 1
[17:38:07.443] plan(): Setting new future strategy stack:
[17:38:07.443] List of future strategies:
[17:38:07.443] 1. multicore:
[17:38:07.443]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:07.443]    - tweaked: FALSE
[17:38:07.443]    - call: plan(strategy)
[17:38:07.448] plan(): nbrOfWorkers() = 2
[17:38:07.439] MulticoreFuture:
[17:38:07.439] Label: ‘future_vapply-2’
[17:38:07.439] Expression:
[17:38:07.439] {
[17:38:07.439]     do.call(function(...) {
[17:38:07.439]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.439]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.439]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.439]             on.exit(options(oopts), add = TRUE)
[17:38:07.439]         }
[17:38:07.439]         {
[17:38:07.439]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.439]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.439]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.439]             })
[17:38:07.439]         }
[17:38:07.439]     }, args = future.call.arguments)
[17:38:07.439] }
[17:38:07.439] Lazy evaluation: FALSE
[17:38:07.439] Asynchronous evaluation: TRUE
[17:38:07.439] Local evaluation: TRUE
[17:38:07.439] Environment: R_GlobalEnv
[17:38:07.439] Capture standard output: TRUE
[17:38:07.439] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.439] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.439] Packages: 1 packages (‘future.apply’)
[17:38:07.439] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.439] Resolved: TRUE
[17:38:07.439] Value: <not collected>
[17:38:07.439] Conditions captured: <none>
[17:38:07.439] Early signaling: FALSE
[17:38:07.439] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.439] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.449] Chunk #2 of 2 ... DONE
[17:38:07.449] Launching 2 futures (chunks) ... DONE
[17:38:07.449] Resolving 2 futures (chunks) ...
[17:38:07.450] resolve() on list ...
[17:38:07.450]  recursive: 0
[17:38:07.450]  length: 2
[17:38:07.450] 
[17:38:07.450] Future #1
[17:38:07.451] result() for MulticoreFuture ...
[17:38:07.453] result() for MulticoreFuture ...
[17:38:07.453] result() for MulticoreFuture ... done
[17:38:07.453] result() for MulticoreFuture ... done
[17:38:07.453] result() for MulticoreFuture ...
[17:38:07.453] result() for MulticoreFuture ... done
[17:38:07.454] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:07.454] - nx: 2
[17:38:07.454] - relay: TRUE
[17:38:07.454] - stdout: TRUE
[17:38:07.454] - signal: TRUE
[17:38:07.454] - resignal: FALSE
[17:38:07.454] - force: TRUE
[17:38:07.455] - relayed: [n=2] FALSE, FALSE
[17:38:07.455] - queued futures: [n=2] FALSE, FALSE
[17:38:07.455]  - until=1
[17:38:07.455]  - relaying element #1
[17:38:07.455] result() for MulticoreFuture ...
[17:38:07.455] result() for MulticoreFuture ... done
[17:38:07.455] result() for MulticoreFuture ...
[17:38:07.456] result() for MulticoreFuture ... done
[17:38:07.456] result() for MulticoreFuture ...
[17:38:07.456] result() for MulticoreFuture ... done
[17:38:07.456] result() for MulticoreFuture ...
[17:38:07.456] result() for MulticoreFuture ... done
[17:38:07.456] - relayed: [n=2] TRUE, FALSE
[17:38:07.457] - queued futures: [n=2] TRUE, FALSE
[17:38:07.457] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:07.457]  length: 1 (resolved future 1)
[17:38:07.457] Future #2
[17:38:07.457] result() for MulticoreFuture ...
[17:38:07.458] result() for MulticoreFuture ...
[17:38:07.458] result() for MulticoreFuture ... done
[17:38:07.458] result() for MulticoreFuture ... done
[17:38:07.458] result() for MulticoreFuture ...
[17:38:07.459] result() for MulticoreFuture ... done
[17:38:07.459] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:07.459] - nx: 2
[17:38:07.459] - relay: TRUE
[17:38:07.459] - stdout: TRUE
[17:38:07.459] - signal: TRUE
[17:38:07.459] - resignal: FALSE
[17:38:07.460] - force: TRUE
[17:38:07.460] - relayed: [n=2] TRUE, FALSE
[17:38:07.460] - queued futures: [n=2] TRUE, FALSE
[17:38:07.460]  - until=2
[17:38:07.460]  - relaying element #2
[17:38:07.460] result() for MulticoreFuture ...
[17:38:07.460] result() for MulticoreFuture ... done
[17:38:07.460] result() for MulticoreFuture ...
[17:38:07.461] result() for MulticoreFuture ... done
[17:38:07.461] result() for MulticoreFuture ...
[17:38:07.461] result() for MulticoreFuture ... done
[17:38:07.461] result() for MulticoreFuture ...
[17:38:07.461] result() for MulticoreFuture ... done
[17:38:07.461] - relayed: [n=2] TRUE, TRUE
[17:38:07.461] - queued futures: [n=2] TRUE, TRUE
[17:38:07.461] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:07.462]  length: 0 (resolved future 2)
[17:38:07.462] Relaying remaining futures
[17:38:07.462] signalConditionsASAP(NULL, pos=0) ...
[17:38:07.462] - nx: 2
[17:38:07.462] - relay: TRUE
[17:38:07.462] - stdout: TRUE
[17:38:07.462] - signal: TRUE
[17:38:07.462] - resignal: FALSE
[17:38:07.462] - force: TRUE
[17:38:07.462] - relayed: [n=2] TRUE, TRUE
[17:38:07.463] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:07.463] - relayed: [n=2] TRUE, TRUE
[17:38:07.463] - queued futures: [n=2] TRUE, TRUE
[17:38:07.463] signalConditionsASAP(NULL, pos=0) ... done
[17:38:07.463] resolve() on list ... DONE
[17:38:07.463] result() for MulticoreFuture ...
[17:38:07.463] result() for MulticoreFuture ... done
[17:38:07.463] result() for MulticoreFuture ...
[17:38:07.463] result() for MulticoreFuture ... done
[17:38:07.464] result() for MulticoreFuture ...
[17:38:07.464] result() for MulticoreFuture ... done
[17:38:07.464] result() for MulticoreFuture ...
[17:38:07.464] result() for MulticoreFuture ... done
[17:38:07.464]  - Number of value chunks collected: 2
[17:38:07.464] Resolving 2 futures (chunks) ... DONE
[17:38:07.464] Reducing values from 2 chunks ...
[17:38:07.464]  - Number of values collected after concatenation: 2
[17:38:07.465]  - Number of values expected: 2
[17:38:07.465] Reducing values from 2 chunks ... DONE
[17:38:07.465] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[17:38:07.472] future_lapply() ...
[17:38:07.478] Number of chunks: 2
[17:38:07.478] getGlobalsAndPackagesXApply() ...
[17:38:07.478]  - future.globals: TRUE
[17:38:07.479] getGlobalsAndPackages() ...
[17:38:07.479] Searching for globals...
[17:38:07.483] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[17:38:07.483] Searching for globals ... DONE
[17:38:07.483] Resolving globals: FALSE
[17:38:07.484] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[17:38:07.484] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:07.485] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.485] - packages: [1] ‘future.apply’
[17:38:07.485] getGlobalsAndPackages() ... DONE
[17:38:07.485]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.485]  - needed namespaces: [n=1] ‘future.apply’
[17:38:07.485] Finding globals ... DONE
[17:38:07.485]  - use_args: TRUE
[17:38:07.485]  - Getting '...' globals ...
[17:38:07.486] resolve() on list ...
[17:38:07.486]  recursive: 0
[17:38:07.486]  length: 1
[17:38:07.486]  elements: ‘...’
[17:38:07.486]  length: 0 (resolved future 1)
[17:38:07.486] resolve() on list ... DONE
[17:38:07.486]    - '...' content: [n=0] 
[17:38:07.486] List of 1
[17:38:07.486]  $ ...: list()
[17:38:07.486]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.486]  - attr(*, "where")=List of 1
[17:38:07.486]   ..$ ...:<environment: 0x560801cd77a8> 
[17:38:07.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.486]  - attr(*, "resolved")= logi TRUE
[17:38:07.486]  - attr(*, "total_size")= num NA
[17:38:07.489]  - Getting '...' globals ... DONE
[17:38:07.489] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:07.489] List of 8
[17:38:07.489]  $ ...future.FUN:function (x, ...)  
[17:38:07.489]  $ x_FUN        :function (x)  
[17:38:07.489]  $ times        : int 0
[17:38:07.489]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.489]  $ stop_if_not  :function (...)  
[17:38:07.489]  $ dim          : NULL
[17:38:07.489]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:07.489]  $ ...          : list()
[17:38:07.489]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.489]  - attr(*, "where")=List of 8
[17:38:07.489]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:07.489]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:07.489]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:07.489]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:07.489]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:07.489]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:07.489]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:07.489]   ..$ ...          :<environment: 0x560801cd77a8> 
[17:38:07.489]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.489]  - attr(*, "resolved")= logi FALSE
[17:38:07.489]  - attr(*, "total_size")= num 95472
[17:38:07.495] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:07.495] getGlobalsAndPackagesXApply() ... DONE
[17:38:07.495] Number of futures (= number of chunks): 2
[17:38:07.495] Launching 2 futures (chunks) ...
[17:38:07.495] Chunk #1 of 2 ...
[17:38:07.495]  - Finding globals in 'X' for chunk #1 ...
[17:38:07.495] getGlobalsAndPackages() ...
[17:38:07.495] Searching for globals...
[17:38:07.496] 
[17:38:07.496] Searching for globals ... DONE
[17:38:07.496] - globals: [0] <none>
[17:38:07.496] getGlobalsAndPackages() ... DONE
[17:38:07.496]    + additional globals found: [n=0] 
[17:38:07.496]    + additional namespaces needed: [n=0] 
[17:38:07.496]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:07.496]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:07.498]  - seeds: <none>
[17:38:07.498]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.498] getGlobalsAndPackages() ...
[17:38:07.499] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.499] Resolving globals: FALSE
[17:38:07.499] Tweak future expression to call with '...' arguments ...
[17:38:07.499] {
[17:38:07.499]     do.call(function(...) {
[17:38:07.499]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.499]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.499]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.499]             on.exit(options(oopts), add = TRUE)
[17:38:07.499]         }
[17:38:07.499]         {
[17:38:07.499]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.499]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.499]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.499]             })
[17:38:07.499]         }
[17:38:07.499]     }, args = future.call.arguments)
[17:38:07.499] }
[17:38:07.499] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.500] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.500] - packages: [1] ‘future.apply’
[17:38:07.500] getGlobalsAndPackages() ... DONE
[17:38:07.500] run() for ‘Future’ ...
[17:38:07.500] - state: ‘created’
[17:38:07.501] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:07.504] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.505] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:07.505]   - Field: ‘label’
[17:38:07.505]   - Field: ‘local’
[17:38:07.505]   - Field: ‘owner’
[17:38:07.505]   - Field: ‘envir’
[17:38:07.505]   - Field: ‘workers’
[17:38:07.505]   - Field: ‘packages’
[17:38:07.505]   - Field: ‘gc’
[17:38:07.505]   - Field: ‘job’
[17:38:07.506]   - Field: ‘conditions’
[17:38:07.506]   - Field: ‘expr’
[17:38:07.506]   - Field: ‘uuid’
[17:38:07.506]   - Field: ‘seed’
[17:38:07.506]   - Field: ‘version’
[17:38:07.506]   - Field: ‘result’
[17:38:07.506]   - Field: ‘asynchronous’
[17:38:07.506]   - Field: ‘calls’
[17:38:07.506]   - Field: ‘globals’
[17:38:07.506]   - Field: ‘stdout’
[17:38:07.506]   - Field: ‘earlySignal’
[17:38:07.507]   - Field: ‘lazy’
[17:38:07.507]   - Field: ‘state’
[17:38:07.507] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:07.507] - Launch lazy future ...
[17:38:07.507] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:07.507] Packages needed by future strategies (n = 0): <none>
[17:38:07.508] {
[17:38:07.508]     {
[17:38:07.508]         {
[17:38:07.508]             ...future.startTime <- base::Sys.time()
[17:38:07.508]             {
[17:38:07.508]                 {
[17:38:07.508]                   {
[17:38:07.508]                     {
[17:38:07.508]                       {
[17:38:07.508]                         base::local({
[17:38:07.508]                           has_future <- base::requireNamespace("future", 
[17:38:07.508]                             quietly = TRUE)
[17:38:07.508]                           if (has_future) {
[17:38:07.508]                             ns <- base::getNamespace("future")
[17:38:07.508]                             version <- ns[[".package"]][["version"]]
[17:38:07.508]                             if (is.null(version)) 
[17:38:07.508]                               version <- utils::packageVersion("future")
[17:38:07.508]                           }
[17:38:07.508]                           else {
[17:38:07.508]                             version <- NULL
[17:38:07.508]                           }
[17:38:07.508]                           if (!has_future || version < "1.8.0") {
[17:38:07.508]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.508]                               "", base::R.version$version.string), 
[17:38:07.508]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:07.508]                                 base::R.version$platform, 8 * 
[17:38:07.508]                                   base::.Machine$sizeof.pointer), 
[17:38:07.508]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.508]                                 "release", "version")], collapse = " "), 
[17:38:07.508]                               hostname = base::Sys.info()[["nodename"]])
[17:38:07.508]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.508]                               info)
[17:38:07.508]                             info <- base::paste(info, collapse = "; ")
[17:38:07.508]                             if (!has_future) {
[17:38:07.508]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.508]                                 info)
[17:38:07.508]                             }
[17:38:07.508]                             else {
[17:38:07.508]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.508]                                 info, version)
[17:38:07.508]                             }
[17:38:07.508]                             base::stop(msg)
[17:38:07.508]                           }
[17:38:07.508]                         })
[17:38:07.508]                       }
[17:38:07.508]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:07.508]                       base::options(mc.cores = 1L)
[17:38:07.508]                     }
[17:38:07.508]                     base::local({
[17:38:07.508]                       for (pkg in "future.apply") {
[17:38:07.508]                         base::loadNamespace(pkg)
[17:38:07.508]                         base::library(pkg, character.only = TRUE)
[17:38:07.508]                       }
[17:38:07.508]                     })
[17:38:07.508]                   }
[17:38:07.508]                   ...future.strategy.old <- future::plan("list")
[17:38:07.508]                   options(future.plan = NULL)
[17:38:07.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.508]                 }
[17:38:07.508]                 ...future.workdir <- getwd()
[17:38:07.508]             }
[17:38:07.508]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.508]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.508]         }
[17:38:07.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.508]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:07.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.508]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.508]             base::names(...future.oldOptions))
[17:38:07.508]     }
[17:38:07.508]     if (FALSE) {
[17:38:07.508]     }
[17:38:07.508]     else {
[17:38:07.508]         if (TRUE) {
[17:38:07.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.508]                 open = "w")
[17:38:07.508]         }
[17:38:07.508]         else {
[17:38:07.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.508]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.508]         }
[17:38:07.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.508]             base::sink(type = "output", split = FALSE)
[17:38:07.508]             base::close(...future.stdout)
[17:38:07.508]         }, add = TRUE)
[17:38:07.508]     }
[17:38:07.508]     ...future.frame <- base::sys.nframe()
[17:38:07.508]     ...future.conditions <- base::list()
[17:38:07.508]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.508]     if (FALSE) {
[17:38:07.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.508]     }
[17:38:07.508]     ...future.result <- base::tryCatch({
[17:38:07.508]         base::withCallingHandlers({
[17:38:07.508]             ...future.value <- base::withVisible(base::local({
[17:38:07.508]                 withCallingHandlers({
[17:38:07.508]                   {
[17:38:07.508]                     do.call(function(...) {
[17:38:07.508]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.508]                       if (!identical(...future.globals.maxSize.org, 
[17:38:07.508]                         ...future.globals.maxSize)) {
[17:38:07.508]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.508]                         on.exit(options(oopts), add = TRUE)
[17:38:07.508]                       }
[17:38:07.508]                       {
[17:38:07.508]                         lapply(seq_along(...future.elements_ii), 
[17:38:07.508]                           FUN = function(jj) {
[17:38:07.508]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.508]                             ...future.FUN(...future.X_jj, ...)
[17:38:07.508]                           })
[17:38:07.508]                       }
[17:38:07.508]                     }, args = future.call.arguments)
[17:38:07.508]                   }
[17:38:07.508]                 }, immediateCondition = function(cond) {
[17:38:07.508]                   save_rds <- function (object, pathname, ...) 
[17:38:07.508]                   {
[17:38:07.508]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:07.508]                     if (file_test("-f", pathname_tmp)) {
[17:38:07.508]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.508]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:07.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.508]                         fi_tmp[["mtime"]])
[17:38:07.508]                     }
[17:38:07.508]                     tryCatch({
[17:38:07.508]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:07.508]                     }, error = function(ex) {
[17:38:07.508]                       msg <- conditionMessage(ex)
[17:38:07.508]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.508]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:07.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.508]                         fi_tmp[["mtime"]], msg)
[17:38:07.508]                       ex$message <- msg
[17:38:07.508]                       stop(ex)
[17:38:07.508]                     })
[17:38:07.508]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:07.508]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:07.508]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:07.508]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.508]                       fi <- file.info(pathname)
[17:38:07.508]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:07.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.508]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:07.508]                         fi[["size"]], fi[["mtime"]])
[17:38:07.508]                       stop(msg)
[17:38:07.508]                     }
[17:38:07.508]                     invisible(pathname)
[17:38:07.508]                   }
[17:38:07.508]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:07.508]                     rootPath = tempdir()) 
[17:38:07.508]                   {
[17:38:07.508]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:07.508]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:07.508]                       tmpdir = path, fileext = ".rds")
[17:38:07.508]                     save_rds(obj, file)
[17:38:07.508]                   }
[17:38:07.508]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:07.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.508]                   {
[17:38:07.508]                     inherits <- base::inherits
[17:38:07.508]                     invokeRestart <- base::invokeRestart
[17:38:07.508]                     is.null <- base::is.null
[17:38:07.508]                     muffled <- FALSE
[17:38:07.508]                     if (inherits(cond, "message")) {
[17:38:07.508]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:07.508]                       if (muffled) 
[17:38:07.508]                         invokeRestart("muffleMessage")
[17:38:07.508]                     }
[17:38:07.508]                     else if (inherits(cond, "warning")) {
[17:38:07.508]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:07.508]                       if (muffled) 
[17:38:07.508]                         invokeRestart("muffleWarning")
[17:38:07.508]                     }
[17:38:07.508]                     else if (inherits(cond, "condition")) {
[17:38:07.508]                       if (!is.null(pattern)) {
[17:38:07.508]                         computeRestarts <- base::computeRestarts
[17:38:07.508]                         grepl <- base::grepl
[17:38:07.508]                         restarts <- computeRestarts(cond)
[17:38:07.508]                         for (restart in restarts) {
[17:38:07.508]                           name <- restart$name
[17:38:07.508]                           if (is.null(name)) 
[17:38:07.508]                             next
[17:38:07.508]                           if (!grepl(pattern, name)) 
[17:38:07.508]                             next
[17:38:07.508]                           invokeRestart(restart)
[17:38:07.508]                           muffled <- TRUE
[17:38:07.508]                           break
[17:38:07.508]                         }
[17:38:07.508]                       }
[17:38:07.508]                     }
[17:38:07.508]                     invisible(muffled)
[17:38:07.508]                   }
[17:38:07.508]                   muffleCondition(cond)
[17:38:07.508]                 })
[17:38:07.508]             }))
[17:38:07.508]             future::FutureResult(value = ...future.value$value, 
[17:38:07.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.508]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.508]                     ...future.globalenv.names))
[17:38:07.508]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.508]         }, condition = base::local({
[17:38:07.508]             c <- base::c
[17:38:07.508]             inherits <- base::inherits
[17:38:07.508]             invokeRestart <- base::invokeRestart
[17:38:07.508]             length <- base::length
[17:38:07.508]             list <- base::list
[17:38:07.508]             seq.int <- base::seq.int
[17:38:07.508]             signalCondition <- base::signalCondition
[17:38:07.508]             sys.calls <- base::sys.calls
[17:38:07.508]             `[[` <- base::`[[`
[17:38:07.508]             `+` <- base::`+`
[17:38:07.508]             `<<-` <- base::`<<-`
[17:38:07.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.508]                   3L)]
[17:38:07.508]             }
[17:38:07.508]             function(cond) {
[17:38:07.508]                 is_error <- inherits(cond, "error")
[17:38:07.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.508]                   NULL)
[17:38:07.508]                 if (is_error) {
[17:38:07.508]                   sessionInformation <- function() {
[17:38:07.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.508]                       search = base::search(), system = base::Sys.info())
[17:38:07.508]                   }
[17:38:07.508]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.508]                     cond$call), session = sessionInformation(), 
[17:38:07.508]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.508]                   signalCondition(cond)
[17:38:07.508]                 }
[17:38:07.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.508]                 "immediateCondition"))) {
[17:38:07.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.508]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.508]                   if (TRUE && !signal) {
[17:38:07.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.508]                     {
[17:38:07.508]                       inherits <- base::inherits
[17:38:07.508]                       invokeRestart <- base::invokeRestart
[17:38:07.508]                       is.null <- base::is.null
[17:38:07.508]                       muffled <- FALSE
[17:38:07.508]                       if (inherits(cond, "message")) {
[17:38:07.508]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.508]                         if (muffled) 
[17:38:07.508]                           invokeRestart("muffleMessage")
[17:38:07.508]                       }
[17:38:07.508]                       else if (inherits(cond, "warning")) {
[17:38:07.508]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.508]                         if (muffled) 
[17:38:07.508]                           invokeRestart("muffleWarning")
[17:38:07.508]                       }
[17:38:07.508]                       else if (inherits(cond, "condition")) {
[17:38:07.508]                         if (!is.null(pattern)) {
[17:38:07.508]                           computeRestarts <- base::computeRestarts
[17:38:07.508]                           grepl <- base::grepl
[17:38:07.508]                           restarts <- computeRestarts(cond)
[17:38:07.508]                           for (restart in restarts) {
[17:38:07.508]                             name <- restart$name
[17:38:07.508]                             if (is.null(name)) 
[17:38:07.508]                               next
[17:38:07.508]                             if (!grepl(pattern, name)) 
[17:38:07.508]                               next
[17:38:07.508]                             invokeRestart(restart)
[17:38:07.508]                             muffled <- TRUE
[17:38:07.508]                             break
[17:38:07.508]                           }
[17:38:07.508]                         }
[17:38:07.508]                       }
[17:38:07.508]                       invisible(muffled)
[17:38:07.508]                     }
[17:38:07.508]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.508]                   }
[17:38:07.508]                 }
[17:38:07.508]                 else {
[17:38:07.508]                   if (TRUE) {
[17:38:07.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.508]                     {
[17:38:07.508]                       inherits <- base::inherits
[17:38:07.508]                       invokeRestart <- base::invokeRestart
[17:38:07.508]                       is.null <- base::is.null
[17:38:07.508]                       muffled <- FALSE
[17:38:07.508]                       if (inherits(cond, "message")) {
[17:38:07.508]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.508]                         if (muffled) 
[17:38:07.508]                           invokeRestart("muffleMessage")
[17:38:07.508]                       }
[17:38:07.508]                       else if (inherits(cond, "warning")) {
[17:38:07.508]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.508]                         if (muffled) 
[17:38:07.508]                           invokeRestart("muffleWarning")
[17:38:07.508]                       }
[17:38:07.508]                       else if (inherits(cond, "condition")) {
[17:38:07.508]                         if (!is.null(pattern)) {
[17:38:07.508]                           computeRestarts <- base::computeRestarts
[17:38:07.508]                           grepl <- base::grepl
[17:38:07.508]                           restarts <- computeRestarts(cond)
[17:38:07.508]                           for (restart in restarts) {
[17:38:07.508]                             name <- restart$name
[17:38:07.508]                             if (is.null(name)) 
[17:38:07.508]                               next
[17:38:07.508]                             if (!grepl(pattern, name)) 
[17:38:07.508]                               next
[17:38:07.508]                             invokeRestart(restart)
[17:38:07.508]                             muffled <- TRUE
[17:38:07.508]                             break
[17:38:07.508]                           }
[17:38:07.508]                         }
[17:38:07.508]                       }
[17:38:07.508]                       invisible(muffled)
[17:38:07.508]                     }
[17:38:07.508]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.508]                   }
[17:38:07.508]                 }
[17:38:07.508]             }
[17:38:07.508]         }))
[17:38:07.508]     }, error = function(ex) {
[17:38:07.508]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.508]                 ...future.rng), started = ...future.startTime, 
[17:38:07.508]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.508]             version = "1.8"), class = "FutureResult")
[17:38:07.508]     }, finally = {
[17:38:07.508]         if (!identical(...future.workdir, getwd())) 
[17:38:07.508]             setwd(...future.workdir)
[17:38:07.508]         {
[17:38:07.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.508]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.508]             }
[17:38:07.508]             base::options(...future.oldOptions)
[17:38:07.508]             if (.Platform$OS.type == "windows") {
[17:38:07.508]                 old_names <- names(...future.oldEnvVars)
[17:38:07.508]                 envs <- base::Sys.getenv()
[17:38:07.508]                 names <- names(envs)
[17:38:07.508]                 common <- intersect(names, old_names)
[17:38:07.508]                 added <- setdiff(names, old_names)
[17:38:07.508]                 removed <- setdiff(old_names, names)
[17:38:07.508]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.508]                   envs[common]]
[17:38:07.508]                 NAMES <- toupper(changed)
[17:38:07.508]                 args <- list()
[17:38:07.508]                 for (kk in seq_along(NAMES)) {
[17:38:07.508]                   name <- changed[[kk]]
[17:38:07.508]                   NAME <- NAMES[[kk]]
[17:38:07.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.508]                     next
[17:38:07.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.508]                 }
[17:38:07.508]                 NAMES <- toupper(added)
[17:38:07.508]                 for (kk in seq_along(NAMES)) {
[17:38:07.508]                   name <- added[[kk]]
[17:38:07.508]                   NAME <- NAMES[[kk]]
[17:38:07.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.508]                     next
[17:38:07.508]                   args[[name]] <- ""
[17:38:07.508]                 }
[17:38:07.508]                 NAMES <- toupper(removed)
[17:38:07.508]                 for (kk in seq_along(NAMES)) {
[17:38:07.508]                   name <- removed[[kk]]
[17:38:07.508]                   NAME <- NAMES[[kk]]
[17:38:07.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.508]                     next
[17:38:07.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.508]                 }
[17:38:07.508]                 if (length(args) > 0) 
[17:38:07.508]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.508]             }
[17:38:07.508]             else {
[17:38:07.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.508]             }
[17:38:07.508]             {
[17:38:07.508]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.508]                   0L) {
[17:38:07.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.508]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.508]                   base::options(opts)
[17:38:07.508]                 }
[17:38:07.508]                 {
[17:38:07.508]                   {
[17:38:07.508]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:07.508]                     NULL
[17:38:07.508]                   }
[17:38:07.508]                   options(future.plan = NULL)
[17:38:07.508]                   if (is.na(NA_character_)) 
[17:38:07.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.508]                     .init = FALSE)
[17:38:07.508]                 }
[17:38:07.508]             }
[17:38:07.508]         }
[17:38:07.508]     })
[17:38:07.508]     if (TRUE) {
[17:38:07.508]         base::sink(type = "output", split = FALSE)
[17:38:07.508]         if (TRUE) {
[17:38:07.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.508]         }
[17:38:07.508]         else {
[17:38:07.508]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.508]         }
[17:38:07.508]         base::close(...future.stdout)
[17:38:07.508]         ...future.stdout <- NULL
[17:38:07.508]     }
[17:38:07.508]     ...future.result$conditions <- ...future.conditions
[17:38:07.508]     ...future.result$finished <- base::Sys.time()
[17:38:07.508]     ...future.result
[17:38:07.508] }
[17:38:07.510] assign_globals() ...
[17:38:07.510] List of 11
[17:38:07.510]  $ ...future.FUN            :function (x, ...)  
[17:38:07.510]  $ x_FUN                    :function (x)  
[17:38:07.510]  $ times                    : int 0
[17:38:07.510]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.510]  $ stop_if_not              :function (...)  
[17:38:07.510]  $ dim                      : NULL
[17:38:07.510]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:07.510]  $ future.call.arguments    : list()
[17:38:07.510]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.510]  $ ...future.elements_ii    :List of 5
[17:38:07.510]   ..$ : int 1
[17:38:07.510]   ..$ : int 2
[17:38:07.510]   ..$ : int 3
[17:38:07.510]   ..$ : int 4
[17:38:07.510]   ..$ : int 5
[17:38:07.510]  $ ...future.seeds_ii       : NULL
[17:38:07.510]  $ ...future.globals.maxSize: NULL
[17:38:07.510]  - attr(*, "where")=List of 11
[17:38:07.510]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.510]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.510]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.510]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.510]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.510]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.510]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.510]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.510]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.510]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.510]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.510]  - attr(*, "resolved")= logi FALSE
[17:38:07.510]  - attr(*, "total_size")= num 95472
[17:38:07.510]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.510]  - attr(*, "already-done")= logi TRUE
[17:38:07.519] - copied ‘...future.FUN’ to environment
[17:38:07.519] - reassign environment for ‘x_FUN’
[17:38:07.519] - copied ‘x_FUN’ to environment
[17:38:07.519] - copied ‘times’ to environment
[17:38:07.519] - copied ‘stopf’ to environment
[17:38:07.519] - copied ‘stop_if_not’ to environment
[17:38:07.519] - copied ‘dim’ to environment
[17:38:07.519] - copied ‘valid_types’ to environment
[17:38:07.519] - copied ‘future.call.arguments’ to environment
[17:38:07.520] - copied ‘...future.elements_ii’ to environment
[17:38:07.520] - copied ‘...future.seeds_ii’ to environment
[17:38:07.520] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.520] assign_globals() ... done
[17:38:07.520] requestCore(): workers = 2
[17:38:07.522] MulticoreFuture started
[17:38:07.523] - Launch lazy future ... done
[17:38:07.523] run() for ‘MulticoreFuture’ ... done
[17:38:07.523] Created future:
[17:38:07.524] plan(): Setting new future strategy stack:
[17:38:07.524] List of future strategies:
[17:38:07.524] 1. sequential:
[17:38:07.524]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.524]    - tweaked: FALSE
[17:38:07.524]    - call: NULL
[17:38:07.525] plan(): nbrOfWorkers() = 1
[17:38:07.527] plan(): Setting new future strategy stack:
[17:38:07.527] List of future strategies:
[17:38:07.527] 1. multicore:
[17:38:07.527]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:07.527]    - tweaked: FALSE
[17:38:07.527]    - call: plan(strategy)
[17:38:07.532] plan(): nbrOfWorkers() = 2
[17:38:07.523] MulticoreFuture:
[17:38:07.523] Label: ‘future_vapply-1’
[17:38:07.523] Expression:
[17:38:07.523] {
[17:38:07.523]     do.call(function(...) {
[17:38:07.523]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.523]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.523]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.523]             on.exit(options(oopts), add = TRUE)
[17:38:07.523]         }
[17:38:07.523]         {
[17:38:07.523]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.523]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.523]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.523]             })
[17:38:07.523]         }
[17:38:07.523]     }, args = future.call.arguments)
[17:38:07.523] }
[17:38:07.523] Lazy evaluation: FALSE
[17:38:07.523] Asynchronous evaluation: TRUE
[17:38:07.523] Local evaluation: TRUE
[17:38:07.523] Environment: R_GlobalEnv
[17:38:07.523] Capture standard output: TRUE
[17:38:07.523] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.523] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.523] Packages: 1 packages (‘future.apply’)
[17:38:07.523] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.523] Resolved: TRUE
[17:38:07.523] Value: <not collected>
[17:38:07.523] Conditions captured: <none>
[17:38:07.523] Early signaling: FALSE
[17:38:07.523] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.523] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.533] Chunk #1 of 2 ... DONE
[17:38:07.534] Chunk #2 of 2 ...
[17:38:07.534]  - Finding globals in 'X' for chunk #2 ...
[17:38:07.534] getGlobalsAndPackages() ...
[17:38:07.534] Searching for globals...
[17:38:07.535] 
[17:38:07.535] Searching for globals ... DONE
[17:38:07.535] - globals: [0] <none>
[17:38:07.535] getGlobalsAndPackages() ... DONE
[17:38:07.535]    + additional globals found: [n=0] 
[17:38:07.535]    + additional namespaces needed: [n=0] 
[17:38:07.535]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:07.535]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:07.536]  - seeds: <none>
[17:38:07.536]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.536] getGlobalsAndPackages() ...
[17:38:07.536] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.536] Resolving globals: FALSE
[17:38:07.536] Tweak future expression to call with '...' arguments ...
[17:38:07.537] {
[17:38:07.537]     do.call(function(...) {
[17:38:07.537]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.537]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.537]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.537]             on.exit(options(oopts), add = TRUE)
[17:38:07.537]         }
[17:38:07.537]         {
[17:38:07.537]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.537]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.537]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.537]             })
[17:38:07.537]         }
[17:38:07.537]     }, args = future.call.arguments)
[17:38:07.537] }
[17:38:07.537] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.542] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.543] - packages: [1] ‘future.apply’
[17:38:07.543] getGlobalsAndPackages() ... DONE
[17:38:07.544] run() for ‘Future’ ...
[17:38:07.544] - state: ‘created’
[17:38:07.545] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:07.551] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.551] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:07.551]   - Field: ‘label’
[17:38:07.552]   - Field: ‘local’
[17:38:07.552]   - Field: ‘owner’
[17:38:07.552]   - Field: ‘envir’
[17:38:07.552]   - Field: ‘workers’
[17:38:07.553]   - Field: ‘packages’
[17:38:07.553]   - Field: ‘gc’
[17:38:07.553]   - Field: ‘job’
[17:38:07.553]   - Field: ‘conditions’
[17:38:07.553]   - Field: ‘expr’
[17:38:07.554]   - Field: ‘uuid’
[17:38:07.554]   - Field: ‘seed’
[17:38:07.554]   - Field: ‘version’
[17:38:07.554]   - Field: ‘result’
[17:38:07.554]   - Field: ‘asynchronous’
[17:38:07.554]   - Field: ‘calls’
[17:38:07.554]   - Field: ‘globals’
[17:38:07.555]   - Field: ‘stdout’
[17:38:07.555]   - Field: ‘earlySignal’
[17:38:07.555]   - Field: ‘lazy’
[17:38:07.555]   - Field: ‘state’
[17:38:07.555] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:07.555] - Launch lazy future ...
[17:38:07.556] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:07.556] Packages needed by future strategies (n = 0): <none>
[17:38:07.557] {
[17:38:07.557]     {
[17:38:07.557]         {
[17:38:07.557]             ...future.startTime <- base::Sys.time()
[17:38:07.557]             {
[17:38:07.557]                 {
[17:38:07.557]                   {
[17:38:07.557]                     {
[17:38:07.557]                       {
[17:38:07.557]                         base::local({
[17:38:07.557]                           has_future <- base::requireNamespace("future", 
[17:38:07.557]                             quietly = TRUE)
[17:38:07.557]                           if (has_future) {
[17:38:07.557]                             ns <- base::getNamespace("future")
[17:38:07.557]                             version <- ns[[".package"]][["version"]]
[17:38:07.557]                             if (is.null(version)) 
[17:38:07.557]                               version <- utils::packageVersion("future")
[17:38:07.557]                           }
[17:38:07.557]                           else {
[17:38:07.557]                             version <- NULL
[17:38:07.557]                           }
[17:38:07.557]                           if (!has_future || version < "1.8.0") {
[17:38:07.557]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.557]                               "", base::R.version$version.string), 
[17:38:07.557]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:07.557]                                 base::R.version$platform, 8 * 
[17:38:07.557]                                   base::.Machine$sizeof.pointer), 
[17:38:07.557]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.557]                                 "release", "version")], collapse = " "), 
[17:38:07.557]                               hostname = base::Sys.info()[["nodename"]])
[17:38:07.557]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.557]                               info)
[17:38:07.557]                             info <- base::paste(info, collapse = "; ")
[17:38:07.557]                             if (!has_future) {
[17:38:07.557]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.557]                                 info)
[17:38:07.557]                             }
[17:38:07.557]                             else {
[17:38:07.557]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.557]                                 info, version)
[17:38:07.557]                             }
[17:38:07.557]                             base::stop(msg)
[17:38:07.557]                           }
[17:38:07.557]                         })
[17:38:07.557]                       }
[17:38:07.557]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:07.557]                       base::options(mc.cores = 1L)
[17:38:07.557]                     }
[17:38:07.557]                     base::local({
[17:38:07.557]                       for (pkg in "future.apply") {
[17:38:07.557]                         base::loadNamespace(pkg)
[17:38:07.557]                         base::library(pkg, character.only = TRUE)
[17:38:07.557]                       }
[17:38:07.557]                     })
[17:38:07.557]                   }
[17:38:07.557]                   ...future.strategy.old <- future::plan("list")
[17:38:07.557]                   options(future.plan = NULL)
[17:38:07.557]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.557]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.557]                 }
[17:38:07.557]                 ...future.workdir <- getwd()
[17:38:07.557]             }
[17:38:07.557]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.557]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.557]         }
[17:38:07.557]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.557]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:07.557]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.557]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.557]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.557]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.557]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.557]             base::names(...future.oldOptions))
[17:38:07.557]     }
[17:38:07.557]     if (FALSE) {
[17:38:07.557]     }
[17:38:07.557]     else {
[17:38:07.557]         if (TRUE) {
[17:38:07.557]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.557]                 open = "w")
[17:38:07.557]         }
[17:38:07.557]         else {
[17:38:07.557]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.557]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.557]         }
[17:38:07.557]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.557]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.557]             base::sink(type = "output", split = FALSE)
[17:38:07.557]             base::close(...future.stdout)
[17:38:07.557]         }, add = TRUE)
[17:38:07.557]     }
[17:38:07.557]     ...future.frame <- base::sys.nframe()
[17:38:07.557]     ...future.conditions <- base::list()
[17:38:07.557]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.557]     if (FALSE) {
[17:38:07.557]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.557]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.557]     }
[17:38:07.557]     ...future.result <- base::tryCatch({
[17:38:07.557]         base::withCallingHandlers({
[17:38:07.557]             ...future.value <- base::withVisible(base::local({
[17:38:07.557]                 withCallingHandlers({
[17:38:07.557]                   {
[17:38:07.557]                     do.call(function(...) {
[17:38:07.557]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.557]                       if (!identical(...future.globals.maxSize.org, 
[17:38:07.557]                         ...future.globals.maxSize)) {
[17:38:07.557]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.557]                         on.exit(options(oopts), add = TRUE)
[17:38:07.557]                       }
[17:38:07.557]                       {
[17:38:07.557]                         lapply(seq_along(...future.elements_ii), 
[17:38:07.557]                           FUN = function(jj) {
[17:38:07.557]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.557]                             ...future.FUN(...future.X_jj, ...)
[17:38:07.557]                           })
[17:38:07.557]                       }
[17:38:07.557]                     }, args = future.call.arguments)
[17:38:07.557]                   }
[17:38:07.557]                 }, immediateCondition = function(cond) {
[17:38:07.557]                   save_rds <- function (object, pathname, ...) 
[17:38:07.557]                   {
[17:38:07.557]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:07.557]                     if (file_test("-f", pathname_tmp)) {
[17:38:07.557]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.557]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:07.557]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.557]                         fi_tmp[["mtime"]])
[17:38:07.557]                     }
[17:38:07.557]                     tryCatch({
[17:38:07.557]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:07.557]                     }, error = function(ex) {
[17:38:07.557]                       msg <- conditionMessage(ex)
[17:38:07.557]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.557]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:07.557]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.557]                         fi_tmp[["mtime"]], msg)
[17:38:07.557]                       ex$message <- msg
[17:38:07.557]                       stop(ex)
[17:38:07.557]                     })
[17:38:07.557]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:07.557]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:07.557]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:07.557]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.557]                       fi <- file.info(pathname)
[17:38:07.557]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:07.557]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.557]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:07.557]                         fi[["size"]], fi[["mtime"]])
[17:38:07.557]                       stop(msg)
[17:38:07.557]                     }
[17:38:07.557]                     invisible(pathname)
[17:38:07.557]                   }
[17:38:07.557]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:07.557]                     rootPath = tempdir()) 
[17:38:07.557]                   {
[17:38:07.557]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:07.557]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:07.557]                       tmpdir = path, fileext = ".rds")
[17:38:07.557]                     save_rds(obj, file)
[17:38:07.557]                   }
[17:38:07.557]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:07.557]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.557]                   {
[17:38:07.557]                     inherits <- base::inherits
[17:38:07.557]                     invokeRestart <- base::invokeRestart
[17:38:07.557]                     is.null <- base::is.null
[17:38:07.557]                     muffled <- FALSE
[17:38:07.557]                     if (inherits(cond, "message")) {
[17:38:07.557]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:07.557]                       if (muffled) 
[17:38:07.557]                         invokeRestart("muffleMessage")
[17:38:07.557]                     }
[17:38:07.557]                     else if (inherits(cond, "warning")) {
[17:38:07.557]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:07.557]                       if (muffled) 
[17:38:07.557]                         invokeRestart("muffleWarning")
[17:38:07.557]                     }
[17:38:07.557]                     else if (inherits(cond, "condition")) {
[17:38:07.557]                       if (!is.null(pattern)) {
[17:38:07.557]                         computeRestarts <- base::computeRestarts
[17:38:07.557]                         grepl <- base::grepl
[17:38:07.557]                         restarts <- computeRestarts(cond)
[17:38:07.557]                         for (restart in restarts) {
[17:38:07.557]                           name <- restart$name
[17:38:07.557]                           if (is.null(name)) 
[17:38:07.557]                             next
[17:38:07.557]                           if (!grepl(pattern, name)) 
[17:38:07.557]                             next
[17:38:07.557]                           invokeRestart(restart)
[17:38:07.557]                           muffled <- TRUE
[17:38:07.557]                           break
[17:38:07.557]                         }
[17:38:07.557]                       }
[17:38:07.557]                     }
[17:38:07.557]                     invisible(muffled)
[17:38:07.557]                   }
[17:38:07.557]                   muffleCondition(cond)
[17:38:07.557]                 })
[17:38:07.557]             }))
[17:38:07.557]             future::FutureResult(value = ...future.value$value, 
[17:38:07.557]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.557]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.557]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.557]                     ...future.globalenv.names))
[17:38:07.557]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.557]         }, condition = base::local({
[17:38:07.557]             c <- base::c
[17:38:07.557]             inherits <- base::inherits
[17:38:07.557]             invokeRestart <- base::invokeRestart
[17:38:07.557]             length <- base::length
[17:38:07.557]             list <- base::list
[17:38:07.557]             seq.int <- base::seq.int
[17:38:07.557]             signalCondition <- base::signalCondition
[17:38:07.557]             sys.calls <- base::sys.calls
[17:38:07.557]             `[[` <- base::`[[`
[17:38:07.557]             `+` <- base::`+`
[17:38:07.557]             `<<-` <- base::`<<-`
[17:38:07.557]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.557]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.557]                   3L)]
[17:38:07.557]             }
[17:38:07.557]             function(cond) {
[17:38:07.557]                 is_error <- inherits(cond, "error")
[17:38:07.557]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.557]                   NULL)
[17:38:07.557]                 if (is_error) {
[17:38:07.557]                   sessionInformation <- function() {
[17:38:07.557]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.557]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.557]                       search = base::search(), system = base::Sys.info())
[17:38:07.557]                   }
[17:38:07.557]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.557]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.557]                     cond$call), session = sessionInformation(), 
[17:38:07.557]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.557]                   signalCondition(cond)
[17:38:07.557]                 }
[17:38:07.557]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.557]                 "immediateCondition"))) {
[17:38:07.557]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.557]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.557]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.557]                   if (TRUE && !signal) {
[17:38:07.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.557]                     {
[17:38:07.557]                       inherits <- base::inherits
[17:38:07.557]                       invokeRestart <- base::invokeRestart
[17:38:07.557]                       is.null <- base::is.null
[17:38:07.557]                       muffled <- FALSE
[17:38:07.557]                       if (inherits(cond, "message")) {
[17:38:07.557]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.557]                         if (muffled) 
[17:38:07.557]                           invokeRestart("muffleMessage")
[17:38:07.557]                       }
[17:38:07.557]                       else if (inherits(cond, "warning")) {
[17:38:07.557]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.557]                         if (muffled) 
[17:38:07.557]                           invokeRestart("muffleWarning")
[17:38:07.557]                       }
[17:38:07.557]                       else if (inherits(cond, "condition")) {
[17:38:07.557]                         if (!is.null(pattern)) {
[17:38:07.557]                           computeRestarts <- base::computeRestarts
[17:38:07.557]                           grepl <- base::grepl
[17:38:07.557]                           restarts <- computeRestarts(cond)
[17:38:07.557]                           for (restart in restarts) {
[17:38:07.557]                             name <- restart$name
[17:38:07.557]                             if (is.null(name)) 
[17:38:07.557]                               next
[17:38:07.557]                             if (!grepl(pattern, name)) 
[17:38:07.557]                               next
[17:38:07.557]                             invokeRestart(restart)
[17:38:07.557]                             muffled <- TRUE
[17:38:07.557]                             break
[17:38:07.557]                           }
[17:38:07.557]                         }
[17:38:07.557]                       }
[17:38:07.557]                       invisible(muffled)
[17:38:07.557]                     }
[17:38:07.557]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.557]                   }
[17:38:07.557]                 }
[17:38:07.557]                 else {
[17:38:07.557]                   if (TRUE) {
[17:38:07.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.557]                     {
[17:38:07.557]                       inherits <- base::inherits
[17:38:07.557]                       invokeRestart <- base::invokeRestart
[17:38:07.557]                       is.null <- base::is.null
[17:38:07.557]                       muffled <- FALSE
[17:38:07.557]                       if (inherits(cond, "message")) {
[17:38:07.557]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.557]                         if (muffled) 
[17:38:07.557]                           invokeRestart("muffleMessage")
[17:38:07.557]                       }
[17:38:07.557]                       else if (inherits(cond, "warning")) {
[17:38:07.557]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.557]                         if (muffled) 
[17:38:07.557]                           invokeRestart("muffleWarning")
[17:38:07.557]                       }
[17:38:07.557]                       else if (inherits(cond, "condition")) {
[17:38:07.557]                         if (!is.null(pattern)) {
[17:38:07.557]                           computeRestarts <- base::computeRestarts
[17:38:07.557]                           grepl <- base::grepl
[17:38:07.557]                           restarts <- computeRestarts(cond)
[17:38:07.557]                           for (restart in restarts) {
[17:38:07.557]                             name <- restart$name
[17:38:07.557]                             if (is.null(name)) 
[17:38:07.557]                               next
[17:38:07.557]                             if (!grepl(pattern, name)) 
[17:38:07.557]                               next
[17:38:07.557]                             invokeRestart(restart)
[17:38:07.557]                             muffled <- TRUE
[17:38:07.557]                             break
[17:38:07.557]                           }
[17:38:07.557]                         }
[17:38:07.557]                       }
[17:38:07.557]                       invisible(muffled)
[17:38:07.557]                     }
[17:38:07.557]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.557]                   }
[17:38:07.557]                 }
[17:38:07.557]             }
[17:38:07.557]         }))
[17:38:07.557]     }, error = function(ex) {
[17:38:07.557]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.557]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.557]                 ...future.rng), started = ...future.startTime, 
[17:38:07.557]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.557]             version = "1.8"), class = "FutureResult")
[17:38:07.557]     }, finally = {
[17:38:07.557]         if (!identical(...future.workdir, getwd())) 
[17:38:07.557]             setwd(...future.workdir)
[17:38:07.557]         {
[17:38:07.557]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.557]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.557]             }
[17:38:07.557]             base::options(...future.oldOptions)
[17:38:07.557]             if (.Platform$OS.type == "windows") {
[17:38:07.557]                 old_names <- names(...future.oldEnvVars)
[17:38:07.557]                 envs <- base::Sys.getenv()
[17:38:07.557]                 names <- names(envs)
[17:38:07.557]                 common <- intersect(names, old_names)
[17:38:07.557]                 added <- setdiff(names, old_names)
[17:38:07.557]                 removed <- setdiff(old_names, names)
[17:38:07.557]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.557]                   envs[common]]
[17:38:07.557]                 NAMES <- toupper(changed)
[17:38:07.557]                 args <- list()
[17:38:07.557]                 for (kk in seq_along(NAMES)) {
[17:38:07.557]                   name <- changed[[kk]]
[17:38:07.557]                   NAME <- NAMES[[kk]]
[17:38:07.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.557]                     next
[17:38:07.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.557]                 }
[17:38:07.557]                 NAMES <- toupper(added)
[17:38:07.557]                 for (kk in seq_along(NAMES)) {
[17:38:07.557]                   name <- added[[kk]]
[17:38:07.557]                   NAME <- NAMES[[kk]]
[17:38:07.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.557]                     next
[17:38:07.557]                   args[[name]] <- ""
[17:38:07.557]                 }
[17:38:07.557]                 NAMES <- toupper(removed)
[17:38:07.557]                 for (kk in seq_along(NAMES)) {
[17:38:07.557]                   name <- removed[[kk]]
[17:38:07.557]                   NAME <- NAMES[[kk]]
[17:38:07.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.557]                     next
[17:38:07.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.557]                 }
[17:38:07.557]                 if (length(args) > 0) 
[17:38:07.557]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.557]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.557]             }
[17:38:07.557]             else {
[17:38:07.557]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.557]             }
[17:38:07.557]             {
[17:38:07.557]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.557]                   0L) {
[17:38:07.557]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.557]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.557]                   base::options(opts)
[17:38:07.557]                 }
[17:38:07.557]                 {
[17:38:07.557]                   {
[17:38:07.557]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:07.557]                     NULL
[17:38:07.557]                   }
[17:38:07.557]                   options(future.plan = NULL)
[17:38:07.557]                   if (is.na(NA_character_)) 
[17:38:07.557]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.557]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.557]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.557]                     .init = FALSE)
[17:38:07.557]                 }
[17:38:07.557]             }
[17:38:07.557]         }
[17:38:07.557]     })
[17:38:07.557]     if (TRUE) {
[17:38:07.557]         base::sink(type = "output", split = FALSE)
[17:38:07.557]         if (TRUE) {
[17:38:07.557]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.557]         }
[17:38:07.557]         else {
[17:38:07.557]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.557]         }
[17:38:07.557]         base::close(...future.stdout)
[17:38:07.557]         ...future.stdout <- NULL
[17:38:07.557]     }
[17:38:07.557]     ...future.result$conditions <- ...future.conditions
[17:38:07.557]     ...future.result$finished <- base::Sys.time()
[17:38:07.557]     ...future.result
[17:38:07.557] }
[17:38:07.560] assign_globals() ...
[17:38:07.560] List of 11
[17:38:07.560]  $ ...future.FUN            :function (x, ...)  
[17:38:07.560]  $ x_FUN                    :function (x)  
[17:38:07.560]  $ times                    : int 0
[17:38:07.560]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.560]  $ stop_if_not              :function (...)  
[17:38:07.560]  $ dim                      : NULL
[17:38:07.560]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:07.560]  $ future.call.arguments    : list()
[17:38:07.560]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.560]  $ ...future.elements_ii    :List of 5
[17:38:07.560]   ..$ : int 6
[17:38:07.560]   ..$ : int 7
[17:38:07.560]   ..$ : int 8
[17:38:07.560]   ..$ : int 9
[17:38:07.560]   ..$ : int 10
[17:38:07.560]  $ ...future.seeds_ii       : NULL
[17:38:07.560]  $ ...future.globals.maxSize: NULL
[17:38:07.560]  - attr(*, "where")=List of 11
[17:38:07.560]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.560]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.560]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.560]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.560]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.560]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.560]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.560]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.560]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.560]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.560]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.560]  - attr(*, "resolved")= logi FALSE
[17:38:07.560]  - attr(*, "total_size")= num 95472
[17:38:07.560]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.560]  - attr(*, "already-done")= logi TRUE
[17:38:07.571] - copied ‘...future.FUN’ to environment
[17:38:07.571] - reassign environment for ‘x_FUN’
[17:38:07.571] - copied ‘x_FUN’ to environment
[17:38:07.571] - copied ‘times’ to environment
[17:38:07.571] - copied ‘stopf’ to environment
[17:38:07.571] - copied ‘stop_if_not’ to environment
[17:38:07.571] - copied ‘dim’ to environment
[17:38:07.572] - copied ‘valid_types’ to environment
[17:38:07.572] - copied ‘future.call.arguments’ to environment
[17:38:07.572] - copied ‘...future.elements_ii’ to environment
[17:38:07.572] - copied ‘...future.seeds_ii’ to environment
[17:38:07.572] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.572] assign_globals() ... done
[17:38:07.572] requestCore(): workers = 2
[17:38:07.575] MulticoreFuture started
[17:38:07.575] - Launch lazy future ... done
[17:38:07.575] run() for ‘MulticoreFuture’ ... done
[17:38:07.575] Created future:
[17:38:07.576] plan(): Setting new future strategy stack:
[17:38:07.576] List of future strategies:
[17:38:07.576] 1. sequential:
[17:38:07.576]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.576]    - tweaked: FALSE
[17:38:07.576]    - call: NULL
[17:38:07.577] plan(): nbrOfWorkers() = 1
[17:38:07.579] plan(): Setting new future strategy stack:
[17:38:07.580] List of future strategies:
[17:38:07.580] 1. multicore:
[17:38:07.580]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:07.580]    - tweaked: FALSE
[17:38:07.580]    - call: plan(strategy)
[17:38:07.585] plan(): nbrOfWorkers() = 2
[17:38:07.576] MulticoreFuture:
[17:38:07.576] Label: ‘future_vapply-2’
[17:38:07.576] Expression:
[17:38:07.576] {
[17:38:07.576]     do.call(function(...) {
[17:38:07.576]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.576]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.576]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.576]             on.exit(options(oopts), add = TRUE)
[17:38:07.576]         }
[17:38:07.576]         {
[17:38:07.576]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.576]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.576]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.576]             })
[17:38:07.576]         }
[17:38:07.576]     }, args = future.call.arguments)
[17:38:07.576] }
[17:38:07.576] Lazy evaluation: FALSE
[17:38:07.576] Asynchronous evaluation: TRUE
[17:38:07.576] Local evaluation: TRUE
[17:38:07.576] Environment: R_GlobalEnv
[17:38:07.576] Capture standard output: TRUE
[17:38:07.576] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.576] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.576] Packages: 1 packages (‘future.apply’)
[17:38:07.576] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.576] Resolved: TRUE
[17:38:07.576] Value: <not collected>
[17:38:07.576] Conditions captured: <none>
[17:38:07.576] Early signaling: FALSE
[17:38:07.576] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.576] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.586] Chunk #2 of 2 ... DONE
[17:38:07.586] Launching 2 futures (chunks) ... DONE
[17:38:07.586] Resolving 2 futures (chunks) ...
[17:38:07.586] resolve() on list ...
[17:38:07.586]  recursive: 0
[17:38:07.586]  length: 2
[17:38:07.587] 
[17:38:07.587] Future #1
[17:38:07.587] result() for MulticoreFuture ...
[17:38:07.588] result() for MulticoreFuture ...
[17:38:07.588] result() for MulticoreFuture ... done
[17:38:07.588] result() for MulticoreFuture ... done
[17:38:07.589] result() for MulticoreFuture ...
[17:38:07.589] result() for MulticoreFuture ... done
[17:38:07.589] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:07.589] - nx: 2
[17:38:07.589] - relay: TRUE
[17:38:07.589] - stdout: TRUE
[17:38:07.590] - signal: TRUE
[17:38:07.590] - resignal: FALSE
[17:38:07.590] - force: TRUE
[17:38:07.590] - relayed: [n=2] FALSE, FALSE
[17:38:07.590] - queued futures: [n=2] FALSE, FALSE
[17:38:07.591]  - until=1
[17:38:07.591]  - relaying element #1
[17:38:07.591] result() for MulticoreFuture ...
[17:38:07.591] result() for MulticoreFuture ... done
[17:38:07.591] result() for MulticoreFuture ...
[17:38:07.592] result() for MulticoreFuture ... done
[17:38:07.596] result() for MulticoreFuture ...
[17:38:07.596] result() for MulticoreFuture ... done
[17:38:07.597] result() for MulticoreFuture ...
[17:38:07.597] result() for MulticoreFuture ... done
[17:38:07.597] - relayed: [n=2] TRUE, FALSE
[17:38:07.598] - queued futures: [n=2] TRUE, FALSE
[17:38:07.598] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:07.598]  length: 1 (resolved future 1)
[17:38:07.599] Future #2
[17:38:07.599] result() for MulticoreFuture ...
[17:38:07.600] result() for MulticoreFuture ...
[17:38:07.601] result() for MulticoreFuture ... done
[17:38:07.601] result() for MulticoreFuture ... done
[17:38:07.601] result() for MulticoreFuture ...
[17:38:07.601] result() for MulticoreFuture ... done
[17:38:07.602] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:07.602] - nx: 2
[17:38:07.602] - relay: TRUE
[17:38:07.603] - stdout: TRUE
[17:38:07.603] - signal: TRUE
[17:38:07.603] - resignal: FALSE
[17:38:07.603] - force: TRUE
[17:38:07.604] - relayed: [n=2] TRUE, FALSE
[17:38:07.604] - queued futures: [n=2] TRUE, FALSE
[17:38:07.604]  - until=2
[17:38:07.604]  - relaying element #2
[17:38:07.604] result() for MulticoreFuture ...
[17:38:07.604] result() for MulticoreFuture ... done
[17:38:07.605] result() for MulticoreFuture ...
[17:38:07.605] result() for MulticoreFuture ... done
[17:38:07.605] result() for MulticoreFuture ...
[17:38:07.605] result() for MulticoreFuture ... done
[17:38:07.605] result() for MulticoreFuture ...
[17:38:07.605] result() for MulticoreFuture ... done
[17:38:07.605] - relayed: [n=2] TRUE, TRUE
[17:38:07.605] - queued futures: [n=2] TRUE, TRUE
[17:38:07.606] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:07.606]  length: 0 (resolved future 2)
[17:38:07.606] Relaying remaining futures
[17:38:07.606] signalConditionsASAP(NULL, pos=0) ...
[17:38:07.606] - nx: 2
[17:38:07.606] - relay: TRUE
[17:38:07.606] - stdout: TRUE
[17:38:07.606] - signal: TRUE
[17:38:07.607] - resignal: FALSE
[17:38:07.607] - force: TRUE
[17:38:07.607] - relayed: [n=2] TRUE, TRUE
[17:38:07.607] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:07.607] - relayed: [n=2] TRUE, TRUE
[17:38:07.607] - queued futures: [n=2] TRUE, TRUE
[17:38:07.607] signalConditionsASAP(NULL, pos=0) ... done
[17:38:07.607] resolve() on list ... DONE
[17:38:07.607] result() for MulticoreFuture ...
[17:38:07.608] result() for MulticoreFuture ... done
[17:38:07.608] result() for MulticoreFuture ...
[17:38:07.608] result() for MulticoreFuture ... done
[17:38:07.608] result() for MulticoreFuture ...
[17:38:07.608] result() for MulticoreFuture ... done
[17:38:07.608] result() for MulticoreFuture ...
[17:38:07.608] result() for MulticoreFuture ... done
[17:38:07.608]  - Number of value chunks collected: 2
[17:38:07.609] Resolving 2 futures (chunks) ... DONE
[17:38:07.609] Reducing values from 2 chunks ...
[17:38:07.609]  - Number of values collected after concatenation: 10
[17:38:07.609]  - Number of values expected: 10
[17:38:07.609] Reducing values from 2 chunks ... DONE
[17:38:07.609] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[17:38:07.610] future_lapply() ...
[17:38:07.616] Number of chunks: 2
[17:38:07.616] getGlobalsAndPackagesXApply() ...
[17:38:07.616]  - future.globals: TRUE
[17:38:07.616] getGlobalsAndPackages() ...
[17:38:07.616] Searching for globals...
[17:38:07.620] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[17:38:07.620] Searching for globals ... DONE
[17:38:07.621] Resolving globals: FALSE
[17:38:07.621] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[17:38:07.622] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:07.622] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.622] - packages: [1] ‘future.apply’
[17:38:07.622] getGlobalsAndPackages() ... DONE
[17:38:07.622]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.622]  - needed namespaces: [n=1] ‘future.apply’
[17:38:07.623] Finding globals ... DONE
[17:38:07.623]  - use_args: TRUE
[17:38:07.623]  - Getting '...' globals ...
[17:38:07.623] resolve() on list ...
[17:38:07.623]  recursive: 0
[17:38:07.623]  length: 1
[17:38:07.623]  elements: ‘...’
[17:38:07.624]  length: 0 (resolved future 1)
[17:38:07.624] resolve() on list ... DONE
[17:38:07.624]    - '...' content: [n=0] 
[17:38:07.624] List of 1
[17:38:07.624]  $ ...: list()
[17:38:07.624]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.624]  - attr(*, "where")=List of 1
[17:38:07.624]   ..$ ...:<environment: 0x5607fff57d90> 
[17:38:07.624]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.624]  - attr(*, "resolved")= logi TRUE
[17:38:07.624]  - attr(*, "total_size")= num NA
[17:38:07.626]  - Getting '...' globals ... DONE
[17:38:07.627] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:07.627] List of 8
[17:38:07.627]  $ ...future.FUN:function (x, ...)  
[17:38:07.627]  $ x_FUN        :function (x)  
[17:38:07.627]  $ times        : int 0
[17:38:07.627]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.627]  $ stop_if_not  :function (...)  
[17:38:07.627]  $ dim          : NULL
[17:38:07.627]  $ valid_types  : chr [1:2] "logical" "integer"
[17:38:07.627]  $ ...          : list()
[17:38:07.627]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.627]  - attr(*, "where")=List of 8
[17:38:07.627]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:07.627]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:07.627]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:07.627]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:07.627]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:07.627]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:07.627]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:07.627]   ..$ ...          :<environment: 0x5607fff57d90> 
[17:38:07.627]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.627]  - attr(*, "resolved")= logi FALSE
[17:38:07.627]  - attr(*, "total_size")= num 95400
[17:38:07.635] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:07.635] getGlobalsAndPackagesXApply() ... DONE
[17:38:07.635] Number of futures (= number of chunks): 2
[17:38:07.635] Launching 2 futures (chunks) ...
[17:38:07.635] Chunk #1 of 2 ...
[17:38:07.635]  - Finding globals in 'X' for chunk #1 ...
[17:38:07.635] getGlobalsAndPackages() ...
[17:38:07.635] Searching for globals...
[17:38:07.636] 
[17:38:07.636] Searching for globals ... DONE
[17:38:07.636] - globals: [0] <none>
[17:38:07.636] getGlobalsAndPackages() ... DONE
[17:38:07.636]    + additional globals found: [n=0] 
[17:38:07.636]    + additional namespaces needed: [n=0] 
[17:38:07.636]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:07.636]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:07.637]  - seeds: <none>
[17:38:07.637]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.637] getGlobalsAndPackages() ...
[17:38:07.637] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.637] Resolving globals: FALSE
[17:38:07.637] Tweak future expression to call with '...' arguments ...
[17:38:07.637] {
[17:38:07.637]     do.call(function(...) {
[17:38:07.637]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.637]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.637]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.637]             on.exit(options(oopts), add = TRUE)
[17:38:07.637]         }
[17:38:07.637]         {
[17:38:07.637]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.637]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.637]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.637]             })
[17:38:07.637]         }
[17:38:07.637]     }, args = future.call.arguments)
[17:38:07.637] }
[17:38:07.637] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.638] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.638] - packages: [1] ‘future.apply’
[17:38:07.638] getGlobalsAndPackages() ... DONE
[17:38:07.638] run() for ‘Future’ ...
[17:38:07.639] - state: ‘created’
[17:38:07.639] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:07.642] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:07.643]   - Field: ‘label’
[17:38:07.643]   - Field: ‘local’
[17:38:07.643]   - Field: ‘owner’
[17:38:07.643]   - Field: ‘envir’
[17:38:07.643]   - Field: ‘workers’
[17:38:07.643]   - Field: ‘packages’
[17:38:07.643]   - Field: ‘gc’
[17:38:07.643]   - Field: ‘job’
[17:38:07.643]   - Field: ‘conditions’
[17:38:07.644]   - Field: ‘expr’
[17:38:07.644]   - Field: ‘uuid’
[17:38:07.644]   - Field: ‘seed’
[17:38:07.644]   - Field: ‘version’
[17:38:07.644]   - Field: ‘result’
[17:38:07.644]   - Field: ‘asynchronous’
[17:38:07.644]   - Field: ‘calls’
[17:38:07.644]   - Field: ‘globals’
[17:38:07.644]   - Field: ‘stdout’
[17:38:07.644]   - Field: ‘earlySignal’
[17:38:07.644]   - Field: ‘lazy’
[17:38:07.645]   - Field: ‘state’
[17:38:07.645] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:07.645] - Launch lazy future ...
[17:38:07.645] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:07.645] Packages needed by future strategies (n = 0): <none>
[17:38:07.646] {
[17:38:07.646]     {
[17:38:07.646]         {
[17:38:07.646]             ...future.startTime <- base::Sys.time()
[17:38:07.646]             {
[17:38:07.646]                 {
[17:38:07.646]                   {
[17:38:07.646]                     {
[17:38:07.646]                       {
[17:38:07.646]                         base::local({
[17:38:07.646]                           has_future <- base::requireNamespace("future", 
[17:38:07.646]                             quietly = TRUE)
[17:38:07.646]                           if (has_future) {
[17:38:07.646]                             ns <- base::getNamespace("future")
[17:38:07.646]                             version <- ns[[".package"]][["version"]]
[17:38:07.646]                             if (is.null(version)) 
[17:38:07.646]                               version <- utils::packageVersion("future")
[17:38:07.646]                           }
[17:38:07.646]                           else {
[17:38:07.646]                             version <- NULL
[17:38:07.646]                           }
[17:38:07.646]                           if (!has_future || version < "1.8.0") {
[17:38:07.646]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.646]                               "", base::R.version$version.string), 
[17:38:07.646]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:07.646]                                 base::R.version$platform, 8 * 
[17:38:07.646]                                   base::.Machine$sizeof.pointer), 
[17:38:07.646]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.646]                                 "release", "version")], collapse = " "), 
[17:38:07.646]                               hostname = base::Sys.info()[["nodename"]])
[17:38:07.646]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.646]                               info)
[17:38:07.646]                             info <- base::paste(info, collapse = "; ")
[17:38:07.646]                             if (!has_future) {
[17:38:07.646]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.646]                                 info)
[17:38:07.646]                             }
[17:38:07.646]                             else {
[17:38:07.646]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.646]                                 info, version)
[17:38:07.646]                             }
[17:38:07.646]                             base::stop(msg)
[17:38:07.646]                           }
[17:38:07.646]                         })
[17:38:07.646]                       }
[17:38:07.646]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:07.646]                       base::options(mc.cores = 1L)
[17:38:07.646]                     }
[17:38:07.646]                     base::local({
[17:38:07.646]                       for (pkg in "future.apply") {
[17:38:07.646]                         base::loadNamespace(pkg)
[17:38:07.646]                         base::library(pkg, character.only = TRUE)
[17:38:07.646]                       }
[17:38:07.646]                     })
[17:38:07.646]                   }
[17:38:07.646]                   ...future.strategy.old <- future::plan("list")
[17:38:07.646]                   options(future.plan = NULL)
[17:38:07.646]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.646]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.646]                 }
[17:38:07.646]                 ...future.workdir <- getwd()
[17:38:07.646]             }
[17:38:07.646]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.646]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.646]         }
[17:38:07.646]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.646]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:07.646]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.646]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.646]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.646]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.646]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.646]             base::names(...future.oldOptions))
[17:38:07.646]     }
[17:38:07.646]     if (FALSE) {
[17:38:07.646]     }
[17:38:07.646]     else {
[17:38:07.646]         if (TRUE) {
[17:38:07.646]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.646]                 open = "w")
[17:38:07.646]         }
[17:38:07.646]         else {
[17:38:07.646]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.646]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.646]         }
[17:38:07.646]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.646]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.646]             base::sink(type = "output", split = FALSE)
[17:38:07.646]             base::close(...future.stdout)
[17:38:07.646]         }, add = TRUE)
[17:38:07.646]     }
[17:38:07.646]     ...future.frame <- base::sys.nframe()
[17:38:07.646]     ...future.conditions <- base::list()
[17:38:07.646]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.646]     if (FALSE) {
[17:38:07.646]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.646]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.646]     }
[17:38:07.646]     ...future.result <- base::tryCatch({
[17:38:07.646]         base::withCallingHandlers({
[17:38:07.646]             ...future.value <- base::withVisible(base::local({
[17:38:07.646]                 withCallingHandlers({
[17:38:07.646]                   {
[17:38:07.646]                     do.call(function(...) {
[17:38:07.646]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.646]                       if (!identical(...future.globals.maxSize.org, 
[17:38:07.646]                         ...future.globals.maxSize)) {
[17:38:07.646]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.646]                         on.exit(options(oopts), add = TRUE)
[17:38:07.646]                       }
[17:38:07.646]                       {
[17:38:07.646]                         lapply(seq_along(...future.elements_ii), 
[17:38:07.646]                           FUN = function(jj) {
[17:38:07.646]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.646]                             ...future.FUN(...future.X_jj, ...)
[17:38:07.646]                           })
[17:38:07.646]                       }
[17:38:07.646]                     }, args = future.call.arguments)
[17:38:07.646]                   }
[17:38:07.646]                 }, immediateCondition = function(cond) {
[17:38:07.646]                   save_rds <- function (object, pathname, ...) 
[17:38:07.646]                   {
[17:38:07.646]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:07.646]                     if (file_test("-f", pathname_tmp)) {
[17:38:07.646]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.646]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:07.646]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.646]                         fi_tmp[["mtime"]])
[17:38:07.646]                     }
[17:38:07.646]                     tryCatch({
[17:38:07.646]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:07.646]                     }, error = function(ex) {
[17:38:07.646]                       msg <- conditionMessage(ex)
[17:38:07.646]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.646]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:07.646]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.646]                         fi_tmp[["mtime"]], msg)
[17:38:07.646]                       ex$message <- msg
[17:38:07.646]                       stop(ex)
[17:38:07.646]                     })
[17:38:07.646]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:07.646]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:07.646]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:07.646]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.646]                       fi <- file.info(pathname)
[17:38:07.646]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:07.646]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.646]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:07.646]                         fi[["size"]], fi[["mtime"]])
[17:38:07.646]                       stop(msg)
[17:38:07.646]                     }
[17:38:07.646]                     invisible(pathname)
[17:38:07.646]                   }
[17:38:07.646]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:07.646]                     rootPath = tempdir()) 
[17:38:07.646]                   {
[17:38:07.646]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:07.646]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:07.646]                       tmpdir = path, fileext = ".rds")
[17:38:07.646]                     save_rds(obj, file)
[17:38:07.646]                   }
[17:38:07.646]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:07.646]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.646]                   {
[17:38:07.646]                     inherits <- base::inherits
[17:38:07.646]                     invokeRestart <- base::invokeRestart
[17:38:07.646]                     is.null <- base::is.null
[17:38:07.646]                     muffled <- FALSE
[17:38:07.646]                     if (inherits(cond, "message")) {
[17:38:07.646]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:07.646]                       if (muffled) 
[17:38:07.646]                         invokeRestart("muffleMessage")
[17:38:07.646]                     }
[17:38:07.646]                     else if (inherits(cond, "warning")) {
[17:38:07.646]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:07.646]                       if (muffled) 
[17:38:07.646]                         invokeRestart("muffleWarning")
[17:38:07.646]                     }
[17:38:07.646]                     else if (inherits(cond, "condition")) {
[17:38:07.646]                       if (!is.null(pattern)) {
[17:38:07.646]                         computeRestarts <- base::computeRestarts
[17:38:07.646]                         grepl <- base::grepl
[17:38:07.646]                         restarts <- computeRestarts(cond)
[17:38:07.646]                         for (restart in restarts) {
[17:38:07.646]                           name <- restart$name
[17:38:07.646]                           if (is.null(name)) 
[17:38:07.646]                             next
[17:38:07.646]                           if (!grepl(pattern, name)) 
[17:38:07.646]                             next
[17:38:07.646]                           invokeRestart(restart)
[17:38:07.646]                           muffled <- TRUE
[17:38:07.646]                           break
[17:38:07.646]                         }
[17:38:07.646]                       }
[17:38:07.646]                     }
[17:38:07.646]                     invisible(muffled)
[17:38:07.646]                   }
[17:38:07.646]                   muffleCondition(cond)
[17:38:07.646]                 })
[17:38:07.646]             }))
[17:38:07.646]             future::FutureResult(value = ...future.value$value, 
[17:38:07.646]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.646]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.646]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.646]                     ...future.globalenv.names))
[17:38:07.646]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.646]         }, condition = base::local({
[17:38:07.646]             c <- base::c
[17:38:07.646]             inherits <- base::inherits
[17:38:07.646]             invokeRestart <- base::invokeRestart
[17:38:07.646]             length <- base::length
[17:38:07.646]             list <- base::list
[17:38:07.646]             seq.int <- base::seq.int
[17:38:07.646]             signalCondition <- base::signalCondition
[17:38:07.646]             sys.calls <- base::sys.calls
[17:38:07.646]             `[[` <- base::`[[`
[17:38:07.646]             `+` <- base::`+`
[17:38:07.646]             `<<-` <- base::`<<-`
[17:38:07.646]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.646]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.646]                   3L)]
[17:38:07.646]             }
[17:38:07.646]             function(cond) {
[17:38:07.646]                 is_error <- inherits(cond, "error")
[17:38:07.646]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.646]                   NULL)
[17:38:07.646]                 if (is_error) {
[17:38:07.646]                   sessionInformation <- function() {
[17:38:07.646]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.646]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.646]                       search = base::search(), system = base::Sys.info())
[17:38:07.646]                   }
[17:38:07.646]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.646]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.646]                     cond$call), session = sessionInformation(), 
[17:38:07.646]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.646]                   signalCondition(cond)
[17:38:07.646]                 }
[17:38:07.646]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.646]                 "immediateCondition"))) {
[17:38:07.646]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.646]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.646]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.646]                   if (TRUE && !signal) {
[17:38:07.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.646]                     {
[17:38:07.646]                       inherits <- base::inherits
[17:38:07.646]                       invokeRestart <- base::invokeRestart
[17:38:07.646]                       is.null <- base::is.null
[17:38:07.646]                       muffled <- FALSE
[17:38:07.646]                       if (inherits(cond, "message")) {
[17:38:07.646]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.646]                         if (muffled) 
[17:38:07.646]                           invokeRestart("muffleMessage")
[17:38:07.646]                       }
[17:38:07.646]                       else if (inherits(cond, "warning")) {
[17:38:07.646]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.646]                         if (muffled) 
[17:38:07.646]                           invokeRestart("muffleWarning")
[17:38:07.646]                       }
[17:38:07.646]                       else if (inherits(cond, "condition")) {
[17:38:07.646]                         if (!is.null(pattern)) {
[17:38:07.646]                           computeRestarts <- base::computeRestarts
[17:38:07.646]                           grepl <- base::grepl
[17:38:07.646]                           restarts <- computeRestarts(cond)
[17:38:07.646]                           for (restart in restarts) {
[17:38:07.646]                             name <- restart$name
[17:38:07.646]                             if (is.null(name)) 
[17:38:07.646]                               next
[17:38:07.646]                             if (!grepl(pattern, name)) 
[17:38:07.646]                               next
[17:38:07.646]                             invokeRestart(restart)
[17:38:07.646]                             muffled <- TRUE
[17:38:07.646]                             break
[17:38:07.646]                           }
[17:38:07.646]                         }
[17:38:07.646]                       }
[17:38:07.646]                       invisible(muffled)
[17:38:07.646]                     }
[17:38:07.646]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.646]                   }
[17:38:07.646]                 }
[17:38:07.646]                 else {
[17:38:07.646]                   if (TRUE) {
[17:38:07.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.646]                     {
[17:38:07.646]                       inherits <- base::inherits
[17:38:07.646]                       invokeRestart <- base::invokeRestart
[17:38:07.646]                       is.null <- base::is.null
[17:38:07.646]                       muffled <- FALSE
[17:38:07.646]                       if (inherits(cond, "message")) {
[17:38:07.646]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.646]                         if (muffled) 
[17:38:07.646]                           invokeRestart("muffleMessage")
[17:38:07.646]                       }
[17:38:07.646]                       else if (inherits(cond, "warning")) {
[17:38:07.646]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.646]                         if (muffled) 
[17:38:07.646]                           invokeRestart("muffleWarning")
[17:38:07.646]                       }
[17:38:07.646]                       else if (inherits(cond, "condition")) {
[17:38:07.646]                         if (!is.null(pattern)) {
[17:38:07.646]                           computeRestarts <- base::computeRestarts
[17:38:07.646]                           grepl <- base::grepl
[17:38:07.646]                           restarts <- computeRestarts(cond)
[17:38:07.646]                           for (restart in restarts) {
[17:38:07.646]                             name <- restart$name
[17:38:07.646]                             if (is.null(name)) 
[17:38:07.646]                               next
[17:38:07.646]                             if (!grepl(pattern, name)) 
[17:38:07.646]                               next
[17:38:07.646]                             invokeRestart(restart)
[17:38:07.646]                             muffled <- TRUE
[17:38:07.646]                             break
[17:38:07.646]                           }
[17:38:07.646]                         }
[17:38:07.646]                       }
[17:38:07.646]                       invisible(muffled)
[17:38:07.646]                     }
[17:38:07.646]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.646]                   }
[17:38:07.646]                 }
[17:38:07.646]             }
[17:38:07.646]         }))
[17:38:07.646]     }, error = function(ex) {
[17:38:07.646]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.646]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.646]                 ...future.rng), started = ...future.startTime, 
[17:38:07.646]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.646]             version = "1.8"), class = "FutureResult")
[17:38:07.646]     }, finally = {
[17:38:07.646]         if (!identical(...future.workdir, getwd())) 
[17:38:07.646]             setwd(...future.workdir)
[17:38:07.646]         {
[17:38:07.646]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.646]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.646]             }
[17:38:07.646]             base::options(...future.oldOptions)
[17:38:07.646]             if (.Platform$OS.type == "windows") {
[17:38:07.646]                 old_names <- names(...future.oldEnvVars)
[17:38:07.646]                 envs <- base::Sys.getenv()
[17:38:07.646]                 names <- names(envs)
[17:38:07.646]                 common <- intersect(names, old_names)
[17:38:07.646]                 added <- setdiff(names, old_names)
[17:38:07.646]                 removed <- setdiff(old_names, names)
[17:38:07.646]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.646]                   envs[common]]
[17:38:07.646]                 NAMES <- toupper(changed)
[17:38:07.646]                 args <- list()
[17:38:07.646]                 for (kk in seq_along(NAMES)) {
[17:38:07.646]                   name <- changed[[kk]]
[17:38:07.646]                   NAME <- NAMES[[kk]]
[17:38:07.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.646]                     next
[17:38:07.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.646]                 }
[17:38:07.646]                 NAMES <- toupper(added)
[17:38:07.646]                 for (kk in seq_along(NAMES)) {
[17:38:07.646]                   name <- added[[kk]]
[17:38:07.646]                   NAME <- NAMES[[kk]]
[17:38:07.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.646]                     next
[17:38:07.646]                   args[[name]] <- ""
[17:38:07.646]                 }
[17:38:07.646]                 NAMES <- toupper(removed)
[17:38:07.646]                 for (kk in seq_along(NAMES)) {
[17:38:07.646]                   name <- removed[[kk]]
[17:38:07.646]                   NAME <- NAMES[[kk]]
[17:38:07.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.646]                     next
[17:38:07.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.646]                 }
[17:38:07.646]                 if (length(args) > 0) 
[17:38:07.646]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.646]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.646]             }
[17:38:07.646]             else {
[17:38:07.646]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.646]             }
[17:38:07.646]             {
[17:38:07.646]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.646]                   0L) {
[17:38:07.646]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.646]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.646]                   base::options(opts)
[17:38:07.646]                 }
[17:38:07.646]                 {
[17:38:07.646]                   {
[17:38:07.646]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:07.646]                     NULL
[17:38:07.646]                   }
[17:38:07.646]                   options(future.plan = NULL)
[17:38:07.646]                   if (is.na(NA_character_)) 
[17:38:07.646]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.646]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.646]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.646]                     .init = FALSE)
[17:38:07.646]                 }
[17:38:07.646]             }
[17:38:07.646]         }
[17:38:07.646]     })
[17:38:07.646]     if (TRUE) {
[17:38:07.646]         base::sink(type = "output", split = FALSE)
[17:38:07.646]         if (TRUE) {
[17:38:07.646]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.646]         }
[17:38:07.646]         else {
[17:38:07.646]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.646]         }
[17:38:07.646]         base::close(...future.stdout)
[17:38:07.646]         ...future.stdout <- NULL
[17:38:07.646]     }
[17:38:07.646]     ...future.result$conditions <- ...future.conditions
[17:38:07.646]     ...future.result$finished <- base::Sys.time()
[17:38:07.646]     ...future.result
[17:38:07.646] }
[17:38:07.648] assign_globals() ...
[17:38:07.648] List of 11
[17:38:07.648]  $ ...future.FUN            :function (x, ...)  
[17:38:07.648]  $ x_FUN                    :function (x)  
[17:38:07.648]  $ times                    : int 0
[17:38:07.648]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.648]  $ stop_if_not              :function (...)  
[17:38:07.648]  $ dim                      : NULL
[17:38:07.648]  $ valid_types              : chr [1:2] "logical" "integer"
[17:38:07.648]  $ future.call.arguments    : list()
[17:38:07.648]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.648]  $ ...future.elements_ii    :List of 5
[17:38:07.648]   ..$ : int 1
[17:38:07.648]   ..$ : int 2
[17:38:07.648]   ..$ : int 3
[17:38:07.648]   ..$ : int 4
[17:38:07.648]   ..$ : int 5
[17:38:07.648]  $ ...future.seeds_ii       : NULL
[17:38:07.648]  $ ...future.globals.maxSize: NULL
[17:38:07.648]  - attr(*, "where")=List of 11
[17:38:07.648]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.648]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.648]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.648]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.648]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.648]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.648]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.648]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.648]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.648]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.648]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.648]  - attr(*, "resolved")= logi FALSE
[17:38:07.648]  - attr(*, "total_size")= num 95400
[17:38:07.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.648]  - attr(*, "already-done")= logi TRUE
[17:38:07.659] - copied ‘...future.FUN’ to environment
[17:38:07.659] - reassign environment for ‘x_FUN’
[17:38:07.659] - copied ‘x_FUN’ to environment
[17:38:07.659] - copied ‘times’ to environment
[17:38:07.659] - copied ‘stopf’ to environment
[17:38:07.660] - copied ‘stop_if_not’ to environment
[17:38:07.660] - copied ‘dim’ to environment
[17:38:07.660] - copied ‘valid_types’ to environment
[17:38:07.660] - copied ‘future.call.arguments’ to environment
[17:38:07.660] - copied ‘...future.elements_ii’ to environment
[17:38:07.660] - copied ‘...future.seeds_ii’ to environment
[17:38:07.660] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.660] assign_globals() ... done
[17:38:07.661] requestCore(): workers = 2
[17:38:07.663] MulticoreFuture started
[17:38:07.663] - Launch lazy future ... done
[17:38:07.664] run() for ‘MulticoreFuture’ ... done
[17:38:07.664] Created future:
[17:38:07.665] plan(): Setting new future strategy stack:
[17:38:07.665] List of future strategies:
[17:38:07.665] 1. sequential:
[17:38:07.665]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.665]    - tweaked: FALSE
[17:38:07.665]    - call: NULL
[17:38:07.666] plan(): nbrOfWorkers() = 1
[17:38:07.669] plan(): Setting new future strategy stack:
[17:38:07.669] List of future strategies:
[17:38:07.669] 1. multicore:
[17:38:07.669]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:07.669]    - tweaked: FALSE
[17:38:07.669]    - call: plan(strategy)
[17:38:07.674] plan(): nbrOfWorkers() = 2
[17:38:07.664] MulticoreFuture:
[17:38:07.664] Label: ‘future_vapply-1’
[17:38:07.664] Expression:
[17:38:07.664] {
[17:38:07.664]     do.call(function(...) {
[17:38:07.664]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.664]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.664]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.664]             on.exit(options(oopts), add = TRUE)
[17:38:07.664]         }
[17:38:07.664]         {
[17:38:07.664]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.664]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.664]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.664]             })
[17:38:07.664]         }
[17:38:07.664]     }, args = future.call.arguments)
[17:38:07.664] }
[17:38:07.664] Lazy evaluation: FALSE
[17:38:07.664] Asynchronous evaluation: TRUE
[17:38:07.664] Local evaluation: TRUE
[17:38:07.664] Environment: R_GlobalEnv
[17:38:07.664] Capture standard output: TRUE
[17:38:07.664] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.664] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.664] Packages: 1 packages (‘future.apply’)
[17:38:07.664] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.664] Resolved: TRUE
[17:38:07.664] Value: <not collected>
[17:38:07.664] Conditions captured: <none>
[17:38:07.664] Early signaling: FALSE
[17:38:07.664] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.664] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.675] Chunk #1 of 2 ... DONE
[17:38:07.675] Chunk #2 of 2 ...
[17:38:07.675]  - Finding globals in 'X' for chunk #2 ...
[17:38:07.676] getGlobalsAndPackages() ...
[17:38:07.676] Searching for globals...
[17:38:07.676] 
[17:38:07.676] Searching for globals ... DONE
[17:38:07.677] - globals: [0] <none>
[17:38:07.677] getGlobalsAndPackages() ... DONE
[17:38:07.677]    + additional globals found: [n=0] 
[17:38:07.677]    + additional namespaces needed: [n=0] 
[17:38:07.677]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:07.677]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:07.677]  - seeds: <none>
[17:38:07.677]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.678] getGlobalsAndPackages() ...
[17:38:07.678] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.678] Resolving globals: FALSE
[17:38:07.678] Tweak future expression to call with '...' arguments ...
[17:38:07.678] {
[17:38:07.678]     do.call(function(...) {
[17:38:07.678]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.678]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.678]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.678]             on.exit(options(oopts), add = TRUE)
[17:38:07.678]         }
[17:38:07.678]         {
[17:38:07.678]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.678]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.678]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.678]             })
[17:38:07.678]         }
[17:38:07.678]     }, args = future.call.arguments)
[17:38:07.678] }
[17:38:07.679] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.680] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.680] - packages: [1] ‘future.apply’
[17:38:07.680] getGlobalsAndPackages() ... DONE
[17:38:07.681] run() for ‘Future’ ...
[17:38:07.681] - state: ‘created’
[17:38:07.681] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:07.686] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.686] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:07.686]   - Field: ‘label’
[17:38:07.686]   - Field: ‘local’
[17:38:07.686]   - Field: ‘owner’
[17:38:07.686]   - Field: ‘envir’
[17:38:07.687]   - Field: ‘workers’
[17:38:07.687]   - Field: ‘packages’
[17:38:07.687]   - Field: ‘gc’
[17:38:07.687]   - Field: ‘job’
[17:38:07.687]   - Field: ‘conditions’
[17:38:07.687]   - Field: ‘expr’
[17:38:07.687]   - Field: ‘uuid’
[17:38:07.688]   - Field: ‘seed’
[17:38:07.688]   - Field: ‘version’
[17:38:07.688]   - Field: ‘result’
[17:38:07.688]   - Field: ‘asynchronous’
[17:38:07.688]   - Field: ‘calls’
[17:38:07.688]   - Field: ‘globals’
[17:38:07.689]   - Field: ‘stdout’
[17:38:07.689]   - Field: ‘earlySignal’
[17:38:07.689]   - Field: ‘lazy’
[17:38:07.689]   - Field: ‘state’
[17:38:07.689] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:07.689] - Launch lazy future ...
[17:38:07.690] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:07.690] Packages needed by future strategies (n = 0): <none>
[17:38:07.691] {
[17:38:07.691]     {
[17:38:07.691]         {
[17:38:07.691]             ...future.startTime <- base::Sys.time()
[17:38:07.691]             {
[17:38:07.691]                 {
[17:38:07.691]                   {
[17:38:07.691]                     {
[17:38:07.691]                       {
[17:38:07.691]                         base::local({
[17:38:07.691]                           has_future <- base::requireNamespace("future", 
[17:38:07.691]                             quietly = TRUE)
[17:38:07.691]                           if (has_future) {
[17:38:07.691]                             ns <- base::getNamespace("future")
[17:38:07.691]                             version <- ns[[".package"]][["version"]]
[17:38:07.691]                             if (is.null(version)) 
[17:38:07.691]                               version <- utils::packageVersion("future")
[17:38:07.691]                           }
[17:38:07.691]                           else {
[17:38:07.691]                             version <- NULL
[17:38:07.691]                           }
[17:38:07.691]                           if (!has_future || version < "1.8.0") {
[17:38:07.691]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.691]                               "", base::R.version$version.string), 
[17:38:07.691]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:07.691]                                 base::R.version$platform, 8 * 
[17:38:07.691]                                   base::.Machine$sizeof.pointer), 
[17:38:07.691]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.691]                                 "release", "version")], collapse = " "), 
[17:38:07.691]                               hostname = base::Sys.info()[["nodename"]])
[17:38:07.691]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.691]                               info)
[17:38:07.691]                             info <- base::paste(info, collapse = "; ")
[17:38:07.691]                             if (!has_future) {
[17:38:07.691]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.691]                                 info)
[17:38:07.691]                             }
[17:38:07.691]                             else {
[17:38:07.691]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.691]                                 info, version)
[17:38:07.691]                             }
[17:38:07.691]                             base::stop(msg)
[17:38:07.691]                           }
[17:38:07.691]                         })
[17:38:07.691]                       }
[17:38:07.691]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:07.691]                       base::options(mc.cores = 1L)
[17:38:07.691]                     }
[17:38:07.691]                     base::local({
[17:38:07.691]                       for (pkg in "future.apply") {
[17:38:07.691]                         base::loadNamespace(pkg)
[17:38:07.691]                         base::library(pkg, character.only = TRUE)
[17:38:07.691]                       }
[17:38:07.691]                     })
[17:38:07.691]                   }
[17:38:07.691]                   ...future.strategy.old <- future::plan("list")
[17:38:07.691]                   options(future.plan = NULL)
[17:38:07.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.691]                 }
[17:38:07.691]                 ...future.workdir <- getwd()
[17:38:07.691]             }
[17:38:07.691]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.691]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.691]         }
[17:38:07.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.691]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:07.691]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.691]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.691]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.691]             base::names(...future.oldOptions))
[17:38:07.691]     }
[17:38:07.691]     if (FALSE) {
[17:38:07.691]     }
[17:38:07.691]     else {
[17:38:07.691]         if (TRUE) {
[17:38:07.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.691]                 open = "w")
[17:38:07.691]         }
[17:38:07.691]         else {
[17:38:07.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.691]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.691]         }
[17:38:07.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.691]             base::sink(type = "output", split = FALSE)
[17:38:07.691]             base::close(...future.stdout)
[17:38:07.691]         }, add = TRUE)
[17:38:07.691]     }
[17:38:07.691]     ...future.frame <- base::sys.nframe()
[17:38:07.691]     ...future.conditions <- base::list()
[17:38:07.691]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.691]     if (FALSE) {
[17:38:07.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.691]     }
[17:38:07.691]     ...future.result <- base::tryCatch({
[17:38:07.691]         base::withCallingHandlers({
[17:38:07.691]             ...future.value <- base::withVisible(base::local({
[17:38:07.691]                 withCallingHandlers({
[17:38:07.691]                   {
[17:38:07.691]                     do.call(function(...) {
[17:38:07.691]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.691]                       if (!identical(...future.globals.maxSize.org, 
[17:38:07.691]                         ...future.globals.maxSize)) {
[17:38:07.691]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.691]                         on.exit(options(oopts), add = TRUE)
[17:38:07.691]                       }
[17:38:07.691]                       {
[17:38:07.691]                         lapply(seq_along(...future.elements_ii), 
[17:38:07.691]                           FUN = function(jj) {
[17:38:07.691]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.691]                             ...future.FUN(...future.X_jj, ...)
[17:38:07.691]                           })
[17:38:07.691]                       }
[17:38:07.691]                     }, args = future.call.arguments)
[17:38:07.691]                   }
[17:38:07.691]                 }, immediateCondition = function(cond) {
[17:38:07.691]                   save_rds <- function (object, pathname, ...) 
[17:38:07.691]                   {
[17:38:07.691]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:07.691]                     if (file_test("-f", pathname_tmp)) {
[17:38:07.691]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.691]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:07.691]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.691]                         fi_tmp[["mtime"]])
[17:38:07.691]                     }
[17:38:07.691]                     tryCatch({
[17:38:07.691]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:07.691]                     }, error = function(ex) {
[17:38:07.691]                       msg <- conditionMessage(ex)
[17:38:07.691]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.691]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:07.691]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.691]                         fi_tmp[["mtime"]], msg)
[17:38:07.691]                       ex$message <- msg
[17:38:07.691]                       stop(ex)
[17:38:07.691]                     })
[17:38:07.691]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:07.691]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:07.691]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:07.691]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.691]                       fi <- file.info(pathname)
[17:38:07.691]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:07.691]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.691]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:07.691]                         fi[["size"]], fi[["mtime"]])
[17:38:07.691]                       stop(msg)
[17:38:07.691]                     }
[17:38:07.691]                     invisible(pathname)
[17:38:07.691]                   }
[17:38:07.691]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:07.691]                     rootPath = tempdir()) 
[17:38:07.691]                   {
[17:38:07.691]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:07.691]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:07.691]                       tmpdir = path, fileext = ".rds")
[17:38:07.691]                     save_rds(obj, file)
[17:38:07.691]                   }
[17:38:07.691]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:07.691]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.691]                   {
[17:38:07.691]                     inherits <- base::inherits
[17:38:07.691]                     invokeRestart <- base::invokeRestart
[17:38:07.691]                     is.null <- base::is.null
[17:38:07.691]                     muffled <- FALSE
[17:38:07.691]                     if (inherits(cond, "message")) {
[17:38:07.691]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:07.691]                       if (muffled) 
[17:38:07.691]                         invokeRestart("muffleMessage")
[17:38:07.691]                     }
[17:38:07.691]                     else if (inherits(cond, "warning")) {
[17:38:07.691]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:07.691]                       if (muffled) 
[17:38:07.691]                         invokeRestart("muffleWarning")
[17:38:07.691]                     }
[17:38:07.691]                     else if (inherits(cond, "condition")) {
[17:38:07.691]                       if (!is.null(pattern)) {
[17:38:07.691]                         computeRestarts <- base::computeRestarts
[17:38:07.691]                         grepl <- base::grepl
[17:38:07.691]                         restarts <- computeRestarts(cond)
[17:38:07.691]                         for (restart in restarts) {
[17:38:07.691]                           name <- restart$name
[17:38:07.691]                           if (is.null(name)) 
[17:38:07.691]                             next
[17:38:07.691]                           if (!grepl(pattern, name)) 
[17:38:07.691]                             next
[17:38:07.691]                           invokeRestart(restart)
[17:38:07.691]                           muffled <- TRUE
[17:38:07.691]                           break
[17:38:07.691]                         }
[17:38:07.691]                       }
[17:38:07.691]                     }
[17:38:07.691]                     invisible(muffled)
[17:38:07.691]                   }
[17:38:07.691]                   muffleCondition(cond)
[17:38:07.691]                 })
[17:38:07.691]             }))
[17:38:07.691]             future::FutureResult(value = ...future.value$value, 
[17:38:07.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.691]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.691]                     ...future.globalenv.names))
[17:38:07.691]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.691]         }, condition = base::local({
[17:38:07.691]             c <- base::c
[17:38:07.691]             inherits <- base::inherits
[17:38:07.691]             invokeRestart <- base::invokeRestart
[17:38:07.691]             length <- base::length
[17:38:07.691]             list <- base::list
[17:38:07.691]             seq.int <- base::seq.int
[17:38:07.691]             signalCondition <- base::signalCondition
[17:38:07.691]             sys.calls <- base::sys.calls
[17:38:07.691]             `[[` <- base::`[[`
[17:38:07.691]             `+` <- base::`+`
[17:38:07.691]             `<<-` <- base::`<<-`
[17:38:07.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.691]                   3L)]
[17:38:07.691]             }
[17:38:07.691]             function(cond) {
[17:38:07.691]                 is_error <- inherits(cond, "error")
[17:38:07.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.691]                   NULL)
[17:38:07.691]                 if (is_error) {
[17:38:07.691]                   sessionInformation <- function() {
[17:38:07.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.691]                       search = base::search(), system = base::Sys.info())
[17:38:07.691]                   }
[17:38:07.691]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.691]                     cond$call), session = sessionInformation(), 
[17:38:07.691]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.691]                   signalCondition(cond)
[17:38:07.691]                 }
[17:38:07.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.691]                 "immediateCondition"))) {
[17:38:07.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.691]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.691]                   if (TRUE && !signal) {
[17:38:07.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.691]                     {
[17:38:07.691]                       inherits <- base::inherits
[17:38:07.691]                       invokeRestart <- base::invokeRestart
[17:38:07.691]                       is.null <- base::is.null
[17:38:07.691]                       muffled <- FALSE
[17:38:07.691]                       if (inherits(cond, "message")) {
[17:38:07.691]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.691]                         if (muffled) 
[17:38:07.691]                           invokeRestart("muffleMessage")
[17:38:07.691]                       }
[17:38:07.691]                       else if (inherits(cond, "warning")) {
[17:38:07.691]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.691]                         if (muffled) 
[17:38:07.691]                           invokeRestart("muffleWarning")
[17:38:07.691]                       }
[17:38:07.691]                       else if (inherits(cond, "condition")) {
[17:38:07.691]                         if (!is.null(pattern)) {
[17:38:07.691]                           computeRestarts <- base::computeRestarts
[17:38:07.691]                           grepl <- base::grepl
[17:38:07.691]                           restarts <- computeRestarts(cond)
[17:38:07.691]                           for (restart in restarts) {
[17:38:07.691]                             name <- restart$name
[17:38:07.691]                             if (is.null(name)) 
[17:38:07.691]                               next
[17:38:07.691]                             if (!grepl(pattern, name)) 
[17:38:07.691]                               next
[17:38:07.691]                             invokeRestart(restart)
[17:38:07.691]                             muffled <- TRUE
[17:38:07.691]                             break
[17:38:07.691]                           }
[17:38:07.691]                         }
[17:38:07.691]                       }
[17:38:07.691]                       invisible(muffled)
[17:38:07.691]                     }
[17:38:07.691]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.691]                   }
[17:38:07.691]                 }
[17:38:07.691]                 else {
[17:38:07.691]                   if (TRUE) {
[17:38:07.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.691]                     {
[17:38:07.691]                       inherits <- base::inherits
[17:38:07.691]                       invokeRestart <- base::invokeRestart
[17:38:07.691]                       is.null <- base::is.null
[17:38:07.691]                       muffled <- FALSE
[17:38:07.691]                       if (inherits(cond, "message")) {
[17:38:07.691]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.691]                         if (muffled) 
[17:38:07.691]                           invokeRestart("muffleMessage")
[17:38:07.691]                       }
[17:38:07.691]                       else if (inherits(cond, "warning")) {
[17:38:07.691]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.691]                         if (muffled) 
[17:38:07.691]                           invokeRestart("muffleWarning")
[17:38:07.691]                       }
[17:38:07.691]                       else if (inherits(cond, "condition")) {
[17:38:07.691]                         if (!is.null(pattern)) {
[17:38:07.691]                           computeRestarts <- base::computeRestarts
[17:38:07.691]                           grepl <- base::grepl
[17:38:07.691]                           restarts <- computeRestarts(cond)
[17:38:07.691]                           for (restart in restarts) {
[17:38:07.691]                             name <- restart$name
[17:38:07.691]                             if (is.null(name)) 
[17:38:07.691]                               next
[17:38:07.691]                             if (!grepl(pattern, name)) 
[17:38:07.691]                               next
[17:38:07.691]                             invokeRestart(restart)
[17:38:07.691]                             muffled <- TRUE
[17:38:07.691]                             break
[17:38:07.691]                           }
[17:38:07.691]                         }
[17:38:07.691]                       }
[17:38:07.691]                       invisible(muffled)
[17:38:07.691]                     }
[17:38:07.691]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.691]                   }
[17:38:07.691]                 }
[17:38:07.691]             }
[17:38:07.691]         }))
[17:38:07.691]     }, error = function(ex) {
[17:38:07.691]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.691]                 ...future.rng), started = ...future.startTime, 
[17:38:07.691]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.691]             version = "1.8"), class = "FutureResult")
[17:38:07.691]     }, finally = {
[17:38:07.691]         if (!identical(...future.workdir, getwd())) 
[17:38:07.691]             setwd(...future.workdir)
[17:38:07.691]         {
[17:38:07.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.691]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.691]             }
[17:38:07.691]             base::options(...future.oldOptions)
[17:38:07.691]             if (.Platform$OS.type == "windows") {
[17:38:07.691]                 old_names <- names(...future.oldEnvVars)
[17:38:07.691]                 envs <- base::Sys.getenv()
[17:38:07.691]                 names <- names(envs)
[17:38:07.691]                 common <- intersect(names, old_names)
[17:38:07.691]                 added <- setdiff(names, old_names)
[17:38:07.691]                 removed <- setdiff(old_names, names)
[17:38:07.691]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.691]                   envs[common]]
[17:38:07.691]                 NAMES <- toupper(changed)
[17:38:07.691]                 args <- list()
[17:38:07.691]                 for (kk in seq_along(NAMES)) {
[17:38:07.691]                   name <- changed[[kk]]
[17:38:07.691]                   NAME <- NAMES[[kk]]
[17:38:07.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.691]                     next
[17:38:07.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.691]                 }
[17:38:07.691]                 NAMES <- toupper(added)
[17:38:07.691]                 for (kk in seq_along(NAMES)) {
[17:38:07.691]                   name <- added[[kk]]
[17:38:07.691]                   NAME <- NAMES[[kk]]
[17:38:07.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.691]                     next
[17:38:07.691]                   args[[name]] <- ""
[17:38:07.691]                 }
[17:38:07.691]                 NAMES <- toupper(removed)
[17:38:07.691]                 for (kk in seq_along(NAMES)) {
[17:38:07.691]                   name <- removed[[kk]]
[17:38:07.691]                   NAME <- NAMES[[kk]]
[17:38:07.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.691]                     next
[17:38:07.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.691]                 }
[17:38:07.691]                 if (length(args) > 0) 
[17:38:07.691]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.691]             }
[17:38:07.691]             else {
[17:38:07.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.691]             }
[17:38:07.691]             {
[17:38:07.691]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.691]                   0L) {
[17:38:07.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.691]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.691]                   base::options(opts)
[17:38:07.691]                 }
[17:38:07.691]                 {
[17:38:07.691]                   {
[17:38:07.691]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:07.691]                     NULL
[17:38:07.691]                   }
[17:38:07.691]                   options(future.plan = NULL)
[17:38:07.691]                   if (is.na(NA_character_)) 
[17:38:07.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.691]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.691]                     .init = FALSE)
[17:38:07.691]                 }
[17:38:07.691]             }
[17:38:07.691]         }
[17:38:07.691]     })
[17:38:07.691]     if (TRUE) {
[17:38:07.691]         base::sink(type = "output", split = FALSE)
[17:38:07.691]         if (TRUE) {
[17:38:07.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.691]         }
[17:38:07.691]         else {
[17:38:07.691]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.691]         }
[17:38:07.691]         base::close(...future.stdout)
[17:38:07.691]         ...future.stdout <- NULL
[17:38:07.691]     }
[17:38:07.691]     ...future.result$conditions <- ...future.conditions
[17:38:07.691]     ...future.result$finished <- base::Sys.time()
[17:38:07.691]     ...future.result
[17:38:07.691] }
[17:38:07.694] assign_globals() ...
[17:38:07.694] List of 11
[17:38:07.694]  $ ...future.FUN            :function (x, ...)  
[17:38:07.694]  $ x_FUN                    :function (x)  
[17:38:07.694]  $ times                    : int 0
[17:38:07.694]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.694]  $ stop_if_not              :function (...)  
[17:38:07.694]  $ dim                      : NULL
[17:38:07.694]  $ valid_types              : chr [1:2] "logical" "integer"
[17:38:07.694]  $ future.call.arguments    : list()
[17:38:07.694]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.694]  $ ...future.elements_ii    :List of 5
[17:38:07.694]   ..$ : int 6
[17:38:07.694]   ..$ : int 7
[17:38:07.694]   ..$ : int 8
[17:38:07.694]   ..$ : int 9
[17:38:07.694]   ..$ : int 10
[17:38:07.694]  $ ...future.seeds_ii       : NULL
[17:38:07.694]  $ ...future.globals.maxSize: NULL
[17:38:07.694]  - attr(*, "where")=List of 11
[17:38:07.694]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.694]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.694]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.694]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.694]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.694]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.694]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.694]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.694]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.694]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.694]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.694]  - attr(*, "resolved")= logi FALSE
[17:38:07.694]  - attr(*, "total_size")= num 95400
[17:38:07.694]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.694]  - attr(*, "already-done")= logi TRUE
[17:38:07.710] - copied ‘...future.FUN’ to environment
[17:38:07.711] - reassign environment for ‘x_FUN’
[17:38:07.711] - copied ‘x_FUN’ to environment
[17:38:07.711] - copied ‘times’ to environment
[17:38:07.711] - copied ‘stopf’ to environment
[17:38:07.711] - copied ‘stop_if_not’ to environment
[17:38:07.712] - copied ‘dim’ to environment
[17:38:07.712] - copied ‘valid_types’ to environment
[17:38:07.712] - copied ‘future.call.arguments’ to environment
[17:38:07.712] - copied ‘...future.elements_ii’ to environment
[17:38:07.712] - copied ‘...future.seeds_ii’ to environment
[17:38:07.712] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.712] assign_globals() ... done
[17:38:07.713] requestCore(): workers = 2
[17:38:07.715] MulticoreFuture started
[17:38:07.716] - Launch lazy future ... done
[17:38:07.716] run() for ‘MulticoreFuture’ ... done
[17:38:07.716] Created future:
[17:38:07.717] plan(): Setting new future strategy stack:
[17:38:07.717] List of future strategies:
[17:38:07.717] 1. sequential:
[17:38:07.717]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.717]    - tweaked: FALSE
[17:38:07.717]    - call: NULL
[17:38:07.718] plan(): nbrOfWorkers() = 1
[17:38:07.721] plan(): Setting new future strategy stack:
[17:38:07.721] List of future strategies:
[17:38:07.721] 1. multicore:
[17:38:07.721]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:07.721]    - tweaked: FALSE
[17:38:07.721]    - call: plan(strategy)
[17:38:07.726] plan(): nbrOfWorkers() = 2
[17:38:07.717] MulticoreFuture:
[17:38:07.717] Label: ‘future_vapply-2’
[17:38:07.717] Expression:
[17:38:07.717] {
[17:38:07.717]     do.call(function(...) {
[17:38:07.717]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.717]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.717]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.717]             on.exit(options(oopts), add = TRUE)
[17:38:07.717]         }
[17:38:07.717]         {
[17:38:07.717]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.717]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.717]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.717]             })
[17:38:07.717]         }
[17:38:07.717]     }, args = future.call.arguments)
[17:38:07.717] }
[17:38:07.717] Lazy evaluation: FALSE
[17:38:07.717] Asynchronous evaluation: TRUE
[17:38:07.717] Local evaluation: TRUE
[17:38:07.717] Environment: R_GlobalEnv
[17:38:07.717] Capture standard output: TRUE
[17:38:07.717] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.717] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.717] Packages: 1 packages (‘future.apply’)
[17:38:07.717] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.717] Resolved: TRUE
[17:38:07.717] Value: <not collected>
[17:38:07.717] Conditions captured: <none>
[17:38:07.717] Early signaling: FALSE
[17:38:07.717] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.717] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.727] Chunk #2 of 2 ... DONE
[17:38:07.727] Launching 2 futures (chunks) ... DONE
[17:38:07.728] Resolving 2 futures (chunks) ...
[17:38:07.728] resolve() on list ...
[17:38:07.728]  recursive: 0
[17:38:07.728]  length: 2
[17:38:07.728] 
[17:38:07.729] Future #1
[17:38:07.729] result() for MulticoreFuture ...
[17:38:07.730] result() for MulticoreFuture ...
[17:38:07.730] result() for MulticoreFuture ... done
[17:38:07.730] result() for MulticoreFuture ... done
[17:38:07.730] result() for MulticoreFuture ...
[17:38:07.730] result() for MulticoreFuture ... done
[17:38:07.731] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:07.731] - nx: 2
[17:38:07.731] - relay: TRUE
[17:38:07.731] - stdout: TRUE
[17:38:07.731] - signal: TRUE
[17:38:07.731] - resignal: FALSE
[17:38:07.731] - force: TRUE
[17:38:07.732] - relayed: [n=2] FALSE, FALSE
[17:38:07.732] - queued futures: [n=2] FALSE, FALSE
[17:38:07.732]  - until=1
[17:38:07.732]  - relaying element #1
[17:38:07.732] result() for MulticoreFuture ...
[17:38:07.732] result() for MulticoreFuture ... done
[17:38:07.733] result() for MulticoreFuture ...
[17:38:07.733] result() for MulticoreFuture ... done
[17:38:07.733] result() for MulticoreFuture ...
[17:38:07.733] result() for MulticoreFuture ... done
[17:38:07.733] result() for MulticoreFuture ...
[17:38:07.733] result() for MulticoreFuture ... done
[17:38:07.734] - relayed: [n=2] TRUE, FALSE
[17:38:07.734] - queued futures: [n=2] TRUE, FALSE
[17:38:07.734] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:07.734]  length: 1 (resolved future 1)
[17:38:07.735] Future #2
[17:38:07.735] result() for MulticoreFuture ...
[17:38:07.735] result() for MulticoreFuture ...
[17:38:07.736] result() for MulticoreFuture ... done
[17:38:07.736] result() for MulticoreFuture ... done
[17:38:07.736] result() for MulticoreFuture ...
[17:38:07.736] result() for MulticoreFuture ... done
[17:38:07.736] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:07.736] - nx: 2
[17:38:07.737] - relay: TRUE
[17:38:07.737] - stdout: TRUE
[17:38:07.737] - signal: TRUE
[17:38:07.737] - resignal: FALSE
[17:38:07.737] - force: TRUE
[17:38:07.737] - relayed: [n=2] TRUE, FALSE
[17:38:07.737] - queued futures: [n=2] TRUE, FALSE
[17:38:07.737]  - until=2
[17:38:07.738]  - relaying element #2
[17:38:07.738] result() for MulticoreFuture ...
[17:38:07.738] result() for MulticoreFuture ... done
[17:38:07.738] result() for MulticoreFuture ...
[17:38:07.738] result() for MulticoreFuture ... done
[17:38:07.738] result() for MulticoreFuture ...
[17:38:07.738] result() for MulticoreFuture ... done
[17:38:07.738] result() for MulticoreFuture ...
[17:38:07.739] result() for MulticoreFuture ... done
[17:38:07.739] - relayed: [n=2] TRUE, TRUE
[17:38:07.739] - queued futures: [n=2] TRUE, TRUE
[17:38:07.739] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:07.739]  length: 0 (resolved future 2)
[17:38:07.739] Relaying remaining futures
[17:38:07.739] signalConditionsASAP(NULL, pos=0) ...
[17:38:07.739] - nx: 2
[17:38:07.739] - relay: TRUE
[17:38:07.740] - stdout: TRUE
[17:38:07.740] - signal: TRUE
[17:38:07.740] - resignal: FALSE
[17:38:07.740] - force: TRUE
[17:38:07.740] - relayed: [n=2] TRUE, TRUE
[17:38:07.740] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:07.740] - relayed: [n=2] TRUE, TRUE
[17:38:07.740] - queued futures: [n=2] TRUE, TRUE
[17:38:07.741] signalConditionsASAP(NULL, pos=0) ... done
[17:38:07.741] resolve() on list ... DONE
[17:38:07.741] result() for MulticoreFuture ...
[17:38:07.741] result() for MulticoreFuture ... done
[17:38:07.741] result() for MulticoreFuture ...
[17:38:07.741] result() for MulticoreFuture ... done
[17:38:07.741] result() for MulticoreFuture ...
[17:38:07.741] result() for MulticoreFuture ... done
[17:38:07.741] result() for MulticoreFuture ...
[17:38:07.742] result() for MulticoreFuture ... done
[17:38:07.742]  - Number of value chunks collected: 2
[17:38:07.742] Resolving 2 futures (chunks) ... DONE
[17:38:07.742] Reducing values from 2 chunks ...
[17:38:07.742]  - Number of values collected after concatenation: 10
[17:38:07.742]  - Number of values expected: 10
[17:38:07.742] Reducing values from 2 chunks ... DONE
[17:38:07.742] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[17:38:07.744] future_lapply() ...
[17:38:07.751] Number of chunks: 2
[17:38:07.751] getGlobalsAndPackagesXApply() ...
[17:38:07.751]  - future.globals: TRUE
[17:38:07.751] getGlobalsAndPackages() ...
[17:38:07.751] Searching for globals...
[17:38:07.758] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:07.759] Searching for globals ... DONE
[17:38:07.759] Resolving globals: FALSE
[17:38:07.760] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[17:38:07.760] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:07.761] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.761] - packages: [1] ‘future.apply’
[17:38:07.761] getGlobalsAndPackages() ... DONE
[17:38:07.761]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.761]  - needed namespaces: [n=1] ‘future.apply’
[17:38:07.761] Finding globals ... DONE
[17:38:07.761]  - use_args: TRUE
[17:38:07.761]  - Getting '...' globals ...
[17:38:07.762] resolve() on list ...
[17:38:07.762]  recursive: 0
[17:38:07.762]  length: 1
[17:38:07.762]  elements: ‘...’
[17:38:07.762]  length: 0 (resolved future 1)
[17:38:07.762] resolve() on list ... DONE
[17:38:07.763]    - '...' content: [n=0] 
[17:38:07.763] List of 1
[17:38:07.763]  $ ...: list()
[17:38:07.763]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.763]  - attr(*, "where")=List of 1
[17:38:07.763]   ..$ ...:<environment: 0x56080185b1e0> 
[17:38:07.763]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.763]  - attr(*, "resolved")= logi TRUE
[17:38:07.763]  - attr(*, "total_size")= num NA
[17:38:07.765]  - Getting '...' globals ... DONE
[17:38:07.766] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:07.766] List of 8
[17:38:07.766]  $ ...future.FUN:function (x, ...)  
[17:38:07.766]  $ x_FUN        :function (x)  
[17:38:07.766]  $ times        : int 1
[17:38:07.766]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.766]  $ stop_if_not  :function (...)  
[17:38:07.766]  $ dim          : NULL
[17:38:07.766]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:07.766]  $ ...          : list()
[17:38:07.766]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.766]  - attr(*, "where")=List of 8
[17:38:07.766]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:07.766]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:07.766]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:07.766]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:07.766]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:07.766]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:07.766]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:07.766]   ..$ ...          :<environment: 0x56080185b1e0> 
[17:38:07.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.766]  - attr(*, "resolved")= logi FALSE
[17:38:07.766]  - attr(*, "total_size")= num 94336
[17:38:07.771] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:07.772] getGlobalsAndPackagesXApply() ... DONE
[17:38:07.772] Number of futures (= number of chunks): 2
[17:38:07.772] Launching 2 futures (chunks) ...
[17:38:07.772] Chunk #1 of 2 ...
[17:38:07.772]  - Finding globals in 'X' for chunk #1 ...
[17:38:07.772] getGlobalsAndPackages() ...
[17:38:07.772] Searching for globals...
[17:38:07.773] 
[17:38:07.773] Searching for globals ... DONE
[17:38:07.773] - globals: [0] <none>
[17:38:07.773] getGlobalsAndPackages() ... DONE
[17:38:07.773]    + additional globals found: [n=0] 
[17:38:07.773]    + additional namespaces needed: [n=0] 
[17:38:07.773]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:07.773]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:07.774]  - seeds: <none>
[17:38:07.774]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.774] getGlobalsAndPackages() ...
[17:38:07.774] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.774] Resolving globals: FALSE
[17:38:07.774] Tweak future expression to call with '...' arguments ...
[17:38:07.774] {
[17:38:07.774]     do.call(function(...) {
[17:38:07.774]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.774]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.774]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.774]             on.exit(options(oopts), add = TRUE)
[17:38:07.774]         }
[17:38:07.774]         {
[17:38:07.774]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.774]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.774]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.774]             })
[17:38:07.774]         }
[17:38:07.774]     }, args = future.call.arguments)
[17:38:07.774] }
[17:38:07.775] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.775] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.775] - packages: [1] ‘future.apply’
[17:38:07.775] getGlobalsAndPackages() ... DONE
[17:38:07.776] run() for ‘Future’ ...
[17:38:07.776] - state: ‘created’
[17:38:07.776] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:07.780] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.780] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:07.780]   - Field: ‘label’
[17:38:07.780]   - Field: ‘local’
[17:38:07.780]   - Field: ‘owner’
[17:38:07.780]   - Field: ‘envir’
[17:38:07.781]   - Field: ‘workers’
[17:38:07.781]   - Field: ‘packages’
[17:38:07.781]   - Field: ‘gc’
[17:38:07.781]   - Field: ‘job’
[17:38:07.781]   - Field: ‘conditions’
[17:38:07.781]   - Field: ‘expr’
[17:38:07.781]   - Field: ‘uuid’
[17:38:07.781]   - Field: ‘seed’
[17:38:07.781]   - Field: ‘version’
[17:38:07.781]   - Field: ‘result’
[17:38:07.781]   - Field: ‘asynchronous’
[17:38:07.782]   - Field: ‘calls’
[17:38:07.784]   - Field: ‘globals’
[17:38:07.784]   - Field: ‘stdout’
[17:38:07.784]   - Field: ‘earlySignal’
[17:38:07.784]   - Field: ‘lazy’
[17:38:07.784]   - Field: ‘state’
[17:38:07.784] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:07.784] - Launch lazy future ...
[17:38:07.785] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:07.785] Packages needed by future strategies (n = 0): <none>
[17:38:07.786] {
[17:38:07.786]     {
[17:38:07.786]         {
[17:38:07.786]             ...future.startTime <- base::Sys.time()
[17:38:07.786]             {
[17:38:07.786]                 {
[17:38:07.786]                   {
[17:38:07.786]                     {
[17:38:07.786]                       {
[17:38:07.786]                         base::local({
[17:38:07.786]                           has_future <- base::requireNamespace("future", 
[17:38:07.786]                             quietly = TRUE)
[17:38:07.786]                           if (has_future) {
[17:38:07.786]                             ns <- base::getNamespace("future")
[17:38:07.786]                             version <- ns[[".package"]][["version"]]
[17:38:07.786]                             if (is.null(version)) 
[17:38:07.786]                               version <- utils::packageVersion("future")
[17:38:07.786]                           }
[17:38:07.786]                           else {
[17:38:07.786]                             version <- NULL
[17:38:07.786]                           }
[17:38:07.786]                           if (!has_future || version < "1.8.0") {
[17:38:07.786]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.786]                               "", base::R.version$version.string), 
[17:38:07.786]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:07.786]                                 base::R.version$platform, 8 * 
[17:38:07.786]                                   base::.Machine$sizeof.pointer), 
[17:38:07.786]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.786]                                 "release", "version")], collapse = " "), 
[17:38:07.786]                               hostname = base::Sys.info()[["nodename"]])
[17:38:07.786]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.786]                               info)
[17:38:07.786]                             info <- base::paste(info, collapse = "; ")
[17:38:07.786]                             if (!has_future) {
[17:38:07.786]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.786]                                 info)
[17:38:07.786]                             }
[17:38:07.786]                             else {
[17:38:07.786]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.786]                                 info, version)
[17:38:07.786]                             }
[17:38:07.786]                             base::stop(msg)
[17:38:07.786]                           }
[17:38:07.786]                         })
[17:38:07.786]                       }
[17:38:07.786]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:07.786]                       base::options(mc.cores = 1L)
[17:38:07.786]                     }
[17:38:07.786]                     base::local({
[17:38:07.786]                       for (pkg in "future.apply") {
[17:38:07.786]                         base::loadNamespace(pkg)
[17:38:07.786]                         base::library(pkg, character.only = TRUE)
[17:38:07.786]                       }
[17:38:07.786]                     })
[17:38:07.786]                   }
[17:38:07.786]                   ...future.strategy.old <- future::plan("list")
[17:38:07.786]                   options(future.plan = NULL)
[17:38:07.786]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.786]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.786]                 }
[17:38:07.786]                 ...future.workdir <- getwd()
[17:38:07.786]             }
[17:38:07.786]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.786]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.786]         }
[17:38:07.786]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.786]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:07.786]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.786]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.786]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.786]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.786]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.786]             base::names(...future.oldOptions))
[17:38:07.786]     }
[17:38:07.786]     if (FALSE) {
[17:38:07.786]     }
[17:38:07.786]     else {
[17:38:07.786]         if (TRUE) {
[17:38:07.786]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.786]                 open = "w")
[17:38:07.786]         }
[17:38:07.786]         else {
[17:38:07.786]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.786]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.786]         }
[17:38:07.786]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.786]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.786]             base::sink(type = "output", split = FALSE)
[17:38:07.786]             base::close(...future.stdout)
[17:38:07.786]         }, add = TRUE)
[17:38:07.786]     }
[17:38:07.786]     ...future.frame <- base::sys.nframe()
[17:38:07.786]     ...future.conditions <- base::list()
[17:38:07.786]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.786]     if (FALSE) {
[17:38:07.786]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.786]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.786]     }
[17:38:07.786]     ...future.result <- base::tryCatch({
[17:38:07.786]         base::withCallingHandlers({
[17:38:07.786]             ...future.value <- base::withVisible(base::local({
[17:38:07.786]                 withCallingHandlers({
[17:38:07.786]                   {
[17:38:07.786]                     do.call(function(...) {
[17:38:07.786]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.786]                       if (!identical(...future.globals.maxSize.org, 
[17:38:07.786]                         ...future.globals.maxSize)) {
[17:38:07.786]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.786]                         on.exit(options(oopts), add = TRUE)
[17:38:07.786]                       }
[17:38:07.786]                       {
[17:38:07.786]                         lapply(seq_along(...future.elements_ii), 
[17:38:07.786]                           FUN = function(jj) {
[17:38:07.786]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.786]                             ...future.FUN(...future.X_jj, ...)
[17:38:07.786]                           })
[17:38:07.786]                       }
[17:38:07.786]                     }, args = future.call.arguments)
[17:38:07.786]                   }
[17:38:07.786]                 }, immediateCondition = function(cond) {
[17:38:07.786]                   save_rds <- function (object, pathname, ...) 
[17:38:07.786]                   {
[17:38:07.786]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:07.786]                     if (file_test("-f", pathname_tmp)) {
[17:38:07.786]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.786]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:07.786]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.786]                         fi_tmp[["mtime"]])
[17:38:07.786]                     }
[17:38:07.786]                     tryCatch({
[17:38:07.786]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:07.786]                     }, error = function(ex) {
[17:38:07.786]                       msg <- conditionMessage(ex)
[17:38:07.786]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.786]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:07.786]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.786]                         fi_tmp[["mtime"]], msg)
[17:38:07.786]                       ex$message <- msg
[17:38:07.786]                       stop(ex)
[17:38:07.786]                     })
[17:38:07.786]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:07.786]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:07.786]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:07.786]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.786]                       fi <- file.info(pathname)
[17:38:07.786]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:07.786]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.786]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:07.786]                         fi[["size"]], fi[["mtime"]])
[17:38:07.786]                       stop(msg)
[17:38:07.786]                     }
[17:38:07.786]                     invisible(pathname)
[17:38:07.786]                   }
[17:38:07.786]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:07.786]                     rootPath = tempdir()) 
[17:38:07.786]                   {
[17:38:07.786]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:07.786]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:07.786]                       tmpdir = path, fileext = ".rds")
[17:38:07.786]                     save_rds(obj, file)
[17:38:07.786]                   }
[17:38:07.786]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:07.786]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.786]                   {
[17:38:07.786]                     inherits <- base::inherits
[17:38:07.786]                     invokeRestart <- base::invokeRestart
[17:38:07.786]                     is.null <- base::is.null
[17:38:07.786]                     muffled <- FALSE
[17:38:07.786]                     if (inherits(cond, "message")) {
[17:38:07.786]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:07.786]                       if (muffled) 
[17:38:07.786]                         invokeRestart("muffleMessage")
[17:38:07.786]                     }
[17:38:07.786]                     else if (inherits(cond, "warning")) {
[17:38:07.786]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:07.786]                       if (muffled) 
[17:38:07.786]                         invokeRestart("muffleWarning")
[17:38:07.786]                     }
[17:38:07.786]                     else if (inherits(cond, "condition")) {
[17:38:07.786]                       if (!is.null(pattern)) {
[17:38:07.786]                         computeRestarts <- base::computeRestarts
[17:38:07.786]                         grepl <- base::grepl
[17:38:07.786]                         restarts <- computeRestarts(cond)
[17:38:07.786]                         for (restart in restarts) {
[17:38:07.786]                           name <- restart$name
[17:38:07.786]                           if (is.null(name)) 
[17:38:07.786]                             next
[17:38:07.786]                           if (!grepl(pattern, name)) 
[17:38:07.786]                             next
[17:38:07.786]                           invokeRestart(restart)
[17:38:07.786]                           muffled <- TRUE
[17:38:07.786]                           break
[17:38:07.786]                         }
[17:38:07.786]                       }
[17:38:07.786]                     }
[17:38:07.786]                     invisible(muffled)
[17:38:07.786]                   }
[17:38:07.786]                   muffleCondition(cond)
[17:38:07.786]                 })
[17:38:07.786]             }))
[17:38:07.786]             future::FutureResult(value = ...future.value$value, 
[17:38:07.786]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.786]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.786]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.786]                     ...future.globalenv.names))
[17:38:07.786]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.786]         }, condition = base::local({
[17:38:07.786]             c <- base::c
[17:38:07.786]             inherits <- base::inherits
[17:38:07.786]             invokeRestart <- base::invokeRestart
[17:38:07.786]             length <- base::length
[17:38:07.786]             list <- base::list
[17:38:07.786]             seq.int <- base::seq.int
[17:38:07.786]             signalCondition <- base::signalCondition
[17:38:07.786]             sys.calls <- base::sys.calls
[17:38:07.786]             `[[` <- base::`[[`
[17:38:07.786]             `+` <- base::`+`
[17:38:07.786]             `<<-` <- base::`<<-`
[17:38:07.786]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.786]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.786]                   3L)]
[17:38:07.786]             }
[17:38:07.786]             function(cond) {
[17:38:07.786]                 is_error <- inherits(cond, "error")
[17:38:07.786]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.786]                   NULL)
[17:38:07.786]                 if (is_error) {
[17:38:07.786]                   sessionInformation <- function() {
[17:38:07.786]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.786]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.786]                       search = base::search(), system = base::Sys.info())
[17:38:07.786]                   }
[17:38:07.786]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.786]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.786]                     cond$call), session = sessionInformation(), 
[17:38:07.786]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.786]                   signalCondition(cond)
[17:38:07.786]                 }
[17:38:07.786]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.786]                 "immediateCondition"))) {
[17:38:07.786]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.786]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.786]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.786]                   if (TRUE && !signal) {
[17:38:07.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.786]                     {
[17:38:07.786]                       inherits <- base::inherits
[17:38:07.786]                       invokeRestart <- base::invokeRestart
[17:38:07.786]                       is.null <- base::is.null
[17:38:07.786]                       muffled <- FALSE
[17:38:07.786]                       if (inherits(cond, "message")) {
[17:38:07.786]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.786]                         if (muffled) 
[17:38:07.786]                           invokeRestart("muffleMessage")
[17:38:07.786]                       }
[17:38:07.786]                       else if (inherits(cond, "warning")) {
[17:38:07.786]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.786]                         if (muffled) 
[17:38:07.786]                           invokeRestart("muffleWarning")
[17:38:07.786]                       }
[17:38:07.786]                       else if (inherits(cond, "condition")) {
[17:38:07.786]                         if (!is.null(pattern)) {
[17:38:07.786]                           computeRestarts <- base::computeRestarts
[17:38:07.786]                           grepl <- base::grepl
[17:38:07.786]                           restarts <- computeRestarts(cond)
[17:38:07.786]                           for (restart in restarts) {
[17:38:07.786]                             name <- restart$name
[17:38:07.786]                             if (is.null(name)) 
[17:38:07.786]                               next
[17:38:07.786]                             if (!grepl(pattern, name)) 
[17:38:07.786]                               next
[17:38:07.786]                             invokeRestart(restart)
[17:38:07.786]                             muffled <- TRUE
[17:38:07.786]                             break
[17:38:07.786]                           }
[17:38:07.786]                         }
[17:38:07.786]                       }
[17:38:07.786]                       invisible(muffled)
[17:38:07.786]                     }
[17:38:07.786]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.786]                   }
[17:38:07.786]                 }
[17:38:07.786]                 else {
[17:38:07.786]                   if (TRUE) {
[17:38:07.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.786]                     {
[17:38:07.786]                       inherits <- base::inherits
[17:38:07.786]                       invokeRestart <- base::invokeRestart
[17:38:07.786]                       is.null <- base::is.null
[17:38:07.786]                       muffled <- FALSE
[17:38:07.786]                       if (inherits(cond, "message")) {
[17:38:07.786]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.786]                         if (muffled) 
[17:38:07.786]                           invokeRestart("muffleMessage")
[17:38:07.786]                       }
[17:38:07.786]                       else if (inherits(cond, "warning")) {
[17:38:07.786]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.786]                         if (muffled) 
[17:38:07.786]                           invokeRestart("muffleWarning")
[17:38:07.786]                       }
[17:38:07.786]                       else if (inherits(cond, "condition")) {
[17:38:07.786]                         if (!is.null(pattern)) {
[17:38:07.786]                           computeRestarts <- base::computeRestarts
[17:38:07.786]                           grepl <- base::grepl
[17:38:07.786]                           restarts <- computeRestarts(cond)
[17:38:07.786]                           for (restart in restarts) {
[17:38:07.786]                             name <- restart$name
[17:38:07.786]                             if (is.null(name)) 
[17:38:07.786]                               next
[17:38:07.786]                             if (!grepl(pattern, name)) 
[17:38:07.786]                               next
[17:38:07.786]                             invokeRestart(restart)
[17:38:07.786]                             muffled <- TRUE
[17:38:07.786]                             break
[17:38:07.786]                           }
[17:38:07.786]                         }
[17:38:07.786]                       }
[17:38:07.786]                       invisible(muffled)
[17:38:07.786]                     }
[17:38:07.786]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.786]                   }
[17:38:07.786]                 }
[17:38:07.786]             }
[17:38:07.786]         }))
[17:38:07.786]     }, error = function(ex) {
[17:38:07.786]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.786]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.786]                 ...future.rng), started = ...future.startTime, 
[17:38:07.786]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.786]             version = "1.8"), class = "FutureResult")
[17:38:07.786]     }, finally = {
[17:38:07.786]         if (!identical(...future.workdir, getwd())) 
[17:38:07.786]             setwd(...future.workdir)
[17:38:07.786]         {
[17:38:07.786]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.786]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.786]             }
[17:38:07.786]             base::options(...future.oldOptions)
[17:38:07.786]             if (.Platform$OS.type == "windows") {
[17:38:07.786]                 old_names <- names(...future.oldEnvVars)
[17:38:07.786]                 envs <- base::Sys.getenv()
[17:38:07.786]                 names <- names(envs)
[17:38:07.786]                 common <- intersect(names, old_names)
[17:38:07.786]                 added <- setdiff(names, old_names)
[17:38:07.786]                 removed <- setdiff(old_names, names)
[17:38:07.786]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.786]                   envs[common]]
[17:38:07.786]                 NAMES <- toupper(changed)
[17:38:07.786]                 args <- list()
[17:38:07.786]                 for (kk in seq_along(NAMES)) {
[17:38:07.786]                   name <- changed[[kk]]
[17:38:07.786]                   NAME <- NAMES[[kk]]
[17:38:07.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.786]                     next
[17:38:07.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.786]                 }
[17:38:07.786]                 NAMES <- toupper(added)
[17:38:07.786]                 for (kk in seq_along(NAMES)) {
[17:38:07.786]                   name <- added[[kk]]
[17:38:07.786]                   NAME <- NAMES[[kk]]
[17:38:07.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.786]                     next
[17:38:07.786]                   args[[name]] <- ""
[17:38:07.786]                 }
[17:38:07.786]                 NAMES <- toupper(removed)
[17:38:07.786]                 for (kk in seq_along(NAMES)) {
[17:38:07.786]                   name <- removed[[kk]]
[17:38:07.786]                   NAME <- NAMES[[kk]]
[17:38:07.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.786]                     next
[17:38:07.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.786]                 }
[17:38:07.786]                 if (length(args) > 0) 
[17:38:07.786]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.786]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.786]             }
[17:38:07.786]             else {
[17:38:07.786]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.786]             }
[17:38:07.786]             {
[17:38:07.786]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.786]                   0L) {
[17:38:07.786]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.786]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.786]                   base::options(opts)
[17:38:07.786]                 }
[17:38:07.786]                 {
[17:38:07.786]                   {
[17:38:07.786]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:07.786]                     NULL
[17:38:07.786]                   }
[17:38:07.786]                   options(future.plan = NULL)
[17:38:07.786]                   if (is.na(NA_character_)) 
[17:38:07.786]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.786]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.786]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.786]                     .init = FALSE)
[17:38:07.786]                 }
[17:38:07.786]             }
[17:38:07.786]         }
[17:38:07.786]     })
[17:38:07.786]     if (TRUE) {
[17:38:07.786]         base::sink(type = "output", split = FALSE)
[17:38:07.786]         if (TRUE) {
[17:38:07.786]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.786]         }
[17:38:07.786]         else {
[17:38:07.786]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.786]         }
[17:38:07.786]         base::close(...future.stdout)
[17:38:07.786]         ...future.stdout <- NULL
[17:38:07.786]     }
[17:38:07.786]     ...future.result$conditions <- ...future.conditions
[17:38:07.786]     ...future.result$finished <- base::Sys.time()
[17:38:07.786]     ...future.result
[17:38:07.786] }
[17:38:07.788] assign_globals() ...
[17:38:07.788] List of 11
[17:38:07.788]  $ ...future.FUN            :function (x, ...)  
[17:38:07.788]  $ x_FUN                    :function (x)  
[17:38:07.788]  $ times                    : int 1
[17:38:07.788]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.788]  $ stop_if_not              :function (...)  
[17:38:07.788]  $ dim                      : NULL
[17:38:07.788]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:07.788]  $ future.call.arguments    : list()
[17:38:07.788]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.788]  $ ...future.elements_ii    :List of 5
[17:38:07.788]   ..$ : int 1
[17:38:07.788]   ..$ : int 2
[17:38:07.788]   ..$ : int 3
[17:38:07.788]   ..$ : int 4
[17:38:07.788]   ..$ : int 5
[17:38:07.788]  $ ...future.seeds_ii       : NULL
[17:38:07.788]  $ ...future.globals.maxSize: NULL
[17:38:07.788]  - attr(*, "where")=List of 11
[17:38:07.788]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.788]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.788]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.788]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.788]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.788]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.788]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.788]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.788]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.788]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.788]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.788]  - attr(*, "resolved")= logi FALSE
[17:38:07.788]  - attr(*, "total_size")= num 94336
[17:38:07.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.788]  - attr(*, "already-done")= logi TRUE
[17:38:07.797] - copied ‘...future.FUN’ to environment
[17:38:07.797] - copied ‘x_FUN’ to environment
[17:38:07.798] - copied ‘times’ to environment
[17:38:07.798] - copied ‘stopf’ to environment
[17:38:07.798] - copied ‘stop_if_not’ to environment
[17:38:07.798] - copied ‘dim’ to environment
[17:38:07.798] - copied ‘valid_types’ to environment
[17:38:07.798] - copied ‘future.call.arguments’ to environment
[17:38:07.798] - copied ‘...future.elements_ii’ to environment
[17:38:07.798] - copied ‘...future.seeds_ii’ to environment
[17:38:07.798] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.798] assign_globals() ... done
[17:38:07.799] requestCore(): workers = 2
[17:38:07.801] MulticoreFuture started
[17:38:07.801] - Launch lazy future ... done
[17:38:07.801] run() for ‘MulticoreFuture’ ... done
[17:38:07.802] Created future:
[17:38:07.802] plan(): Setting new future strategy stack:
[17:38:07.803] List of future strategies:
[17:38:07.803] 1. sequential:
[17:38:07.803]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.803]    - tweaked: FALSE
[17:38:07.803]    - call: NULL
[17:38:07.804] plan(): nbrOfWorkers() = 1
[17:38:07.806] plan(): Setting new future strategy stack:
[17:38:07.806] List of future strategies:
[17:38:07.806] 1. multicore:
[17:38:07.806]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:07.806]    - tweaked: FALSE
[17:38:07.806]    - call: plan(strategy)
[17:38:07.811] plan(): nbrOfWorkers() = 2
[17:38:07.802] MulticoreFuture:
[17:38:07.802] Label: ‘future_vapply-1’
[17:38:07.802] Expression:
[17:38:07.802] {
[17:38:07.802]     do.call(function(...) {
[17:38:07.802]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.802]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.802]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.802]             on.exit(options(oopts), add = TRUE)
[17:38:07.802]         }
[17:38:07.802]         {
[17:38:07.802]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.802]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.802]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.802]             })
[17:38:07.802]         }
[17:38:07.802]     }, args = future.call.arguments)
[17:38:07.802] }
[17:38:07.802] Lazy evaluation: FALSE
[17:38:07.802] Asynchronous evaluation: TRUE
[17:38:07.802] Local evaluation: TRUE
[17:38:07.802] Environment: R_GlobalEnv
[17:38:07.802] Capture standard output: TRUE
[17:38:07.802] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.802] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.802] Packages: 1 packages (‘future.apply’)
[17:38:07.802] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.802] Resolved: TRUE
[17:38:07.802] Value: <not collected>
[17:38:07.802] Conditions captured: <none>
[17:38:07.802] Early signaling: FALSE
[17:38:07.802] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.802] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.812] Chunk #1 of 2 ... DONE
[17:38:07.812] Chunk #2 of 2 ...
[17:38:07.812]  - Finding globals in 'X' for chunk #2 ...
[17:38:07.813] getGlobalsAndPackages() ...
[17:38:07.813] Searching for globals...
[17:38:07.813] 
[17:38:07.813] Searching for globals ... DONE
[17:38:07.813] - globals: [0] <none>
[17:38:07.814] getGlobalsAndPackages() ... DONE
[17:38:07.814]    + additional globals found: [n=0] 
[17:38:07.814]    + additional namespaces needed: [n=0] 
[17:38:07.814]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:07.814]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:07.814]  - seeds: <none>
[17:38:07.814]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.815] getGlobalsAndPackages() ...
[17:38:07.815] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.815] Resolving globals: FALSE
[17:38:07.815] Tweak future expression to call with '...' arguments ...
[17:38:07.815] {
[17:38:07.815]     do.call(function(...) {
[17:38:07.815]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.815]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.815]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.815]             on.exit(options(oopts), add = TRUE)
[17:38:07.815]         }
[17:38:07.815]         {
[17:38:07.815]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.815]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.815]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.815]             })
[17:38:07.815]         }
[17:38:07.815]     }, args = future.call.arguments)
[17:38:07.815] }
[17:38:07.816] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.817] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.817] - packages: [1] ‘future.apply’
[17:38:07.817] getGlobalsAndPackages() ... DONE
[17:38:07.817] run() for ‘Future’ ...
[17:38:07.818] - state: ‘created’
[17:38:07.818] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:07.822] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.822] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:07.823]   - Field: ‘label’
[17:38:07.823]   - Field: ‘local’
[17:38:07.823]   - Field: ‘owner’
[17:38:07.823]   - Field: ‘envir’
[17:38:07.823]   - Field: ‘workers’
[17:38:07.823]   - Field: ‘packages’
[17:38:07.823]   - Field: ‘gc’
[17:38:07.824]   - Field: ‘job’
[17:38:07.824]   - Field: ‘conditions’
[17:38:07.824]   - Field: ‘expr’
[17:38:07.824]   - Field: ‘uuid’
[17:38:07.824]   - Field: ‘seed’
[17:38:07.824]   - Field: ‘version’
[17:38:07.825]   - Field: ‘result’
[17:38:07.825]   - Field: ‘asynchronous’
[17:38:07.825]   - Field: ‘calls’
[17:38:07.828]   - Field: ‘globals’
[17:38:07.829]   - Field: ‘stdout’
[17:38:07.829]   - Field: ‘earlySignal’
[17:38:07.829]   - Field: ‘lazy’
[17:38:07.830]   - Field: ‘state’
[17:38:07.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:07.830] - Launch lazy future ...
[17:38:07.831] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:07.831] Packages needed by future strategies (n = 0): <none>
[17:38:07.833] {
[17:38:07.833]     {
[17:38:07.833]         {
[17:38:07.833]             ...future.startTime <- base::Sys.time()
[17:38:07.833]             {
[17:38:07.833]                 {
[17:38:07.833]                   {
[17:38:07.833]                     {
[17:38:07.833]                       {
[17:38:07.833]                         base::local({
[17:38:07.833]                           has_future <- base::requireNamespace("future", 
[17:38:07.833]                             quietly = TRUE)
[17:38:07.833]                           if (has_future) {
[17:38:07.833]                             ns <- base::getNamespace("future")
[17:38:07.833]                             version <- ns[[".package"]][["version"]]
[17:38:07.833]                             if (is.null(version)) 
[17:38:07.833]                               version <- utils::packageVersion("future")
[17:38:07.833]                           }
[17:38:07.833]                           else {
[17:38:07.833]                             version <- NULL
[17:38:07.833]                           }
[17:38:07.833]                           if (!has_future || version < "1.8.0") {
[17:38:07.833]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.833]                               "", base::R.version$version.string), 
[17:38:07.833]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:07.833]                                 base::R.version$platform, 8 * 
[17:38:07.833]                                   base::.Machine$sizeof.pointer), 
[17:38:07.833]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.833]                                 "release", "version")], collapse = " "), 
[17:38:07.833]                               hostname = base::Sys.info()[["nodename"]])
[17:38:07.833]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.833]                               info)
[17:38:07.833]                             info <- base::paste(info, collapse = "; ")
[17:38:07.833]                             if (!has_future) {
[17:38:07.833]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.833]                                 info)
[17:38:07.833]                             }
[17:38:07.833]                             else {
[17:38:07.833]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.833]                                 info, version)
[17:38:07.833]                             }
[17:38:07.833]                             base::stop(msg)
[17:38:07.833]                           }
[17:38:07.833]                         })
[17:38:07.833]                       }
[17:38:07.833]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:07.833]                       base::options(mc.cores = 1L)
[17:38:07.833]                     }
[17:38:07.833]                     base::local({
[17:38:07.833]                       for (pkg in "future.apply") {
[17:38:07.833]                         base::loadNamespace(pkg)
[17:38:07.833]                         base::library(pkg, character.only = TRUE)
[17:38:07.833]                       }
[17:38:07.833]                     })
[17:38:07.833]                   }
[17:38:07.833]                   ...future.strategy.old <- future::plan("list")
[17:38:07.833]                   options(future.plan = NULL)
[17:38:07.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.833]                 }
[17:38:07.833]                 ...future.workdir <- getwd()
[17:38:07.833]             }
[17:38:07.833]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.833]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.833]         }
[17:38:07.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.833]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:07.833]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.833]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.833]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.833]             base::names(...future.oldOptions))
[17:38:07.833]     }
[17:38:07.833]     if (FALSE) {
[17:38:07.833]     }
[17:38:07.833]     else {
[17:38:07.833]         if (TRUE) {
[17:38:07.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.833]                 open = "w")
[17:38:07.833]         }
[17:38:07.833]         else {
[17:38:07.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.833]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.833]         }
[17:38:07.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.833]             base::sink(type = "output", split = FALSE)
[17:38:07.833]             base::close(...future.stdout)
[17:38:07.833]         }, add = TRUE)
[17:38:07.833]     }
[17:38:07.833]     ...future.frame <- base::sys.nframe()
[17:38:07.833]     ...future.conditions <- base::list()
[17:38:07.833]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.833]     if (FALSE) {
[17:38:07.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.833]     }
[17:38:07.833]     ...future.result <- base::tryCatch({
[17:38:07.833]         base::withCallingHandlers({
[17:38:07.833]             ...future.value <- base::withVisible(base::local({
[17:38:07.833]                 withCallingHandlers({
[17:38:07.833]                   {
[17:38:07.833]                     do.call(function(...) {
[17:38:07.833]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.833]                       if (!identical(...future.globals.maxSize.org, 
[17:38:07.833]                         ...future.globals.maxSize)) {
[17:38:07.833]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.833]                         on.exit(options(oopts), add = TRUE)
[17:38:07.833]                       }
[17:38:07.833]                       {
[17:38:07.833]                         lapply(seq_along(...future.elements_ii), 
[17:38:07.833]                           FUN = function(jj) {
[17:38:07.833]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.833]                             ...future.FUN(...future.X_jj, ...)
[17:38:07.833]                           })
[17:38:07.833]                       }
[17:38:07.833]                     }, args = future.call.arguments)
[17:38:07.833]                   }
[17:38:07.833]                 }, immediateCondition = function(cond) {
[17:38:07.833]                   save_rds <- function (object, pathname, ...) 
[17:38:07.833]                   {
[17:38:07.833]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:07.833]                     if (file_test("-f", pathname_tmp)) {
[17:38:07.833]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.833]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:07.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.833]                         fi_tmp[["mtime"]])
[17:38:07.833]                     }
[17:38:07.833]                     tryCatch({
[17:38:07.833]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:07.833]                     }, error = function(ex) {
[17:38:07.833]                       msg <- conditionMessage(ex)
[17:38:07.833]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.833]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:07.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.833]                         fi_tmp[["mtime"]], msg)
[17:38:07.833]                       ex$message <- msg
[17:38:07.833]                       stop(ex)
[17:38:07.833]                     })
[17:38:07.833]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:07.833]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:07.833]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:07.833]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.833]                       fi <- file.info(pathname)
[17:38:07.833]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:07.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.833]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:07.833]                         fi[["size"]], fi[["mtime"]])
[17:38:07.833]                       stop(msg)
[17:38:07.833]                     }
[17:38:07.833]                     invisible(pathname)
[17:38:07.833]                   }
[17:38:07.833]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:07.833]                     rootPath = tempdir()) 
[17:38:07.833]                   {
[17:38:07.833]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:07.833]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:07.833]                       tmpdir = path, fileext = ".rds")
[17:38:07.833]                     save_rds(obj, file)
[17:38:07.833]                   }
[17:38:07.833]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:07.833]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.833]                   {
[17:38:07.833]                     inherits <- base::inherits
[17:38:07.833]                     invokeRestart <- base::invokeRestart
[17:38:07.833]                     is.null <- base::is.null
[17:38:07.833]                     muffled <- FALSE
[17:38:07.833]                     if (inherits(cond, "message")) {
[17:38:07.833]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:07.833]                       if (muffled) 
[17:38:07.833]                         invokeRestart("muffleMessage")
[17:38:07.833]                     }
[17:38:07.833]                     else if (inherits(cond, "warning")) {
[17:38:07.833]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:07.833]                       if (muffled) 
[17:38:07.833]                         invokeRestart("muffleWarning")
[17:38:07.833]                     }
[17:38:07.833]                     else if (inherits(cond, "condition")) {
[17:38:07.833]                       if (!is.null(pattern)) {
[17:38:07.833]                         computeRestarts <- base::computeRestarts
[17:38:07.833]                         grepl <- base::grepl
[17:38:07.833]                         restarts <- computeRestarts(cond)
[17:38:07.833]                         for (restart in restarts) {
[17:38:07.833]                           name <- restart$name
[17:38:07.833]                           if (is.null(name)) 
[17:38:07.833]                             next
[17:38:07.833]                           if (!grepl(pattern, name)) 
[17:38:07.833]                             next
[17:38:07.833]                           invokeRestart(restart)
[17:38:07.833]                           muffled <- TRUE
[17:38:07.833]                           break
[17:38:07.833]                         }
[17:38:07.833]                       }
[17:38:07.833]                     }
[17:38:07.833]                     invisible(muffled)
[17:38:07.833]                   }
[17:38:07.833]                   muffleCondition(cond)
[17:38:07.833]                 })
[17:38:07.833]             }))
[17:38:07.833]             future::FutureResult(value = ...future.value$value, 
[17:38:07.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.833]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.833]                     ...future.globalenv.names))
[17:38:07.833]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.833]         }, condition = base::local({
[17:38:07.833]             c <- base::c
[17:38:07.833]             inherits <- base::inherits
[17:38:07.833]             invokeRestart <- base::invokeRestart
[17:38:07.833]             length <- base::length
[17:38:07.833]             list <- base::list
[17:38:07.833]             seq.int <- base::seq.int
[17:38:07.833]             signalCondition <- base::signalCondition
[17:38:07.833]             sys.calls <- base::sys.calls
[17:38:07.833]             `[[` <- base::`[[`
[17:38:07.833]             `+` <- base::`+`
[17:38:07.833]             `<<-` <- base::`<<-`
[17:38:07.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.833]                   3L)]
[17:38:07.833]             }
[17:38:07.833]             function(cond) {
[17:38:07.833]                 is_error <- inherits(cond, "error")
[17:38:07.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.833]                   NULL)
[17:38:07.833]                 if (is_error) {
[17:38:07.833]                   sessionInformation <- function() {
[17:38:07.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.833]                       search = base::search(), system = base::Sys.info())
[17:38:07.833]                   }
[17:38:07.833]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.833]                     cond$call), session = sessionInformation(), 
[17:38:07.833]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.833]                   signalCondition(cond)
[17:38:07.833]                 }
[17:38:07.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.833]                 "immediateCondition"))) {
[17:38:07.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.833]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.833]                   if (TRUE && !signal) {
[17:38:07.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.833]                     {
[17:38:07.833]                       inherits <- base::inherits
[17:38:07.833]                       invokeRestart <- base::invokeRestart
[17:38:07.833]                       is.null <- base::is.null
[17:38:07.833]                       muffled <- FALSE
[17:38:07.833]                       if (inherits(cond, "message")) {
[17:38:07.833]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.833]                         if (muffled) 
[17:38:07.833]                           invokeRestart("muffleMessage")
[17:38:07.833]                       }
[17:38:07.833]                       else if (inherits(cond, "warning")) {
[17:38:07.833]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.833]                         if (muffled) 
[17:38:07.833]                           invokeRestart("muffleWarning")
[17:38:07.833]                       }
[17:38:07.833]                       else if (inherits(cond, "condition")) {
[17:38:07.833]                         if (!is.null(pattern)) {
[17:38:07.833]                           computeRestarts <- base::computeRestarts
[17:38:07.833]                           grepl <- base::grepl
[17:38:07.833]                           restarts <- computeRestarts(cond)
[17:38:07.833]                           for (restart in restarts) {
[17:38:07.833]                             name <- restart$name
[17:38:07.833]                             if (is.null(name)) 
[17:38:07.833]                               next
[17:38:07.833]                             if (!grepl(pattern, name)) 
[17:38:07.833]                               next
[17:38:07.833]                             invokeRestart(restart)
[17:38:07.833]                             muffled <- TRUE
[17:38:07.833]                             break
[17:38:07.833]                           }
[17:38:07.833]                         }
[17:38:07.833]                       }
[17:38:07.833]                       invisible(muffled)
[17:38:07.833]                     }
[17:38:07.833]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.833]                   }
[17:38:07.833]                 }
[17:38:07.833]                 else {
[17:38:07.833]                   if (TRUE) {
[17:38:07.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.833]                     {
[17:38:07.833]                       inherits <- base::inherits
[17:38:07.833]                       invokeRestart <- base::invokeRestart
[17:38:07.833]                       is.null <- base::is.null
[17:38:07.833]                       muffled <- FALSE
[17:38:07.833]                       if (inherits(cond, "message")) {
[17:38:07.833]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.833]                         if (muffled) 
[17:38:07.833]                           invokeRestart("muffleMessage")
[17:38:07.833]                       }
[17:38:07.833]                       else if (inherits(cond, "warning")) {
[17:38:07.833]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.833]                         if (muffled) 
[17:38:07.833]                           invokeRestart("muffleWarning")
[17:38:07.833]                       }
[17:38:07.833]                       else if (inherits(cond, "condition")) {
[17:38:07.833]                         if (!is.null(pattern)) {
[17:38:07.833]                           computeRestarts <- base::computeRestarts
[17:38:07.833]                           grepl <- base::grepl
[17:38:07.833]                           restarts <- computeRestarts(cond)
[17:38:07.833]                           for (restart in restarts) {
[17:38:07.833]                             name <- restart$name
[17:38:07.833]                             if (is.null(name)) 
[17:38:07.833]                               next
[17:38:07.833]                             if (!grepl(pattern, name)) 
[17:38:07.833]                               next
[17:38:07.833]                             invokeRestart(restart)
[17:38:07.833]                             muffled <- TRUE
[17:38:07.833]                             break
[17:38:07.833]                           }
[17:38:07.833]                         }
[17:38:07.833]                       }
[17:38:07.833]                       invisible(muffled)
[17:38:07.833]                     }
[17:38:07.833]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.833]                   }
[17:38:07.833]                 }
[17:38:07.833]             }
[17:38:07.833]         }))
[17:38:07.833]     }, error = function(ex) {
[17:38:07.833]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.833]                 ...future.rng), started = ...future.startTime, 
[17:38:07.833]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.833]             version = "1.8"), class = "FutureResult")
[17:38:07.833]     }, finally = {
[17:38:07.833]         if (!identical(...future.workdir, getwd())) 
[17:38:07.833]             setwd(...future.workdir)
[17:38:07.833]         {
[17:38:07.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.833]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.833]             }
[17:38:07.833]             base::options(...future.oldOptions)
[17:38:07.833]             if (.Platform$OS.type == "windows") {
[17:38:07.833]                 old_names <- names(...future.oldEnvVars)
[17:38:07.833]                 envs <- base::Sys.getenv()
[17:38:07.833]                 names <- names(envs)
[17:38:07.833]                 common <- intersect(names, old_names)
[17:38:07.833]                 added <- setdiff(names, old_names)
[17:38:07.833]                 removed <- setdiff(old_names, names)
[17:38:07.833]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.833]                   envs[common]]
[17:38:07.833]                 NAMES <- toupper(changed)
[17:38:07.833]                 args <- list()
[17:38:07.833]                 for (kk in seq_along(NAMES)) {
[17:38:07.833]                   name <- changed[[kk]]
[17:38:07.833]                   NAME <- NAMES[[kk]]
[17:38:07.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.833]                     next
[17:38:07.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.833]                 }
[17:38:07.833]                 NAMES <- toupper(added)
[17:38:07.833]                 for (kk in seq_along(NAMES)) {
[17:38:07.833]                   name <- added[[kk]]
[17:38:07.833]                   NAME <- NAMES[[kk]]
[17:38:07.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.833]                     next
[17:38:07.833]                   args[[name]] <- ""
[17:38:07.833]                 }
[17:38:07.833]                 NAMES <- toupper(removed)
[17:38:07.833]                 for (kk in seq_along(NAMES)) {
[17:38:07.833]                   name <- removed[[kk]]
[17:38:07.833]                   NAME <- NAMES[[kk]]
[17:38:07.833]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.833]                     next
[17:38:07.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.833]                 }
[17:38:07.833]                 if (length(args) > 0) 
[17:38:07.833]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.833]             }
[17:38:07.833]             else {
[17:38:07.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.833]             }
[17:38:07.833]             {
[17:38:07.833]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.833]                   0L) {
[17:38:07.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.833]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.833]                   base::options(opts)
[17:38:07.833]                 }
[17:38:07.833]                 {
[17:38:07.833]                   {
[17:38:07.833]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:07.833]                     NULL
[17:38:07.833]                   }
[17:38:07.833]                   options(future.plan = NULL)
[17:38:07.833]                   if (is.na(NA_character_)) 
[17:38:07.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.833]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.833]                     .init = FALSE)
[17:38:07.833]                 }
[17:38:07.833]             }
[17:38:07.833]         }
[17:38:07.833]     })
[17:38:07.833]     if (TRUE) {
[17:38:07.833]         base::sink(type = "output", split = FALSE)
[17:38:07.833]         if (TRUE) {
[17:38:07.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.833]         }
[17:38:07.833]         else {
[17:38:07.833]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.833]         }
[17:38:07.833]         base::close(...future.stdout)
[17:38:07.833]         ...future.stdout <- NULL
[17:38:07.833]     }
[17:38:07.833]     ...future.result$conditions <- ...future.conditions
[17:38:07.833]     ...future.result$finished <- base::Sys.time()
[17:38:07.833]     ...future.result
[17:38:07.833] }
[17:38:07.835] assign_globals() ...
[17:38:07.836] List of 11
[17:38:07.836]  $ ...future.FUN            :function (x, ...)  
[17:38:07.836]  $ x_FUN                    :function (x)  
[17:38:07.836]  $ times                    : int 1
[17:38:07.836]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.836]  $ stop_if_not              :function (...)  
[17:38:07.836]  $ dim                      : NULL
[17:38:07.836]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:07.836]  $ future.call.arguments    : list()
[17:38:07.836]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.836]  $ ...future.elements_ii    :List of 5
[17:38:07.836]   ..$ : int 6
[17:38:07.836]   ..$ : int 7
[17:38:07.836]   ..$ : int 8
[17:38:07.836]   ..$ : int 9
[17:38:07.836]   ..$ : int 10
[17:38:07.836]  $ ...future.seeds_ii       : NULL
[17:38:07.836]  $ ...future.globals.maxSize: NULL
[17:38:07.836]  - attr(*, "where")=List of 11
[17:38:07.836]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.836]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.836]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.836]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.836]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.836]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.836]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.836]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.836]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.836]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.836]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.836]  - attr(*, "resolved")= logi FALSE
[17:38:07.836]  - attr(*, "total_size")= num 94336
[17:38:07.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.836]  - attr(*, "already-done")= logi TRUE
[17:38:07.849] - copied ‘...future.FUN’ to environment
[17:38:07.849] - copied ‘x_FUN’ to environment
[17:38:07.849] - copied ‘times’ to environment
[17:38:07.849] - copied ‘stopf’ to environment
[17:38:07.849] - copied ‘stop_if_not’ to environment
[17:38:07.849] - copied ‘dim’ to environment
[17:38:07.849] - copied ‘valid_types’ to environment
[17:38:07.849] - copied ‘future.call.arguments’ to environment
[17:38:07.849] - copied ‘...future.elements_ii’ to environment
[17:38:07.850] - copied ‘...future.seeds_ii’ to environment
[17:38:07.850] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.850] assign_globals() ... done
[17:38:07.850] requestCore(): workers = 2
[17:38:07.852] MulticoreFuture started
[17:38:07.853] - Launch lazy future ... done
[17:38:07.853] run() for ‘MulticoreFuture’ ... done
[17:38:07.853] Created future:
[17:38:07.854] plan(): Setting new future strategy stack:
[17:38:07.854] List of future strategies:
[17:38:07.854] 1. sequential:
[17:38:07.854]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.854]    - tweaked: FALSE
[17:38:07.854]    - call: NULL
[17:38:07.855] plan(): nbrOfWorkers() = 1
[17:38:07.857] plan(): Setting new future strategy stack:
[17:38:07.857] List of future strategies:
[17:38:07.857] 1. multicore:
[17:38:07.857]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:07.857]    - tweaked: FALSE
[17:38:07.857]    - call: plan(strategy)
[17:38:07.862] plan(): nbrOfWorkers() = 2
[17:38:07.853] MulticoreFuture:
[17:38:07.853] Label: ‘future_vapply-2’
[17:38:07.853] Expression:
[17:38:07.853] {
[17:38:07.853]     do.call(function(...) {
[17:38:07.853]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.853]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.853]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.853]             on.exit(options(oopts), add = TRUE)
[17:38:07.853]         }
[17:38:07.853]         {
[17:38:07.853]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.853]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.853]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.853]             })
[17:38:07.853]         }
[17:38:07.853]     }, args = future.call.arguments)
[17:38:07.853] }
[17:38:07.853] Lazy evaluation: FALSE
[17:38:07.853] Asynchronous evaluation: TRUE
[17:38:07.853] Local evaluation: TRUE
[17:38:07.853] Environment: R_GlobalEnv
[17:38:07.853] Capture standard output: TRUE
[17:38:07.853] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.853] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.853] Packages: 1 packages (‘future.apply’)
[17:38:07.853] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.853] Resolved: TRUE
[17:38:07.853] Value: <not collected>
[17:38:07.853] Conditions captured: <none>
[17:38:07.853] Early signaling: FALSE
[17:38:07.853] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.853] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.863] Chunk #2 of 2 ... DONE
[17:38:07.863] Launching 2 futures (chunks) ... DONE
[17:38:07.863] Resolving 2 futures (chunks) ...
[17:38:07.864] resolve() on list ...
[17:38:07.864]  recursive: 0
[17:38:07.864]  length: 2
[17:38:07.864] 
[17:38:07.864] Future #1
[17:38:07.865] result() for MulticoreFuture ...
[17:38:07.865] result() for MulticoreFuture ...
[17:38:07.866] result() for MulticoreFuture ... done
[17:38:07.866] result() for MulticoreFuture ... done
[17:38:07.866] result() for MulticoreFuture ...
[17:38:07.866] result() for MulticoreFuture ... done
[17:38:07.866] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:07.866] - nx: 2
[17:38:07.866] - relay: TRUE
[17:38:07.866] - stdout: TRUE
[17:38:07.867] - signal: TRUE
[17:38:07.867] - resignal: FALSE
[17:38:07.867] - force: TRUE
[17:38:07.867] - relayed: [n=2] FALSE, FALSE
[17:38:07.867] - queued futures: [n=2] FALSE, FALSE
[17:38:07.867]  - until=1
[17:38:07.867]  - relaying element #1
[17:38:07.868] result() for MulticoreFuture ...
[17:38:07.868] result() for MulticoreFuture ... done
[17:38:07.868] result() for MulticoreFuture ...
[17:38:07.868] result() for MulticoreFuture ... done
[17:38:07.868] result() for MulticoreFuture ...
[17:38:07.868] result() for MulticoreFuture ... done
[17:38:07.869] result() for MulticoreFuture ...
[17:38:07.869] result() for MulticoreFuture ... done
[17:38:07.869] - relayed: [n=2] TRUE, FALSE
[17:38:07.869] - queued futures: [n=2] TRUE, FALSE
[17:38:07.869] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:07.869]  length: 1 (resolved future 1)
[17:38:07.870] Future #2
[17:38:07.870] result() for MulticoreFuture ...
[17:38:07.871] result() for MulticoreFuture ...
[17:38:07.871] result() for MulticoreFuture ... done
[17:38:07.871] result() for MulticoreFuture ... done
[17:38:07.871] result() for MulticoreFuture ...
[17:38:07.871] result() for MulticoreFuture ... done
[17:38:07.871] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:07.871] - nx: 2
[17:38:07.872] - relay: TRUE
[17:38:07.872] - stdout: TRUE
[17:38:07.872] - signal: TRUE
[17:38:07.872] - resignal: FALSE
[17:38:07.872] - force: TRUE
[17:38:07.872] - relayed: [n=2] TRUE, FALSE
[17:38:07.872] - queued futures: [n=2] TRUE, FALSE
[17:38:07.873]  - until=2
[17:38:07.873]  - relaying element #2
[17:38:07.873] result() for MulticoreFuture ...
[17:38:07.873] result() for MulticoreFuture ... done
[17:38:07.873] result() for MulticoreFuture ...
[17:38:07.876] result() for MulticoreFuture ... done
[17:38:07.876] result() for MulticoreFuture ...
[17:38:07.876] result() for MulticoreFuture ... done
[17:38:07.877] result() for MulticoreFuture ...
[17:38:07.877] result() for MulticoreFuture ... done
[17:38:07.877] - relayed: [n=2] TRUE, TRUE
[17:38:07.877] - queued futures: [n=2] TRUE, TRUE
[17:38:07.877] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:07.877]  length: 0 (resolved future 2)
[17:38:07.878] Relaying remaining futures
[17:38:07.878] signalConditionsASAP(NULL, pos=0) ...
[17:38:07.878] - nx: 2
[17:38:07.878] - relay: TRUE
[17:38:07.878] - stdout: TRUE
[17:38:07.878] - signal: TRUE
[17:38:07.878] - resignal: FALSE
[17:38:07.879] - force: TRUE
[17:38:07.879] - relayed: [n=2] TRUE, TRUE
[17:38:07.879] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:07.879] - relayed: [n=2] TRUE, TRUE
[17:38:07.879] - queued futures: [n=2] TRUE, TRUE
[17:38:07.880] signalConditionsASAP(NULL, pos=0) ... done
[17:38:07.880] resolve() on list ... DONE
[17:38:07.880] result() for MulticoreFuture ...
[17:38:07.880] result() for MulticoreFuture ... done
[17:38:07.880] result() for MulticoreFuture ...
[17:38:07.880] result() for MulticoreFuture ... done
[17:38:07.881] result() for MulticoreFuture ...
[17:38:07.881] result() for MulticoreFuture ... done
[17:38:07.881] result() for MulticoreFuture ...
[17:38:07.881] result() for MulticoreFuture ... done
[17:38:07.881]  - Number of value chunks collected: 2
[17:38:07.881] Resolving 2 futures (chunks) ... DONE
[17:38:07.881] Reducing values from 2 chunks ...
[17:38:07.881]  - Number of values collected after concatenation: 10
[17:38:07.882]  - Number of values expected: 10
[17:38:07.882] Reducing values from 2 chunks ... DONE
[17:38:07.882] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[17:38:07.883] future_lapply() ...
[17:38:07.889] Number of chunks: 2
[17:38:07.889] getGlobalsAndPackagesXApply() ...
[17:38:07.889]  - future.globals: TRUE
[17:38:07.890] getGlobalsAndPackages() ...
[17:38:07.890] Searching for globals...
[17:38:07.894] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[17:38:07.894] Searching for globals ... DONE
[17:38:07.894] Resolving globals: FALSE
[17:38:07.895] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[17:38:07.896] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:07.896] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.896] - packages: [1] ‘future.apply’
[17:38:07.896] getGlobalsAndPackages() ... DONE
[17:38:07.896]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:07.896]  - needed namespaces: [n=1] ‘future.apply’
[17:38:07.896] Finding globals ... DONE
[17:38:07.896]  - use_args: TRUE
[17:38:07.896]  - Getting '...' globals ...
[17:38:07.897] resolve() on list ...
[17:38:07.897]  recursive: 0
[17:38:07.897]  length: 1
[17:38:07.897]  elements: ‘...’
[17:38:07.897]  length: 0 (resolved future 1)
[17:38:07.897] resolve() on list ... DONE
[17:38:07.897]    - '...' content: [n=0] 
[17:38:07.897] List of 1
[17:38:07.897]  $ ...: list()
[17:38:07.897]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.897]  - attr(*, "where")=List of 1
[17:38:07.897]   ..$ ...:<environment: 0x560800109fe8> 
[17:38:07.897]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.897]  - attr(*, "resolved")= logi TRUE
[17:38:07.897]  - attr(*, "total_size")= num NA
[17:38:07.900]  - Getting '...' globals ... DONE
[17:38:07.900] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:07.900] List of 8
[17:38:07.900]  $ ...future.FUN:function (x, ...)  
[17:38:07.900]  $ x_FUN        :function (x)  
[17:38:07.900]  $ times        : int 2
[17:38:07.900]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.900]  $ stop_if_not  :function (...)  
[17:38:07.900]  $ dim          : NULL
[17:38:07.900]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:07.900]  $ ...          : list()
[17:38:07.900]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.900]  - attr(*, "where")=List of 8
[17:38:07.900]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:07.900]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:07.900]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:07.900]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:07.900]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:07.900]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:07.900]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:07.900]   ..$ ...          :<environment: 0x560800109fe8> 
[17:38:07.900]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.900]  - attr(*, "resolved")= logi FALSE
[17:38:07.900]  - attr(*, "total_size")= num 96456
[17:38:07.908] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:07.908] getGlobalsAndPackagesXApply() ... DONE
[17:38:07.908] Number of futures (= number of chunks): 2
[17:38:07.909] Launching 2 futures (chunks) ...
[17:38:07.909] Chunk #1 of 2 ...
[17:38:07.909]  - Finding globals in 'X' for chunk #1 ...
[17:38:07.909] getGlobalsAndPackages() ...
[17:38:07.909] Searching for globals...
[17:38:07.909] 
[17:38:07.909] Searching for globals ... DONE
[17:38:07.910] - globals: [0] <none>
[17:38:07.910] getGlobalsAndPackages() ... DONE
[17:38:07.910]    + additional globals found: [n=0] 
[17:38:07.910]    + additional namespaces needed: [n=0] 
[17:38:07.910]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:07.910]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:07.910]  - seeds: <none>
[17:38:07.910]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.910] getGlobalsAndPackages() ...
[17:38:07.910] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.911] Resolving globals: FALSE
[17:38:07.911] Tweak future expression to call with '...' arguments ...
[17:38:07.911] {
[17:38:07.911]     do.call(function(...) {
[17:38:07.911]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.911]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.911]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.911]             on.exit(options(oopts), add = TRUE)
[17:38:07.911]         }
[17:38:07.911]         {
[17:38:07.911]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.911]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.911]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.911]             })
[17:38:07.911]         }
[17:38:07.911]     }, args = future.call.arguments)
[17:38:07.911] }
[17:38:07.911] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.911] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.912] - packages: [1] ‘future.apply’
[17:38:07.912] getGlobalsAndPackages() ... DONE
[17:38:07.912] run() for ‘Future’ ...
[17:38:07.912] - state: ‘created’
[17:38:07.912] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:07.916] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.916] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:07.916]   - Field: ‘label’
[17:38:07.916]   - Field: ‘local’
[17:38:07.916]   - Field: ‘owner’
[17:38:07.916]   - Field: ‘envir’
[17:38:07.917]   - Field: ‘workers’
[17:38:07.917]   - Field: ‘packages’
[17:38:07.917]   - Field: ‘gc’
[17:38:07.917]   - Field: ‘job’
[17:38:07.917]   - Field: ‘conditions’
[17:38:07.917]   - Field: ‘expr’
[17:38:07.917]   - Field: ‘uuid’
[17:38:07.917]   - Field: ‘seed’
[17:38:07.917]   - Field: ‘version’
[17:38:07.917]   - Field: ‘result’
[17:38:07.918]   - Field: ‘asynchronous’
[17:38:07.918]   - Field: ‘calls’
[17:38:07.918]   - Field: ‘globals’
[17:38:07.918]   - Field: ‘stdout’
[17:38:07.918]   - Field: ‘earlySignal’
[17:38:07.918]   - Field: ‘lazy’
[17:38:07.918]   - Field: ‘state’
[17:38:07.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:07.918] - Launch lazy future ...
[17:38:07.919] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:07.919] Packages needed by future strategies (n = 0): <none>
[17:38:07.919] {
[17:38:07.919]     {
[17:38:07.919]         {
[17:38:07.919]             ...future.startTime <- base::Sys.time()
[17:38:07.919]             {
[17:38:07.919]                 {
[17:38:07.919]                   {
[17:38:07.919]                     {
[17:38:07.919]                       {
[17:38:07.919]                         base::local({
[17:38:07.919]                           has_future <- base::requireNamespace("future", 
[17:38:07.919]                             quietly = TRUE)
[17:38:07.919]                           if (has_future) {
[17:38:07.919]                             ns <- base::getNamespace("future")
[17:38:07.919]                             version <- ns[[".package"]][["version"]]
[17:38:07.919]                             if (is.null(version)) 
[17:38:07.919]                               version <- utils::packageVersion("future")
[17:38:07.919]                           }
[17:38:07.919]                           else {
[17:38:07.919]                             version <- NULL
[17:38:07.919]                           }
[17:38:07.919]                           if (!has_future || version < "1.8.0") {
[17:38:07.919]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.919]                               "", base::R.version$version.string), 
[17:38:07.919]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:07.919]                                 base::R.version$platform, 8 * 
[17:38:07.919]                                   base::.Machine$sizeof.pointer), 
[17:38:07.919]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.919]                                 "release", "version")], collapse = " "), 
[17:38:07.919]                               hostname = base::Sys.info()[["nodename"]])
[17:38:07.919]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.919]                               info)
[17:38:07.919]                             info <- base::paste(info, collapse = "; ")
[17:38:07.919]                             if (!has_future) {
[17:38:07.919]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.919]                                 info)
[17:38:07.919]                             }
[17:38:07.919]                             else {
[17:38:07.919]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.919]                                 info, version)
[17:38:07.919]                             }
[17:38:07.919]                             base::stop(msg)
[17:38:07.919]                           }
[17:38:07.919]                         })
[17:38:07.919]                       }
[17:38:07.919]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:07.919]                       base::options(mc.cores = 1L)
[17:38:07.919]                     }
[17:38:07.919]                     base::local({
[17:38:07.919]                       for (pkg in "future.apply") {
[17:38:07.919]                         base::loadNamespace(pkg)
[17:38:07.919]                         base::library(pkg, character.only = TRUE)
[17:38:07.919]                       }
[17:38:07.919]                     })
[17:38:07.919]                   }
[17:38:07.919]                   ...future.strategy.old <- future::plan("list")
[17:38:07.919]                   options(future.plan = NULL)
[17:38:07.919]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.919]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.919]                 }
[17:38:07.919]                 ...future.workdir <- getwd()
[17:38:07.919]             }
[17:38:07.919]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.919]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.919]         }
[17:38:07.919]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.919]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:07.919]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.919]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.919]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.919]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.919]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.919]             base::names(...future.oldOptions))
[17:38:07.919]     }
[17:38:07.919]     if (FALSE) {
[17:38:07.919]     }
[17:38:07.919]     else {
[17:38:07.919]         if (TRUE) {
[17:38:07.919]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.919]                 open = "w")
[17:38:07.919]         }
[17:38:07.919]         else {
[17:38:07.919]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.919]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.919]         }
[17:38:07.919]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.919]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.919]             base::sink(type = "output", split = FALSE)
[17:38:07.919]             base::close(...future.stdout)
[17:38:07.919]         }, add = TRUE)
[17:38:07.919]     }
[17:38:07.919]     ...future.frame <- base::sys.nframe()
[17:38:07.919]     ...future.conditions <- base::list()
[17:38:07.919]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.919]     if (FALSE) {
[17:38:07.919]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.919]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.919]     }
[17:38:07.919]     ...future.result <- base::tryCatch({
[17:38:07.919]         base::withCallingHandlers({
[17:38:07.919]             ...future.value <- base::withVisible(base::local({
[17:38:07.919]                 withCallingHandlers({
[17:38:07.919]                   {
[17:38:07.919]                     do.call(function(...) {
[17:38:07.919]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.919]                       if (!identical(...future.globals.maxSize.org, 
[17:38:07.919]                         ...future.globals.maxSize)) {
[17:38:07.919]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.919]                         on.exit(options(oopts), add = TRUE)
[17:38:07.919]                       }
[17:38:07.919]                       {
[17:38:07.919]                         lapply(seq_along(...future.elements_ii), 
[17:38:07.919]                           FUN = function(jj) {
[17:38:07.919]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.919]                             ...future.FUN(...future.X_jj, ...)
[17:38:07.919]                           })
[17:38:07.919]                       }
[17:38:07.919]                     }, args = future.call.arguments)
[17:38:07.919]                   }
[17:38:07.919]                 }, immediateCondition = function(cond) {
[17:38:07.919]                   save_rds <- function (object, pathname, ...) 
[17:38:07.919]                   {
[17:38:07.919]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:07.919]                     if (file_test("-f", pathname_tmp)) {
[17:38:07.919]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.919]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:07.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.919]                         fi_tmp[["mtime"]])
[17:38:07.919]                     }
[17:38:07.919]                     tryCatch({
[17:38:07.919]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:07.919]                     }, error = function(ex) {
[17:38:07.919]                       msg <- conditionMessage(ex)
[17:38:07.919]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.919]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:07.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.919]                         fi_tmp[["mtime"]], msg)
[17:38:07.919]                       ex$message <- msg
[17:38:07.919]                       stop(ex)
[17:38:07.919]                     })
[17:38:07.919]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:07.919]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:07.919]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:07.919]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.919]                       fi <- file.info(pathname)
[17:38:07.919]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:07.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.919]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:07.919]                         fi[["size"]], fi[["mtime"]])
[17:38:07.919]                       stop(msg)
[17:38:07.919]                     }
[17:38:07.919]                     invisible(pathname)
[17:38:07.919]                   }
[17:38:07.919]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:07.919]                     rootPath = tempdir()) 
[17:38:07.919]                   {
[17:38:07.919]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:07.919]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:07.919]                       tmpdir = path, fileext = ".rds")
[17:38:07.919]                     save_rds(obj, file)
[17:38:07.919]                   }
[17:38:07.919]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:07.919]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.919]                   {
[17:38:07.919]                     inherits <- base::inherits
[17:38:07.919]                     invokeRestart <- base::invokeRestart
[17:38:07.919]                     is.null <- base::is.null
[17:38:07.919]                     muffled <- FALSE
[17:38:07.919]                     if (inherits(cond, "message")) {
[17:38:07.919]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:07.919]                       if (muffled) 
[17:38:07.919]                         invokeRestart("muffleMessage")
[17:38:07.919]                     }
[17:38:07.919]                     else if (inherits(cond, "warning")) {
[17:38:07.919]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:07.919]                       if (muffled) 
[17:38:07.919]                         invokeRestart("muffleWarning")
[17:38:07.919]                     }
[17:38:07.919]                     else if (inherits(cond, "condition")) {
[17:38:07.919]                       if (!is.null(pattern)) {
[17:38:07.919]                         computeRestarts <- base::computeRestarts
[17:38:07.919]                         grepl <- base::grepl
[17:38:07.919]                         restarts <- computeRestarts(cond)
[17:38:07.919]                         for (restart in restarts) {
[17:38:07.919]                           name <- restart$name
[17:38:07.919]                           if (is.null(name)) 
[17:38:07.919]                             next
[17:38:07.919]                           if (!grepl(pattern, name)) 
[17:38:07.919]                             next
[17:38:07.919]                           invokeRestart(restart)
[17:38:07.919]                           muffled <- TRUE
[17:38:07.919]                           break
[17:38:07.919]                         }
[17:38:07.919]                       }
[17:38:07.919]                     }
[17:38:07.919]                     invisible(muffled)
[17:38:07.919]                   }
[17:38:07.919]                   muffleCondition(cond)
[17:38:07.919]                 })
[17:38:07.919]             }))
[17:38:07.919]             future::FutureResult(value = ...future.value$value, 
[17:38:07.919]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.919]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.919]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.919]                     ...future.globalenv.names))
[17:38:07.919]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.919]         }, condition = base::local({
[17:38:07.919]             c <- base::c
[17:38:07.919]             inherits <- base::inherits
[17:38:07.919]             invokeRestart <- base::invokeRestart
[17:38:07.919]             length <- base::length
[17:38:07.919]             list <- base::list
[17:38:07.919]             seq.int <- base::seq.int
[17:38:07.919]             signalCondition <- base::signalCondition
[17:38:07.919]             sys.calls <- base::sys.calls
[17:38:07.919]             `[[` <- base::`[[`
[17:38:07.919]             `+` <- base::`+`
[17:38:07.919]             `<<-` <- base::`<<-`
[17:38:07.919]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.919]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.919]                   3L)]
[17:38:07.919]             }
[17:38:07.919]             function(cond) {
[17:38:07.919]                 is_error <- inherits(cond, "error")
[17:38:07.919]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.919]                   NULL)
[17:38:07.919]                 if (is_error) {
[17:38:07.919]                   sessionInformation <- function() {
[17:38:07.919]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.919]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.919]                       search = base::search(), system = base::Sys.info())
[17:38:07.919]                   }
[17:38:07.919]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.919]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.919]                     cond$call), session = sessionInformation(), 
[17:38:07.919]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.919]                   signalCondition(cond)
[17:38:07.919]                 }
[17:38:07.919]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.919]                 "immediateCondition"))) {
[17:38:07.919]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.919]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.919]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.919]                   if (TRUE && !signal) {
[17:38:07.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.919]                     {
[17:38:07.919]                       inherits <- base::inherits
[17:38:07.919]                       invokeRestart <- base::invokeRestart
[17:38:07.919]                       is.null <- base::is.null
[17:38:07.919]                       muffled <- FALSE
[17:38:07.919]                       if (inherits(cond, "message")) {
[17:38:07.919]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.919]                         if (muffled) 
[17:38:07.919]                           invokeRestart("muffleMessage")
[17:38:07.919]                       }
[17:38:07.919]                       else if (inherits(cond, "warning")) {
[17:38:07.919]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.919]                         if (muffled) 
[17:38:07.919]                           invokeRestart("muffleWarning")
[17:38:07.919]                       }
[17:38:07.919]                       else if (inherits(cond, "condition")) {
[17:38:07.919]                         if (!is.null(pattern)) {
[17:38:07.919]                           computeRestarts <- base::computeRestarts
[17:38:07.919]                           grepl <- base::grepl
[17:38:07.919]                           restarts <- computeRestarts(cond)
[17:38:07.919]                           for (restart in restarts) {
[17:38:07.919]                             name <- restart$name
[17:38:07.919]                             if (is.null(name)) 
[17:38:07.919]                               next
[17:38:07.919]                             if (!grepl(pattern, name)) 
[17:38:07.919]                               next
[17:38:07.919]                             invokeRestart(restart)
[17:38:07.919]                             muffled <- TRUE
[17:38:07.919]                             break
[17:38:07.919]                           }
[17:38:07.919]                         }
[17:38:07.919]                       }
[17:38:07.919]                       invisible(muffled)
[17:38:07.919]                     }
[17:38:07.919]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.919]                   }
[17:38:07.919]                 }
[17:38:07.919]                 else {
[17:38:07.919]                   if (TRUE) {
[17:38:07.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.919]                     {
[17:38:07.919]                       inherits <- base::inherits
[17:38:07.919]                       invokeRestart <- base::invokeRestart
[17:38:07.919]                       is.null <- base::is.null
[17:38:07.919]                       muffled <- FALSE
[17:38:07.919]                       if (inherits(cond, "message")) {
[17:38:07.919]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.919]                         if (muffled) 
[17:38:07.919]                           invokeRestart("muffleMessage")
[17:38:07.919]                       }
[17:38:07.919]                       else if (inherits(cond, "warning")) {
[17:38:07.919]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.919]                         if (muffled) 
[17:38:07.919]                           invokeRestart("muffleWarning")
[17:38:07.919]                       }
[17:38:07.919]                       else if (inherits(cond, "condition")) {
[17:38:07.919]                         if (!is.null(pattern)) {
[17:38:07.919]                           computeRestarts <- base::computeRestarts
[17:38:07.919]                           grepl <- base::grepl
[17:38:07.919]                           restarts <- computeRestarts(cond)
[17:38:07.919]                           for (restart in restarts) {
[17:38:07.919]                             name <- restart$name
[17:38:07.919]                             if (is.null(name)) 
[17:38:07.919]                               next
[17:38:07.919]                             if (!grepl(pattern, name)) 
[17:38:07.919]                               next
[17:38:07.919]                             invokeRestart(restart)
[17:38:07.919]                             muffled <- TRUE
[17:38:07.919]                             break
[17:38:07.919]                           }
[17:38:07.919]                         }
[17:38:07.919]                       }
[17:38:07.919]                       invisible(muffled)
[17:38:07.919]                     }
[17:38:07.919]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.919]                   }
[17:38:07.919]                 }
[17:38:07.919]             }
[17:38:07.919]         }))
[17:38:07.919]     }, error = function(ex) {
[17:38:07.919]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.919]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.919]                 ...future.rng), started = ...future.startTime, 
[17:38:07.919]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.919]             version = "1.8"), class = "FutureResult")
[17:38:07.919]     }, finally = {
[17:38:07.919]         if (!identical(...future.workdir, getwd())) 
[17:38:07.919]             setwd(...future.workdir)
[17:38:07.919]         {
[17:38:07.919]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.919]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.919]             }
[17:38:07.919]             base::options(...future.oldOptions)
[17:38:07.919]             if (.Platform$OS.type == "windows") {
[17:38:07.919]                 old_names <- names(...future.oldEnvVars)
[17:38:07.919]                 envs <- base::Sys.getenv()
[17:38:07.919]                 names <- names(envs)
[17:38:07.919]                 common <- intersect(names, old_names)
[17:38:07.919]                 added <- setdiff(names, old_names)
[17:38:07.919]                 removed <- setdiff(old_names, names)
[17:38:07.919]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.919]                   envs[common]]
[17:38:07.919]                 NAMES <- toupper(changed)
[17:38:07.919]                 args <- list()
[17:38:07.919]                 for (kk in seq_along(NAMES)) {
[17:38:07.919]                   name <- changed[[kk]]
[17:38:07.919]                   NAME <- NAMES[[kk]]
[17:38:07.919]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.919]                     next
[17:38:07.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.919]                 }
[17:38:07.919]                 NAMES <- toupper(added)
[17:38:07.919]                 for (kk in seq_along(NAMES)) {
[17:38:07.919]                   name <- added[[kk]]
[17:38:07.919]                   NAME <- NAMES[[kk]]
[17:38:07.919]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.919]                     next
[17:38:07.919]                   args[[name]] <- ""
[17:38:07.919]                 }
[17:38:07.919]                 NAMES <- toupper(removed)
[17:38:07.919]                 for (kk in seq_along(NAMES)) {
[17:38:07.919]                   name <- removed[[kk]]
[17:38:07.919]                   NAME <- NAMES[[kk]]
[17:38:07.919]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.919]                     next
[17:38:07.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.919]                 }
[17:38:07.919]                 if (length(args) > 0) 
[17:38:07.919]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.919]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.919]             }
[17:38:07.919]             else {
[17:38:07.919]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.919]             }
[17:38:07.919]             {
[17:38:07.919]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.919]                   0L) {
[17:38:07.919]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.919]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.919]                   base::options(opts)
[17:38:07.919]                 }
[17:38:07.919]                 {
[17:38:07.919]                   {
[17:38:07.919]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:07.919]                     NULL
[17:38:07.919]                   }
[17:38:07.919]                   options(future.plan = NULL)
[17:38:07.919]                   if (is.na(NA_character_)) 
[17:38:07.919]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.919]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.919]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.919]                     .init = FALSE)
[17:38:07.919]                 }
[17:38:07.919]             }
[17:38:07.919]         }
[17:38:07.919]     })
[17:38:07.919]     if (TRUE) {
[17:38:07.919]         base::sink(type = "output", split = FALSE)
[17:38:07.919]         if (TRUE) {
[17:38:07.919]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.919]         }
[17:38:07.919]         else {
[17:38:07.919]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.919]         }
[17:38:07.919]         base::close(...future.stdout)
[17:38:07.919]         ...future.stdout <- NULL
[17:38:07.919]     }
[17:38:07.919]     ...future.result$conditions <- ...future.conditions
[17:38:07.919]     ...future.result$finished <- base::Sys.time()
[17:38:07.919]     ...future.result
[17:38:07.919] }
[17:38:07.922] assign_globals() ...
[17:38:07.922] List of 11
[17:38:07.922]  $ ...future.FUN            :function (x, ...)  
[17:38:07.922]  $ x_FUN                    :function (x)  
[17:38:07.922]  $ times                    : int 2
[17:38:07.922]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.922]  $ stop_if_not              :function (...)  
[17:38:07.922]  $ dim                      : NULL
[17:38:07.922]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:07.922]  $ future.call.arguments    : list()
[17:38:07.922]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.922]  $ ...future.elements_ii    :List of 5
[17:38:07.922]   ..$ : int 1
[17:38:07.922]   ..$ : int 2
[17:38:07.922]   ..$ : int 3
[17:38:07.922]   ..$ : int 4
[17:38:07.922]   ..$ : int 5
[17:38:07.922]  $ ...future.seeds_ii       : NULL
[17:38:07.922]  $ ...future.globals.maxSize: NULL
[17:38:07.922]  - attr(*, "where")=List of 11
[17:38:07.922]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.922]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.922]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.922]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.922]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.922]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.922]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.922]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.922]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.922]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.922]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.922]  - attr(*, "resolved")= logi FALSE
[17:38:07.922]  - attr(*, "total_size")= num 96456
[17:38:07.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.922]  - attr(*, "already-done")= logi TRUE
[17:38:07.933] - copied ‘...future.FUN’ to environment
[17:38:07.933] - reassign environment for ‘x_FUN’
[17:38:07.933] - copied ‘x_FUN’ to environment
[17:38:07.933] - copied ‘times’ to environment
[17:38:07.933] - copied ‘stopf’ to environment
[17:38:07.934] - copied ‘stop_if_not’ to environment
[17:38:07.934] - copied ‘dim’ to environment
[17:38:07.934] - copied ‘valid_types’ to environment
[17:38:07.934] - copied ‘future.call.arguments’ to environment
[17:38:07.934] - copied ‘...future.elements_ii’ to environment
[17:38:07.934] - copied ‘...future.seeds_ii’ to environment
[17:38:07.934] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.934] assign_globals() ... done
[17:38:07.935] requestCore(): workers = 2
[17:38:07.937] MulticoreFuture started
[17:38:07.938] - Launch lazy future ... done
[17:38:07.938] run() for ‘MulticoreFuture’ ... done
[17:38:07.938] Created future:
[17:38:07.939] plan(): Setting new future strategy stack:
[17:38:07.939] List of future strategies:
[17:38:07.939] 1. sequential:
[17:38:07.939]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.939]    - tweaked: FALSE
[17:38:07.939]    - call: NULL
[17:38:07.940] plan(): nbrOfWorkers() = 1
[17:38:07.943] plan(): Setting new future strategy stack:
[17:38:07.943] List of future strategies:
[17:38:07.943] 1. multicore:
[17:38:07.943]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:07.943]    - tweaked: FALSE
[17:38:07.943]    - call: plan(strategy)
[17:38:07.949] plan(): nbrOfWorkers() = 2
[17:38:07.939] MulticoreFuture:
[17:38:07.939] Label: ‘future_vapply-1’
[17:38:07.939] Expression:
[17:38:07.939] {
[17:38:07.939]     do.call(function(...) {
[17:38:07.939]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.939]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.939]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.939]             on.exit(options(oopts), add = TRUE)
[17:38:07.939]         }
[17:38:07.939]         {
[17:38:07.939]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.939]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.939]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.939]             })
[17:38:07.939]         }
[17:38:07.939]     }, args = future.call.arguments)
[17:38:07.939] }
[17:38:07.939] Lazy evaluation: FALSE
[17:38:07.939] Asynchronous evaluation: TRUE
[17:38:07.939] Local evaluation: TRUE
[17:38:07.939] Environment: R_GlobalEnv
[17:38:07.939] Capture standard output: TRUE
[17:38:07.939] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.939] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.939] Packages: 1 packages (‘future.apply’)
[17:38:07.939] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.939] Resolved: TRUE
[17:38:07.939] Value: <not collected>
[17:38:07.939] Conditions captured: <none>
[17:38:07.939] Early signaling: FALSE
[17:38:07.939] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.939] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.950] Chunk #1 of 2 ... DONE
[17:38:07.950] Chunk #2 of 2 ...
[17:38:07.950]  - Finding globals in 'X' for chunk #2 ...
[17:38:07.950] getGlobalsAndPackages() ...
[17:38:07.950] Searching for globals...
[17:38:07.951] 
[17:38:07.951] Searching for globals ... DONE
[17:38:07.951] - globals: [0] <none>
[17:38:07.951] getGlobalsAndPackages() ... DONE
[17:38:07.952]    + additional globals found: [n=0] 
[17:38:07.952]    + additional namespaces needed: [n=0] 
[17:38:07.952]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:07.952]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:07.952]  - seeds: <none>
[17:38:07.952]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.953] getGlobalsAndPackages() ...
[17:38:07.953] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.953] Resolving globals: FALSE
[17:38:07.953] Tweak future expression to call with '...' arguments ...
[17:38:07.953] {
[17:38:07.953]     do.call(function(...) {
[17:38:07.953]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.953]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.953]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.953]             on.exit(options(oopts), add = TRUE)
[17:38:07.953]         }
[17:38:07.953]         {
[17:38:07.953]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.953]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.953]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.953]             })
[17:38:07.953]         }
[17:38:07.953]     }, args = future.call.arguments)
[17:38:07.953] }
[17:38:07.954] Tweak future expression to call with '...' arguments ... DONE
[17:38:07.955] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:07.955] - packages: [1] ‘future.apply’
[17:38:07.955] getGlobalsAndPackages() ... DONE
[17:38:07.956] run() for ‘Future’ ...
[17:38:07.956] - state: ‘created’
[17:38:07.956] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:07.961] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:07.961] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:07.961]   - Field: ‘label’
[17:38:07.961]   - Field: ‘local’
[17:38:07.961]   - Field: ‘owner’
[17:38:07.961]   - Field: ‘envir’
[17:38:07.961]   - Field: ‘workers’
[17:38:07.962]   - Field: ‘packages’
[17:38:07.962]   - Field: ‘gc’
[17:38:07.962]   - Field: ‘job’
[17:38:07.962]   - Field: ‘conditions’
[17:38:07.962]   - Field: ‘expr’
[17:38:07.962]   - Field: ‘uuid’
[17:38:07.963]   - Field: ‘seed’
[17:38:07.963]   - Field: ‘version’
[17:38:07.963]   - Field: ‘result’
[17:38:07.963]   - Field: ‘asynchronous’
[17:38:07.963]   - Field: ‘calls’
[17:38:07.963]   - Field: ‘globals’
[17:38:07.963]   - Field: ‘stdout’
[17:38:07.963]   - Field: ‘earlySignal’
[17:38:07.964]   - Field: ‘lazy’
[17:38:07.964]   - Field: ‘state’
[17:38:07.964] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:07.964] - Launch lazy future ...
[17:38:07.965] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:07.965] Packages needed by future strategies (n = 0): <none>
[17:38:07.966] {
[17:38:07.966]     {
[17:38:07.966]         {
[17:38:07.966]             ...future.startTime <- base::Sys.time()
[17:38:07.966]             {
[17:38:07.966]                 {
[17:38:07.966]                   {
[17:38:07.966]                     {
[17:38:07.966]                       {
[17:38:07.966]                         base::local({
[17:38:07.966]                           has_future <- base::requireNamespace("future", 
[17:38:07.966]                             quietly = TRUE)
[17:38:07.966]                           if (has_future) {
[17:38:07.966]                             ns <- base::getNamespace("future")
[17:38:07.966]                             version <- ns[[".package"]][["version"]]
[17:38:07.966]                             if (is.null(version)) 
[17:38:07.966]                               version <- utils::packageVersion("future")
[17:38:07.966]                           }
[17:38:07.966]                           else {
[17:38:07.966]                             version <- NULL
[17:38:07.966]                           }
[17:38:07.966]                           if (!has_future || version < "1.8.0") {
[17:38:07.966]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:07.966]                               "", base::R.version$version.string), 
[17:38:07.966]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:07.966]                                 base::R.version$platform, 8 * 
[17:38:07.966]                                   base::.Machine$sizeof.pointer), 
[17:38:07.966]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:07.966]                                 "release", "version")], collapse = " "), 
[17:38:07.966]                               hostname = base::Sys.info()[["nodename"]])
[17:38:07.966]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:07.966]                               info)
[17:38:07.966]                             info <- base::paste(info, collapse = "; ")
[17:38:07.966]                             if (!has_future) {
[17:38:07.966]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:07.966]                                 info)
[17:38:07.966]                             }
[17:38:07.966]                             else {
[17:38:07.966]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:07.966]                                 info, version)
[17:38:07.966]                             }
[17:38:07.966]                             base::stop(msg)
[17:38:07.966]                           }
[17:38:07.966]                         })
[17:38:07.966]                       }
[17:38:07.966]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:07.966]                       base::options(mc.cores = 1L)
[17:38:07.966]                     }
[17:38:07.966]                     base::local({
[17:38:07.966]                       for (pkg in "future.apply") {
[17:38:07.966]                         base::loadNamespace(pkg)
[17:38:07.966]                         base::library(pkg, character.only = TRUE)
[17:38:07.966]                       }
[17:38:07.966]                     })
[17:38:07.966]                   }
[17:38:07.966]                   ...future.strategy.old <- future::plan("list")
[17:38:07.966]                   options(future.plan = NULL)
[17:38:07.966]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.966]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:07.966]                 }
[17:38:07.966]                 ...future.workdir <- getwd()
[17:38:07.966]             }
[17:38:07.966]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:07.966]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:07.966]         }
[17:38:07.966]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:07.966]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:07.966]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:07.966]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:07.966]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:07.966]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:07.966]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:07.966]             base::names(...future.oldOptions))
[17:38:07.966]     }
[17:38:07.966]     if (FALSE) {
[17:38:07.966]     }
[17:38:07.966]     else {
[17:38:07.966]         if (TRUE) {
[17:38:07.966]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:07.966]                 open = "w")
[17:38:07.966]         }
[17:38:07.966]         else {
[17:38:07.966]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:07.966]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:07.966]         }
[17:38:07.966]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:07.966]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:07.966]             base::sink(type = "output", split = FALSE)
[17:38:07.966]             base::close(...future.stdout)
[17:38:07.966]         }, add = TRUE)
[17:38:07.966]     }
[17:38:07.966]     ...future.frame <- base::sys.nframe()
[17:38:07.966]     ...future.conditions <- base::list()
[17:38:07.966]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:07.966]     if (FALSE) {
[17:38:07.966]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:07.966]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:07.966]     }
[17:38:07.966]     ...future.result <- base::tryCatch({
[17:38:07.966]         base::withCallingHandlers({
[17:38:07.966]             ...future.value <- base::withVisible(base::local({
[17:38:07.966]                 withCallingHandlers({
[17:38:07.966]                   {
[17:38:07.966]                     do.call(function(...) {
[17:38:07.966]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.966]                       if (!identical(...future.globals.maxSize.org, 
[17:38:07.966]                         ...future.globals.maxSize)) {
[17:38:07.966]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.966]                         on.exit(options(oopts), add = TRUE)
[17:38:07.966]                       }
[17:38:07.966]                       {
[17:38:07.966]                         lapply(seq_along(...future.elements_ii), 
[17:38:07.966]                           FUN = function(jj) {
[17:38:07.966]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.966]                             ...future.FUN(...future.X_jj, ...)
[17:38:07.966]                           })
[17:38:07.966]                       }
[17:38:07.966]                     }, args = future.call.arguments)
[17:38:07.966]                   }
[17:38:07.966]                 }, immediateCondition = function(cond) {
[17:38:07.966]                   save_rds <- function (object, pathname, ...) 
[17:38:07.966]                   {
[17:38:07.966]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:07.966]                     if (file_test("-f", pathname_tmp)) {
[17:38:07.966]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.966]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:07.966]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.966]                         fi_tmp[["mtime"]])
[17:38:07.966]                     }
[17:38:07.966]                     tryCatch({
[17:38:07.966]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:07.966]                     }, error = function(ex) {
[17:38:07.966]                       msg <- conditionMessage(ex)
[17:38:07.966]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.966]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:07.966]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.966]                         fi_tmp[["mtime"]], msg)
[17:38:07.966]                       ex$message <- msg
[17:38:07.966]                       stop(ex)
[17:38:07.966]                     })
[17:38:07.966]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:07.966]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:07.966]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:07.966]                       fi_tmp <- file.info(pathname_tmp)
[17:38:07.966]                       fi <- file.info(pathname)
[17:38:07.966]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:07.966]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:07.966]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:07.966]                         fi[["size"]], fi[["mtime"]])
[17:38:07.966]                       stop(msg)
[17:38:07.966]                     }
[17:38:07.966]                     invisible(pathname)
[17:38:07.966]                   }
[17:38:07.966]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:07.966]                     rootPath = tempdir()) 
[17:38:07.966]                   {
[17:38:07.966]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:07.966]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:07.966]                       tmpdir = path, fileext = ".rds")
[17:38:07.966]                     save_rds(obj, file)
[17:38:07.966]                   }
[17:38:07.966]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:07.966]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.966]                   {
[17:38:07.966]                     inherits <- base::inherits
[17:38:07.966]                     invokeRestart <- base::invokeRestart
[17:38:07.966]                     is.null <- base::is.null
[17:38:07.966]                     muffled <- FALSE
[17:38:07.966]                     if (inherits(cond, "message")) {
[17:38:07.966]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:07.966]                       if (muffled) 
[17:38:07.966]                         invokeRestart("muffleMessage")
[17:38:07.966]                     }
[17:38:07.966]                     else if (inherits(cond, "warning")) {
[17:38:07.966]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:07.966]                       if (muffled) 
[17:38:07.966]                         invokeRestart("muffleWarning")
[17:38:07.966]                     }
[17:38:07.966]                     else if (inherits(cond, "condition")) {
[17:38:07.966]                       if (!is.null(pattern)) {
[17:38:07.966]                         computeRestarts <- base::computeRestarts
[17:38:07.966]                         grepl <- base::grepl
[17:38:07.966]                         restarts <- computeRestarts(cond)
[17:38:07.966]                         for (restart in restarts) {
[17:38:07.966]                           name <- restart$name
[17:38:07.966]                           if (is.null(name)) 
[17:38:07.966]                             next
[17:38:07.966]                           if (!grepl(pattern, name)) 
[17:38:07.966]                             next
[17:38:07.966]                           invokeRestart(restart)
[17:38:07.966]                           muffled <- TRUE
[17:38:07.966]                           break
[17:38:07.966]                         }
[17:38:07.966]                       }
[17:38:07.966]                     }
[17:38:07.966]                     invisible(muffled)
[17:38:07.966]                   }
[17:38:07.966]                   muffleCondition(cond)
[17:38:07.966]                 })
[17:38:07.966]             }))
[17:38:07.966]             future::FutureResult(value = ...future.value$value, 
[17:38:07.966]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.966]                   ...future.rng), globalenv = if (FALSE) 
[17:38:07.966]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:07.966]                     ...future.globalenv.names))
[17:38:07.966]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:07.966]         }, condition = base::local({
[17:38:07.966]             c <- base::c
[17:38:07.966]             inherits <- base::inherits
[17:38:07.966]             invokeRestart <- base::invokeRestart
[17:38:07.966]             length <- base::length
[17:38:07.966]             list <- base::list
[17:38:07.966]             seq.int <- base::seq.int
[17:38:07.966]             signalCondition <- base::signalCondition
[17:38:07.966]             sys.calls <- base::sys.calls
[17:38:07.966]             `[[` <- base::`[[`
[17:38:07.966]             `+` <- base::`+`
[17:38:07.966]             `<<-` <- base::`<<-`
[17:38:07.966]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:07.966]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:07.966]                   3L)]
[17:38:07.966]             }
[17:38:07.966]             function(cond) {
[17:38:07.966]                 is_error <- inherits(cond, "error")
[17:38:07.966]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:07.966]                   NULL)
[17:38:07.966]                 if (is_error) {
[17:38:07.966]                   sessionInformation <- function() {
[17:38:07.966]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:07.966]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:07.966]                       search = base::search(), system = base::Sys.info())
[17:38:07.966]                   }
[17:38:07.966]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.966]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:07.966]                     cond$call), session = sessionInformation(), 
[17:38:07.966]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:07.966]                   signalCondition(cond)
[17:38:07.966]                 }
[17:38:07.966]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:07.966]                 "immediateCondition"))) {
[17:38:07.966]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:07.966]                   ...future.conditions[[length(...future.conditions) + 
[17:38:07.966]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:07.966]                   if (TRUE && !signal) {
[17:38:07.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.966]                     {
[17:38:07.966]                       inherits <- base::inherits
[17:38:07.966]                       invokeRestart <- base::invokeRestart
[17:38:07.966]                       is.null <- base::is.null
[17:38:07.966]                       muffled <- FALSE
[17:38:07.966]                       if (inherits(cond, "message")) {
[17:38:07.966]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.966]                         if (muffled) 
[17:38:07.966]                           invokeRestart("muffleMessage")
[17:38:07.966]                       }
[17:38:07.966]                       else if (inherits(cond, "warning")) {
[17:38:07.966]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.966]                         if (muffled) 
[17:38:07.966]                           invokeRestart("muffleWarning")
[17:38:07.966]                       }
[17:38:07.966]                       else if (inherits(cond, "condition")) {
[17:38:07.966]                         if (!is.null(pattern)) {
[17:38:07.966]                           computeRestarts <- base::computeRestarts
[17:38:07.966]                           grepl <- base::grepl
[17:38:07.966]                           restarts <- computeRestarts(cond)
[17:38:07.966]                           for (restart in restarts) {
[17:38:07.966]                             name <- restart$name
[17:38:07.966]                             if (is.null(name)) 
[17:38:07.966]                               next
[17:38:07.966]                             if (!grepl(pattern, name)) 
[17:38:07.966]                               next
[17:38:07.966]                             invokeRestart(restart)
[17:38:07.966]                             muffled <- TRUE
[17:38:07.966]                             break
[17:38:07.966]                           }
[17:38:07.966]                         }
[17:38:07.966]                       }
[17:38:07.966]                       invisible(muffled)
[17:38:07.966]                     }
[17:38:07.966]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.966]                   }
[17:38:07.966]                 }
[17:38:07.966]                 else {
[17:38:07.966]                   if (TRUE) {
[17:38:07.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:07.966]                     {
[17:38:07.966]                       inherits <- base::inherits
[17:38:07.966]                       invokeRestart <- base::invokeRestart
[17:38:07.966]                       is.null <- base::is.null
[17:38:07.966]                       muffled <- FALSE
[17:38:07.966]                       if (inherits(cond, "message")) {
[17:38:07.966]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:07.966]                         if (muffled) 
[17:38:07.966]                           invokeRestart("muffleMessage")
[17:38:07.966]                       }
[17:38:07.966]                       else if (inherits(cond, "warning")) {
[17:38:07.966]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:07.966]                         if (muffled) 
[17:38:07.966]                           invokeRestart("muffleWarning")
[17:38:07.966]                       }
[17:38:07.966]                       else if (inherits(cond, "condition")) {
[17:38:07.966]                         if (!is.null(pattern)) {
[17:38:07.966]                           computeRestarts <- base::computeRestarts
[17:38:07.966]                           grepl <- base::grepl
[17:38:07.966]                           restarts <- computeRestarts(cond)
[17:38:07.966]                           for (restart in restarts) {
[17:38:07.966]                             name <- restart$name
[17:38:07.966]                             if (is.null(name)) 
[17:38:07.966]                               next
[17:38:07.966]                             if (!grepl(pattern, name)) 
[17:38:07.966]                               next
[17:38:07.966]                             invokeRestart(restart)
[17:38:07.966]                             muffled <- TRUE
[17:38:07.966]                             break
[17:38:07.966]                           }
[17:38:07.966]                         }
[17:38:07.966]                       }
[17:38:07.966]                       invisible(muffled)
[17:38:07.966]                     }
[17:38:07.966]                     muffleCondition(cond, pattern = "^muffle")
[17:38:07.966]                   }
[17:38:07.966]                 }
[17:38:07.966]             }
[17:38:07.966]         }))
[17:38:07.966]     }, error = function(ex) {
[17:38:07.966]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:07.966]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:07.966]                 ...future.rng), started = ...future.startTime, 
[17:38:07.966]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:07.966]             version = "1.8"), class = "FutureResult")
[17:38:07.966]     }, finally = {
[17:38:07.966]         if (!identical(...future.workdir, getwd())) 
[17:38:07.966]             setwd(...future.workdir)
[17:38:07.966]         {
[17:38:07.966]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:07.966]                 ...future.oldOptions$nwarnings <- NULL
[17:38:07.966]             }
[17:38:07.966]             base::options(...future.oldOptions)
[17:38:07.966]             if (.Platform$OS.type == "windows") {
[17:38:07.966]                 old_names <- names(...future.oldEnvVars)
[17:38:07.966]                 envs <- base::Sys.getenv()
[17:38:07.966]                 names <- names(envs)
[17:38:07.966]                 common <- intersect(names, old_names)
[17:38:07.966]                 added <- setdiff(names, old_names)
[17:38:07.966]                 removed <- setdiff(old_names, names)
[17:38:07.966]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:07.966]                   envs[common]]
[17:38:07.966]                 NAMES <- toupper(changed)
[17:38:07.966]                 args <- list()
[17:38:07.966]                 for (kk in seq_along(NAMES)) {
[17:38:07.966]                   name <- changed[[kk]]
[17:38:07.966]                   NAME <- NAMES[[kk]]
[17:38:07.966]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.966]                     next
[17:38:07.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.966]                 }
[17:38:07.966]                 NAMES <- toupper(added)
[17:38:07.966]                 for (kk in seq_along(NAMES)) {
[17:38:07.966]                   name <- added[[kk]]
[17:38:07.966]                   NAME <- NAMES[[kk]]
[17:38:07.966]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.966]                     next
[17:38:07.966]                   args[[name]] <- ""
[17:38:07.966]                 }
[17:38:07.966]                 NAMES <- toupper(removed)
[17:38:07.966]                 for (kk in seq_along(NAMES)) {
[17:38:07.966]                   name <- removed[[kk]]
[17:38:07.966]                   NAME <- NAMES[[kk]]
[17:38:07.966]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:07.966]                     next
[17:38:07.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:07.966]                 }
[17:38:07.966]                 if (length(args) > 0) 
[17:38:07.966]                   base::do.call(base::Sys.setenv, args = args)
[17:38:07.966]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:07.966]             }
[17:38:07.966]             else {
[17:38:07.966]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:07.966]             }
[17:38:07.966]             {
[17:38:07.966]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:07.966]                   0L) {
[17:38:07.966]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:07.966]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:07.966]                   base::options(opts)
[17:38:07.966]                 }
[17:38:07.966]                 {
[17:38:07.966]                   {
[17:38:07.966]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:07.966]                     NULL
[17:38:07.966]                   }
[17:38:07.966]                   options(future.plan = NULL)
[17:38:07.966]                   if (is.na(NA_character_)) 
[17:38:07.966]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:07.966]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:07.966]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:07.966]                     .init = FALSE)
[17:38:07.966]                 }
[17:38:07.966]             }
[17:38:07.966]         }
[17:38:07.966]     })
[17:38:07.966]     if (TRUE) {
[17:38:07.966]         base::sink(type = "output", split = FALSE)
[17:38:07.966]         if (TRUE) {
[17:38:07.966]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:07.966]         }
[17:38:07.966]         else {
[17:38:07.966]             ...future.result["stdout"] <- base::list(NULL)
[17:38:07.966]         }
[17:38:07.966]         base::close(...future.stdout)
[17:38:07.966]         ...future.stdout <- NULL
[17:38:07.966]     }
[17:38:07.966]     ...future.result$conditions <- ...future.conditions
[17:38:07.966]     ...future.result$finished <- base::Sys.time()
[17:38:07.966]     ...future.result
[17:38:07.966] }
[17:38:07.969] assign_globals() ...
[17:38:07.969] List of 11
[17:38:07.969]  $ ...future.FUN            :function (x, ...)  
[17:38:07.969]  $ x_FUN                    :function (x)  
[17:38:07.969]  $ times                    : int 2
[17:38:07.969]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:07.969]  $ stop_if_not              :function (...)  
[17:38:07.969]  $ dim                      : NULL
[17:38:07.969]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:07.969]  $ future.call.arguments    : list()
[17:38:07.969]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:07.969]  $ ...future.elements_ii    :List of 5
[17:38:07.969]   ..$ : int 6
[17:38:07.969]   ..$ : int 7
[17:38:07.969]   ..$ : int 8
[17:38:07.969]   ..$ : int 9
[17:38:07.969]   ..$ : int 10
[17:38:07.969]  $ ...future.seeds_ii       : NULL
[17:38:07.969]  $ ...future.globals.maxSize: NULL
[17:38:07.969]  - attr(*, "where")=List of 11
[17:38:07.969]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:07.969]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:07.969]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:07.969]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:07.969]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:07.969]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:07.969]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:07.969]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:07.969]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:07.969]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:07.969]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:07.969]  - attr(*, "resolved")= logi FALSE
[17:38:07.969]  - attr(*, "total_size")= num 96456
[17:38:07.969]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:07.969]  - attr(*, "already-done")= logi TRUE
[17:38:07.986] - copied ‘...future.FUN’ to environment
[17:38:07.986] - reassign environment for ‘x_FUN’
[17:38:07.986] - copied ‘x_FUN’ to environment
[17:38:07.986] - copied ‘times’ to environment
[17:38:07.986] - copied ‘stopf’ to environment
[17:38:07.986] - copied ‘stop_if_not’ to environment
[17:38:07.987] - copied ‘dim’ to environment
[17:38:07.987] - copied ‘valid_types’ to environment
[17:38:07.987] - copied ‘future.call.arguments’ to environment
[17:38:07.987] - copied ‘...future.elements_ii’ to environment
[17:38:07.987] - copied ‘...future.seeds_ii’ to environment
[17:38:07.987] - copied ‘...future.globals.maxSize’ to environment
[17:38:07.987] assign_globals() ... done
[17:38:07.987] requestCore(): workers = 2
[17:38:07.990] MulticoreFuture started
[17:38:07.990] - Launch lazy future ... done
[17:38:07.991] run() for ‘MulticoreFuture’ ... done
[17:38:07.991] Created future:
[17:38:07.991] plan(): Setting new future strategy stack:
[17:38:07.992] List of future strategies:
[17:38:07.992] 1. sequential:
[17:38:07.992]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:07.992]    - tweaked: FALSE
[17:38:07.992]    - call: NULL
[17:38:07.993] plan(): nbrOfWorkers() = 1
[17:38:07.995] plan(): Setting new future strategy stack:
[17:38:07.995] List of future strategies:
[17:38:07.995] 1. multicore:
[17:38:07.995]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:07.995]    - tweaked: FALSE
[17:38:07.995]    - call: plan(strategy)
[17:38:08.001] plan(): nbrOfWorkers() = 2
[17:38:07.991] MulticoreFuture:
[17:38:07.991] Label: ‘future_vapply-2’
[17:38:07.991] Expression:
[17:38:07.991] {
[17:38:07.991]     do.call(function(...) {
[17:38:07.991]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:07.991]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:07.991]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:07.991]             on.exit(options(oopts), add = TRUE)
[17:38:07.991]         }
[17:38:07.991]         {
[17:38:07.991]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:07.991]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:07.991]                 ...future.FUN(...future.X_jj, ...)
[17:38:07.991]             })
[17:38:07.991]         }
[17:38:07.991]     }, args = future.call.arguments)
[17:38:07.991] }
[17:38:07.991] Lazy evaluation: FALSE
[17:38:07.991] Asynchronous evaluation: TRUE
[17:38:07.991] Local evaluation: TRUE
[17:38:07.991] Environment: R_GlobalEnv
[17:38:07.991] Capture standard output: TRUE
[17:38:07.991] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:07.991] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:07.991] Packages: 1 packages (‘future.apply’)
[17:38:07.991] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:07.991] Resolved: TRUE
[17:38:07.991] Value: <not collected>
[17:38:07.991] Conditions captured: <none>
[17:38:07.991] Early signaling: FALSE
[17:38:07.991] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:07.991] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.002] Chunk #2 of 2 ... DONE
[17:38:08.002] Launching 2 futures (chunks) ... DONE
[17:38:08.002] Resolving 2 futures (chunks) ...
[17:38:08.002] resolve() on list ...
[17:38:08.002]  recursive: 0
[17:38:08.003]  length: 2
[17:38:08.003] 
[17:38:08.003] Future #1
[17:38:08.003] result() for MulticoreFuture ...
[17:38:08.004] result() for MulticoreFuture ...
[17:38:08.004] result() for MulticoreFuture ... done
[17:38:08.005] result() for MulticoreFuture ... done
[17:38:08.005] result() for MulticoreFuture ...
[17:38:08.005] result() for MulticoreFuture ... done
[17:38:08.005] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:08.005] - nx: 2
[17:38:08.005] - relay: TRUE
[17:38:08.005] - stdout: TRUE
[17:38:08.006] - signal: TRUE
[17:38:08.006] - resignal: FALSE
[17:38:08.006] - force: TRUE
[17:38:08.006] - relayed: [n=2] FALSE, FALSE
[17:38:08.006] - queued futures: [n=2] FALSE, FALSE
[17:38:08.006]  - until=1
[17:38:08.006]  - relaying element #1
[17:38:08.007] result() for MulticoreFuture ...
[17:38:08.007] result() for MulticoreFuture ... done
[17:38:08.007] result() for MulticoreFuture ...
[17:38:08.007] result() for MulticoreFuture ... done
[17:38:08.007] result() for MulticoreFuture ...
[17:38:08.007] result() for MulticoreFuture ... done
[17:38:08.008] result() for MulticoreFuture ...
[17:38:08.008] result() for MulticoreFuture ... done
[17:38:08.008] - relayed: [n=2] TRUE, FALSE
[17:38:08.008] - queued futures: [n=2] TRUE, FALSE
[17:38:08.008] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:08.008]  length: 1 (resolved future 1)
[17:38:08.009] Future #2
[17:38:08.009] result() for MulticoreFuture ...
[17:38:08.010] result() for MulticoreFuture ...
[17:38:08.010] result() for MulticoreFuture ... done
[17:38:08.010] result() for MulticoreFuture ... done
[17:38:08.010] result() for MulticoreFuture ...
[17:38:08.010] result() for MulticoreFuture ... done
[17:38:08.010] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:08.011] - nx: 2
[17:38:08.011] - relay: TRUE
[17:38:08.011] - stdout: TRUE
[17:38:08.011] - signal: TRUE
[17:38:08.011] - resignal: FALSE
[17:38:08.011] - force: TRUE
[17:38:08.011] - relayed: [n=2] TRUE, FALSE
[17:38:08.011] - queued futures: [n=2] TRUE, FALSE
[17:38:08.011]  - until=2
[17:38:08.012]  - relaying element #2
[17:38:08.012] result() for MulticoreFuture ...
[17:38:08.012] result() for MulticoreFuture ... done
[17:38:08.012] result() for MulticoreFuture ...
[17:38:08.012] result() for MulticoreFuture ... done
[17:38:08.012] result() for MulticoreFuture ...
[17:38:08.012] result() for MulticoreFuture ... done
[17:38:08.013] result() for MulticoreFuture ...
[17:38:08.013] result() for MulticoreFuture ... done
[17:38:08.013] - relayed: [n=2] TRUE, TRUE
[17:38:08.013] - queued futures: [n=2] TRUE, TRUE
[17:38:08.013] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:08.013]  length: 0 (resolved future 2)
[17:38:08.013] Relaying remaining futures
[17:38:08.013] signalConditionsASAP(NULL, pos=0) ...
[17:38:08.013] - nx: 2
[17:38:08.014] - relay: TRUE
[17:38:08.014] - stdout: TRUE
[17:38:08.014] - signal: TRUE
[17:38:08.014] - resignal: FALSE
[17:38:08.014] - force: TRUE
[17:38:08.014] - relayed: [n=2] TRUE, TRUE
[17:38:08.014] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:08.014] - relayed: [n=2] TRUE, TRUE
[17:38:08.014] - queued futures: [n=2] TRUE, TRUE
[17:38:08.015] signalConditionsASAP(NULL, pos=0) ... done
[17:38:08.015] resolve() on list ... DONE
[17:38:08.015] result() for MulticoreFuture ...
[17:38:08.015] result() for MulticoreFuture ... done
[17:38:08.015] result() for MulticoreFuture ...
[17:38:08.015] result() for MulticoreFuture ... done
[17:38:08.015] result() for MulticoreFuture ...
[17:38:08.015] result() for MulticoreFuture ... done
[17:38:08.016] result() for MulticoreFuture ...
[17:38:08.016] result() for MulticoreFuture ... done
[17:38:08.016]  - Number of value chunks collected: 2
[17:38:08.016] Resolving 2 futures (chunks) ... DONE
[17:38:08.016] Reducing values from 2 chunks ...
[17:38:08.016]  - Number of values collected after concatenation: 10
[17:38:08.016]  - Number of values expected: 10
[17:38:08.016] Reducing values from 2 chunks ... DONE
[17:38:08.016] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:38:08.018] future_lapply() ...
[17:38:08.025] Number of chunks: 2
[17:38:08.025] getGlobalsAndPackagesXApply() ...
[17:38:08.025]  - future.globals: TRUE
[17:38:08.025] getGlobalsAndPackages() ...
[17:38:08.025] Searching for globals...
[17:38:08.033] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:38:08.033] Searching for globals ... DONE
[17:38:08.033] Resolving globals: FALSE
[17:38:08.034] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[17:38:08.034] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:08.035] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:08.035] - packages: [1] ‘future.apply’
[17:38:08.035] getGlobalsAndPackages() ... DONE
[17:38:08.035]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:08.035]  - needed namespaces: [n=1] ‘future.apply’
[17:38:08.035] Finding globals ... DONE
[17:38:08.035]  - use_args: TRUE
[17:38:08.035]  - Getting '...' globals ...
[17:38:08.036] resolve() on list ...
[17:38:08.036]  recursive: 0
[17:38:08.036]  length: 1
[17:38:08.036]  elements: ‘...’
[17:38:08.036]  length: 0 (resolved future 1)
[17:38:08.036] resolve() on list ... DONE
[17:38:08.036]    - '...' content: [n=0] 
[17:38:08.036] List of 1
[17:38:08.036]  $ ...: list()
[17:38:08.036]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.036]  - attr(*, "where")=List of 1
[17:38:08.036]   ..$ ...:<environment: 0x560801905720> 
[17:38:08.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.036]  - attr(*, "resolved")= logi TRUE
[17:38:08.036]  - attr(*, "total_size")= num NA
[17:38:08.039]  - Getting '...' globals ... DONE
[17:38:08.039] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:08.039] List of 8
[17:38:08.039]  $ ...future.FUN:function (x, ...)  
[17:38:08.039]  $ x_FUN        :function (x)  
[17:38:08.039]  $ times        : int 4
[17:38:08.039]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.039]  $ stop_if_not  :function (...)  
[17:38:08.039]  $ dim          : int [1:2] 2 2
[17:38:08.039]  $ valid_types  : chr [1:2] "logical" "integer"
[17:38:08.039]  $ ...          : list()
[17:38:08.039]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.039]  - attr(*, "where")=List of 8
[17:38:08.039]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:08.039]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:08.039]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:08.039]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:08.039]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:08.039]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:08.039]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:08.039]   ..$ ...          :<environment: 0x560801905720> 
[17:38:08.039]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.039]  - attr(*, "resolved")= logi FALSE
[17:38:08.039]  - attr(*, "total_size")= num 97232
[17:38:08.045] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:08.045] getGlobalsAndPackagesXApply() ... DONE
[17:38:08.045] Number of futures (= number of chunks): 2
[17:38:08.045] Launching 2 futures (chunks) ...
[17:38:08.045] Chunk #1 of 2 ...
[17:38:08.046]  - Finding globals in 'X' for chunk #1 ...
[17:38:08.046] getGlobalsAndPackages() ...
[17:38:08.046] Searching for globals...
[17:38:08.046] 
[17:38:08.046] Searching for globals ... DONE
[17:38:08.046] - globals: [0] <none>
[17:38:08.046] getGlobalsAndPackages() ... DONE
[17:38:08.046]    + additional globals found: [n=0] 
[17:38:08.046]    + additional namespaces needed: [n=0] 
[17:38:08.047]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:08.047]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:08.047]  - seeds: <none>
[17:38:08.047]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.047] getGlobalsAndPackages() ...
[17:38:08.047] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.047] Resolving globals: FALSE
[17:38:08.047] Tweak future expression to call with '...' arguments ...
[17:38:08.047] {
[17:38:08.047]     do.call(function(...) {
[17:38:08.047]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.047]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.047]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.047]             on.exit(options(oopts), add = TRUE)
[17:38:08.047]         }
[17:38:08.047]         {
[17:38:08.047]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.047]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.047]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.047]             })
[17:38:08.047]         }
[17:38:08.047]     }, args = future.call.arguments)
[17:38:08.047] }
[17:38:08.048] Tweak future expression to call with '...' arguments ... DONE
[17:38:08.048] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.048] - packages: [1] ‘future.apply’
[17:38:08.049] getGlobalsAndPackages() ... DONE
[17:38:08.049] run() for ‘Future’ ...
[17:38:08.049] - state: ‘created’
[17:38:08.051] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:08.055] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.055] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:08.055]   - Field: ‘label’
[17:38:08.056]   - Field: ‘local’
[17:38:08.056]   - Field: ‘owner’
[17:38:08.056]   - Field: ‘envir’
[17:38:08.056]   - Field: ‘workers’
[17:38:08.056]   - Field: ‘packages’
[17:38:08.056]   - Field: ‘gc’
[17:38:08.056]   - Field: ‘job’
[17:38:08.056]   - Field: ‘conditions’
[17:38:08.057]   - Field: ‘expr’
[17:38:08.057]   - Field: ‘uuid’
[17:38:08.057]   - Field: ‘seed’
[17:38:08.057]   - Field: ‘version’
[17:38:08.057]   - Field: ‘result’
[17:38:08.057]   - Field: ‘asynchronous’
[17:38:08.057]   - Field: ‘calls’
[17:38:08.057]   - Field: ‘globals’
[17:38:08.057]   - Field: ‘stdout’
[17:38:08.058]   - Field: ‘earlySignal’
[17:38:08.058]   - Field: ‘lazy’
[17:38:08.058]   - Field: ‘state’
[17:38:08.058] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:08.058] - Launch lazy future ...
[17:38:08.058] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:08.058] Packages needed by future strategies (n = 0): <none>
[17:38:08.059] {
[17:38:08.059]     {
[17:38:08.059]         {
[17:38:08.059]             ...future.startTime <- base::Sys.time()
[17:38:08.059]             {
[17:38:08.059]                 {
[17:38:08.059]                   {
[17:38:08.059]                     {
[17:38:08.059]                       {
[17:38:08.059]                         base::local({
[17:38:08.059]                           has_future <- base::requireNamespace("future", 
[17:38:08.059]                             quietly = TRUE)
[17:38:08.059]                           if (has_future) {
[17:38:08.059]                             ns <- base::getNamespace("future")
[17:38:08.059]                             version <- ns[[".package"]][["version"]]
[17:38:08.059]                             if (is.null(version)) 
[17:38:08.059]                               version <- utils::packageVersion("future")
[17:38:08.059]                           }
[17:38:08.059]                           else {
[17:38:08.059]                             version <- NULL
[17:38:08.059]                           }
[17:38:08.059]                           if (!has_future || version < "1.8.0") {
[17:38:08.059]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:08.059]                               "", base::R.version$version.string), 
[17:38:08.059]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:08.059]                                 base::R.version$platform, 8 * 
[17:38:08.059]                                   base::.Machine$sizeof.pointer), 
[17:38:08.059]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:08.059]                                 "release", "version")], collapse = " "), 
[17:38:08.059]                               hostname = base::Sys.info()[["nodename"]])
[17:38:08.059]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:08.059]                               info)
[17:38:08.059]                             info <- base::paste(info, collapse = "; ")
[17:38:08.059]                             if (!has_future) {
[17:38:08.059]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:08.059]                                 info)
[17:38:08.059]                             }
[17:38:08.059]                             else {
[17:38:08.059]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:08.059]                                 info, version)
[17:38:08.059]                             }
[17:38:08.059]                             base::stop(msg)
[17:38:08.059]                           }
[17:38:08.059]                         })
[17:38:08.059]                       }
[17:38:08.059]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:08.059]                       base::options(mc.cores = 1L)
[17:38:08.059]                     }
[17:38:08.059]                     base::local({
[17:38:08.059]                       for (pkg in "future.apply") {
[17:38:08.059]                         base::loadNamespace(pkg)
[17:38:08.059]                         base::library(pkg, character.only = TRUE)
[17:38:08.059]                       }
[17:38:08.059]                     })
[17:38:08.059]                   }
[17:38:08.059]                   ...future.strategy.old <- future::plan("list")
[17:38:08.059]                   options(future.plan = NULL)
[17:38:08.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:08.059]                 }
[17:38:08.059]                 ...future.workdir <- getwd()
[17:38:08.059]             }
[17:38:08.059]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:08.059]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:08.059]         }
[17:38:08.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:08.059]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:08.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:08.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:08.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:08.059]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:08.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:08.059]             base::names(...future.oldOptions))
[17:38:08.059]     }
[17:38:08.059]     if (FALSE) {
[17:38:08.059]     }
[17:38:08.059]     else {
[17:38:08.059]         if (TRUE) {
[17:38:08.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:08.059]                 open = "w")
[17:38:08.059]         }
[17:38:08.059]         else {
[17:38:08.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:08.059]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:08.059]         }
[17:38:08.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:08.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:08.059]             base::sink(type = "output", split = FALSE)
[17:38:08.059]             base::close(...future.stdout)
[17:38:08.059]         }, add = TRUE)
[17:38:08.059]     }
[17:38:08.059]     ...future.frame <- base::sys.nframe()
[17:38:08.059]     ...future.conditions <- base::list()
[17:38:08.059]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:08.059]     if (FALSE) {
[17:38:08.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:08.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:08.059]     }
[17:38:08.059]     ...future.result <- base::tryCatch({
[17:38:08.059]         base::withCallingHandlers({
[17:38:08.059]             ...future.value <- base::withVisible(base::local({
[17:38:08.059]                 withCallingHandlers({
[17:38:08.059]                   {
[17:38:08.059]                     do.call(function(...) {
[17:38:08.059]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.059]                       if (!identical(...future.globals.maxSize.org, 
[17:38:08.059]                         ...future.globals.maxSize)) {
[17:38:08.059]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.059]                         on.exit(options(oopts), add = TRUE)
[17:38:08.059]                       }
[17:38:08.059]                       {
[17:38:08.059]                         lapply(seq_along(...future.elements_ii), 
[17:38:08.059]                           FUN = function(jj) {
[17:38:08.059]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.059]                             ...future.FUN(...future.X_jj, ...)
[17:38:08.059]                           })
[17:38:08.059]                       }
[17:38:08.059]                     }, args = future.call.arguments)
[17:38:08.059]                   }
[17:38:08.059]                 }, immediateCondition = function(cond) {
[17:38:08.059]                   save_rds <- function (object, pathname, ...) 
[17:38:08.059]                   {
[17:38:08.059]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:08.059]                     if (file_test("-f", pathname_tmp)) {
[17:38:08.059]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.059]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:08.059]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.059]                         fi_tmp[["mtime"]])
[17:38:08.059]                     }
[17:38:08.059]                     tryCatch({
[17:38:08.059]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:08.059]                     }, error = function(ex) {
[17:38:08.059]                       msg <- conditionMessage(ex)
[17:38:08.059]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.059]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:08.059]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.059]                         fi_tmp[["mtime"]], msg)
[17:38:08.059]                       ex$message <- msg
[17:38:08.059]                       stop(ex)
[17:38:08.059]                     })
[17:38:08.059]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:08.059]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:08.059]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:08.059]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.059]                       fi <- file.info(pathname)
[17:38:08.059]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:08.059]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.059]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:08.059]                         fi[["size"]], fi[["mtime"]])
[17:38:08.059]                       stop(msg)
[17:38:08.059]                     }
[17:38:08.059]                     invisible(pathname)
[17:38:08.059]                   }
[17:38:08.059]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:08.059]                     rootPath = tempdir()) 
[17:38:08.059]                   {
[17:38:08.059]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:08.059]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:08.059]                       tmpdir = path, fileext = ".rds")
[17:38:08.059]                     save_rds(obj, file)
[17:38:08.059]                   }
[17:38:08.059]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:08.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.059]                   {
[17:38:08.059]                     inherits <- base::inherits
[17:38:08.059]                     invokeRestart <- base::invokeRestart
[17:38:08.059]                     is.null <- base::is.null
[17:38:08.059]                     muffled <- FALSE
[17:38:08.059]                     if (inherits(cond, "message")) {
[17:38:08.059]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:08.059]                       if (muffled) 
[17:38:08.059]                         invokeRestart("muffleMessage")
[17:38:08.059]                     }
[17:38:08.059]                     else if (inherits(cond, "warning")) {
[17:38:08.059]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:08.059]                       if (muffled) 
[17:38:08.059]                         invokeRestart("muffleWarning")
[17:38:08.059]                     }
[17:38:08.059]                     else if (inherits(cond, "condition")) {
[17:38:08.059]                       if (!is.null(pattern)) {
[17:38:08.059]                         computeRestarts <- base::computeRestarts
[17:38:08.059]                         grepl <- base::grepl
[17:38:08.059]                         restarts <- computeRestarts(cond)
[17:38:08.059]                         for (restart in restarts) {
[17:38:08.059]                           name <- restart$name
[17:38:08.059]                           if (is.null(name)) 
[17:38:08.059]                             next
[17:38:08.059]                           if (!grepl(pattern, name)) 
[17:38:08.059]                             next
[17:38:08.059]                           invokeRestart(restart)
[17:38:08.059]                           muffled <- TRUE
[17:38:08.059]                           break
[17:38:08.059]                         }
[17:38:08.059]                       }
[17:38:08.059]                     }
[17:38:08.059]                     invisible(muffled)
[17:38:08.059]                   }
[17:38:08.059]                   muffleCondition(cond)
[17:38:08.059]                 })
[17:38:08.059]             }))
[17:38:08.059]             future::FutureResult(value = ...future.value$value, 
[17:38:08.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.059]                   ...future.rng), globalenv = if (FALSE) 
[17:38:08.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:08.059]                     ...future.globalenv.names))
[17:38:08.059]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:08.059]         }, condition = base::local({
[17:38:08.059]             c <- base::c
[17:38:08.059]             inherits <- base::inherits
[17:38:08.059]             invokeRestart <- base::invokeRestart
[17:38:08.059]             length <- base::length
[17:38:08.059]             list <- base::list
[17:38:08.059]             seq.int <- base::seq.int
[17:38:08.059]             signalCondition <- base::signalCondition
[17:38:08.059]             sys.calls <- base::sys.calls
[17:38:08.059]             `[[` <- base::`[[`
[17:38:08.059]             `+` <- base::`+`
[17:38:08.059]             `<<-` <- base::`<<-`
[17:38:08.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:08.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:08.059]                   3L)]
[17:38:08.059]             }
[17:38:08.059]             function(cond) {
[17:38:08.059]                 is_error <- inherits(cond, "error")
[17:38:08.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:08.059]                   NULL)
[17:38:08.059]                 if (is_error) {
[17:38:08.059]                   sessionInformation <- function() {
[17:38:08.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:08.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:08.059]                       search = base::search(), system = base::Sys.info())
[17:38:08.059]                   }
[17:38:08.059]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:08.059]                     cond$call), session = sessionInformation(), 
[17:38:08.059]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:08.059]                   signalCondition(cond)
[17:38:08.059]                 }
[17:38:08.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:08.059]                 "immediateCondition"))) {
[17:38:08.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:08.059]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:08.059]                   if (TRUE && !signal) {
[17:38:08.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.059]                     {
[17:38:08.059]                       inherits <- base::inherits
[17:38:08.059]                       invokeRestart <- base::invokeRestart
[17:38:08.059]                       is.null <- base::is.null
[17:38:08.059]                       muffled <- FALSE
[17:38:08.059]                       if (inherits(cond, "message")) {
[17:38:08.059]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.059]                         if (muffled) 
[17:38:08.059]                           invokeRestart("muffleMessage")
[17:38:08.059]                       }
[17:38:08.059]                       else if (inherits(cond, "warning")) {
[17:38:08.059]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.059]                         if (muffled) 
[17:38:08.059]                           invokeRestart("muffleWarning")
[17:38:08.059]                       }
[17:38:08.059]                       else if (inherits(cond, "condition")) {
[17:38:08.059]                         if (!is.null(pattern)) {
[17:38:08.059]                           computeRestarts <- base::computeRestarts
[17:38:08.059]                           grepl <- base::grepl
[17:38:08.059]                           restarts <- computeRestarts(cond)
[17:38:08.059]                           for (restart in restarts) {
[17:38:08.059]                             name <- restart$name
[17:38:08.059]                             if (is.null(name)) 
[17:38:08.059]                               next
[17:38:08.059]                             if (!grepl(pattern, name)) 
[17:38:08.059]                               next
[17:38:08.059]                             invokeRestart(restart)
[17:38:08.059]                             muffled <- TRUE
[17:38:08.059]                             break
[17:38:08.059]                           }
[17:38:08.059]                         }
[17:38:08.059]                       }
[17:38:08.059]                       invisible(muffled)
[17:38:08.059]                     }
[17:38:08.059]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.059]                   }
[17:38:08.059]                 }
[17:38:08.059]                 else {
[17:38:08.059]                   if (TRUE) {
[17:38:08.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.059]                     {
[17:38:08.059]                       inherits <- base::inherits
[17:38:08.059]                       invokeRestart <- base::invokeRestart
[17:38:08.059]                       is.null <- base::is.null
[17:38:08.059]                       muffled <- FALSE
[17:38:08.059]                       if (inherits(cond, "message")) {
[17:38:08.059]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.059]                         if (muffled) 
[17:38:08.059]                           invokeRestart("muffleMessage")
[17:38:08.059]                       }
[17:38:08.059]                       else if (inherits(cond, "warning")) {
[17:38:08.059]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.059]                         if (muffled) 
[17:38:08.059]                           invokeRestart("muffleWarning")
[17:38:08.059]                       }
[17:38:08.059]                       else if (inherits(cond, "condition")) {
[17:38:08.059]                         if (!is.null(pattern)) {
[17:38:08.059]                           computeRestarts <- base::computeRestarts
[17:38:08.059]                           grepl <- base::grepl
[17:38:08.059]                           restarts <- computeRestarts(cond)
[17:38:08.059]                           for (restart in restarts) {
[17:38:08.059]                             name <- restart$name
[17:38:08.059]                             if (is.null(name)) 
[17:38:08.059]                               next
[17:38:08.059]                             if (!grepl(pattern, name)) 
[17:38:08.059]                               next
[17:38:08.059]                             invokeRestart(restart)
[17:38:08.059]                             muffled <- TRUE
[17:38:08.059]                             break
[17:38:08.059]                           }
[17:38:08.059]                         }
[17:38:08.059]                       }
[17:38:08.059]                       invisible(muffled)
[17:38:08.059]                     }
[17:38:08.059]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.059]                   }
[17:38:08.059]                 }
[17:38:08.059]             }
[17:38:08.059]         }))
[17:38:08.059]     }, error = function(ex) {
[17:38:08.059]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:08.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.059]                 ...future.rng), started = ...future.startTime, 
[17:38:08.059]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:08.059]             version = "1.8"), class = "FutureResult")
[17:38:08.059]     }, finally = {
[17:38:08.059]         if (!identical(...future.workdir, getwd())) 
[17:38:08.059]             setwd(...future.workdir)
[17:38:08.059]         {
[17:38:08.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:08.059]                 ...future.oldOptions$nwarnings <- NULL
[17:38:08.059]             }
[17:38:08.059]             base::options(...future.oldOptions)
[17:38:08.059]             if (.Platform$OS.type == "windows") {
[17:38:08.059]                 old_names <- names(...future.oldEnvVars)
[17:38:08.059]                 envs <- base::Sys.getenv()
[17:38:08.059]                 names <- names(envs)
[17:38:08.059]                 common <- intersect(names, old_names)
[17:38:08.059]                 added <- setdiff(names, old_names)
[17:38:08.059]                 removed <- setdiff(old_names, names)
[17:38:08.059]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:08.059]                   envs[common]]
[17:38:08.059]                 NAMES <- toupper(changed)
[17:38:08.059]                 args <- list()
[17:38:08.059]                 for (kk in seq_along(NAMES)) {
[17:38:08.059]                   name <- changed[[kk]]
[17:38:08.059]                   NAME <- NAMES[[kk]]
[17:38:08.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.059]                     next
[17:38:08.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.059]                 }
[17:38:08.059]                 NAMES <- toupper(added)
[17:38:08.059]                 for (kk in seq_along(NAMES)) {
[17:38:08.059]                   name <- added[[kk]]
[17:38:08.059]                   NAME <- NAMES[[kk]]
[17:38:08.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.059]                     next
[17:38:08.059]                   args[[name]] <- ""
[17:38:08.059]                 }
[17:38:08.059]                 NAMES <- toupper(removed)
[17:38:08.059]                 for (kk in seq_along(NAMES)) {
[17:38:08.059]                   name <- removed[[kk]]
[17:38:08.059]                   NAME <- NAMES[[kk]]
[17:38:08.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.059]                     next
[17:38:08.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.059]                 }
[17:38:08.059]                 if (length(args) > 0) 
[17:38:08.059]                   base::do.call(base::Sys.setenv, args = args)
[17:38:08.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:08.059]             }
[17:38:08.059]             else {
[17:38:08.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:08.059]             }
[17:38:08.059]             {
[17:38:08.059]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:08.059]                   0L) {
[17:38:08.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:08.059]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:08.059]                   base::options(opts)
[17:38:08.059]                 }
[17:38:08.059]                 {
[17:38:08.059]                   {
[17:38:08.059]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:08.059]                     NULL
[17:38:08.059]                   }
[17:38:08.059]                   options(future.plan = NULL)
[17:38:08.059]                   if (is.na(NA_character_)) 
[17:38:08.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:08.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:08.059]                     .init = FALSE)
[17:38:08.059]                 }
[17:38:08.059]             }
[17:38:08.059]         }
[17:38:08.059]     })
[17:38:08.059]     if (TRUE) {
[17:38:08.059]         base::sink(type = "output", split = FALSE)
[17:38:08.059]         if (TRUE) {
[17:38:08.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:08.059]         }
[17:38:08.059]         else {
[17:38:08.059]             ...future.result["stdout"] <- base::list(NULL)
[17:38:08.059]         }
[17:38:08.059]         base::close(...future.stdout)
[17:38:08.059]         ...future.stdout <- NULL
[17:38:08.059]     }
[17:38:08.059]     ...future.result$conditions <- ...future.conditions
[17:38:08.059]     ...future.result$finished <- base::Sys.time()
[17:38:08.059]     ...future.result
[17:38:08.059] }
[17:38:08.062] assign_globals() ...
[17:38:08.062] List of 11
[17:38:08.062]  $ ...future.FUN            :function (x, ...)  
[17:38:08.062]  $ x_FUN                    :function (x)  
[17:38:08.062]  $ times                    : int 4
[17:38:08.062]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.062]  $ stop_if_not              :function (...)  
[17:38:08.062]  $ dim                      : int [1:2] 2 2
[17:38:08.062]  $ valid_types              : chr [1:2] "logical" "integer"
[17:38:08.062]  $ future.call.arguments    : list()
[17:38:08.062]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.062]  $ ...future.elements_ii    :List of 5
[17:38:08.062]   ..$ : int 1
[17:38:08.062]   ..$ : int 2
[17:38:08.062]   ..$ : int 3
[17:38:08.062]   ..$ : int 4
[17:38:08.062]   ..$ : int 5
[17:38:08.062]  $ ...future.seeds_ii       : NULL
[17:38:08.062]  $ ...future.globals.maxSize: NULL
[17:38:08.062]  - attr(*, "where")=List of 11
[17:38:08.062]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:08.062]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:08.062]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:08.062]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:08.062]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:08.062]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:08.062]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:08.062]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:08.062]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:08.062]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:08.062]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:08.062]  - attr(*, "resolved")= logi FALSE
[17:38:08.062]  - attr(*, "total_size")= num 97232
[17:38:08.062]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.062]  - attr(*, "already-done")= logi TRUE
[17:38:08.070] - copied ‘...future.FUN’ to environment
[17:38:08.070] - reassign environment for ‘x_FUN’
[17:38:08.070] - copied ‘x_FUN’ to environment
[17:38:08.071] - copied ‘times’ to environment
[17:38:08.071] - copied ‘stopf’ to environment
[17:38:08.071] - copied ‘stop_if_not’ to environment
[17:38:08.071] - copied ‘dim’ to environment
[17:38:08.071] - copied ‘valid_types’ to environment
[17:38:08.071] - copied ‘future.call.arguments’ to environment
[17:38:08.071] - copied ‘...future.elements_ii’ to environment
[17:38:08.071] - copied ‘...future.seeds_ii’ to environment
[17:38:08.071] - copied ‘...future.globals.maxSize’ to environment
[17:38:08.071] assign_globals() ... done
[17:38:08.072] requestCore(): workers = 2
[17:38:08.074] MulticoreFuture started
[17:38:08.074] - Launch lazy future ... done
[17:38:08.074] run() for ‘MulticoreFuture’ ... done
[17:38:08.075] Created future:
[17:38:08.075] plan(): Setting new future strategy stack:
[17:38:08.076] List of future strategies:
[17:38:08.076] 1. sequential:
[17:38:08.076]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:08.076]    - tweaked: FALSE
[17:38:08.076]    - call: NULL
[17:38:08.077] plan(): nbrOfWorkers() = 1
[17:38:08.079] plan(): Setting new future strategy stack:
[17:38:08.079] List of future strategies:
[17:38:08.079] 1. multicore:
[17:38:08.079]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:08.079]    - tweaked: FALSE
[17:38:08.079]    - call: plan(strategy)
[17:38:08.084] plan(): nbrOfWorkers() = 2
[17:38:08.075] MulticoreFuture:
[17:38:08.075] Label: ‘future_vapply-1’
[17:38:08.075] Expression:
[17:38:08.075] {
[17:38:08.075]     do.call(function(...) {
[17:38:08.075]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.075]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.075]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.075]             on.exit(options(oopts), add = TRUE)
[17:38:08.075]         }
[17:38:08.075]         {
[17:38:08.075]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.075]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.075]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.075]             })
[17:38:08.075]         }
[17:38:08.075]     }, args = future.call.arguments)
[17:38:08.075] }
[17:38:08.075] Lazy evaluation: FALSE
[17:38:08.075] Asynchronous evaluation: TRUE
[17:38:08.075] Local evaluation: TRUE
[17:38:08.075] Environment: R_GlobalEnv
[17:38:08.075] Capture standard output: TRUE
[17:38:08.075] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:08.075] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:08.075] Packages: 1 packages (‘future.apply’)
[17:38:08.075] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:08.075] Resolved: TRUE
[17:38:08.075] Value: <not collected>
[17:38:08.075] Conditions captured: <none>
[17:38:08.075] Early signaling: FALSE
[17:38:08.075] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:08.075] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.085] Chunk #1 of 2 ... DONE
[17:38:08.085] Chunk #2 of 2 ...
[17:38:08.086]  - Finding globals in 'X' for chunk #2 ...
[17:38:08.086] getGlobalsAndPackages() ...
[17:38:08.086] Searching for globals...
[17:38:08.086] 
[17:38:08.086] Searching for globals ... DONE
[17:38:08.087] - globals: [0] <none>
[17:38:08.087] getGlobalsAndPackages() ... DONE
[17:38:08.087]    + additional globals found: [n=0] 
[17:38:08.087]    + additional namespaces needed: [n=0] 
[17:38:08.087]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:08.087]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:08.087]  - seeds: <none>
[17:38:08.087]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.088] getGlobalsAndPackages() ...
[17:38:08.088] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.088] Resolving globals: FALSE
[17:38:08.088] Tweak future expression to call with '...' arguments ...
[17:38:08.092] {
[17:38:08.092]     do.call(function(...) {
[17:38:08.092]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.092]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.092]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.092]             on.exit(options(oopts), add = TRUE)
[17:38:08.092]         }
[17:38:08.092]         {
[17:38:08.092]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.092]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.092]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.092]             })
[17:38:08.092]         }
[17:38:08.092]     }, args = future.call.arguments)
[17:38:08.092] }
[17:38:08.093] Tweak future expression to call with '...' arguments ... DONE
[17:38:08.095] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.096] - packages: [1] ‘future.apply’
[17:38:08.096] getGlobalsAndPackages() ... DONE
[17:38:08.097] run() for ‘Future’ ...
[17:38:08.097] - state: ‘created’
[17:38:08.097] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:08.103] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.104] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:08.104]   - Field: ‘label’
[17:38:08.104]   - Field: ‘local’
[17:38:08.105]   - Field: ‘owner’
[17:38:08.105]   - Field: ‘envir’
[17:38:08.105]   - Field: ‘workers’
[17:38:08.105]   - Field: ‘packages’
[17:38:08.105]   - Field: ‘gc’
[17:38:08.105]   - Field: ‘job’
[17:38:08.106]   - Field: ‘conditions’
[17:38:08.106]   - Field: ‘expr’
[17:38:08.106]   - Field: ‘uuid’
[17:38:08.106]   - Field: ‘seed’
[17:38:08.106]   - Field: ‘version’
[17:38:08.106]   - Field: ‘result’
[17:38:08.106]   - Field: ‘asynchronous’
[17:38:08.107]   - Field: ‘calls’
[17:38:08.107]   - Field: ‘globals’
[17:38:08.107]   - Field: ‘stdout’
[17:38:08.107]   - Field: ‘earlySignal’
[17:38:08.107]   - Field: ‘lazy’
[17:38:08.107]   - Field: ‘state’
[17:38:08.108] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:08.108] - Launch lazy future ...
[17:38:08.108] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:08.108] Packages needed by future strategies (n = 0): <none>
[17:38:08.109] {
[17:38:08.109]     {
[17:38:08.109]         {
[17:38:08.109]             ...future.startTime <- base::Sys.time()
[17:38:08.109]             {
[17:38:08.109]                 {
[17:38:08.109]                   {
[17:38:08.109]                     {
[17:38:08.109]                       {
[17:38:08.109]                         base::local({
[17:38:08.109]                           has_future <- base::requireNamespace("future", 
[17:38:08.109]                             quietly = TRUE)
[17:38:08.109]                           if (has_future) {
[17:38:08.109]                             ns <- base::getNamespace("future")
[17:38:08.109]                             version <- ns[[".package"]][["version"]]
[17:38:08.109]                             if (is.null(version)) 
[17:38:08.109]                               version <- utils::packageVersion("future")
[17:38:08.109]                           }
[17:38:08.109]                           else {
[17:38:08.109]                             version <- NULL
[17:38:08.109]                           }
[17:38:08.109]                           if (!has_future || version < "1.8.0") {
[17:38:08.109]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:08.109]                               "", base::R.version$version.string), 
[17:38:08.109]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:08.109]                                 base::R.version$platform, 8 * 
[17:38:08.109]                                   base::.Machine$sizeof.pointer), 
[17:38:08.109]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:08.109]                                 "release", "version")], collapse = " "), 
[17:38:08.109]                               hostname = base::Sys.info()[["nodename"]])
[17:38:08.109]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:08.109]                               info)
[17:38:08.109]                             info <- base::paste(info, collapse = "; ")
[17:38:08.109]                             if (!has_future) {
[17:38:08.109]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:08.109]                                 info)
[17:38:08.109]                             }
[17:38:08.109]                             else {
[17:38:08.109]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:08.109]                                 info, version)
[17:38:08.109]                             }
[17:38:08.109]                             base::stop(msg)
[17:38:08.109]                           }
[17:38:08.109]                         })
[17:38:08.109]                       }
[17:38:08.109]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:08.109]                       base::options(mc.cores = 1L)
[17:38:08.109]                     }
[17:38:08.109]                     base::local({
[17:38:08.109]                       for (pkg in "future.apply") {
[17:38:08.109]                         base::loadNamespace(pkg)
[17:38:08.109]                         base::library(pkg, character.only = TRUE)
[17:38:08.109]                       }
[17:38:08.109]                     })
[17:38:08.109]                   }
[17:38:08.109]                   ...future.strategy.old <- future::plan("list")
[17:38:08.109]                   options(future.plan = NULL)
[17:38:08.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:08.109]                 }
[17:38:08.109]                 ...future.workdir <- getwd()
[17:38:08.109]             }
[17:38:08.109]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:08.109]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:08.109]         }
[17:38:08.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:08.109]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:08.109]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:08.109]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:08.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:08.109]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:08.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:08.109]             base::names(...future.oldOptions))
[17:38:08.109]     }
[17:38:08.109]     if (FALSE) {
[17:38:08.109]     }
[17:38:08.109]     else {
[17:38:08.109]         if (TRUE) {
[17:38:08.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:08.109]                 open = "w")
[17:38:08.109]         }
[17:38:08.109]         else {
[17:38:08.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:08.109]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:08.109]         }
[17:38:08.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:08.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:08.109]             base::sink(type = "output", split = FALSE)
[17:38:08.109]             base::close(...future.stdout)
[17:38:08.109]         }, add = TRUE)
[17:38:08.109]     }
[17:38:08.109]     ...future.frame <- base::sys.nframe()
[17:38:08.109]     ...future.conditions <- base::list()
[17:38:08.109]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:08.109]     if (FALSE) {
[17:38:08.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:08.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:08.109]     }
[17:38:08.109]     ...future.result <- base::tryCatch({
[17:38:08.109]         base::withCallingHandlers({
[17:38:08.109]             ...future.value <- base::withVisible(base::local({
[17:38:08.109]                 withCallingHandlers({
[17:38:08.109]                   {
[17:38:08.109]                     do.call(function(...) {
[17:38:08.109]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.109]                       if (!identical(...future.globals.maxSize.org, 
[17:38:08.109]                         ...future.globals.maxSize)) {
[17:38:08.109]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.109]                         on.exit(options(oopts), add = TRUE)
[17:38:08.109]                       }
[17:38:08.109]                       {
[17:38:08.109]                         lapply(seq_along(...future.elements_ii), 
[17:38:08.109]                           FUN = function(jj) {
[17:38:08.109]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.109]                             ...future.FUN(...future.X_jj, ...)
[17:38:08.109]                           })
[17:38:08.109]                       }
[17:38:08.109]                     }, args = future.call.arguments)
[17:38:08.109]                   }
[17:38:08.109]                 }, immediateCondition = function(cond) {
[17:38:08.109]                   save_rds <- function (object, pathname, ...) 
[17:38:08.109]                   {
[17:38:08.109]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:08.109]                     if (file_test("-f", pathname_tmp)) {
[17:38:08.109]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.109]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:08.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.109]                         fi_tmp[["mtime"]])
[17:38:08.109]                     }
[17:38:08.109]                     tryCatch({
[17:38:08.109]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:08.109]                     }, error = function(ex) {
[17:38:08.109]                       msg <- conditionMessage(ex)
[17:38:08.109]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.109]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:08.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.109]                         fi_tmp[["mtime"]], msg)
[17:38:08.109]                       ex$message <- msg
[17:38:08.109]                       stop(ex)
[17:38:08.109]                     })
[17:38:08.109]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:08.109]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:08.109]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:08.109]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.109]                       fi <- file.info(pathname)
[17:38:08.109]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:08.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.109]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:08.109]                         fi[["size"]], fi[["mtime"]])
[17:38:08.109]                       stop(msg)
[17:38:08.109]                     }
[17:38:08.109]                     invisible(pathname)
[17:38:08.109]                   }
[17:38:08.109]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:08.109]                     rootPath = tempdir()) 
[17:38:08.109]                   {
[17:38:08.109]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:08.109]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:08.109]                       tmpdir = path, fileext = ".rds")
[17:38:08.109]                     save_rds(obj, file)
[17:38:08.109]                   }
[17:38:08.109]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:08.109]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.109]                   {
[17:38:08.109]                     inherits <- base::inherits
[17:38:08.109]                     invokeRestart <- base::invokeRestart
[17:38:08.109]                     is.null <- base::is.null
[17:38:08.109]                     muffled <- FALSE
[17:38:08.109]                     if (inherits(cond, "message")) {
[17:38:08.109]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:08.109]                       if (muffled) 
[17:38:08.109]                         invokeRestart("muffleMessage")
[17:38:08.109]                     }
[17:38:08.109]                     else if (inherits(cond, "warning")) {
[17:38:08.109]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:08.109]                       if (muffled) 
[17:38:08.109]                         invokeRestart("muffleWarning")
[17:38:08.109]                     }
[17:38:08.109]                     else if (inherits(cond, "condition")) {
[17:38:08.109]                       if (!is.null(pattern)) {
[17:38:08.109]                         computeRestarts <- base::computeRestarts
[17:38:08.109]                         grepl <- base::grepl
[17:38:08.109]                         restarts <- computeRestarts(cond)
[17:38:08.109]                         for (restart in restarts) {
[17:38:08.109]                           name <- restart$name
[17:38:08.109]                           if (is.null(name)) 
[17:38:08.109]                             next
[17:38:08.109]                           if (!grepl(pattern, name)) 
[17:38:08.109]                             next
[17:38:08.109]                           invokeRestart(restart)
[17:38:08.109]                           muffled <- TRUE
[17:38:08.109]                           break
[17:38:08.109]                         }
[17:38:08.109]                       }
[17:38:08.109]                     }
[17:38:08.109]                     invisible(muffled)
[17:38:08.109]                   }
[17:38:08.109]                   muffleCondition(cond)
[17:38:08.109]                 })
[17:38:08.109]             }))
[17:38:08.109]             future::FutureResult(value = ...future.value$value, 
[17:38:08.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.109]                   ...future.rng), globalenv = if (FALSE) 
[17:38:08.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:08.109]                     ...future.globalenv.names))
[17:38:08.109]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:08.109]         }, condition = base::local({
[17:38:08.109]             c <- base::c
[17:38:08.109]             inherits <- base::inherits
[17:38:08.109]             invokeRestart <- base::invokeRestart
[17:38:08.109]             length <- base::length
[17:38:08.109]             list <- base::list
[17:38:08.109]             seq.int <- base::seq.int
[17:38:08.109]             signalCondition <- base::signalCondition
[17:38:08.109]             sys.calls <- base::sys.calls
[17:38:08.109]             `[[` <- base::`[[`
[17:38:08.109]             `+` <- base::`+`
[17:38:08.109]             `<<-` <- base::`<<-`
[17:38:08.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:08.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:08.109]                   3L)]
[17:38:08.109]             }
[17:38:08.109]             function(cond) {
[17:38:08.109]                 is_error <- inherits(cond, "error")
[17:38:08.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:08.109]                   NULL)
[17:38:08.109]                 if (is_error) {
[17:38:08.109]                   sessionInformation <- function() {
[17:38:08.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:08.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:08.109]                       search = base::search(), system = base::Sys.info())
[17:38:08.109]                   }
[17:38:08.109]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:08.109]                     cond$call), session = sessionInformation(), 
[17:38:08.109]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:08.109]                   signalCondition(cond)
[17:38:08.109]                 }
[17:38:08.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:08.109]                 "immediateCondition"))) {
[17:38:08.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:08.109]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:08.109]                   if (TRUE && !signal) {
[17:38:08.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.109]                     {
[17:38:08.109]                       inherits <- base::inherits
[17:38:08.109]                       invokeRestart <- base::invokeRestart
[17:38:08.109]                       is.null <- base::is.null
[17:38:08.109]                       muffled <- FALSE
[17:38:08.109]                       if (inherits(cond, "message")) {
[17:38:08.109]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.109]                         if (muffled) 
[17:38:08.109]                           invokeRestart("muffleMessage")
[17:38:08.109]                       }
[17:38:08.109]                       else if (inherits(cond, "warning")) {
[17:38:08.109]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.109]                         if (muffled) 
[17:38:08.109]                           invokeRestart("muffleWarning")
[17:38:08.109]                       }
[17:38:08.109]                       else if (inherits(cond, "condition")) {
[17:38:08.109]                         if (!is.null(pattern)) {
[17:38:08.109]                           computeRestarts <- base::computeRestarts
[17:38:08.109]                           grepl <- base::grepl
[17:38:08.109]                           restarts <- computeRestarts(cond)
[17:38:08.109]                           for (restart in restarts) {
[17:38:08.109]                             name <- restart$name
[17:38:08.109]                             if (is.null(name)) 
[17:38:08.109]                               next
[17:38:08.109]                             if (!grepl(pattern, name)) 
[17:38:08.109]                               next
[17:38:08.109]                             invokeRestart(restart)
[17:38:08.109]                             muffled <- TRUE
[17:38:08.109]                             break
[17:38:08.109]                           }
[17:38:08.109]                         }
[17:38:08.109]                       }
[17:38:08.109]                       invisible(muffled)
[17:38:08.109]                     }
[17:38:08.109]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.109]                   }
[17:38:08.109]                 }
[17:38:08.109]                 else {
[17:38:08.109]                   if (TRUE) {
[17:38:08.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.109]                     {
[17:38:08.109]                       inherits <- base::inherits
[17:38:08.109]                       invokeRestart <- base::invokeRestart
[17:38:08.109]                       is.null <- base::is.null
[17:38:08.109]                       muffled <- FALSE
[17:38:08.109]                       if (inherits(cond, "message")) {
[17:38:08.109]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.109]                         if (muffled) 
[17:38:08.109]                           invokeRestart("muffleMessage")
[17:38:08.109]                       }
[17:38:08.109]                       else if (inherits(cond, "warning")) {
[17:38:08.109]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.109]                         if (muffled) 
[17:38:08.109]                           invokeRestart("muffleWarning")
[17:38:08.109]                       }
[17:38:08.109]                       else if (inherits(cond, "condition")) {
[17:38:08.109]                         if (!is.null(pattern)) {
[17:38:08.109]                           computeRestarts <- base::computeRestarts
[17:38:08.109]                           grepl <- base::grepl
[17:38:08.109]                           restarts <- computeRestarts(cond)
[17:38:08.109]                           for (restart in restarts) {
[17:38:08.109]                             name <- restart$name
[17:38:08.109]                             if (is.null(name)) 
[17:38:08.109]                               next
[17:38:08.109]                             if (!grepl(pattern, name)) 
[17:38:08.109]                               next
[17:38:08.109]                             invokeRestart(restart)
[17:38:08.109]                             muffled <- TRUE
[17:38:08.109]                             break
[17:38:08.109]                           }
[17:38:08.109]                         }
[17:38:08.109]                       }
[17:38:08.109]                       invisible(muffled)
[17:38:08.109]                     }
[17:38:08.109]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.109]                   }
[17:38:08.109]                 }
[17:38:08.109]             }
[17:38:08.109]         }))
[17:38:08.109]     }, error = function(ex) {
[17:38:08.109]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:08.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.109]                 ...future.rng), started = ...future.startTime, 
[17:38:08.109]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:08.109]             version = "1.8"), class = "FutureResult")
[17:38:08.109]     }, finally = {
[17:38:08.109]         if (!identical(...future.workdir, getwd())) 
[17:38:08.109]             setwd(...future.workdir)
[17:38:08.109]         {
[17:38:08.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:08.109]                 ...future.oldOptions$nwarnings <- NULL
[17:38:08.109]             }
[17:38:08.109]             base::options(...future.oldOptions)
[17:38:08.109]             if (.Platform$OS.type == "windows") {
[17:38:08.109]                 old_names <- names(...future.oldEnvVars)
[17:38:08.109]                 envs <- base::Sys.getenv()
[17:38:08.109]                 names <- names(envs)
[17:38:08.109]                 common <- intersect(names, old_names)
[17:38:08.109]                 added <- setdiff(names, old_names)
[17:38:08.109]                 removed <- setdiff(old_names, names)
[17:38:08.109]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:08.109]                   envs[common]]
[17:38:08.109]                 NAMES <- toupper(changed)
[17:38:08.109]                 args <- list()
[17:38:08.109]                 for (kk in seq_along(NAMES)) {
[17:38:08.109]                   name <- changed[[kk]]
[17:38:08.109]                   NAME <- NAMES[[kk]]
[17:38:08.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.109]                     next
[17:38:08.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.109]                 }
[17:38:08.109]                 NAMES <- toupper(added)
[17:38:08.109]                 for (kk in seq_along(NAMES)) {
[17:38:08.109]                   name <- added[[kk]]
[17:38:08.109]                   NAME <- NAMES[[kk]]
[17:38:08.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.109]                     next
[17:38:08.109]                   args[[name]] <- ""
[17:38:08.109]                 }
[17:38:08.109]                 NAMES <- toupper(removed)
[17:38:08.109]                 for (kk in seq_along(NAMES)) {
[17:38:08.109]                   name <- removed[[kk]]
[17:38:08.109]                   NAME <- NAMES[[kk]]
[17:38:08.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.109]                     next
[17:38:08.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.109]                 }
[17:38:08.109]                 if (length(args) > 0) 
[17:38:08.109]                   base::do.call(base::Sys.setenv, args = args)
[17:38:08.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:08.109]             }
[17:38:08.109]             else {
[17:38:08.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:08.109]             }
[17:38:08.109]             {
[17:38:08.109]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:08.109]                   0L) {
[17:38:08.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:08.109]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:08.109]                   base::options(opts)
[17:38:08.109]                 }
[17:38:08.109]                 {
[17:38:08.109]                   {
[17:38:08.109]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:08.109]                     NULL
[17:38:08.109]                   }
[17:38:08.109]                   options(future.plan = NULL)
[17:38:08.109]                   if (is.na(NA_character_)) 
[17:38:08.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:08.109]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:08.109]                     .init = FALSE)
[17:38:08.109]                 }
[17:38:08.109]             }
[17:38:08.109]         }
[17:38:08.109]     })
[17:38:08.109]     if (TRUE) {
[17:38:08.109]         base::sink(type = "output", split = FALSE)
[17:38:08.109]         if (TRUE) {
[17:38:08.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:08.109]         }
[17:38:08.109]         else {
[17:38:08.109]             ...future.result["stdout"] <- base::list(NULL)
[17:38:08.109]         }
[17:38:08.109]         base::close(...future.stdout)
[17:38:08.109]         ...future.stdout <- NULL
[17:38:08.109]     }
[17:38:08.109]     ...future.result$conditions <- ...future.conditions
[17:38:08.109]     ...future.result$finished <- base::Sys.time()
[17:38:08.109]     ...future.result
[17:38:08.109] }
[17:38:08.112] assign_globals() ...
[17:38:08.112] List of 11
[17:38:08.112]  $ ...future.FUN            :function (x, ...)  
[17:38:08.112]  $ x_FUN                    :function (x)  
[17:38:08.112]  $ times                    : int 4
[17:38:08.112]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.112]  $ stop_if_not              :function (...)  
[17:38:08.112]  $ dim                      : int [1:2] 2 2
[17:38:08.112]  $ valid_types              : chr [1:2] "logical" "integer"
[17:38:08.112]  $ future.call.arguments    : list()
[17:38:08.112]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.112]  $ ...future.elements_ii    :List of 5
[17:38:08.112]   ..$ : int 6
[17:38:08.112]   ..$ : int 7
[17:38:08.112]   ..$ : int 8
[17:38:08.112]   ..$ : int 9
[17:38:08.112]   ..$ : int 10
[17:38:08.112]  $ ...future.seeds_ii       : NULL
[17:38:08.112]  $ ...future.globals.maxSize: NULL
[17:38:08.112]  - attr(*, "where")=List of 11
[17:38:08.112]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:08.112]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:08.112]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:08.112]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:08.112]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:08.112]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:08.112]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:08.112]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:08.112]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:08.112]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:08.112]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:08.112]  - attr(*, "resolved")= logi FALSE
[17:38:08.112]  - attr(*, "total_size")= num 97232
[17:38:08.112]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.112]  - attr(*, "already-done")= logi TRUE
[17:38:08.123] - copied ‘...future.FUN’ to environment
[17:38:08.123] - reassign environment for ‘x_FUN’
[17:38:08.123] - copied ‘x_FUN’ to environment
[17:38:08.123] - copied ‘times’ to environment
[17:38:08.123] - copied ‘stopf’ to environment
[17:38:08.124] - copied ‘stop_if_not’ to environment
[17:38:08.124] - copied ‘dim’ to environment
[17:38:08.124] - copied ‘valid_types’ to environment
[17:38:08.124] - copied ‘future.call.arguments’ to environment
[17:38:08.124] - copied ‘...future.elements_ii’ to environment
[17:38:08.124] - copied ‘...future.seeds_ii’ to environment
[17:38:08.124] - copied ‘...future.globals.maxSize’ to environment
[17:38:08.124] assign_globals() ... done
[17:38:08.124] requestCore(): workers = 2
[17:38:08.127] MulticoreFuture started
[17:38:08.127] - Launch lazy future ... done
[17:38:08.127] run() for ‘MulticoreFuture’ ... done
[17:38:08.128] Created future:
[17:38:08.128] plan(): Setting new future strategy stack:
[17:38:08.128] List of future strategies:
[17:38:08.128] 1. sequential:
[17:38:08.128]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:08.128]    - tweaked: FALSE
[17:38:08.128]    - call: NULL
[17:38:08.129] plan(): nbrOfWorkers() = 1
[17:38:08.131] plan(): Setting new future strategy stack:
[17:38:08.132] List of future strategies:
[17:38:08.132] 1. multicore:
[17:38:08.132]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:08.132]    - tweaked: FALSE
[17:38:08.132]    - call: plan(strategy)
[17:38:08.128] MulticoreFuture:
[17:38:08.128] Label: ‘future_vapply-2’
[17:38:08.128] Expression:
[17:38:08.128] {
[17:38:08.128]     do.call(function(...) {
[17:38:08.128]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.128]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.128]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.128]             on.exit(options(oopts), add = TRUE)
[17:38:08.128]         }
[17:38:08.128]         {
[17:38:08.128]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.128]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.128]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.128]             })
[17:38:08.128]         }
[17:38:08.128]     }, args = future.call.arguments)
[17:38:08.128] }
[17:38:08.128] Lazy evaluation: FALSE
[17:38:08.128] Asynchronous evaluation: TRUE
[17:38:08.128] Local evaluation: TRUE
[17:38:08.128] Environment: R_GlobalEnv
[17:38:08.128] Capture standard output: TRUE
[17:38:08.128] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:08.128] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:08.128] Packages: 1 packages (‘future.apply’)
[17:38:08.128] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:08.128] Resolved: FALSE
[17:38:08.128] Value: <not collected>
[17:38:08.128] Conditions captured: <none>
[17:38:08.128] Early signaling: FALSE
[17:38:08.128] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:08.128] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.141] Chunk #2 of 2 ... DONE
[17:38:08.141] Launching 2 futures (chunks) ... DONE
[17:38:08.141] Resolving 2 futures (chunks) ...
[17:38:08.142] resolve() on list ...
[17:38:08.142]  recursive: 0
[17:38:08.142]  length: 2
[17:38:08.142] plan(): nbrOfWorkers() = 2
[17:38:08.142] 
[17:38:08.145] Future #1
[17:38:08.145] result() for MulticoreFuture ...
[17:38:08.147] result() for MulticoreFuture ...
[17:38:08.147] result() for MulticoreFuture ... done
[17:38:08.147] result() for MulticoreFuture ... done
[17:38:08.148] result() for MulticoreFuture ...
[17:38:08.148] result() for MulticoreFuture ... done
[17:38:08.148] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:08.149] - nx: 2
[17:38:08.149] - relay: TRUE
[17:38:08.149] - stdout: TRUE
[17:38:08.150] - signal: TRUE
[17:38:08.150] - resignal: FALSE
[17:38:08.150] - force: TRUE
[17:38:08.150] - relayed: [n=2] FALSE, FALSE
[17:38:08.151] - queued futures: [n=2] FALSE, FALSE
[17:38:08.151]  - until=1
[17:38:08.152]  - relaying element #1
[17:38:08.152] result() for MulticoreFuture ...
[17:38:08.152] result() for MulticoreFuture ... done
[17:38:08.153] result() for MulticoreFuture ...
[17:38:08.153] result() for MulticoreFuture ... done
[17:38:08.153] result() for MulticoreFuture ...
[17:38:08.153] result() for MulticoreFuture ... done
[17:38:08.154] result() for MulticoreFuture ...
[17:38:08.154] result() for MulticoreFuture ... done
[17:38:08.154] - relayed: [n=2] TRUE, FALSE
[17:38:08.154] - queued futures: [n=2] TRUE, FALSE
[17:38:08.154] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:08.155]  length: 1 (resolved future 1)
[17:38:08.155] Future #2
[17:38:08.155] result() for MulticoreFuture ...
[17:38:08.156] result() for MulticoreFuture ...
[17:38:08.156] result() for MulticoreFuture ... done
[17:38:08.156] result() for MulticoreFuture ... done
[17:38:08.156] result() for MulticoreFuture ...
[17:38:08.157] result() for MulticoreFuture ... done
[17:38:08.157] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:08.157] - nx: 2
[17:38:08.157] - relay: TRUE
[17:38:08.157] - stdout: TRUE
[17:38:08.157] - signal: TRUE
[17:38:08.158] - resignal: FALSE
[17:38:08.158] - force: TRUE
[17:38:08.158] - relayed: [n=2] TRUE, FALSE
[17:38:08.158] - queued futures: [n=2] TRUE, FALSE
[17:38:08.158]  - until=2
[17:38:08.158]  - relaying element #2
[17:38:08.158] result() for MulticoreFuture ...
[17:38:08.158] result() for MulticoreFuture ... done
[17:38:08.159] result() for MulticoreFuture ...
[17:38:08.159] result() for MulticoreFuture ... done
[17:38:08.159] result() for MulticoreFuture ...
[17:38:08.159] result() for MulticoreFuture ... done
[17:38:08.159] result() for MulticoreFuture ...
[17:38:08.159] result() for MulticoreFuture ... done
[17:38:08.159] - relayed: [n=2] TRUE, TRUE
[17:38:08.159] - queued futures: [n=2] TRUE, TRUE
[17:38:08.159] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:08.160]  length: 0 (resolved future 2)
[17:38:08.160] Relaying remaining futures
[17:38:08.160] signalConditionsASAP(NULL, pos=0) ...
[17:38:08.160] - nx: 2
[17:38:08.160] - relay: TRUE
[17:38:08.160] - stdout: TRUE
[17:38:08.160] - signal: TRUE
[17:38:08.160] - resignal: FALSE
[17:38:08.160] - force: TRUE
[17:38:08.160] - relayed: [n=2] TRUE, TRUE
[17:38:08.161] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:08.161] - relayed: [n=2] TRUE, TRUE
[17:38:08.161] - queued futures: [n=2] TRUE, TRUE
[17:38:08.161] signalConditionsASAP(NULL, pos=0) ... done
[17:38:08.161] resolve() on list ... DONE
[17:38:08.161] result() for MulticoreFuture ...
[17:38:08.161] result() for MulticoreFuture ... done
[17:38:08.161] result() for MulticoreFuture ...
[17:38:08.161] result() for MulticoreFuture ... done
[17:38:08.162] result() for MulticoreFuture ...
[17:38:08.162] result() for MulticoreFuture ... done
[17:38:08.162] result() for MulticoreFuture ...
[17:38:08.162] result() for MulticoreFuture ... done
[17:38:08.162]  - Number of value chunks collected: 2
[17:38:08.162] Resolving 2 futures (chunks) ... DONE
[17:38:08.162] Reducing values from 2 chunks ...
[17:38:08.162]  - Number of values collected after concatenation: 10
[17:38:08.162]  - Number of values expected: 10
[17:38:08.163] Reducing values from 2 chunks ... DONE
[17:38:08.163] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:38:08.164] future_lapply() ...
[17:38:08.170] Number of chunks: 2
[17:38:08.170] getGlobalsAndPackagesXApply() ...
[17:38:08.170]  - future.globals: TRUE
[17:38:08.171] getGlobalsAndPackages() ...
[17:38:08.171] Searching for globals...
[17:38:08.174] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:38:08.175] Searching for globals ... DONE
[17:38:08.175] Resolving globals: FALSE
[17:38:08.176] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[17:38:08.176] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:08.176] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:08.176] - packages: [1] ‘future.apply’
[17:38:08.176] getGlobalsAndPackages() ... DONE
[17:38:08.177]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:08.179]  - needed namespaces: [n=1] ‘future.apply’
[17:38:08.179] Finding globals ... DONE
[17:38:08.179]  - use_args: TRUE
[17:38:08.179]  - Getting '...' globals ...
[17:38:08.180] resolve() on list ...
[17:38:08.180]  recursive: 0
[17:38:08.180]  length: 1
[17:38:08.180]  elements: ‘...’
[17:38:08.180]  length: 0 (resolved future 1)
[17:38:08.180] resolve() on list ... DONE
[17:38:08.181]    - '...' content: [n=0] 
[17:38:08.181] List of 1
[17:38:08.181]  $ ...: list()
[17:38:08.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.181]  - attr(*, "where")=List of 1
[17:38:08.181]   ..$ ...:<environment: 0x5608010590c8> 
[17:38:08.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.181]  - attr(*, "resolved")= logi TRUE
[17:38:08.181]  - attr(*, "total_size")= num NA
[17:38:08.184]  - Getting '...' globals ... DONE
[17:38:08.184] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:08.184] List of 8
[17:38:08.184]  $ ...future.FUN:function (x, ...)  
[17:38:08.184]  $ x_FUN        :function (x)  
[17:38:08.184]  $ times        : int 4
[17:38:08.184]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.184]  $ stop_if_not  :function (...)  
[17:38:08.184]  $ dim          : int [1:2] 2 2
[17:38:08.184]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:08.184]  $ ...          : list()
[17:38:08.184]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.184]  - attr(*, "where")=List of 8
[17:38:08.184]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:08.184]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:08.184]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:08.184]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:08.184]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:08.184]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:08.184]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:08.184]   ..$ ...          :<environment: 0x5608010590c8> 
[17:38:08.184]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.184]  - attr(*, "resolved")= logi FALSE
[17:38:08.184]  - attr(*, "total_size")= num 97304
[17:38:08.190] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:08.190] getGlobalsAndPackagesXApply() ... DONE
[17:38:08.190] Number of futures (= number of chunks): 2
[17:38:08.190] Launching 2 futures (chunks) ...
[17:38:08.190] Chunk #1 of 2 ...
[17:38:08.190]  - Finding globals in 'X' for chunk #1 ...
[17:38:08.190] getGlobalsAndPackages() ...
[17:38:08.190] Searching for globals...
[17:38:08.191] 
[17:38:08.191] Searching for globals ... DONE
[17:38:08.191] - globals: [0] <none>
[17:38:08.191] getGlobalsAndPackages() ... DONE
[17:38:08.191]    + additional globals found: [n=0] 
[17:38:08.191]    + additional namespaces needed: [n=0] 
[17:38:08.191]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:08.191]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:08.191]  - seeds: <none>
[17:38:08.192]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.192] getGlobalsAndPackages() ...
[17:38:08.192] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.192] Resolving globals: FALSE
[17:38:08.192] Tweak future expression to call with '...' arguments ...
[17:38:08.192] {
[17:38:08.192]     do.call(function(...) {
[17:38:08.192]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.192]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.192]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.192]             on.exit(options(oopts), add = TRUE)
[17:38:08.192]         }
[17:38:08.192]         {
[17:38:08.192]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.192]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.192]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.192]             })
[17:38:08.192]         }
[17:38:08.192]     }, args = future.call.arguments)
[17:38:08.192] }
[17:38:08.192] Tweak future expression to call with '...' arguments ... DONE
[17:38:08.193] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.193] - packages: [1] ‘future.apply’
[17:38:08.193] getGlobalsAndPackages() ... DONE
[17:38:08.193] run() for ‘Future’ ...
[17:38:08.194] - state: ‘created’
[17:38:08.194] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:08.197] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.198] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:08.198]   - Field: ‘label’
[17:38:08.198]   - Field: ‘local’
[17:38:08.198]   - Field: ‘owner’
[17:38:08.198]   - Field: ‘envir’
[17:38:08.198]   - Field: ‘workers’
[17:38:08.198]   - Field: ‘packages’
[17:38:08.198]   - Field: ‘gc’
[17:38:08.198]   - Field: ‘job’
[17:38:08.198]   - Field: ‘conditions’
[17:38:08.199]   - Field: ‘expr’
[17:38:08.199]   - Field: ‘uuid’
[17:38:08.199]   - Field: ‘seed’
[17:38:08.199]   - Field: ‘version’
[17:38:08.199]   - Field: ‘result’
[17:38:08.199]   - Field: ‘asynchronous’
[17:38:08.199]   - Field: ‘calls’
[17:38:08.199]   - Field: ‘globals’
[17:38:08.199]   - Field: ‘stdout’
[17:38:08.199]   - Field: ‘earlySignal’
[17:38:08.199]   - Field: ‘lazy’
[17:38:08.200]   - Field: ‘state’
[17:38:08.200] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:08.200] - Launch lazy future ...
[17:38:08.200] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:08.200] Packages needed by future strategies (n = 0): <none>
[17:38:08.201] {
[17:38:08.201]     {
[17:38:08.201]         {
[17:38:08.201]             ...future.startTime <- base::Sys.time()
[17:38:08.201]             {
[17:38:08.201]                 {
[17:38:08.201]                   {
[17:38:08.201]                     {
[17:38:08.201]                       {
[17:38:08.201]                         base::local({
[17:38:08.201]                           has_future <- base::requireNamespace("future", 
[17:38:08.201]                             quietly = TRUE)
[17:38:08.201]                           if (has_future) {
[17:38:08.201]                             ns <- base::getNamespace("future")
[17:38:08.201]                             version <- ns[[".package"]][["version"]]
[17:38:08.201]                             if (is.null(version)) 
[17:38:08.201]                               version <- utils::packageVersion("future")
[17:38:08.201]                           }
[17:38:08.201]                           else {
[17:38:08.201]                             version <- NULL
[17:38:08.201]                           }
[17:38:08.201]                           if (!has_future || version < "1.8.0") {
[17:38:08.201]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:08.201]                               "", base::R.version$version.string), 
[17:38:08.201]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:08.201]                                 base::R.version$platform, 8 * 
[17:38:08.201]                                   base::.Machine$sizeof.pointer), 
[17:38:08.201]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:08.201]                                 "release", "version")], collapse = " "), 
[17:38:08.201]                               hostname = base::Sys.info()[["nodename"]])
[17:38:08.201]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:08.201]                               info)
[17:38:08.201]                             info <- base::paste(info, collapse = "; ")
[17:38:08.201]                             if (!has_future) {
[17:38:08.201]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:08.201]                                 info)
[17:38:08.201]                             }
[17:38:08.201]                             else {
[17:38:08.201]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:08.201]                                 info, version)
[17:38:08.201]                             }
[17:38:08.201]                             base::stop(msg)
[17:38:08.201]                           }
[17:38:08.201]                         })
[17:38:08.201]                       }
[17:38:08.201]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:08.201]                       base::options(mc.cores = 1L)
[17:38:08.201]                     }
[17:38:08.201]                     base::local({
[17:38:08.201]                       for (pkg in "future.apply") {
[17:38:08.201]                         base::loadNamespace(pkg)
[17:38:08.201]                         base::library(pkg, character.only = TRUE)
[17:38:08.201]                       }
[17:38:08.201]                     })
[17:38:08.201]                   }
[17:38:08.201]                   ...future.strategy.old <- future::plan("list")
[17:38:08.201]                   options(future.plan = NULL)
[17:38:08.201]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.201]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:08.201]                 }
[17:38:08.201]                 ...future.workdir <- getwd()
[17:38:08.201]             }
[17:38:08.201]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:08.201]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:08.201]         }
[17:38:08.201]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:08.201]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:08.201]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:08.201]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:08.201]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:08.201]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:08.201]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:08.201]             base::names(...future.oldOptions))
[17:38:08.201]     }
[17:38:08.201]     if (FALSE) {
[17:38:08.201]     }
[17:38:08.201]     else {
[17:38:08.201]         if (TRUE) {
[17:38:08.201]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:08.201]                 open = "w")
[17:38:08.201]         }
[17:38:08.201]         else {
[17:38:08.201]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:08.201]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:08.201]         }
[17:38:08.201]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:08.201]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:08.201]             base::sink(type = "output", split = FALSE)
[17:38:08.201]             base::close(...future.stdout)
[17:38:08.201]         }, add = TRUE)
[17:38:08.201]     }
[17:38:08.201]     ...future.frame <- base::sys.nframe()
[17:38:08.201]     ...future.conditions <- base::list()
[17:38:08.201]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:08.201]     if (FALSE) {
[17:38:08.201]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:08.201]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:08.201]     }
[17:38:08.201]     ...future.result <- base::tryCatch({
[17:38:08.201]         base::withCallingHandlers({
[17:38:08.201]             ...future.value <- base::withVisible(base::local({
[17:38:08.201]                 withCallingHandlers({
[17:38:08.201]                   {
[17:38:08.201]                     do.call(function(...) {
[17:38:08.201]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.201]                       if (!identical(...future.globals.maxSize.org, 
[17:38:08.201]                         ...future.globals.maxSize)) {
[17:38:08.201]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.201]                         on.exit(options(oopts), add = TRUE)
[17:38:08.201]                       }
[17:38:08.201]                       {
[17:38:08.201]                         lapply(seq_along(...future.elements_ii), 
[17:38:08.201]                           FUN = function(jj) {
[17:38:08.201]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.201]                             ...future.FUN(...future.X_jj, ...)
[17:38:08.201]                           })
[17:38:08.201]                       }
[17:38:08.201]                     }, args = future.call.arguments)
[17:38:08.201]                   }
[17:38:08.201]                 }, immediateCondition = function(cond) {
[17:38:08.201]                   save_rds <- function (object, pathname, ...) 
[17:38:08.201]                   {
[17:38:08.201]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:08.201]                     if (file_test("-f", pathname_tmp)) {
[17:38:08.201]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.201]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:08.201]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.201]                         fi_tmp[["mtime"]])
[17:38:08.201]                     }
[17:38:08.201]                     tryCatch({
[17:38:08.201]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:08.201]                     }, error = function(ex) {
[17:38:08.201]                       msg <- conditionMessage(ex)
[17:38:08.201]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.201]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:08.201]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.201]                         fi_tmp[["mtime"]], msg)
[17:38:08.201]                       ex$message <- msg
[17:38:08.201]                       stop(ex)
[17:38:08.201]                     })
[17:38:08.201]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:08.201]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:08.201]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:08.201]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.201]                       fi <- file.info(pathname)
[17:38:08.201]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:08.201]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.201]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:08.201]                         fi[["size"]], fi[["mtime"]])
[17:38:08.201]                       stop(msg)
[17:38:08.201]                     }
[17:38:08.201]                     invisible(pathname)
[17:38:08.201]                   }
[17:38:08.201]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:08.201]                     rootPath = tempdir()) 
[17:38:08.201]                   {
[17:38:08.201]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:08.201]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:08.201]                       tmpdir = path, fileext = ".rds")
[17:38:08.201]                     save_rds(obj, file)
[17:38:08.201]                   }
[17:38:08.201]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:08.201]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.201]                   {
[17:38:08.201]                     inherits <- base::inherits
[17:38:08.201]                     invokeRestart <- base::invokeRestart
[17:38:08.201]                     is.null <- base::is.null
[17:38:08.201]                     muffled <- FALSE
[17:38:08.201]                     if (inherits(cond, "message")) {
[17:38:08.201]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:08.201]                       if (muffled) 
[17:38:08.201]                         invokeRestart("muffleMessage")
[17:38:08.201]                     }
[17:38:08.201]                     else if (inherits(cond, "warning")) {
[17:38:08.201]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:08.201]                       if (muffled) 
[17:38:08.201]                         invokeRestart("muffleWarning")
[17:38:08.201]                     }
[17:38:08.201]                     else if (inherits(cond, "condition")) {
[17:38:08.201]                       if (!is.null(pattern)) {
[17:38:08.201]                         computeRestarts <- base::computeRestarts
[17:38:08.201]                         grepl <- base::grepl
[17:38:08.201]                         restarts <- computeRestarts(cond)
[17:38:08.201]                         for (restart in restarts) {
[17:38:08.201]                           name <- restart$name
[17:38:08.201]                           if (is.null(name)) 
[17:38:08.201]                             next
[17:38:08.201]                           if (!grepl(pattern, name)) 
[17:38:08.201]                             next
[17:38:08.201]                           invokeRestart(restart)
[17:38:08.201]                           muffled <- TRUE
[17:38:08.201]                           break
[17:38:08.201]                         }
[17:38:08.201]                       }
[17:38:08.201]                     }
[17:38:08.201]                     invisible(muffled)
[17:38:08.201]                   }
[17:38:08.201]                   muffleCondition(cond)
[17:38:08.201]                 })
[17:38:08.201]             }))
[17:38:08.201]             future::FutureResult(value = ...future.value$value, 
[17:38:08.201]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.201]                   ...future.rng), globalenv = if (FALSE) 
[17:38:08.201]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:08.201]                     ...future.globalenv.names))
[17:38:08.201]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:08.201]         }, condition = base::local({
[17:38:08.201]             c <- base::c
[17:38:08.201]             inherits <- base::inherits
[17:38:08.201]             invokeRestart <- base::invokeRestart
[17:38:08.201]             length <- base::length
[17:38:08.201]             list <- base::list
[17:38:08.201]             seq.int <- base::seq.int
[17:38:08.201]             signalCondition <- base::signalCondition
[17:38:08.201]             sys.calls <- base::sys.calls
[17:38:08.201]             `[[` <- base::`[[`
[17:38:08.201]             `+` <- base::`+`
[17:38:08.201]             `<<-` <- base::`<<-`
[17:38:08.201]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:08.201]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:08.201]                   3L)]
[17:38:08.201]             }
[17:38:08.201]             function(cond) {
[17:38:08.201]                 is_error <- inherits(cond, "error")
[17:38:08.201]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:08.201]                   NULL)
[17:38:08.201]                 if (is_error) {
[17:38:08.201]                   sessionInformation <- function() {
[17:38:08.201]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:08.201]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:08.201]                       search = base::search(), system = base::Sys.info())
[17:38:08.201]                   }
[17:38:08.201]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.201]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:08.201]                     cond$call), session = sessionInformation(), 
[17:38:08.201]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:08.201]                   signalCondition(cond)
[17:38:08.201]                 }
[17:38:08.201]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:08.201]                 "immediateCondition"))) {
[17:38:08.201]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:08.201]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.201]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:08.201]                   if (TRUE && !signal) {
[17:38:08.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.201]                     {
[17:38:08.201]                       inherits <- base::inherits
[17:38:08.201]                       invokeRestart <- base::invokeRestart
[17:38:08.201]                       is.null <- base::is.null
[17:38:08.201]                       muffled <- FALSE
[17:38:08.201]                       if (inherits(cond, "message")) {
[17:38:08.201]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.201]                         if (muffled) 
[17:38:08.201]                           invokeRestart("muffleMessage")
[17:38:08.201]                       }
[17:38:08.201]                       else if (inherits(cond, "warning")) {
[17:38:08.201]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.201]                         if (muffled) 
[17:38:08.201]                           invokeRestart("muffleWarning")
[17:38:08.201]                       }
[17:38:08.201]                       else if (inherits(cond, "condition")) {
[17:38:08.201]                         if (!is.null(pattern)) {
[17:38:08.201]                           computeRestarts <- base::computeRestarts
[17:38:08.201]                           grepl <- base::grepl
[17:38:08.201]                           restarts <- computeRestarts(cond)
[17:38:08.201]                           for (restart in restarts) {
[17:38:08.201]                             name <- restart$name
[17:38:08.201]                             if (is.null(name)) 
[17:38:08.201]                               next
[17:38:08.201]                             if (!grepl(pattern, name)) 
[17:38:08.201]                               next
[17:38:08.201]                             invokeRestart(restart)
[17:38:08.201]                             muffled <- TRUE
[17:38:08.201]                             break
[17:38:08.201]                           }
[17:38:08.201]                         }
[17:38:08.201]                       }
[17:38:08.201]                       invisible(muffled)
[17:38:08.201]                     }
[17:38:08.201]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.201]                   }
[17:38:08.201]                 }
[17:38:08.201]                 else {
[17:38:08.201]                   if (TRUE) {
[17:38:08.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.201]                     {
[17:38:08.201]                       inherits <- base::inherits
[17:38:08.201]                       invokeRestart <- base::invokeRestart
[17:38:08.201]                       is.null <- base::is.null
[17:38:08.201]                       muffled <- FALSE
[17:38:08.201]                       if (inherits(cond, "message")) {
[17:38:08.201]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.201]                         if (muffled) 
[17:38:08.201]                           invokeRestart("muffleMessage")
[17:38:08.201]                       }
[17:38:08.201]                       else if (inherits(cond, "warning")) {
[17:38:08.201]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.201]                         if (muffled) 
[17:38:08.201]                           invokeRestart("muffleWarning")
[17:38:08.201]                       }
[17:38:08.201]                       else if (inherits(cond, "condition")) {
[17:38:08.201]                         if (!is.null(pattern)) {
[17:38:08.201]                           computeRestarts <- base::computeRestarts
[17:38:08.201]                           grepl <- base::grepl
[17:38:08.201]                           restarts <- computeRestarts(cond)
[17:38:08.201]                           for (restart in restarts) {
[17:38:08.201]                             name <- restart$name
[17:38:08.201]                             if (is.null(name)) 
[17:38:08.201]                               next
[17:38:08.201]                             if (!grepl(pattern, name)) 
[17:38:08.201]                               next
[17:38:08.201]                             invokeRestart(restart)
[17:38:08.201]                             muffled <- TRUE
[17:38:08.201]                             break
[17:38:08.201]                           }
[17:38:08.201]                         }
[17:38:08.201]                       }
[17:38:08.201]                       invisible(muffled)
[17:38:08.201]                     }
[17:38:08.201]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.201]                   }
[17:38:08.201]                 }
[17:38:08.201]             }
[17:38:08.201]         }))
[17:38:08.201]     }, error = function(ex) {
[17:38:08.201]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:08.201]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.201]                 ...future.rng), started = ...future.startTime, 
[17:38:08.201]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:08.201]             version = "1.8"), class = "FutureResult")
[17:38:08.201]     }, finally = {
[17:38:08.201]         if (!identical(...future.workdir, getwd())) 
[17:38:08.201]             setwd(...future.workdir)
[17:38:08.201]         {
[17:38:08.201]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:08.201]                 ...future.oldOptions$nwarnings <- NULL
[17:38:08.201]             }
[17:38:08.201]             base::options(...future.oldOptions)
[17:38:08.201]             if (.Platform$OS.type == "windows") {
[17:38:08.201]                 old_names <- names(...future.oldEnvVars)
[17:38:08.201]                 envs <- base::Sys.getenv()
[17:38:08.201]                 names <- names(envs)
[17:38:08.201]                 common <- intersect(names, old_names)
[17:38:08.201]                 added <- setdiff(names, old_names)
[17:38:08.201]                 removed <- setdiff(old_names, names)
[17:38:08.201]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:08.201]                   envs[common]]
[17:38:08.201]                 NAMES <- toupper(changed)
[17:38:08.201]                 args <- list()
[17:38:08.201]                 for (kk in seq_along(NAMES)) {
[17:38:08.201]                   name <- changed[[kk]]
[17:38:08.201]                   NAME <- NAMES[[kk]]
[17:38:08.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.201]                     next
[17:38:08.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.201]                 }
[17:38:08.201]                 NAMES <- toupper(added)
[17:38:08.201]                 for (kk in seq_along(NAMES)) {
[17:38:08.201]                   name <- added[[kk]]
[17:38:08.201]                   NAME <- NAMES[[kk]]
[17:38:08.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.201]                     next
[17:38:08.201]                   args[[name]] <- ""
[17:38:08.201]                 }
[17:38:08.201]                 NAMES <- toupper(removed)
[17:38:08.201]                 for (kk in seq_along(NAMES)) {
[17:38:08.201]                   name <- removed[[kk]]
[17:38:08.201]                   NAME <- NAMES[[kk]]
[17:38:08.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.201]                     next
[17:38:08.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.201]                 }
[17:38:08.201]                 if (length(args) > 0) 
[17:38:08.201]                   base::do.call(base::Sys.setenv, args = args)
[17:38:08.201]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:08.201]             }
[17:38:08.201]             else {
[17:38:08.201]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:08.201]             }
[17:38:08.201]             {
[17:38:08.201]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:08.201]                   0L) {
[17:38:08.201]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:08.201]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:08.201]                   base::options(opts)
[17:38:08.201]                 }
[17:38:08.201]                 {
[17:38:08.201]                   {
[17:38:08.201]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:08.201]                     NULL
[17:38:08.201]                   }
[17:38:08.201]                   options(future.plan = NULL)
[17:38:08.201]                   if (is.na(NA_character_)) 
[17:38:08.201]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.201]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:08.201]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:08.201]                     .init = FALSE)
[17:38:08.201]                 }
[17:38:08.201]             }
[17:38:08.201]         }
[17:38:08.201]     })
[17:38:08.201]     if (TRUE) {
[17:38:08.201]         base::sink(type = "output", split = FALSE)
[17:38:08.201]         if (TRUE) {
[17:38:08.201]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:08.201]         }
[17:38:08.201]         else {
[17:38:08.201]             ...future.result["stdout"] <- base::list(NULL)
[17:38:08.201]         }
[17:38:08.201]         base::close(...future.stdout)
[17:38:08.201]         ...future.stdout <- NULL
[17:38:08.201]     }
[17:38:08.201]     ...future.result$conditions <- ...future.conditions
[17:38:08.201]     ...future.result$finished <- base::Sys.time()
[17:38:08.201]     ...future.result
[17:38:08.201] }
[17:38:08.203] assign_globals() ...
[17:38:08.203] List of 11
[17:38:08.203]  $ ...future.FUN            :function (x, ...)  
[17:38:08.203]  $ x_FUN                    :function (x)  
[17:38:08.203]  $ times                    : int 4
[17:38:08.203]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.203]  $ stop_if_not              :function (...)  
[17:38:08.203]  $ dim                      : int [1:2] 2 2
[17:38:08.203]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:08.203]  $ future.call.arguments    : list()
[17:38:08.203]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.203]  $ ...future.elements_ii    :List of 5
[17:38:08.203]   ..$ : int 1
[17:38:08.203]   ..$ : int 2
[17:38:08.203]   ..$ : int 3
[17:38:08.203]   ..$ : int 4
[17:38:08.203]   ..$ : int 5
[17:38:08.203]  $ ...future.seeds_ii       : NULL
[17:38:08.203]  $ ...future.globals.maxSize: NULL
[17:38:08.203]  - attr(*, "where")=List of 11
[17:38:08.203]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:08.203]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:08.203]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:08.203]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:08.203]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:08.203]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:08.203]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:08.203]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:08.203]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:08.203]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:08.203]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:08.203]  - attr(*, "resolved")= logi FALSE
[17:38:08.203]  - attr(*, "total_size")= num 97304
[17:38:08.203]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.203]  - attr(*, "already-done")= logi TRUE
[17:38:08.215] - copied ‘...future.FUN’ to environment
[17:38:08.215] - reassign environment for ‘x_FUN’
[17:38:08.215] - copied ‘x_FUN’ to environment
[17:38:08.215] - copied ‘times’ to environment
[17:38:08.215] - copied ‘stopf’ to environment
[17:38:08.215] - copied ‘stop_if_not’ to environment
[17:38:08.215] - copied ‘dim’ to environment
[17:38:08.216] - copied ‘valid_types’ to environment
[17:38:08.216] - copied ‘future.call.arguments’ to environment
[17:38:08.216] - copied ‘...future.elements_ii’ to environment
[17:38:08.216] - copied ‘...future.seeds_ii’ to environment
[17:38:08.216] - copied ‘...future.globals.maxSize’ to environment
[17:38:08.216] assign_globals() ... done
[17:38:08.216] requestCore(): workers = 2
[17:38:08.218] MulticoreFuture started
[17:38:08.219] - Launch lazy future ... done
[17:38:08.219] run() for ‘MulticoreFuture’ ... done
[17:38:08.219] Created future:
[17:38:08.220] plan(): Setting new future strategy stack:
[17:38:08.220] List of future strategies:
[17:38:08.220] 1. sequential:
[17:38:08.220]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:08.220]    - tweaked: FALSE
[17:38:08.220]    - call: NULL
[17:38:08.221] plan(): nbrOfWorkers() = 1
[17:38:08.223] plan(): Setting new future strategy stack:
[17:38:08.224] List of future strategies:
[17:38:08.224] 1. multicore:
[17:38:08.224]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:08.224]    - tweaked: FALSE
[17:38:08.224]    - call: plan(strategy)
[17:38:08.229] plan(): nbrOfWorkers() = 2
[17:38:08.219] MulticoreFuture:
[17:38:08.219] Label: ‘future_vapply-1’
[17:38:08.219] Expression:
[17:38:08.219] {
[17:38:08.219]     do.call(function(...) {
[17:38:08.219]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.219]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.219]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.219]             on.exit(options(oopts), add = TRUE)
[17:38:08.219]         }
[17:38:08.219]         {
[17:38:08.219]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.219]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.219]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.219]             })
[17:38:08.219]         }
[17:38:08.219]     }, args = future.call.arguments)
[17:38:08.219] }
[17:38:08.219] Lazy evaluation: FALSE
[17:38:08.219] Asynchronous evaluation: TRUE
[17:38:08.219] Local evaluation: TRUE
[17:38:08.219] Environment: R_GlobalEnv
[17:38:08.219] Capture standard output: TRUE
[17:38:08.219] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:08.219] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:08.219] Packages: 1 packages (‘future.apply’)
[17:38:08.219] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:08.219] Resolved: TRUE
[17:38:08.219] Value: <not collected>
[17:38:08.219] Conditions captured: <none>
[17:38:08.219] Early signaling: FALSE
[17:38:08.219] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:08.219] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.230] Chunk #1 of 2 ... DONE
[17:38:08.230] Chunk #2 of 2 ...
[17:38:08.230]  - Finding globals in 'X' for chunk #2 ...
[17:38:08.230] getGlobalsAndPackages() ...
[17:38:08.231] Searching for globals...
[17:38:08.231] 
[17:38:08.231] Searching for globals ... DONE
[17:38:08.231] - globals: [0] <none>
[17:38:08.231] getGlobalsAndPackages() ... DONE
[17:38:08.232]    + additional globals found: [n=0] 
[17:38:08.232]    + additional namespaces needed: [n=0] 
[17:38:08.232]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:08.232]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:08.232]  - seeds: <none>
[17:38:08.232]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.232] getGlobalsAndPackages() ...
[17:38:08.233] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.233] Resolving globals: FALSE
[17:38:08.233] Tweak future expression to call with '...' arguments ...
[17:38:08.233] {
[17:38:08.233]     do.call(function(...) {
[17:38:08.233]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.233]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.233]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.233]             on.exit(options(oopts), add = TRUE)
[17:38:08.233]         }
[17:38:08.233]         {
[17:38:08.233]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.233]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.233]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.233]             })
[17:38:08.233]         }
[17:38:08.233]     }, args = future.call.arguments)
[17:38:08.233] }
[17:38:08.234] Tweak future expression to call with '...' arguments ... DONE
[17:38:08.234] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.235] - packages: [1] ‘future.apply’
[17:38:08.235] getGlobalsAndPackages() ... DONE
[17:38:08.235] run() for ‘Future’ ...
[17:38:08.236] - state: ‘created’
[17:38:08.236] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:08.240] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.240] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:08.241]   - Field: ‘label’
[17:38:08.241]   - Field: ‘local’
[17:38:08.241]   - Field: ‘owner’
[17:38:08.241]   - Field: ‘envir’
[17:38:08.241]   - Field: ‘workers’
[17:38:08.241]   - Field: ‘packages’
[17:38:08.241]   - Field: ‘gc’
[17:38:08.242]   - Field: ‘job’
[17:38:08.242]   - Field: ‘conditions’
[17:38:08.242]   - Field: ‘expr’
[17:38:08.242]   - Field: ‘uuid’
[17:38:08.242]   - Field: ‘seed’
[17:38:08.242]   - Field: ‘version’
[17:38:08.242]   - Field: ‘result’
[17:38:08.243]   - Field: ‘asynchronous’
[17:38:08.243]   - Field: ‘calls’
[17:38:08.243]   - Field: ‘globals’
[17:38:08.243]   - Field: ‘stdout’
[17:38:08.243]   - Field: ‘earlySignal’
[17:38:08.243]   - Field: ‘lazy’
[17:38:08.246]   - Field: ‘state’
[17:38:08.246] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:08.247] - Launch lazy future ...
[17:38:08.248] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:08.248] Packages needed by future strategies (n = 0): <none>
[17:38:08.250] {
[17:38:08.250]     {
[17:38:08.250]         {
[17:38:08.250]             ...future.startTime <- base::Sys.time()
[17:38:08.250]             {
[17:38:08.250]                 {
[17:38:08.250]                   {
[17:38:08.250]                     {
[17:38:08.250]                       {
[17:38:08.250]                         base::local({
[17:38:08.250]                           has_future <- base::requireNamespace("future", 
[17:38:08.250]                             quietly = TRUE)
[17:38:08.250]                           if (has_future) {
[17:38:08.250]                             ns <- base::getNamespace("future")
[17:38:08.250]                             version <- ns[[".package"]][["version"]]
[17:38:08.250]                             if (is.null(version)) 
[17:38:08.250]                               version <- utils::packageVersion("future")
[17:38:08.250]                           }
[17:38:08.250]                           else {
[17:38:08.250]                             version <- NULL
[17:38:08.250]                           }
[17:38:08.250]                           if (!has_future || version < "1.8.0") {
[17:38:08.250]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:08.250]                               "", base::R.version$version.string), 
[17:38:08.250]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:08.250]                                 base::R.version$platform, 8 * 
[17:38:08.250]                                   base::.Machine$sizeof.pointer), 
[17:38:08.250]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:08.250]                                 "release", "version")], collapse = " "), 
[17:38:08.250]                               hostname = base::Sys.info()[["nodename"]])
[17:38:08.250]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:08.250]                               info)
[17:38:08.250]                             info <- base::paste(info, collapse = "; ")
[17:38:08.250]                             if (!has_future) {
[17:38:08.250]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:08.250]                                 info)
[17:38:08.250]                             }
[17:38:08.250]                             else {
[17:38:08.250]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:08.250]                                 info, version)
[17:38:08.250]                             }
[17:38:08.250]                             base::stop(msg)
[17:38:08.250]                           }
[17:38:08.250]                         })
[17:38:08.250]                       }
[17:38:08.250]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:08.250]                       base::options(mc.cores = 1L)
[17:38:08.250]                     }
[17:38:08.250]                     base::local({
[17:38:08.250]                       for (pkg in "future.apply") {
[17:38:08.250]                         base::loadNamespace(pkg)
[17:38:08.250]                         base::library(pkg, character.only = TRUE)
[17:38:08.250]                       }
[17:38:08.250]                     })
[17:38:08.250]                   }
[17:38:08.250]                   ...future.strategy.old <- future::plan("list")
[17:38:08.250]                   options(future.plan = NULL)
[17:38:08.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:08.250]                 }
[17:38:08.250]                 ...future.workdir <- getwd()
[17:38:08.250]             }
[17:38:08.250]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:08.250]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:08.250]         }
[17:38:08.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:08.250]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:08.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:08.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:08.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:08.250]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:08.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:08.250]             base::names(...future.oldOptions))
[17:38:08.250]     }
[17:38:08.250]     if (FALSE) {
[17:38:08.250]     }
[17:38:08.250]     else {
[17:38:08.250]         if (TRUE) {
[17:38:08.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:08.250]                 open = "w")
[17:38:08.250]         }
[17:38:08.250]         else {
[17:38:08.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:08.250]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:08.250]         }
[17:38:08.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:08.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:08.250]             base::sink(type = "output", split = FALSE)
[17:38:08.250]             base::close(...future.stdout)
[17:38:08.250]         }, add = TRUE)
[17:38:08.250]     }
[17:38:08.250]     ...future.frame <- base::sys.nframe()
[17:38:08.250]     ...future.conditions <- base::list()
[17:38:08.250]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:08.250]     if (FALSE) {
[17:38:08.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:08.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:08.250]     }
[17:38:08.250]     ...future.result <- base::tryCatch({
[17:38:08.250]         base::withCallingHandlers({
[17:38:08.250]             ...future.value <- base::withVisible(base::local({
[17:38:08.250]                 withCallingHandlers({
[17:38:08.250]                   {
[17:38:08.250]                     do.call(function(...) {
[17:38:08.250]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.250]                       if (!identical(...future.globals.maxSize.org, 
[17:38:08.250]                         ...future.globals.maxSize)) {
[17:38:08.250]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.250]                         on.exit(options(oopts), add = TRUE)
[17:38:08.250]                       }
[17:38:08.250]                       {
[17:38:08.250]                         lapply(seq_along(...future.elements_ii), 
[17:38:08.250]                           FUN = function(jj) {
[17:38:08.250]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.250]                             ...future.FUN(...future.X_jj, ...)
[17:38:08.250]                           })
[17:38:08.250]                       }
[17:38:08.250]                     }, args = future.call.arguments)
[17:38:08.250]                   }
[17:38:08.250]                 }, immediateCondition = function(cond) {
[17:38:08.250]                   save_rds <- function (object, pathname, ...) 
[17:38:08.250]                   {
[17:38:08.250]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:08.250]                     if (file_test("-f", pathname_tmp)) {
[17:38:08.250]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.250]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:08.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.250]                         fi_tmp[["mtime"]])
[17:38:08.250]                     }
[17:38:08.250]                     tryCatch({
[17:38:08.250]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:08.250]                     }, error = function(ex) {
[17:38:08.250]                       msg <- conditionMessage(ex)
[17:38:08.250]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.250]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:08.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.250]                         fi_tmp[["mtime"]], msg)
[17:38:08.250]                       ex$message <- msg
[17:38:08.250]                       stop(ex)
[17:38:08.250]                     })
[17:38:08.250]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:08.250]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:08.250]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:08.250]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.250]                       fi <- file.info(pathname)
[17:38:08.250]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:08.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.250]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:08.250]                         fi[["size"]], fi[["mtime"]])
[17:38:08.250]                       stop(msg)
[17:38:08.250]                     }
[17:38:08.250]                     invisible(pathname)
[17:38:08.250]                   }
[17:38:08.250]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:08.250]                     rootPath = tempdir()) 
[17:38:08.250]                   {
[17:38:08.250]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:08.250]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:08.250]                       tmpdir = path, fileext = ".rds")
[17:38:08.250]                     save_rds(obj, file)
[17:38:08.250]                   }
[17:38:08.250]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:08.250]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.250]                   {
[17:38:08.250]                     inherits <- base::inherits
[17:38:08.250]                     invokeRestart <- base::invokeRestart
[17:38:08.250]                     is.null <- base::is.null
[17:38:08.250]                     muffled <- FALSE
[17:38:08.250]                     if (inherits(cond, "message")) {
[17:38:08.250]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:08.250]                       if (muffled) 
[17:38:08.250]                         invokeRestart("muffleMessage")
[17:38:08.250]                     }
[17:38:08.250]                     else if (inherits(cond, "warning")) {
[17:38:08.250]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:08.250]                       if (muffled) 
[17:38:08.250]                         invokeRestart("muffleWarning")
[17:38:08.250]                     }
[17:38:08.250]                     else if (inherits(cond, "condition")) {
[17:38:08.250]                       if (!is.null(pattern)) {
[17:38:08.250]                         computeRestarts <- base::computeRestarts
[17:38:08.250]                         grepl <- base::grepl
[17:38:08.250]                         restarts <- computeRestarts(cond)
[17:38:08.250]                         for (restart in restarts) {
[17:38:08.250]                           name <- restart$name
[17:38:08.250]                           if (is.null(name)) 
[17:38:08.250]                             next
[17:38:08.250]                           if (!grepl(pattern, name)) 
[17:38:08.250]                             next
[17:38:08.250]                           invokeRestart(restart)
[17:38:08.250]                           muffled <- TRUE
[17:38:08.250]                           break
[17:38:08.250]                         }
[17:38:08.250]                       }
[17:38:08.250]                     }
[17:38:08.250]                     invisible(muffled)
[17:38:08.250]                   }
[17:38:08.250]                   muffleCondition(cond)
[17:38:08.250]                 })
[17:38:08.250]             }))
[17:38:08.250]             future::FutureResult(value = ...future.value$value, 
[17:38:08.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.250]                   ...future.rng), globalenv = if (FALSE) 
[17:38:08.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:08.250]                     ...future.globalenv.names))
[17:38:08.250]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:08.250]         }, condition = base::local({
[17:38:08.250]             c <- base::c
[17:38:08.250]             inherits <- base::inherits
[17:38:08.250]             invokeRestart <- base::invokeRestart
[17:38:08.250]             length <- base::length
[17:38:08.250]             list <- base::list
[17:38:08.250]             seq.int <- base::seq.int
[17:38:08.250]             signalCondition <- base::signalCondition
[17:38:08.250]             sys.calls <- base::sys.calls
[17:38:08.250]             `[[` <- base::`[[`
[17:38:08.250]             `+` <- base::`+`
[17:38:08.250]             `<<-` <- base::`<<-`
[17:38:08.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:08.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:08.250]                   3L)]
[17:38:08.250]             }
[17:38:08.250]             function(cond) {
[17:38:08.250]                 is_error <- inherits(cond, "error")
[17:38:08.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:08.250]                   NULL)
[17:38:08.250]                 if (is_error) {
[17:38:08.250]                   sessionInformation <- function() {
[17:38:08.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:08.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:08.250]                       search = base::search(), system = base::Sys.info())
[17:38:08.250]                   }
[17:38:08.250]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:08.250]                     cond$call), session = sessionInformation(), 
[17:38:08.250]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:08.250]                   signalCondition(cond)
[17:38:08.250]                 }
[17:38:08.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:08.250]                 "immediateCondition"))) {
[17:38:08.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:08.250]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:08.250]                   if (TRUE && !signal) {
[17:38:08.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.250]                     {
[17:38:08.250]                       inherits <- base::inherits
[17:38:08.250]                       invokeRestart <- base::invokeRestart
[17:38:08.250]                       is.null <- base::is.null
[17:38:08.250]                       muffled <- FALSE
[17:38:08.250]                       if (inherits(cond, "message")) {
[17:38:08.250]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.250]                         if (muffled) 
[17:38:08.250]                           invokeRestart("muffleMessage")
[17:38:08.250]                       }
[17:38:08.250]                       else if (inherits(cond, "warning")) {
[17:38:08.250]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.250]                         if (muffled) 
[17:38:08.250]                           invokeRestart("muffleWarning")
[17:38:08.250]                       }
[17:38:08.250]                       else if (inherits(cond, "condition")) {
[17:38:08.250]                         if (!is.null(pattern)) {
[17:38:08.250]                           computeRestarts <- base::computeRestarts
[17:38:08.250]                           grepl <- base::grepl
[17:38:08.250]                           restarts <- computeRestarts(cond)
[17:38:08.250]                           for (restart in restarts) {
[17:38:08.250]                             name <- restart$name
[17:38:08.250]                             if (is.null(name)) 
[17:38:08.250]                               next
[17:38:08.250]                             if (!grepl(pattern, name)) 
[17:38:08.250]                               next
[17:38:08.250]                             invokeRestart(restart)
[17:38:08.250]                             muffled <- TRUE
[17:38:08.250]                             break
[17:38:08.250]                           }
[17:38:08.250]                         }
[17:38:08.250]                       }
[17:38:08.250]                       invisible(muffled)
[17:38:08.250]                     }
[17:38:08.250]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.250]                   }
[17:38:08.250]                 }
[17:38:08.250]                 else {
[17:38:08.250]                   if (TRUE) {
[17:38:08.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.250]                     {
[17:38:08.250]                       inherits <- base::inherits
[17:38:08.250]                       invokeRestart <- base::invokeRestart
[17:38:08.250]                       is.null <- base::is.null
[17:38:08.250]                       muffled <- FALSE
[17:38:08.250]                       if (inherits(cond, "message")) {
[17:38:08.250]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.250]                         if (muffled) 
[17:38:08.250]                           invokeRestart("muffleMessage")
[17:38:08.250]                       }
[17:38:08.250]                       else if (inherits(cond, "warning")) {
[17:38:08.250]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.250]                         if (muffled) 
[17:38:08.250]                           invokeRestart("muffleWarning")
[17:38:08.250]                       }
[17:38:08.250]                       else if (inherits(cond, "condition")) {
[17:38:08.250]                         if (!is.null(pattern)) {
[17:38:08.250]                           computeRestarts <- base::computeRestarts
[17:38:08.250]                           grepl <- base::grepl
[17:38:08.250]                           restarts <- computeRestarts(cond)
[17:38:08.250]                           for (restart in restarts) {
[17:38:08.250]                             name <- restart$name
[17:38:08.250]                             if (is.null(name)) 
[17:38:08.250]                               next
[17:38:08.250]                             if (!grepl(pattern, name)) 
[17:38:08.250]                               next
[17:38:08.250]                             invokeRestart(restart)
[17:38:08.250]                             muffled <- TRUE
[17:38:08.250]                             break
[17:38:08.250]                           }
[17:38:08.250]                         }
[17:38:08.250]                       }
[17:38:08.250]                       invisible(muffled)
[17:38:08.250]                     }
[17:38:08.250]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.250]                   }
[17:38:08.250]                 }
[17:38:08.250]             }
[17:38:08.250]         }))
[17:38:08.250]     }, error = function(ex) {
[17:38:08.250]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:08.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.250]                 ...future.rng), started = ...future.startTime, 
[17:38:08.250]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:08.250]             version = "1.8"), class = "FutureResult")
[17:38:08.250]     }, finally = {
[17:38:08.250]         if (!identical(...future.workdir, getwd())) 
[17:38:08.250]             setwd(...future.workdir)
[17:38:08.250]         {
[17:38:08.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:08.250]                 ...future.oldOptions$nwarnings <- NULL
[17:38:08.250]             }
[17:38:08.250]             base::options(...future.oldOptions)
[17:38:08.250]             if (.Platform$OS.type == "windows") {
[17:38:08.250]                 old_names <- names(...future.oldEnvVars)
[17:38:08.250]                 envs <- base::Sys.getenv()
[17:38:08.250]                 names <- names(envs)
[17:38:08.250]                 common <- intersect(names, old_names)
[17:38:08.250]                 added <- setdiff(names, old_names)
[17:38:08.250]                 removed <- setdiff(old_names, names)
[17:38:08.250]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:08.250]                   envs[common]]
[17:38:08.250]                 NAMES <- toupper(changed)
[17:38:08.250]                 args <- list()
[17:38:08.250]                 for (kk in seq_along(NAMES)) {
[17:38:08.250]                   name <- changed[[kk]]
[17:38:08.250]                   NAME <- NAMES[[kk]]
[17:38:08.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.250]                     next
[17:38:08.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.250]                 }
[17:38:08.250]                 NAMES <- toupper(added)
[17:38:08.250]                 for (kk in seq_along(NAMES)) {
[17:38:08.250]                   name <- added[[kk]]
[17:38:08.250]                   NAME <- NAMES[[kk]]
[17:38:08.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.250]                     next
[17:38:08.250]                   args[[name]] <- ""
[17:38:08.250]                 }
[17:38:08.250]                 NAMES <- toupper(removed)
[17:38:08.250]                 for (kk in seq_along(NAMES)) {
[17:38:08.250]                   name <- removed[[kk]]
[17:38:08.250]                   NAME <- NAMES[[kk]]
[17:38:08.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.250]                     next
[17:38:08.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.250]                 }
[17:38:08.250]                 if (length(args) > 0) 
[17:38:08.250]                   base::do.call(base::Sys.setenv, args = args)
[17:38:08.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:08.250]             }
[17:38:08.250]             else {
[17:38:08.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:08.250]             }
[17:38:08.250]             {
[17:38:08.250]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:08.250]                   0L) {
[17:38:08.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:08.250]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:08.250]                   base::options(opts)
[17:38:08.250]                 }
[17:38:08.250]                 {
[17:38:08.250]                   {
[17:38:08.250]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:08.250]                     NULL
[17:38:08.250]                   }
[17:38:08.250]                   options(future.plan = NULL)
[17:38:08.250]                   if (is.na(NA_character_)) 
[17:38:08.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:08.250]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:08.250]                     .init = FALSE)
[17:38:08.250]                 }
[17:38:08.250]             }
[17:38:08.250]         }
[17:38:08.250]     })
[17:38:08.250]     if (TRUE) {
[17:38:08.250]         base::sink(type = "output", split = FALSE)
[17:38:08.250]         if (TRUE) {
[17:38:08.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:08.250]         }
[17:38:08.250]         else {
[17:38:08.250]             ...future.result["stdout"] <- base::list(NULL)
[17:38:08.250]         }
[17:38:08.250]         base::close(...future.stdout)
[17:38:08.250]         ...future.stdout <- NULL
[17:38:08.250]     }
[17:38:08.250]     ...future.result$conditions <- ...future.conditions
[17:38:08.250]     ...future.result$finished <- base::Sys.time()
[17:38:08.250]     ...future.result
[17:38:08.250] }
[17:38:08.253] assign_globals() ...
[17:38:08.254] List of 11
[17:38:08.254]  $ ...future.FUN            :function (x, ...)  
[17:38:08.254]  $ x_FUN                    :function (x)  
[17:38:08.254]  $ times                    : int 4
[17:38:08.254]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.254]  $ stop_if_not              :function (...)  
[17:38:08.254]  $ dim                      : int [1:2] 2 2
[17:38:08.254]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:08.254]  $ future.call.arguments    : list()
[17:38:08.254]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.254]  $ ...future.elements_ii    :List of 5
[17:38:08.254]   ..$ : int 6
[17:38:08.254]   ..$ : int 7
[17:38:08.254]   ..$ : int 8
[17:38:08.254]   ..$ : int 9
[17:38:08.254]   ..$ : int 10
[17:38:08.254]  $ ...future.seeds_ii       : NULL
[17:38:08.254]  $ ...future.globals.maxSize: NULL
[17:38:08.254]  - attr(*, "where")=List of 11
[17:38:08.254]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:08.254]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:08.254]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:08.254]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:08.254]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:08.254]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:08.254]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:08.254]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:08.254]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:08.254]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:08.254]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:08.254]  - attr(*, "resolved")= logi FALSE
[17:38:08.254]  - attr(*, "total_size")= num 97304
[17:38:08.254]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.254]  - attr(*, "already-done")= logi TRUE
[17:38:08.267] - copied ‘...future.FUN’ to environment
[17:38:08.267] - reassign environment for ‘x_FUN’
[17:38:08.267] - copied ‘x_FUN’ to environment
[17:38:08.267] - copied ‘times’ to environment
[17:38:08.267] - copied ‘stopf’ to environment
[17:38:08.267] - copied ‘stop_if_not’ to environment
[17:38:08.268] - copied ‘dim’ to environment
[17:38:08.268] - copied ‘valid_types’ to environment
[17:38:08.268] - copied ‘future.call.arguments’ to environment
[17:38:08.268] - copied ‘...future.elements_ii’ to environment
[17:38:08.268] - copied ‘...future.seeds_ii’ to environment
[17:38:08.268] - copied ‘...future.globals.maxSize’ to environment
[17:38:08.268] assign_globals() ... done
[17:38:08.268] requestCore(): workers = 2
[17:38:08.271] MulticoreFuture started
[17:38:08.271] - Launch lazy future ... done
[17:38:08.271] run() for ‘MulticoreFuture’ ... done
[17:38:08.271] Created future:
[17:38:08.272] plan(): Setting new future strategy stack:
[17:38:08.272] List of future strategies:
[17:38:08.272] 1. sequential:
[17:38:08.272]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:08.272]    - tweaked: FALSE
[17:38:08.272]    - call: NULL
[17:38:08.273] plan(): nbrOfWorkers() = 1
[17:38:08.275] plan(): Setting new future strategy stack:
[17:38:08.276] List of future strategies:
[17:38:08.276] 1. multicore:
[17:38:08.276]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:08.276]    - tweaked: FALSE
[17:38:08.276]    - call: plan(strategy)
[17:38:08.281] plan(): nbrOfWorkers() = 2
[17:38:08.272] MulticoreFuture:
[17:38:08.272] Label: ‘future_vapply-2’
[17:38:08.272] Expression:
[17:38:08.272] {
[17:38:08.272]     do.call(function(...) {
[17:38:08.272]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.272]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.272]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.272]             on.exit(options(oopts), add = TRUE)
[17:38:08.272]         }
[17:38:08.272]         {
[17:38:08.272]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.272]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.272]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.272]             })
[17:38:08.272]         }
[17:38:08.272]     }, args = future.call.arguments)
[17:38:08.272] }
[17:38:08.272] Lazy evaluation: FALSE
[17:38:08.272] Asynchronous evaluation: TRUE
[17:38:08.272] Local evaluation: TRUE
[17:38:08.272] Environment: R_GlobalEnv
[17:38:08.272] Capture standard output: TRUE
[17:38:08.272] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:08.272] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:08.272] Packages: 1 packages (‘future.apply’)
[17:38:08.272] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:08.272] Resolved: TRUE
[17:38:08.272] Value: <not collected>
[17:38:08.272] Conditions captured: <none>
[17:38:08.272] Early signaling: FALSE
[17:38:08.272] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:08.272] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.282] Chunk #2 of 2 ... DONE
[17:38:08.282] Launching 2 futures (chunks) ... DONE
[17:38:08.282] Resolving 2 futures (chunks) ...
[17:38:08.283] resolve() on list ...
[17:38:08.283]  recursive: 0
[17:38:08.283]  length: 2
[17:38:08.283] 
[17:38:08.283] Future #1
[17:38:08.283] result() for MulticoreFuture ...
[17:38:08.284] result() for MulticoreFuture ...
[17:38:08.284] result() for MulticoreFuture ... done
[17:38:08.285] result() for MulticoreFuture ... done
[17:38:08.285] result() for MulticoreFuture ...
[17:38:08.285] result() for MulticoreFuture ... done
[17:38:08.285] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:08.285] - nx: 2
[17:38:08.285] - relay: TRUE
[17:38:08.285] - stdout: TRUE
[17:38:08.286] - signal: TRUE
[17:38:08.286] - resignal: FALSE
[17:38:08.286] - force: TRUE
[17:38:08.286] - relayed: [n=2] FALSE, FALSE
[17:38:08.286] - queued futures: [n=2] FALSE, FALSE
[17:38:08.286]  - until=1
[17:38:08.286]  - relaying element #1
[17:38:08.287] result() for MulticoreFuture ...
[17:38:08.287] result() for MulticoreFuture ... done
[17:38:08.287] result() for MulticoreFuture ...
[17:38:08.287] result() for MulticoreFuture ... done
[17:38:08.287] result() for MulticoreFuture ...
[17:38:08.287] result() for MulticoreFuture ... done
[17:38:08.287] result() for MulticoreFuture ...
[17:38:08.288] result() for MulticoreFuture ... done
[17:38:08.288] - relayed: [n=2] TRUE, FALSE
[17:38:08.288] - queued futures: [n=2] TRUE, FALSE
[17:38:08.288] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:08.288]  length: 1 (resolved future 1)
[17:38:08.289] Future #2
[17:38:08.289] result() for MulticoreFuture ...
[17:38:08.290] result() for MulticoreFuture ...
[17:38:08.290] result() for MulticoreFuture ... done
[17:38:08.290] result() for MulticoreFuture ... done
[17:38:08.290] result() for MulticoreFuture ...
[17:38:08.290] result() for MulticoreFuture ... done
[17:38:08.291] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:08.297] - nx: 2
[17:38:08.297] - relay: TRUE
[17:38:08.297] - stdout: TRUE
[17:38:08.297] - signal: TRUE
[17:38:08.297] - resignal: FALSE
[17:38:08.298] - force: TRUE
[17:38:08.298] - relayed: [n=2] TRUE, FALSE
[17:38:08.298] - queued futures: [n=2] TRUE, FALSE
[17:38:08.298]  - until=2
[17:38:08.298]  - relaying element #2
[17:38:08.298] result() for MulticoreFuture ...
[17:38:08.298] result() for MulticoreFuture ... done
[17:38:08.298] result() for MulticoreFuture ...
[17:38:08.298] result() for MulticoreFuture ... done
[17:38:08.299] result() for MulticoreFuture ...
[17:38:08.299] result() for MulticoreFuture ... done
[17:38:08.299] result() for MulticoreFuture ...
[17:38:08.299] result() for MulticoreFuture ... done
[17:38:08.299] - relayed: [n=2] TRUE, TRUE
[17:38:08.299] - queued futures: [n=2] TRUE, TRUE
[17:38:08.299] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:08.300]  length: 0 (resolved future 2)
[17:38:08.300] Relaying remaining futures
[17:38:08.300] signalConditionsASAP(NULL, pos=0) ...
[17:38:08.300] - nx: 2
[17:38:08.300] - relay: TRUE
[17:38:08.300] - stdout: TRUE
[17:38:08.301] - signal: TRUE
[17:38:08.301] - resignal: FALSE
[17:38:08.301] - force: TRUE
[17:38:08.301] - relayed: [n=2] TRUE, TRUE
[17:38:08.301] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:08.301] - relayed: [n=2] TRUE, TRUE
[17:38:08.301] - queued futures: [n=2] TRUE, TRUE
[17:38:08.302] signalConditionsASAP(NULL, pos=0) ... done
[17:38:08.302] resolve() on list ... DONE
[17:38:08.302] result() for MulticoreFuture ...
[17:38:08.302] result() for MulticoreFuture ... done
[17:38:08.302] result() for MulticoreFuture ...
[17:38:08.302] result() for MulticoreFuture ... done
[17:38:08.302] result() for MulticoreFuture ...
[17:38:08.303] result() for MulticoreFuture ... done
[17:38:08.303] result() for MulticoreFuture ...
[17:38:08.303] result() for MulticoreFuture ... done
[17:38:08.303]  - Number of value chunks collected: 2
[17:38:08.303] Resolving 2 futures (chunks) ... DONE
[17:38:08.303] Reducing values from 2 chunks ...
[17:38:08.303]  - Number of values collected after concatenation: 10
[17:38:08.304]  - Number of values expected: 10
[17:38:08.304] Reducing values from 2 chunks ... DONE
[17:38:08.304] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[17:38:08.306] future_lapply() ...
[17:38:08.313] Number of chunks: 2
[17:38:08.313] getGlobalsAndPackagesXApply() ...
[17:38:08.313]  - future.globals: TRUE
[17:38:08.313] getGlobalsAndPackages() ...
[17:38:08.313] Searching for globals...
[17:38:08.317] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[17:38:08.317] Searching for globals ... DONE
[17:38:08.317] Resolving globals: FALSE
[17:38:08.318] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[17:38:08.319] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:08.319] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:08.319] - packages: [1] ‘future.apply’
[17:38:08.319] getGlobalsAndPackages() ... DONE
[17:38:08.319]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:08.319]  - needed namespaces: [n=1] ‘future.apply’
[17:38:08.319] Finding globals ... DONE
[17:38:08.319]  - use_args: TRUE
[17:38:08.320]  - Getting '...' globals ...
[17:38:08.320] resolve() on list ...
[17:38:08.320]  recursive: 0
[17:38:08.320]  length: 1
[17:38:08.320]  elements: ‘...’
[17:38:08.320]  length: 0 (resolved future 1)
[17:38:08.320] resolve() on list ... DONE
[17:38:08.321]    - '...' content: [n=0] 
[17:38:08.321] List of 1
[17:38:08.321]  $ ...: list()
[17:38:08.321]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.321]  - attr(*, "where")=List of 1
[17:38:08.321]   ..$ ...:<environment: 0x5607ffdeb070> 
[17:38:08.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.321]  - attr(*, "resolved")= logi TRUE
[17:38:08.321]  - attr(*, "total_size")= num NA
[17:38:08.325]  - Getting '...' globals ... DONE
[17:38:08.325] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:08.325] List of 8
[17:38:08.325]  $ ...future.FUN:function (x, ...)  
[17:38:08.325]  $ x_FUN        :function (x)  
[17:38:08.325]  $ times        : int 4
[17:38:08.325]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.325]  $ stop_if_not  :function (...)  
[17:38:08.325]  $ dim          : int [1:2] 2 2
[17:38:08.325]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:08.325]  $ ...          : list()
[17:38:08.325]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.325]  - attr(*, "where")=List of 8
[17:38:08.325]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:08.325]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:08.325]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:08.325]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:08.325]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:08.325]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:08.325]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:08.325]   ..$ ...          :<environment: 0x5607ffdeb070> 
[17:38:08.325]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.325]  - attr(*, "resolved")= logi FALSE
[17:38:08.325]  - attr(*, "total_size")= num 105552
[17:38:08.332] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:08.332] getGlobalsAndPackagesXApply() ... DONE
[17:38:08.332] Number of futures (= number of chunks): 2
[17:38:08.332] Launching 2 futures (chunks) ...
[17:38:08.332] Chunk #1 of 2 ...
[17:38:08.332]  - Finding globals in 'X' for chunk #1 ...
[17:38:08.333] getGlobalsAndPackages() ...
[17:38:08.333] Searching for globals...
[17:38:08.333] 
[17:38:08.333] Searching for globals ... DONE
[17:38:08.333] - globals: [0] <none>
[17:38:08.333] getGlobalsAndPackages() ... DONE
[17:38:08.333]    + additional globals found: [n=0] 
[17:38:08.333]    + additional namespaces needed: [n=0] 
[17:38:08.333]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:08.334]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:08.334]  - seeds: <none>
[17:38:08.334]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.334] getGlobalsAndPackages() ...
[17:38:08.334] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.334] Resolving globals: FALSE
[17:38:08.334] Tweak future expression to call with '...' arguments ...
[17:38:08.334] {
[17:38:08.334]     do.call(function(...) {
[17:38:08.334]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.334]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.334]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.334]             on.exit(options(oopts), add = TRUE)
[17:38:08.334]         }
[17:38:08.334]         {
[17:38:08.334]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.334]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.334]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.334]             })
[17:38:08.334]         }
[17:38:08.334]     }, args = future.call.arguments)
[17:38:08.334] }
[17:38:08.335] Tweak future expression to call with '...' arguments ... DONE
[17:38:08.335] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.335] - packages: [1] ‘future.apply’
[17:38:08.335] getGlobalsAndPackages() ... DONE
[17:38:08.336] run() for ‘Future’ ...
[17:38:08.336] - state: ‘created’
[17:38:08.336] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:08.340] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.340] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:08.340]   - Field: ‘label’
[17:38:08.340]   - Field: ‘local’
[17:38:08.340]   - Field: ‘owner’
[17:38:08.341]   - Field: ‘envir’
[17:38:08.341]   - Field: ‘workers’
[17:38:08.341]   - Field: ‘packages’
[17:38:08.341]   - Field: ‘gc’
[17:38:08.341]   - Field: ‘job’
[17:38:08.341]   - Field: ‘conditions’
[17:38:08.341]   - Field: ‘expr’
[17:38:08.341]   - Field: ‘uuid’
[17:38:08.341]   - Field: ‘seed’
[17:38:08.342]   - Field: ‘version’
[17:38:08.342]   - Field: ‘result’
[17:38:08.342]   - Field: ‘asynchronous’
[17:38:08.342]   - Field: ‘calls’
[17:38:08.342]   - Field: ‘globals’
[17:38:08.342]   - Field: ‘stdout’
[17:38:08.342]   - Field: ‘earlySignal’
[17:38:08.342]   - Field: ‘lazy’
[17:38:08.342]   - Field: ‘state’
[17:38:08.342] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:08.343] - Launch lazy future ...
[17:38:08.343] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:08.343] Packages needed by future strategies (n = 0): <none>
[17:38:08.343] {
[17:38:08.343]     {
[17:38:08.343]         {
[17:38:08.343]             ...future.startTime <- base::Sys.time()
[17:38:08.343]             {
[17:38:08.343]                 {
[17:38:08.343]                   {
[17:38:08.343]                     {
[17:38:08.343]                       {
[17:38:08.343]                         base::local({
[17:38:08.343]                           has_future <- base::requireNamespace("future", 
[17:38:08.343]                             quietly = TRUE)
[17:38:08.343]                           if (has_future) {
[17:38:08.343]                             ns <- base::getNamespace("future")
[17:38:08.343]                             version <- ns[[".package"]][["version"]]
[17:38:08.343]                             if (is.null(version)) 
[17:38:08.343]                               version <- utils::packageVersion("future")
[17:38:08.343]                           }
[17:38:08.343]                           else {
[17:38:08.343]                             version <- NULL
[17:38:08.343]                           }
[17:38:08.343]                           if (!has_future || version < "1.8.0") {
[17:38:08.343]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:08.343]                               "", base::R.version$version.string), 
[17:38:08.343]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:08.343]                                 base::R.version$platform, 8 * 
[17:38:08.343]                                   base::.Machine$sizeof.pointer), 
[17:38:08.343]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:08.343]                                 "release", "version")], collapse = " "), 
[17:38:08.343]                               hostname = base::Sys.info()[["nodename"]])
[17:38:08.343]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:08.343]                               info)
[17:38:08.343]                             info <- base::paste(info, collapse = "; ")
[17:38:08.343]                             if (!has_future) {
[17:38:08.343]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:08.343]                                 info)
[17:38:08.343]                             }
[17:38:08.343]                             else {
[17:38:08.343]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:08.343]                                 info, version)
[17:38:08.343]                             }
[17:38:08.343]                             base::stop(msg)
[17:38:08.343]                           }
[17:38:08.343]                         })
[17:38:08.343]                       }
[17:38:08.343]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:08.343]                       base::options(mc.cores = 1L)
[17:38:08.343]                     }
[17:38:08.343]                     base::local({
[17:38:08.343]                       for (pkg in "future.apply") {
[17:38:08.343]                         base::loadNamespace(pkg)
[17:38:08.343]                         base::library(pkg, character.only = TRUE)
[17:38:08.343]                       }
[17:38:08.343]                     })
[17:38:08.343]                   }
[17:38:08.343]                   ...future.strategy.old <- future::plan("list")
[17:38:08.343]                   options(future.plan = NULL)
[17:38:08.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:08.343]                 }
[17:38:08.343]                 ...future.workdir <- getwd()
[17:38:08.343]             }
[17:38:08.343]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:08.343]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:08.343]         }
[17:38:08.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:08.343]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:08.343]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:08.343]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:08.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:08.343]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:08.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:08.343]             base::names(...future.oldOptions))
[17:38:08.343]     }
[17:38:08.343]     if (FALSE) {
[17:38:08.343]     }
[17:38:08.343]     else {
[17:38:08.343]         if (TRUE) {
[17:38:08.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:08.343]                 open = "w")
[17:38:08.343]         }
[17:38:08.343]         else {
[17:38:08.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:08.343]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:08.343]         }
[17:38:08.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:08.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:08.343]             base::sink(type = "output", split = FALSE)
[17:38:08.343]             base::close(...future.stdout)
[17:38:08.343]         }, add = TRUE)
[17:38:08.343]     }
[17:38:08.343]     ...future.frame <- base::sys.nframe()
[17:38:08.343]     ...future.conditions <- base::list()
[17:38:08.343]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:08.343]     if (FALSE) {
[17:38:08.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:08.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:08.343]     }
[17:38:08.343]     ...future.result <- base::tryCatch({
[17:38:08.343]         base::withCallingHandlers({
[17:38:08.343]             ...future.value <- base::withVisible(base::local({
[17:38:08.343]                 withCallingHandlers({
[17:38:08.343]                   {
[17:38:08.343]                     do.call(function(...) {
[17:38:08.343]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.343]                       if (!identical(...future.globals.maxSize.org, 
[17:38:08.343]                         ...future.globals.maxSize)) {
[17:38:08.343]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.343]                         on.exit(options(oopts), add = TRUE)
[17:38:08.343]                       }
[17:38:08.343]                       {
[17:38:08.343]                         lapply(seq_along(...future.elements_ii), 
[17:38:08.343]                           FUN = function(jj) {
[17:38:08.343]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.343]                             ...future.FUN(...future.X_jj, ...)
[17:38:08.343]                           })
[17:38:08.343]                       }
[17:38:08.343]                     }, args = future.call.arguments)
[17:38:08.343]                   }
[17:38:08.343]                 }, immediateCondition = function(cond) {
[17:38:08.343]                   save_rds <- function (object, pathname, ...) 
[17:38:08.343]                   {
[17:38:08.343]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:08.343]                     if (file_test("-f", pathname_tmp)) {
[17:38:08.343]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.343]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:08.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.343]                         fi_tmp[["mtime"]])
[17:38:08.343]                     }
[17:38:08.343]                     tryCatch({
[17:38:08.343]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:08.343]                     }, error = function(ex) {
[17:38:08.343]                       msg <- conditionMessage(ex)
[17:38:08.343]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.343]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:08.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.343]                         fi_tmp[["mtime"]], msg)
[17:38:08.343]                       ex$message <- msg
[17:38:08.343]                       stop(ex)
[17:38:08.343]                     })
[17:38:08.343]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:08.343]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:08.343]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:08.343]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.343]                       fi <- file.info(pathname)
[17:38:08.343]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:08.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.343]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:08.343]                         fi[["size"]], fi[["mtime"]])
[17:38:08.343]                       stop(msg)
[17:38:08.343]                     }
[17:38:08.343]                     invisible(pathname)
[17:38:08.343]                   }
[17:38:08.343]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:08.343]                     rootPath = tempdir()) 
[17:38:08.343]                   {
[17:38:08.343]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:08.343]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:08.343]                       tmpdir = path, fileext = ".rds")
[17:38:08.343]                     save_rds(obj, file)
[17:38:08.343]                   }
[17:38:08.343]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:08.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.343]                   {
[17:38:08.343]                     inherits <- base::inherits
[17:38:08.343]                     invokeRestart <- base::invokeRestart
[17:38:08.343]                     is.null <- base::is.null
[17:38:08.343]                     muffled <- FALSE
[17:38:08.343]                     if (inherits(cond, "message")) {
[17:38:08.343]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:08.343]                       if (muffled) 
[17:38:08.343]                         invokeRestart("muffleMessage")
[17:38:08.343]                     }
[17:38:08.343]                     else if (inherits(cond, "warning")) {
[17:38:08.343]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:08.343]                       if (muffled) 
[17:38:08.343]                         invokeRestart("muffleWarning")
[17:38:08.343]                     }
[17:38:08.343]                     else if (inherits(cond, "condition")) {
[17:38:08.343]                       if (!is.null(pattern)) {
[17:38:08.343]                         computeRestarts <- base::computeRestarts
[17:38:08.343]                         grepl <- base::grepl
[17:38:08.343]                         restarts <- computeRestarts(cond)
[17:38:08.343]                         for (restart in restarts) {
[17:38:08.343]                           name <- restart$name
[17:38:08.343]                           if (is.null(name)) 
[17:38:08.343]                             next
[17:38:08.343]                           if (!grepl(pattern, name)) 
[17:38:08.343]                             next
[17:38:08.343]                           invokeRestart(restart)
[17:38:08.343]                           muffled <- TRUE
[17:38:08.343]                           break
[17:38:08.343]                         }
[17:38:08.343]                       }
[17:38:08.343]                     }
[17:38:08.343]                     invisible(muffled)
[17:38:08.343]                   }
[17:38:08.343]                   muffleCondition(cond)
[17:38:08.343]                 })
[17:38:08.343]             }))
[17:38:08.343]             future::FutureResult(value = ...future.value$value, 
[17:38:08.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.343]                   ...future.rng), globalenv = if (FALSE) 
[17:38:08.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:08.343]                     ...future.globalenv.names))
[17:38:08.343]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:08.343]         }, condition = base::local({
[17:38:08.343]             c <- base::c
[17:38:08.343]             inherits <- base::inherits
[17:38:08.343]             invokeRestart <- base::invokeRestart
[17:38:08.343]             length <- base::length
[17:38:08.343]             list <- base::list
[17:38:08.343]             seq.int <- base::seq.int
[17:38:08.343]             signalCondition <- base::signalCondition
[17:38:08.343]             sys.calls <- base::sys.calls
[17:38:08.343]             `[[` <- base::`[[`
[17:38:08.343]             `+` <- base::`+`
[17:38:08.343]             `<<-` <- base::`<<-`
[17:38:08.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:08.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:08.343]                   3L)]
[17:38:08.343]             }
[17:38:08.343]             function(cond) {
[17:38:08.343]                 is_error <- inherits(cond, "error")
[17:38:08.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:08.343]                   NULL)
[17:38:08.343]                 if (is_error) {
[17:38:08.343]                   sessionInformation <- function() {
[17:38:08.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:08.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:08.343]                       search = base::search(), system = base::Sys.info())
[17:38:08.343]                   }
[17:38:08.343]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:08.343]                     cond$call), session = sessionInformation(), 
[17:38:08.343]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:08.343]                   signalCondition(cond)
[17:38:08.343]                 }
[17:38:08.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:08.343]                 "immediateCondition"))) {
[17:38:08.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:08.343]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:08.343]                   if (TRUE && !signal) {
[17:38:08.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.343]                     {
[17:38:08.343]                       inherits <- base::inherits
[17:38:08.343]                       invokeRestart <- base::invokeRestart
[17:38:08.343]                       is.null <- base::is.null
[17:38:08.343]                       muffled <- FALSE
[17:38:08.343]                       if (inherits(cond, "message")) {
[17:38:08.343]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.343]                         if (muffled) 
[17:38:08.343]                           invokeRestart("muffleMessage")
[17:38:08.343]                       }
[17:38:08.343]                       else if (inherits(cond, "warning")) {
[17:38:08.343]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.343]                         if (muffled) 
[17:38:08.343]                           invokeRestart("muffleWarning")
[17:38:08.343]                       }
[17:38:08.343]                       else if (inherits(cond, "condition")) {
[17:38:08.343]                         if (!is.null(pattern)) {
[17:38:08.343]                           computeRestarts <- base::computeRestarts
[17:38:08.343]                           grepl <- base::grepl
[17:38:08.343]                           restarts <- computeRestarts(cond)
[17:38:08.343]                           for (restart in restarts) {
[17:38:08.343]                             name <- restart$name
[17:38:08.343]                             if (is.null(name)) 
[17:38:08.343]                               next
[17:38:08.343]                             if (!grepl(pattern, name)) 
[17:38:08.343]                               next
[17:38:08.343]                             invokeRestart(restart)
[17:38:08.343]                             muffled <- TRUE
[17:38:08.343]                             break
[17:38:08.343]                           }
[17:38:08.343]                         }
[17:38:08.343]                       }
[17:38:08.343]                       invisible(muffled)
[17:38:08.343]                     }
[17:38:08.343]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.343]                   }
[17:38:08.343]                 }
[17:38:08.343]                 else {
[17:38:08.343]                   if (TRUE) {
[17:38:08.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.343]                     {
[17:38:08.343]                       inherits <- base::inherits
[17:38:08.343]                       invokeRestart <- base::invokeRestart
[17:38:08.343]                       is.null <- base::is.null
[17:38:08.343]                       muffled <- FALSE
[17:38:08.343]                       if (inherits(cond, "message")) {
[17:38:08.343]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.343]                         if (muffled) 
[17:38:08.343]                           invokeRestart("muffleMessage")
[17:38:08.343]                       }
[17:38:08.343]                       else if (inherits(cond, "warning")) {
[17:38:08.343]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.343]                         if (muffled) 
[17:38:08.343]                           invokeRestart("muffleWarning")
[17:38:08.343]                       }
[17:38:08.343]                       else if (inherits(cond, "condition")) {
[17:38:08.343]                         if (!is.null(pattern)) {
[17:38:08.343]                           computeRestarts <- base::computeRestarts
[17:38:08.343]                           grepl <- base::grepl
[17:38:08.343]                           restarts <- computeRestarts(cond)
[17:38:08.343]                           for (restart in restarts) {
[17:38:08.343]                             name <- restart$name
[17:38:08.343]                             if (is.null(name)) 
[17:38:08.343]                               next
[17:38:08.343]                             if (!grepl(pattern, name)) 
[17:38:08.343]                               next
[17:38:08.343]                             invokeRestart(restart)
[17:38:08.343]                             muffled <- TRUE
[17:38:08.343]                             break
[17:38:08.343]                           }
[17:38:08.343]                         }
[17:38:08.343]                       }
[17:38:08.343]                       invisible(muffled)
[17:38:08.343]                     }
[17:38:08.343]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.343]                   }
[17:38:08.343]                 }
[17:38:08.343]             }
[17:38:08.343]         }))
[17:38:08.343]     }, error = function(ex) {
[17:38:08.343]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:08.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.343]                 ...future.rng), started = ...future.startTime, 
[17:38:08.343]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:08.343]             version = "1.8"), class = "FutureResult")
[17:38:08.343]     }, finally = {
[17:38:08.343]         if (!identical(...future.workdir, getwd())) 
[17:38:08.343]             setwd(...future.workdir)
[17:38:08.343]         {
[17:38:08.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:08.343]                 ...future.oldOptions$nwarnings <- NULL
[17:38:08.343]             }
[17:38:08.343]             base::options(...future.oldOptions)
[17:38:08.343]             if (.Platform$OS.type == "windows") {
[17:38:08.343]                 old_names <- names(...future.oldEnvVars)
[17:38:08.343]                 envs <- base::Sys.getenv()
[17:38:08.343]                 names <- names(envs)
[17:38:08.343]                 common <- intersect(names, old_names)
[17:38:08.343]                 added <- setdiff(names, old_names)
[17:38:08.343]                 removed <- setdiff(old_names, names)
[17:38:08.343]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:08.343]                   envs[common]]
[17:38:08.343]                 NAMES <- toupper(changed)
[17:38:08.343]                 args <- list()
[17:38:08.343]                 for (kk in seq_along(NAMES)) {
[17:38:08.343]                   name <- changed[[kk]]
[17:38:08.343]                   NAME <- NAMES[[kk]]
[17:38:08.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.343]                     next
[17:38:08.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.343]                 }
[17:38:08.343]                 NAMES <- toupper(added)
[17:38:08.343]                 for (kk in seq_along(NAMES)) {
[17:38:08.343]                   name <- added[[kk]]
[17:38:08.343]                   NAME <- NAMES[[kk]]
[17:38:08.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.343]                     next
[17:38:08.343]                   args[[name]] <- ""
[17:38:08.343]                 }
[17:38:08.343]                 NAMES <- toupper(removed)
[17:38:08.343]                 for (kk in seq_along(NAMES)) {
[17:38:08.343]                   name <- removed[[kk]]
[17:38:08.343]                   NAME <- NAMES[[kk]]
[17:38:08.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.343]                     next
[17:38:08.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.343]                 }
[17:38:08.343]                 if (length(args) > 0) 
[17:38:08.343]                   base::do.call(base::Sys.setenv, args = args)
[17:38:08.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:08.343]             }
[17:38:08.343]             else {
[17:38:08.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:08.343]             }
[17:38:08.343]             {
[17:38:08.343]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:08.343]                   0L) {
[17:38:08.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:08.343]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:08.343]                   base::options(opts)
[17:38:08.343]                 }
[17:38:08.343]                 {
[17:38:08.343]                   {
[17:38:08.343]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:08.343]                     NULL
[17:38:08.343]                   }
[17:38:08.343]                   options(future.plan = NULL)
[17:38:08.343]                   if (is.na(NA_character_)) 
[17:38:08.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:08.343]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:08.343]                     .init = FALSE)
[17:38:08.343]                 }
[17:38:08.343]             }
[17:38:08.343]         }
[17:38:08.343]     })
[17:38:08.343]     if (TRUE) {
[17:38:08.343]         base::sink(type = "output", split = FALSE)
[17:38:08.343]         if (TRUE) {
[17:38:08.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:08.343]         }
[17:38:08.343]         else {
[17:38:08.343]             ...future.result["stdout"] <- base::list(NULL)
[17:38:08.343]         }
[17:38:08.343]         base::close(...future.stdout)
[17:38:08.343]         ...future.stdout <- NULL
[17:38:08.343]     }
[17:38:08.343]     ...future.result$conditions <- ...future.conditions
[17:38:08.343]     ...future.result$finished <- base::Sys.time()
[17:38:08.343]     ...future.result
[17:38:08.343] }
[17:38:08.346] assign_globals() ...
[17:38:08.346] List of 11
[17:38:08.346]  $ ...future.FUN            :function (x, ...)  
[17:38:08.346]  $ x_FUN                    :function (x)  
[17:38:08.346]  $ times                    : int 4
[17:38:08.346]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.346]  $ stop_if_not              :function (...)  
[17:38:08.346]  $ dim                      : int [1:2] 2 2
[17:38:08.346]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:08.346]  $ future.call.arguments    : list()
[17:38:08.346]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.346]  $ ...future.elements_ii    :List of 5
[17:38:08.346]   ..$ : int 1
[17:38:08.346]   ..$ : int 2
[17:38:08.346]   ..$ : int 3
[17:38:08.346]   ..$ : int 4
[17:38:08.346]   ..$ : int 5
[17:38:08.346]  $ ...future.seeds_ii       : NULL
[17:38:08.346]  $ ...future.globals.maxSize: NULL
[17:38:08.346]  - attr(*, "where")=List of 11
[17:38:08.346]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:08.346]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:08.346]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:08.346]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:08.346]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:08.346]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:08.346]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:08.346]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:08.346]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:08.346]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:08.346]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:08.346]  - attr(*, "resolved")= logi FALSE
[17:38:08.346]  - attr(*, "total_size")= num 105552
[17:38:08.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.346]  - attr(*, "already-done")= logi TRUE
[17:38:08.359] - copied ‘...future.FUN’ to environment
[17:38:08.359] - reassign environment for ‘x_FUN’
[17:38:08.359] - copied ‘x_FUN’ to environment
[17:38:08.359] - copied ‘times’ to environment
[17:38:08.360] - copied ‘stopf’ to environment
[17:38:08.360] - copied ‘stop_if_not’ to environment
[17:38:08.360] - copied ‘dim’ to environment
[17:38:08.360] - copied ‘valid_types’ to environment
[17:38:08.360] - copied ‘future.call.arguments’ to environment
[17:38:08.360] - copied ‘...future.elements_ii’ to environment
[17:38:08.360] - copied ‘...future.seeds_ii’ to environment
[17:38:08.360] - copied ‘...future.globals.maxSize’ to environment
[17:38:08.360] assign_globals() ... done
[17:38:08.361] requestCore(): workers = 2
[17:38:08.363] MulticoreFuture started
[17:38:08.364] - Launch lazy future ... done
[17:38:08.364] run() for ‘MulticoreFuture’ ... done
[17:38:08.364] Created future:
[17:38:08.365] plan(): Setting new future strategy stack:
[17:38:08.365] List of future strategies:
[17:38:08.365] 1. sequential:
[17:38:08.365]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:08.365]    - tweaked: FALSE
[17:38:08.365]    - call: NULL
[17:38:08.366] plan(): nbrOfWorkers() = 1
[17:38:08.369] plan(): Setting new future strategy stack:
[17:38:08.369] List of future strategies:
[17:38:08.369] 1. multicore:
[17:38:08.369]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:08.369]    - tweaked: FALSE
[17:38:08.369]    - call: plan(strategy)
[17:38:08.374] plan(): nbrOfWorkers() = 2
[17:38:08.365] MulticoreFuture:
[17:38:08.365] Label: ‘future_vapply-1’
[17:38:08.365] Expression:
[17:38:08.365] {
[17:38:08.365]     do.call(function(...) {
[17:38:08.365]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.365]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.365]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.365]             on.exit(options(oopts), add = TRUE)
[17:38:08.365]         }
[17:38:08.365]         {
[17:38:08.365]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.365]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.365]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.365]             })
[17:38:08.365]         }
[17:38:08.365]     }, args = future.call.arguments)
[17:38:08.365] }
[17:38:08.365] Lazy evaluation: FALSE
[17:38:08.365] Asynchronous evaluation: TRUE
[17:38:08.365] Local evaluation: TRUE
[17:38:08.365] Environment: R_GlobalEnv
[17:38:08.365] Capture standard output: TRUE
[17:38:08.365] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:08.365] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:08.365] Packages: 1 packages (‘future.apply’)
[17:38:08.365] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:08.365] Resolved: TRUE
[17:38:08.365] Value: <not collected>
[17:38:08.365] Conditions captured: <none>
[17:38:08.365] Early signaling: FALSE
[17:38:08.365] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:08.365] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.375] Chunk #1 of 2 ... DONE
[17:38:08.375] Chunk #2 of 2 ...
[17:38:08.376]  - Finding globals in 'X' for chunk #2 ...
[17:38:08.376] getGlobalsAndPackages() ...
[17:38:08.376] Searching for globals...
[17:38:08.377] 
[17:38:08.377] Searching for globals ... DONE
[17:38:08.377] - globals: [0] <none>
[17:38:08.377] getGlobalsAndPackages() ... DONE
[17:38:08.377]    + additional globals found: [n=0] 
[17:38:08.377]    + additional namespaces needed: [n=0] 
[17:38:08.377]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:08.377]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:08.378]  - seeds: <none>
[17:38:08.378]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.378] getGlobalsAndPackages() ...
[17:38:08.378] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.378] Resolving globals: FALSE
[17:38:08.378] Tweak future expression to call with '...' arguments ...
[17:38:08.379] {
[17:38:08.379]     do.call(function(...) {
[17:38:08.379]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.379]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.379]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.379]             on.exit(options(oopts), add = TRUE)
[17:38:08.379]         }
[17:38:08.379]         {
[17:38:08.379]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.379]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.379]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.379]             })
[17:38:08.379]         }
[17:38:08.379]     }, args = future.call.arguments)
[17:38:08.379] }
[17:38:08.379] Tweak future expression to call with '...' arguments ... DONE
[17:38:08.380] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.380] - packages: [1] ‘future.apply’
[17:38:08.380] getGlobalsAndPackages() ... DONE
[17:38:08.381] run() for ‘Future’ ...
[17:38:08.381] - state: ‘created’
[17:38:08.381] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:08.386] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.386] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:08.386]   - Field: ‘label’
[17:38:08.386]   - Field: ‘local’
[17:38:08.386]   - Field: ‘owner’
[17:38:08.387]   - Field: ‘envir’
[17:38:08.387]   - Field: ‘workers’
[17:38:08.387]   - Field: ‘packages’
[17:38:08.387]   - Field: ‘gc’
[17:38:08.387]   - Field: ‘job’
[17:38:08.387]   - Field: ‘conditions’
[17:38:08.387]   - Field: ‘expr’
[17:38:08.388]   - Field: ‘uuid’
[17:38:08.388]   - Field: ‘seed’
[17:38:08.388]   - Field: ‘version’
[17:38:08.388]   - Field: ‘result’
[17:38:08.388]   - Field: ‘asynchronous’
[17:38:08.388]   - Field: ‘calls’
[17:38:08.389]   - Field: ‘globals’
[17:38:08.389]   - Field: ‘stdout’
[17:38:08.389]   - Field: ‘earlySignal’
[17:38:08.389]   - Field: ‘lazy’
[17:38:08.389]   - Field: ‘state’
[17:38:08.389] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:08.389] - Launch lazy future ...
[17:38:08.390] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:08.390] Packages needed by future strategies (n = 0): <none>
[17:38:08.391] {
[17:38:08.391]     {
[17:38:08.391]         {
[17:38:08.391]             ...future.startTime <- base::Sys.time()
[17:38:08.391]             {
[17:38:08.391]                 {
[17:38:08.391]                   {
[17:38:08.391]                     {
[17:38:08.391]                       {
[17:38:08.391]                         base::local({
[17:38:08.391]                           has_future <- base::requireNamespace("future", 
[17:38:08.391]                             quietly = TRUE)
[17:38:08.391]                           if (has_future) {
[17:38:08.391]                             ns <- base::getNamespace("future")
[17:38:08.391]                             version <- ns[[".package"]][["version"]]
[17:38:08.391]                             if (is.null(version)) 
[17:38:08.391]                               version <- utils::packageVersion("future")
[17:38:08.391]                           }
[17:38:08.391]                           else {
[17:38:08.391]                             version <- NULL
[17:38:08.391]                           }
[17:38:08.391]                           if (!has_future || version < "1.8.0") {
[17:38:08.391]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:08.391]                               "", base::R.version$version.string), 
[17:38:08.391]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:08.391]                                 base::R.version$platform, 8 * 
[17:38:08.391]                                   base::.Machine$sizeof.pointer), 
[17:38:08.391]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:08.391]                                 "release", "version")], collapse = " "), 
[17:38:08.391]                               hostname = base::Sys.info()[["nodename"]])
[17:38:08.391]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:08.391]                               info)
[17:38:08.391]                             info <- base::paste(info, collapse = "; ")
[17:38:08.391]                             if (!has_future) {
[17:38:08.391]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:08.391]                                 info)
[17:38:08.391]                             }
[17:38:08.391]                             else {
[17:38:08.391]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:08.391]                                 info, version)
[17:38:08.391]                             }
[17:38:08.391]                             base::stop(msg)
[17:38:08.391]                           }
[17:38:08.391]                         })
[17:38:08.391]                       }
[17:38:08.391]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:08.391]                       base::options(mc.cores = 1L)
[17:38:08.391]                     }
[17:38:08.391]                     base::local({
[17:38:08.391]                       for (pkg in "future.apply") {
[17:38:08.391]                         base::loadNamespace(pkg)
[17:38:08.391]                         base::library(pkg, character.only = TRUE)
[17:38:08.391]                       }
[17:38:08.391]                     })
[17:38:08.391]                   }
[17:38:08.391]                   ...future.strategy.old <- future::plan("list")
[17:38:08.391]                   options(future.plan = NULL)
[17:38:08.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:08.391]                 }
[17:38:08.391]                 ...future.workdir <- getwd()
[17:38:08.391]             }
[17:38:08.391]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:08.391]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:08.391]         }
[17:38:08.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:08.391]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:08.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:08.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:08.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:08.391]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:08.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:08.391]             base::names(...future.oldOptions))
[17:38:08.391]     }
[17:38:08.391]     if (FALSE) {
[17:38:08.391]     }
[17:38:08.391]     else {
[17:38:08.391]         if (TRUE) {
[17:38:08.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:08.391]                 open = "w")
[17:38:08.391]         }
[17:38:08.391]         else {
[17:38:08.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:08.391]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:08.391]         }
[17:38:08.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:08.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:08.391]             base::sink(type = "output", split = FALSE)
[17:38:08.391]             base::close(...future.stdout)
[17:38:08.391]         }, add = TRUE)
[17:38:08.391]     }
[17:38:08.391]     ...future.frame <- base::sys.nframe()
[17:38:08.391]     ...future.conditions <- base::list()
[17:38:08.391]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:08.391]     if (FALSE) {
[17:38:08.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:08.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:08.391]     }
[17:38:08.391]     ...future.result <- base::tryCatch({
[17:38:08.391]         base::withCallingHandlers({
[17:38:08.391]             ...future.value <- base::withVisible(base::local({
[17:38:08.391]                 withCallingHandlers({
[17:38:08.391]                   {
[17:38:08.391]                     do.call(function(...) {
[17:38:08.391]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.391]                       if (!identical(...future.globals.maxSize.org, 
[17:38:08.391]                         ...future.globals.maxSize)) {
[17:38:08.391]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.391]                         on.exit(options(oopts), add = TRUE)
[17:38:08.391]                       }
[17:38:08.391]                       {
[17:38:08.391]                         lapply(seq_along(...future.elements_ii), 
[17:38:08.391]                           FUN = function(jj) {
[17:38:08.391]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.391]                             ...future.FUN(...future.X_jj, ...)
[17:38:08.391]                           })
[17:38:08.391]                       }
[17:38:08.391]                     }, args = future.call.arguments)
[17:38:08.391]                   }
[17:38:08.391]                 }, immediateCondition = function(cond) {
[17:38:08.391]                   save_rds <- function (object, pathname, ...) 
[17:38:08.391]                   {
[17:38:08.391]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:08.391]                     if (file_test("-f", pathname_tmp)) {
[17:38:08.391]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.391]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:08.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.391]                         fi_tmp[["mtime"]])
[17:38:08.391]                     }
[17:38:08.391]                     tryCatch({
[17:38:08.391]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:08.391]                     }, error = function(ex) {
[17:38:08.391]                       msg <- conditionMessage(ex)
[17:38:08.391]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.391]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:08.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.391]                         fi_tmp[["mtime"]], msg)
[17:38:08.391]                       ex$message <- msg
[17:38:08.391]                       stop(ex)
[17:38:08.391]                     })
[17:38:08.391]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:08.391]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:08.391]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:08.391]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.391]                       fi <- file.info(pathname)
[17:38:08.391]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:08.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.391]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:08.391]                         fi[["size"]], fi[["mtime"]])
[17:38:08.391]                       stop(msg)
[17:38:08.391]                     }
[17:38:08.391]                     invisible(pathname)
[17:38:08.391]                   }
[17:38:08.391]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:08.391]                     rootPath = tempdir()) 
[17:38:08.391]                   {
[17:38:08.391]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:08.391]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:08.391]                       tmpdir = path, fileext = ".rds")
[17:38:08.391]                     save_rds(obj, file)
[17:38:08.391]                   }
[17:38:08.391]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:08.391]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.391]                   {
[17:38:08.391]                     inherits <- base::inherits
[17:38:08.391]                     invokeRestart <- base::invokeRestart
[17:38:08.391]                     is.null <- base::is.null
[17:38:08.391]                     muffled <- FALSE
[17:38:08.391]                     if (inherits(cond, "message")) {
[17:38:08.391]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:08.391]                       if (muffled) 
[17:38:08.391]                         invokeRestart("muffleMessage")
[17:38:08.391]                     }
[17:38:08.391]                     else if (inherits(cond, "warning")) {
[17:38:08.391]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:08.391]                       if (muffled) 
[17:38:08.391]                         invokeRestart("muffleWarning")
[17:38:08.391]                     }
[17:38:08.391]                     else if (inherits(cond, "condition")) {
[17:38:08.391]                       if (!is.null(pattern)) {
[17:38:08.391]                         computeRestarts <- base::computeRestarts
[17:38:08.391]                         grepl <- base::grepl
[17:38:08.391]                         restarts <- computeRestarts(cond)
[17:38:08.391]                         for (restart in restarts) {
[17:38:08.391]                           name <- restart$name
[17:38:08.391]                           if (is.null(name)) 
[17:38:08.391]                             next
[17:38:08.391]                           if (!grepl(pattern, name)) 
[17:38:08.391]                             next
[17:38:08.391]                           invokeRestart(restart)
[17:38:08.391]                           muffled <- TRUE
[17:38:08.391]                           break
[17:38:08.391]                         }
[17:38:08.391]                       }
[17:38:08.391]                     }
[17:38:08.391]                     invisible(muffled)
[17:38:08.391]                   }
[17:38:08.391]                   muffleCondition(cond)
[17:38:08.391]                 })
[17:38:08.391]             }))
[17:38:08.391]             future::FutureResult(value = ...future.value$value, 
[17:38:08.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.391]                   ...future.rng), globalenv = if (FALSE) 
[17:38:08.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:08.391]                     ...future.globalenv.names))
[17:38:08.391]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:08.391]         }, condition = base::local({
[17:38:08.391]             c <- base::c
[17:38:08.391]             inherits <- base::inherits
[17:38:08.391]             invokeRestart <- base::invokeRestart
[17:38:08.391]             length <- base::length
[17:38:08.391]             list <- base::list
[17:38:08.391]             seq.int <- base::seq.int
[17:38:08.391]             signalCondition <- base::signalCondition
[17:38:08.391]             sys.calls <- base::sys.calls
[17:38:08.391]             `[[` <- base::`[[`
[17:38:08.391]             `+` <- base::`+`
[17:38:08.391]             `<<-` <- base::`<<-`
[17:38:08.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:08.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:08.391]                   3L)]
[17:38:08.391]             }
[17:38:08.391]             function(cond) {
[17:38:08.391]                 is_error <- inherits(cond, "error")
[17:38:08.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:08.391]                   NULL)
[17:38:08.391]                 if (is_error) {
[17:38:08.391]                   sessionInformation <- function() {
[17:38:08.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:08.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:08.391]                       search = base::search(), system = base::Sys.info())
[17:38:08.391]                   }
[17:38:08.391]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:08.391]                     cond$call), session = sessionInformation(), 
[17:38:08.391]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:08.391]                   signalCondition(cond)
[17:38:08.391]                 }
[17:38:08.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:08.391]                 "immediateCondition"))) {
[17:38:08.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:08.391]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:08.391]                   if (TRUE && !signal) {
[17:38:08.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.391]                     {
[17:38:08.391]                       inherits <- base::inherits
[17:38:08.391]                       invokeRestart <- base::invokeRestart
[17:38:08.391]                       is.null <- base::is.null
[17:38:08.391]                       muffled <- FALSE
[17:38:08.391]                       if (inherits(cond, "message")) {
[17:38:08.391]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.391]                         if (muffled) 
[17:38:08.391]                           invokeRestart("muffleMessage")
[17:38:08.391]                       }
[17:38:08.391]                       else if (inherits(cond, "warning")) {
[17:38:08.391]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.391]                         if (muffled) 
[17:38:08.391]                           invokeRestart("muffleWarning")
[17:38:08.391]                       }
[17:38:08.391]                       else if (inherits(cond, "condition")) {
[17:38:08.391]                         if (!is.null(pattern)) {
[17:38:08.391]                           computeRestarts <- base::computeRestarts
[17:38:08.391]                           grepl <- base::grepl
[17:38:08.391]                           restarts <- computeRestarts(cond)
[17:38:08.391]                           for (restart in restarts) {
[17:38:08.391]                             name <- restart$name
[17:38:08.391]                             if (is.null(name)) 
[17:38:08.391]                               next
[17:38:08.391]                             if (!grepl(pattern, name)) 
[17:38:08.391]                               next
[17:38:08.391]                             invokeRestart(restart)
[17:38:08.391]                             muffled <- TRUE
[17:38:08.391]                             break
[17:38:08.391]                           }
[17:38:08.391]                         }
[17:38:08.391]                       }
[17:38:08.391]                       invisible(muffled)
[17:38:08.391]                     }
[17:38:08.391]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.391]                   }
[17:38:08.391]                 }
[17:38:08.391]                 else {
[17:38:08.391]                   if (TRUE) {
[17:38:08.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.391]                     {
[17:38:08.391]                       inherits <- base::inherits
[17:38:08.391]                       invokeRestart <- base::invokeRestart
[17:38:08.391]                       is.null <- base::is.null
[17:38:08.391]                       muffled <- FALSE
[17:38:08.391]                       if (inherits(cond, "message")) {
[17:38:08.391]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.391]                         if (muffled) 
[17:38:08.391]                           invokeRestart("muffleMessage")
[17:38:08.391]                       }
[17:38:08.391]                       else if (inherits(cond, "warning")) {
[17:38:08.391]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.391]                         if (muffled) 
[17:38:08.391]                           invokeRestart("muffleWarning")
[17:38:08.391]                       }
[17:38:08.391]                       else if (inherits(cond, "condition")) {
[17:38:08.391]                         if (!is.null(pattern)) {
[17:38:08.391]                           computeRestarts <- base::computeRestarts
[17:38:08.391]                           grepl <- base::grepl
[17:38:08.391]                           restarts <- computeRestarts(cond)
[17:38:08.391]                           for (restart in restarts) {
[17:38:08.391]                             name <- restart$name
[17:38:08.391]                             if (is.null(name)) 
[17:38:08.391]                               next
[17:38:08.391]                             if (!grepl(pattern, name)) 
[17:38:08.391]                               next
[17:38:08.391]                             invokeRestart(restart)
[17:38:08.391]                             muffled <- TRUE
[17:38:08.391]                             break
[17:38:08.391]                           }
[17:38:08.391]                         }
[17:38:08.391]                       }
[17:38:08.391]                       invisible(muffled)
[17:38:08.391]                     }
[17:38:08.391]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.391]                   }
[17:38:08.391]                 }
[17:38:08.391]             }
[17:38:08.391]         }))
[17:38:08.391]     }, error = function(ex) {
[17:38:08.391]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:08.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.391]                 ...future.rng), started = ...future.startTime, 
[17:38:08.391]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:08.391]             version = "1.8"), class = "FutureResult")
[17:38:08.391]     }, finally = {
[17:38:08.391]         if (!identical(...future.workdir, getwd())) 
[17:38:08.391]             setwd(...future.workdir)
[17:38:08.391]         {
[17:38:08.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:08.391]                 ...future.oldOptions$nwarnings <- NULL
[17:38:08.391]             }
[17:38:08.391]             base::options(...future.oldOptions)
[17:38:08.391]             if (.Platform$OS.type == "windows") {
[17:38:08.391]                 old_names <- names(...future.oldEnvVars)
[17:38:08.391]                 envs <- base::Sys.getenv()
[17:38:08.391]                 names <- names(envs)
[17:38:08.391]                 common <- intersect(names, old_names)
[17:38:08.391]                 added <- setdiff(names, old_names)
[17:38:08.391]                 removed <- setdiff(old_names, names)
[17:38:08.391]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:08.391]                   envs[common]]
[17:38:08.391]                 NAMES <- toupper(changed)
[17:38:08.391]                 args <- list()
[17:38:08.391]                 for (kk in seq_along(NAMES)) {
[17:38:08.391]                   name <- changed[[kk]]
[17:38:08.391]                   NAME <- NAMES[[kk]]
[17:38:08.391]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.391]                     next
[17:38:08.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.391]                 }
[17:38:08.391]                 NAMES <- toupper(added)
[17:38:08.391]                 for (kk in seq_along(NAMES)) {
[17:38:08.391]                   name <- added[[kk]]
[17:38:08.391]                   NAME <- NAMES[[kk]]
[17:38:08.391]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.391]                     next
[17:38:08.391]                   args[[name]] <- ""
[17:38:08.391]                 }
[17:38:08.391]                 NAMES <- toupper(removed)
[17:38:08.391]                 for (kk in seq_along(NAMES)) {
[17:38:08.391]                   name <- removed[[kk]]
[17:38:08.391]                   NAME <- NAMES[[kk]]
[17:38:08.391]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.391]                     next
[17:38:08.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.391]                 }
[17:38:08.391]                 if (length(args) > 0) 
[17:38:08.391]                   base::do.call(base::Sys.setenv, args = args)
[17:38:08.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:08.391]             }
[17:38:08.391]             else {
[17:38:08.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:08.391]             }
[17:38:08.391]             {
[17:38:08.391]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:08.391]                   0L) {
[17:38:08.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:08.391]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:08.391]                   base::options(opts)
[17:38:08.391]                 }
[17:38:08.391]                 {
[17:38:08.391]                   {
[17:38:08.391]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:08.391]                     NULL
[17:38:08.391]                   }
[17:38:08.391]                   options(future.plan = NULL)
[17:38:08.391]                   if (is.na(NA_character_)) 
[17:38:08.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:08.391]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:08.391]                     .init = FALSE)
[17:38:08.391]                 }
[17:38:08.391]             }
[17:38:08.391]         }
[17:38:08.391]     })
[17:38:08.391]     if (TRUE) {
[17:38:08.391]         base::sink(type = "output", split = FALSE)
[17:38:08.391]         if (TRUE) {
[17:38:08.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:08.391]         }
[17:38:08.391]         else {
[17:38:08.391]             ...future.result["stdout"] <- base::list(NULL)
[17:38:08.391]         }
[17:38:08.391]         base::close(...future.stdout)
[17:38:08.391]         ...future.stdout <- NULL
[17:38:08.391]     }
[17:38:08.391]     ...future.result$conditions <- ...future.conditions
[17:38:08.391]     ...future.result$finished <- base::Sys.time()
[17:38:08.391]     ...future.result
[17:38:08.391] }
[17:38:08.394] assign_globals() ...
[17:38:08.395] List of 11
[17:38:08.395]  $ ...future.FUN            :function (x, ...)  
[17:38:08.395]  $ x_FUN                    :function (x)  
[17:38:08.395]  $ times                    : int 4
[17:38:08.395]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.395]  $ stop_if_not              :function (...)  
[17:38:08.395]  $ dim                      : int [1:2] 2 2
[17:38:08.395]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:08.395]  $ future.call.arguments    : list()
[17:38:08.395]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.395]  $ ...future.elements_ii    :List of 5
[17:38:08.395]   ..$ : int 6
[17:38:08.395]   ..$ : int 7
[17:38:08.395]   ..$ : int 8
[17:38:08.395]   ..$ : int 9
[17:38:08.395]   ..$ : int 10
[17:38:08.395]  $ ...future.seeds_ii       : NULL
[17:38:08.395]  $ ...future.globals.maxSize: NULL
[17:38:08.395]  - attr(*, "where")=List of 11
[17:38:08.395]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:08.395]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:08.395]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:08.395]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:08.395]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:08.395]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:08.395]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:08.395]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:08.395]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:08.395]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:08.395]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:08.395]  - attr(*, "resolved")= logi FALSE
[17:38:08.395]  - attr(*, "total_size")= num 105552
[17:38:08.395]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.395]  - attr(*, "already-done")= logi TRUE
[17:38:08.412] - copied ‘...future.FUN’ to environment
[17:38:08.412] - reassign environment for ‘x_FUN’
[17:38:08.412] - copied ‘x_FUN’ to environment
[17:38:08.412] - copied ‘times’ to environment
[17:38:08.412] - copied ‘stopf’ to environment
[17:38:08.413] - copied ‘stop_if_not’ to environment
[17:38:08.413] - copied ‘dim’ to environment
[17:38:08.413] - copied ‘valid_types’ to environment
[17:38:08.413] - copied ‘future.call.arguments’ to environment
[17:38:08.413] - copied ‘...future.elements_ii’ to environment
[17:38:08.413] - copied ‘...future.seeds_ii’ to environment
[17:38:08.413] - copied ‘...future.globals.maxSize’ to environment
[17:38:08.413] assign_globals() ... done
[17:38:08.414] requestCore(): workers = 2
[17:38:08.416] MulticoreFuture started
[17:38:08.416] - Launch lazy future ... done
[17:38:08.417] run() for ‘MulticoreFuture’ ... done
[17:38:08.417] Created future:
[17:38:08.418] plan(): Setting new future strategy stack:
[17:38:08.418] List of future strategies:
[17:38:08.418] 1. sequential:
[17:38:08.418]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:08.418]    - tweaked: FALSE
[17:38:08.418]    - call: NULL
[17:38:08.419] plan(): nbrOfWorkers() = 1
[17:38:08.421] plan(): Setting new future strategy stack:
[17:38:08.422] List of future strategies:
[17:38:08.422] 1. multicore:
[17:38:08.422]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:08.422]    - tweaked: FALSE
[17:38:08.422]    - call: plan(strategy)
[17:38:08.427] plan(): nbrOfWorkers() = 2
[17:38:08.417] MulticoreFuture:
[17:38:08.417] Label: ‘future_vapply-2’
[17:38:08.417] Expression:
[17:38:08.417] {
[17:38:08.417]     do.call(function(...) {
[17:38:08.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.417]             on.exit(options(oopts), add = TRUE)
[17:38:08.417]         }
[17:38:08.417]         {
[17:38:08.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.417]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.417]             })
[17:38:08.417]         }
[17:38:08.417]     }, args = future.call.arguments)
[17:38:08.417] }
[17:38:08.417] Lazy evaluation: FALSE
[17:38:08.417] Asynchronous evaluation: TRUE
[17:38:08.417] Local evaluation: TRUE
[17:38:08.417] Environment: R_GlobalEnv
[17:38:08.417] Capture standard output: TRUE
[17:38:08.417] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:08.417] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:08.417] Packages: 1 packages (‘future.apply’)
[17:38:08.417] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:08.417] Resolved: TRUE
[17:38:08.417] Value: <not collected>
[17:38:08.417] Conditions captured: <none>
[17:38:08.417] Early signaling: FALSE
[17:38:08.417] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:08.417] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.428] Chunk #2 of 2 ... DONE
[17:38:08.428] Launching 2 futures (chunks) ... DONE
[17:38:08.428] Resolving 2 futures (chunks) ...
[17:38:08.428] resolve() on list ...
[17:38:08.429]  recursive: 0
[17:38:08.429]  length: 2
[17:38:08.429] 
[17:38:08.429] Future #1
[17:38:08.429] result() for MulticoreFuture ...
[17:38:08.430] result() for MulticoreFuture ...
[17:38:08.430] result() for MulticoreFuture ... done
[17:38:08.431] result() for MulticoreFuture ... done
[17:38:08.431] result() for MulticoreFuture ...
[17:38:08.431] result() for MulticoreFuture ... done
[17:38:08.431] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:08.431] - nx: 2
[17:38:08.431] - relay: TRUE
[17:38:08.431] - stdout: TRUE
[17:38:08.432] - signal: TRUE
[17:38:08.432] - resignal: FALSE
[17:38:08.432] - force: TRUE
[17:38:08.432] - relayed: [n=2] FALSE, FALSE
[17:38:08.432] - queued futures: [n=2] FALSE, FALSE
[17:38:08.432]  - until=1
[17:38:08.432]  - relaying element #1
[17:38:08.433] result() for MulticoreFuture ...
[17:38:08.433] result() for MulticoreFuture ... done
[17:38:08.433] result() for MulticoreFuture ...
[17:38:08.433] result() for MulticoreFuture ... done
[17:38:08.433] result() for MulticoreFuture ...
[17:38:08.433] result() for MulticoreFuture ... done
[17:38:08.434] result() for MulticoreFuture ...
[17:38:08.434] result() for MulticoreFuture ... done
[17:38:08.434] - relayed: [n=2] TRUE, FALSE
[17:38:08.434] - queued futures: [n=2] TRUE, FALSE
[17:38:08.434] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:08.434]  length: 1 (resolved future 1)
[17:38:08.435] Future #2
[17:38:08.435] result() for MulticoreFuture ...
[17:38:08.436] result() for MulticoreFuture ...
[17:38:08.436] result() for MulticoreFuture ... done
[17:38:08.436] result() for MulticoreFuture ... done
[17:38:08.436] result() for MulticoreFuture ...
[17:38:08.436] result() for MulticoreFuture ... done
[17:38:08.436] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:08.436] - nx: 2
[17:38:08.437] - relay: TRUE
[17:38:08.437] - stdout: TRUE
[17:38:08.437] - signal: TRUE
[17:38:08.437] - resignal: FALSE
[17:38:08.437] - force: TRUE
[17:38:08.437] - relayed: [n=2] TRUE, FALSE
[17:38:08.437] - queued futures: [n=2] TRUE, FALSE
[17:38:08.437]  - until=2
[17:38:08.438]  - relaying element #2
[17:38:08.438] result() for MulticoreFuture ...
[17:38:08.438] result() for MulticoreFuture ... done
[17:38:08.438] result() for MulticoreFuture ...
[17:38:08.438] result() for MulticoreFuture ... done
[17:38:08.438] result() for MulticoreFuture ...
[17:38:08.438] result() for MulticoreFuture ... done
[17:38:08.438] result() for MulticoreFuture ...
[17:38:08.439] result() for MulticoreFuture ... done
[17:38:08.439] - relayed: [n=2] TRUE, TRUE
[17:38:08.439] - queued futures: [n=2] TRUE, TRUE
[17:38:08.439] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:08.439]  length: 0 (resolved future 2)
[17:38:08.439] Relaying remaining futures
[17:38:08.439] signalConditionsASAP(NULL, pos=0) ...
[17:38:08.439] - nx: 2
[17:38:08.440] - relay: TRUE
[17:38:08.440] - stdout: TRUE
[17:38:08.440] - signal: TRUE
[17:38:08.440] - resignal: FALSE
[17:38:08.440] - force: TRUE
[17:38:08.440] - relayed: [n=2] TRUE, TRUE
[17:38:08.440] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:08.440] - relayed: [n=2] TRUE, TRUE
[17:38:08.440] - queued futures: [n=2] TRUE, TRUE
[17:38:08.441] signalConditionsASAP(NULL, pos=0) ... done
[17:38:08.441] resolve() on list ... DONE
[17:38:08.441] result() for MulticoreFuture ...
[17:38:08.441] result() for MulticoreFuture ... done
[17:38:08.441] result() for MulticoreFuture ...
[17:38:08.441] result() for MulticoreFuture ... done
[17:38:08.441] result() for MulticoreFuture ...
[17:38:08.441] result() for MulticoreFuture ... done
[17:38:08.441] result() for MulticoreFuture ...
[17:38:08.442] result() for MulticoreFuture ... done
[17:38:08.442]  - Number of value chunks collected: 2
[17:38:08.442] Resolving 2 futures (chunks) ... DONE
[17:38:08.442] Reducing values from 2 chunks ...
[17:38:08.442]  - Number of values collected after concatenation: 10
[17:38:08.442]  - Number of values expected: 10
[17:38:08.442] Reducing values from 2 chunks ... DONE
[17:38:08.442] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[17:38:08.445] future_lapply() ...
[17:38:08.455] Number of chunks: 2
[17:38:08.455] getGlobalsAndPackagesXApply() ...
[17:38:08.456]  - future.globals: TRUE
[17:38:08.456] getGlobalsAndPackages() ...
[17:38:08.456] Searching for globals...
[17:38:08.460] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[17:38:08.461] Searching for globals ... DONE
[17:38:08.461] Resolving globals: FALSE
[17:38:08.462] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[17:38:08.462] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:08.462] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:08.462] - packages: [2] ‘stats’, ‘future.apply’
[17:38:08.462] getGlobalsAndPackages() ... DONE
[17:38:08.462]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:08.463]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:38:08.463] Finding globals ... DONE
[17:38:08.463]  - use_args: TRUE
[17:38:08.463]  - Getting '...' globals ...
[17:38:08.463] resolve() on list ...
[17:38:08.463]  recursive: 0
[17:38:08.463]  length: 1
[17:38:08.464]  elements: ‘...’
[17:38:08.464]  length: 0 (resolved future 1)
[17:38:08.464] resolve() on list ... DONE
[17:38:08.464]    - '...' content: [n=0] 
[17:38:08.464] List of 1
[17:38:08.464]  $ ...: list()
[17:38:08.464]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.464]  - attr(*, "where")=List of 1
[17:38:08.464]   ..$ ...:<environment: 0x560801adad68> 
[17:38:08.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.464]  - attr(*, "resolved")= logi TRUE
[17:38:08.464]  - attr(*, "total_size")= num NA
[17:38:08.467]  - Getting '...' globals ... DONE
[17:38:08.467] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:08.467] List of 8
[17:38:08.467]  $ ...future.FUN:function (x, ...)  
[17:38:08.467]  $ x_FUN        :function (x, ...)  
[17:38:08.467]  $ times        : int 5
[17:38:08.467]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.467]  $ stop_if_not  :function (...)  
[17:38:08.467]  $ dim          : NULL
[17:38:08.467]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:08.467]  $ ...          : list()
[17:38:08.467]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.467]  - attr(*, "where")=List of 8
[17:38:08.467]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:08.467]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:08.467]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:08.467]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:08.467]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:08.467]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:08.467]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:08.467]   ..$ ...          :<environment: 0x560801adad68> 
[17:38:08.467]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.467]  - attr(*, "resolved")= logi FALSE
[17:38:08.467]  - attr(*, "total_size")= num 95528
[17:38:08.472] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:38:08.472] getGlobalsAndPackagesXApply() ... DONE
[17:38:08.473] Number of futures (= number of chunks): 2
[17:38:08.473] Launching 2 futures (chunks) ...
[17:38:08.473] Chunk #1 of 2 ...
[17:38:08.473]  - Finding globals in 'X' for chunk #1 ...
[17:38:08.473] getGlobalsAndPackages() ...
[17:38:08.473] Searching for globals...
[17:38:08.476] 
[17:38:08.476] Searching for globals ... DONE
[17:38:08.476] - globals: [0] <none>
[17:38:08.476] getGlobalsAndPackages() ... DONE
[17:38:08.476]    + additional globals found: [n=0] 
[17:38:08.476]    + additional namespaces needed: [n=0] 
[17:38:08.476]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:08.476]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:08.477]  - seeds: <none>
[17:38:08.477]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.477] getGlobalsAndPackages() ...
[17:38:08.477] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.477] Resolving globals: FALSE
[17:38:08.477] Tweak future expression to call with '...' arguments ...
[17:38:08.477] {
[17:38:08.477]     do.call(function(...) {
[17:38:08.477]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.477]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.477]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.477]             on.exit(options(oopts), add = TRUE)
[17:38:08.477]         }
[17:38:08.477]         {
[17:38:08.477]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.477]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.477]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.477]             })
[17:38:08.477]         }
[17:38:08.477]     }, args = future.call.arguments)
[17:38:08.477] }
[17:38:08.478] Tweak future expression to call with '...' arguments ... DONE
[17:38:08.478] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.478] - packages: [2] ‘stats’, ‘future.apply’
[17:38:08.478] getGlobalsAndPackages() ... DONE
[17:38:08.479] run() for ‘Future’ ...
[17:38:08.479] - state: ‘created’
[17:38:08.479] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:08.483] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.483] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:08.483]   - Field: ‘label’
[17:38:08.483]   - Field: ‘local’
[17:38:08.484]   - Field: ‘owner’
[17:38:08.484]   - Field: ‘envir’
[17:38:08.484]   - Field: ‘workers’
[17:38:08.484]   - Field: ‘packages’
[17:38:08.484]   - Field: ‘gc’
[17:38:08.484]   - Field: ‘job’
[17:38:08.484]   - Field: ‘conditions’
[17:38:08.484]   - Field: ‘expr’
[17:38:08.484]   - Field: ‘uuid’
[17:38:08.485]   - Field: ‘seed’
[17:38:08.485]   - Field: ‘version’
[17:38:08.485]   - Field: ‘result’
[17:38:08.485]   - Field: ‘asynchronous’
[17:38:08.485]   - Field: ‘calls’
[17:38:08.485]   - Field: ‘globals’
[17:38:08.485]   - Field: ‘stdout’
[17:38:08.485]   - Field: ‘earlySignal’
[17:38:08.485]   - Field: ‘lazy’
[17:38:08.485]   - Field: ‘state’
[17:38:08.485] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:08.486] - Launch lazy future ...
[17:38:08.486] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:38:08.486] Packages needed by future strategies (n = 0): <none>
[17:38:08.487] {
[17:38:08.487]     {
[17:38:08.487]         {
[17:38:08.487]             ...future.startTime <- base::Sys.time()
[17:38:08.487]             {
[17:38:08.487]                 {
[17:38:08.487]                   {
[17:38:08.487]                     {
[17:38:08.487]                       {
[17:38:08.487]                         base::local({
[17:38:08.487]                           has_future <- base::requireNamespace("future", 
[17:38:08.487]                             quietly = TRUE)
[17:38:08.487]                           if (has_future) {
[17:38:08.487]                             ns <- base::getNamespace("future")
[17:38:08.487]                             version <- ns[[".package"]][["version"]]
[17:38:08.487]                             if (is.null(version)) 
[17:38:08.487]                               version <- utils::packageVersion("future")
[17:38:08.487]                           }
[17:38:08.487]                           else {
[17:38:08.487]                             version <- NULL
[17:38:08.487]                           }
[17:38:08.487]                           if (!has_future || version < "1.8.0") {
[17:38:08.487]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:08.487]                               "", base::R.version$version.string), 
[17:38:08.487]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:08.487]                                 base::R.version$platform, 8 * 
[17:38:08.487]                                   base::.Machine$sizeof.pointer), 
[17:38:08.487]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:08.487]                                 "release", "version")], collapse = " "), 
[17:38:08.487]                               hostname = base::Sys.info()[["nodename"]])
[17:38:08.487]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:08.487]                               info)
[17:38:08.487]                             info <- base::paste(info, collapse = "; ")
[17:38:08.487]                             if (!has_future) {
[17:38:08.487]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:08.487]                                 info)
[17:38:08.487]                             }
[17:38:08.487]                             else {
[17:38:08.487]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:08.487]                                 info, version)
[17:38:08.487]                             }
[17:38:08.487]                             base::stop(msg)
[17:38:08.487]                           }
[17:38:08.487]                         })
[17:38:08.487]                       }
[17:38:08.487]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:08.487]                       base::options(mc.cores = 1L)
[17:38:08.487]                     }
[17:38:08.487]                     base::local({
[17:38:08.487]                       for (pkg in c("stats", "future.apply")) {
[17:38:08.487]                         base::loadNamespace(pkg)
[17:38:08.487]                         base::library(pkg, character.only = TRUE)
[17:38:08.487]                       }
[17:38:08.487]                     })
[17:38:08.487]                   }
[17:38:08.487]                   ...future.strategy.old <- future::plan("list")
[17:38:08.487]                   options(future.plan = NULL)
[17:38:08.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:08.487]                 }
[17:38:08.487]                 ...future.workdir <- getwd()
[17:38:08.487]             }
[17:38:08.487]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:08.487]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:08.487]         }
[17:38:08.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:08.487]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:08.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:08.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:08.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:08.487]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:08.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:08.487]             base::names(...future.oldOptions))
[17:38:08.487]     }
[17:38:08.487]     if (FALSE) {
[17:38:08.487]     }
[17:38:08.487]     else {
[17:38:08.487]         if (TRUE) {
[17:38:08.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:08.487]                 open = "w")
[17:38:08.487]         }
[17:38:08.487]         else {
[17:38:08.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:08.487]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:08.487]         }
[17:38:08.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:08.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:08.487]             base::sink(type = "output", split = FALSE)
[17:38:08.487]             base::close(...future.stdout)
[17:38:08.487]         }, add = TRUE)
[17:38:08.487]     }
[17:38:08.487]     ...future.frame <- base::sys.nframe()
[17:38:08.487]     ...future.conditions <- base::list()
[17:38:08.487]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:08.487]     if (FALSE) {
[17:38:08.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:08.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:08.487]     }
[17:38:08.487]     ...future.result <- base::tryCatch({
[17:38:08.487]         base::withCallingHandlers({
[17:38:08.487]             ...future.value <- base::withVisible(base::local({
[17:38:08.487]                 withCallingHandlers({
[17:38:08.487]                   {
[17:38:08.487]                     do.call(function(...) {
[17:38:08.487]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.487]                       if (!identical(...future.globals.maxSize.org, 
[17:38:08.487]                         ...future.globals.maxSize)) {
[17:38:08.487]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.487]                         on.exit(options(oopts), add = TRUE)
[17:38:08.487]                       }
[17:38:08.487]                       {
[17:38:08.487]                         lapply(seq_along(...future.elements_ii), 
[17:38:08.487]                           FUN = function(jj) {
[17:38:08.487]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.487]                             ...future.FUN(...future.X_jj, ...)
[17:38:08.487]                           })
[17:38:08.487]                       }
[17:38:08.487]                     }, args = future.call.arguments)
[17:38:08.487]                   }
[17:38:08.487]                 }, immediateCondition = function(cond) {
[17:38:08.487]                   save_rds <- function (object, pathname, ...) 
[17:38:08.487]                   {
[17:38:08.487]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:08.487]                     if (file_test("-f", pathname_tmp)) {
[17:38:08.487]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.487]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:08.487]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.487]                         fi_tmp[["mtime"]])
[17:38:08.487]                     }
[17:38:08.487]                     tryCatch({
[17:38:08.487]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:08.487]                     }, error = function(ex) {
[17:38:08.487]                       msg <- conditionMessage(ex)
[17:38:08.487]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.487]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:08.487]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.487]                         fi_tmp[["mtime"]], msg)
[17:38:08.487]                       ex$message <- msg
[17:38:08.487]                       stop(ex)
[17:38:08.487]                     })
[17:38:08.487]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:08.487]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:08.487]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:08.487]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.487]                       fi <- file.info(pathname)
[17:38:08.487]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:08.487]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.487]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:08.487]                         fi[["size"]], fi[["mtime"]])
[17:38:08.487]                       stop(msg)
[17:38:08.487]                     }
[17:38:08.487]                     invisible(pathname)
[17:38:08.487]                   }
[17:38:08.487]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:08.487]                     rootPath = tempdir()) 
[17:38:08.487]                   {
[17:38:08.487]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:08.487]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:08.487]                       tmpdir = path, fileext = ".rds")
[17:38:08.487]                     save_rds(obj, file)
[17:38:08.487]                   }
[17:38:08.487]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:08.487]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.487]                   {
[17:38:08.487]                     inherits <- base::inherits
[17:38:08.487]                     invokeRestart <- base::invokeRestart
[17:38:08.487]                     is.null <- base::is.null
[17:38:08.487]                     muffled <- FALSE
[17:38:08.487]                     if (inherits(cond, "message")) {
[17:38:08.487]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:08.487]                       if (muffled) 
[17:38:08.487]                         invokeRestart("muffleMessage")
[17:38:08.487]                     }
[17:38:08.487]                     else if (inherits(cond, "warning")) {
[17:38:08.487]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:08.487]                       if (muffled) 
[17:38:08.487]                         invokeRestart("muffleWarning")
[17:38:08.487]                     }
[17:38:08.487]                     else if (inherits(cond, "condition")) {
[17:38:08.487]                       if (!is.null(pattern)) {
[17:38:08.487]                         computeRestarts <- base::computeRestarts
[17:38:08.487]                         grepl <- base::grepl
[17:38:08.487]                         restarts <- computeRestarts(cond)
[17:38:08.487]                         for (restart in restarts) {
[17:38:08.487]                           name <- restart$name
[17:38:08.487]                           if (is.null(name)) 
[17:38:08.487]                             next
[17:38:08.487]                           if (!grepl(pattern, name)) 
[17:38:08.487]                             next
[17:38:08.487]                           invokeRestart(restart)
[17:38:08.487]                           muffled <- TRUE
[17:38:08.487]                           break
[17:38:08.487]                         }
[17:38:08.487]                       }
[17:38:08.487]                     }
[17:38:08.487]                     invisible(muffled)
[17:38:08.487]                   }
[17:38:08.487]                   muffleCondition(cond)
[17:38:08.487]                 })
[17:38:08.487]             }))
[17:38:08.487]             future::FutureResult(value = ...future.value$value, 
[17:38:08.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.487]                   ...future.rng), globalenv = if (FALSE) 
[17:38:08.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:08.487]                     ...future.globalenv.names))
[17:38:08.487]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:08.487]         }, condition = base::local({
[17:38:08.487]             c <- base::c
[17:38:08.487]             inherits <- base::inherits
[17:38:08.487]             invokeRestart <- base::invokeRestart
[17:38:08.487]             length <- base::length
[17:38:08.487]             list <- base::list
[17:38:08.487]             seq.int <- base::seq.int
[17:38:08.487]             signalCondition <- base::signalCondition
[17:38:08.487]             sys.calls <- base::sys.calls
[17:38:08.487]             `[[` <- base::`[[`
[17:38:08.487]             `+` <- base::`+`
[17:38:08.487]             `<<-` <- base::`<<-`
[17:38:08.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:08.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:08.487]                   3L)]
[17:38:08.487]             }
[17:38:08.487]             function(cond) {
[17:38:08.487]                 is_error <- inherits(cond, "error")
[17:38:08.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:08.487]                   NULL)
[17:38:08.487]                 if (is_error) {
[17:38:08.487]                   sessionInformation <- function() {
[17:38:08.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:08.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:08.487]                       search = base::search(), system = base::Sys.info())
[17:38:08.487]                   }
[17:38:08.487]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:08.487]                     cond$call), session = sessionInformation(), 
[17:38:08.487]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:08.487]                   signalCondition(cond)
[17:38:08.487]                 }
[17:38:08.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:08.487]                 "immediateCondition"))) {
[17:38:08.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:08.487]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:08.487]                   if (TRUE && !signal) {
[17:38:08.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.487]                     {
[17:38:08.487]                       inherits <- base::inherits
[17:38:08.487]                       invokeRestart <- base::invokeRestart
[17:38:08.487]                       is.null <- base::is.null
[17:38:08.487]                       muffled <- FALSE
[17:38:08.487]                       if (inherits(cond, "message")) {
[17:38:08.487]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.487]                         if (muffled) 
[17:38:08.487]                           invokeRestart("muffleMessage")
[17:38:08.487]                       }
[17:38:08.487]                       else if (inherits(cond, "warning")) {
[17:38:08.487]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.487]                         if (muffled) 
[17:38:08.487]                           invokeRestart("muffleWarning")
[17:38:08.487]                       }
[17:38:08.487]                       else if (inherits(cond, "condition")) {
[17:38:08.487]                         if (!is.null(pattern)) {
[17:38:08.487]                           computeRestarts <- base::computeRestarts
[17:38:08.487]                           grepl <- base::grepl
[17:38:08.487]                           restarts <- computeRestarts(cond)
[17:38:08.487]                           for (restart in restarts) {
[17:38:08.487]                             name <- restart$name
[17:38:08.487]                             if (is.null(name)) 
[17:38:08.487]                               next
[17:38:08.487]                             if (!grepl(pattern, name)) 
[17:38:08.487]                               next
[17:38:08.487]                             invokeRestart(restart)
[17:38:08.487]                             muffled <- TRUE
[17:38:08.487]                             break
[17:38:08.487]                           }
[17:38:08.487]                         }
[17:38:08.487]                       }
[17:38:08.487]                       invisible(muffled)
[17:38:08.487]                     }
[17:38:08.487]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.487]                   }
[17:38:08.487]                 }
[17:38:08.487]                 else {
[17:38:08.487]                   if (TRUE) {
[17:38:08.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.487]                     {
[17:38:08.487]                       inherits <- base::inherits
[17:38:08.487]                       invokeRestart <- base::invokeRestart
[17:38:08.487]                       is.null <- base::is.null
[17:38:08.487]                       muffled <- FALSE
[17:38:08.487]                       if (inherits(cond, "message")) {
[17:38:08.487]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.487]                         if (muffled) 
[17:38:08.487]                           invokeRestart("muffleMessage")
[17:38:08.487]                       }
[17:38:08.487]                       else if (inherits(cond, "warning")) {
[17:38:08.487]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.487]                         if (muffled) 
[17:38:08.487]                           invokeRestart("muffleWarning")
[17:38:08.487]                       }
[17:38:08.487]                       else if (inherits(cond, "condition")) {
[17:38:08.487]                         if (!is.null(pattern)) {
[17:38:08.487]                           computeRestarts <- base::computeRestarts
[17:38:08.487]                           grepl <- base::grepl
[17:38:08.487]                           restarts <- computeRestarts(cond)
[17:38:08.487]                           for (restart in restarts) {
[17:38:08.487]                             name <- restart$name
[17:38:08.487]                             if (is.null(name)) 
[17:38:08.487]                               next
[17:38:08.487]                             if (!grepl(pattern, name)) 
[17:38:08.487]                               next
[17:38:08.487]                             invokeRestart(restart)
[17:38:08.487]                             muffled <- TRUE
[17:38:08.487]                             break
[17:38:08.487]                           }
[17:38:08.487]                         }
[17:38:08.487]                       }
[17:38:08.487]                       invisible(muffled)
[17:38:08.487]                     }
[17:38:08.487]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.487]                   }
[17:38:08.487]                 }
[17:38:08.487]             }
[17:38:08.487]         }))
[17:38:08.487]     }, error = function(ex) {
[17:38:08.487]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:08.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.487]                 ...future.rng), started = ...future.startTime, 
[17:38:08.487]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:08.487]             version = "1.8"), class = "FutureResult")
[17:38:08.487]     }, finally = {
[17:38:08.487]         if (!identical(...future.workdir, getwd())) 
[17:38:08.487]             setwd(...future.workdir)
[17:38:08.487]         {
[17:38:08.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:08.487]                 ...future.oldOptions$nwarnings <- NULL
[17:38:08.487]             }
[17:38:08.487]             base::options(...future.oldOptions)
[17:38:08.487]             if (.Platform$OS.type == "windows") {
[17:38:08.487]                 old_names <- names(...future.oldEnvVars)
[17:38:08.487]                 envs <- base::Sys.getenv()
[17:38:08.487]                 names <- names(envs)
[17:38:08.487]                 common <- intersect(names, old_names)
[17:38:08.487]                 added <- setdiff(names, old_names)
[17:38:08.487]                 removed <- setdiff(old_names, names)
[17:38:08.487]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:08.487]                   envs[common]]
[17:38:08.487]                 NAMES <- toupper(changed)
[17:38:08.487]                 args <- list()
[17:38:08.487]                 for (kk in seq_along(NAMES)) {
[17:38:08.487]                   name <- changed[[kk]]
[17:38:08.487]                   NAME <- NAMES[[kk]]
[17:38:08.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.487]                     next
[17:38:08.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.487]                 }
[17:38:08.487]                 NAMES <- toupper(added)
[17:38:08.487]                 for (kk in seq_along(NAMES)) {
[17:38:08.487]                   name <- added[[kk]]
[17:38:08.487]                   NAME <- NAMES[[kk]]
[17:38:08.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.487]                     next
[17:38:08.487]                   args[[name]] <- ""
[17:38:08.487]                 }
[17:38:08.487]                 NAMES <- toupper(removed)
[17:38:08.487]                 for (kk in seq_along(NAMES)) {
[17:38:08.487]                   name <- removed[[kk]]
[17:38:08.487]                   NAME <- NAMES[[kk]]
[17:38:08.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.487]                     next
[17:38:08.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.487]                 }
[17:38:08.487]                 if (length(args) > 0) 
[17:38:08.487]                   base::do.call(base::Sys.setenv, args = args)
[17:38:08.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:08.487]             }
[17:38:08.487]             else {
[17:38:08.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:08.487]             }
[17:38:08.487]             {
[17:38:08.487]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:08.487]                   0L) {
[17:38:08.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:08.487]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:08.487]                   base::options(opts)
[17:38:08.487]                 }
[17:38:08.487]                 {
[17:38:08.487]                   {
[17:38:08.487]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:08.487]                     NULL
[17:38:08.487]                   }
[17:38:08.487]                   options(future.plan = NULL)
[17:38:08.487]                   if (is.na(NA_character_)) 
[17:38:08.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:08.487]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:08.487]                     .init = FALSE)
[17:38:08.487]                 }
[17:38:08.487]             }
[17:38:08.487]         }
[17:38:08.487]     })
[17:38:08.487]     if (TRUE) {
[17:38:08.487]         base::sink(type = "output", split = FALSE)
[17:38:08.487]         if (TRUE) {
[17:38:08.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:08.487]         }
[17:38:08.487]         else {
[17:38:08.487]             ...future.result["stdout"] <- base::list(NULL)
[17:38:08.487]         }
[17:38:08.487]         base::close(...future.stdout)
[17:38:08.487]         ...future.stdout <- NULL
[17:38:08.487]     }
[17:38:08.487]     ...future.result$conditions <- ...future.conditions
[17:38:08.487]     ...future.result$finished <- base::Sys.time()
[17:38:08.487]     ...future.result
[17:38:08.487] }
[17:38:08.489] assign_globals() ...
[17:38:08.489] List of 11
[17:38:08.489]  $ ...future.FUN            :function (x, ...)  
[17:38:08.489]  $ x_FUN                    :function (x, ...)  
[17:38:08.489]  $ times                    : int 5
[17:38:08.489]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.489]  $ stop_if_not              :function (...)  
[17:38:08.489]  $ dim                      : NULL
[17:38:08.489]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:08.489]  $ future.call.arguments    : list()
[17:38:08.489]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.489]  $ ...future.elements_ii    :List of 1
[17:38:08.489]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:38:08.489]  $ ...future.seeds_ii       : NULL
[17:38:08.489]  $ ...future.globals.maxSize: NULL
[17:38:08.489]  - attr(*, "where")=List of 11
[17:38:08.489]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:08.489]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:08.489]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:08.489]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:08.489]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:08.489]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:08.489]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:08.489]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:08.489]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:08.489]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:08.489]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:08.489]  - attr(*, "resolved")= logi FALSE
[17:38:08.489]  - attr(*, "total_size")= num 95528
[17:38:08.489]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.489]  - attr(*, "already-done")= logi TRUE
[17:38:08.497] - copied ‘...future.FUN’ to environment
[17:38:08.497] - copied ‘x_FUN’ to environment
[17:38:08.497] - copied ‘times’ to environment
[17:38:08.497] - copied ‘stopf’ to environment
[17:38:08.497] - copied ‘stop_if_not’ to environment
[17:38:08.497] - copied ‘dim’ to environment
[17:38:08.497] - copied ‘valid_types’ to environment
[17:38:08.497] - copied ‘future.call.arguments’ to environment
[17:38:08.498] - copied ‘...future.elements_ii’ to environment
[17:38:08.498] - copied ‘...future.seeds_ii’ to environment
[17:38:08.498] - copied ‘...future.globals.maxSize’ to environment
[17:38:08.498] assign_globals() ... done
[17:38:08.498] requestCore(): workers = 2
[17:38:08.500] MulticoreFuture started
[17:38:08.501] - Launch lazy future ... done
[17:38:08.501] run() for ‘MulticoreFuture’ ... done
[17:38:08.501] Created future:
[17:38:08.502] plan(): Setting new future strategy stack:
[17:38:08.502] List of future strategies:
[17:38:08.502] 1. sequential:
[17:38:08.502]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:08.502]    - tweaked: FALSE
[17:38:08.502]    - call: NULL
[17:38:08.503] plan(): nbrOfWorkers() = 1
[17:38:08.506] plan(): Setting new future strategy stack:
[17:38:08.506] List of future strategies:
[17:38:08.506] 1. multicore:
[17:38:08.506]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:08.506]    - tweaked: FALSE
[17:38:08.506]    - call: plan(strategy)
[17:38:08.501] MulticoreFuture:
[17:38:08.501] Label: ‘future_vapply-1’
[17:38:08.501] Expression:
[17:38:08.501] {
[17:38:08.501]     do.call(function(...) {
[17:38:08.501]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.501]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.501]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.501]             on.exit(options(oopts), add = TRUE)
[17:38:08.501]         }
[17:38:08.501]         {
[17:38:08.501]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.501]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.501]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.501]             })
[17:38:08.501]         }
[17:38:08.501]     }, args = future.call.arguments)
[17:38:08.501] }
[17:38:08.501] Lazy evaluation: FALSE
[17:38:08.501] Asynchronous evaluation: TRUE
[17:38:08.501] Local evaluation: TRUE
[17:38:08.501] Environment: R_GlobalEnv
[17:38:08.501] Capture standard output: TRUE
[17:38:08.501] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:08.501] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:08.501] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:38:08.501] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:08.501] Resolved: FALSE
[17:38:08.501] Value: <not collected>
[17:38:08.501] Conditions captured: <none>
[17:38:08.501] Early signaling: FALSE
[17:38:08.501] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:08.501] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.514] Chunk #1 of 2 ... DONE
[17:38:08.515] Chunk #2 of 2 ...
[17:38:08.515]  - Finding globals in 'X' for chunk #2 ...
[17:38:08.515] getGlobalsAndPackages() ...
[17:38:08.515] Searching for globals...
[17:38:08.516] 
[17:38:08.516] Searching for globals ... DONE
[17:38:08.516] - globals: [0] <none>
[17:38:08.516] getGlobalsAndPackages() ... DONE
[17:38:08.516] plan(): nbrOfWorkers() = 2
[17:38:08.516]    + additional globals found: [n=0] 
[17:38:08.519]    + additional namespaces needed: [n=0] 
[17:38:08.519]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:08.519]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:08.520]  - seeds: <none>
[17:38:08.520]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.520] getGlobalsAndPackages() ...
[17:38:08.520] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.521] Resolving globals: FALSE
[17:38:08.521] Tweak future expression to call with '...' arguments ...
[17:38:08.521] {
[17:38:08.521]     do.call(function(...) {
[17:38:08.521]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.521]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.521]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.521]             on.exit(options(oopts), add = TRUE)
[17:38:08.521]         }
[17:38:08.521]         {
[17:38:08.521]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.521]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.521]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.521]             })
[17:38:08.521]         }
[17:38:08.521]     }, args = future.call.arguments)
[17:38:08.521] }
[17:38:08.522] Tweak future expression to call with '...' arguments ... DONE
[17:38:08.524] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.524] - packages: [2] ‘stats’, ‘future.apply’
[17:38:08.524] getGlobalsAndPackages() ... DONE
[17:38:08.525] run() for ‘Future’ ...
[17:38:08.525] - state: ‘created’
[17:38:08.526] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:08.532] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.532] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:08.532]   - Field: ‘label’
[17:38:08.533]   - Field: ‘local’
[17:38:08.533]   - Field: ‘owner’
[17:38:08.533]   - Field: ‘envir’
[17:38:08.533]   - Field: ‘workers’
[17:38:08.533]   - Field: ‘packages’
[17:38:08.534]   - Field: ‘gc’
[17:38:08.534]   - Field: ‘job’
[17:38:08.534]   - Field: ‘conditions’
[17:38:08.534]   - Field: ‘expr’
[17:38:08.534]   - Field: ‘uuid’
[17:38:08.535]   - Field: ‘seed’
[17:38:08.535]   - Field: ‘version’
[17:38:08.535]   - Field: ‘result’
[17:38:08.535]   - Field: ‘asynchronous’
[17:38:08.535]   - Field: ‘calls’
[17:38:08.535]   - Field: ‘globals’
[17:38:08.535]   - Field: ‘stdout’
[17:38:08.535]   - Field: ‘earlySignal’
[17:38:08.536]   - Field: ‘lazy’
[17:38:08.536]   - Field: ‘state’
[17:38:08.536] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:08.536] - Launch lazy future ...
[17:38:08.537] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:38:08.537] Packages needed by future strategies (n = 0): <none>
[17:38:08.538] {
[17:38:08.538]     {
[17:38:08.538]         {
[17:38:08.538]             ...future.startTime <- base::Sys.time()
[17:38:08.538]             {
[17:38:08.538]                 {
[17:38:08.538]                   {
[17:38:08.538]                     {
[17:38:08.538]                       {
[17:38:08.538]                         base::local({
[17:38:08.538]                           has_future <- base::requireNamespace("future", 
[17:38:08.538]                             quietly = TRUE)
[17:38:08.538]                           if (has_future) {
[17:38:08.538]                             ns <- base::getNamespace("future")
[17:38:08.538]                             version <- ns[[".package"]][["version"]]
[17:38:08.538]                             if (is.null(version)) 
[17:38:08.538]                               version <- utils::packageVersion("future")
[17:38:08.538]                           }
[17:38:08.538]                           else {
[17:38:08.538]                             version <- NULL
[17:38:08.538]                           }
[17:38:08.538]                           if (!has_future || version < "1.8.0") {
[17:38:08.538]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:08.538]                               "", base::R.version$version.string), 
[17:38:08.538]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:08.538]                                 base::R.version$platform, 8 * 
[17:38:08.538]                                   base::.Machine$sizeof.pointer), 
[17:38:08.538]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:08.538]                                 "release", "version")], collapse = " "), 
[17:38:08.538]                               hostname = base::Sys.info()[["nodename"]])
[17:38:08.538]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:08.538]                               info)
[17:38:08.538]                             info <- base::paste(info, collapse = "; ")
[17:38:08.538]                             if (!has_future) {
[17:38:08.538]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:08.538]                                 info)
[17:38:08.538]                             }
[17:38:08.538]                             else {
[17:38:08.538]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:08.538]                                 info, version)
[17:38:08.538]                             }
[17:38:08.538]                             base::stop(msg)
[17:38:08.538]                           }
[17:38:08.538]                         })
[17:38:08.538]                       }
[17:38:08.538]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:08.538]                       base::options(mc.cores = 1L)
[17:38:08.538]                     }
[17:38:08.538]                     base::local({
[17:38:08.538]                       for (pkg in c("stats", "future.apply")) {
[17:38:08.538]                         base::loadNamespace(pkg)
[17:38:08.538]                         base::library(pkg, character.only = TRUE)
[17:38:08.538]                       }
[17:38:08.538]                     })
[17:38:08.538]                   }
[17:38:08.538]                   ...future.strategy.old <- future::plan("list")
[17:38:08.538]                   options(future.plan = NULL)
[17:38:08.538]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.538]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:08.538]                 }
[17:38:08.538]                 ...future.workdir <- getwd()
[17:38:08.538]             }
[17:38:08.538]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:08.538]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:08.538]         }
[17:38:08.538]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:08.538]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:08.538]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:08.538]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:08.538]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:08.538]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:08.538]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:08.538]             base::names(...future.oldOptions))
[17:38:08.538]     }
[17:38:08.538]     if (FALSE) {
[17:38:08.538]     }
[17:38:08.538]     else {
[17:38:08.538]         if (TRUE) {
[17:38:08.538]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:08.538]                 open = "w")
[17:38:08.538]         }
[17:38:08.538]         else {
[17:38:08.538]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:08.538]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:08.538]         }
[17:38:08.538]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:08.538]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:08.538]             base::sink(type = "output", split = FALSE)
[17:38:08.538]             base::close(...future.stdout)
[17:38:08.538]         }, add = TRUE)
[17:38:08.538]     }
[17:38:08.538]     ...future.frame <- base::sys.nframe()
[17:38:08.538]     ...future.conditions <- base::list()
[17:38:08.538]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:08.538]     if (FALSE) {
[17:38:08.538]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:08.538]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:08.538]     }
[17:38:08.538]     ...future.result <- base::tryCatch({
[17:38:08.538]         base::withCallingHandlers({
[17:38:08.538]             ...future.value <- base::withVisible(base::local({
[17:38:08.538]                 withCallingHandlers({
[17:38:08.538]                   {
[17:38:08.538]                     do.call(function(...) {
[17:38:08.538]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.538]                       if (!identical(...future.globals.maxSize.org, 
[17:38:08.538]                         ...future.globals.maxSize)) {
[17:38:08.538]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.538]                         on.exit(options(oopts), add = TRUE)
[17:38:08.538]                       }
[17:38:08.538]                       {
[17:38:08.538]                         lapply(seq_along(...future.elements_ii), 
[17:38:08.538]                           FUN = function(jj) {
[17:38:08.538]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.538]                             ...future.FUN(...future.X_jj, ...)
[17:38:08.538]                           })
[17:38:08.538]                       }
[17:38:08.538]                     }, args = future.call.arguments)
[17:38:08.538]                   }
[17:38:08.538]                 }, immediateCondition = function(cond) {
[17:38:08.538]                   save_rds <- function (object, pathname, ...) 
[17:38:08.538]                   {
[17:38:08.538]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:08.538]                     if (file_test("-f", pathname_tmp)) {
[17:38:08.538]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.538]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:08.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.538]                         fi_tmp[["mtime"]])
[17:38:08.538]                     }
[17:38:08.538]                     tryCatch({
[17:38:08.538]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:08.538]                     }, error = function(ex) {
[17:38:08.538]                       msg <- conditionMessage(ex)
[17:38:08.538]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.538]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:08.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.538]                         fi_tmp[["mtime"]], msg)
[17:38:08.538]                       ex$message <- msg
[17:38:08.538]                       stop(ex)
[17:38:08.538]                     })
[17:38:08.538]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:08.538]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:08.538]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:08.538]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.538]                       fi <- file.info(pathname)
[17:38:08.538]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:08.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.538]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:08.538]                         fi[["size"]], fi[["mtime"]])
[17:38:08.538]                       stop(msg)
[17:38:08.538]                     }
[17:38:08.538]                     invisible(pathname)
[17:38:08.538]                   }
[17:38:08.538]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:08.538]                     rootPath = tempdir()) 
[17:38:08.538]                   {
[17:38:08.538]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:08.538]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:08.538]                       tmpdir = path, fileext = ".rds")
[17:38:08.538]                     save_rds(obj, file)
[17:38:08.538]                   }
[17:38:08.538]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:08.538]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.538]                   {
[17:38:08.538]                     inherits <- base::inherits
[17:38:08.538]                     invokeRestart <- base::invokeRestart
[17:38:08.538]                     is.null <- base::is.null
[17:38:08.538]                     muffled <- FALSE
[17:38:08.538]                     if (inherits(cond, "message")) {
[17:38:08.538]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:08.538]                       if (muffled) 
[17:38:08.538]                         invokeRestart("muffleMessage")
[17:38:08.538]                     }
[17:38:08.538]                     else if (inherits(cond, "warning")) {
[17:38:08.538]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:08.538]                       if (muffled) 
[17:38:08.538]                         invokeRestart("muffleWarning")
[17:38:08.538]                     }
[17:38:08.538]                     else if (inherits(cond, "condition")) {
[17:38:08.538]                       if (!is.null(pattern)) {
[17:38:08.538]                         computeRestarts <- base::computeRestarts
[17:38:08.538]                         grepl <- base::grepl
[17:38:08.538]                         restarts <- computeRestarts(cond)
[17:38:08.538]                         for (restart in restarts) {
[17:38:08.538]                           name <- restart$name
[17:38:08.538]                           if (is.null(name)) 
[17:38:08.538]                             next
[17:38:08.538]                           if (!grepl(pattern, name)) 
[17:38:08.538]                             next
[17:38:08.538]                           invokeRestart(restart)
[17:38:08.538]                           muffled <- TRUE
[17:38:08.538]                           break
[17:38:08.538]                         }
[17:38:08.538]                       }
[17:38:08.538]                     }
[17:38:08.538]                     invisible(muffled)
[17:38:08.538]                   }
[17:38:08.538]                   muffleCondition(cond)
[17:38:08.538]                 })
[17:38:08.538]             }))
[17:38:08.538]             future::FutureResult(value = ...future.value$value, 
[17:38:08.538]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.538]                   ...future.rng), globalenv = if (FALSE) 
[17:38:08.538]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:08.538]                     ...future.globalenv.names))
[17:38:08.538]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:08.538]         }, condition = base::local({
[17:38:08.538]             c <- base::c
[17:38:08.538]             inherits <- base::inherits
[17:38:08.538]             invokeRestart <- base::invokeRestart
[17:38:08.538]             length <- base::length
[17:38:08.538]             list <- base::list
[17:38:08.538]             seq.int <- base::seq.int
[17:38:08.538]             signalCondition <- base::signalCondition
[17:38:08.538]             sys.calls <- base::sys.calls
[17:38:08.538]             `[[` <- base::`[[`
[17:38:08.538]             `+` <- base::`+`
[17:38:08.538]             `<<-` <- base::`<<-`
[17:38:08.538]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:08.538]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:08.538]                   3L)]
[17:38:08.538]             }
[17:38:08.538]             function(cond) {
[17:38:08.538]                 is_error <- inherits(cond, "error")
[17:38:08.538]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:08.538]                   NULL)
[17:38:08.538]                 if (is_error) {
[17:38:08.538]                   sessionInformation <- function() {
[17:38:08.538]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:08.538]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:08.538]                       search = base::search(), system = base::Sys.info())
[17:38:08.538]                   }
[17:38:08.538]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.538]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:08.538]                     cond$call), session = sessionInformation(), 
[17:38:08.538]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:08.538]                   signalCondition(cond)
[17:38:08.538]                 }
[17:38:08.538]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:08.538]                 "immediateCondition"))) {
[17:38:08.538]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:08.538]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.538]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:08.538]                   if (TRUE && !signal) {
[17:38:08.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.538]                     {
[17:38:08.538]                       inherits <- base::inherits
[17:38:08.538]                       invokeRestart <- base::invokeRestart
[17:38:08.538]                       is.null <- base::is.null
[17:38:08.538]                       muffled <- FALSE
[17:38:08.538]                       if (inherits(cond, "message")) {
[17:38:08.538]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.538]                         if (muffled) 
[17:38:08.538]                           invokeRestart("muffleMessage")
[17:38:08.538]                       }
[17:38:08.538]                       else if (inherits(cond, "warning")) {
[17:38:08.538]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.538]                         if (muffled) 
[17:38:08.538]                           invokeRestart("muffleWarning")
[17:38:08.538]                       }
[17:38:08.538]                       else if (inherits(cond, "condition")) {
[17:38:08.538]                         if (!is.null(pattern)) {
[17:38:08.538]                           computeRestarts <- base::computeRestarts
[17:38:08.538]                           grepl <- base::grepl
[17:38:08.538]                           restarts <- computeRestarts(cond)
[17:38:08.538]                           for (restart in restarts) {
[17:38:08.538]                             name <- restart$name
[17:38:08.538]                             if (is.null(name)) 
[17:38:08.538]                               next
[17:38:08.538]                             if (!grepl(pattern, name)) 
[17:38:08.538]                               next
[17:38:08.538]                             invokeRestart(restart)
[17:38:08.538]                             muffled <- TRUE
[17:38:08.538]                             break
[17:38:08.538]                           }
[17:38:08.538]                         }
[17:38:08.538]                       }
[17:38:08.538]                       invisible(muffled)
[17:38:08.538]                     }
[17:38:08.538]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.538]                   }
[17:38:08.538]                 }
[17:38:08.538]                 else {
[17:38:08.538]                   if (TRUE) {
[17:38:08.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.538]                     {
[17:38:08.538]                       inherits <- base::inherits
[17:38:08.538]                       invokeRestart <- base::invokeRestart
[17:38:08.538]                       is.null <- base::is.null
[17:38:08.538]                       muffled <- FALSE
[17:38:08.538]                       if (inherits(cond, "message")) {
[17:38:08.538]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.538]                         if (muffled) 
[17:38:08.538]                           invokeRestart("muffleMessage")
[17:38:08.538]                       }
[17:38:08.538]                       else if (inherits(cond, "warning")) {
[17:38:08.538]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.538]                         if (muffled) 
[17:38:08.538]                           invokeRestart("muffleWarning")
[17:38:08.538]                       }
[17:38:08.538]                       else if (inherits(cond, "condition")) {
[17:38:08.538]                         if (!is.null(pattern)) {
[17:38:08.538]                           computeRestarts <- base::computeRestarts
[17:38:08.538]                           grepl <- base::grepl
[17:38:08.538]                           restarts <- computeRestarts(cond)
[17:38:08.538]                           for (restart in restarts) {
[17:38:08.538]                             name <- restart$name
[17:38:08.538]                             if (is.null(name)) 
[17:38:08.538]                               next
[17:38:08.538]                             if (!grepl(pattern, name)) 
[17:38:08.538]                               next
[17:38:08.538]                             invokeRestart(restart)
[17:38:08.538]                             muffled <- TRUE
[17:38:08.538]                             break
[17:38:08.538]                           }
[17:38:08.538]                         }
[17:38:08.538]                       }
[17:38:08.538]                       invisible(muffled)
[17:38:08.538]                     }
[17:38:08.538]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.538]                   }
[17:38:08.538]                 }
[17:38:08.538]             }
[17:38:08.538]         }))
[17:38:08.538]     }, error = function(ex) {
[17:38:08.538]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:08.538]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.538]                 ...future.rng), started = ...future.startTime, 
[17:38:08.538]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:08.538]             version = "1.8"), class = "FutureResult")
[17:38:08.538]     }, finally = {
[17:38:08.538]         if (!identical(...future.workdir, getwd())) 
[17:38:08.538]             setwd(...future.workdir)
[17:38:08.538]         {
[17:38:08.538]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:08.538]                 ...future.oldOptions$nwarnings <- NULL
[17:38:08.538]             }
[17:38:08.538]             base::options(...future.oldOptions)
[17:38:08.538]             if (.Platform$OS.type == "windows") {
[17:38:08.538]                 old_names <- names(...future.oldEnvVars)
[17:38:08.538]                 envs <- base::Sys.getenv()
[17:38:08.538]                 names <- names(envs)
[17:38:08.538]                 common <- intersect(names, old_names)
[17:38:08.538]                 added <- setdiff(names, old_names)
[17:38:08.538]                 removed <- setdiff(old_names, names)
[17:38:08.538]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:08.538]                   envs[common]]
[17:38:08.538]                 NAMES <- toupper(changed)
[17:38:08.538]                 args <- list()
[17:38:08.538]                 for (kk in seq_along(NAMES)) {
[17:38:08.538]                   name <- changed[[kk]]
[17:38:08.538]                   NAME <- NAMES[[kk]]
[17:38:08.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.538]                     next
[17:38:08.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.538]                 }
[17:38:08.538]                 NAMES <- toupper(added)
[17:38:08.538]                 for (kk in seq_along(NAMES)) {
[17:38:08.538]                   name <- added[[kk]]
[17:38:08.538]                   NAME <- NAMES[[kk]]
[17:38:08.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.538]                     next
[17:38:08.538]                   args[[name]] <- ""
[17:38:08.538]                 }
[17:38:08.538]                 NAMES <- toupper(removed)
[17:38:08.538]                 for (kk in seq_along(NAMES)) {
[17:38:08.538]                   name <- removed[[kk]]
[17:38:08.538]                   NAME <- NAMES[[kk]]
[17:38:08.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.538]                     next
[17:38:08.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.538]                 }
[17:38:08.538]                 if (length(args) > 0) 
[17:38:08.538]                   base::do.call(base::Sys.setenv, args = args)
[17:38:08.538]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:08.538]             }
[17:38:08.538]             else {
[17:38:08.538]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:08.538]             }
[17:38:08.538]             {
[17:38:08.538]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:08.538]                   0L) {
[17:38:08.538]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:08.538]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:08.538]                   base::options(opts)
[17:38:08.538]                 }
[17:38:08.538]                 {
[17:38:08.538]                   {
[17:38:08.538]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:08.538]                     NULL
[17:38:08.538]                   }
[17:38:08.538]                   options(future.plan = NULL)
[17:38:08.538]                   if (is.na(NA_character_)) 
[17:38:08.538]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.538]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:08.538]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:08.538]                     .init = FALSE)
[17:38:08.538]                 }
[17:38:08.538]             }
[17:38:08.538]         }
[17:38:08.538]     })
[17:38:08.538]     if (TRUE) {
[17:38:08.538]         base::sink(type = "output", split = FALSE)
[17:38:08.538]         if (TRUE) {
[17:38:08.538]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:08.538]         }
[17:38:08.538]         else {
[17:38:08.538]             ...future.result["stdout"] <- base::list(NULL)
[17:38:08.538]         }
[17:38:08.538]         base::close(...future.stdout)
[17:38:08.538]         ...future.stdout <- NULL
[17:38:08.538]     }
[17:38:08.538]     ...future.result$conditions <- ...future.conditions
[17:38:08.538]     ...future.result$finished <- base::Sys.time()
[17:38:08.538]     ...future.result
[17:38:08.538] }
[17:38:08.540] assign_globals() ...
[17:38:08.541] List of 11
[17:38:08.541]  $ ...future.FUN            :function (x, ...)  
[17:38:08.541]  $ x_FUN                    :function (x, ...)  
[17:38:08.541]  $ times                    : int 5
[17:38:08.541]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.541]  $ stop_if_not              :function (...)  
[17:38:08.541]  $ dim                      : NULL
[17:38:08.541]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:08.541]  $ future.call.arguments    : list()
[17:38:08.541]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.541]  $ ...future.elements_ii    :List of 2
[17:38:08.541]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:38:08.541]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:38:08.541]  $ ...future.seeds_ii       : NULL
[17:38:08.541]  $ ...future.globals.maxSize: NULL
[17:38:08.541]  - attr(*, "where")=List of 11
[17:38:08.541]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:08.541]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:08.541]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:08.541]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:08.541]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:08.541]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:08.541]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:08.541]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:08.541]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:08.541]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:08.541]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:08.541]  - attr(*, "resolved")= logi FALSE
[17:38:08.541]  - attr(*, "total_size")= num 95528
[17:38:08.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.541]  - attr(*, "already-done")= logi TRUE
[17:38:08.550] - copied ‘...future.FUN’ to environment
[17:38:08.550] - copied ‘x_FUN’ to environment
[17:38:08.550] - copied ‘times’ to environment
[17:38:08.550] - copied ‘stopf’ to environment
[17:38:08.551] - copied ‘stop_if_not’ to environment
[17:38:08.551] - copied ‘dim’ to environment
[17:38:08.551] - copied ‘valid_types’ to environment
[17:38:08.551] - copied ‘future.call.arguments’ to environment
[17:38:08.551] - copied ‘...future.elements_ii’ to environment
[17:38:08.551] - copied ‘...future.seeds_ii’ to environment
[17:38:08.551] - copied ‘...future.globals.maxSize’ to environment
[17:38:08.551] assign_globals() ... done
[17:38:08.552] requestCore(): workers = 2
[17:38:08.554] MulticoreFuture started
[17:38:08.554] - Launch lazy future ... done
[17:38:08.554] run() for ‘MulticoreFuture’ ... done
[17:38:08.555] Created future:
[17:38:08.555] plan(): Setting new future strategy stack:
[17:38:08.556] List of future strategies:
[17:38:08.556] 1. sequential:
[17:38:08.556]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:08.556]    - tweaked: FALSE
[17:38:08.556]    - call: NULL
[17:38:08.557] plan(): nbrOfWorkers() = 1
[17:38:08.560] plan(): Setting new future strategy stack:
[17:38:08.560] List of future strategies:
[17:38:08.560] 1. multicore:
[17:38:08.560]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:08.560]    - tweaked: FALSE
[17:38:08.560]    - call: plan(strategy)
[17:38:08.555] MulticoreFuture:
[17:38:08.555] Label: ‘future_vapply-2’
[17:38:08.555] Expression:
[17:38:08.555] {
[17:38:08.555]     do.call(function(...) {
[17:38:08.555]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.555]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.555]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.555]             on.exit(options(oopts), add = TRUE)
[17:38:08.555]         }
[17:38:08.555]         {
[17:38:08.555]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.555]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.555]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.555]             })
[17:38:08.555]         }
[17:38:08.555]     }, args = future.call.arguments)
[17:38:08.555] }
[17:38:08.555] Lazy evaluation: FALSE
[17:38:08.555] Asynchronous evaluation: TRUE
[17:38:08.555] Local evaluation: TRUE
[17:38:08.555] Environment: R_GlobalEnv
[17:38:08.555] Capture standard output: TRUE
[17:38:08.555] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:08.555] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:08.555] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:38:08.555] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:08.555] Resolved: FALSE
[17:38:08.555] Value: <not collected>
[17:38:08.555] Conditions captured: <none>
[17:38:08.555] Early signaling: FALSE
[17:38:08.555] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:08.555] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.568] Chunk #2 of 2 ... DONE
[17:38:08.568] Launching 2 futures (chunks) ... DONE
[17:38:08.568] Resolving 2 futures (chunks) ...
[17:38:08.569] resolve() on list ...
[17:38:08.569]  recursive: 0
[17:38:08.569]  length: 2
[17:38:08.569] 
[17:38:08.569] Future #1
[17:38:08.569] result() for MulticoreFuture ...
[17:38:08.572] plan(): nbrOfWorkers() = 2
[17:38:08.571] result() for MulticoreFuture ...
[17:38:08.574] result() for MulticoreFuture ... done
[17:38:08.575] result() for MulticoreFuture ... done
[17:38:08.575] result() for MulticoreFuture ...
[17:38:08.575] result() for MulticoreFuture ... done
[17:38:08.575] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:08.576] - nx: 2
[17:38:08.576] - relay: TRUE
[17:38:08.576] - stdout: TRUE
[17:38:08.576] - signal: TRUE
[17:38:08.577] - resignal: FALSE
[17:38:08.577] - force: TRUE
[17:38:08.577] - relayed: [n=2] FALSE, FALSE
[17:38:08.577] - queued futures: [n=2] FALSE, FALSE
[17:38:08.578]  - until=1
[17:38:08.578]  - relaying element #1
[17:38:08.578] result() for MulticoreFuture ...
[17:38:08.579] result() for MulticoreFuture ... done
[17:38:08.579] result() for MulticoreFuture ...
[17:38:08.579] result() for MulticoreFuture ... done
[17:38:08.579] result() for MulticoreFuture ...
[17:38:08.580] result() for MulticoreFuture ... done
[17:38:08.580] result() for MulticoreFuture ...
[17:38:08.580] result() for MulticoreFuture ... done
[17:38:08.580] - relayed: [n=2] TRUE, FALSE
[17:38:08.581] - queued futures: [n=2] TRUE, FALSE
[17:38:08.581] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:08.581]  length: 1 (resolved future 1)
[17:38:08.582] Future #2
[17:38:08.582] result() for MulticoreFuture ...
[17:38:08.583] result() for MulticoreFuture ...
[17:38:08.583] result() for MulticoreFuture ... done
[17:38:08.583] result() for MulticoreFuture ... done
[17:38:08.584] result() for MulticoreFuture ...
[17:38:08.584] result() for MulticoreFuture ... done
[17:38:08.584] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:08.584] - nx: 2
[17:38:08.585] - relay: TRUE
[17:38:08.585] - stdout: TRUE
[17:38:08.585] - signal: TRUE
[17:38:08.585] - resignal: FALSE
[17:38:08.585] - force: TRUE
[17:38:08.585] - relayed: [n=2] TRUE, FALSE
[17:38:08.586] - queued futures: [n=2] TRUE, FALSE
[17:38:08.586]  - until=2
[17:38:08.586]  - relaying element #2
[17:38:08.586] result() for MulticoreFuture ...
[17:38:08.586] result() for MulticoreFuture ... done
[17:38:08.586] result() for MulticoreFuture ...
[17:38:08.586] result() for MulticoreFuture ... done
[17:38:08.586] result() for MulticoreFuture ...
[17:38:08.587] result() for MulticoreFuture ... done
[17:38:08.587] result() for MulticoreFuture ...
[17:38:08.587] result() for MulticoreFuture ... done
[17:38:08.587] - relayed: [n=2] TRUE, TRUE
[17:38:08.587] - queued futures: [n=2] TRUE, TRUE
[17:38:08.587] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:08.587]  length: 0 (resolved future 2)
[17:38:08.587] Relaying remaining futures
[17:38:08.588] signalConditionsASAP(NULL, pos=0) ...
[17:38:08.588] - nx: 2
[17:38:08.588] - relay: TRUE
[17:38:08.588] - stdout: TRUE
[17:38:08.588] - signal: TRUE
[17:38:08.588] - resignal: FALSE
[17:38:08.588] - force: TRUE
[17:38:08.588] - relayed: [n=2] TRUE, TRUE
[17:38:08.588] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:08.589] - relayed: [n=2] TRUE, TRUE
[17:38:08.589] - queued futures: [n=2] TRUE, TRUE
[17:38:08.589] signalConditionsASAP(NULL, pos=0) ... done
[17:38:08.589] resolve() on list ... DONE
[17:38:08.589] result() for MulticoreFuture ...
[17:38:08.589] result() for MulticoreFuture ... done
[17:38:08.589] result() for MulticoreFuture ...
[17:38:08.589] result() for MulticoreFuture ... done
[17:38:08.589] result() for MulticoreFuture ...
[17:38:08.590] result() for MulticoreFuture ... done
[17:38:08.590] result() for MulticoreFuture ...
[17:38:08.590] result() for MulticoreFuture ... done
[17:38:08.590]  - Number of value chunks collected: 2
[17:38:08.590] Resolving 2 futures (chunks) ... DONE
[17:38:08.590] Reducing values from 2 chunks ...
[17:38:08.590]  - Number of values collected after concatenation: 3
[17:38:08.590]  - Number of values expected: 3
[17:38:08.590] Reducing values from 2 chunks ... DONE
[17:38:08.591] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[17:38:08.593] future_lapply() ...
[17:38:08.601] Number of chunks: 2
[17:38:08.601] getGlobalsAndPackagesXApply() ...
[17:38:08.601]  - future.globals: TRUE
[17:38:08.601] getGlobalsAndPackages() ...
[17:38:08.602] Searching for globals...
[17:38:08.609] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:38:08.609] Searching for globals ... DONE
[17:38:08.609] Resolving globals: FALSE
[17:38:08.610] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[17:38:08.611] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[17:38:08.611] - globals: [1] ‘FUN’
[17:38:08.611] - packages: [1] ‘stats’
[17:38:08.611] getGlobalsAndPackages() ... DONE
[17:38:08.611]  - globals found/used: [n=1] ‘FUN’
[17:38:08.611]  - needed namespaces: [n=1] ‘stats’
[17:38:08.612] Finding globals ... DONE
[17:38:08.612]  - use_args: TRUE
[17:38:08.612]  - Getting '...' globals ...
[17:38:08.612] resolve() on list ...
[17:38:08.612]  recursive: 0
[17:38:08.612]  length: 1
[17:38:08.612]  elements: ‘...’
[17:38:08.613]  length: 0 (resolved future 1)
[17:38:08.613] resolve() on list ... DONE
[17:38:08.613]    - '...' content: [n=0] 
[17:38:08.613] List of 1
[17:38:08.613]  $ ...: list()
[17:38:08.613]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.613]  - attr(*, "where")=List of 1
[17:38:08.613]   ..$ ...:<environment: 0x5607ffb15cb8> 
[17:38:08.613]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.613]  - attr(*, "resolved")= logi TRUE
[17:38:08.613]  - attr(*, "total_size")= num NA
[17:38:08.615]  - Getting '...' globals ... DONE
[17:38:08.616] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:08.616] List of 2
[17:38:08.616]  $ ...future.FUN:function (x, na.rm = TRUE)  
[17:38:08.616]  $ ...          : list()
[17:38:08.616]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.616]  - attr(*, "where")=List of 2
[17:38:08.616]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:08.616]   ..$ ...          :<environment: 0x5607ffb15cb8> 
[17:38:08.616]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.616]  - attr(*, "resolved")= logi FALSE
[17:38:08.616]  - attr(*, "total_size")= num 46960
[17:38:08.618] Packages to be attached in all futures: [n=1] ‘stats’
[17:38:08.619] getGlobalsAndPackagesXApply() ... DONE
[17:38:08.619] Number of futures (= number of chunks): 2
[17:38:08.619] Launching 2 futures (chunks) ...
[17:38:08.619] Chunk #1 of 2 ...
[17:38:08.619]  - Finding globals in 'X' for chunk #1 ...
[17:38:08.619] getGlobalsAndPackages() ...
[17:38:08.619] Searching for globals...
[17:38:08.620] 
[17:38:08.620] Searching for globals ... DONE
[17:38:08.620] - globals: [0] <none>
[17:38:08.620] getGlobalsAndPackages() ... DONE
[17:38:08.620]    + additional globals found: [n=0] 
[17:38:08.620]    + additional namespaces needed: [n=0] 
[17:38:08.620]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:08.620]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:08.620]  - seeds: <none>
[17:38:08.620]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.621] getGlobalsAndPackages() ...
[17:38:08.621] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.621] Resolving globals: FALSE
[17:38:08.621] Tweak future expression to call with '...' arguments ...
[17:38:08.621] {
[17:38:08.621]     do.call(function(...) {
[17:38:08.621]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.621]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.621]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.621]             on.exit(options(oopts), add = TRUE)
[17:38:08.621]         }
[17:38:08.621]         {
[17:38:08.621]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.621]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.621]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.621]             })
[17:38:08.621]         }
[17:38:08.621]     }, args = future.call.arguments)
[17:38:08.621] }
[17:38:08.621] Tweak future expression to call with '...' arguments ... DONE
[17:38:08.622] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.622] - packages: [1] ‘stats’
[17:38:08.622] getGlobalsAndPackages() ... DONE
[17:38:08.622] run() for ‘Future’ ...
[17:38:08.622] - state: ‘created’
[17:38:08.622] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:08.626] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.626] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:08.626]   - Field: ‘label’
[17:38:08.627]   - Field: ‘local’
[17:38:08.627]   - Field: ‘owner’
[17:38:08.627]   - Field: ‘envir’
[17:38:08.627]   - Field: ‘workers’
[17:38:08.627]   - Field: ‘packages’
[17:38:08.627]   - Field: ‘gc’
[17:38:08.627]   - Field: ‘job’
[17:38:08.627]   - Field: ‘conditions’
[17:38:08.627]   - Field: ‘expr’
[17:38:08.627]   - Field: ‘uuid’
[17:38:08.627]   - Field: ‘seed’
[17:38:08.628]   - Field: ‘version’
[17:38:08.628]   - Field: ‘result’
[17:38:08.628]   - Field: ‘asynchronous’
[17:38:08.628]   - Field: ‘calls’
[17:38:08.628]   - Field: ‘globals’
[17:38:08.628]   - Field: ‘stdout’
[17:38:08.628]   - Field: ‘earlySignal’
[17:38:08.628]   - Field: ‘lazy’
[17:38:08.628]   - Field: ‘state’
[17:38:08.628] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:08.629] - Launch lazy future ...
[17:38:08.629] Packages needed by the future expression (n = 1): ‘stats’
[17:38:08.629] Packages needed by future strategies (n = 0): <none>
[17:38:08.630] {
[17:38:08.630]     {
[17:38:08.630]         {
[17:38:08.630]             ...future.startTime <- base::Sys.time()
[17:38:08.630]             {
[17:38:08.630]                 {
[17:38:08.630]                   {
[17:38:08.630]                     {
[17:38:08.630]                       {
[17:38:08.630]                         base::local({
[17:38:08.630]                           has_future <- base::requireNamespace("future", 
[17:38:08.630]                             quietly = TRUE)
[17:38:08.630]                           if (has_future) {
[17:38:08.630]                             ns <- base::getNamespace("future")
[17:38:08.630]                             version <- ns[[".package"]][["version"]]
[17:38:08.630]                             if (is.null(version)) 
[17:38:08.630]                               version <- utils::packageVersion("future")
[17:38:08.630]                           }
[17:38:08.630]                           else {
[17:38:08.630]                             version <- NULL
[17:38:08.630]                           }
[17:38:08.630]                           if (!has_future || version < "1.8.0") {
[17:38:08.630]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:08.630]                               "", base::R.version$version.string), 
[17:38:08.630]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:08.630]                                 base::R.version$platform, 8 * 
[17:38:08.630]                                   base::.Machine$sizeof.pointer), 
[17:38:08.630]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:08.630]                                 "release", "version")], collapse = " "), 
[17:38:08.630]                               hostname = base::Sys.info()[["nodename"]])
[17:38:08.630]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:08.630]                               info)
[17:38:08.630]                             info <- base::paste(info, collapse = "; ")
[17:38:08.630]                             if (!has_future) {
[17:38:08.630]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:08.630]                                 info)
[17:38:08.630]                             }
[17:38:08.630]                             else {
[17:38:08.630]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:08.630]                                 info, version)
[17:38:08.630]                             }
[17:38:08.630]                             base::stop(msg)
[17:38:08.630]                           }
[17:38:08.630]                         })
[17:38:08.630]                       }
[17:38:08.630]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:08.630]                       base::options(mc.cores = 1L)
[17:38:08.630]                     }
[17:38:08.630]                     base::local({
[17:38:08.630]                       for (pkg in "stats") {
[17:38:08.630]                         base::loadNamespace(pkg)
[17:38:08.630]                         base::library(pkg, character.only = TRUE)
[17:38:08.630]                       }
[17:38:08.630]                     })
[17:38:08.630]                   }
[17:38:08.630]                   ...future.strategy.old <- future::plan("list")
[17:38:08.630]                   options(future.plan = NULL)
[17:38:08.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:08.630]                 }
[17:38:08.630]                 ...future.workdir <- getwd()
[17:38:08.630]             }
[17:38:08.630]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:08.630]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:08.630]         }
[17:38:08.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:08.630]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:08.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:08.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:08.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:08.630]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:08.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:08.630]             base::names(...future.oldOptions))
[17:38:08.630]     }
[17:38:08.630]     if (FALSE) {
[17:38:08.630]     }
[17:38:08.630]     else {
[17:38:08.630]         if (TRUE) {
[17:38:08.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:08.630]                 open = "w")
[17:38:08.630]         }
[17:38:08.630]         else {
[17:38:08.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:08.630]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:08.630]         }
[17:38:08.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:08.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:08.630]             base::sink(type = "output", split = FALSE)
[17:38:08.630]             base::close(...future.stdout)
[17:38:08.630]         }, add = TRUE)
[17:38:08.630]     }
[17:38:08.630]     ...future.frame <- base::sys.nframe()
[17:38:08.630]     ...future.conditions <- base::list()
[17:38:08.630]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:08.630]     if (FALSE) {
[17:38:08.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:08.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:08.630]     }
[17:38:08.630]     ...future.result <- base::tryCatch({
[17:38:08.630]         base::withCallingHandlers({
[17:38:08.630]             ...future.value <- base::withVisible(base::local({
[17:38:08.630]                 withCallingHandlers({
[17:38:08.630]                   {
[17:38:08.630]                     do.call(function(...) {
[17:38:08.630]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.630]                       if (!identical(...future.globals.maxSize.org, 
[17:38:08.630]                         ...future.globals.maxSize)) {
[17:38:08.630]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.630]                         on.exit(options(oopts), add = TRUE)
[17:38:08.630]                       }
[17:38:08.630]                       {
[17:38:08.630]                         lapply(seq_along(...future.elements_ii), 
[17:38:08.630]                           FUN = function(jj) {
[17:38:08.630]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.630]                             ...future.FUN(...future.X_jj, ...)
[17:38:08.630]                           })
[17:38:08.630]                       }
[17:38:08.630]                     }, args = future.call.arguments)
[17:38:08.630]                   }
[17:38:08.630]                 }, immediateCondition = function(cond) {
[17:38:08.630]                   save_rds <- function (object, pathname, ...) 
[17:38:08.630]                   {
[17:38:08.630]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:08.630]                     if (file_test("-f", pathname_tmp)) {
[17:38:08.630]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.630]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:08.630]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.630]                         fi_tmp[["mtime"]])
[17:38:08.630]                     }
[17:38:08.630]                     tryCatch({
[17:38:08.630]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:08.630]                     }, error = function(ex) {
[17:38:08.630]                       msg <- conditionMessage(ex)
[17:38:08.630]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.630]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:08.630]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.630]                         fi_tmp[["mtime"]], msg)
[17:38:08.630]                       ex$message <- msg
[17:38:08.630]                       stop(ex)
[17:38:08.630]                     })
[17:38:08.630]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:08.630]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:08.630]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:08.630]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.630]                       fi <- file.info(pathname)
[17:38:08.630]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:08.630]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.630]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:08.630]                         fi[["size"]], fi[["mtime"]])
[17:38:08.630]                       stop(msg)
[17:38:08.630]                     }
[17:38:08.630]                     invisible(pathname)
[17:38:08.630]                   }
[17:38:08.630]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:08.630]                     rootPath = tempdir()) 
[17:38:08.630]                   {
[17:38:08.630]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:08.630]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:08.630]                       tmpdir = path, fileext = ".rds")
[17:38:08.630]                     save_rds(obj, file)
[17:38:08.630]                   }
[17:38:08.630]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:08.630]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.630]                   {
[17:38:08.630]                     inherits <- base::inherits
[17:38:08.630]                     invokeRestart <- base::invokeRestart
[17:38:08.630]                     is.null <- base::is.null
[17:38:08.630]                     muffled <- FALSE
[17:38:08.630]                     if (inherits(cond, "message")) {
[17:38:08.630]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:08.630]                       if (muffled) 
[17:38:08.630]                         invokeRestart("muffleMessage")
[17:38:08.630]                     }
[17:38:08.630]                     else if (inherits(cond, "warning")) {
[17:38:08.630]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:08.630]                       if (muffled) 
[17:38:08.630]                         invokeRestart("muffleWarning")
[17:38:08.630]                     }
[17:38:08.630]                     else if (inherits(cond, "condition")) {
[17:38:08.630]                       if (!is.null(pattern)) {
[17:38:08.630]                         computeRestarts <- base::computeRestarts
[17:38:08.630]                         grepl <- base::grepl
[17:38:08.630]                         restarts <- computeRestarts(cond)
[17:38:08.630]                         for (restart in restarts) {
[17:38:08.630]                           name <- restart$name
[17:38:08.630]                           if (is.null(name)) 
[17:38:08.630]                             next
[17:38:08.630]                           if (!grepl(pattern, name)) 
[17:38:08.630]                             next
[17:38:08.630]                           invokeRestart(restart)
[17:38:08.630]                           muffled <- TRUE
[17:38:08.630]                           break
[17:38:08.630]                         }
[17:38:08.630]                       }
[17:38:08.630]                     }
[17:38:08.630]                     invisible(muffled)
[17:38:08.630]                   }
[17:38:08.630]                   muffleCondition(cond)
[17:38:08.630]                 })
[17:38:08.630]             }))
[17:38:08.630]             future::FutureResult(value = ...future.value$value, 
[17:38:08.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.630]                   ...future.rng), globalenv = if (FALSE) 
[17:38:08.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:08.630]                     ...future.globalenv.names))
[17:38:08.630]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:08.630]         }, condition = base::local({
[17:38:08.630]             c <- base::c
[17:38:08.630]             inherits <- base::inherits
[17:38:08.630]             invokeRestart <- base::invokeRestart
[17:38:08.630]             length <- base::length
[17:38:08.630]             list <- base::list
[17:38:08.630]             seq.int <- base::seq.int
[17:38:08.630]             signalCondition <- base::signalCondition
[17:38:08.630]             sys.calls <- base::sys.calls
[17:38:08.630]             `[[` <- base::`[[`
[17:38:08.630]             `+` <- base::`+`
[17:38:08.630]             `<<-` <- base::`<<-`
[17:38:08.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:08.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:08.630]                   3L)]
[17:38:08.630]             }
[17:38:08.630]             function(cond) {
[17:38:08.630]                 is_error <- inherits(cond, "error")
[17:38:08.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:08.630]                   NULL)
[17:38:08.630]                 if (is_error) {
[17:38:08.630]                   sessionInformation <- function() {
[17:38:08.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:08.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:08.630]                       search = base::search(), system = base::Sys.info())
[17:38:08.630]                   }
[17:38:08.630]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:08.630]                     cond$call), session = sessionInformation(), 
[17:38:08.630]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:08.630]                   signalCondition(cond)
[17:38:08.630]                 }
[17:38:08.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:08.630]                 "immediateCondition"))) {
[17:38:08.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:08.630]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:08.630]                   if (TRUE && !signal) {
[17:38:08.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.630]                     {
[17:38:08.630]                       inherits <- base::inherits
[17:38:08.630]                       invokeRestart <- base::invokeRestart
[17:38:08.630]                       is.null <- base::is.null
[17:38:08.630]                       muffled <- FALSE
[17:38:08.630]                       if (inherits(cond, "message")) {
[17:38:08.630]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.630]                         if (muffled) 
[17:38:08.630]                           invokeRestart("muffleMessage")
[17:38:08.630]                       }
[17:38:08.630]                       else if (inherits(cond, "warning")) {
[17:38:08.630]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.630]                         if (muffled) 
[17:38:08.630]                           invokeRestart("muffleWarning")
[17:38:08.630]                       }
[17:38:08.630]                       else if (inherits(cond, "condition")) {
[17:38:08.630]                         if (!is.null(pattern)) {
[17:38:08.630]                           computeRestarts <- base::computeRestarts
[17:38:08.630]                           grepl <- base::grepl
[17:38:08.630]                           restarts <- computeRestarts(cond)
[17:38:08.630]                           for (restart in restarts) {
[17:38:08.630]                             name <- restart$name
[17:38:08.630]                             if (is.null(name)) 
[17:38:08.630]                               next
[17:38:08.630]                             if (!grepl(pattern, name)) 
[17:38:08.630]                               next
[17:38:08.630]                             invokeRestart(restart)
[17:38:08.630]                             muffled <- TRUE
[17:38:08.630]                             break
[17:38:08.630]                           }
[17:38:08.630]                         }
[17:38:08.630]                       }
[17:38:08.630]                       invisible(muffled)
[17:38:08.630]                     }
[17:38:08.630]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.630]                   }
[17:38:08.630]                 }
[17:38:08.630]                 else {
[17:38:08.630]                   if (TRUE) {
[17:38:08.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.630]                     {
[17:38:08.630]                       inherits <- base::inherits
[17:38:08.630]                       invokeRestart <- base::invokeRestart
[17:38:08.630]                       is.null <- base::is.null
[17:38:08.630]                       muffled <- FALSE
[17:38:08.630]                       if (inherits(cond, "message")) {
[17:38:08.630]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.630]                         if (muffled) 
[17:38:08.630]                           invokeRestart("muffleMessage")
[17:38:08.630]                       }
[17:38:08.630]                       else if (inherits(cond, "warning")) {
[17:38:08.630]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.630]                         if (muffled) 
[17:38:08.630]                           invokeRestart("muffleWarning")
[17:38:08.630]                       }
[17:38:08.630]                       else if (inherits(cond, "condition")) {
[17:38:08.630]                         if (!is.null(pattern)) {
[17:38:08.630]                           computeRestarts <- base::computeRestarts
[17:38:08.630]                           grepl <- base::grepl
[17:38:08.630]                           restarts <- computeRestarts(cond)
[17:38:08.630]                           for (restart in restarts) {
[17:38:08.630]                             name <- restart$name
[17:38:08.630]                             if (is.null(name)) 
[17:38:08.630]                               next
[17:38:08.630]                             if (!grepl(pattern, name)) 
[17:38:08.630]                               next
[17:38:08.630]                             invokeRestart(restart)
[17:38:08.630]                             muffled <- TRUE
[17:38:08.630]                             break
[17:38:08.630]                           }
[17:38:08.630]                         }
[17:38:08.630]                       }
[17:38:08.630]                       invisible(muffled)
[17:38:08.630]                     }
[17:38:08.630]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.630]                   }
[17:38:08.630]                 }
[17:38:08.630]             }
[17:38:08.630]         }))
[17:38:08.630]     }, error = function(ex) {
[17:38:08.630]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:08.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.630]                 ...future.rng), started = ...future.startTime, 
[17:38:08.630]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:08.630]             version = "1.8"), class = "FutureResult")
[17:38:08.630]     }, finally = {
[17:38:08.630]         if (!identical(...future.workdir, getwd())) 
[17:38:08.630]             setwd(...future.workdir)
[17:38:08.630]         {
[17:38:08.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:08.630]                 ...future.oldOptions$nwarnings <- NULL
[17:38:08.630]             }
[17:38:08.630]             base::options(...future.oldOptions)
[17:38:08.630]             if (.Platform$OS.type == "windows") {
[17:38:08.630]                 old_names <- names(...future.oldEnvVars)
[17:38:08.630]                 envs <- base::Sys.getenv()
[17:38:08.630]                 names <- names(envs)
[17:38:08.630]                 common <- intersect(names, old_names)
[17:38:08.630]                 added <- setdiff(names, old_names)
[17:38:08.630]                 removed <- setdiff(old_names, names)
[17:38:08.630]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:08.630]                   envs[common]]
[17:38:08.630]                 NAMES <- toupper(changed)
[17:38:08.630]                 args <- list()
[17:38:08.630]                 for (kk in seq_along(NAMES)) {
[17:38:08.630]                   name <- changed[[kk]]
[17:38:08.630]                   NAME <- NAMES[[kk]]
[17:38:08.630]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.630]                     next
[17:38:08.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.630]                 }
[17:38:08.630]                 NAMES <- toupper(added)
[17:38:08.630]                 for (kk in seq_along(NAMES)) {
[17:38:08.630]                   name <- added[[kk]]
[17:38:08.630]                   NAME <- NAMES[[kk]]
[17:38:08.630]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.630]                     next
[17:38:08.630]                   args[[name]] <- ""
[17:38:08.630]                 }
[17:38:08.630]                 NAMES <- toupper(removed)
[17:38:08.630]                 for (kk in seq_along(NAMES)) {
[17:38:08.630]                   name <- removed[[kk]]
[17:38:08.630]                   NAME <- NAMES[[kk]]
[17:38:08.630]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.630]                     next
[17:38:08.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.630]                 }
[17:38:08.630]                 if (length(args) > 0) 
[17:38:08.630]                   base::do.call(base::Sys.setenv, args = args)
[17:38:08.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:08.630]             }
[17:38:08.630]             else {
[17:38:08.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:08.630]             }
[17:38:08.630]             {
[17:38:08.630]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:08.630]                   0L) {
[17:38:08.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:08.630]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:08.630]                   base::options(opts)
[17:38:08.630]                 }
[17:38:08.630]                 {
[17:38:08.630]                   {
[17:38:08.630]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:08.630]                     NULL
[17:38:08.630]                   }
[17:38:08.630]                   options(future.plan = NULL)
[17:38:08.630]                   if (is.na(NA_character_)) 
[17:38:08.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:08.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:08.630]                     .init = FALSE)
[17:38:08.630]                 }
[17:38:08.630]             }
[17:38:08.630]         }
[17:38:08.630]     })
[17:38:08.630]     if (TRUE) {
[17:38:08.630]         base::sink(type = "output", split = FALSE)
[17:38:08.630]         if (TRUE) {
[17:38:08.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:08.630]         }
[17:38:08.630]         else {
[17:38:08.630]             ...future.result["stdout"] <- base::list(NULL)
[17:38:08.630]         }
[17:38:08.630]         base::close(...future.stdout)
[17:38:08.630]         ...future.stdout <- NULL
[17:38:08.630]     }
[17:38:08.630]     ...future.result$conditions <- ...future.conditions
[17:38:08.630]     ...future.result$finished <- base::Sys.time()
[17:38:08.630]     ...future.result
[17:38:08.630] }
[17:38:08.634] assign_globals() ...
[17:38:08.634] List of 5
[17:38:08.634]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[17:38:08.634]  $ future.call.arguments    : list()
[17:38:08.634]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.634]  $ ...future.elements_ii    :List of 4
[17:38:08.634]   ..$ : int [1:3] 1 2 3
[17:38:08.634]   ..$ : int [1:4] 1 2 3 4
[17:38:08.634]   ..$ : int [1:5] 1 2 3 4 5
[17:38:08.634]   ..$ : int [1:6] 1 2 3 4 5 6
[17:38:08.634]  $ ...future.seeds_ii       : NULL
[17:38:08.634]  $ ...future.globals.maxSize: NULL
[17:38:08.634]  - attr(*, "where")=List of 5
[17:38:08.634]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:08.634]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:08.634]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:08.634]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:08.634]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:08.634]  - attr(*, "resolved")= logi FALSE
[17:38:08.634]  - attr(*, "total_size")= num 46960
[17:38:08.634]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.634]  - attr(*, "already-done")= logi TRUE
[17:38:08.641] - copied ‘...future.FUN’ to environment
[17:38:08.641] - copied ‘future.call.arguments’ to environment
[17:38:08.641] - copied ‘...future.elements_ii’ to environment
[17:38:08.641] - copied ‘...future.seeds_ii’ to environment
[17:38:08.641] - copied ‘...future.globals.maxSize’ to environment
[17:38:08.641] assign_globals() ... done
[17:38:08.641] requestCore(): workers = 2
[17:38:08.644] MulticoreFuture started
[17:38:08.644] - Launch lazy future ... done
[17:38:08.645] run() for ‘MulticoreFuture’ ... done
[17:38:08.645] Created future:
[17:38:08.645] plan(): Setting new future strategy stack:
[17:38:08.646] List of future strategies:
[17:38:08.646] 1. sequential:
[17:38:08.646]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:08.646]    - tweaked: FALSE
[17:38:08.646]    - call: NULL
[17:38:08.647] plan(): nbrOfWorkers() = 1
[17:38:08.649] plan(): Setting new future strategy stack:
[17:38:08.649] List of future strategies:
[17:38:08.649] 1. multicore:
[17:38:08.649]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:08.649]    - tweaked: FALSE
[17:38:08.649]    - call: plan(strategy)
[17:38:08.654] plan(): nbrOfWorkers() = 2
[17:38:08.645] MulticoreFuture:
[17:38:08.645] Label: ‘future_sapply-1’
[17:38:08.645] Expression:
[17:38:08.645] {
[17:38:08.645]     do.call(function(...) {
[17:38:08.645]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.645]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.645]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.645]             on.exit(options(oopts), add = TRUE)
[17:38:08.645]         }
[17:38:08.645]         {
[17:38:08.645]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.645]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.645]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.645]             })
[17:38:08.645]         }
[17:38:08.645]     }, args = future.call.arguments)
[17:38:08.645] }
[17:38:08.645] Lazy evaluation: FALSE
[17:38:08.645] Asynchronous evaluation: TRUE
[17:38:08.645] Local evaluation: TRUE
[17:38:08.645] Environment: R_GlobalEnv
[17:38:08.645] Capture standard output: TRUE
[17:38:08.645] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:08.645] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:08.645] Packages: 1 packages (‘stats’)
[17:38:08.645] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:08.645] Resolved: TRUE
[17:38:08.645] Value: <not collected>
[17:38:08.645] Conditions captured: <none>
[17:38:08.645] Early signaling: FALSE
[17:38:08.645] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:08.645] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.655] Chunk #1 of 2 ... DONE
[17:38:08.656] Chunk #2 of 2 ...
[17:38:08.656]  - Finding globals in 'X' for chunk #2 ...
[17:38:08.656] getGlobalsAndPackages() ...
[17:38:08.656] Searching for globals...
[17:38:08.657] 
[17:38:08.657] Searching for globals ... DONE
[17:38:08.657] - globals: [0] <none>
[17:38:08.657] getGlobalsAndPackages() ... DONE
[17:38:08.657]    + additional globals found: [n=0] 
[17:38:08.657]    + additional namespaces needed: [n=0] 
[17:38:08.657]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:08.657]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:08.658]  - seeds: <none>
[17:38:08.658]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.658] getGlobalsAndPackages() ...
[17:38:08.658] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.658] Resolving globals: FALSE
[17:38:08.658] Tweak future expression to call with '...' arguments ...
[17:38:08.659] {
[17:38:08.659]     do.call(function(...) {
[17:38:08.659]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.659]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.659]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.659]             on.exit(options(oopts), add = TRUE)
[17:38:08.659]         }
[17:38:08.659]         {
[17:38:08.659]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.659]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.659]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.659]             })
[17:38:08.659]         }
[17:38:08.659]     }, args = future.call.arguments)
[17:38:08.659] }
[17:38:08.659] Tweak future expression to call with '...' arguments ... DONE
[17:38:08.660] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.660] - packages: [1] ‘stats’
[17:38:08.660] getGlobalsAndPackages() ... DONE
[17:38:08.661] run() for ‘Future’ ...
[17:38:08.661] - state: ‘created’
[17:38:08.661] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:08.666] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.666] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:08.666]   - Field: ‘label’
[17:38:08.666]   - Field: ‘local’
[17:38:08.667]   - Field: ‘owner’
[17:38:08.667]   - Field: ‘envir’
[17:38:08.667]   - Field: ‘workers’
[17:38:08.667]   - Field: ‘packages’
[17:38:08.667]   - Field: ‘gc’
[17:38:08.667]   - Field: ‘job’
[17:38:08.668]   - Field: ‘conditions’
[17:38:08.668]   - Field: ‘expr’
[17:38:08.668]   - Field: ‘uuid’
[17:38:08.668]   - Field: ‘seed’
[17:38:08.668]   - Field: ‘version’
[17:38:08.668]   - Field: ‘result’
[17:38:08.669]   - Field: ‘asynchronous’
[17:38:08.669]   - Field: ‘calls’
[17:38:08.669]   - Field: ‘globals’
[17:38:08.669]   - Field: ‘stdout’
[17:38:08.669]   - Field: ‘earlySignal’
[17:38:08.669]   - Field: ‘lazy’
[17:38:08.669]   - Field: ‘state’
[17:38:08.670] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:08.670] - Launch lazy future ...
[17:38:08.670] Packages needed by the future expression (n = 1): ‘stats’
[17:38:08.670] Packages needed by future strategies (n = 0): <none>
[17:38:08.671] {
[17:38:08.671]     {
[17:38:08.671]         {
[17:38:08.671]             ...future.startTime <- base::Sys.time()
[17:38:08.671]             {
[17:38:08.671]                 {
[17:38:08.671]                   {
[17:38:08.671]                     {
[17:38:08.671]                       {
[17:38:08.671]                         base::local({
[17:38:08.671]                           has_future <- base::requireNamespace("future", 
[17:38:08.671]                             quietly = TRUE)
[17:38:08.671]                           if (has_future) {
[17:38:08.671]                             ns <- base::getNamespace("future")
[17:38:08.671]                             version <- ns[[".package"]][["version"]]
[17:38:08.671]                             if (is.null(version)) 
[17:38:08.671]                               version <- utils::packageVersion("future")
[17:38:08.671]                           }
[17:38:08.671]                           else {
[17:38:08.671]                             version <- NULL
[17:38:08.671]                           }
[17:38:08.671]                           if (!has_future || version < "1.8.0") {
[17:38:08.671]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:08.671]                               "", base::R.version$version.string), 
[17:38:08.671]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:08.671]                                 base::R.version$platform, 8 * 
[17:38:08.671]                                   base::.Machine$sizeof.pointer), 
[17:38:08.671]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:08.671]                                 "release", "version")], collapse = " "), 
[17:38:08.671]                               hostname = base::Sys.info()[["nodename"]])
[17:38:08.671]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:08.671]                               info)
[17:38:08.671]                             info <- base::paste(info, collapse = "; ")
[17:38:08.671]                             if (!has_future) {
[17:38:08.671]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:08.671]                                 info)
[17:38:08.671]                             }
[17:38:08.671]                             else {
[17:38:08.671]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:08.671]                                 info, version)
[17:38:08.671]                             }
[17:38:08.671]                             base::stop(msg)
[17:38:08.671]                           }
[17:38:08.671]                         })
[17:38:08.671]                       }
[17:38:08.671]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:08.671]                       base::options(mc.cores = 1L)
[17:38:08.671]                     }
[17:38:08.671]                     base::local({
[17:38:08.671]                       for (pkg in "stats") {
[17:38:08.671]                         base::loadNamespace(pkg)
[17:38:08.671]                         base::library(pkg, character.only = TRUE)
[17:38:08.671]                       }
[17:38:08.671]                     })
[17:38:08.671]                   }
[17:38:08.671]                   ...future.strategy.old <- future::plan("list")
[17:38:08.671]                   options(future.plan = NULL)
[17:38:08.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:08.671]                 }
[17:38:08.671]                 ...future.workdir <- getwd()
[17:38:08.671]             }
[17:38:08.671]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:08.671]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:08.671]         }
[17:38:08.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:08.671]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:08.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:08.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:08.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:08.671]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:08.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:08.671]             base::names(...future.oldOptions))
[17:38:08.671]     }
[17:38:08.671]     if (FALSE) {
[17:38:08.671]     }
[17:38:08.671]     else {
[17:38:08.671]         if (TRUE) {
[17:38:08.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:08.671]                 open = "w")
[17:38:08.671]         }
[17:38:08.671]         else {
[17:38:08.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:08.671]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:08.671]         }
[17:38:08.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:08.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:08.671]             base::sink(type = "output", split = FALSE)
[17:38:08.671]             base::close(...future.stdout)
[17:38:08.671]         }, add = TRUE)
[17:38:08.671]     }
[17:38:08.671]     ...future.frame <- base::sys.nframe()
[17:38:08.671]     ...future.conditions <- base::list()
[17:38:08.671]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:08.671]     if (FALSE) {
[17:38:08.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:08.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:08.671]     }
[17:38:08.671]     ...future.result <- base::tryCatch({
[17:38:08.671]         base::withCallingHandlers({
[17:38:08.671]             ...future.value <- base::withVisible(base::local({
[17:38:08.671]                 withCallingHandlers({
[17:38:08.671]                   {
[17:38:08.671]                     do.call(function(...) {
[17:38:08.671]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.671]                       if (!identical(...future.globals.maxSize.org, 
[17:38:08.671]                         ...future.globals.maxSize)) {
[17:38:08.671]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.671]                         on.exit(options(oopts), add = TRUE)
[17:38:08.671]                       }
[17:38:08.671]                       {
[17:38:08.671]                         lapply(seq_along(...future.elements_ii), 
[17:38:08.671]                           FUN = function(jj) {
[17:38:08.671]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.671]                             ...future.FUN(...future.X_jj, ...)
[17:38:08.671]                           })
[17:38:08.671]                       }
[17:38:08.671]                     }, args = future.call.arguments)
[17:38:08.671]                   }
[17:38:08.671]                 }, immediateCondition = function(cond) {
[17:38:08.671]                   save_rds <- function (object, pathname, ...) 
[17:38:08.671]                   {
[17:38:08.671]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:08.671]                     if (file_test("-f", pathname_tmp)) {
[17:38:08.671]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.671]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:08.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.671]                         fi_tmp[["mtime"]])
[17:38:08.671]                     }
[17:38:08.671]                     tryCatch({
[17:38:08.671]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:08.671]                     }, error = function(ex) {
[17:38:08.671]                       msg <- conditionMessage(ex)
[17:38:08.671]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.671]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:08.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.671]                         fi_tmp[["mtime"]], msg)
[17:38:08.671]                       ex$message <- msg
[17:38:08.671]                       stop(ex)
[17:38:08.671]                     })
[17:38:08.671]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:08.671]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:08.671]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:08.671]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.671]                       fi <- file.info(pathname)
[17:38:08.671]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:08.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.671]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:08.671]                         fi[["size"]], fi[["mtime"]])
[17:38:08.671]                       stop(msg)
[17:38:08.671]                     }
[17:38:08.671]                     invisible(pathname)
[17:38:08.671]                   }
[17:38:08.671]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:08.671]                     rootPath = tempdir()) 
[17:38:08.671]                   {
[17:38:08.671]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:08.671]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:08.671]                       tmpdir = path, fileext = ".rds")
[17:38:08.671]                     save_rds(obj, file)
[17:38:08.671]                   }
[17:38:08.671]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:08.671]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.671]                   {
[17:38:08.671]                     inherits <- base::inherits
[17:38:08.671]                     invokeRestart <- base::invokeRestart
[17:38:08.671]                     is.null <- base::is.null
[17:38:08.671]                     muffled <- FALSE
[17:38:08.671]                     if (inherits(cond, "message")) {
[17:38:08.671]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:08.671]                       if (muffled) 
[17:38:08.671]                         invokeRestart("muffleMessage")
[17:38:08.671]                     }
[17:38:08.671]                     else if (inherits(cond, "warning")) {
[17:38:08.671]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:08.671]                       if (muffled) 
[17:38:08.671]                         invokeRestart("muffleWarning")
[17:38:08.671]                     }
[17:38:08.671]                     else if (inherits(cond, "condition")) {
[17:38:08.671]                       if (!is.null(pattern)) {
[17:38:08.671]                         computeRestarts <- base::computeRestarts
[17:38:08.671]                         grepl <- base::grepl
[17:38:08.671]                         restarts <- computeRestarts(cond)
[17:38:08.671]                         for (restart in restarts) {
[17:38:08.671]                           name <- restart$name
[17:38:08.671]                           if (is.null(name)) 
[17:38:08.671]                             next
[17:38:08.671]                           if (!grepl(pattern, name)) 
[17:38:08.671]                             next
[17:38:08.671]                           invokeRestart(restart)
[17:38:08.671]                           muffled <- TRUE
[17:38:08.671]                           break
[17:38:08.671]                         }
[17:38:08.671]                       }
[17:38:08.671]                     }
[17:38:08.671]                     invisible(muffled)
[17:38:08.671]                   }
[17:38:08.671]                   muffleCondition(cond)
[17:38:08.671]                 })
[17:38:08.671]             }))
[17:38:08.671]             future::FutureResult(value = ...future.value$value, 
[17:38:08.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.671]                   ...future.rng), globalenv = if (FALSE) 
[17:38:08.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:08.671]                     ...future.globalenv.names))
[17:38:08.671]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:08.671]         }, condition = base::local({
[17:38:08.671]             c <- base::c
[17:38:08.671]             inherits <- base::inherits
[17:38:08.671]             invokeRestart <- base::invokeRestart
[17:38:08.671]             length <- base::length
[17:38:08.671]             list <- base::list
[17:38:08.671]             seq.int <- base::seq.int
[17:38:08.671]             signalCondition <- base::signalCondition
[17:38:08.671]             sys.calls <- base::sys.calls
[17:38:08.671]             `[[` <- base::`[[`
[17:38:08.671]             `+` <- base::`+`
[17:38:08.671]             `<<-` <- base::`<<-`
[17:38:08.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:08.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:08.671]                   3L)]
[17:38:08.671]             }
[17:38:08.671]             function(cond) {
[17:38:08.671]                 is_error <- inherits(cond, "error")
[17:38:08.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:08.671]                   NULL)
[17:38:08.671]                 if (is_error) {
[17:38:08.671]                   sessionInformation <- function() {
[17:38:08.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:08.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:08.671]                       search = base::search(), system = base::Sys.info())
[17:38:08.671]                   }
[17:38:08.671]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:08.671]                     cond$call), session = sessionInformation(), 
[17:38:08.671]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:08.671]                   signalCondition(cond)
[17:38:08.671]                 }
[17:38:08.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:08.671]                 "immediateCondition"))) {
[17:38:08.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:08.671]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:08.671]                   if (TRUE && !signal) {
[17:38:08.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.671]                     {
[17:38:08.671]                       inherits <- base::inherits
[17:38:08.671]                       invokeRestart <- base::invokeRestart
[17:38:08.671]                       is.null <- base::is.null
[17:38:08.671]                       muffled <- FALSE
[17:38:08.671]                       if (inherits(cond, "message")) {
[17:38:08.671]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.671]                         if (muffled) 
[17:38:08.671]                           invokeRestart("muffleMessage")
[17:38:08.671]                       }
[17:38:08.671]                       else if (inherits(cond, "warning")) {
[17:38:08.671]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.671]                         if (muffled) 
[17:38:08.671]                           invokeRestart("muffleWarning")
[17:38:08.671]                       }
[17:38:08.671]                       else if (inherits(cond, "condition")) {
[17:38:08.671]                         if (!is.null(pattern)) {
[17:38:08.671]                           computeRestarts <- base::computeRestarts
[17:38:08.671]                           grepl <- base::grepl
[17:38:08.671]                           restarts <- computeRestarts(cond)
[17:38:08.671]                           for (restart in restarts) {
[17:38:08.671]                             name <- restart$name
[17:38:08.671]                             if (is.null(name)) 
[17:38:08.671]                               next
[17:38:08.671]                             if (!grepl(pattern, name)) 
[17:38:08.671]                               next
[17:38:08.671]                             invokeRestart(restart)
[17:38:08.671]                             muffled <- TRUE
[17:38:08.671]                             break
[17:38:08.671]                           }
[17:38:08.671]                         }
[17:38:08.671]                       }
[17:38:08.671]                       invisible(muffled)
[17:38:08.671]                     }
[17:38:08.671]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.671]                   }
[17:38:08.671]                 }
[17:38:08.671]                 else {
[17:38:08.671]                   if (TRUE) {
[17:38:08.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.671]                     {
[17:38:08.671]                       inherits <- base::inherits
[17:38:08.671]                       invokeRestart <- base::invokeRestart
[17:38:08.671]                       is.null <- base::is.null
[17:38:08.671]                       muffled <- FALSE
[17:38:08.671]                       if (inherits(cond, "message")) {
[17:38:08.671]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.671]                         if (muffled) 
[17:38:08.671]                           invokeRestart("muffleMessage")
[17:38:08.671]                       }
[17:38:08.671]                       else if (inherits(cond, "warning")) {
[17:38:08.671]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.671]                         if (muffled) 
[17:38:08.671]                           invokeRestart("muffleWarning")
[17:38:08.671]                       }
[17:38:08.671]                       else if (inherits(cond, "condition")) {
[17:38:08.671]                         if (!is.null(pattern)) {
[17:38:08.671]                           computeRestarts <- base::computeRestarts
[17:38:08.671]                           grepl <- base::grepl
[17:38:08.671]                           restarts <- computeRestarts(cond)
[17:38:08.671]                           for (restart in restarts) {
[17:38:08.671]                             name <- restart$name
[17:38:08.671]                             if (is.null(name)) 
[17:38:08.671]                               next
[17:38:08.671]                             if (!grepl(pattern, name)) 
[17:38:08.671]                               next
[17:38:08.671]                             invokeRestart(restart)
[17:38:08.671]                             muffled <- TRUE
[17:38:08.671]                             break
[17:38:08.671]                           }
[17:38:08.671]                         }
[17:38:08.671]                       }
[17:38:08.671]                       invisible(muffled)
[17:38:08.671]                     }
[17:38:08.671]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.671]                   }
[17:38:08.671]                 }
[17:38:08.671]             }
[17:38:08.671]         }))
[17:38:08.671]     }, error = function(ex) {
[17:38:08.671]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:08.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.671]                 ...future.rng), started = ...future.startTime, 
[17:38:08.671]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:08.671]             version = "1.8"), class = "FutureResult")
[17:38:08.671]     }, finally = {
[17:38:08.671]         if (!identical(...future.workdir, getwd())) 
[17:38:08.671]             setwd(...future.workdir)
[17:38:08.671]         {
[17:38:08.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:08.671]                 ...future.oldOptions$nwarnings <- NULL
[17:38:08.671]             }
[17:38:08.671]             base::options(...future.oldOptions)
[17:38:08.671]             if (.Platform$OS.type == "windows") {
[17:38:08.671]                 old_names <- names(...future.oldEnvVars)
[17:38:08.671]                 envs <- base::Sys.getenv()
[17:38:08.671]                 names <- names(envs)
[17:38:08.671]                 common <- intersect(names, old_names)
[17:38:08.671]                 added <- setdiff(names, old_names)
[17:38:08.671]                 removed <- setdiff(old_names, names)
[17:38:08.671]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:08.671]                   envs[common]]
[17:38:08.671]                 NAMES <- toupper(changed)
[17:38:08.671]                 args <- list()
[17:38:08.671]                 for (kk in seq_along(NAMES)) {
[17:38:08.671]                   name <- changed[[kk]]
[17:38:08.671]                   NAME <- NAMES[[kk]]
[17:38:08.671]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.671]                     next
[17:38:08.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.671]                 }
[17:38:08.671]                 NAMES <- toupper(added)
[17:38:08.671]                 for (kk in seq_along(NAMES)) {
[17:38:08.671]                   name <- added[[kk]]
[17:38:08.671]                   NAME <- NAMES[[kk]]
[17:38:08.671]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.671]                     next
[17:38:08.671]                   args[[name]] <- ""
[17:38:08.671]                 }
[17:38:08.671]                 NAMES <- toupper(removed)
[17:38:08.671]                 for (kk in seq_along(NAMES)) {
[17:38:08.671]                   name <- removed[[kk]]
[17:38:08.671]                   NAME <- NAMES[[kk]]
[17:38:08.671]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.671]                     next
[17:38:08.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.671]                 }
[17:38:08.671]                 if (length(args) > 0) 
[17:38:08.671]                   base::do.call(base::Sys.setenv, args = args)
[17:38:08.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:08.671]             }
[17:38:08.671]             else {
[17:38:08.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:08.671]             }
[17:38:08.671]             {
[17:38:08.671]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:08.671]                   0L) {
[17:38:08.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:08.671]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:08.671]                   base::options(opts)
[17:38:08.671]                 }
[17:38:08.671]                 {
[17:38:08.671]                   {
[17:38:08.671]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:08.671]                     NULL
[17:38:08.671]                   }
[17:38:08.671]                   options(future.plan = NULL)
[17:38:08.671]                   if (is.na(NA_character_)) 
[17:38:08.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:08.671]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:08.671]                     .init = FALSE)
[17:38:08.671]                 }
[17:38:08.671]             }
[17:38:08.671]         }
[17:38:08.671]     })
[17:38:08.671]     if (TRUE) {
[17:38:08.671]         base::sink(type = "output", split = FALSE)
[17:38:08.671]         if (TRUE) {
[17:38:08.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:08.671]         }
[17:38:08.671]         else {
[17:38:08.671]             ...future.result["stdout"] <- base::list(NULL)
[17:38:08.671]         }
[17:38:08.671]         base::close(...future.stdout)
[17:38:08.671]         ...future.stdout <- NULL
[17:38:08.671]     }
[17:38:08.671]     ...future.result$conditions <- ...future.conditions
[17:38:08.671]     ...future.result$finished <- base::Sys.time()
[17:38:08.671]     ...future.result
[17:38:08.671] }
[17:38:08.675] assign_globals() ...
[17:38:08.675] List of 5
[17:38:08.675]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[17:38:08.675]  $ future.call.arguments    : list()
[17:38:08.675]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.675]  $ ...future.elements_ii    :List of 3
[17:38:08.675]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:38:08.675]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:38:08.675]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:38:08.675]  $ ...future.seeds_ii       : NULL
[17:38:08.675]  $ ...future.globals.maxSize: NULL
[17:38:08.675]  - attr(*, "where")=List of 5
[17:38:08.675]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:08.675]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:08.675]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:08.675]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:08.675]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:08.675]  - attr(*, "resolved")= logi FALSE
[17:38:08.675]  - attr(*, "total_size")= num 46960
[17:38:08.675]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.675]  - attr(*, "already-done")= logi TRUE
[17:38:08.688] - copied ‘...future.FUN’ to environment
[17:38:08.689] - copied ‘future.call.arguments’ to environment
[17:38:08.689] - copied ‘...future.elements_ii’ to environment
[17:38:08.689] - copied ‘...future.seeds_ii’ to environment
[17:38:08.689] - copied ‘...future.globals.maxSize’ to environment
[17:38:08.689] assign_globals() ... done
[17:38:08.690] requestCore(): workers = 2
[17:38:08.692] MulticoreFuture started
[17:38:08.693] - Launch lazy future ... done
[17:38:08.693] run() for ‘MulticoreFuture’ ... done
[17:38:08.694] Created future:
[17:38:08.694] plan(): Setting new future strategy stack:
[17:38:08.695] List of future strategies:
[17:38:08.695] 1. sequential:
[17:38:08.695]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:08.695]    - tweaked: FALSE
[17:38:08.695]    - call: NULL
[17:38:08.697] plan(): nbrOfWorkers() = 1
[17:38:08.699] plan(): Setting new future strategy stack:
[17:38:08.700] List of future strategies:
[17:38:08.700] 1. multicore:
[17:38:08.700]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:08.700]    - tweaked: FALSE
[17:38:08.700]    - call: plan(strategy)
[17:38:08.705] plan(): nbrOfWorkers() = 2
[17:38:08.695] MulticoreFuture:
[17:38:08.695] Label: ‘future_sapply-2’
[17:38:08.695] Expression:
[17:38:08.695] {
[17:38:08.695]     do.call(function(...) {
[17:38:08.695]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.695]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.695]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.695]             on.exit(options(oopts), add = TRUE)
[17:38:08.695]         }
[17:38:08.695]         {
[17:38:08.695]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.695]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.695]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.695]             })
[17:38:08.695]         }
[17:38:08.695]     }, args = future.call.arguments)
[17:38:08.695] }
[17:38:08.695] Lazy evaluation: FALSE
[17:38:08.695] Asynchronous evaluation: TRUE
[17:38:08.695] Local evaluation: TRUE
[17:38:08.695] Environment: R_GlobalEnv
[17:38:08.695] Capture standard output: TRUE
[17:38:08.695] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:08.695] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:08.695] Packages: 1 packages (‘stats’)
[17:38:08.695] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:08.695] Resolved: TRUE
[17:38:08.695] Value: <not collected>
[17:38:08.695] Conditions captured: <none>
[17:38:08.695] Early signaling: FALSE
[17:38:08.695] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:08.695] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.706] Chunk #2 of 2 ... DONE
[17:38:08.707] Launching 2 futures (chunks) ... DONE
[17:38:08.707] Resolving 2 futures (chunks) ...
[17:38:08.707] resolve() on list ...
[17:38:08.707]  recursive: 0
[17:38:08.707]  length: 2
[17:38:08.708] 
[17:38:08.708] Future #1
[17:38:08.708] result() for MulticoreFuture ...
[17:38:08.709] result() for MulticoreFuture ...
[17:38:08.710] result() for MulticoreFuture ... done
[17:38:08.710] result() for MulticoreFuture ... done
[17:38:08.710] result() for MulticoreFuture ...
[17:38:08.710] result() for MulticoreFuture ... done
[17:38:08.710] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:08.711] - nx: 2
[17:38:08.711] - relay: TRUE
[17:38:08.711] - stdout: TRUE
[17:38:08.711] - signal: TRUE
[17:38:08.711] - resignal: FALSE
[17:38:08.711] - force: TRUE
[17:38:08.712] - relayed: [n=2] FALSE, FALSE
[17:38:08.712] - queued futures: [n=2] FALSE, FALSE
[17:38:08.712]  - until=1
[17:38:08.712]  - relaying element #1
[17:38:08.713] result() for MulticoreFuture ...
[17:38:08.713] result() for MulticoreFuture ... done
[17:38:08.713] result() for MulticoreFuture ...
[17:38:08.713] result() for MulticoreFuture ... done
[17:38:08.713] result() for MulticoreFuture ...
[17:38:08.714] result() for MulticoreFuture ... done
[17:38:08.714] result() for MulticoreFuture ...
[17:38:08.714] result() for MulticoreFuture ... done
[17:38:08.714] - relayed: [n=2] TRUE, FALSE
[17:38:08.714] - queued futures: [n=2] TRUE, FALSE
[17:38:08.714] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:08.715]  length: 1 (resolved future 1)
[17:38:08.715] Future #2
[17:38:08.715] result() for MulticoreFuture ...
[17:38:08.716] result() for MulticoreFuture ...
[17:38:08.716] result() for MulticoreFuture ... done
[17:38:08.716] result() for MulticoreFuture ... done
[17:38:08.716] result() for MulticoreFuture ...
[17:38:08.717] result() for MulticoreFuture ... done
[17:38:08.717] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:08.717] - nx: 2
[17:38:08.717] - relay: TRUE
[17:38:08.717] - stdout: TRUE
[17:38:08.717] - signal: TRUE
[17:38:08.718] - resignal: FALSE
[17:38:08.718] - force: TRUE
[17:38:08.718] - relayed: [n=2] TRUE, FALSE
[17:38:08.718] - queued futures: [n=2] TRUE, FALSE
[17:38:08.718]  - until=2
[17:38:08.718]  - relaying element #2
[17:38:08.718] result() for MulticoreFuture ...
[17:38:08.719] result() for MulticoreFuture ... done
[17:38:08.719] result() for MulticoreFuture ...
[17:38:08.719] result() for MulticoreFuture ... done
[17:38:08.719] result() for MulticoreFuture ...
[17:38:08.719] result() for MulticoreFuture ... done
[17:38:08.719] result() for MulticoreFuture ...
[17:38:08.720] result() for MulticoreFuture ... done
[17:38:08.720] - relayed: [n=2] TRUE, TRUE
[17:38:08.720] - queued futures: [n=2] TRUE, TRUE
[17:38:08.720] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:08.720]  length: 0 (resolved future 2)
[17:38:08.720] Relaying remaining futures
[17:38:08.720] signalConditionsASAP(NULL, pos=0) ...
[17:38:08.720] - nx: 2
[17:38:08.720] - relay: TRUE
[17:38:08.721] - stdout: TRUE
[17:38:08.721] - signal: TRUE
[17:38:08.721] - resignal: FALSE
[17:38:08.721] - force: TRUE
[17:38:08.721] - relayed: [n=2] TRUE, TRUE
[17:38:08.721] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:08.721] - relayed: [n=2] TRUE, TRUE
[17:38:08.721] - queued futures: [n=2] TRUE, TRUE
[17:38:08.721] signalConditionsASAP(NULL, pos=0) ... done
[17:38:08.722] resolve() on list ... DONE
[17:38:08.722] result() for MulticoreFuture ...
[17:38:08.722] result() for MulticoreFuture ... done
[17:38:08.722] result() for MulticoreFuture ...
[17:38:08.722] result() for MulticoreFuture ... done
[17:38:08.722] result() for MulticoreFuture ...
[17:38:08.722] result() for MulticoreFuture ... done
[17:38:08.722] result() for MulticoreFuture ...
[17:38:08.722] result() for MulticoreFuture ... done
[17:38:08.723]  - Number of value chunks collected: 2
[17:38:08.723] Resolving 2 futures (chunks) ... DONE
[17:38:08.723] Reducing values from 2 chunks ...
[17:38:08.723]  - Number of values collected after concatenation: 7
[17:38:08.723]  - Number of values expected: 7
[17:38:08.723] Reducing values from 2 chunks ... DONE
[17:38:08.723] future_lapply() ... DONE
[17:38:08.724] future_lapply() ...
[17:38:08.730] Number of chunks: 2
[17:38:08.730] getGlobalsAndPackagesXApply() ...
[17:38:08.730]  - future.globals: TRUE
[17:38:08.730] getGlobalsAndPackages() ...
[17:38:08.731] Searching for globals...
[17:38:08.742] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:38:08.742] Searching for globals ... DONE
[17:38:08.742] Resolving globals: FALSE
[17:38:08.744] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[17:38:08.744] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[17:38:08.744] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:08.744] - packages: [2] ‘stats’, ‘future.apply’
[17:38:08.744] getGlobalsAndPackages() ... DONE
[17:38:08.745]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:08.745]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:38:08.745] Finding globals ... DONE
[17:38:08.745]  - use_args: TRUE
[17:38:08.745]  - Getting '...' globals ...
[17:38:08.745] resolve() on list ...
[17:38:08.745]  recursive: 0
[17:38:08.745]  length: 1
[17:38:08.746]  elements: ‘...’
[17:38:08.746]  length: 0 (resolved future 1)
[17:38:08.746] resolve() on list ... DONE
[17:38:08.746]    - '...' content: [n=0] 
[17:38:08.746] List of 1
[17:38:08.746]  $ ...: list()
[17:38:08.746]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.746]  - attr(*, "where")=List of 1
[17:38:08.746]   ..$ ...:<environment: 0x560801795178> 
[17:38:08.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.746]  - attr(*, "resolved")= logi TRUE
[17:38:08.746]  - attr(*, "total_size")= num NA
[17:38:08.749]  - Getting '...' globals ... DONE
[17:38:08.749] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:08.749] List of 8
[17:38:08.749]  $ ...future.FUN:function (x, ...)  
[17:38:08.749]  $ x_FUN        :function (x, na.rm = TRUE)  
[17:38:08.749]  $ times        : int 5
[17:38:08.749]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.749]  $ stop_if_not  :function (...)  
[17:38:08.749]  $ dim          : NULL
[17:38:08.749]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:08.749]  $ ...          : list()
[17:38:08.749]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.749]  - attr(*, "where")=List of 8
[17:38:08.749]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:08.749]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:08.749]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:08.749]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:08.749]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:08.749]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:08.749]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:08.749]   ..$ ...          :<environment: 0x560801795178> 
[17:38:08.749]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.749]  - attr(*, "resolved")= logi FALSE
[17:38:08.749]  - attr(*, "total_size")= num 141240
[17:38:08.758] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:38:08.758] getGlobalsAndPackagesXApply() ... DONE
[17:38:08.759] Number of futures (= number of chunks): 2
[17:38:08.759] Launching 2 futures (chunks) ...
[17:38:08.759] Chunk #1 of 2 ...
[17:38:08.759]  - Finding globals in 'X' for chunk #1 ...
[17:38:08.759] getGlobalsAndPackages() ...
[17:38:08.759] Searching for globals...
[17:38:08.760] 
[17:38:08.760] Searching for globals ... DONE
[17:38:08.760] - globals: [0] <none>
[17:38:08.760] getGlobalsAndPackages() ... DONE
[17:38:08.760]    + additional globals found: [n=0] 
[17:38:08.760]    + additional namespaces needed: [n=0] 
[17:38:08.760]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:08.760]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:08.761]  - seeds: <none>
[17:38:08.761]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.761] getGlobalsAndPackages() ...
[17:38:08.761] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.761] Resolving globals: FALSE
[17:38:08.761] Tweak future expression to call with '...' arguments ...
[17:38:08.761] {
[17:38:08.761]     do.call(function(...) {
[17:38:08.761]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.761]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.761]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.761]             on.exit(options(oopts), add = TRUE)
[17:38:08.761]         }
[17:38:08.761]         {
[17:38:08.761]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.761]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.761]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.761]             })
[17:38:08.761]         }
[17:38:08.761]     }, args = future.call.arguments)
[17:38:08.761] }
[17:38:08.762] Tweak future expression to call with '...' arguments ... DONE
[17:38:08.762] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.762] - packages: [2] ‘stats’, ‘future.apply’
[17:38:08.763] getGlobalsAndPackages() ... DONE
[17:38:08.763] run() for ‘Future’ ...
[17:38:08.763] - state: ‘created’
[17:38:08.763] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:08.767] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.767] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:08.767]   - Field: ‘label’
[17:38:08.767]   - Field: ‘local’
[17:38:08.767]   - Field: ‘owner’
[17:38:08.768]   - Field: ‘envir’
[17:38:08.768]   - Field: ‘workers’
[17:38:08.768]   - Field: ‘packages’
[17:38:08.768]   - Field: ‘gc’
[17:38:08.768]   - Field: ‘job’
[17:38:08.768]   - Field: ‘conditions’
[17:38:08.768]   - Field: ‘expr’
[17:38:08.768]   - Field: ‘uuid’
[17:38:08.768]   - Field: ‘seed’
[17:38:08.768]   - Field: ‘version’
[17:38:08.769]   - Field: ‘result’
[17:38:08.769]   - Field: ‘asynchronous’
[17:38:08.769]   - Field: ‘calls’
[17:38:08.769]   - Field: ‘globals’
[17:38:08.769]   - Field: ‘stdout’
[17:38:08.769]   - Field: ‘earlySignal’
[17:38:08.769]   - Field: ‘lazy’
[17:38:08.769]   - Field: ‘state’
[17:38:08.769] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:08.769] - Launch lazy future ...
[17:38:08.770] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:38:08.770] Packages needed by future strategies (n = 0): <none>
[17:38:08.770] {
[17:38:08.770]     {
[17:38:08.770]         {
[17:38:08.770]             ...future.startTime <- base::Sys.time()
[17:38:08.770]             {
[17:38:08.770]                 {
[17:38:08.770]                   {
[17:38:08.770]                     {
[17:38:08.770]                       {
[17:38:08.770]                         base::local({
[17:38:08.770]                           has_future <- base::requireNamespace("future", 
[17:38:08.770]                             quietly = TRUE)
[17:38:08.770]                           if (has_future) {
[17:38:08.770]                             ns <- base::getNamespace("future")
[17:38:08.770]                             version <- ns[[".package"]][["version"]]
[17:38:08.770]                             if (is.null(version)) 
[17:38:08.770]                               version <- utils::packageVersion("future")
[17:38:08.770]                           }
[17:38:08.770]                           else {
[17:38:08.770]                             version <- NULL
[17:38:08.770]                           }
[17:38:08.770]                           if (!has_future || version < "1.8.0") {
[17:38:08.770]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:08.770]                               "", base::R.version$version.string), 
[17:38:08.770]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:08.770]                                 base::R.version$platform, 8 * 
[17:38:08.770]                                   base::.Machine$sizeof.pointer), 
[17:38:08.770]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:08.770]                                 "release", "version")], collapse = " "), 
[17:38:08.770]                               hostname = base::Sys.info()[["nodename"]])
[17:38:08.770]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:08.770]                               info)
[17:38:08.770]                             info <- base::paste(info, collapse = "; ")
[17:38:08.770]                             if (!has_future) {
[17:38:08.770]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:08.770]                                 info)
[17:38:08.770]                             }
[17:38:08.770]                             else {
[17:38:08.770]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:08.770]                                 info, version)
[17:38:08.770]                             }
[17:38:08.770]                             base::stop(msg)
[17:38:08.770]                           }
[17:38:08.770]                         })
[17:38:08.770]                       }
[17:38:08.770]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:08.770]                       base::options(mc.cores = 1L)
[17:38:08.770]                     }
[17:38:08.770]                     base::local({
[17:38:08.770]                       for (pkg in c("stats", "future.apply")) {
[17:38:08.770]                         base::loadNamespace(pkg)
[17:38:08.770]                         base::library(pkg, character.only = TRUE)
[17:38:08.770]                       }
[17:38:08.770]                     })
[17:38:08.770]                   }
[17:38:08.770]                   ...future.strategy.old <- future::plan("list")
[17:38:08.770]                   options(future.plan = NULL)
[17:38:08.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:08.770]                 }
[17:38:08.770]                 ...future.workdir <- getwd()
[17:38:08.770]             }
[17:38:08.770]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:08.770]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:08.770]         }
[17:38:08.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:08.770]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:08.770]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:08.770]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:08.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:08.770]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:08.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:08.770]             base::names(...future.oldOptions))
[17:38:08.770]     }
[17:38:08.770]     if (FALSE) {
[17:38:08.770]     }
[17:38:08.770]     else {
[17:38:08.770]         if (TRUE) {
[17:38:08.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:08.770]                 open = "w")
[17:38:08.770]         }
[17:38:08.770]         else {
[17:38:08.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:08.770]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:08.770]         }
[17:38:08.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:08.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:08.770]             base::sink(type = "output", split = FALSE)
[17:38:08.770]             base::close(...future.stdout)
[17:38:08.770]         }, add = TRUE)
[17:38:08.770]     }
[17:38:08.770]     ...future.frame <- base::sys.nframe()
[17:38:08.770]     ...future.conditions <- base::list()
[17:38:08.770]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:08.770]     if (FALSE) {
[17:38:08.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:08.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:08.770]     }
[17:38:08.770]     ...future.result <- base::tryCatch({
[17:38:08.770]         base::withCallingHandlers({
[17:38:08.770]             ...future.value <- base::withVisible(base::local({
[17:38:08.770]                 withCallingHandlers({
[17:38:08.770]                   {
[17:38:08.770]                     do.call(function(...) {
[17:38:08.770]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.770]                       if (!identical(...future.globals.maxSize.org, 
[17:38:08.770]                         ...future.globals.maxSize)) {
[17:38:08.770]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.770]                         on.exit(options(oopts), add = TRUE)
[17:38:08.770]                       }
[17:38:08.770]                       {
[17:38:08.770]                         lapply(seq_along(...future.elements_ii), 
[17:38:08.770]                           FUN = function(jj) {
[17:38:08.770]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.770]                             ...future.FUN(...future.X_jj, ...)
[17:38:08.770]                           })
[17:38:08.770]                       }
[17:38:08.770]                     }, args = future.call.arguments)
[17:38:08.770]                   }
[17:38:08.770]                 }, immediateCondition = function(cond) {
[17:38:08.770]                   save_rds <- function (object, pathname, ...) 
[17:38:08.770]                   {
[17:38:08.770]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:08.770]                     if (file_test("-f", pathname_tmp)) {
[17:38:08.770]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.770]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:08.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.770]                         fi_tmp[["mtime"]])
[17:38:08.770]                     }
[17:38:08.770]                     tryCatch({
[17:38:08.770]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:08.770]                     }, error = function(ex) {
[17:38:08.770]                       msg <- conditionMessage(ex)
[17:38:08.770]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.770]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:08.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.770]                         fi_tmp[["mtime"]], msg)
[17:38:08.770]                       ex$message <- msg
[17:38:08.770]                       stop(ex)
[17:38:08.770]                     })
[17:38:08.770]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:08.770]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:08.770]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:08.770]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.770]                       fi <- file.info(pathname)
[17:38:08.770]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:08.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.770]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:08.770]                         fi[["size"]], fi[["mtime"]])
[17:38:08.770]                       stop(msg)
[17:38:08.770]                     }
[17:38:08.770]                     invisible(pathname)
[17:38:08.770]                   }
[17:38:08.770]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:08.770]                     rootPath = tempdir()) 
[17:38:08.770]                   {
[17:38:08.770]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:08.770]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:08.770]                       tmpdir = path, fileext = ".rds")
[17:38:08.770]                     save_rds(obj, file)
[17:38:08.770]                   }
[17:38:08.770]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:08.770]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.770]                   {
[17:38:08.770]                     inherits <- base::inherits
[17:38:08.770]                     invokeRestart <- base::invokeRestart
[17:38:08.770]                     is.null <- base::is.null
[17:38:08.770]                     muffled <- FALSE
[17:38:08.770]                     if (inherits(cond, "message")) {
[17:38:08.770]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:08.770]                       if (muffled) 
[17:38:08.770]                         invokeRestart("muffleMessage")
[17:38:08.770]                     }
[17:38:08.770]                     else if (inherits(cond, "warning")) {
[17:38:08.770]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:08.770]                       if (muffled) 
[17:38:08.770]                         invokeRestart("muffleWarning")
[17:38:08.770]                     }
[17:38:08.770]                     else if (inherits(cond, "condition")) {
[17:38:08.770]                       if (!is.null(pattern)) {
[17:38:08.770]                         computeRestarts <- base::computeRestarts
[17:38:08.770]                         grepl <- base::grepl
[17:38:08.770]                         restarts <- computeRestarts(cond)
[17:38:08.770]                         for (restart in restarts) {
[17:38:08.770]                           name <- restart$name
[17:38:08.770]                           if (is.null(name)) 
[17:38:08.770]                             next
[17:38:08.770]                           if (!grepl(pattern, name)) 
[17:38:08.770]                             next
[17:38:08.770]                           invokeRestart(restart)
[17:38:08.770]                           muffled <- TRUE
[17:38:08.770]                           break
[17:38:08.770]                         }
[17:38:08.770]                       }
[17:38:08.770]                     }
[17:38:08.770]                     invisible(muffled)
[17:38:08.770]                   }
[17:38:08.770]                   muffleCondition(cond)
[17:38:08.770]                 })
[17:38:08.770]             }))
[17:38:08.770]             future::FutureResult(value = ...future.value$value, 
[17:38:08.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.770]                   ...future.rng), globalenv = if (FALSE) 
[17:38:08.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:08.770]                     ...future.globalenv.names))
[17:38:08.770]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:08.770]         }, condition = base::local({
[17:38:08.770]             c <- base::c
[17:38:08.770]             inherits <- base::inherits
[17:38:08.770]             invokeRestart <- base::invokeRestart
[17:38:08.770]             length <- base::length
[17:38:08.770]             list <- base::list
[17:38:08.770]             seq.int <- base::seq.int
[17:38:08.770]             signalCondition <- base::signalCondition
[17:38:08.770]             sys.calls <- base::sys.calls
[17:38:08.770]             `[[` <- base::`[[`
[17:38:08.770]             `+` <- base::`+`
[17:38:08.770]             `<<-` <- base::`<<-`
[17:38:08.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:08.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:08.770]                   3L)]
[17:38:08.770]             }
[17:38:08.770]             function(cond) {
[17:38:08.770]                 is_error <- inherits(cond, "error")
[17:38:08.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:08.770]                   NULL)
[17:38:08.770]                 if (is_error) {
[17:38:08.770]                   sessionInformation <- function() {
[17:38:08.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:08.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:08.770]                       search = base::search(), system = base::Sys.info())
[17:38:08.770]                   }
[17:38:08.770]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:08.770]                     cond$call), session = sessionInformation(), 
[17:38:08.770]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:08.770]                   signalCondition(cond)
[17:38:08.770]                 }
[17:38:08.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:08.770]                 "immediateCondition"))) {
[17:38:08.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:08.770]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:08.770]                   if (TRUE && !signal) {
[17:38:08.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.770]                     {
[17:38:08.770]                       inherits <- base::inherits
[17:38:08.770]                       invokeRestart <- base::invokeRestart
[17:38:08.770]                       is.null <- base::is.null
[17:38:08.770]                       muffled <- FALSE
[17:38:08.770]                       if (inherits(cond, "message")) {
[17:38:08.770]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.770]                         if (muffled) 
[17:38:08.770]                           invokeRestart("muffleMessage")
[17:38:08.770]                       }
[17:38:08.770]                       else if (inherits(cond, "warning")) {
[17:38:08.770]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.770]                         if (muffled) 
[17:38:08.770]                           invokeRestart("muffleWarning")
[17:38:08.770]                       }
[17:38:08.770]                       else if (inherits(cond, "condition")) {
[17:38:08.770]                         if (!is.null(pattern)) {
[17:38:08.770]                           computeRestarts <- base::computeRestarts
[17:38:08.770]                           grepl <- base::grepl
[17:38:08.770]                           restarts <- computeRestarts(cond)
[17:38:08.770]                           for (restart in restarts) {
[17:38:08.770]                             name <- restart$name
[17:38:08.770]                             if (is.null(name)) 
[17:38:08.770]                               next
[17:38:08.770]                             if (!grepl(pattern, name)) 
[17:38:08.770]                               next
[17:38:08.770]                             invokeRestart(restart)
[17:38:08.770]                             muffled <- TRUE
[17:38:08.770]                             break
[17:38:08.770]                           }
[17:38:08.770]                         }
[17:38:08.770]                       }
[17:38:08.770]                       invisible(muffled)
[17:38:08.770]                     }
[17:38:08.770]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.770]                   }
[17:38:08.770]                 }
[17:38:08.770]                 else {
[17:38:08.770]                   if (TRUE) {
[17:38:08.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.770]                     {
[17:38:08.770]                       inherits <- base::inherits
[17:38:08.770]                       invokeRestart <- base::invokeRestart
[17:38:08.770]                       is.null <- base::is.null
[17:38:08.770]                       muffled <- FALSE
[17:38:08.770]                       if (inherits(cond, "message")) {
[17:38:08.770]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.770]                         if (muffled) 
[17:38:08.770]                           invokeRestart("muffleMessage")
[17:38:08.770]                       }
[17:38:08.770]                       else if (inherits(cond, "warning")) {
[17:38:08.770]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.770]                         if (muffled) 
[17:38:08.770]                           invokeRestart("muffleWarning")
[17:38:08.770]                       }
[17:38:08.770]                       else if (inherits(cond, "condition")) {
[17:38:08.770]                         if (!is.null(pattern)) {
[17:38:08.770]                           computeRestarts <- base::computeRestarts
[17:38:08.770]                           grepl <- base::grepl
[17:38:08.770]                           restarts <- computeRestarts(cond)
[17:38:08.770]                           for (restart in restarts) {
[17:38:08.770]                             name <- restart$name
[17:38:08.770]                             if (is.null(name)) 
[17:38:08.770]                               next
[17:38:08.770]                             if (!grepl(pattern, name)) 
[17:38:08.770]                               next
[17:38:08.770]                             invokeRestart(restart)
[17:38:08.770]                             muffled <- TRUE
[17:38:08.770]                             break
[17:38:08.770]                           }
[17:38:08.770]                         }
[17:38:08.770]                       }
[17:38:08.770]                       invisible(muffled)
[17:38:08.770]                     }
[17:38:08.770]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.770]                   }
[17:38:08.770]                 }
[17:38:08.770]             }
[17:38:08.770]         }))
[17:38:08.770]     }, error = function(ex) {
[17:38:08.770]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:08.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.770]                 ...future.rng), started = ...future.startTime, 
[17:38:08.770]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:08.770]             version = "1.8"), class = "FutureResult")
[17:38:08.770]     }, finally = {
[17:38:08.770]         if (!identical(...future.workdir, getwd())) 
[17:38:08.770]             setwd(...future.workdir)
[17:38:08.770]         {
[17:38:08.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:08.770]                 ...future.oldOptions$nwarnings <- NULL
[17:38:08.770]             }
[17:38:08.770]             base::options(...future.oldOptions)
[17:38:08.770]             if (.Platform$OS.type == "windows") {
[17:38:08.770]                 old_names <- names(...future.oldEnvVars)
[17:38:08.770]                 envs <- base::Sys.getenv()
[17:38:08.770]                 names <- names(envs)
[17:38:08.770]                 common <- intersect(names, old_names)
[17:38:08.770]                 added <- setdiff(names, old_names)
[17:38:08.770]                 removed <- setdiff(old_names, names)
[17:38:08.770]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:08.770]                   envs[common]]
[17:38:08.770]                 NAMES <- toupper(changed)
[17:38:08.770]                 args <- list()
[17:38:08.770]                 for (kk in seq_along(NAMES)) {
[17:38:08.770]                   name <- changed[[kk]]
[17:38:08.770]                   NAME <- NAMES[[kk]]
[17:38:08.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.770]                     next
[17:38:08.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.770]                 }
[17:38:08.770]                 NAMES <- toupper(added)
[17:38:08.770]                 for (kk in seq_along(NAMES)) {
[17:38:08.770]                   name <- added[[kk]]
[17:38:08.770]                   NAME <- NAMES[[kk]]
[17:38:08.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.770]                     next
[17:38:08.770]                   args[[name]] <- ""
[17:38:08.770]                 }
[17:38:08.770]                 NAMES <- toupper(removed)
[17:38:08.770]                 for (kk in seq_along(NAMES)) {
[17:38:08.770]                   name <- removed[[kk]]
[17:38:08.770]                   NAME <- NAMES[[kk]]
[17:38:08.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.770]                     next
[17:38:08.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.770]                 }
[17:38:08.770]                 if (length(args) > 0) 
[17:38:08.770]                   base::do.call(base::Sys.setenv, args = args)
[17:38:08.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:08.770]             }
[17:38:08.770]             else {
[17:38:08.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:08.770]             }
[17:38:08.770]             {
[17:38:08.770]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:08.770]                   0L) {
[17:38:08.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:08.770]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:08.770]                   base::options(opts)
[17:38:08.770]                 }
[17:38:08.770]                 {
[17:38:08.770]                   {
[17:38:08.770]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:08.770]                     NULL
[17:38:08.770]                   }
[17:38:08.770]                   options(future.plan = NULL)
[17:38:08.770]                   if (is.na(NA_character_)) 
[17:38:08.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:08.770]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:08.770]                     .init = FALSE)
[17:38:08.770]                 }
[17:38:08.770]             }
[17:38:08.770]         }
[17:38:08.770]     })
[17:38:08.770]     if (TRUE) {
[17:38:08.770]         base::sink(type = "output", split = FALSE)
[17:38:08.770]         if (TRUE) {
[17:38:08.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:08.770]         }
[17:38:08.770]         else {
[17:38:08.770]             ...future.result["stdout"] <- base::list(NULL)
[17:38:08.770]         }
[17:38:08.770]         base::close(...future.stdout)
[17:38:08.770]         ...future.stdout <- NULL
[17:38:08.770]     }
[17:38:08.770]     ...future.result$conditions <- ...future.conditions
[17:38:08.770]     ...future.result$finished <- base::Sys.time()
[17:38:08.770]     ...future.result
[17:38:08.770] }
[17:38:08.773] assign_globals() ...
[17:38:08.773] List of 11
[17:38:08.773]  $ ...future.FUN            :function (x, ...)  
[17:38:08.773]  $ x_FUN                    :function (x, na.rm = TRUE)  
[17:38:08.773]  $ times                    : int 5
[17:38:08.773]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.773]  $ stop_if_not              :function (...)  
[17:38:08.773]  $ dim                      : NULL
[17:38:08.773]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:08.773]  $ future.call.arguments    : list()
[17:38:08.773]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.773]  $ ...future.elements_ii    :List of 4
[17:38:08.773]   ..$ : int [1:3] 1 2 3
[17:38:08.773]   ..$ : int [1:4] 1 2 3 4
[17:38:08.773]   ..$ : int [1:5] 1 2 3 4 5
[17:38:08.773]   ..$ : int [1:6] 1 2 3 4 5 6
[17:38:08.773]  $ ...future.seeds_ii       : NULL
[17:38:08.773]  $ ...future.globals.maxSize: NULL
[17:38:08.773]  - attr(*, "where")=List of 11
[17:38:08.773]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:08.773]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:08.773]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:08.773]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:08.773]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:08.773]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:08.773]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:08.773]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:08.773]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:08.773]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:08.773]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:08.773]  - attr(*, "resolved")= logi FALSE
[17:38:08.773]  - attr(*, "total_size")= num 141240
[17:38:08.773]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.773]  - attr(*, "already-done")= logi TRUE
[17:38:08.786] - copied ‘...future.FUN’ to environment
[17:38:08.786] - copied ‘x_FUN’ to environment
[17:38:08.786] - copied ‘times’ to environment
[17:38:08.786] - copied ‘stopf’ to environment
[17:38:08.786] - copied ‘stop_if_not’ to environment
[17:38:08.787] - copied ‘dim’ to environment
[17:38:08.787] - copied ‘valid_types’ to environment
[17:38:08.787] - copied ‘future.call.arguments’ to environment
[17:38:08.787] - copied ‘...future.elements_ii’ to environment
[17:38:08.787] - copied ‘...future.seeds_ii’ to environment
[17:38:08.787] - copied ‘...future.globals.maxSize’ to environment
[17:38:08.788] assign_globals() ... done
[17:38:08.788] requestCore(): workers = 2
[17:38:08.791] MulticoreFuture started
[17:38:08.792] - Launch lazy future ... done
[17:38:08.793] run() for ‘MulticoreFuture’ ... done
[17:38:08.794] Created future:
[17:38:08.795] plan(): Setting new future strategy stack:
[17:38:08.795] List of future strategies:
[17:38:08.795] 1. sequential:
[17:38:08.795]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:08.795]    - tweaked: FALSE
[17:38:08.795]    - call: NULL
[17:38:08.797] plan(): nbrOfWorkers() = 1
[17:38:08.802] plan(): Setting new future strategy stack:
[17:38:08.803] List of future strategies:
[17:38:08.803] 1. multicore:
[17:38:08.803]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:08.803]    - tweaked: FALSE
[17:38:08.803]    - call: plan(strategy)
[17:38:08.794] MulticoreFuture:
[17:38:08.794] Label: ‘future_vapply-1’
[17:38:08.794] Expression:
[17:38:08.794] {
[17:38:08.794]     do.call(function(...) {
[17:38:08.794]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.794]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.794]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.794]             on.exit(options(oopts), add = TRUE)
[17:38:08.794]         }
[17:38:08.794]         {
[17:38:08.794]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.794]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.794]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.794]             })
[17:38:08.794]         }
[17:38:08.794]     }, args = future.call.arguments)
[17:38:08.794] }
[17:38:08.794] Lazy evaluation: FALSE
[17:38:08.794] Asynchronous evaluation: TRUE
[17:38:08.794] Local evaluation: TRUE
[17:38:08.794] Environment: R_GlobalEnv
[17:38:08.794] Capture standard output: TRUE
[17:38:08.794] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:08.794] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:08.794] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:38:08.794] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:08.794] Resolved: FALSE
[17:38:08.794] Value: <not collected>
[17:38:08.794] Conditions captured: <none>
[17:38:08.794] Early signaling: FALSE
[17:38:08.794] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:08.794] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.810] Chunk #1 of 2 ... DONE
[17:38:08.810] Chunk #2 of 2 ...
[17:38:08.811]  - Finding globals in 'X' for chunk #2 ...
[17:38:08.811] getGlobalsAndPackages() ...
[17:38:08.811] Searching for globals...
[17:38:08.812] plan(): nbrOfWorkers() = 2
[17:38:08.812] 
[17:38:08.813] Searching for globals ... DONE
[17:38:08.813] - globals: [0] <none>
[17:38:08.813] getGlobalsAndPackages() ... DONE
[17:38:08.813]    + additional globals found: [n=0] 
[17:38:08.813]    + additional namespaces needed: [n=0] 
[17:38:08.814]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:08.814]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:08.814]  - seeds: <none>
[17:38:08.814]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.814] getGlobalsAndPackages() ...
[17:38:08.814] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.815] Resolving globals: FALSE
[17:38:08.815] Tweak future expression to call with '...' arguments ...
[17:38:08.815] {
[17:38:08.815]     do.call(function(...) {
[17:38:08.815]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.815]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.815]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.815]             on.exit(options(oopts), add = TRUE)
[17:38:08.815]         }
[17:38:08.815]         {
[17:38:08.815]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.815]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.815]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.815]             })
[17:38:08.815]         }
[17:38:08.815]     }, args = future.call.arguments)
[17:38:08.815] }
[17:38:08.816] Tweak future expression to call with '...' arguments ... DONE
[17:38:08.817] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.817] - packages: [2] ‘stats’, ‘future.apply’
[17:38:08.817] getGlobalsAndPackages() ... DONE
[17:38:08.818] run() for ‘Future’ ...
[17:38:08.818] - state: ‘created’
[17:38:08.818] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:08.823] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.823] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:08.823]   - Field: ‘label’
[17:38:08.823]   - Field: ‘local’
[17:38:08.824]   - Field: ‘owner’
[17:38:08.824]   - Field: ‘envir’
[17:38:08.824]   - Field: ‘workers’
[17:38:08.824]   - Field: ‘packages’
[17:38:08.824]   - Field: ‘gc’
[17:38:08.824]   - Field: ‘job’
[17:38:08.825]   - Field: ‘conditions’
[17:38:08.825]   - Field: ‘expr’
[17:38:08.825]   - Field: ‘uuid’
[17:38:08.825]   - Field: ‘seed’
[17:38:08.825]   - Field: ‘version’
[17:38:08.825]   - Field: ‘result’
[17:38:08.825]   - Field: ‘asynchronous’
[17:38:08.825]   - Field: ‘calls’
[17:38:08.826]   - Field: ‘globals’
[17:38:08.826]   - Field: ‘stdout’
[17:38:08.826]   - Field: ‘earlySignal’
[17:38:08.826]   - Field: ‘lazy’
[17:38:08.826]   - Field: ‘state’
[17:38:08.826] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:08.826] - Launch lazy future ...
[17:38:08.827] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:38:08.827] Packages needed by future strategies (n = 0): <none>
[17:38:08.828] {
[17:38:08.828]     {
[17:38:08.828]         {
[17:38:08.828]             ...future.startTime <- base::Sys.time()
[17:38:08.828]             {
[17:38:08.828]                 {
[17:38:08.828]                   {
[17:38:08.828]                     {
[17:38:08.828]                       {
[17:38:08.828]                         base::local({
[17:38:08.828]                           has_future <- base::requireNamespace("future", 
[17:38:08.828]                             quietly = TRUE)
[17:38:08.828]                           if (has_future) {
[17:38:08.828]                             ns <- base::getNamespace("future")
[17:38:08.828]                             version <- ns[[".package"]][["version"]]
[17:38:08.828]                             if (is.null(version)) 
[17:38:08.828]                               version <- utils::packageVersion("future")
[17:38:08.828]                           }
[17:38:08.828]                           else {
[17:38:08.828]                             version <- NULL
[17:38:08.828]                           }
[17:38:08.828]                           if (!has_future || version < "1.8.0") {
[17:38:08.828]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:08.828]                               "", base::R.version$version.string), 
[17:38:08.828]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:08.828]                                 base::R.version$platform, 8 * 
[17:38:08.828]                                   base::.Machine$sizeof.pointer), 
[17:38:08.828]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:08.828]                                 "release", "version")], collapse = " "), 
[17:38:08.828]                               hostname = base::Sys.info()[["nodename"]])
[17:38:08.828]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:08.828]                               info)
[17:38:08.828]                             info <- base::paste(info, collapse = "; ")
[17:38:08.828]                             if (!has_future) {
[17:38:08.828]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:08.828]                                 info)
[17:38:08.828]                             }
[17:38:08.828]                             else {
[17:38:08.828]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:08.828]                                 info, version)
[17:38:08.828]                             }
[17:38:08.828]                             base::stop(msg)
[17:38:08.828]                           }
[17:38:08.828]                         })
[17:38:08.828]                       }
[17:38:08.828]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:08.828]                       base::options(mc.cores = 1L)
[17:38:08.828]                     }
[17:38:08.828]                     base::local({
[17:38:08.828]                       for (pkg in c("stats", "future.apply")) {
[17:38:08.828]                         base::loadNamespace(pkg)
[17:38:08.828]                         base::library(pkg, character.only = TRUE)
[17:38:08.828]                       }
[17:38:08.828]                     })
[17:38:08.828]                   }
[17:38:08.828]                   ...future.strategy.old <- future::plan("list")
[17:38:08.828]                   options(future.plan = NULL)
[17:38:08.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:08.828]                 }
[17:38:08.828]                 ...future.workdir <- getwd()
[17:38:08.828]             }
[17:38:08.828]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:08.828]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:08.828]         }
[17:38:08.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:08.828]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:08.828]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:08.828]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:08.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:08.828]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:08.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:08.828]             base::names(...future.oldOptions))
[17:38:08.828]     }
[17:38:08.828]     if (FALSE) {
[17:38:08.828]     }
[17:38:08.828]     else {
[17:38:08.828]         if (TRUE) {
[17:38:08.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:08.828]                 open = "w")
[17:38:08.828]         }
[17:38:08.828]         else {
[17:38:08.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:08.828]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:08.828]         }
[17:38:08.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:08.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:08.828]             base::sink(type = "output", split = FALSE)
[17:38:08.828]             base::close(...future.stdout)
[17:38:08.828]         }, add = TRUE)
[17:38:08.828]     }
[17:38:08.828]     ...future.frame <- base::sys.nframe()
[17:38:08.828]     ...future.conditions <- base::list()
[17:38:08.828]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:08.828]     if (FALSE) {
[17:38:08.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:08.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:08.828]     }
[17:38:08.828]     ...future.result <- base::tryCatch({
[17:38:08.828]         base::withCallingHandlers({
[17:38:08.828]             ...future.value <- base::withVisible(base::local({
[17:38:08.828]                 withCallingHandlers({
[17:38:08.828]                   {
[17:38:08.828]                     do.call(function(...) {
[17:38:08.828]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.828]                       if (!identical(...future.globals.maxSize.org, 
[17:38:08.828]                         ...future.globals.maxSize)) {
[17:38:08.828]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.828]                         on.exit(options(oopts), add = TRUE)
[17:38:08.828]                       }
[17:38:08.828]                       {
[17:38:08.828]                         lapply(seq_along(...future.elements_ii), 
[17:38:08.828]                           FUN = function(jj) {
[17:38:08.828]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.828]                             ...future.FUN(...future.X_jj, ...)
[17:38:08.828]                           })
[17:38:08.828]                       }
[17:38:08.828]                     }, args = future.call.arguments)
[17:38:08.828]                   }
[17:38:08.828]                 }, immediateCondition = function(cond) {
[17:38:08.828]                   save_rds <- function (object, pathname, ...) 
[17:38:08.828]                   {
[17:38:08.828]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:08.828]                     if (file_test("-f", pathname_tmp)) {
[17:38:08.828]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.828]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:08.828]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.828]                         fi_tmp[["mtime"]])
[17:38:08.828]                     }
[17:38:08.828]                     tryCatch({
[17:38:08.828]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:08.828]                     }, error = function(ex) {
[17:38:08.828]                       msg <- conditionMessage(ex)
[17:38:08.828]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.828]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:08.828]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.828]                         fi_tmp[["mtime"]], msg)
[17:38:08.828]                       ex$message <- msg
[17:38:08.828]                       stop(ex)
[17:38:08.828]                     })
[17:38:08.828]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:08.828]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:08.828]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:08.828]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.828]                       fi <- file.info(pathname)
[17:38:08.828]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:08.828]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.828]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:08.828]                         fi[["size"]], fi[["mtime"]])
[17:38:08.828]                       stop(msg)
[17:38:08.828]                     }
[17:38:08.828]                     invisible(pathname)
[17:38:08.828]                   }
[17:38:08.828]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:08.828]                     rootPath = tempdir()) 
[17:38:08.828]                   {
[17:38:08.828]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:08.828]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:08.828]                       tmpdir = path, fileext = ".rds")
[17:38:08.828]                     save_rds(obj, file)
[17:38:08.828]                   }
[17:38:08.828]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:08.828]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.828]                   {
[17:38:08.828]                     inherits <- base::inherits
[17:38:08.828]                     invokeRestart <- base::invokeRestart
[17:38:08.828]                     is.null <- base::is.null
[17:38:08.828]                     muffled <- FALSE
[17:38:08.828]                     if (inherits(cond, "message")) {
[17:38:08.828]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:08.828]                       if (muffled) 
[17:38:08.828]                         invokeRestart("muffleMessage")
[17:38:08.828]                     }
[17:38:08.828]                     else if (inherits(cond, "warning")) {
[17:38:08.828]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:08.828]                       if (muffled) 
[17:38:08.828]                         invokeRestart("muffleWarning")
[17:38:08.828]                     }
[17:38:08.828]                     else if (inherits(cond, "condition")) {
[17:38:08.828]                       if (!is.null(pattern)) {
[17:38:08.828]                         computeRestarts <- base::computeRestarts
[17:38:08.828]                         grepl <- base::grepl
[17:38:08.828]                         restarts <- computeRestarts(cond)
[17:38:08.828]                         for (restart in restarts) {
[17:38:08.828]                           name <- restart$name
[17:38:08.828]                           if (is.null(name)) 
[17:38:08.828]                             next
[17:38:08.828]                           if (!grepl(pattern, name)) 
[17:38:08.828]                             next
[17:38:08.828]                           invokeRestart(restart)
[17:38:08.828]                           muffled <- TRUE
[17:38:08.828]                           break
[17:38:08.828]                         }
[17:38:08.828]                       }
[17:38:08.828]                     }
[17:38:08.828]                     invisible(muffled)
[17:38:08.828]                   }
[17:38:08.828]                   muffleCondition(cond)
[17:38:08.828]                 })
[17:38:08.828]             }))
[17:38:08.828]             future::FutureResult(value = ...future.value$value, 
[17:38:08.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.828]                   ...future.rng), globalenv = if (FALSE) 
[17:38:08.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:08.828]                     ...future.globalenv.names))
[17:38:08.828]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:08.828]         }, condition = base::local({
[17:38:08.828]             c <- base::c
[17:38:08.828]             inherits <- base::inherits
[17:38:08.828]             invokeRestart <- base::invokeRestart
[17:38:08.828]             length <- base::length
[17:38:08.828]             list <- base::list
[17:38:08.828]             seq.int <- base::seq.int
[17:38:08.828]             signalCondition <- base::signalCondition
[17:38:08.828]             sys.calls <- base::sys.calls
[17:38:08.828]             `[[` <- base::`[[`
[17:38:08.828]             `+` <- base::`+`
[17:38:08.828]             `<<-` <- base::`<<-`
[17:38:08.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:08.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:08.828]                   3L)]
[17:38:08.828]             }
[17:38:08.828]             function(cond) {
[17:38:08.828]                 is_error <- inherits(cond, "error")
[17:38:08.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:08.828]                   NULL)
[17:38:08.828]                 if (is_error) {
[17:38:08.828]                   sessionInformation <- function() {
[17:38:08.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:08.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:08.828]                       search = base::search(), system = base::Sys.info())
[17:38:08.828]                   }
[17:38:08.828]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:08.828]                     cond$call), session = sessionInformation(), 
[17:38:08.828]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:08.828]                   signalCondition(cond)
[17:38:08.828]                 }
[17:38:08.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:08.828]                 "immediateCondition"))) {
[17:38:08.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:08.828]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:08.828]                   if (TRUE && !signal) {
[17:38:08.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.828]                     {
[17:38:08.828]                       inherits <- base::inherits
[17:38:08.828]                       invokeRestart <- base::invokeRestart
[17:38:08.828]                       is.null <- base::is.null
[17:38:08.828]                       muffled <- FALSE
[17:38:08.828]                       if (inherits(cond, "message")) {
[17:38:08.828]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.828]                         if (muffled) 
[17:38:08.828]                           invokeRestart("muffleMessage")
[17:38:08.828]                       }
[17:38:08.828]                       else if (inherits(cond, "warning")) {
[17:38:08.828]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.828]                         if (muffled) 
[17:38:08.828]                           invokeRestart("muffleWarning")
[17:38:08.828]                       }
[17:38:08.828]                       else if (inherits(cond, "condition")) {
[17:38:08.828]                         if (!is.null(pattern)) {
[17:38:08.828]                           computeRestarts <- base::computeRestarts
[17:38:08.828]                           grepl <- base::grepl
[17:38:08.828]                           restarts <- computeRestarts(cond)
[17:38:08.828]                           for (restart in restarts) {
[17:38:08.828]                             name <- restart$name
[17:38:08.828]                             if (is.null(name)) 
[17:38:08.828]                               next
[17:38:08.828]                             if (!grepl(pattern, name)) 
[17:38:08.828]                               next
[17:38:08.828]                             invokeRestart(restart)
[17:38:08.828]                             muffled <- TRUE
[17:38:08.828]                             break
[17:38:08.828]                           }
[17:38:08.828]                         }
[17:38:08.828]                       }
[17:38:08.828]                       invisible(muffled)
[17:38:08.828]                     }
[17:38:08.828]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.828]                   }
[17:38:08.828]                 }
[17:38:08.828]                 else {
[17:38:08.828]                   if (TRUE) {
[17:38:08.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.828]                     {
[17:38:08.828]                       inherits <- base::inherits
[17:38:08.828]                       invokeRestart <- base::invokeRestart
[17:38:08.828]                       is.null <- base::is.null
[17:38:08.828]                       muffled <- FALSE
[17:38:08.828]                       if (inherits(cond, "message")) {
[17:38:08.828]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.828]                         if (muffled) 
[17:38:08.828]                           invokeRestart("muffleMessage")
[17:38:08.828]                       }
[17:38:08.828]                       else if (inherits(cond, "warning")) {
[17:38:08.828]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.828]                         if (muffled) 
[17:38:08.828]                           invokeRestart("muffleWarning")
[17:38:08.828]                       }
[17:38:08.828]                       else if (inherits(cond, "condition")) {
[17:38:08.828]                         if (!is.null(pattern)) {
[17:38:08.828]                           computeRestarts <- base::computeRestarts
[17:38:08.828]                           grepl <- base::grepl
[17:38:08.828]                           restarts <- computeRestarts(cond)
[17:38:08.828]                           for (restart in restarts) {
[17:38:08.828]                             name <- restart$name
[17:38:08.828]                             if (is.null(name)) 
[17:38:08.828]                               next
[17:38:08.828]                             if (!grepl(pattern, name)) 
[17:38:08.828]                               next
[17:38:08.828]                             invokeRestart(restart)
[17:38:08.828]                             muffled <- TRUE
[17:38:08.828]                             break
[17:38:08.828]                           }
[17:38:08.828]                         }
[17:38:08.828]                       }
[17:38:08.828]                       invisible(muffled)
[17:38:08.828]                     }
[17:38:08.828]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.828]                   }
[17:38:08.828]                 }
[17:38:08.828]             }
[17:38:08.828]         }))
[17:38:08.828]     }, error = function(ex) {
[17:38:08.828]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:08.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.828]                 ...future.rng), started = ...future.startTime, 
[17:38:08.828]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:08.828]             version = "1.8"), class = "FutureResult")
[17:38:08.828]     }, finally = {
[17:38:08.828]         if (!identical(...future.workdir, getwd())) 
[17:38:08.828]             setwd(...future.workdir)
[17:38:08.828]         {
[17:38:08.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:08.828]                 ...future.oldOptions$nwarnings <- NULL
[17:38:08.828]             }
[17:38:08.828]             base::options(...future.oldOptions)
[17:38:08.828]             if (.Platform$OS.type == "windows") {
[17:38:08.828]                 old_names <- names(...future.oldEnvVars)
[17:38:08.828]                 envs <- base::Sys.getenv()
[17:38:08.828]                 names <- names(envs)
[17:38:08.828]                 common <- intersect(names, old_names)
[17:38:08.828]                 added <- setdiff(names, old_names)
[17:38:08.828]                 removed <- setdiff(old_names, names)
[17:38:08.828]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:08.828]                   envs[common]]
[17:38:08.828]                 NAMES <- toupper(changed)
[17:38:08.828]                 args <- list()
[17:38:08.828]                 for (kk in seq_along(NAMES)) {
[17:38:08.828]                   name <- changed[[kk]]
[17:38:08.828]                   NAME <- NAMES[[kk]]
[17:38:08.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.828]                     next
[17:38:08.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.828]                 }
[17:38:08.828]                 NAMES <- toupper(added)
[17:38:08.828]                 for (kk in seq_along(NAMES)) {
[17:38:08.828]                   name <- added[[kk]]
[17:38:08.828]                   NAME <- NAMES[[kk]]
[17:38:08.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.828]                     next
[17:38:08.828]                   args[[name]] <- ""
[17:38:08.828]                 }
[17:38:08.828]                 NAMES <- toupper(removed)
[17:38:08.828]                 for (kk in seq_along(NAMES)) {
[17:38:08.828]                   name <- removed[[kk]]
[17:38:08.828]                   NAME <- NAMES[[kk]]
[17:38:08.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.828]                     next
[17:38:08.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.828]                 }
[17:38:08.828]                 if (length(args) > 0) 
[17:38:08.828]                   base::do.call(base::Sys.setenv, args = args)
[17:38:08.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:08.828]             }
[17:38:08.828]             else {
[17:38:08.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:08.828]             }
[17:38:08.828]             {
[17:38:08.828]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:08.828]                   0L) {
[17:38:08.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:08.828]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:08.828]                   base::options(opts)
[17:38:08.828]                 }
[17:38:08.828]                 {
[17:38:08.828]                   {
[17:38:08.828]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:08.828]                     NULL
[17:38:08.828]                   }
[17:38:08.828]                   options(future.plan = NULL)
[17:38:08.828]                   if (is.na(NA_character_)) 
[17:38:08.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:08.828]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:08.828]                     .init = FALSE)
[17:38:08.828]                 }
[17:38:08.828]             }
[17:38:08.828]         }
[17:38:08.828]     })
[17:38:08.828]     if (TRUE) {
[17:38:08.828]         base::sink(type = "output", split = FALSE)
[17:38:08.828]         if (TRUE) {
[17:38:08.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:08.828]         }
[17:38:08.828]         else {
[17:38:08.828]             ...future.result["stdout"] <- base::list(NULL)
[17:38:08.828]         }
[17:38:08.828]         base::close(...future.stdout)
[17:38:08.828]         ...future.stdout <- NULL
[17:38:08.828]     }
[17:38:08.828]     ...future.result$conditions <- ...future.conditions
[17:38:08.828]     ...future.result$finished <- base::Sys.time()
[17:38:08.828]     ...future.result
[17:38:08.828] }
[17:38:08.831] assign_globals() ...
[17:38:08.831] List of 11
[17:38:08.831]  $ ...future.FUN            :function (x, ...)  
[17:38:08.831]  $ x_FUN                    :function (x, na.rm = TRUE)  
[17:38:08.831]  $ times                    : int 5
[17:38:08.831]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:08.831]  $ stop_if_not              :function (...)  
[17:38:08.831]  $ dim                      : NULL
[17:38:08.831]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:08.831]  $ future.call.arguments    : list()
[17:38:08.831]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.831]  $ ...future.elements_ii    :List of 3
[17:38:08.831]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:38:08.831]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:38:08.831]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:38:08.831]  $ ...future.seeds_ii       : NULL
[17:38:08.831]  $ ...future.globals.maxSize: NULL
[17:38:08.831]  - attr(*, "where")=List of 11
[17:38:08.831]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:08.831]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:08.831]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:08.831]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:08.831]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:08.831]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:08.831]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:08.831]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:08.831]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:08.831]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:08.831]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:08.831]  - attr(*, "resolved")= logi FALSE
[17:38:08.831]  - attr(*, "total_size")= num 141240
[17:38:08.831]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.831]  - attr(*, "already-done")= logi TRUE
[17:38:08.845] - copied ‘...future.FUN’ to environment
[17:38:08.845] - copied ‘x_FUN’ to environment
[17:38:08.845] - copied ‘times’ to environment
[17:38:08.845] - copied ‘stopf’ to environment
[17:38:08.846] - copied ‘stop_if_not’ to environment
[17:38:08.846] - copied ‘dim’ to environment
[17:38:08.846] - copied ‘valid_types’ to environment
[17:38:08.846] - copied ‘future.call.arguments’ to environment
[17:38:08.846] - copied ‘...future.elements_ii’ to environment
[17:38:08.846] - copied ‘...future.seeds_ii’ to environment
[17:38:08.846] - copied ‘...future.globals.maxSize’ to environment
[17:38:08.846] assign_globals() ... done
[17:38:08.847] requestCore(): workers = 2
[17:38:08.849] MulticoreFuture started
[17:38:08.850] - Launch lazy future ... done
[17:38:08.850] run() for ‘MulticoreFuture’ ... done
[17:38:08.851] Created future:
[17:38:08.852] plan(): Setting new future strategy stack:
[17:38:08.852] List of future strategies:
[17:38:08.852] 1. sequential:
[17:38:08.852]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:08.852]    - tweaked: FALSE
[17:38:08.852]    - call: NULL
[17:38:08.854] plan(): nbrOfWorkers() = 1
[17:38:08.857] plan(): Setting new future strategy stack:
[17:38:08.857] List of future strategies:
[17:38:08.857] 1. multicore:
[17:38:08.857]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:08.857]    - tweaked: FALSE
[17:38:08.857]    - call: plan(strategy)
[17:38:08.863] plan(): nbrOfWorkers() = 2
[17:38:08.851] MulticoreFuture:
[17:38:08.851] Label: ‘future_vapply-2’
[17:38:08.851] Expression:
[17:38:08.851] {
[17:38:08.851]     do.call(function(...) {
[17:38:08.851]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.851]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.851]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.851]             on.exit(options(oopts), add = TRUE)
[17:38:08.851]         }
[17:38:08.851]         {
[17:38:08.851]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.851]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.851]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.851]             })
[17:38:08.851]         }
[17:38:08.851]     }, args = future.call.arguments)
[17:38:08.851] }
[17:38:08.851] Lazy evaluation: FALSE
[17:38:08.851] Asynchronous evaluation: TRUE
[17:38:08.851] Local evaluation: TRUE
[17:38:08.851] Environment: R_GlobalEnv
[17:38:08.851] Capture standard output: TRUE
[17:38:08.851] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:08.851] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:08.851] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:38:08.851] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:08.851] Resolved: TRUE
[17:38:08.851] Value: <not collected>
[17:38:08.851] Conditions captured: <none>
[17:38:08.851] Early signaling: FALSE
[17:38:08.851] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:08.851] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.864] Chunk #2 of 2 ... DONE
[17:38:08.864] Launching 2 futures (chunks) ... DONE
[17:38:08.864] Resolving 2 futures (chunks) ...
[17:38:08.864] resolve() on list ...
[17:38:08.864]  recursive: 0
[17:38:08.865]  length: 2
[17:38:08.865] 
[17:38:08.865] Future #1
[17:38:08.865] result() for MulticoreFuture ...
[17:38:08.866] result() for MulticoreFuture ...
[17:38:08.867] result() for MulticoreFuture ... done
[17:38:08.867] result() for MulticoreFuture ... done
[17:38:08.867] result() for MulticoreFuture ...
[17:38:08.867] result() for MulticoreFuture ... done
[17:38:08.867] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:08.868] - nx: 2
[17:38:08.868] - relay: TRUE
[17:38:08.868] - stdout: TRUE
[17:38:08.868] - signal: TRUE
[17:38:08.868] - resignal: FALSE
[17:38:08.869] - force: TRUE
[17:38:08.869] - relayed: [n=2] FALSE, FALSE
[17:38:08.869] - queued futures: [n=2] FALSE, FALSE
[17:38:08.869]  - until=1
[17:38:08.869]  - relaying element #1
[17:38:08.869] result() for MulticoreFuture ...
[17:38:08.870] result() for MulticoreFuture ... done
[17:38:08.870] result() for MulticoreFuture ...
[17:38:08.870] result() for MulticoreFuture ... done
[17:38:08.870] result() for MulticoreFuture ...
[17:38:08.871] result() for MulticoreFuture ... done
[17:38:08.871] result() for MulticoreFuture ...
[17:38:08.871] result() for MulticoreFuture ... done
[17:38:08.871] - relayed: [n=2] TRUE, FALSE
[17:38:08.871] - queued futures: [n=2] TRUE, FALSE
[17:38:08.872] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:08.872]  length: 1 (resolved future 1)
[17:38:08.872] Future #2
[17:38:08.872] result() for MulticoreFuture ...
[17:38:08.873] result() for MulticoreFuture ...
[17:38:08.873] result() for MulticoreFuture ... done
[17:38:08.873] result() for MulticoreFuture ... done
[17:38:08.873] result() for MulticoreFuture ...
[17:38:08.873] result() for MulticoreFuture ... done
[17:38:08.874] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:08.874] - nx: 2
[17:38:08.874] - relay: TRUE
[17:38:08.874] - stdout: TRUE
[17:38:08.874] - signal: TRUE
[17:38:08.874] - resignal: FALSE
[17:38:08.874] - force: TRUE
[17:38:08.874] - relayed: [n=2] TRUE, FALSE
[17:38:08.875] - queued futures: [n=2] TRUE, FALSE
[17:38:08.875]  - until=2
[17:38:08.875]  - relaying element #2
[17:38:08.875] result() for MulticoreFuture ...
[17:38:08.875] result() for MulticoreFuture ... done
[17:38:08.875] result() for MulticoreFuture ...
[17:38:08.875] result() for MulticoreFuture ... done
[17:38:08.875] result() for MulticoreFuture ...
[17:38:08.876] result() for MulticoreFuture ... done
[17:38:08.876] result() for MulticoreFuture ...
[17:38:08.876] result() for MulticoreFuture ... done
[17:38:08.876] - relayed: [n=2] TRUE, TRUE
[17:38:08.876] - queued futures: [n=2] TRUE, TRUE
[17:38:08.876] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:08.876]  length: 0 (resolved future 2)
[17:38:08.876] Relaying remaining futures
[17:38:08.877] signalConditionsASAP(NULL, pos=0) ...
[17:38:08.877] - nx: 2
[17:38:08.877] - relay: TRUE
[17:38:08.877] - stdout: TRUE
[17:38:08.877] - signal: TRUE
[17:38:08.877] - resignal: FALSE
[17:38:08.877] - force: TRUE
[17:38:08.877] - relayed: [n=2] TRUE, TRUE
[17:38:08.877] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:08.877] - relayed: [n=2] TRUE, TRUE
[17:38:08.878] - queued futures: [n=2] TRUE, TRUE
[17:38:08.878] signalConditionsASAP(NULL, pos=0) ... done
[17:38:08.878] resolve() on list ... DONE
[17:38:08.878] result() for MulticoreFuture ...
[17:38:08.878] result() for MulticoreFuture ... done
[17:38:08.878] result() for MulticoreFuture ...
[17:38:08.878] result() for MulticoreFuture ... done
[17:38:08.878] result() for MulticoreFuture ...
[17:38:08.878] result() for MulticoreFuture ... done
[17:38:08.879] result() for MulticoreFuture ...
[17:38:08.879] result() for MulticoreFuture ... done
[17:38:08.879]  - Number of value chunks collected: 2
[17:38:08.879] Resolving 2 futures (chunks) ... DONE
[17:38:08.879] Reducing values from 2 chunks ...
[17:38:08.879]  - Number of values collected after concatenation: 7
[17:38:08.879]  - Number of values expected: 7
[17:38:08.879] Reducing values from 2 chunks ... DONE
[17:38:08.880] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[17:38:08.882] future_lapply() ...
[17:38:08.887] Number of chunks: 2
[17:38:08.887] getGlobalsAndPackagesXApply() ...
[17:38:08.887]  - future.globals: TRUE
[17:38:08.887] getGlobalsAndPackages() ...
[17:38:08.887] Searching for globals...
[17:38:08.891] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[17:38:08.892] Searching for globals ... DONE
[17:38:08.892] Resolving globals: FALSE
[17:38:08.892] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[17:38:08.893] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[17:38:08.893] - globals: [1] ‘FUN’
[17:38:08.893] 
[17:38:08.893] getGlobalsAndPackages() ... DONE
[17:38:08.893]  - globals found/used: [n=1] ‘FUN’
[17:38:08.893]  - needed namespaces: [n=0] 
[17:38:08.894] Finding globals ... DONE
[17:38:08.894]  - use_args: TRUE
[17:38:08.894]  - Getting '...' globals ...
[17:38:08.894] resolve() on list ...
[17:38:08.894]  recursive: 0
[17:38:08.895]  length: 1
[17:38:08.895]  elements: ‘...’
[17:38:08.895]  length: 0 (resolved future 1)
[17:38:08.895] resolve() on list ... DONE
[17:38:08.895]    - '...' content: [n=1] ‘y’
[17:38:08.895] List of 1
[17:38:08.895]  $ ...:List of 1
[17:38:08.895]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:08.895]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.895]  - attr(*, "where")=List of 1
[17:38:08.895]   ..$ ...:<environment: 0x560801849c38> 
[17:38:08.895]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.895]  - attr(*, "resolved")= logi TRUE
[17:38:08.895]  - attr(*, "total_size")= num NA
[17:38:08.899]  - Getting '...' globals ... DONE
[17:38:08.899] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:08.899] List of 2
[17:38:08.899]  $ ...future.FUN:function (x, y)  
[17:38:08.899]  $ ...          :List of 1
[17:38:08.899]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:08.899]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.899]  - attr(*, "where")=List of 2
[17:38:08.899]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:08.899]   ..$ ...          :<environment: 0x560801849c38> 
[17:38:08.899]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.899]  - attr(*, "resolved")= logi FALSE
[17:38:08.899]  - attr(*, "total_size")= num 4264
[17:38:08.902] Packages to be attached in all futures: [n=0] 
[17:38:08.902] getGlobalsAndPackagesXApply() ... DONE
[17:38:08.902] Number of futures (= number of chunks): 2
[17:38:08.902] Launching 2 futures (chunks) ...
[17:38:08.903] Chunk #1 of 2 ...
[17:38:08.903]  - Finding globals in 'X' for chunk #1 ...
[17:38:08.903] getGlobalsAndPackages() ...
[17:38:08.903] Searching for globals...
[17:38:08.903] 
[17:38:08.903] Searching for globals ... DONE
[17:38:08.903] - globals: [0] <none>
[17:38:08.903] getGlobalsAndPackages() ... DONE
[17:38:08.904]    + additional globals found: [n=0] 
[17:38:08.904]    + additional namespaces needed: [n=0] 
[17:38:08.904]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:08.904]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:08.904]  - seeds: <none>
[17:38:08.904]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.904] getGlobalsAndPackages() ...
[17:38:08.904] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.904] Resolving globals: FALSE
[17:38:08.905] Tweak future expression to call with '...' arguments ...
[17:38:08.905] {
[17:38:08.905]     do.call(function(...) {
[17:38:08.905]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.905]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.905]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.905]             on.exit(options(oopts), add = TRUE)
[17:38:08.905]         }
[17:38:08.905]         {
[17:38:08.905]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.905]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.905]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.905]             })
[17:38:08.905]         }
[17:38:08.905]     }, args = future.call.arguments)
[17:38:08.905] }
[17:38:08.905] Tweak future expression to call with '...' arguments ... DONE
[17:38:08.905] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.905] 
[17:38:08.905] getGlobalsAndPackages() ... DONE
[17:38:08.906] run() for ‘Future’ ...
[17:38:08.906] - state: ‘created’
[17:38:08.906] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:08.910] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.910] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:08.910]   - Field: ‘label’
[17:38:08.910]   - Field: ‘local’
[17:38:08.910]   - Field: ‘owner’
[17:38:08.910]   - Field: ‘envir’
[17:38:08.910]   - Field: ‘workers’
[17:38:08.910]   - Field: ‘packages’
[17:38:08.911]   - Field: ‘gc’
[17:38:08.911]   - Field: ‘job’
[17:38:08.911]   - Field: ‘conditions’
[17:38:08.911]   - Field: ‘expr’
[17:38:08.911]   - Field: ‘uuid’
[17:38:08.911]   - Field: ‘seed’
[17:38:08.911]   - Field: ‘version’
[17:38:08.911]   - Field: ‘result’
[17:38:08.911]   - Field: ‘asynchronous’
[17:38:08.911]   - Field: ‘calls’
[17:38:08.911]   - Field: ‘globals’
[17:38:08.912]   - Field: ‘stdout’
[17:38:08.912]   - Field: ‘earlySignal’
[17:38:08.912]   - Field: ‘lazy’
[17:38:08.912]   - Field: ‘state’
[17:38:08.912] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:08.912] - Launch lazy future ...
[17:38:08.912] Packages needed by the future expression (n = 0): <none>
[17:38:08.912] Packages needed by future strategies (n = 0): <none>
[17:38:08.913] {
[17:38:08.913]     {
[17:38:08.913]         {
[17:38:08.913]             ...future.startTime <- base::Sys.time()
[17:38:08.913]             {
[17:38:08.913]                 {
[17:38:08.913]                   {
[17:38:08.913]                     {
[17:38:08.913]                       base::local({
[17:38:08.913]                         has_future <- base::requireNamespace("future", 
[17:38:08.913]                           quietly = TRUE)
[17:38:08.913]                         if (has_future) {
[17:38:08.913]                           ns <- base::getNamespace("future")
[17:38:08.913]                           version <- ns[[".package"]][["version"]]
[17:38:08.913]                           if (is.null(version)) 
[17:38:08.913]                             version <- utils::packageVersion("future")
[17:38:08.913]                         }
[17:38:08.913]                         else {
[17:38:08.913]                           version <- NULL
[17:38:08.913]                         }
[17:38:08.913]                         if (!has_future || version < "1.8.0") {
[17:38:08.913]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:08.913]                             "", base::R.version$version.string), 
[17:38:08.913]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:08.913]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:08.913]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:08.913]                               "release", "version")], collapse = " "), 
[17:38:08.913]                             hostname = base::Sys.info()[["nodename"]])
[17:38:08.913]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:08.913]                             info)
[17:38:08.913]                           info <- base::paste(info, collapse = "; ")
[17:38:08.913]                           if (!has_future) {
[17:38:08.913]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:08.913]                               info)
[17:38:08.913]                           }
[17:38:08.913]                           else {
[17:38:08.913]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:08.913]                               info, version)
[17:38:08.913]                           }
[17:38:08.913]                           base::stop(msg)
[17:38:08.913]                         }
[17:38:08.913]                       })
[17:38:08.913]                     }
[17:38:08.913]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:08.913]                     base::options(mc.cores = 1L)
[17:38:08.913]                   }
[17:38:08.913]                   ...future.strategy.old <- future::plan("list")
[17:38:08.913]                   options(future.plan = NULL)
[17:38:08.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:08.913]                 }
[17:38:08.913]                 ...future.workdir <- getwd()
[17:38:08.913]             }
[17:38:08.913]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:08.913]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:08.913]         }
[17:38:08.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:08.913]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:08.913]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:08.913]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:08.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:08.913]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:08.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:08.913]             base::names(...future.oldOptions))
[17:38:08.913]     }
[17:38:08.913]     if (FALSE) {
[17:38:08.913]     }
[17:38:08.913]     else {
[17:38:08.913]         if (TRUE) {
[17:38:08.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:08.913]                 open = "w")
[17:38:08.913]         }
[17:38:08.913]         else {
[17:38:08.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:08.913]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:08.913]         }
[17:38:08.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:08.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:08.913]             base::sink(type = "output", split = FALSE)
[17:38:08.913]             base::close(...future.stdout)
[17:38:08.913]         }, add = TRUE)
[17:38:08.913]     }
[17:38:08.913]     ...future.frame <- base::sys.nframe()
[17:38:08.913]     ...future.conditions <- base::list()
[17:38:08.913]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:08.913]     if (FALSE) {
[17:38:08.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:08.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:08.913]     }
[17:38:08.913]     ...future.result <- base::tryCatch({
[17:38:08.913]         base::withCallingHandlers({
[17:38:08.913]             ...future.value <- base::withVisible(base::local({
[17:38:08.913]                 withCallingHandlers({
[17:38:08.913]                   {
[17:38:08.913]                     do.call(function(...) {
[17:38:08.913]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.913]                       if (!identical(...future.globals.maxSize.org, 
[17:38:08.913]                         ...future.globals.maxSize)) {
[17:38:08.913]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.913]                         on.exit(options(oopts), add = TRUE)
[17:38:08.913]                       }
[17:38:08.913]                       {
[17:38:08.913]                         lapply(seq_along(...future.elements_ii), 
[17:38:08.913]                           FUN = function(jj) {
[17:38:08.913]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.913]                             ...future.FUN(...future.X_jj, ...)
[17:38:08.913]                           })
[17:38:08.913]                       }
[17:38:08.913]                     }, args = future.call.arguments)
[17:38:08.913]                   }
[17:38:08.913]                 }, immediateCondition = function(cond) {
[17:38:08.913]                   save_rds <- function (object, pathname, ...) 
[17:38:08.913]                   {
[17:38:08.913]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:08.913]                     if (file_test("-f", pathname_tmp)) {
[17:38:08.913]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.913]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:08.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.913]                         fi_tmp[["mtime"]])
[17:38:08.913]                     }
[17:38:08.913]                     tryCatch({
[17:38:08.913]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:08.913]                     }, error = function(ex) {
[17:38:08.913]                       msg <- conditionMessage(ex)
[17:38:08.913]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.913]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:08.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.913]                         fi_tmp[["mtime"]], msg)
[17:38:08.913]                       ex$message <- msg
[17:38:08.913]                       stop(ex)
[17:38:08.913]                     })
[17:38:08.913]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:08.913]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:08.913]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:08.913]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.913]                       fi <- file.info(pathname)
[17:38:08.913]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:08.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.913]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:08.913]                         fi[["size"]], fi[["mtime"]])
[17:38:08.913]                       stop(msg)
[17:38:08.913]                     }
[17:38:08.913]                     invisible(pathname)
[17:38:08.913]                   }
[17:38:08.913]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:08.913]                     rootPath = tempdir()) 
[17:38:08.913]                   {
[17:38:08.913]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:08.913]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:08.913]                       tmpdir = path, fileext = ".rds")
[17:38:08.913]                     save_rds(obj, file)
[17:38:08.913]                   }
[17:38:08.913]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:08.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.913]                   {
[17:38:08.913]                     inherits <- base::inherits
[17:38:08.913]                     invokeRestart <- base::invokeRestart
[17:38:08.913]                     is.null <- base::is.null
[17:38:08.913]                     muffled <- FALSE
[17:38:08.913]                     if (inherits(cond, "message")) {
[17:38:08.913]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:08.913]                       if (muffled) 
[17:38:08.913]                         invokeRestart("muffleMessage")
[17:38:08.913]                     }
[17:38:08.913]                     else if (inherits(cond, "warning")) {
[17:38:08.913]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:08.913]                       if (muffled) 
[17:38:08.913]                         invokeRestart("muffleWarning")
[17:38:08.913]                     }
[17:38:08.913]                     else if (inherits(cond, "condition")) {
[17:38:08.913]                       if (!is.null(pattern)) {
[17:38:08.913]                         computeRestarts <- base::computeRestarts
[17:38:08.913]                         grepl <- base::grepl
[17:38:08.913]                         restarts <- computeRestarts(cond)
[17:38:08.913]                         for (restart in restarts) {
[17:38:08.913]                           name <- restart$name
[17:38:08.913]                           if (is.null(name)) 
[17:38:08.913]                             next
[17:38:08.913]                           if (!grepl(pattern, name)) 
[17:38:08.913]                             next
[17:38:08.913]                           invokeRestart(restart)
[17:38:08.913]                           muffled <- TRUE
[17:38:08.913]                           break
[17:38:08.913]                         }
[17:38:08.913]                       }
[17:38:08.913]                     }
[17:38:08.913]                     invisible(muffled)
[17:38:08.913]                   }
[17:38:08.913]                   muffleCondition(cond)
[17:38:08.913]                 })
[17:38:08.913]             }))
[17:38:08.913]             future::FutureResult(value = ...future.value$value, 
[17:38:08.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.913]                   ...future.rng), globalenv = if (FALSE) 
[17:38:08.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:08.913]                     ...future.globalenv.names))
[17:38:08.913]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:08.913]         }, condition = base::local({
[17:38:08.913]             c <- base::c
[17:38:08.913]             inherits <- base::inherits
[17:38:08.913]             invokeRestart <- base::invokeRestart
[17:38:08.913]             length <- base::length
[17:38:08.913]             list <- base::list
[17:38:08.913]             seq.int <- base::seq.int
[17:38:08.913]             signalCondition <- base::signalCondition
[17:38:08.913]             sys.calls <- base::sys.calls
[17:38:08.913]             `[[` <- base::`[[`
[17:38:08.913]             `+` <- base::`+`
[17:38:08.913]             `<<-` <- base::`<<-`
[17:38:08.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:08.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:08.913]                   3L)]
[17:38:08.913]             }
[17:38:08.913]             function(cond) {
[17:38:08.913]                 is_error <- inherits(cond, "error")
[17:38:08.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:08.913]                   NULL)
[17:38:08.913]                 if (is_error) {
[17:38:08.913]                   sessionInformation <- function() {
[17:38:08.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:08.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:08.913]                       search = base::search(), system = base::Sys.info())
[17:38:08.913]                   }
[17:38:08.913]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:08.913]                     cond$call), session = sessionInformation(), 
[17:38:08.913]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:08.913]                   signalCondition(cond)
[17:38:08.913]                 }
[17:38:08.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:08.913]                 "immediateCondition"))) {
[17:38:08.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:08.913]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:08.913]                   if (TRUE && !signal) {
[17:38:08.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.913]                     {
[17:38:08.913]                       inherits <- base::inherits
[17:38:08.913]                       invokeRestart <- base::invokeRestart
[17:38:08.913]                       is.null <- base::is.null
[17:38:08.913]                       muffled <- FALSE
[17:38:08.913]                       if (inherits(cond, "message")) {
[17:38:08.913]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.913]                         if (muffled) 
[17:38:08.913]                           invokeRestart("muffleMessage")
[17:38:08.913]                       }
[17:38:08.913]                       else if (inherits(cond, "warning")) {
[17:38:08.913]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.913]                         if (muffled) 
[17:38:08.913]                           invokeRestart("muffleWarning")
[17:38:08.913]                       }
[17:38:08.913]                       else if (inherits(cond, "condition")) {
[17:38:08.913]                         if (!is.null(pattern)) {
[17:38:08.913]                           computeRestarts <- base::computeRestarts
[17:38:08.913]                           grepl <- base::grepl
[17:38:08.913]                           restarts <- computeRestarts(cond)
[17:38:08.913]                           for (restart in restarts) {
[17:38:08.913]                             name <- restart$name
[17:38:08.913]                             if (is.null(name)) 
[17:38:08.913]                               next
[17:38:08.913]                             if (!grepl(pattern, name)) 
[17:38:08.913]                               next
[17:38:08.913]                             invokeRestart(restart)
[17:38:08.913]                             muffled <- TRUE
[17:38:08.913]                             break
[17:38:08.913]                           }
[17:38:08.913]                         }
[17:38:08.913]                       }
[17:38:08.913]                       invisible(muffled)
[17:38:08.913]                     }
[17:38:08.913]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.913]                   }
[17:38:08.913]                 }
[17:38:08.913]                 else {
[17:38:08.913]                   if (TRUE) {
[17:38:08.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.913]                     {
[17:38:08.913]                       inherits <- base::inherits
[17:38:08.913]                       invokeRestart <- base::invokeRestart
[17:38:08.913]                       is.null <- base::is.null
[17:38:08.913]                       muffled <- FALSE
[17:38:08.913]                       if (inherits(cond, "message")) {
[17:38:08.913]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.913]                         if (muffled) 
[17:38:08.913]                           invokeRestart("muffleMessage")
[17:38:08.913]                       }
[17:38:08.913]                       else if (inherits(cond, "warning")) {
[17:38:08.913]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.913]                         if (muffled) 
[17:38:08.913]                           invokeRestart("muffleWarning")
[17:38:08.913]                       }
[17:38:08.913]                       else if (inherits(cond, "condition")) {
[17:38:08.913]                         if (!is.null(pattern)) {
[17:38:08.913]                           computeRestarts <- base::computeRestarts
[17:38:08.913]                           grepl <- base::grepl
[17:38:08.913]                           restarts <- computeRestarts(cond)
[17:38:08.913]                           for (restart in restarts) {
[17:38:08.913]                             name <- restart$name
[17:38:08.913]                             if (is.null(name)) 
[17:38:08.913]                               next
[17:38:08.913]                             if (!grepl(pattern, name)) 
[17:38:08.913]                               next
[17:38:08.913]                             invokeRestart(restart)
[17:38:08.913]                             muffled <- TRUE
[17:38:08.913]                             break
[17:38:08.913]                           }
[17:38:08.913]                         }
[17:38:08.913]                       }
[17:38:08.913]                       invisible(muffled)
[17:38:08.913]                     }
[17:38:08.913]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.913]                   }
[17:38:08.913]                 }
[17:38:08.913]             }
[17:38:08.913]         }))
[17:38:08.913]     }, error = function(ex) {
[17:38:08.913]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:08.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.913]                 ...future.rng), started = ...future.startTime, 
[17:38:08.913]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:08.913]             version = "1.8"), class = "FutureResult")
[17:38:08.913]     }, finally = {
[17:38:08.913]         if (!identical(...future.workdir, getwd())) 
[17:38:08.913]             setwd(...future.workdir)
[17:38:08.913]         {
[17:38:08.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:08.913]                 ...future.oldOptions$nwarnings <- NULL
[17:38:08.913]             }
[17:38:08.913]             base::options(...future.oldOptions)
[17:38:08.913]             if (.Platform$OS.type == "windows") {
[17:38:08.913]                 old_names <- names(...future.oldEnvVars)
[17:38:08.913]                 envs <- base::Sys.getenv()
[17:38:08.913]                 names <- names(envs)
[17:38:08.913]                 common <- intersect(names, old_names)
[17:38:08.913]                 added <- setdiff(names, old_names)
[17:38:08.913]                 removed <- setdiff(old_names, names)
[17:38:08.913]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:08.913]                   envs[common]]
[17:38:08.913]                 NAMES <- toupper(changed)
[17:38:08.913]                 args <- list()
[17:38:08.913]                 for (kk in seq_along(NAMES)) {
[17:38:08.913]                   name <- changed[[kk]]
[17:38:08.913]                   NAME <- NAMES[[kk]]
[17:38:08.913]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.913]                     next
[17:38:08.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.913]                 }
[17:38:08.913]                 NAMES <- toupper(added)
[17:38:08.913]                 for (kk in seq_along(NAMES)) {
[17:38:08.913]                   name <- added[[kk]]
[17:38:08.913]                   NAME <- NAMES[[kk]]
[17:38:08.913]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.913]                     next
[17:38:08.913]                   args[[name]] <- ""
[17:38:08.913]                 }
[17:38:08.913]                 NAMES <- toupper(removed)
[17:38:08.913]                 for (kk in seq_along(NAMES)) {
[17:38:08.913]                   name <- removed[[kk]]
[17:38:08.913]                   NAME <- NAMES[[kk]]
[17:38:08.913]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.913]                     next
[17:38:08.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.913]                 }
[17:38:08.913]                 if (length(args) > 0) 
[17:38:08.913]                   base::do.call(base::Sys.setenv, args = args)
[17:38:08.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:08.913]             }
[17:38:08.913]             else {
[17:38:08.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:08.913]             }
[17:38:08.913]             {
[17:38:08.913]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:08.913]                   0L) {
[17:38:08.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:08.913]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:08.913]                   base::options(opts)
[17:38:08.913]                 }
[17:38:08.913]                 {
[17:38:08.913]                   {
[17:38:08.913]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:08.913]                     NULL
[17:38:08.913]                   }
[17:38:08.913]                   options(future.plan = NULL)
[17:38:08.913]                   if (is.na(NA_character_)) 
[17:38:08.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:08.913]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:08.913]                     .init = FALSE)
[17:38:08.913]                 }
[17:38:08.913]             }
[17:38:08.913]         }
[17:38:08.913]     })
[17:38:08.913]     if (TRUE) {
[17:38:08.913]         base::sink(type = "output", split = FALSE)
[17:38:08.913]         if (TRUE) {
[17:38:08.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:08.913]         }
[17:38:08.913]         else {
[17:38:08.913]             ...future.result["stdout"] <- base::list(NULL)
[17:38:08.913]         }
[17:38:08.913]         base::close(...future.stdout)
[17:38:08.913]         ...future.stdout <- NULL
[17:38:08.913]     }
[17:38:08.913]     ...future.result$conditions <- ...future.conditions
[17:38:08.913]     ...future.result$finished <- base::Sys.time()
[17:38:08.913]     ...future.result
[17:38:08.913] }
[17:38:08.916] assign_globals() ...
[17:38:08.916] List of 5
[17:38:08.916]  $ ...future.FUN            :function (x, y)  
[17:38:08.916]  $ future.call.arguments    :List of 1
[17:38:08.916]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:08.916]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.916]  $ ...future.elements_ii    :List of 2
[17:38:08.916]   ..$ A: num 50
[17:38:08.916]   ..$ B: num 60
[17:38:08.916]  $ ...future.seeds_ii       : NULL
[17:38:08.916]  $ ...future.globals.maxSize: NULL
[17:38:08.916]  - attr(*, "where")=List of 5
[17:38:08.916]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:08.916]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:08.916]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:08.916]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:08.916]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:08.916]  - attr(*, "resolved")= logi FALSE
[17:38:08.916]  - attr(*, "total_size")= num 4264
[17:38:08.916]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.916]  - attr(*, "already-done")= logi TRUE
[17:38:08.924] - reassign environment for ‘...future.FUN’
[17:38:08.924] - copied ‘...future.FUN’ to environment
[17:38:08.925] - copied ‘future.call.arguments’ to environment
[17:38:08.925] - copied ‘...future.elements_ii’ to environment
[17:38:08.925] - copied ‘...future.seeds_ii’ to environment
[17:38:08.925] - copied ‘...future.globals.maxSize’ to environment
[17:38:08.925] assign_globals() ... done
[17:38:08.925] requestCore(): workers = 2
[17:38:08.927] MulticoreFuture started
[17:38:08.928] - Launch lazy future ... done
[17:38:08.928] run() for ‘MulticoreFuture’ ... done
[17:38:08.929] Created future:
[17:38:08.929] plan(): Setting new future strategy stack:
[17:38:08.929] List of future strategies:
[17:38:08.929] 1. sequential:
[17:38:08.929]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:08.929]    - tweaked: FALSE
[17:38:08.929]    - call: NULL
[17:38:08.930] plan(): nbrOfWorkers() = 1
[17:38:08.932] plan(): Setting new future strategy stack:
[17:38:08.932] List of future strategies:
[17:38:08.932] 1. multicore:
[17:38:08.932]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:08.932]    - tweaked: FALSE
[17:38:08.932]    - call: plan(strategy)
[17:38:08.938] plan(): nbrOfWorkers() = 2
[17:38:08.929] MulticoreFuture:
[17:38:08.929] Label: ‘future_sapply-1’
[17:38:08.929] Expression:
[17:38:08.929] {
[17:38:08.929]     do.call(function(...) {
[17:38:08.929]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.929]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.929]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.929]             on.exit(options(oopts), add = TRUE)
[17:38:08.929]         }
[17:38:08.929]         {
[17:38:08.929]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.929]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.929]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.929]             })
[17:38:08.929]         }
[17:38:08.929]     }, args = future.call.arguments)
[17:38:08.929] }
[17:38:08.929] Lazy evaluation: FALSE
[17:38:08.929] Asynchronous evaluation: TRUE
[17:38:08.929] Local evaluation: TRUE
[17:38:08.929] Environment: R_GlobalEnv
[17:38:08.929] Capture standard output: TRUE
[17:38:08.929] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:08.929] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:08.929] Packages: <none>
[17:38:08.929] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:08.929] Resolved: TRUE
[17:38:08.929] Value: <not collected>
[17:38:08.929] Conditions captured: <none>
[17:38:08.929] Early signaling: FALSE
[17:38:08.929] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:08.929] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.939] Chunk #1 of 2 ... DONE
[17:38:08.939] Chunk #2 of 2 ...
[17:38:08.939]  - Finding globals in 'X' for chunk #2 ...
[17:38:08.940] getGlobalsAndPackages() ...
[17:38:08.940] Searching for globals...
[17:38:08.940] 
[17:38:08.940] Searching for globals ... DONE
[17:38:08.940] - globals: [0] <none>
[17:38:08.941] getGlobalsAndPackages() ... DONE
[17:38:08.941]    + additional globals found: [n=0] 
[17:38:08.941]    + additional namespaces needed: [n=0] 
[17:38:08.941]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:08.941]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:08.941]  - seeds: <none>
[17:38:08.941]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.942] getGlobalsAndPackages() ...
[17:38:08.942] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.942] Resolving globals: FALSE
[17:38:08.942] Tweak future expression to call with '...' arguments ...
[17:38:08.942] {
[17:38:08.942]     do.call(function(...) {
[17:38:08.942]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.942]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.942]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.942]             on.exit(options(oopts), add = TRUE)
[17:38:08.942]         }
[17:38:08.942]         {
[17:38:08.942]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.942]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.942]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.942]             })
[17:38:08.942]         }
[17:38:08.942]     }, args = future.call.arguments)
[17:38:08.942] }
[17:38:08.943] Tweak future expression to call with '...' arguments ... DONE
[17:38:08.943] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:08.944] 
[17:38:08.944] getGlobalsAndPackages() ... DONE
[17:38:08.944] run() for ‘Future’ ...
[17:38:08.945] - state: ‘created’
[17:38:08.945] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:08.950] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.950] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:08.950]   - Field: ‘label’
[17:38:08.950]   - Field: ‘local’
[17:38:08.950]   - Field: ‘owner’
[17:38:08.950]   - Field: ‘envir’
[17:38:08.951]   - Field: ‘workers’
[17:38:08.951]   - Field: ‘packages’
[17:38:08.951]   - Field: ‘gc’
[17:38:08.951]   - Field: ‘job’
[17:38:08.951]   - Field: ‘conditions’
[17:38:08.951]   - Field: ‘expr’
[17:38:08.952]   - Field: ‘uuid’
[17:38:08.952]   - Field: ‘seed’
[17:38:08.952]   - Field: ‘version’
[17:38:08.952]   - Field: ‘result’
[17:38:08.952]   - Field: ‘asynchronous’
[17:38:08.952]   - Field: ‘calls’
[17:38:08.953]   - Field: ‘globals’
[17:38:08.953]   - Field: ‘stdout’
[17:38:08.953]   - Field: ‘earlySignal’
[17:38:08.953]   - Field: ‘lazy’
[17:38:08.953]   - Field: ‘state’
[17:38:08.953] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:08.954] - Launch lazy future ...
[17:38:08.954] Packages needed by the future expression (n = 0): <none>
[17:38:08.954] Packages needed by future strategies (n = 0): <none>
[17:38:08.955] {
[17:38:08.955]     {
[17:38:08.955]         {
[17:38:08.955]             ...future.startTime <- base::Sys.time()
[17:38:08.955]             {
[17:38:08.955]                 {
[17:38:08.955]                   {
[17:38:08.955]                     {
[17:38:08.955]                       base::local({
[17:38:08.955]                         has_future <- base::requireNamespace("future", 
[17:38:08.955]                           quietly = TRUE)
[17:38:08.955]                         if (has_future) {
[17:38:08.955]                           ns <- base::getNamespace("future")
[17:38:08.955]                           version <- ns[[".package"]][["version"]]
[17:38:08.955]                           if (is.null(version)) 
[17:38:08.955]                             version <- utils::packageVersion("future")
[17:38:08.955]                         }
[17:38:08.955]                         else {
[17:38:08.955]                           version <- NULL
[17:38:08.955]                         }
[17:38:08.955]                         if (!has_future || version < "1.8.0") {
[17:38:08.955]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:08.955]                             "", base::R.version$version.string), 
[17:38:08.955]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:08.955]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:08.955]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:08.955]                               "release", "version")], collapse = " "), 
[17:38:08.955]                             hostname = base::Sys.info()[["nodename"]])
[17:38:08.955]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:08.955]                             info)
[17:38:08.955]                           info <- base::paste(info, collapse = "; ")
[17:38:08.955]                           if (!has_future) {
[17:38:08.955]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:08.955]                               info)
[17:38:08.955]                           }
[17:38:08.955]                           else {
[17:38:08.955]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:08.955]                               info, version)
[17:38:08.955]                           }
[17:38:08.955]                           base::stop(msg)
[17:38:08.955]                         }
[17:38:08.955]                       })
[17:38:08.955]                     }
[17:38:08.955]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:08.955]                     base::options(mc.cores = 1L)
[17:38:08.955]                   }
[17:38:08.955]                   ...future.strategy.old <- future::plan("list")
[17:38:08.955]                   options(future.plan = NULL)
[17:38:08.955]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.955]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:08.955]                 }
[17:38:08.955]                 ...future.workdir <- getwd()
[17:38:08.955]             }
[17:38:08.955]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:08.955]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:08.955]         }
[17:38:08.955]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:08.955]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:08.955]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:08.955]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:08.955]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:08.955]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:08.955]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:08.955]             base::names(...future.oldOptions))
[17:38:08.955]     }
[17:38:08.955]     if (FALSE) {
[17:38:08.955]     }
[17:38:08.955]     else {
[17:38:08.955]         if (TRUE) {
[17:38:08.955]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:08.955]                 open = "w")
[17:38:08.955]         }
[17:38:08.955]         else {
[17:38:08.955]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:08.955]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:08.955]         }
[17:38:08.955]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:08.955]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:08.955]             base::sink(type = "output", split = FALSE)
[17:38:08.955]             base::close(...future.stdout)
[17:38:08.955]         }, add = TRUE)
[17:38:08.955]     }
[17:38:08.955]     ...future.frame <- base::sys.nframe()
[17:38:08.955]     ...future.conditions <- base::list()
[17:38:08.955]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:08.955]     if (FALSE) {
[17:38:08.955]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:08.955]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:08.955]     }
[17:38:08.955]     ...future.result <- base::tryCatch({
[17:38:08.955]         base::withCallingHandlers({
[17:38:08.955]             ...future.value <- base::withVisible(base::local({
[17:38:08.955]                 withCallingHandlers({
[17:38:08.955]                   {
[17:38:08.955]                     do.call(function(...) {
[17:38:08.955]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.955]                       if (!identical(...future.globals.maxSize.org, 
[17:38:08.955]                         ...future.globals.maxSize)) {
[17:38:08.955]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.955]                         on.exit(options(oopts), add = TRUE)
[17:38:08.955]                       }
[17:38:08.955]                       {
[17:38:08.955]                         lapply(seq_along(...future.elements_ii), 
[17:38:08.955]                           FUN = function(jj) {
[17:38:08.955]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.955]                             ...future.FUN(...future.X_jj, ...)
[17:38:08.955]                           })
[17:38:08.955]                       }
[17:38:08.955]                     }, args = future.call.arguments)
[17:38:08.955]                   }
[17:38:08.955]                 }, immediateCondition = function(cond) {
[17:38:08.955]                   save_rds <- function (object, pathname, ...) 
[17:38:08.955]                   {
[17:38:08.955]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:08.955]                     if (file_test("-f", pathname_tmp)) {
[17:38:08.955]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.955]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:08.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.955]                         fi_tmp[["mtime"]])
[17:38:08.955]                     }
[17:38:08.955]                     tryCatch({
[17:38:08.955]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:08.955]                     }, error = function(ex) {
[17:38:08.955]                       msg <- conditionMessage(ex)
[17:38:08.955]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.955]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:08.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.955]                         fi_tmp[["mtime"]], msg)
[17:38:08.955]                       ex$message <- msg
[17:38:08.955]                       stop(ex)
[17:38:08.955]                     })
[17:38:08.955]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:08.955]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:08.955]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:08.955]                       fi_tmp <- file.info(pathname_tmp)
[17:38:08.955]                       fi <- file.info(pathname)
[17:38:08.955]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:08.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:08.955]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:08.955]                         fi[["size"]], fi[["mtime"]])
[17:38:08.955]                       stop(msg)
[17:38:08.955]                     }
[17:38:08.955]                     invisible(pathname)
[17:38:08.955]                   }
[17:38:08.955]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:08.955]                     rootPath = tempdir()) 
[17:38:08.955]                   {
[17:38:08.955]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:08.955]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:08.955]                       tmpdir = path, fileext = ".rds")
[17:38:08.955]                     save_rds(obj, file)
[17:38:08.955]                   }
[17:38:08.955]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:08.955]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.955]                   {
[17:38:08.955]                     inherits <- base::inherits
[17:38:08.955]                     invokeRestart <- base::invokeRestart
[17:38:08.955]                     is.null <- base::is.null
[17:38:08.955]                     muffled <- FALSE
[17:38:08.955]                     if (inherits(cond, "message")) {
[17:38:08.955]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:08.955]                       if (muffled) 
[17:38:08.955]                         invokeRestart("muffleMessage")
[17:38:08.955]                     }
[17:38:08.955]                     else if (inherits(cond, "warning")) {
[17:38:08.955]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:08.955]                       if (muffled) 
[17:38:08.955]                         invokeRestart("muffleWarning")
[17:38:08.955]                     }
[17:38:08.955]                     else if (inherits(cond, "condition")) {
[17:38:08.955]                       if (!is.null(pattern)) {
[17:38:08.955]                         computeRestarts <- base::computeRestarts
[17:38:08.955]                         grepl <- base::grepl
[17:38:08.955]                         restarts <- computeRestarts(cond)
[17:38:08.955]                         for (restart in restarts) {
[17:38:08.955]                           name <- restart$name
[17:38:08.955]                           if (is.null(name)) 
[17:38:08.955]                             next
[17:38:08.955]                           if (!grepl(pattern, name)) 
[17:38:08.955]                             next
[17:38:08.955]                           invokeRestart(restart)
[17:38:08.955]                           muffled <- TRUE
[17:38:08.955]                           break
[17:38:08.955]                         }
[17:38:08.955]                       }
[17:38:08.955]                     }
[17:38:08.955]                     invisible(muffled)
[17:38:08.955]                   }
[17:38:08.955]                   muffleCondition(cond)
[17:38:08.955]                 })
[17:38:08.955]             }))
[17:38:08.955]             future::FutureResult(value = ...future.value$value, 
[17:38:08.955]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.955]                   ...future.rng), globalenv = if (FALSE) 
[17:38:08.955]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:08.955]                     ...future.globalenv.names))
[17:38:08.955]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:08.955]         }, condition = base::local({
[17:38:08.955]             c <- base::c
[17:38:08.955]             inherits <- base::inherits
[17:38:08.955]             invokeRestart <- base::invokeRestart
[17:38:08.955]             length <- base::length
[17:38:08.955]             list <- base::list
[17:38:08.955]             seq.int <- base::seq.int
[17:38:08.955]             signalCondition <- base::signalCondition
[17:38:08.955]             sys.calls <- base::sys.calls
[17:38:08.955]             `[[` <- base::`[[`
[17:38:08.955]             `+` <- base::`+`
[17:38:08.955]             `<<-` <- base::`<<-`
[17:38:08.955]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:08.955]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:08.955]                   3L)]
[17:38:08.955]             }
[17:38:08.955]             function(cond) {
[17:38:08.955]                 is_error <- inherits(cond, "error")
[17:38:08.955]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:08.955]                   NULL)
[17:38:08.955]                 if (is_error) {
[17:38:08.955]                   sessionInformation <- function() {
[17:38:08.955]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:08.955]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:08.955]                       search = base::search(), system = base::Sys.info())
[17:38:08.955]                   }
[17:38:08.955]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.955]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:08.955]                     cond$call), session = sessionInformation(), 
[17:38:08.955]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:08.955]                   signalCondition(cond)
[17:38:08.955]                 }
[17:38:08.955]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:08.955]                 "immediateCondition"))) {
[17:38:08.955]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:08.955]                   ...future.conditions[[length(...future.conditions) + 
[17:38:08.955]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:08.955]                   if (TRUE && !signal) {
[17:38:08.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.955]                     {
[17:38:08.955]                       inherits <- base::inherits
[17:38:08.955]                       invokeRestart <- base::invokeRestart
[17:38:08.955]                       is.null <- base::is.null
[17:38:08.955]                       muffled <- FALSE
[17:38:08.955]                       if (inherits(cond, "message")) {
[17:38:08.955]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.955]                         if (muffled) 
[17:38:08.955]                           invokeRestart("muffleMessage")
[17:38:08.955]                       }
[17:38:08.955]                       else if (inherits(cond, "warning")) {
[17:38:08.955]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.955]                         if (muffled) 
[17:38:08.955]                           invokeRestart("muffleWarning")
[17:38:08.955]                       }
[17:38:08.955]                       else if (inherits(cond, "condition")) {
[17:38:08.955]                         if (!is.null(pattern)) {
[17:38:08.955]                           computeRestarts <- base::computeRestarts
[17:38:08.955]                           grepl <- base::grepl
[17:38:08.955]                           restarts <- computeRestarts(cond)
[17:38:08.955]                           for (restart in restarts) {
[17:38:08.955]                             name <- restart$name
[17:38:08.955]                             if (is.null(name)) 
[17:38:08.955]                               next
[17:38:08.955]                             if (!grepl(pattern, name)) 
[17:38:08.955]                               next
[17:38:08.955]                             invokeRestart(restart)
[17:38:08.955]                             muffled <- TRUE
[17:38:08.955]                             break
[17:38:08.955]                           }
[17:38:08.955]                         }
[17:38:08.955]                       }
[17:38:08.955]                       invisible(muffled)
[17:38:08.955]                     }
[17:38:08.955]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.955]                   }
[17:38:08.955]                 }
[17:38:08.955]                 else {
[17:38:08.955]                   if (TRUE) {
[17:38:08.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:08.955]                     {
[17:38:08.955]                       inherits <- base::inherits
[17:38:08.955]                       invokeRestart <- base::invokeRestart
[17:38:08.955]                       is.null <- base::is.null
[17:38:08.955]                       muffled <- FALSE
[17:38:08.955]                       if (inherits(cond, "message")) {
[17:38:08.955]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:08.955]                         if (muffled) 
[17:38:08.955]                           invokeRestart("muffleMessage")
[17:38:08.955]                       }
[17:38:08.955]                       else if (inherits(cond, "warning")) {
[17:38:08.955]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:08.955]                         if (muffled) 
[17:38:08.955]                           invokeRestart("muffleWarning")
[17:38:08.955]                       }
[17:38:08.955]                       else if (inherits(cond, "condition")) {
[17:38:08.955]                         if (!is.null(pattern)) {
[17:38:08.955]                           computeRestarts <- base::computeRestarts
[17:38:08.955]                           grepl <- base::grepl
[17:38:08.955]                           restarts <- computeRestarts(cond)
[17:38:08.955]                           for (restart in restarts) {
[17:38:08.955]                             name <- restart$name
[17:38:08.955]                             if (is.null(name)) 
[17:38:08.955]                               next
[17:38:08.955]                             if (!grepl(pattern, name)) 
[17:38:08.955]                               next
[17:38:08.955]                             invokeRestart(restart)
[17:38:08.955]                             muffled <- TRUE
[17:38:08.955]                             break
[17:38:08.955]                           }
[17:38:08.955]                         }
[17:38:08.955]                       }
[17:38:08.955]                       invisible(muffled)
[17:38:08.955]                     }
[17:38:08.955]                     muffleCondition(cond, pattern = "^muffle")
[17:38:08.955]                   }
[17:38:08.955]                 }
[17:38:08.955]             }
[17:38:08.955]         }))
[17:38:08.955]     }, error = function(ex) {
[17:38:08.955]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:08.955]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:08.955]                 ...future.rng), started = ...future.startTime, 
[17:38:08.955]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:08.955]             version = "1.8"), class = "FutureResult")
[17:38:08.955]     }, finally = {
[17:38:08.955]         if (!identical(...future.workdir, getwd())) 
[17:38:08.955]             setwd(...future.workdir)
[17:38:08.955]         {
[17:38:08.955]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:08.955]                 ...future.oldOptions$nwarnings <- NULL
[17:38:08.955]             }
[17:38:08.955]             base::options(...future.oldOptions)
[17:38:08.955]             if (.Platform$OS.type == "windows") {
[17:38:08.955]                 old_names <- names(...future.oldEnvVars)
[17:38:08.955]                 envs <- base::Sys.getenv()
[17:38:08.955]                 names <- names(envs)
[17:38:08.955]                 common <- intersect(names, old_names)
[17:38:08.955]                 added <- setdiff(names, old_names)
[17:38:08.955]                 removed <- setdiff(old_names, names)
[17:38:08.955]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:08.955]                   envs[common]]
[17:38:08.955]                 NAMES <- toupper(changed)
[17:38:08.955]                 args <- list()
[17:38:08.955]                 for (kk in seq_along(NAMES)) {
[17:38:08.955]                   name <- changed[[kk]]
[17:38:08.955]                   NAME <- NAMES[[kk]]
[17:38:08.955]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.955]                     next
[17:38:08.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.955]                 }
[17:38:08.955]                 NAMES <- toupper(added)
[17:38:08.955]                 for (kk in seq_along(NAMES)) {
[17:38:08.955]                   name <- added[[kk]]
[17:38:08.955]                   NAME <- NAMES[[kk]]
[17:38:08.955]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.955]                     next
[17:38:08.955]                   args[[name]] <- ""
[17:38:08.955]                 }
[17:38:08.955]                 NAMES <- toupper(removed)
[17:38:08.955]                 for (kk in seq_along(NAMES)) {
[17:38:08.955]                   name <- removed[[kk]]
[17:38:08.955]                   NAME <- NAMES[[kk]]
[17:38:08.955]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:08.955]                     next
[17:38:08.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:08.955]                 }
[17:38:08.955]                 if (length(args) > 0) 
[17:38:08.955]                   base::do.call(base::Sys.setenv, args = args)
[17:38:08.955]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:08.955]             }
[17:38:08.955]             else {
[17:38:08.955]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:08.955]             }
[17:38:08.955]             {
[17:38:08.955]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:08.955]                   0L) {
[17:38:08.955]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:08.955]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:08.955]                   base::options(opts)
[17:38:08.955]                 }
[17:38:08.955]                 {
[17:38:08.955]                   {
[17:38:08.955]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:08.955]                     NULL
[17:38:08.955]                   }
[17:38:08.955]                   options(future.plan = NULL)
[17:38:08.955]                   if (is.na(NA_character_)) 
[17:38:08.955]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:08.955]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:08.955]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:08.955]                     .init = FALSE)
[17:38:08.955]                 }
[17:38:08.955]             }
[17:38:08.955]         }
[17:38:08.955]     })
[17:38:08.955]     if (TRUE) {
[17:38:08.955]         base::sink(type = "output", split = FALSE)
[17:38:08.955]         if (TRUE) {
[17:38:08.955]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:08.955]         }
[17:38:08.955]         else {
[17:38:08.955]             ...future.result["stdout"] <- base::list(NULL)
[17:38:08.955]         }
[17:38:08.955]         base::close(...future.stdout)
[17:38:08.955]         ...future.stdout <- NULL
[17:38:08.955]     }
[17:38:08.955]     ...future.result$conditions <- ...future.conditions
[17:38:08.955]     ...future.result$finished <- base::Sys.time()
[17:38:08.955]     ...future.result
[17:38:08.955] }
[17:38:08.959] assign_globals() ...
[17:38:08.959] List of 5
[17:38:08.959]  $ ...future.FUN            :function (x, y)  
[17:38:08.959]  $ future.call.arguments    :List of 1
[17:38:08.959]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:08.959]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:08.959]  $ ...future.elements_ii    :List of 2
[17:38:08.959]   ..$ C: num 70
[17:38:08.959]   ..$ D: num 80
[17:38:08.959]  $ ...future.seeds_ii       : NULL
[17:38:08.959]  $ ...future.globals.maxSize: NULL
[17:38:08.959]  - attr(*, "where")=List of 5
[17:38:08.959]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:08.959]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:08.959]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:08.959]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:08.959]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:08.959]  - attr(*, "resolved")= logi FALSE
[17:38:08.959]  - attr(*, "total_size")= num 4264
[17:38:08.959]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:08.959]  - attr(*, "already-done")= logi TRUE
[17:38:08.972] - reassign environment for ‘...future.FUN’
[17:38:08.972] - copied ‘...future.FUN’ to environment
[17:38:08.972] - copied ‘future.call.arguments’ to environment
[17:38:08.973] - copied ‘...future.elements_ii’ to environment
[17:38:08.973] - copied ‘...future.seeds_ii’ to environment
[17:38:08.973] - copied ‘...future.globals.maxSize’ to environment
[17:38:08.973] assign_globals() ... done
[17:38:08.973] requestCore(): workers = 2
[17:38:08.976] MulticoreFuture started
[17:38:08.977] - Launch lazy future ... done
[17:38:08.977] plan(): Setting new future strategy stack:
[17:38:08.977] run() for ‘MulticoreFuture’ ... done
[17:38:08.978] Created future:
[17:38:08.978] List of future strategies:
[17:38:08.978] 1. sequential:
[17:38:08.978]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:08.978]    - tweaked: FALSE
[17:38:08.978]    - call: NULL
[17:38:08.979] plan(): nbrOfWorkers() = 1
[17:38:08.982] plan(): Setting new future strategy stack:
[17:38:08.982] List of future strategies:
[17:38:08.982] 1. multicore:
[17:38:08.982]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:08.982]    - tweaked: FALSE
[17:38:08.982]    - call: plan(strategy)
[17:38:08.988] plan(): nbrOfWorkers() = 2
[17:38:08.978] MulticoreFuture:
[17:38:08.978] Label: ‘future_sapply-2’
[17:38:08.978] Expression:
[17:38:08.978] {
[17:38:08.978]     do.call(function(...) {
[17:38:08.978]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:08.978]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:08.978]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:08.978]             on.exit(options(oopts), add = TRUE)
[17:38:08.978]         }
[17:38:08.978]         {
[17:38:08.978]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:08.978]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:08.978]                 ...future.FUN(...future.X_jj, ...)
[17:38:08.978]             })
[17:38:08.978]         }
[17:38:08.978]     }, args = future.call.arguments)
[17:38:08.978] }
[17:38:08.978] Lazy evaluation: FALSE
[17:38:08.978] Asynchronous evaluation: TRUE
[17:38:08.978] Local evaluation: TRUE
[17:38:08.978] Environment: R_GlobalEnv
[17:38:08.978] Capture standard output: TRUE
[17:38:08.978] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:08.978] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:08.978] Packages: <none>
[17:38:08.978] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:08.978] Resolved: TRUE
[17:38:08.978] Value: <not collected>
[17:38:08.978] Conditions captured: <none>
[17:38:08.978] Early signaling: FALSE
[17:38:08.978] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:08.978] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:08.989] Chunk #2 of 2 ... DONE
[17:38:08.990] Launching 2 futures (chunks) ... DONE
[17:38:08.990] Resolving 2 futures (chunks) ...
[17:38:08.990] resolve() on list ...
[17:38:08.990]  recursive: 0
[17:38:08.990]  length: 2
[17:38:08.990] 
[17:38:08.991] Future #1
[17:38:08.991] result() for MulticoreFuture ...
[17:38:08.992] result() for MulticoreFuture ...
[17:38:08.992] result() for MulticoreFuture ... done
[17:38:08.992] result() for MulticoreFuture ... done
[17:38:08.993] result() for MulticoreFuture ...
[17:38:08.993] result() for MulticoreFuture ... done
[17:38:08.993] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:08.993] - nx: 2
[17:38:08.993] - relay: TRUE
[17:38:08.993] - stdout: TRUE
[17:38:08.993] - signal: TRUE
[17:38:08.994] - resignal: FALSE
[17:38:08.994] - force: TRUE
[17:38:08.994] - relayed: [n=2] FALSE, FALSE
[17:38:08.994] - queued futures: [n=2] FALSE, FALSE
[17:38:08.994]  - until=1
[17:38:08.994]  - relaying element #1
[17:38:08.995] result() for MulticoreFuture ...
[17:38:08.995] result() for MulticoreFuture ... done
[17:38:08.995] result() for MulticoreFuture ...
[17:38:08.995] result() for MulticoreFuture ... done
[17:38:08.995] result() for MulticoreFuture ...
[17:38:08.995] result() for MulticoreFuture ... done
[17:38:08.995] result() for MulticoreFuture ...
[17:38:08.996] result() for MulticoreFuture ... done
[17:38:08.996] - relayed: [n=2] TRUE, FALSE
[17:38:08.996] - queued futures: [n=2] TRUE, FALSE
[17:38:08.996] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:08.996]  length: 1 (resolved future 1)
[17:38:08.997] Future #2
[17:38:08.997] result() for MulticoreFuture ...
[17:38:08.997] result() for MulticoreFuture ...
[17:38:08.998] result() for MulticoreFuture ... done
[17:38:08.998] result() for MulticoreFuture ... done
[17:38:08.998] result() for MulticoreFuture ...
[17:38:08.998] result() for MulticoreFuture ... done
[17:38:08.998] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:08.998] - nx: 2
[17:38:08.998] - relay: TRUE
[17:38:08.999] - stdout: TRUE
[17:38:08.999] - signal: TRUE
[17:38:08.999] - resignal: FALSE
[17:38:08.999] - force: TRUE
[17:38:08.999] - relayed: [n=2] TRUE, FALSE
[17:38:08.999] - queued futures: [n=2] TRUE, FALSE
[17:38:08.999]  - until=2
[17:38:08.999]  - relaying element #2
[17:38:09.000] result() for MulticoreFuture ...
[17:38:09.000] result() for MulticoreFuture ... done
[17:38:09.000] result() for MulticoreFuture ...
[17:38:09.000] result() for MulticoreFuture ... done
[17:38:09.000] result() for MulticoreFuture ...
[17:38:09.000] result() for MulticoreFuture ... done
[17:38:09.000] result() for MulticoreFuture ...
[17:38:09.000] result() for MulticoreFuture ... done
[17:38:09.001] - relayed: [n=2] TRUE, TRUE
[17:38:09.001] - queued futures: [n=2] TRUE, TRUE
[17:38:09.001] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:09.001]  length: 0 (resolved future 2)
[17:38:09.001] Relaying remaining futures
[17:38:09.001] signalConditionsASAP(NULL, pos=0) ...
[17:38:09.001] - nx: 2
[17:38:09.001] - relay: TRUE
[17:38:09.001] - stdout: TRUE
[17:38:09.002] - signal: TRUE
[17:38:09.002] - resignal: FALSE
[17:38:09.002] - force: TRUE
[17:38:09.002] - relayed: [n=2] TRUE, TRUE
[17:38:09.002] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:09.002] - relayed: [n=2] TRUE, TRUE
[17:38:09.002] - queued futures: [n=2] TRUE, TRUE
[17:38:09.002] signalConditionsASAP(NULL, pos=0) ... done
[17:38:09.002] resolve() on list ... DONE
[17:38:09.003] result() for MulticoreFuture ...
[17:38:09.003] result() for MulticoreFuture ... done
[17:38:09.003] result() for MulticoreFuture ...
[17:38:09.003] result() for MulticoreFuture ... done
[17:38:09.003] result() for MulticoreFuture ...
[17:38:09.003] result() for MulticoreFuture ... done
[17:38:09.003] result() for MulticoreFuture ...
[17:38:09.003] result() for MulticoreFuture ... done
[17:38:09.004]  - Number of value chunks collected: 2
[17:38:09.004] Resolving 2 futures (chunks) ... DONE
[17:38:09.004] Reducing values from 2 chunks ...
[17:38:09.004]  - Number of values collected after concatenation: 4
[17:38:09.004]  - Number of values expected: 4
[17:38:09.004] Reducing values from 2 chunks ... DONE
[17:38:09.004] future_lapply() ... DONE
[17:38:09.005] future_lapply() ...
[17:38:09.014] Number of chunks: 2
[17:38:09.014] getGlobalsAndPackagesXApply() ...
[17:38:09.015]  - future.globals: TRUE
[17:38:09.015] getGlobalsAndPackages() ...
[17:38:09.015] Searching for globals...
[17:38:09.020] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[17:38:09.020] Searching for globals ... DONE
[17:38:09.020] Resolving globals: FALSE
[17:38:09.021] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[17:38:09.022] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:09.022] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:09.022] - packages: [1] ‘future.apply’
[17:38:09.022] getGlobalsAndPackages() ... DONE
[17:38:09.022]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:09.022]  - needed namespaces: [n=1] ‘future.apply’
[17:38:09.023] Finding globals ... DONE
[17:38:09.023]  - use_args: TRUE
[17:38:09.023]  - Getting '...' globals ...
[17:38:09.023] resolve() on list ...
[17:38:09.023]  recursive: 0
[17:38:09.023]  length: 1
[17:38:09.023]  elements: ‘...’
[17:38:09.024]  length: 0 (resolved future 1)
[17:38:09.024] resolve() on list ... DONE
[17:38:09.024]    - '...' content: [n=1] ‘y’
[17:38:09.024] List of 1
[17:38:09.024]  $ ...:List of 1
[17:38:09.024]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:09.024]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.024]  - attr(*, "where")=List of 1
[17:38:09.024]   ..$ ...:<environment: 0x560801839cf8> 
[17:38:09.024]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.024]  - attr(*, "resolved")= logi TRUE
[17:38:09.024]  - attr(*, "total_size")= num NA
[17:38:09.027]  - Getting '...' globals ... DONE
[17:38:09.027] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:09.027] List of 8
[17:38:09.027]  $ ...future.FUN:function (x, ...)  
[17:38:09.027]  $ x_FUN        :function (x, y)  
[17:38:09.027]  $ times        : int 15
[17:38:09.027]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:09.027]  $ stop_if_not  :function (...)  
[17:38:09.027]  $ dim          : int [1:2] 3 5
[17:38:09.027]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:09.027]  $ ...          :List of 1
[17:38:09.027]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:09.027]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.027]  - attr(*, "where")=List of 8
[17:38:09.027]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:09.027]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:09.027]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:09.027]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:09.027]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:09.027]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:09.027]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:09.027]   ..$ ...          :<environment: 0x560801839cf8> 
[17:38:09.027]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.027]  - attr(*, "resolved")= logi FALSE
[17:38:09.027]  - attr(*, "total_size")= num 98600
[17:38:09.036] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:09.036] getGlobalsAndPackagesXApply() ... DONE
[17:38:09.036] Number of futures (= number of chunks): 2
[17:38:09.036] Launching 2 futures (chunks) ...
[17:38:09.037] Chunk #1 of 2 ...
[17:38:09.037]  - Finding globals in 'X' for chunk #1 ...
[17:38:09.037] getGlobalsAndPackages() ...
[17:38:09.037] Searching for globals...
[17:38:09.037] 
[17:38:09.037] Searching for globals ... DONE
[17:38:09.038] - globals: [0] <none>
[17:38:09.038] getGlobalsAndPackages() ... DONE
[17:38:09.038]    + additional globals found: [n=0] 
[17:38:09.038]    + additional namespaces needed: [n=0] 
[17:38:09.038]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:09.038]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:09.038]  - seeds: <none>
[17:38:09.038]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.038] getGlobalsAndPackages() ...
[17:38:09.039] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.039] Resolving globals: FALSE
[17:38:09.039] Tweak future expression to call with '...' arguments ...
[17:38:09.039] {
[17:38:09.039]     do.call(function(...) {
[17:38:09.039]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.039]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.039]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.039]             on.exit(options(oopts), add = TRUE)
[17:38:09.039]         }
[17:38:09.039]         {
[17:38:09.039]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.039]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.039]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.039]             })
[17:38:09.039]         }
[17:38:09.039]     }, args = future.call.arguments)
[17:38:09.039] }
[17:38:09.039] Tweak future expression to call with '...' arguments ... DONE
[17:38:09.040] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.040] - packages: [1] ‘future.apply’
[17:38:09.040] getGlobalsAndPackages() ... DONE
[17:38:09.041] run() for ‘Future’ ...
[17:38:09.041] - state: ‘created’
[17:38:09.041] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:09.045] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.045] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:09.045]   - Field: ‘label’
[17:38:09.045]   - Field: ‘local’
[17:38:09.045]   - Field: ‘owner’
[17:38:09.045]   - Field: ‘envir’
[17:38:09.045]   - Field: ‘workers’
[17:38:09.045]   - Field: ‘packages’
[17:38:09.045]   - Field: ‘gc’
[17:38:09.046]   - Field: ‘job’
[17:38:09.046]   - Field: ‘conditions’
[17:38:09.046]   - Field: ‘expr’
[17:38:09.046]   - Field: ‘uuid’
[17:38:09.046]   - Field: ‘seed’
[17:38:09.046]   - Field: ‘version’
[17:38:09.046]   - Field: ‘result’
[17:38:09.046]   - Field: ‘asynchronous’
[17:38:09.046]   - Field: ‘calls’
[17:38:09.046]   - Field: ‘globals’
[17:38:09.046]   - Field: ‘stdout’
[17:38:09.047]   - Field: ‘earlySignal’
[17:38:09.047]   - Field: ‘lazy’
[17:38:09.047]   - Field: ‘state’
[17:38:09.047] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:09.047] - Launch lazy future ...
[17:38:09.047] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:09.047] Packages needed by future strategies (n = 0): <none>
[17:38:09.048] {
[17:38:09.048]     {
[17:38:09.048]         {
[17:38:09.048]             ...future.startTime <- base::Sys.time()
[17:38:09.048]             {
[17:38:09.048]                 {
[17:38:09.048]                   {
[17:38:09.048]                     {
[17:38:09.048]                       {
[17:38:09.048]                         base::local({
[17:38:09.048]                           has_future <- base::requireNamespace("future", 
[17:38:09.048]                             quietly = TRUE)
[17:38:09.048]                           if (has_future) {
[17:38:09.048]                             ns <- base::getNamespace("future")
[17:38:09.048]                             version <- ns[[".package"]][["version"]]
[17:38:09.048]                             if (is.null(version)) 
[17:38:09.048]                               version <- utils::packageVersion("future")
[17:38:09.048]                           }
[17:38:09.048]                           else {
[17:38:09.048]                             version <- NULL
[17:38:09.048]                           }
[17:38:09.048]                           if (!has_future || version < "1.8.0") {
[17:38:09.048]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:09.048]                               "", base::R.version$version.string), 
[17:38:09.048]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:09.048]                                 base::R.version$platform, 8 * 
[17:38:09.048]                                   base::.Machine$sizeof.pointer), 
[17:38:09.048]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:09.048]                                 "release", "version")], collapse = " "), 
[17:38:09.048]                               hostname = base::Sys.info()[["nodename"]])
[17:38:09.048]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:09.048]                               info)
[17:38:09.048]                             info <- base::paste(info, collapse = "; ")
[17:38:09.048]                             if (!has_future) {
[17:38:09.048]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:09.048]                                 info)
[17:38:09.048]                             }
[17:38:09.048]                             else {
[17:38:09.048]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:09.048]                                 info, version)
[17:38:09.048]                             }
[17:38:09.048]                             base::stop(msg)
[17:38:09.048]                           }
[17:38:09.048]                         })
[17:38:09.048]                       }
[17:38:09.048]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:09.048]                       base::options(mc.cores = 1L)
[17:38:09.048]                     }
[17:38:09.048]                     base::local({
[17:38:09.048]                       for (pkg in "future.apply") {
[17:38:09.048]                         base::loadNamespace(pkg)
[17:38:09.048]                         base::library(pkg, character.only = TRUE)
[17:38:09.048]                       }
[17:38:09.048]                     })
[17:38:09.048]                   }
[17:38:09.048]                   ...future.strategy.old <- future::plan("list")
[17:38:09.048]                   options(future.plan = NULL)
[17:38:09.048]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.048]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:09.048]                 }
[17:38:09.048]                 ...future.workdir <- getwd()
[17:38:09.048]             }
[17:38:09.048]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:09.048]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:09.048]         }
[17:38:09.048]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:09.048]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:09.048]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:09.048]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:09.048]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:09.048]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:09.048]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:09.048]             base::names(...future.oldOptions))
[17:38:09.048]     }
[17:38:09.048]     if (FALSE) {
[17:38:09.048]     }
[17:38:09.048]     else {
[17:38:09.048]         if (TRUE) {
[17:38:09.048]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:09.048]                 open = "w")
[17:38:09.048]         }
[17:38:09.048]         else {
[17:38:09.048]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:09.048]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:09.048]         }
[17:38:09.048]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:09.048]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:09.048]             base::sink(type = "output", split = FALSE)
[17:38:09.048]             base::close(...future.stdout)
[17:38:09.048]         }, add = TRUE)
[17:38:09.048]     }
[17:38:09.048]     ...future.frame <- base::sys.nframe()
[17:38:09.048]     ...future.conditions <- base::list()
[17:38:09.048]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:09.048]     if (FALSE) {
[17:38:09.048]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:09.048]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:09.048]     }
[17:38:09.048]     ...future.result <- base::tryCatch({
[17:38:09.048]         base::withCallingHandlers({
[17:38:09.048]             ...future.value <- base::withVisible(base::local({
[17:38:09.048]                 withCallingHandlers({
[17:38:09.048]                   {
[17:38:09.048]                     do.call(function(...) {
[17:38:09.048]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.048]                       if (!identical(...future.globals.maxSize.org, 
[17:38:09.048]                         ...future.globals.maxSize)) {
[17:38:09.048]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.048]                         on.exit(options(oopts), add = TRUE)
[17:38:09.048]                       }
[17:38:09.048]                       {
[17:38:09.048]                         lapply(seq_along(...future.elements_ii), 
[17:38:09.048]                           FUN = function(jj) {
[17:38:09.048]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.048]                             ...future.FUN(...future.X_jj, ...)
[17:38:09.048]                           })
[17:38:09.048]                       }
[17:38:09.048]                     }, args = future.call.arguments)
[17:38:09.048]                   }
[17:38:09.048]                 }, immediateCondition = function(cond) {
[17:38:09.048]                   save_rds <- function (object, pathname, ...) 
[17:38:09.048]                   {
[17:38:09.048]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:09.048]                     if (file_test("-f", pathname_tmp)) {
[17:38:09.048]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.048]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:09.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.048]                         fi_tmp[["mtime"]])
[17:38:09.048]                     }
[17:38:09.048]                     tryCatch({
[17:38:09.048]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:09.048]                     }, error = function(ex) {
[17:38:09.048]                       msg <- conditionMessage(ex)
[17:38:09.048]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.048]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:09.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.048]                         fi_tmp[["mtime"]], msg)
[17:38:09.048]                       ex$message <- msg
[17:38:09.048]                       stop(ex)
[17:38:09.048]                     })
[17:38:09.048]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:09.048]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:09.048]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:09.048]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.048]                       fi <- file.info(pathname)
[17:38:09.048]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:09.048]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.048]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:09.048]                         fi[["size"]], fi[["mtime"]])
[17:38:09.048]                       stop(msg)
[17:38:09.048]                     }
[17:38:09.048]                     invisible(pathname)
[17:38:09.048]                   }
[17:38:09.048]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:09.048]                     rootPath = tempdir()) 
[17:38:09.048]                   {
[17:38:09.048]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:09.048]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:09.048]                       tmpdir = path, fileext = ".rds")
[17:38:09.048]                     save_rds(obj, file)
[17:38:09.048]                   }
[17:38:09.048]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:09.048]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.048]                   {
[17:38:09.048]                     inherits <- base::inherits
[17:38:09.048]                     invokeRestart <- base::invokeRestart
[17:38:09.048]                     is.null <- base::is.null
[17:38:09.048]                     muffled <- FALSE
[17:38:09.048]                     if (inherits(cond, "message")) {
[17:38:09.048]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:09.048]                       if (muffled) 
[17:38:09.048]                         invokeRestart("muffleMessage")
[17:38:09.048]                     }
[17:38:09.048]                     else if (inherits(cond, "warning")) {
[17:38:09.048]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:09.048]                       if (muffled) 
[17:38:09.048]                         invokeRestart("muffleWarning")
[17:38:09.048]                     }
[17:38:09.048]                     else if (inherits(cond, "condition")) {
[17:38:09.048]                       if (!is.null(pattern)) {
[17:38:09.048]                         computeRestarts <- base::computeRestarts
[17:38:09.048]                         grepl <- base::grepl
[17:38:09.048]                         restarts <- computeRestarts(cond)
[17:38:09.048]                         for (restart in restarts) {
[17:38:09.048]                           name <- restart$name
[17:38:09.048]                           if (is.null(name)) 
[17:38:09.048]                             next
[17:38:09.048]                           if (!grepl(pattern, name)) 
[17:38:09.048]                             next
[17:38:09.048]                           invokeRestart(restart)
[17:38:09.048]                           muffled <- TRUE
[17:38:09.048]                           break
[17:38:09.048]                         }
[17:38:09.048]                       }
[17:38:09.048]                     }
[17:38:09.048]                     invisible(muffled)
[17:38:09.048]                   }
[17:38:09.048]                   muffleCondition(cond)
[17:38:09.048]                 })
[17:38:09.048]             }))
[17:38:09.048]             future::FutureResult(value = ...future.value$value, 
[17:38:09.048]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.048]                   ...future.rng), globalenv = if (FALSE) 
[17:38:09.048]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:09.048]                     ...future.globalenv.names))
[17:38:09.048]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:09.048]         }, condition = base::local({
[17:38:09.048]             c <- base::c
[17:38:09.048]             inherits <- base::inherits
[17:38:09.048]             invokeRestart <- base::invokeRestart
[17:38:09.048]             length <- base::length
[17:38:09.048]             list <- base::list
[17:38:09.048]             seq.int <- base::seq.int
[17:38:09.048]             signalCondition <- base::signalCondition
[17:38:09.048]             sys.calls <- base::sys.calls
[17:38:09.048]             `[[` <- base::`[[`
[17:38:09.048]             `+` <- base::`+`
[17:38:09.048]             `<<-` <- base::`<<-`
[17:38:09.048]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:09.048]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:09.048]                   3L)]
[17:38:09.048]             }
[17:38:09.048]             function(cond) {
[17:38:09.048]                 is_error <- inherits(cond, "error")
[17:38:09.048]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:09.048]                   NULL)
[17:38:09.048]                 if (is_error) {
[17:38:09.048]                   sessionInformation <- function() {
[17:38:09.048]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:09.048]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:09.048]                       search = base::search(), system = base::Sys.info())
[17:38:09.048]                   }
[17:38:09.048]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.048]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:09.048]                     cond$call), session = sessionInformation(), 
[17:38:09.048]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:09.048]                   signalCondition(cond)
[17:38:09.048]                 }
[17:38:09.048]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:09.048]                 "immediateCondition"))) {
[17:38:09.048]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:09.048]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.048]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:09.048]                   if (TRUE && !signal) {
[17:38:09.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.048]                     {
[17:38:09.048]                       inherits <- base::inherits
[17:38:09.048]                       invokeRestart <- base::invokeRestart
[17:38:09.048]                       is.null <- base::is.null
[17:38:09.048]                       muffled <- FALSE
[17:38:09.048]                       if (inherits(cond, "message")) {
[17:38:09.048]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.048]                         if (muffled) 
[17:38:09.048]                           invokeRestart("muffleMessage")
[17:38:09.048]                       }
[17:38:09.048]                       else if (inherits(cond, "warning")) {
[17:38:09.048]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.048]                         if (muffled) 
[17:38:09.048]                           invokeRestart("muffleWarning")
[17:38:09.048]                       }
[17:38:09.048]                       else if (inherits(cond, "condition")) {
[17:38:09.048]                         if (!is.null(pattern)) {
[17:38:09.048]                           computeRestarts <- base::computeRestarts
[17:38:09.048]                           grepl <- base::grepl
[17:38:09.048]                           restarts <- computeRestarts(cond)
[17:38:09.048]                           for (restart in restarts) {
[17:38:09.048]                             name <- restart$name
[17:38:09.048]                             if (is.null(name)) 
[17:38:09.048]                               next
[17:38:09.048]                             if (!grepl(pattern, name)) 
[17:38:09.048]                               next
[17:38:09.048]                             invokeRestart(restart)
[17:38:09.048]                             muffled <- TRUE
[17:38:09.048]                             break
[17:38:09.048]                           }
[17:38:09.048]                         }
[17:38:09.048]                       }
[17:38:09.048]                       invisible(muffled)
[17:38:09.048]                     }
[17:38:09.048]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.048]                   }
[17:38:09.048]                 }
[17:38:09.048]                 else {
[17:38:09.048]                   if (TRUE) {
[17:38:09.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.048]                     {
[17:38:09.048]                       inherits <- base::inherits
[17:38:09.048]                       invokeRestart <- base::invokeRestart
[17:38:09.048]                       is.null <- base::is.null
[17:38:09.048]                       muffled <- FALSE
[17:38:09.048]                       if (inherits(cond, "message")) {
[17:38:09.048]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.048]                         if (muffled) 
[17:38:09.048]                           invokeRestart("muffleMessage")
[17:38:09.048]                       }
[17:38:09.048]                       else if (inherits(cond, "warning")) {
[17:38:09.048]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.048]                         if (muffled) 
[17:38:09.048]                           invokeRestart("muffleWarning")
[17:38:09.048]                       }
[17:38:09.048]                       else if (inherits(cond, "condition")) {
[17:38:09.048]                         if (!is.null(pattern)) {
[17:38:09.048]                           computeRestarts <- base::computeRestarts
[17:38:09.048]                           grepl <- base::grepl
[17:38:09.048]                           restarts <- computeRestarts(cond)
[17:38:09.048]                           for (restart in restarts) {
[17:38:09.048]                             name <- restart$name
[17:38:09.048]                             if (is.null(name)) 
[17:38:09.048]                               next
[17:38:09.048]                             if (!grepl(pattern, name)) 
[17:38:09.048]                               next
[17:38:09.048]                             invokeRestart(restart)
[17:38:09.048]                             muffled <- TRUE
[17:38:09.048]                             break
[17:38:09.048]                           }
[17:38:09.048]                         }
[17:38:09.048]                       }
[17:38:09.048]                       invisible(muffled)
[17:38:09.048]                     }
[17:38:09.048]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.048]                   }
[17:38:09.048]                 }
[17:38:09.048]             }
[17:38:09.048]         }))
[17:38:09.048]     }, error = function(ex) {
[17:38:09.048]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:09.048]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.048]                 ...future.rng), started = ...future.startTime, 
[17:38:09.048]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:09.048]             version = "1.8"), class = "FutureResult")
[17:38:09.048]     }, finally = {
[17:38:09.048]         if (!identical(...future.workdir, getwd())) 
[17:38:09.048]             setwd(...future.workdir)
[17:38:09.048]         {
[17:38:09.048]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:09.048]                 ...future.oldOptions$nwarnings <- NULL
[17:38:09.048]             }
[17:38:09.048]             base::options(...future.oldOptions)
[17:38:09.048]             if (.Platform$OS.type == "windows") {
[17:38:09.048]                 old_names <- names(...future.oldEnvVars)
[17:38:09.048]                 envs <- base::Sys.getenv()
[17:38:09.048]                 names <- names(envs)
[17:38:09.048]                 common <- intersect(names, old_names)
[17:38:09.048]                 added <- setdiff(names, old_names)
[17:38:09.048]                 removed <- setdiff(old_names, names)
[17:38:09.048]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:09.048]                   envs[common]]
[17:38:09.048]                 NAMES <- toupper(changed)
[17:38:09.048]                 args <- list()
[17:38:09.048]                 for (kk in seq_along(NAMES)) {
[17:38:09.048]                   name <- changed[[kk]]
[17:38:09.048]                   NAME <- NAMES[[kk]]
[17:38:09.048]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.048]                     next
[17:38:09.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.048]                 }
[17:38:09.048]                 NAMES <- toupper(added)
[17:38:09.048]                 for (kk in seq_along(NAMES)) {
[17:38:09.048]                   name <- added[[kk]]
[17:38:09.048]                   NAME <- NAMES[[kk]]
[17:38:09.048]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.048]                     next
[17:38:09.048]                   args[[name]] <- ""
[17:38:09.048]                 }
[17:38:09.048]                 NAMES <- toupper(removed)
[17:38:09.048]                 for (kk in seq_along(NAMES)) {
[17:38:09.048]                   name <- removed[[kk]]
[17:38:09.048]                   NAME <- NAMES[[kk]]
[17:38:09.048]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.048]                     next
[17:38:09.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.048]                 }
[17:38:09.048]                 if (length(args) > 0) 
[17:38:09.048]                   base::do.call(base::Sys.setenv, args = args)
[17:38:09.048]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:09.048]             }
[17:38:09.048]             else {
[17:38:09.048]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:09.048]             }
[17:38:09.048]             {
[17:38:09.048]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:09.048]                   0L) {
[17:38:09.048]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:09.048]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:09.048]                   base::options(opts)
[17:38:09.048]                 }
[17:38:09.048]                 {
[17:38:09.048]                   {
[17:38:09.048]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:09.048]                     NULL
[17:38:09.048]                   }
[17:38:09.048]                   options(future.plan = NULL)
[17:38:09.048]                   if (is.na(NA_character_)) 
[17:38:09.048]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.048]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:09.048]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:09.048]                     .init = FALSE)
[17:38:09.048]                 }
[17:38:09.048]             }
[17:38:09.048]         }
[17:38:09.048]     })
[17:38:09.048]     if (TRUE) {
[17:38:09.048]         base::sink(type = "output", split = FALSE)
[17:38:09.048]         if (TRUE) {
[17:38:09.048]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:09.048]         }
[17:38:09.048]         else {
[17:38:09.048]             ...future.result["stdout"] <- base::list(NULL)
[17:38:09.048]         }
[17:38:09.048]         base::close(...future.stdout)
[17:38:09.048]         ...future.stdout <- NULL
[17:38:09.048]     }
[17:38:09.048]     ...future.result$conditions <- ...future.conditions
[17:38:09.048]     ...future.result$finished <- base::Sys.time()
[17:38:09.048]     ...future.result
[17:38:09.048] }
[17:38:09.051] assign_globals() ...
[17:38:09.051] List of 11
[17:38:09.051]  $ ...future.FUN            :function (x, ...)  
[17:38:09.051]  $ x_FUN                    :function (x, y)  
[17:38:09.051]  $ times                    : int 15
[17:38:09.051]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:09.051]  $ stop_if_not              :function (...)  
[17:38:09.051]  $ dim                      : int [1:2] 3 5
[17:38:09.051]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:09.051]  $ future.call.arguments    :List of 1
[17:38:09.051]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:09.051]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.051]  $ ...future.elements_ii    :List of 2
[17:38:09.051]   ..$ A: num 50
[17:38:09.051]   ..$ B: num 60
[17:38:09.051]  $ ...future.seeds_ii       : NULL
[17:38:09.051]  $ ...future.globals.maxSize: NULL
[17:38:09.051]  - attr(*, "where")=List of 11
[17:38:09.051]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:09.051]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:09.051]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:09.051]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:09.051]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:09.051]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:09.051]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:09.051]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:09.051]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:09.051]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:09.051]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:09.051]  - attr(*, "resolved")= logi FALSE
[17:38:09.051]  - attr(*, "total_size")= num 98600
[17:38:09.051]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.051]  - attr(*, "already-done")= logi TRUE
[17:38:09.061] - copied ‘...future.FUN’ to environment
[17:38:09.061] - reassign environment for ‘x_FUN’
[17:38:09.061] - copied ‘x_FUN’ to environment
[17:38:09.062] - copied ‘times’ to environment
[17:38:09.062] - copied ‘stopf’ to environment
[17:38:09.062] - copied ‘stop_if_not’ to environment
[17:38:09.062] - copied ‘dim’ to environment
[17:38:09.062] - copied ‘valid_types’ to environment
[17:38:09.062] - copied ‘future.call.arguments’ to environment
[17:38:09.062] - copied ‘...future.elements_ii’ to environment
[17:38:09.062] - copied ‘...future.seeds_ii’ to environment
[17:38:09.062] - copied ‘...future.globals.maxSize’ to environment
[17:38:09.063] assign_globals() ... done
[17:38:09.063] requestCore(): workers = 2
[17:38:09.065] MulticoreFuture started
[17:38:09.066] - Launch lazy future ... done
[17:38:09.066] run() for ‘MulticoreFuture’ ... done
[17:38:09.067] Created future:
[17:38:09.067] plan(): Setting new future strategy stack:
[17:38:09.068] List of future strategies:
[17:38:09.068] 1. sequential:
[17:38:09.068]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:09.068]    - tweaked: FALSE
[17:38:09.068]    - call: NULL
[17:38:09.070] plan(): nbrOfWorkers() = 1
[17:38:09.073] plan(): Setting new future strategy stack:
[17:38:09.073] List of future strategies:
[17:38:09.073] 1. multicore:
[17:38:09.073]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:09.073]    - tweaked: FALSE
[17:38:09.073]    - call: plan(strategy)
[17:38:09.080] plan(): nbrOfWorkers() = 2
[17:38:09.067] MulticoreFuture:
[17:38:09.067] Label: ‘future_vapply-1’
[17:38:09.067] Expression:
[17:38:09.067] {
[17:38:09.067]     do.call(function(...) {
[17:38:09.067]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.067]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.067]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.067]             on.exit(options(oopts), add = TRUE)
[17:38:09.067]         }
[17:38:09.067]         {
[17:38:09.067]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.067]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.067]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.067]             })
[17:38:09.067]         }
[17:38:09.067]     }, args = future.call.arguments)
[17:38:09.067] }
[17:38:09.067] Lazy evaluation: FALSE
[17:38:09.067] Asynchronous evaluation: TRUE
[17:38:09.067] Local evaluation: TRUE
[17:38:09.067] Environment: R_GlobalEnv
[17:38:09.067] Capture standard output: TRUE
[17:38:09.067] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:09.067] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:09.067] Packages: 1 packages (‘future.apply’)
[17:38:09.067] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:09.067] Resolved: TRUE
[17:38:09.067] Value: <not collected>
[17:38:09.067] Conditions captured: <none>
[17:38:09.067] Early signaling: FALSE
[17:38:09.067] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:09.067] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.081] Chunk #1 of 2 ... DONE
[17:38:09.081] Chunk #2 of 2 ...
[17:38:09.082]  - Finding globals in 'X' for chunk #2 ...
[17:38:09.082] getGlobalsAndPackages() ...
[17:38:09.082] Searching for globals...
[17:38:09.083] 
[17:38:09.083] Searching for globals ... DONE
[17:38:09.083] - globals: [0] <none>
[17:38:09.083] getGlobalsAndPackages() ... DONE
[17:38:09.083]    + additional globals found: [n=0] 
[17:38:09.084]    + additional namespaces needed: [n=0] 
[17:38:09.084]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:09.084]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:09.084]  - seeds: <none>
[17:38:09.084]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.085] getGlobalsAndPackages() ...
[17:38:09.085] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.085] Resolving globals: FALSE
[17:38:09.085] Tweak future expression to call with '...' arguments ...
[17:38:09.085] {
[17:38:09.085]     do.call(function(...) {
[17:38:09.085]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.085]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.085]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.085]             on.exit(options(oopts), add = TRUE)
[17:38:09.085]         }
[17:38:09.085]         {
[17:38:09.085]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.085]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.085]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.085]             })
[17:38:09.085]         }
[17:38:09.085]     }, args = future.call.arguments)
[17:38:09.085] }
[17:38:09.086] Tweak future expression to call with '...' arguments ... DONE
[17:38:09.087] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.087] - packages: [1] ‘future.apply’
[17:38:09.087] getGlobalsAndPackages() ... DONE
[17:38:09.088] run() for ‘Future’ ...
[17:38:09.088] - state: ‘created’
[17:38:09.088] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:09.093] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.093] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:09.093]   - Field: ‘label’
[17:38:09.093]   - Field: ‘local’
[17:38:09.093]   - Field: ‘owner’
[17:38:09.093]   - Field: ‘envir’
[17:38:09.093]   - Field: ‘workers’
[17:38:09.094]   - Field: ‘packages’
[17:38:09.094]   - Field: ‘gc’
[17:38:09.094]   - Field: ‘job’
[17:38:09.094]   - Field: ‘conditions’
[17:38:09.094]   - Field: ‘expr’
[17:38:09.094]   - Field: ‘uuid’
[17:38:09.094]   - Field: ‘seed’
[17:38:09.094]   - Field: ‘version’
[17:38:09.095]   - Field: ‘result’
[17:38:09.095]   - Field: ‘asynchronous’
[17:38:09.095]   - Field: ‘calls’
[17:38:09.095]   - Field: ‘globals’
[17:38:09.095]   - Field: ‘stdout’
[17:38:09.095]   - Field: ‘earlySignal’
[17:38:09.095]   - Field: ‘lazy’
[17:38:09.095]   - Field: ‘state’
[17:38:09.096] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:09.096] - Launch lazy future ...
[17:38:09.096] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:09.096] Packages needed by future strategies (n = 0): <none>
[17:38:09.097] {
[17:38:09.097]     {
[17:38:09.097]         {
[17:38:09.097]             ...future.startTime <- base::Sys.time()
[17:38:09.097]             {
[17:38:09.097]                 {
[17:38:09.097]                   {
[17:38:09.097]                     {
[17:38:09.097]                       {
[17:38:09.097]                         base::local({
[17:38:09.097]                           has_future <- base::requireNamespace("future", 
[17:38:09.097]                             quietly = TRUE)
[17:38:09.097]                           if (has_future) {
[17:38:09.097]                             ns <- base::getNamespace("future")
[17:38:09.097]                             version <- ns[[".package"]][["version"]]
[17:38:09.097]                             if (is.null(version)) 
[17:38:09.097]                               version <- utils::packageVersion("future")
[17:38:09.097]                           }
[17:38:09.097]                           else {
[17:38:09.097]                             version <- NULL
[17:38:09.097]                           }
[17:38:09.097]                           if (!has_future || version < "1.8.0") {
[17:38:09.097]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:09.097]                               "", base::R.version$version.string), 
[17:38:09.097]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:09.097]                                 base::R.version$platform, 8 * 
[17:38:09.097]                                   base::.Machine$sizeof.pointer), 
[17:38:09.097]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:09.097]                                 "release", "version")], collapse = " "), 
[17:38:09.097]                               hostname = base::Sys.info()[["nodename"]])
[17:38:09.097]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:09.097]                               info)
[17:38:09.097]                             info <- base::paste(info, collapse = "; ")
[17:38:09.097]                             if (!has_future) {
[17:38:09.097]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:09.097]                                 info)
[17:38:09.097]                             }
[17:38:09.097]                             else {
[17:38:09.097]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:09.097]                                 info, version)
[17:38:09.097]                             }
[17:38:09.097]                             base::stop(msg)
[17:38:09.097]                           }
[17:38:09.097]                         })
[17:38:09.097]                       }
[17:38:09.097]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:09.097]                       base::options(mc.cores = 1L)
[17:38:09.097]                     }
[17:38:09.097]                     base::local({
[17:38:09.097]                       for (pkg in "future.apply") {
[17:38:09.097]                         base::loadNamespace(pkg)
[17:38:09.097]                         base::library(pkg, character.only = TRUE)
[17:38:09.097]                       }
[17:38:09.097]                     })
[17:38:09.097]                   }
[17:38:09.097]                   ...future.strategy.old <- future::plan("list")
[17:38:09.097]                   options(future.plan = NULL)
[17:38:09.097]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.097]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:09.097]                 }
[17:38:09.097]                 ...future.workdir <- getwd()
[17:38:09.097]             }
[17:38:09.097]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:09.097]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:09.097]         }
[17:38:09.097]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:09.097]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:09.097]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:09.097]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:09.097]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:09.097]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:09.097]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:09.097]             base::names(...future.oldOptions))
[17:38:09.097]     }
[17:38:09.097]     if (FALSE) {
[17:38:09.097]     }
[17:38:09.097]     else {
[17:38:09.097]         if (TRUE) {
[17:38:09.097]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:09.097]                 open = "w")
[17:38:09.097]         }
[17:38:09.097]         else {
[17:38:09.097]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:09.097]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:09.097]         }
[17:38:09.097]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:09.097]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:09.097]             base::sink(type = "output", split = FALSE)
[17:38:09.097]             base::close(...future.stdout)
[17:38:09.097]         }, add = TRUE)
[17:38:09.097]     }
[17:38:09.097]     ...future.frame <- base::sys.nframe()
[17:38:09.097]     ...future.conditions <- base::list()
[17:38:09.097]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:09.097]     if (FALSE) {
[17:38:09.097]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:09.097]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:09.097]     }
[17:38:09.097]     ...future.result <- base::tryCatch({
[17:38:09.097]         base::withCallingHandlers({
[17:38:09.097]             ...future.value <- base::withVisible(base::local({
[17:38:09.097]                 withCallingHandlers({
[17:38:09.097]                   {
[17:38:09.097]                     do.call(function(...) {
[17:38:09.097]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.097]                       if (!identical(...future.globals.maxSize.org, 
[17:38:09.097]                         ...future.globals.maxSize)) {
[17:38:09.097]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.097]                         on.exit(options(oopts), add = TRUE)
[17:38:09.097]                       }
[17:38:09.097]                       {
[17:38:09.097]                         lapply(seq_along(...future.elements_ii), 
[17:38:09.097]                           FUN = function(jj) {
[17:38:09.097]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.097]                             ...future.FUN(...future.X_jj, ...)
[17:38:09.097]                           })
[17:38:09.097]                       }
[17:38:09.097]                     }, args = future.call.arguments)
[17:38:09.097]                   }
[17:38:09.097]                 }, immediateCondition = function(cond) {
[17:38:09.097]                   save_rds <- function (object, pathname, ...) 
[17:38:09.097]                   {
[17:38:09.097]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:09.097]                     if (file_test("-f", pathname_tmp)) {
[17:38:09.097]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.097]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:09.097]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.097]                         fi_tmp[["mtime"]])
[17:38:09.097]                     }
[17:38:09.097]                     tryCatch({
[17:38:09.097]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:09.097]                     }, error = function(ex) {
[17:38:09.097]                       msg <- conditionMessage(ex)
[17:38:09.097]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.097]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:09.097]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.097]                         fi_tmp[["mtime"]], msg)
[17:38:09.097]                       ex$message <- msg
[17:38:09.097]                       stop(ex)
[17:38:09.097]                     })
[17:38:09.097]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:09.097]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:09.097]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:09.097]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.097]                       fi <- file.info(pathname)
[17:38:09.097]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:09.097]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.097]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:09.097]                         fi[["size"]], fi[["mtime"]])
[17:38:09.097]                       stop(msg)
[17:38:09.097]                     }
[17:38:09.097]                     invisible(pathname)
[17:38:09.097]                   }
[17:38:09.097]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:09.097]                     rootPath = tempdir()) 
[17:38:09.097]                   {
[17:38:09.097]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:09.097]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:09.097]                       tmpdir = path, fileext = ".rds")
[17:38:09.097]                     save_rds(obj, file)
[17:38:09.097]                   }
[17:38:09.097]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:09.097]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.097]                   {
[17:38:09.097]                     inherits <- base::inherits
[17:38:09.097]                     invokeRestart <- base::invokeRestart
[17:38:09.097]                     is.null <- base::is.null
[17:38:09.097]                     muffled <- FALSE
[17:38:09.097]                     if (inherits(cond, "message")) {
[17:38:09.097]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:09.097]                       if (muffled) 
[17:38:09.097]                         invokeRestart("muffleMessage")
[17:38:09.097]                     }
[17:38:09.097]                     else if (inherits(cond, "warning")) {
[17:38:09.097]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:09.097]                       if (muffled) 
[17:38:09.097]                         invokeRestart("muffleWarning")
[17:38:09.097]                     }
[17:38:09.097]                     else if (inherits(cond, "condition")) {
[17:38:09.097]                       if (!is.null(pattern)) {
[17:38:09.097]                         computeRestarts <- base::computeRestarts
[17:38:09.097]                         grepl <- base::grepl
[17:38:09.097]                         restarts <- computeRestarts(cond)
[17:38:09.097]                         for (restart in restarts) {
[17:38:09.097]                           name <- restart$name
[17:38:09.097]                           if (is.null(name)) 
[17:38:09.097]                             next
[17:38:09.097]                           if (!grepl(pattern, name)) 
[17:38:09.097]                             next
[17:38:09.097]                           invokeRestart(restart)
[17:38:09.097]                           muffled <- TRUE
[17:38:09.097]                           break
[17:38:09.097]                         }
[17:38:09.097]                       }
[17:38:09.097]                     }
[17:38:09.097]                     invisible(muffled)
[17:38:09.097]                   }
[17:38:09.097]                   muffleCondition(cond)
[17:38:09.097]                 })
[17:38:09.097]             }))
[17:38:09.097]             future::FutureResult(value = ...future.value$value, 
[17:38:09.097]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.097]                   ...future.rng), globalenv = if (FALSE) 
[17:38:09.097]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:09.097]                     ...future.globalenv.names))
[17:38:09.097]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:09.097]         }, condition = base::local({
[17:38:09.097]             c <- base::c
[17:38:09.097]             inherits <- base::inherits
[17:38:09.097]             invokeRestart <- base::invokeRestart
[17:38:09.097]             length <- base::length
[17:38:09.097]             list <- base::list
[17:38:09.097]             seq.int <- base::seq.int
[17:38:09.097]             signalCondition <- base::signalCondition
[17:38:09.097]             sys.calls <- base::sys.calls
[17:38:09.097]             `[[` <- base::`[[`
[17:38:09.097]             `+` <- base::`+`
[17:38:09.097]             `<<-` <- base::`<<-`
[17:38:09.097]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:09.097]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:09.097]                   3L)]
[17:38:09.097]             }
[17:38:09.097]             function(cond) {
[17:38:09.097]                 is_error <- inherits(cond, "error")
[17:38:09.097]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:09.097]                   NULL)
[17:38:09.097]                 if (is_error) {
[17:38:09.097]                   sessionInformation <- function() {
[17:38:09.097]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:09.097]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:09.097]                       search = base::search(), system = base::Sys.info())
[17:38:09.097]                   }
[17:38:09.097]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.097]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:09.097]                     cond$call), session = sessionInformation(), 
[17:38:09.097]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:09.097]                   signalCondition(cond)
[17:38:09.097]                 }
[17:38:09.097]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:09.097]                 "immediateCondition"))) {
[17:38:09.097]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:09.097]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.097]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:09.097]                   if (TRUE && !signal) {
[17:38:09.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.097]                     {
[17:38:09.097]                       inherits <- base::inherits
[17:38:09.097]                       invokeRestart <- base::invokeRestart
[17:38:09.097]                       is.null <- base::is.null
[17:38:09.097]                       muffled <- FALSE
[17:38:09.097]                       if (inherits(cond, "message")) {
[17:38:09.097]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.097]                         if (muffled) 
[17:38:09.097]                           invokeRestart("muffleMessage")
[17:38:09.097]                       }
[17:38:09.097]                       else if (inherits(cond, "warning")) {
[17:38:09.097]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.097]                         if (muffled) 
[17:38:09.097]                           invokeRestart("muffleWarning")
[17:38:09.097]                       }
[17:38:09.097]                       else if (inherits(cond, "condition")) {
[17:38:09.097]                         if (!is.null(pattern)) {
[17:38:09.097]                           computeRestarts <- base::computeRestarts
[17:38:09.097]                           grepl <- base::grepl
[17:38:09.097]                           restarts <- computeRestarts(cond)
[17:38:09.097]                           for (restart in restarts) {
[17:38:09.097]                             name <- restart$name
[17:38:09.097]                             if (is.null(name)) 
[17:38:09.097]                               next
[17:38:09.097]                             if (!grepl(pattern, name)) 
[17:38:09.097]                               next
[17:38:09.097]                             invokeRestart(restart)
[17:38:09.097]                             muffled <- TRUE
[17:38:09.097]                             break
[17:38:09.097]                           }
[17:38:09.097]                         }
[17:38:09.097]                       }
[17:38:09.097]                       invisible(muffled)
[17:38:09.097]                     }
[17:38:09.097]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.097]                   }
[17:38:09.097]                 }
[17:38:09.097]                 else {
[17:38:09.097]                   if (TRUE) {
[17:38:09.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.097]                     {
[17:38:09.097]                       inherits <- base::inherits
[17:38:09.097]                       invokeRestart <- base::invokeRestart
[17:38:09.097]                       is.null <- base::is.null
[17:38:09.097]                       muffled <- FALSE
[17:38:09.097]                       if (inherits(cond, "message")) {
[17:38:09.097]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.097]                         if (muffled) 
[17:38:09.097]                           invokeRestart("muffleMessage")
[17:38:09.097]                       }
[17:38:09.097]                       else if (inherits(cond, "warning")) {
[17:38:09.097]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.097]                         if (muffled) 
[17:38:09.097]                           invokeRestart("muffleWarning")
[17:38:09.097]                       }
[17:38:09.097]                       else if (inherits(cond, "condition")) {
[17:38:09.097]                         if (!is.null(pattern)) {
[17:38:09.097]                           computeRestarts <- base::computeRestarts
[17:38:09.097]                           grepl <- base::grepl
[17:38:09.097]                           restarts <- computeRestarts(cond)
[17:38:09.097]                           for (restart in restarts) {
[17:38:09.097]                             name <- restart$name
[17:38:09.097]                             if (is.null(name)) 
[17:38:09.097]                               next
[17:38:09.097]                             if (!grepl(pattern, name)) 
[17:38:09.097]                               next
[17:38:09.097]                             invokeRestart(restart)
[17:38:09.097]                             muffled <- TRUE
[17:38:09.097]                             break
[17:38:09.097]                           }
[17:38:09.097]                         }
[17:38:09.097]                       }
[17:38:09.097]                       invisible(muffled)
[17:38:09.097]                     }
[17:38:09.097]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.097]                   }
[17:38:09.097]                 }
[17:38:09.097]             }
[17:38:09.097]         }))
[17:38:09.097]     }, error = function(ex) {
[17:38:09.097]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:09.097]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.097]                 ...future.rng), started = ...future.startTime, 
[17:38:09.097]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:09.097]             version = "1.8"), class = "FutureResult")
[17:38:09.097]     }, finally = {
[17:38:09.097]         if (!identical(...future.workdir, getwd())) 
[17:38:09.097]             setwd(...future.workdir)
[17:38:09.097]         {
[17:38:09.097]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:09.097]                 ...future.oldOptions$nwarnings <- NULL
[17:38:09.097]             }
[17:38:09.097]             base::options(...future.oldOptions)
[17:38:09.097]             if (.Platform$OS.type == "windows") {
[17:38:09.097]                 old_names <- names(...future.oldEnvVars)
[17:38:09.097]                 envs <- base::Sys.getenv()
[17:38:09.097]                 names <- names(envs)
[17:38:09.097]                 common <- intersect(names, old_names)
[17:38:09.097]                 added <- setdiff(names, old_names)
[17:38:09.097]                 removed <- setdiff(old_names, names)
[17:38:09.097]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:09.097]                   envs[common]]
[17:38:09.097]                 NAMES <- toupper(changed)
[17:38:09.097]                 args <- list()
[17:38:09.097]                 for (kk in seq_along(NAMES)) {
[17:38:09.097]                   name <- changed[[kk]]
[17:38:09.097]                   NAME <- NAMES[[kk]]
[17:38:09.097]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.097]                     next
[17:38:09.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.097]                 }
[17:38:09.097]                 NAMES <- toupper(added)
[17:38:09.097]                 for (kk in seq_along(NAMES)) {
[17:38:09.097]                   name <- added[[kk]]
[17:38:09.097]                   NAME <- NAMES[[kk]]
[17:38:09.097]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.097]                     next
[17:38:09.097]                   args[[name]] <- ""
[17:38:09.097]                 }
[17:38:09.097]                 NAMES <- toupper(removed)
[17:38:09.097]                 for (kk in seq_along(NAMES)) {
[17:38:09.097]                   name <- removed[[kk]]
[17:38:09.097]                   NAME <- NAMES[[kk]]
[17:38:09.097]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.097]                     next
[17:38:09.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.097]                 }
[17:38:09.097]                 if (length(args) > 0) 
[17:38:09.097]                   base::do.call(base::Sys.setenv, args = args)
[17:38:09.097]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:09.097]             }
[17:38:09.097]             else {
[17:38:09.097]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:09.097]             }
[17:38:09.097]             {
[17:38:09.097]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:09.097]                   0L) {
[17:38:09.097]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:09.097]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:09.097]                   base::options(opts)
[17:38:09.097]                 }
[17:38:09.097]                 {
[17:38:09.097]                   {
[17:38:09.097]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:09.097]                     NULL
[17:38:09.097]                   }
[17:38:09.097]                   options(future.plan = NULL)
[17:38:09.097]                   if (is.na(NA_character_)) 
[17:38:09.097]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.097]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:09.097]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:09.097]                     .init = FALSE)
[17:38:09.097]                 }
[17:38:09.097]             }
[17:38:09.097]         }
[17:38:09.097]     })
[17:38:09.097]     if (TRUE) {
[17:38:09.097]         base::sink(type = "output", split = FALSE)
[17:38:09.097]         if (TRUE) {
[17:38:09.097]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:09.097]         }
[17:38:09.097]         else {
[17:38:09.097]             ...future.result["stdout"] <- base::list(NULL)
[17:38:09.097]         }
[17:38:09.097]         base::close(...future.stdout)
[17:38:09.097]         ...future.stdout <- NULL
[17:38:09.097]     }
[17:38:09.097]     ...future.result$conditions <- ...future.conditions
[17:38:09.097]     ...future.result$finished <- base::Sys.time()
[17:38:09.097]     ...future.result
[17:38:09.097] }
[17:38:09.101] assign_globals() ...
[17:38:09.101] List of 11
[17:38:09.101]  $ ...future.FUN            :function (x, ...)  
[17:38:09.101]  $ x_FUN                    :function (x, y)  
[17:38:09.101]  $ times                    : int 15
[17:38:09.101]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:09.101]  $ stop_if_not              :function (...)  
[17:38:09.101]  $ dim                      : int [1:2] 3 5
[17:38:09.101]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:09.101]  $ future.call.arguments    :List of 1
[17:38:09.101]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:09.101]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.101]  $ ...future.elements_ii    :List of 2
[17:38:09.101]   ..$ C: num 70
[17:38:09.101]   ..$ D: num 80
[17:38:09.101]  $ ...future.seeds_ii       : NULL
[17:38:09.101]  $ ...future.globals.maxSize: NULL
[17:38:09.101]  - attr(*, "where")=List of 11
[17:38:09.101]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:09.101]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:09.101]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:09.101]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:09.101]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:09.101]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:09.101]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:09.101]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:09.101]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:09.101]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:09.101]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:09.101]  - attr(*, "resolved")= logi FALSE
[17:38:09.101]  - attr(*, "total_size")= num 98600
[17:38:09.101]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.101]  - attr(*, "already-done")= logi TRUE
[17:38:09.117] - copied ‘...future.FUN’ to environment
[17:38:09.117] - reassign environment for ‘x_FUN’
[17:38:09.118] - copied ‘x_FUN’ to environment
[17:38:09.118] - copied ‘times’ to environment
[17:38:09.118] - copied ‘stopf’ to environment
[17:38:09.118] - copied ‘stop_if_not’ to environment
[17:38:09.118] - copied ‘dim’ to environment
[17:38:09.118] - copied ‘valid_types’ to environment
[17:38:09.118] - copied ‘future.call.arguments’ to environment
[17:38:09.119] - copied ‘...future.elements_ii’ to environment
[17:38:09.119] - copied ‘...future.seeds_ii’ to environment
[17:38:09.119] - copied ‘...future.globals.maxSize’ to environment
[17:38:09.119] assign_globals() ... done
[17:38:09.119] requestCore(): workers = 2
[17:38:09.122] MulticoreFuture started
[17:38:09.122] - Launch lazy future ... done
[17:38:09.123] run() for ‘MulticoreFuture’ ... done
[17:38:09.123] Created future:
[17:38:09.124] plan(): Setting new future strategy stack:
[17:38:09.124] List of future strategies:
[17:38:09.124] 1. sequential:
[17:38:09.124]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:09.124]    - tweaked: FALSE
[17:38:09.124]    - call: NULL
[17:38:09.126] plan(): nbrOfWorkers() = 1
[17:38:09.129] plan(): Setting new future strategy stack:
[17:38:09.129] List of future strategies:
[17:38:09.129] 1. multicore:
[17:38:09.129]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:09.129]    - tweaked: FALSE
[17:38:09.129]    - call: plan(strategy)
[17:38:09.135] plan(): nbrOfWorkers() = 2
[17:38:09.124] MulticoreFuture:
[17:38:09.124] Label: ‘future_vapply-2’
[17:38:09.124] Expression:
[17:38:09.124] {
[17:38:09.124]     do.call(function(...) {
[17:38:09.124]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.124]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.124]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.124]             on.exit(options(oopts), add = TRUE)
[17:38:09.124]         }
[17:38:09.124]         {
[17:38:09.124]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.124]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.124]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.124]             })
[17:38:09.124]         }
[17:38:09.124]     }, args = future.call.arguments)
[17:38:09.124] }
[17:38:09.124] Lazy evaluation: FALSE
[17:38:09.124] Asynchronous evaluation: TRUE
[17:38:09.124] Local evaluation: TRUE
[17:38:09.124] Environment: R_GlobalEnv
[17:38:09.124] Capture standard output: TRUE
[17:38:09.124] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:09.124] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:09.124] Packages: 1 packages (‘future.apply’)
[17:38:09.124] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:09.124] Resolved: TRUE
[17:38:09.124] Value: <not collected>
[17:38:09.124] Conditions captured: <none>
[17:38:09.124] Early signaling: FALSE
[17:38:09.124] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:09.124] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.137] Chunk #2 of 2 ... DONE
[17:38:09.137] Launching 2 futures (chunks) ... DONE
[17:38:09.137] Resolving 2 futures (chunks) ...
[17:38:09.137] resolve() on list ...
[17:38:09.137]  recursive: 0
[17:38:09.138]  length: 2
[17:38:09.138] 
[17:38:09.138] Future #1
[17:38:09.139] result() for MulticoreFuture ...
[17:38:09.139] result() for MulticoreFuture ...
[17:38:09.139] result() for MulticoreFuture ... done
[17:38:09.140] result() for MulticoreFuture ... done
[17:38:09.140] result() for MulticoreFuture ...
[17:38:09.140] result() for MulticoreFuture ... done
[17:38:09.140] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:09.141] - nx: 2
[17:38:09.141] - relay: TRUE
[17:38:09.141] - stdout: TRUE
[17:38:09.141] - signal: TRUE
[17:38:09.141] - resignal: FALSE
[17:38:09.141] - force: TRUE
[17:38:09.141] - relayed: [n=2] FALSE, FALSE
[17:38:09.142] - queued futures: [n=2] FALSE, FALSE
[17:38:09.142]  - until=1
[17:38:09.142]  - relaying element #1
[17:38:09.142] result() for MulticoreFuture ...
[17:38:09.142] result() for MulticoreFuture ... done
[17:38:09.142] result() for MulticoreFuture ...
[17:38:09.143] result() for MulticoreFuture ... done
[17:38:09.143] result() for MulticoreFuture ...
[17:38:09.143] result() for MulticoreFuture ... done
[17:38:09.143] result() for MulticoreFuture ...
[17:38:09.143] result() for MulticoreFuture ... done
[17:38:09.143] - relayed: [n=2] TRUE, FALSE
[17:38:09.143] - queued futures: [n=2] TRUE, FALSE
[17:38:09.144] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:09.144]  length: 1 (resolved future 1)
[17:38:09.144] Future #2
[17:38:09.144] result() for MulticoreFuture ...
[17:38:09.145] result() for MulticoreFuture ...
[17:38:09.145] result() for MulticoreFuture ... done
[17:38:09.145] result() for MulticoreFuture ... done
[17:38:09.145] result() for MulticoreFuture ...
[17:38:09.146] result() for MulticoreFuture ... done
[17:38:09.146] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:09.146] - nx: 2
[17:38:09.146] - relay: TRUE
[17:38:09.146] - stdout: TRUE
[17:38:09.146] - signal: TRUE
[17:38:09.146] - resignal: FALSE
[17:38:09.146] - force: TRUE
[17:38:09.146] - relayed: [n=2] TRUE, FALSE
[17:38:09.147] - queued futures: [n=2] TRUE, FALSE
[17:38:09.147]  - until=2
[17:38:09.147]  - relaying element #2
[17:38:09.147] result() for MulticoreFuture ...
[17:38:09.147] result() for MulticoreFuture ... done
[17:38:09.147] result() for MulticoreFuture ...
[17:38:09.147] result() for MulticoreFuture ... done
[17:38:09.147] result() for MulticoreFuture ...
[17:38:09.148] result() for MulticoreFuture ... done
[17:38:09.148] result() for MulticoreFuture ...
[17:38:09.148] result() for MulticoreFuture ... done
[17:38:09.148] - relayed: [n=2] TRUE, TRUE
[17:38:09.148] - queued futures: [n=2] TRUE, TRUE
[17:38:09.148] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:09.148]  length: 0 (resolved future 2)
[17:38:09.148] Relaying remaining futures
[17:38:09.148] signalConditionsASAP(NULL, pos=0) ...
[17:38:09.149] - nx: 2
[17:38:09.149] - relay: TRUE
[17:38:09.149] - stdout: TRUE
[17:38:09.149] - signal: TRUE
[17:38:09.149] - resignal: FALSE
[17:38:09.149] - force: TRUE
[17:38:09.149] - relayed: [n=2] TRUE, TRUE
[17:38:09.149] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:09.149] - relayed: [n=2] TRUE, TRUE
[17:38:09.149] - queued futures: [n=2] TRUE, TRUE
[17:38:09.150] signalConditionsASAP(NULL, pos=0) ... done
[17:38:09.150] resolve() on list ... DONE
[17:38:09.150] result() for MulticoreFuture ...
[17:38:09.150] result() for MulticoreFuture ... done
[17:38:09.150] result() for MulticoreFuture ...
[17:38:09.150] result() for MulticoreFuture ... done
[17:38:09.150] result() for MulticoreFuture ...
[17:38:09.150] result() for MulticoreFuture ... done
[17:38:09.150] result() for MulticoreFuture ...
[17:38:09.151] result() for MulticoreFuture ... done
[17:38:09.151]  - Number of value chunks collected: 2
[17:38:09.151] Resolving 2 futures (chunks) ... DONE
[17:38:09.151] Reducing values from 2 chunks ...
[17:38:09.151]  - Number of values collected after concatenation: 4
[17:38:09.151]  - Number of values expected: 4
[17:38:09.151] Reducing values from 2 chunks ... DONE
[17:38:09.151] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[17:38:09.153] future_lapply() ...
[17:38:09.163] Number of chunks: 2
[17:38:09.163] getGlobalsAndPackagesXApply() ...
[17:38:09.163]  - future.globals: TRUE
[17:38:09.163] getGlobalsAndPackages() ...
[17:38:09.163] Searching for globals...
[17:38:09.168] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:09.168] Searching for globals ... DONE
[17:38:09.168] Resolving globals: FALSE
[17:38:09.169] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[17:38:09.169] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:09.170] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:09.170] - packages: [1] ‘future.apply’
[17:38:09.170] getGlobalsAndPackages() ... DONE
[17:38:09.170]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:09.170]  - needed namespaces: [n=1] ‘future.apply’
[17:38:09.170] Finding globals ... DONE
[17:38:09.170]  - use_args: TRUE
[17:38:09.171]  - Getting '...' globals ...
[17:38:09.171] resolve() on list ...
[17:38:09.171]  recursive: 0
[17:38:09.171]  length: 1
[17:38:09.171]  elements: ‘...’
[17:38:09.171]  length: 0 (resolved future 1)
[17:38:09.171] resolve() on list ... DONE
[17:38:09.172]    - '...' content: [n=0] 
[17:38:09.172] List of 1
[17:38:09.172]  $ ...: list()
[17:38:09.172]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.172]  - attr(*, "where")=List of 1
[17:38:09.172]   ..$ ...:<environment: 0x560801803c20> 
[17:38:09.172]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.172]  - attr(*, "resolved")= logi TRUE
[17:38:09.172]  - attr(*, "total_size")= num NA
[17:38:09.174]  - Getting '...' globals ... DONE
[17:38:09.175] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:09.175] List of 8
[17:38:09.175]  $ ...future.FUN:function (x, ...)  
[17:38:09.175]  $ x_FUN        :function (x)  
[17:38:09.175]  $ times        : int 1
[17:38:09.175]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:09.175]  $ stop_if_not  :function (...)  
[17:38:09.175]  $ dim          : NULL
[17:38:09.175]  $ valid_types  : chr "logical"
[17:38:09.175]  $ ...          : list()
[17:38:09.175]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.175]  - attr(*, "where")=List of 8
[17:38:09.175]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:09.175]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:09.175]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:09.175]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:09.175]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:09.175]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:09.175]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:09.175]   ..$ ...          :<environment: 0x560801803c20> 
[17:38:09.175]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.175]  - attr(*, "resolved")= logi FALSE
[17:38:09.175]  - attr(*, "total_size")= num 94200
[17:38:09.180] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:09.180] getGlobalsAndPackagesXApply() ... DONE
[17:38:09.180] Number of futures (= number of chunks): 2
[17:38:09.181] Launching 2 futures (chunks) ...
[17:38:09.181] Chunk #1 of 2 ...
[17:38:09.181]  - Finding globals in 'X' for chunk #1 ...
[17:38:09.181] getGlobalsAndPackages() ...
[17:38:09.181] Searching for globals...
[17:38:09.181] 
[17:38:09.181] Searching for globals ... DONE
[17:38:09.182] - globals: [0] <none>
[17:38:09.182] getGlobalsAndPackages() ... DONE
[17:38:09.182]    + additional globals found: [n=0] 
[17:38:09.182]    + additional namespaces needed: [n=0] 
[17:38:09.182]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:09.182]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:09.182]  - seeds: <none>
[17:38:09.182]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.182] getGlobalsAndPackages() ...
[17:38:09.182] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.183] Resolving globals: FALSE
[17:38:09.183] Tweak future expression to call with '...' arguments ...
[17:38:09.183] {
[17:38:09.183]     do.call(function(...) {
[17:38:09.183]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.183]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.183]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.183]             on.exit(options(oopts), add = TRUE)
[17:38:09.183]         }
[17:38:09.183]         {
[17:38:09.183]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.183]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.183]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.183]             })
[17:38:09.183]         }
[17:38:09.183]     }, args = future.call.arguments)
[17:38:09.183] }
[17:38:09.183] Tweak future expression to call with '...' arguments ... DONE
[17:38:09.186] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.186] - packages: [1] ‘future.apply’
[17:38:09.186] getGlobalsAndPackages() ... DONE
[17:38:09.186] run() for ‘Future’ ...
[17:38:09.187] - state: ‘created’
[17:38:09.187] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:09.191] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.191] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:09.191]   - Field: ‘label’
[17:38:09.191]   - Field: ‘local’
[17:38:09.192]   - Field: ‘owner’
[17:38:09.192]   - Field: ‘envir’
[17:38:09.192]   - Field: ‘workers’
[17:38:09.192]   - Field: ‘packages’
[17:38:09.192]   - Field: ‘gc’
[17:38:09.192]   - Field: ‘job’
[17:38:09.192]   - Field: ‘conditions’
[17:38:09.192]   - Field: ‘expr’
[17:38:09.192]   - Field: ‘uuid’
[17:38:09.193]   - Field: ‘seed’
[17:38:09.193]   - Field: ‘version’
[17:38:09.193]   - Field: ‘result’
[17:38:09.193]   - Field: ‘asynchronous’
[17:38:09.193]   - Field: ‘calls’
[17:38:09.193]   - Field: ‘globals’
[17:38:09.193]   - Field: ‘stdout’
[17:38:09.193]   - Field: ‘earlySignal’
[17:38:09.193]   - Field: ‘lazy’
[17:38:09.194]   - Field: ‘state’
[17:38:09.194] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:09.194] - Launch lazy future ...
[17:38:09.194] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:09.194] Packages needed by future strategies (n = 0): <none>
[17:38:09.195] {
[17:38:09.195]     {
[17:38:09.195]         {
[17:38:09.195]             ...future.startTime <- base::Sys.time()
[17:38:09.195]             {
[17:38:09.195]                 {
[17:38:09.195]                   {
[17:38:09.195]                     {
[17:38:09.195]                       {
[17:38:09.195]                         base::local({
[17:38:09.195]                           has_future <- base::requireNamespace("future", 
[17:38:09.195]                             quietly = TRUE)
[17:38:09.195]                           if (has_future) {
[17:38:09.195]                             ns <- base::getNamespace("future")
[17:38:09.195]                             version <- ns[[".package"]][["version"]]
[17:38:09.195]                             if (is.null(version)) 
[17:38:09.195]                               version <- utils::packageVersion("future")
[17:38:09.195]                           }
[17:38:09.195]                           else {
[17:38:09.195]                             version <- NULL
[17:38:09.195]                           }
[17:38:09.195]                           if (!has_future || version < "1.8.0") {
[17:38:09.195]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:09.195]                               "", base::R.version$version.string), 
[17:38:09.195]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:09.195]                                 base::R.version$platform, 8 * 
[17:38:09.195]                                   base::.Machine$sizeof.pointer), 
[17:38:09.195]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:09.195]                                 "release", "version")], collapse = " "), 
[17:38:09.195]                               hostname = base::Sys.info()[["nodename"]])
[17:38:09.195]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:09.195]                               info)
[17:38:09.195]                             info <- base::paste(info, collapse = "; ")
[17:38:09.195]                             if (!has_future) {
[17:38:09.195]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:09.195]                                 info)
[17:38:09.195]                             }
[17:38:09.195]                             else {
[17:38:09.195]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:09.195]                                 info, version)
[17:38:09.195]                             }
[17:38:09.195]                             base::stop(msg)
[17:38:09.195]                           }
[17:38:09.195]                         })
[17:38:09.195]                       }
[17:38:09.195]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:09.195]                       base::options(mc.cores = 1L)
[17:38:09.195]                     }
[17:38:09.195]                     base::local({
[17:38:09.195]                       for (pkg in "future.apply") {
[17:38:09.195]                         base::loadNamespace(pkg)
[17:38:09.195]                         base::library(pkg, character.only = TRUE)
[17:38:09.195]                       }
[17:38:09.195]                     })
[17:38:09.195]                   }
[17:38:09.195]                   ...future.strategy.old <- future::plan("list")
[17:38:09.195]                   options(future.plan = NULL)
[17:38:09.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:09.195]                 }
[17:38:09.195]                 ...future.workdir <- getwd()
[17:38:09.195]             }
[17:38:09.195]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:09.195]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:09.195]         }
[17:38:09.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:09.195]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:09.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:09.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:09.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:09.195]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:09.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:09.195]             base::names(...future.oldOptions))
[17:38:09.195]     }
[17:38:09.195]     if (FALSE) {
[17:38:09.195]     }
[17:38:09.195]     else {
[17:38:09.195]         if (TRUE) {
[17:38:09.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:09.195]                 open = "w")
[17:38:09.195]         }
[17:38:09.195]         else {
[17:38:09.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:09.195]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:09.195]         }
[17:38:09.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:09.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:09.195]             base::sink(type = "output", split = FALSE)
[17:38:09.195]             base::close(...future.stdout)
[17:38:09.195]         }, add = TRUE)
[17:38:09.195]     }
[17:38:09.195]     ...future.frame <- base::sys.nframe()
[17:38:09.195]     ...future.conditions <- base::list()
[17:38:09.195]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:09.195]     if (FALSE) {
[17:38:09.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:09.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:09.195]     }
[17:38:09.195]     ...future.result <- base::tryCatch({
[17:38:09.195]         base::withCallingHandlers({
[17:38:09.195]             ...future.value <- base::withVisible(base::local({
[17:38:09.195]                 withCallingHandlers({
[17:38:09.195]                   {
[17:38:09.195]                     do.call(function(...) {
[17:38:09.195]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.195]                       if (!identical(...future.globals.maxSize.org, 
[17:38:09.195]                         ...future.globals.maxSize)) {
[17:38:09.195]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.195]                         on.exit(options(oopts), add = TRUE)
[17:38:09.195]                       }
[17:38:09.195]                       {
[17:38:09.195]                         lapply(seq_along(...future.elements_ii), 
[17:38:09.195]                           FUN = function(jj) {
[17:38:09.195]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.195]                             ...future.FUN(...future.X_jj, ...)
[17:38:09.195]                           })
[17:38:09.195]                       }
[17:38:09.195]                     }, args = future.call.arguments)
[17:38:09.195]                   }
[17:38:09.195]                 }, immediateCondition = function(cond) {
[17:38:09.195]                   save_rds <- function (object, pathname, ...) 
[17:38:09.195]                   {
[17:38:09.195]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:09.195]                     if (file_test("-f", pathname_tmp)) {
[17:38:09.195]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.195]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:09.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.195]                         fi_tmp[["mtime"]])
[17:38:09.195]                     }
[17:38:09.195]                     tryCatch({
[17:38:09.195]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:09.195]                     }, error = function(ex) {
[17:38:09.195]                       msg <- conditionMessage(ex)
[17:38:09.195]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.195]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:09.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.195]                         fi_tmp[["mtime"]], msg)
[17:38:09.195]                       ex$message <- msg
[17:38:09.195]                       stop(ex)
[17:38:09.195]                     })
[17:38:09.195]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:09.195]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:09.195]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:09.195]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.195]                       fi <- file.info(pathname)
[17:38:09.195]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:09.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.195]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:09.195]                         fi[["size"]], fi[["mtime"]])
[17:38:09.195]                       stop(msg)
[17:38:09.195]                     }
[17:38:09.195]                     invisible(pathname)
[17:38:09.195]                   }
[17:38:09.195]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:09.195]                     rootPath = tempdir()) 
[17:38:09.195]                   {
[17:38:09.195]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:09.195]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:09.195]                       tmpdir = path, fileext = ".rds")
[17:38:09.195]                     save_rds(obj, file)
[17:38:09.195]                   }
[17:38:09.195]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:09.195]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.195]                   {
[17:38:09.195]                     inherits <- base::inherits
[17:38:09.195]                     invokeRestart <- base::invokeRestart
[17:38:09.195]                     is.null <- base::is.null
[17:38:09.195]                     muffled <- FALSE
[17:38:09.195]                     if (inherits(cond, "message")) {
[17:38:09.195]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:09.195]                       if (muffled) 
[17:38:09.195]                         invokeRestart("muffleMessage")
[17:38:09.195]                     }
[17:38:09.195]                     else if (inherits(cond, "warning")) {
[17:38:09.195]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:09.195]                       if (muffled) 
[17:38:09.195]                         invokeRestart("muffleWarning")
[17:38:09.195]                     }
[17:38:09.195]                     else if (inherits(cond, "condition")) {
[17:38:09.195]                       if (!is.null(pattern)) {
[17:38:09.195]                         computeRestarts <- base::computeRestarts
[17:38:09.195]                         grepl <- base::grepl
[17:38:09.195]                         restarts <- computeRestarts(cond)
[17:38:09.195]                         for (restart in restarts) {
[17:38:09.195]                           name <- restart$name
[17:38:09.195]                           if (is.null(name)) 
[17:38:09.195]                             next
[17:38:09.195]                           if (!grepl(pattern, name)) 
[17:38:09.195]                             next
[17:38:09.195]                           invokeRestart(restart)
[17:38:09.195]                           muffled <- TRUE
[17:38:09.195]                           break
[17:38:09.195]                         }
[17:38:09.195]                       }
[17:38:09.195]                     }
[17:38:09.195]                     invisible(muffled)
[17:38:09.195]                   }
[17:38:09.195]                   muffleCondition(cond)
[17:38:09.195]                 })
[17:38:09.195]             }))
[17:38:09.195]             future::FutureResult(value = ...future.value$value, 
[17:38:09.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.195]                   ...future.rng), globalenv = if (FALSE) 
[17:38:09.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:09.195]                     ...future.globalenv.names))
[17:38:09.195]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:09.195]         }, condition = base::local({
[17:38:09.195]             c <- base::c
[17:38:09.195]             inherits <- base::inherits
[17:38:09.195]             invokeRestart <- base::invokeRestart
[17:38:09.195]             length <- base::length
[17:38:09.195]             list <- base::list
[17:38:09.195]             seq.int <- base::seq.int
[17:38:09.195]             signalCondition <- base::signalCondition
[17:38:09.195]             sys.calls <- base::sys.calls
[17:38:09.195]             `[[` <- base::`[[`
[17:38:09.195]             `+` <- base::`+`
[17:38:09.195]             `<<-` <- base::`<<-`
[17:38:09.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:09.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:09.195]                   3L)]
[17:38:09.195]             }
[17:38:09.195]             function(cond) {
[17:38:09.195]                 is_error <- inherits(cond, "error")
[17:38:09.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:09.195]                   NULL)
[17:38:09.195]                 if (is_error) {
[17:38:09.195]                   sessionInformation <- function() {
[17:38:09.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:09.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:09.195]                       search = base::search(), system = base::Sys.info())
[17:38:09.195]                   }
[17:38:09.195]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:09.195]                     cond$call), session = sessionInformation(), 
[17:38:09.195]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:09.195]                   signalCondition(cond)
[17:38:09.195]                 }
[17:38:09.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:09.195]                 "immediateCondition"))) {
[17:38:09.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:09.195]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:09.195]                   if (TRUE && !signal) {
[17:38:09.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.195]                     {
[17:38:09.195]                       inherits <- base::inherits
[17:38:09.195]                       invokeRestart <- base::invokeRestart
[17:38:09.195]                       is.null <- base::is.null
[17:38:09.195]                       muffled <- FALSE
[17:38:09.195]                       if (inherits(cond, "message")) {
[17:38:09.195]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.195]                         if (muffled) 
[17:38:09.195]                           invokeRestart("muffleMessage")
[17:38:09.195]                       }
[17:38:09.195]                       else if (inherits(cond, "warning")) {
[17:38:09.195]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.195]                         if (muffled) 
[17:38:09.195]                           invokeRestart("muffleWarning")
[17:38:09.195]                       }
[17:38:09.195]                       else if (inherits(cond, "condition")) {
[17:38:09.195]                         if (!is.null(pattern)) {
[17:38:09.195]                           computeRestarts <- base::computeRestarts
[17:38:09.195]                           grepl <- base::grepl
[17:38:09.195]                           restarts <- computeRestarts(cond)
[17:38:09.195]                           for (restart in restarts) {
[17:38:09.195]                             name <- restart$name
[17:38:09.195]                             if (is.null(name)) 
[17:38:09.195]                               next
[17:38:09.195]                             if (!grepl(pattern, name)) 
[17:38:09.195]                               next
[17:38:09.195]                             invokeRestart(restart)
[17:38:09.195]                             muffled <- TRUE
[17:38:09.195]                             break
[17:38:09.195]                           }
[17:38:09.195]                         }
[17:38:09.195]                       }
[17:38:09.195]                       invisible(muffled)
[17:38:09.195]                     }
[17:38:09.195]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.195]                   }
[17:38:09.195]                 }
[17:38:09.195]                 else {
[17:38:09.195]                   if (TRUE) {
[17:38:09.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.195]                     {
[17:38:09.195]                       inherits <- base::inherits
[17:38:09.195]                       invokeRestart <- base::invokeRestart
[17:38:09.195]                       is.null <- base::is.null
[17:38:09.195]                       muffled <- FALSE
[17:38:09.195]                       if (inherits(cond, "message")) {
[17:38:09.195]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.195]                         if (muffled) 
[17:38:09.195]                           invokeRestart("muffleMessage")
[17:38:09.195]                       }
[17:38:09.195]                       else if (inherits(cond, "warning")) {
[17:38:09.195]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.195]                         if (muffled) 
[17:38:09.195]                           invokeRestart("muffleWarning")
[17:38:09.195]                       }
[17:38:09.195]                       else if (inherits(cond, "condition")) {
[17:38:09.195]                         if (!is.null(pattern)) {
[17:38:09.195]                           computeRestarts <- base::computeRestarts
[17:38:09.195]                           grepl <- base::grepl
[17:38:09.195]                           restarts <- computeRestarts(cond)
[17:38:09.195]                           for (restart in restarts) {
[17:38:09.195]                             name <- restart$name
[17:38:09.195]                             if (is.null(name)) 
[17:38:09.195]                               next
[17:38:09.195]                             if (!grepl(pattern, name)) 
[17:38:09.195]                               next
[17:38:09.195]                             invokeRestart(restart)
[17:38:09.195]                             muffled <- TRUE
[17:38:09.195]                             break
[17:38:09.195]                           }
[17:38:09.195]                         }
[17:38:09.195]                       }
[17:38:09.195]                       invisible(muffled)
[17:38:09.195]                     }
[17:38:09.195]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.195]                   }
[17:38:09.195]                 }
[17:38:09.195]             }
[17:38:09.195]         }))
[17:38:09.195]     }, error = function(ex) {
[17:38:09.195]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:09.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.195]                 ...future.rng), started = ...future.startTime, 
[17:38:09.195]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:09.195]             version = "1.8"), class = "FutureResult")
[17:38:09.195]     }, finally = {
[17:38:09.195]         if (!identical(...future.workdir, getwd())) 
[17:38:09.195]             setwd(...future.workdir)
[17:38:09.195]         {
[17:38:09.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:09.195]                 ...future.oldOptions$nwarnings <- NULL
[17:38:09.195]             }
[17:38:09.195]             base::options(...future.oldOptions)
[17:38:09.195]             if (.Platform$OS.type == "windows") {
[17:38:09.195]                 old_names <- names(...future.oldEnvVars)
[17:38:09.195]                 envs <- base::Sys.getenv()
[17:38:09.195]                 names <- names(envs)
[17:38:09.195]                 common <- intersect(names, old_names)
[17:38:09.195]                 added <- setdiff(names, old_names)
[17:38:09.195]                 removed <- setdiff(old_names, names)
[17:38:09.195]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:09.195]                   envs[common]]
[17:38:09.195]                 NAMES <- toupper(changed)
[17:38:09.195]                 args <- list()
[17:38:09.195]                 for (kk in seq_along(NAMES)) {
[17:38:09.195]                   name <- changed[[kk]]
[17:38:09.195]                   NAME <- NAMES[[kk]]
[17:38:09.195]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.195]                     next
[17:38:09.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.195]                 }
[17:38:09.195]                 NAMES <- toupper(added)
[17:38:09.195]                 for (kk in seq_along(NAMES)) {
[17:38:09.195]                   name <- added[[kk]]
[17:38:09.195]                   NAME <- NAMES[[kk]]
[17:38:09.195]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.195]                     next
[17:38:09.195]                   args[[name]] <- ""
[17:38:09.195]                 }
[17:38:09.195]                 NAMES <- toupper(removed)
[17:38:09.195]                 for (kk in seq_along(NAMES)) {
[17:38:09.195]                   name <- removed[[kk]]
[17:38:09.195]                   NAME <- NAMES[[kk]]
[17:38:09.195]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.195]                     next
[17:38:09.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.195]                 }
[17:38:09.195]                 if (length(args) > 0) 
[17:38:09.195]                   base::do.call(base::Sys.setenv, args = args)
[17:38:09.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:09.195]             }
[17:38:09.195]             else {
[17:38:09.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:09.195]             }
[17:38:09.195]             {
[17:38:09.195]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:09.195]                   0L) {
[17:38:09.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:09.195]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:09.195]                   base::options(opts)
[17:38:09.195]                 }
[17:38:09.195]                 {
[17:38:09.195]                   {
[17:38:09.195]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:09.195]                     NULL
[17:38:09.195]                   }
[17:38:09.195]                   options(future.plan = NULL)
[17:38:09.195]                   if (is.na(NA_character_)) 
[17:38:09.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:09.195]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:09.195]                     .init = FALSE)
[17:38:09.195]                 }
[17:38:09.195]             }
[17:38:09.195]         }
[17:38:09.195]     })
[17:38:09.195]     if (TRUE) {
[17:38:09.195]         base::sink(type = "output", split = FALSE)
[17:38:09.195]         if (TRUE) {
[17:38:09.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:09.195]         }
[17:38:09.195]         else {
[17:38:09.195]             ...future.result["stdout"] <- base::list(NULL)
[17:38:09.195]         }
[17:38:09.195]         base::close(...future.stdout)
[17:38:09.195]         ...future.stdout <- NULL
[17:38:09.195]     }
[17:38:09.195]     ...future.result$conditions <- ...future.conditions
[17:38:09.195]     ...future.result$finished <- base::Sys.time()
[17:38:09.195]     ...future.result
[17:38:09.195] }
[17:38:09.198] assign_globals() ...
[17:38:09.198] List of 11
[17:38:09.198]  $ ...future.FUN            :function (x, ...)  
[17:38:09.198]  $ x_FUN                    :function (x)  
[17:38:09.198]  $ times                    : int 1
[17:38:09.198]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:09.198]  $ stop_if_not              :function (...)  
[17:38:09.198]  $ dim                      : NULL
[17:38:09.198]  $ valid_types              : chr "logical"
[17:38:09.198]  $ future.call.arguments    : list()
[17:38:09.198]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.198]  $ ...future.elements_ii    :List of 6
[17:38:09.198]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[17:38:09.198]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[17:38:09.198]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[17:38:09.198]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[17:38:09.198]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[17:38:09.198]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[17:38:09.198]  $ ...future.seeds_ii       : NULL
[17:38:09.198]  $ ...future.globals.maxSize: NULL
[17:38:09.198]  - attr(*, "where")=List of 11
[17:38:09.198]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:09.198]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:09.198]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:09.198]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:09.198]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:09.198]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:09.198]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:09.198]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:09.198]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:09.198]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:09.198]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:09.198]  - attr(*, "resolved")= logi FALSE
[17:38:09.198]  - attr(*, "total_size")= num 94200
[17:38:09.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.198]  - attr(*, "already-done")= logi TRUE
[17:38:09.207] - copied ‘...future.FUN’ to environment
[17:38:09.207] - copied ‘x_FUN’ to environment
[17:38:09.207] - copied ‘times’ to environment
[17:38:09.207] - copied ‘stopf’ to environment
[17:38:09.208] - copied ‘stop_if_not’ to environment
[17:38:09.208] - copied ‘dim’ to environment
[17:38:09.208] - copied ‘valid_types’ to environment
[17:38:09.208] - copied ‘future.call.arguments’ to environment
[17:38:09.208] - copied ‘...future.elements_ii’ to environment
[17:38:09.208] - copied ‘...future.seeds_ii’ to environment
[17:38:09.208] - copied ‘...future.globals.maxSize’ to environment
[17:38:09.208] assign_globals() ... done
[17:38:09.208] requestCore(): workers = 2
[17:38:09.211] MulticoreFuture started
[17:38:09.211] - Launch lazy future ... done
[17:38:09.211] run() for ‘MulticoreFuture’ ... done
[17:38:09.212] Created future:
[17:38:09.212] plan(): Setting new future strategy stack:
[17:38:09.213] List of future strategies:
[17:38:09.213] 1. sequential:
[17:38:09.213]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:09.213]    - tweaked: FALSE
[17:38:09.213]    - call: NULL
[17:38:09.213] plan(): nbrOfWorkers() = 1
[17:38:09.216] plan(): Setting new future strategy stack:
[17:38:09.216] List of future strategies:
[17:38:09.216] 1. multicore:
[17:38:09.216]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:09.216]    - tweaked: FALSE
[17:38:09.216]    - call: plan(strategy)
[17:38:09.212] MulticoreFuture:
[17:38:09.212] Label: ‘future_vapply-1’
[17:38:09.212] Expression:
[17:38:09.212] {
[17:38:09.212]     do.call(function(...) {
[17:38:09.212]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.212]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.212]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.212]             on.exit(options(oopts), add = TRUE)
[17:38:09.212]         }
[17:38:09.212]         {
[17:38:09.212]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.212]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.212]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.212]             })
[17:38:09.212]         }
[17:38:09.212]     }, args = future.call.arguments)
[17:38:09.212] }
[17:38:09.212] Lazy evaluation: FALSE
[17:38:09.212] Asynchronous evaluation: TRUE
[17:38:09.212] Local evaluation: TRUE
[17:38:09.212] Environment: R_GlobalEnv
[17:38:09.212] Capture standard output: TRUE
[17:38:09.212] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:09.212] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:09.212] Packages: 1 packages (‘future.apply’)
[17:38:09.212] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:09.212] Resolved: FALSE
[17:38:09.212] Value: <not collected>
[17:38:09.212] Conditions captured: <none>
[17:38:09.212] Early signaling: FALSE
[17:38:09.212] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:09.212] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.225] Chunk #1 of 2 ... DONE
[17:38:09.225] Chunk #2 of 2 ...
[17:38:09.226]  - Finding globals in 'X' for chunk #2 ...
[17:38:09.226] getGlobalsAndPackages() ...
[17:38:09.226] Searching for globals...
[17:38:09.226] 
[17:38:09.227] plan(): nbrOfWorkers() = 2
[17:38:09.227] Searching for globals ... DONE
[17:38:09.230] - globals: [0] <none>
[17:38:09.230] getGlobalsAndPackages() ... DONE
[17:38:09.230]    + additional globals found: [n=0] 
[17:38:09.230]    + additional namespaces needed: [n=0] 
[17:38:09.231]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:09.231]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:09.231]  - seeds: <none>
[17:38:09.231]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.232] getGlobalsAndPackages() ...
[17:38:09.232] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.232] Resolving globals: FALSE
[17:38:09.233] Tweak future expression to call with '...' arguments ...
[17:38:09.233] {
[17:38:09.233]     do.call(function(...) {
[17:38:09.233]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.233]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.233]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.233]             on.exit(options(oopts), add = TRUE)
[17:38:09.233]         }
[17:38:09.233]         {
[17:38:09.233]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.233]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.233]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.233]             })
[17:38:09.233]         }
[17:38:09.233]     }, args = future.call.arguments)
[17:38:09.233] }
[17:38:09.234] Tweak future expression to call with '...' arguments ... DONE
[17:38:09.235] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.236] - packages: [1] ‘future.apply’
[17:38:09.236] getGlobalsAndPackages() ... DONE
[17:38:09.237] run() for ‘Future’ ...
[17:38:09.237] - state: ‘created’
[17:38:09.237] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:09.243] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.243] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:09.243]   - Field: ‘label’
[17:38:09.244]   - Field: ‘local’
[17:38:09.244]   - Field: ‘owner’
[17:38:09.244]   - Field: ‘envir’
[17:38:09.244]   - Field: ‘workers’
[17:38:09.244]   - Field: ‘packages’
[17:38:09.245]   - Field: ‘gc’
[17:38:09.245]   - Field: ‘job’
[17:38:09.245]   - Field: ‘conditions’
[17:38:09.245]   - Field: ‘expr’
[17:38:09.245]   - Field: ‘uuid’
[17:38:09.246]   - Field: ‘seed’
[17:38:09.246]   - Field: ‘version’
[17:38:09.246]   - Field: ‘result’
[17:38:09.246]   - Field: ‘asynchronous’
[17:38:09.247]   - Field: ‘calls’
[17:38:09.247]   - Field: ‘globals’
[17:38:09.247]   - Field: ‘stdout’
[17:38:09.247]   - Field: ‘earlySignal’
[17:38:09.247]   - Field: ‘lazy’
[17:38:09.247]   - Field: ‘state’
[17:38:09.248] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:09.248] - Launch lazy future ...
[17:38:09.248] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:09.248] Packages needed by future strategies (n = 0): <none>
[17:38:09.249] {
[17:38:09.249]     {
[17:38:09.249]         {
[17:38:09.249]             ...future.startTime <- base::Sys.time()
[17:38:09.249]             {
[17:38:09.249]                 {
[17:38:09.249]                   {
[17:38:09.249]                     {
[17:38:09.249]                       {
[17:38:09.249]                         base::local({
[17:38:09.249]                           has_future <- base::requireNamespace("future", 
[17:38:09.249]                             quietly = TRUE)
[17:38:09.249]                           if (has_future) {
[17:38:09.249]                             ns <- base::getNamespace("future")
[17:38:09.249]                             version <- ns[[".package"]][["version"]]
[17:38:09.249]                             if (is.null(version)) 
[17:38:09.249]                               version <- utils::packageVersion("future")
[17:38:09.249]                           }
[17:38:09.249]                           else {
[17:38:09.249]                             version <- NULL
[17:38:09.249]                           }
[17:38:09.249]                           if (!has_future || version < "1.8.0") {
[17:38:09.249]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:09.249]                               "", base::R.version$version.string), 
[17:38:09.249]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:09.249]                                 base::R.version$platform, 8 * 
[17:38:09.249]                                   base::.Machine$sizeof.pointer), 
[17:38:09.249]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:09.249]                                 "release", "version")], collapse = " "), 
[17:38:09.249]                               hostname = base::Sys.info()[["nodename"]])
[17:38:09.249]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:09.249]                               info)
[17:38:09.249]                             info <- base::paste(info, collapse = "; ")
[17:38:09.249]                             if (!has_future) {
[17:38:09.249]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:09.249]                                 info)
[17:38:09.249]                             }
[17:38:09.249]                             else {
[17:38:09.249]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:09.249]                                 info, version)
[17:38:09.249]                             }
[17:38:09.249]                             base::stop(msg)
[17:38:09.249]                           }
[17:38:09.249]                         })
[17:38:09.249]                       }
[17:38:09.249]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:09.249]                       base::options(mc.cores = 1L)
[17:38:09.249]                     }
[17:38:09.249]                     base::local({
[17:38:09.249]                       for (pkg in "future.apply") {
[17:38:09.249]                         base::loadNamespace(pkg)
[17:38:09.249]                         base::library(pkg, character.only = TRUE)
[17:38:09.249]                       }
[17:38:09.249]                     })
[17:38:09.249]                   }
[17:38:09.249]                   ...future.strategy.old <- future::plan("list")
[17:38:09.249]                   options(future.plan = NULL)
[17:38:09.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:09.249]                 }
[17:38:09.249]                 ...future.workdir <- getwd()
[17:38:09.249]             }
[17:38:09.249]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:09.249]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:09.249]         }
[17:38:09.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:09.249]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:09.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:09.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:09.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:09.249]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:09.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:09.249]             base::names(...future.oldOptions))
[17:38:09.249]     }
[17:38:09.249]     if (FALSE) {
[17:38:09.249]     }
[17:38:09.249]     else {
[17:38:09.249]         if (TRUE) {
[17:38:09.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:09.249]                 open = "w")
[17:38:09.249]         }
[17:38:09.249]         else {
[17:38:09.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:09.249]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:09.249]         }
[17:38:09.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:09.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:09.249]             base::sink(type = "output", split = FALSE)
[17:38:09.249]             base::close(...future.stdout)
[17:38:09.249]         }, add = TRUE)
[17:38:09.249]     }
[17:38:09.249]     ...future.frame <- base::sys.nframe()
[17:38:09.249]     ...future.conditions <- base::list()
[17:38:09.249]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:09.249]     if (FALSE) {
[17:38:09.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:09.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:09.249]     }
[17:38:09.249]     ...future.result <- base::tryCatch({
[17:38:09.249]         base::withCallingHandlers({
[17:38:09.249]             ...future.value <- base::withVisible(base::local({
[17:38:09.249]                 withCallingHandlers({
[17:38:09.249]                   {
[17:38:09.249]                     do.call(function(...) {
[17:38:09.249]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.249]                       if (!identical(...future.globals.maxSize.org, 
[17:38:09.249]                         ...future.globals.maxSize)) {
[17:38:09.249]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.249]                         on.exit(options(oopts), add = TRUE)
[17:38:09.249]                       }
[17:38:09.249]                       {
[17:38:09.249]                         lapply(seq_along(...future.elements_ii), 
[17:38:09.249]                           FUN = function(jj) {
[17:38:09.249]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.249]                             ...future.FUN(...future.X_jj, ...)
[17:38:09.249]                           })
[17:38:09.249]                       }
[17:38:09.249]                     }, args = future.call.arguments)
[17:38:09.249]                   }
[17:38:09.249]                 }, immediateCondition = function(cond) {
[17:38:09.249]                   save_rds <- function (object, pathname, ...) 
[17:38:09.249]                   {
[17:38:09.249]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:09.249]                     if (file_test("-f", pathname_tmp)) {
[17:38:09.249]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.249]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:09.249]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.249]                         fi_tmp[["mtime"]])
[17:38:09.249]                     }
[17:38:09.249]                     tryCatch({
[17:38:09.249]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:09.249]                     }, error = function(ex) {
[17:38:09.249]                       msg <- conditionMessage(ex)
[17:38:09.249]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.249]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:09.249]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.249]                         fi_tmp[["mtime"]], msg)
[17:38:09.249]                       ex$message <- msg
[17:38:09.249]                       stop(ex)
[17:38:09.249]                     })
[17:38:09.249]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:09.249]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:09.249]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:09.249]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.249]                       fi <- file.info(pathname)
[17:38:09.249]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:09.249]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.249]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:09.249]                         fi[["size"]], fi[["mtime"]])
[17:38:09.249]                       stop(msg)
[17:38:09.249]                     }
[17:38:09.249]                     invisible(pathname)
[17:38:09.249]                   }
[17:38:09.249]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:09.249]                     rootPath = tempdir()) 
[17:38:09.249]                   {
[17:38:09.249]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:09.249]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:09.249]                       tmpdir = path, fileext = ".rds")
[17:38:09.249]                     save_rds(obj, file)
[17:38:09.249]                   }
[17:38:09.249]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:09.249]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.249]                   {
[17:38:09.249]                     inherits <- base::inherits
[17:38:09.249]                     invokeRestart <- base::invokeRestart
[17:38:09.249]                     is.null <- base::is.null
[17:38:09.249]                     muffled <- FALSE
[17:38:09.249]                     if (inherits(cond, "message")) {
[17:38:09.249]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:09.249]                       if (muffled) 
[17:38:09.249]                         invokeRestart("muffleMessage")
[17:38:09.249]                     }
[17:38:09.249]                     else if (inherits(cond, "warning")) {
[17:38:09.249]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:09.249]                       if (muffled) 
[17:38:09.249]                         invokeRestart("muffleWarning")
[17:38:09.249]                     }
[17:38:09.249]                     else if (inherits(cond, "condition")) {
[17:38:09.249]                       if (!is.null(pattern)) {
[17:38:09.249]                         computeRestarts <- base::computeRestarts
[17:38:09.249]                         grepl <- base::grepl
[17:38:09.249]                         restarts <- computeRestarts(cond)
[17:38:09.249]                         for (restart in restarts) {
[17:38:09.249]                           name <- restart$name
[17:38:09.249]                           if (is.null(name)) 
[17:38:09.249]                             next
[17:38:09.249]                           if (!grepl(pattern, name)) 
[17:38:09.249]                             next
[17:38:09.249]                           invokeRestart(restart)
[17:38:09.249]                           muffled <- TRUE
[17:38:09.249]                           break
[17:38:09.249]                         }
[17:38:09.249]                       }
[17:38:09.249]                     }
[17:38:09.249]                     invisible(muffled)
[17:38:09.249]                   }
[17:38:09.249]                   muffleCondition(cond)
[17:38:09.249]                 })
[17:38:09.249]             }))
[17:38:09.249]             future::FutureResult(value = ...future.value$value, 
[17:38:09.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.249]                   ...future.rng), globalenv = if (FALSE) 
[17:38:09.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:09.249]                     ...future.globalenv.names))
[17:38:09.249]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:09.249]         }, condition = base::local({
[17:38:09.249]             c <- base::c
[17:38:09.249]             inherits <- base::inherits
[17:38:09.249]             invokeRestart <- base::invokeRestart
[17:38:09.249]             length <- base::length
[17:38:09.249]             list <- base::list
[17:38:09.249]             seq.int <- base::seq.int
[17:38:09.249]             signalCondition <- base::signalCondition
[17:38:09.249]             sys.calls <- base::sys.calls
[17:38:09.249]             `[[` <- base::`[[`
[17:38:09.249]             `+` <- base::`+`
[17:38:09.249]             `<<-` <- base::`<<-`
[17:38:09.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:09.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:09.249]                   3L)]
[17:38:09.249]             }
[17:38:09.249]             function(cond) {
[17:38:09.249]                 is_error <- inherits(cond, "error")
[17:38:09.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:09.249]                   NULL)
[17:38:09.249]                 if (is_error) {
[17:38:09.249]                   sessionInformation <- function() {
[17:38:09.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:09.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:09.249]                       search = base::search(), system = base::Sys.info())
[17:38:09.249]                   }
[17:38:09.249]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:09.249]                     cond$call), session = sessionInformation(), 
[17:38:09.249]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:09.249]                   signalCondition(cond)
[17:38:09.249]                 }
[17:38:09.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:09.249]                 "immediateCondition"))) {
[17:38:09.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:09.249]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:09.249]                   if (TRUE && !signal) {
[17:38:09.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.249]                     {
[17:38:09.249]                       inherits <- base::inherits
[17:38:09.249]                       invokeRestart <- base::invokeRestart
[17:38:09.249]                       is.null <- base::is.null
[17:38:09.249]                       muffled <- FALSE
[17:38:09.249]                       if (inherits(cond, "message")) {
[17:38:09.249]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.249]                         if (muffled) 
[17:38:09.249]                           invokeRestart("muffleMessage")
[17:38:09.249]                       }
[17:38:09.249]                       else if (inherits(cond, "warning")) {
[17:38:09.249]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.249]                         if (muffled) 
[17:38:09.249]                           invokeRestart("muffleWarning")
[17:38:09.249]                       }
[17:38:09.249]                       else if (inherits(cond, "condition")) {
[17:38:09.249]                         if (!is.null(pattern)) {
[17:38:09.249]                           computeRestarts <- base::computeRestarts
[17:38:09.249]                           grepl <- base::grepl
[17:38:09.249]                           restarts <- computeRestarts(cond)
[17:38:09.249]                           for (restart in restarts) {
[17:38:09.249]                             name <- restart$name
[17:38:09.249]                             if (is.null(name)) 
[17:38:09.249]                               next
[17:38:09.249]                             if (!grepl(pattern, name)) 
[17:38:09.249]                               next
[17:38:09.249]                             invokeRestart(restart)
[17:38:09.249]                             muffled <- TRUE
[17:38:09.249]                             break
[17:38:09.249]                           }
[17:38:09.249]                         }
[17:38:09.249]                       }
[17:38:09.249]                       invisible(muffled)
[17:38:09.249]                     }
[17:38:09.249]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.249]                   }
[17:38:09.249]                 }
[17:38:09.249]                 else {
[17:38:09.249]                   if (TRUE) {
[17:38:09.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.249]                     {
[17:38:09.249]                       inherits <- base::inherits
[17:38:09.249]                       invokeRestart <- base::invokeRestart
[17:38:09.249]                       is.null <- base::is.null
[17:38:09.249]                       muffled <- FALSE
[17:38:09.249]                       if (inherits(cond, "message")) {
[17:38:09.249]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.249]                         if (muffled) 
[17:38:09.249]                           invokeRestart("muffleMessage")
[17:38:09.249]                       }
[17:38:09.249]                       else if (inherits(cond, "warning")) {
[17:38:09.249]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.249]                         if (muffled) 
[17:38:09.249]                           invokeRestart("muffleWarning")
[17:38:09.249]                       }
[17:38:09.249]                       else if (inherits(cond, "condition")) {
[17:38:09.249]                         if (!is.null(pattern)) {
[17:38:09.249]                           computeRestarts <- base::computeRestarts
[17:38:09.249]                           grepl <- base::grepl
[17:38:09.249]                           restarts <- computeRestarts(cond)
[17:38:09.249]                           for (restart in restarts) {
[17:38:09.249]                             name <- restart$name
[17:38:09.249]                             if (is.null(name)) 
[17:38:09.249]                               next
[17:38:09.249]                             if (!grepl(pattern, name)) 
[17:38:09.249]                               next
[17:38:09.249]                             invokeRestart(restart)
[17:38:09.249]                             muffled <- TRUE
[17:38:09.249]                             break
[17:38:09.249]                           }
[17:38:09.249]                         }
[17:38:09.249]                       }
[17:38:09.249]                       invisible(muffled)
[17:38:09.249]                     }
[17:38:09.249]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.249]                   }
[17:38:09.249]                 }
[17:38:09.249]             }
[17:38:09.249]         }))
[17:38:09.249]     }, error = function(ex) {
[17:38:09.249]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:09.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.249]                 ...future.rng), started = ...future.startTime, 
[17:38:09.249]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:09.249]             version = "1.8"), class = "FutureResult")
[17:38:09.249]     }, finally = {
[17:38:09.249]         if (!identical(...future.workdir, getwd())) 
[17:38:09.249]             setwd(...future.workdir)
[17:38:09.249]         {
[17:38:09.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:09.249]                 ...future.oldOptions$nwarnings <- NULL
[17:38:09.249]             }
[17:38:09.249]             base::options(...future.oldOptions)
[17:38:09.249]             if (.Platform$OS.type == "windows") {
[17:38:09.249]                 old_names <- names(...future.oldEnvVars)
[17:38:09.249]                 envs <- base::Sys.getenv()
[17:38:09.249]                 names <- names(envs)
[17:38:09.249]                 common <- intersect(names, old_names)
[17:38:09.249]                 added <- setdiff(names, old_names)
[17:38:09.249]                 removed <- setdiff(old_names, names)
[17:38:09.249]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:09.249]                   envs[common]]
[17:38:09.249]                 NAMES <- toupper(changed)
[17:38:09.249]                 args <- list()
[17:38:09.249]                 for (kk in seq_along(NAMES)) {
[17:38:09.249]                   name <- changed[[kk]]
[17:38:09.249]                   NAME <- NAMES[[kk]]
[17:38:09.249]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.249]                     next
[17:38:09.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.249]                 }
[17:38:09.249]                 NAMES <- toupper(added)
[17:38:09.249]                 for (kk in seq_along(NAMES)) {
[17:38:09.249]                   name <- added[[kk]]
[17:38:09.249]                   NAME <- NAMES[[kk]]
[17:38:09.249]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.249]                     next
[17:38:09.249]                   args[[name]] <- ""
[17:38:09.249]                 }
[17:38:09.249]                 NAMES <- toupper(removed)
[17:38:09.249]                 for (kk in seq_along(NAMES)) {
[17:38:09.249]                   name <- removed[[kk]]
[17:38:09.249]                   NAME <- NAMES[[kk]]
[17:38:09.249]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.249]                     next
[17:38:09.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.249]                 }
[17:38:09.249]                 if (length(args) > 0) 
[17:38:09.249]                   base::do.call(base::Sys.setenv, args = args)
[17:38:09.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:09.249]             }
[17:38:09.249]             else {
[17:38:09.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:09.249]             }
[17:38:09.249]             {
[17:38:09.249]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:09.249]                   0L) {
[17:38:09.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:09.249]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:09.249]                   base::options(opts)
[17:38:09.249]                 }
[17:38:09.249]                 {
[17:38:09.249]                   {
[17:38:09.249]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:09.249]                     NULL
[17:38:09.249]                   }
[17:38:09.249]                   options(future.plan = NULL)
[17:38:09.249]                   if (is.na(NA_character_)) 
[17:38:09.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:09.249]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:09.249]                     .init = FALSE)
[17:38:09.249]                 }
[17:38:09.249]             }
[17:38:09.249]         }
[17:38:09.249]     })
[17:38:09.249]     if (TRUE) {
[17:38:09.249]         base::sink(type = "output", split = FALSE)
[17:38:09.249]         if (TRUE) {
[17:38:09.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:09.249]         }
[17:38:09.249]         else {
[17:38:09.249]             ...future.result["stdout"] <- base::list(NULL)
[17:38:09.249]         }
[17:38:09.249]         base::close(...future.stdout)
[17:38:09.249]         ...future.stdout <- NULL
[17:38:09.249]     }
[17:38:09.249]     ...future.result$conditions <- ...future.conditions
[17:38:09.249]     ...future.result$finished <- base::Sys.time()
[17:38:09.249]     ...future.result
[17:38:09.249] }
[17:38:09.252] assign_globals() ...
[17:38:09.252] List of 11
[17:38:09.252]  $ ...future.FUN            :function (x, ...)  
[17:38:09.252]  $ x_FUN                    :function (x)  
[17:38:09.252]  $ times                    : int 1
[17:38:09.252]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:09.252]  $ stop_if_not              :function (...)  
[17:38:09.252]  $ dim                      : NULL
[17:38:09.252]  $ valid_types              : chr "logical"
[17:38:09.252]  $ future.call.arguments    : list()
[17:38:09.252]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.252]  $ ...future.elements_ii    :List of 5
[17:38:09.252]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[17:38:09.252]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[17:38:09.252]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[17:38:09.252]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[17:38:09.252]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[17:38:09.252]  $ ...future.seeds_ii       : NULL
[17:38:09.252]  $ ...future.globals.maxSize: NULL
[17:38:09.252]  - attr(*, "where")=List of 11
[17:38:09.252]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:09.252]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:09.252]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:09.252]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:09.252]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:09.252]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:09.252]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:09.252]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:09.252]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:09.252]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:09.252]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:09.252]  - attr(*, "resolved")= logi FALSE
[17:38:09.252]  - attr(*, "total_size")= num 94200
[17:38:09.252]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.252]  - attr(*, "already-done")= logi TRUE
[17:38:09.263] - copied ‘...future.FUN’ to environment
[17:38:09.263] - copied ‘x_FUN’ to environment
[17:38:09.263] - copied ‘times’ to environment
[17:38:09.263] - copied ‘stopf’ to environment
[17:38:09.263] - copied ‘stop_if_not’ to environment
[17:38:09.264] - copied ‘dim’ to environment
[17:38:09.264] - copied ‘valid_types’ to environment
[17:38:09.264] - copied ‘future.call.arguments’ to environment
[17:38:09.264] - copied ‘...future.elements_ii’ to environment
[17:38:09.264] - copied ‘...future.seeds_ii’ to environment
[17:38:09.264] - copied ‘...future.globals.maxSize’ to environment
[17:38:09.264] assign_globals() ... done
[17:38:09.264] requestCore(): workers = 2
[17:38:09.267] MulticoreFuture started
[17:38:09.267] - Launch lazy future ... done
[17:38:09.267] run() for ‘MulticoreFuture’ ... done
[17:38:09.268] Created future:
[17:38:09.268] plan(): Setting new future strategy stack:
[17:38:09.268] List of future strategies:
[17:38:09.268] 1. sequential:
[17:38:09.268]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:09.268]    - tweaked: FALSE
[17:38:09.268]    - call: NULL
[17:38:09.273] plan(): nbrOfWorkers() = 1
[17:38:09.276] plan(): Setting new future strategy stack:
[17:38:09.276] List of future strategies:
[17:38:09.276] 1. multicore:
[17:38:09.276]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:09.276]    - tweaked: FALSE
[17:38:09.276]    - call: plan(strategy)
[17:38:09.284] plan(): nbrOfWorkers() = 2
[17:38:09.268] MulticoreFuture:
[17:38:09.268] Label: ‘future_vapply-2’
[17:38:09.268] Expression:
[17:38:09.268] {
[17:38:09.268]     do.call(function(...) {
[17:38:09.268]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.268]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.268]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.268]             on.exit(options(oopts), add = TRUE)
[17:38:09.268]         }
[17:38:09.268]         {
[17:38:09.268]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.268]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.268]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.268]             })
[17:38:09.268]         }
[17:38:09.268]     }, args = future.call.arguments)
[17:38:09.268] }
[17:38:09.268] Lazy evaluation: FALSE
[17:38:09.268] Asynchronous evaluation: TRUE
[17:38:09.268] Local evaluation: TRUE
[17:38:09.268] Environment: R_GlobalEnv
[17:38:09.268] Capture standard output: TRUE
[17:38:09.268] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:09.268] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:09.268] Packages: 1 packages (‘future.apply’)
[17:38:09.268] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:09.268] Resolved: TRUE
[17:38:09.268] Value: <not collected>
[17:38:09.268] Conditions captured: <none>
[17:38:09.268] Early signaling: FALSE
[17:38:09.268] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:09.268] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.285] Chunk #2 of 2 ... DONE
[17:38:09.286] Launching 2 futures (chunks) ... DONE
[17:38:09.286] Resolving 2 futures (chunks) ...
[17:38:09.286] resolve() on list ...
[17:38:09.286]  recursive: 0
[17:38:09.287]  length: 2
[17:38:09.287] 
[17:38:09.287] Future #1
[17:38:09.288] result() for MulticoreFuture ...
[17:38:09.289] result() for MulticoreFuture ...
[17:38:09.289] result() for MulticoreFuture ... done
[17:38:09.289] result() for MulticoreFuture ... done
[17:38:09.289] result() for MulticoreFuture ...
[17:38:09.290] result() for MulticoreFuture ... done
[17:38:09.290] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:09.290] - nx: 2
[17:38:09.290] - relay: TRUE
[17:38:09.291] - stdout: TRUE
[17:38:09.291] - signal: TRUE
[17:38:09.291] - resignal: FALSE
[17:38:09.291] - force: TRUE
[17:38:09.291] - relayed: [n=2] FALSE, FALSE
[17:38:09.292] - queued futures: [n=2] FALSE, FALSE
[17:38:09.292]  - until=1
[17:38:09.292]  - relaying element #1
[17:38:09.292] result() for MulticoreFuture ...
[17:38:09.293] result() for MulticoreFuture ... done
[17:38:09.293] result() for MulticoreFuture ...
[17:38:09.293] result() for MulticoreFuture ... done
[17:38:09.293] result() for MulticoreFuture ...
[17:38:09.294] result() for MulticoreFuture ... done
[17:38:09.294] result() for MulticoreFuture ...
[17:38:09.294] result() for MulticoreFuture ... done
[17:38:09.294] - relayed: [n=2] TRUE, FALSE
[17:38:09.295] - queued futures: [n=2] TRUE, FALSE
[17:38:09.295] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:09.295]  length: 1 (resolved future 1)
[17:38:09.295] Future #2
[17:38:09.296] result() for MulticoreFuture ...
[17:38:09.297] result() for MulticoreFuture ...
[17:38:09.297] result() for MulticoreFuture ... done
[17:38:09.297] result() for MulticoreFuture ... done
[17:38:09.297] result() for MulticoreFuture ...
[17:38:09.298] result() for MulticoreFuture ... done
[17:38:09.298] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:09.298] - nx: 2
[17:38:09.298] - relay: TRUE
[17:38:09.298] - stdout: TRUE
[17:38:09.298] - signal: TRUE
[17:38:09.299] - resignal: FALSE
[17:38:09.299] - force: TRUE
[17:38:09.299] - relayed: [n=2] TRUE, FALSE
[17:38:09.299] - queued futures: [n=2] TRUE, FALSE
[17:38:09.299]  - until=2
[17:38:09.299]  - relaying element #2
[17:38:09.299] result() for MulticoreFuture ...
[17:38:09.300] result() for MulticoreFuture ... done
[17:38:09.300] result() for MulticoreFuture ...
[17:38:09.300] result() for MulticoreFuture ... done
[17:38:09.300] result() for MulticoreFuture ...
[17:38:09.300] result() for MulticoreFuture ... done
[17:38:09.300] result() for MulticoreFuture ...
[17:38:09.300] result() for MulticoreFuture ... done
[17:38:09.300] - relayed: [n=2] TRUE, TRUE
[17:38:09.301] - queued futures: [n=2] TRUE, TRUE
[17:38:09.301] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:09.301]  length: 0 (resolved future 2)
[17:38:09.301] Relaying remaining futures
[17:38:09.301] signalConditionsASAP(NULL, pos=0) ...
[17:38:09.301] - nx: 2
[17:38:09.301] - relay: TRUE
[17:38:09.301] - stdout: TRUE
[17:38:09.301] - signal: TRUE
[17:38:09.301] - resignal: FALSE
[17:38:09.302] - force: TRUE
[17:38:09.302] - relayed: [n=2] TRUE, TRUE
[17:38:09.302] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:09.302] - relayed: [n=2] TRUE, TRUE
[17:38:09.302] - queued futures: [n=2] TRUE, TRUE
[17:38:09.302] signalConditionsASAP(NULL, pos=0) ... done
[17:38:09.302] resolve() on list ... DONE
[17:38:09.302] result() for MulticoreFuture ...
[17:38:09.302] result() for MulticoreFuture ... done
[17:38:09.303] result() for MulticoreFuture ...
[17:38:09.303] result() for MulticoreFuture ... done
[17:38:09.303] result() for MulticoreFuture ...
[17:38:09.303] result() for MulticoreFuture ... done
[17:38:09.303] result() for MulticoreFuture ...
[17:38:09.303] result() for MulticoreFuture ... done
[17:38:09.303]  - Number of value chunks collected: 2
[17:38:09.303] Resolving 2 futures (chunks) ... DONE
[17:38:09.303] Reducing values from 2 chunks ...
[17:38:09.304]  - Number of values collected after concatenation: 11
[17:38:09.304]  - Number of values expected: 11
[17:38:09.304] Reducing values from 2 chunks ... DONE
[17:38:09.304] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[17:38:09.305] future_lapply() ...
[17:38:09.312] Number of chunks: 2
[17:38:09.312] getGlobalsAndPackagesXApply() ...
[17:38:09.312]  - future.globals: TRUE
[17:38:09.312] getGlobalsAndPackages() ...
[17:38:09.312] Searching for globals...
[17:38:09.316] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:09.316] Searching for globals ... DONE
[17:38:09.316] Resolving globals: FALSE
[17:38:09.317] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[17:38:09.320] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:09.320] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:09.321] - packages: [1] ‘future.apply’
[17:38:09.321] getGlobalsAndPackages() ... DONE
[17:38:09.321]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:09.321]  - needed namespaces: [n=1] ‘future.apply’
[17:38:09.321] Finding globals ... DONE
[17:38:09.321]  - use_args: TRUE
[17:38:09.321]  - Getting '...' globals ...
[17:38:09.322] resolve() on list ...
[17:38:09.322]  recursive: 0
[17:38:09.322]  length: 1
[17:38:09.322]  elements: ‘...’
[17:38:09.322]  length: 0 (resolved future 1)
[17:38:09.323] resolve() on list ... DONE
[17:38:09.323]    - '...' content: [n=0] 
[17:38:09.323] List of 1
[17:38:09.323]  $ ...: list()
[17:38:09.323]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.323]  - attr(*, "where")=List of 1
[17:38:09.323]   ..$ ...:<environment: 0x5607ff5523b8> 
[17:38:09.323]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.323]  - attr(*, "resolved")= logi TRUE
[17:38:09.323]  - attr(*, "total_size")= num NA
[17:38:09.326]  - Getting '...' globals ... DONE
[17:38:09.327] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:09.327] List of 8
[17:38:09.327]  $ ...future.FUN:function (x, ...)  
[17:38:09.327]  $ x_FUN        :function (x)  
[17:38:09.327]  $ times        : int 1
[17:38:09.327]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:09.327]  $ stop_if_not  :function (...)  
[17:38:09.327]  $ dim          : NULL
[17:38:09.327]  $ valid_types  : chr [1:2] "logical" "integer"
[17:38:09.327]  $ ...          : list()
[17:38:09.327]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.327]  - attr(*, "where")=List of 8
[17:38:09.327]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:09.327]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:09.327]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:09.327]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:09.327]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:09.327]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:09.327]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:09.327]   ..$ ...          :<environment: 0x5607ff5523b8> 
[17:38:09.327]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.327]  - attr(*, "resolved")= logi FALSE
[17:38:09.327]  - attr(*, "total_size")= num 94264
[17:38:09.333] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:09.333] getGlobalsAndPackagesXApply() ... DONE
[17:38:09.333] Number of futures (= number of chunks): 2
[17:38:09.333] Launching 2 futures (chunks) ...
[17:38:09.333] Chunk #1 of 2 ...
[17:38:09.333]  - Finding globals in 'X' for chunk #1 ...
[17:38:09.334] getGlobalsAndPackages() ...
[17:38:09.334] Searching for globals...
[17:38:09.334] 
[17:38:09.334] Searching for globals ... DONE
[17:38:09.334] - globals: [0] <none>
[17:38:09.334] getGlobalsAndPackages() ... DONE
[17:38:09.334]    + additional globals found: [n=0] 
[17:38:09.334]    + additional namespaces needed: [n=0] 
[17:38:09.334]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:09.335]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:09.335]  - seeds: <none>
[17:38:09.335]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.335] getGlobalsAndPackages() ...
[17:38:09.335] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.335] Resolving globals: FALSE
[17:38:09.335] Tweak future expression to call with '...' arguments ...
[17:38:09.335] {
[17:38:09.335]     do.call(function(...) {
[17:38:09.335]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.335]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.335]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.335]             on.exit(options(oopts), add = TRUE)
[17:38:09.335]         }
[17:38:09.335]         {
[17:38:09.335]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.335]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.335]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.335]             })
[17:38:09.335]         }
[17:38:09.335]     }, args = future.call.arguments)
[17:38:09.335] }
[17:38:09.336] Tweak future expression to call with '...' arguments ... DONE
[17:38:09.336] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.336] - packages: [1] ‘future.apply’
[17:38:09.336] getGlobalsAndPackages() ... DONE
[17:38:09.337] run() for ‘Future’ ...
[17:38:09.337] - state: ‘created’
[17:38:09.337] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:09.341] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.341] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:09.341]   - Field: ‘label’
[17:38:09.341]   - Field: ‘local’
[17:38:09.341]   - Field: ‘owner’
[17:38:09.341]   - Field: ‘envir’
[17:38:09.342]   - Field: ‘workers’
[17:38:09.342]   - Field: ‘packages’
[17:38:09.342]   - Field: ‘gc’
[17:38:09.342]   - Field: ‘job’
[17:38:09.342]   - Field: ‘conditions’
[17:38:09.342]   - Field: ‘expr’
[17:38:09.342]   - Field: ‘uuid’
[17:38:09.342]   - Field: ‘seed’
[17:38:09.342]   - Field: ‘version’
[17:38:09.342]   - Field: ‘result’
[17:38:09.343]   - Field: ‘asynchronous’
[17:38:09.343]   - Field: ‘calls’
[17:38:09.343]   - Field: ‘globals’
[17:38:09.343]   - Field: ‘stdout’
[17:38:09.343]   - Field: ‘earlySignal’
[17:38:09.343]   - Field: ‘lazy’
[17:38:09.343]   - Field: ‘state’
[17:38:09.343] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:09.343] - Launch lazy future ...
[17:38:09.344] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:09.344] Packages needed by future strategies (n = 0): <none>
[17:38:09.347] {
[17:38:09.347]     {
[17:38:09.347]         {
[17:38:09.347]             ...future.startTime <- base::Sys.time()
[17:38:09.347]             {
[17:38:09.347]                 {
[17:38:09.347]                   {
[17:38:09.347]                     {
[17:38:09.347]                       {
[17:38:09.347]                         base::local({
[17:38:09.347]                           has_future <- base::requireNamespace("future", 
[17:38:09.347]                             quietly = TRUE)
[17:38:09.347]                           if (has_future) {
[17:38:09.347]                             ns <- base::getNamespace("future")
[17:38:09.347]                             version <- ns[[".package"]][["version"]]
[17:38:09.347]                             if (is.null(version)) 
[17:38:09.347]                               version <- utils::packageVersion("future")
[17:38:09.347]                           }
[17:38:09.347]                           else {
[17:38:09.347]                             version <- NULL
[17:38:09.347]                           }
[17:38:09.347]                           if (!has_future || version < "1.8.0") {
[17:38:09.347]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:09.347]                               "", base::R.version$version.string), 
[17:38:09.347]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:09.347]                                 base::R.version$platform, 8 * 
[17:38:09.347]                                   base::.Machine$sizeof.pointer), 
[17:38:09.347]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:09.347]                                 "release", "version")], collapse = " "), 
[17:38:09.347]                               hostname = base::Sys.info()[["nodename"]])
[17:38:09.347]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:09.347]                               info)
[17:38:09.347]                             info <- base::paste(info, collapse = "; ")
[17:38:09.347]                             if (!has_future) {
[17:38:09.347]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:09.347]                                 info)
[17:38:09.347]                             }
[17:38:09.347]                             else {
[17:38:09.347]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:09.347]                                 info, version)
[17:38:09.347]                             }
[17:38:09.347]                             base::stop(msg)
[17:38:09.347]                           }
[17:38:09.347]                         })
[17:38:09.347]                       }
[17:38:09.347]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:09.347]                       base::options(mc.cores = 1L)
[17:38:09.347]                     }
[17:38:09.347]                     base::local({
[17:38:09.347]                       for (pkg in "future.apply") {
[17:38:09.347]                         base::loadNamespace(pkg)
[17:38:09.347]                         base::library(pkg, character.only = TRUE)
[17:38:09.347]                       }
[17:38:09.347]                     })
[17:38:09.347]                   }
[17:38:09.347]                   ...future.strategy.old <- future::plan("list")
[17:38:09.347]                   options(future.plan = NULL)
[17:38:09.347]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.347]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:09.347]                 }
[17:38:09.347]                 ...future.workdir <- getwd()
[17:38:09.347]             }
[17:38:09.347]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:09.347]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:09.347]         }
[17:38:09.347]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:09.347]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:09.347]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:09.347]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:09.347]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:09.347]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:09.347]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:09.347]             base::names(...future.oldOptions))
[17:38:09.347]     }
[17:38:09.347]     if (FALSE) {
[17:38:09.347]     }
[17:38:09.347]     else {
[17:38:09.347]         if (TRUE) {
[17:38:09.347]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:09.347]                 open = "w")
[17:38:09.347]         }
[17:38:09.347]         else {
[17:38:09.347]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:09.347]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:09.347]         }
[17:38:09.347]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:09.347]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:09.347]             base::sink(type = "output", split = FALSE)
[17:38:09.347]             base::close(...future.stdout)
[17:38:09.347]         }, add = TRUE)
[17:38:09.347]     }
[17:38:09.347]     ...future.frame <- base::sys.nframe()
[17:38:09.347]     ...future.conditions <- base::list()
[17:38:09.347]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:09.347]     if (FALSE) {
[17:38:09.347]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:09.347]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:09.347]     }
[17:38:09.347]     ...future.result <- base::tryCatch({
[17:38:09.347]         base::withCallingHandlers({
[17:38:09.347]             ...future.value <- base::withVisible(base::local({
[17:38:09.347]                 withCallingHandlers({
[17:38:09.347]                   {
[17:38:09.347]                     do.call(function(...) {
[17:38:09.347]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.347]                       if (!identical(...future.globals.maxSize.org, 
[17:38:09.347]                         ...future.globals.maxSize)) {
[17:38:09.347]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.347]                         on.exit(options(oopts), add = TRUE)
[17:38:09.347]                       }
[17:38:09.347]                       {
[17:38:09.347]                         lapply(seq_along(...future.elements_ii), 
[17:38:09.347]                           FUN = function(jj) {
[17:38:09.347]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.347]                             ...future.FUN(...future.X_jj, ...)
[17:38:09.347]                           })
[17:38:09.347]                       }
[17:38:09.347]                     }, args = future.call.arguments)
[17:38:09.347]                   }
[17:38:09.347]                 }, immediateCondition = function(cond) {
[17:38:09.347]                   save_rds <- function (object, pathname, ...) 
[17:38:09.347]                   {
[17:38:09.347]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:09.347]                     if (file_test("-f", pathname_tmp)) {
[17:38:09.347]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.347]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:09.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.347]                         fi_tmp[["mtime"]])
[17:38:09.347]                     }
[17:38:09.347]                     tryCatch({
[17:38:09.347]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:09.347]                     }, error = function(ex) {
[17:38:09.347]                       msg <- conditionMessage(ex)
[17:38:09.347]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.347]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:09.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.347]                         fi_tmp[["mtime"]], msg)
[17:38:09.347]                       ex$message <- msg
[17:38:09.347]                       stop(ex)
[17:38:09.347]                     })
[17:38:09.347]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:09.347]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:09.347]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:09.347]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.347]                       fi <- file.info(pathname)
[17:38:09.347]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:09.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.347]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:09.347]                         fi[["size"]], fi[["mtime"]])
[17:38:09.347]                       stop(msg)
[17:38:09.347]                     }
[17:38:09.347]                     invisible(pathname)
[17:38:09.347]                   }
[17:38:09.347]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:09.347]                     rootPath = tempdir()) 
[17:38:09.347]                   {
[17:38:09.347]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:09.347]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:09.347]                       tmpdir = path, fileext = ".rds")
[17:38:09.347]                     save_rds(obj, file)
[17:38:09.347]                   }
[17:38:09.347]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:09.347]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.347]                   {
[17:38:09.347]                     inherits <- base::inherits
[17:38:09.347]                     invokeRestart <- base::invokeRestart
[17:38:09.347]                     is.null <- base::is.null
[17:38:09.347]                     muffled <- FALSE
[17:38:09.347]                     if (inherits(cond, "message")) {
[17:38:09.347]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:09.347]                       if (muffled) 
[17:38:09.347]                         invokeRestart("muffleMessage")
[17:38:09.347]                     }
[17:38:09.347]                     else if (inherits(cond, "warning")) {
[17:38:09.347]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:09.347]                       if (muffled) 
[17:38:09.347]                         invokeRestart("muffleWarning")
[17:38:09.347]                     }
[17:38:09.347]                     else if (inherits(cond, "condition")) {
[17:38:09.347]                       if (!is.null(pattern)) {
[17:38:09.347]                         computeRestarts <- base::computeRestarts
[17:38:09.347]                         grepl <- base::grepl
[17:38:09.347]                         restarts <- computeRestarts(cond)
[17:38:09.347]                         for (restart in restarts) {
[17:38:09.347]                           name <- restart$name
[17:38:09.347]                           if (is.null(name)) 
[17:38:09.347]                             next
[17:38:09.347]                           if (!grepl(pattern, name)) 
[17:38:09.347]                             next
[17:38:09.347]                           invokeRestart(restart)
[17:38:09.347]                           muffled <- TRUE
[17:38:09.347]                           break
[17:38:09.347]                         }
[17:38:09.347]                       }
[17:38:09.347]                     }
[17:38:09.347]                     invisible(muffled)
[17:38:09.347]                   }
[17:38:09.347]                   muffleCondition(cond)
[17:38:09.347]                 })
[17:38:09.347]             }))
[17:38:09.347]             future::FutureResult(value = ...future.value$value, 
[17:38:09.347]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.347]                   ...future.rng), globalenv = if (FALSE) 
[17:38:09.347]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:09.347]                     ...future.globalenv.names))
[17:38:09.347]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:09.347]         }, condition = base::local({
[17:38:09.347]             c <- base::c
[17:38:09.347]             inherits <- base::inherits
[17:38:09.347]             invokeRestart <- base::invokeRestart
[17:38:09.347]             length <- base::length
[17:38:09.347]             list <- base::list
[17:38:09.347]             seq.int <- base::seq.int
[17:38:09.347]             signalCondition <- base::signalCondition
[17:38:09.347]             sys.calls <- base::sys.calls
[17:38:09.347]             `[[` <- base::`[[`
[17:38:09.347]             `+` <- base::`+`
[17:38:09.347]             `<<-` <- base::`<<-`
[17:38:09.347]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:09.347]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:09.347]                   3L)]
[17:38:09.347]             }
[17:38:09.347]             function(cond) {
[17:38:09.347]                 is_error <- inherits(cond, "error")
[17:38:09.347]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:09.347]                   NULL)
[17:38:09.347]                 if (is_error) {
[17:38:09.347]                   sessionInformation <- function() {
[17:38:09.347]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:09.347]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:09.347]                       search = base::search(), system = base::Sys.info())
[17:38:09.347]                   }
[17:38:09.347]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.347]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:09.347]                     cond$call), session = sessionInformation(), 
[17:38:09.347]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:09.347]                   signalCondition(cond)
[17:38:09.347]                 }
[17:38:09.347]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:09.347]                 "immediateCondition"))) {
[17:38:09.347]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:09.347]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.347]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:09.347]                   if (TRUE && !signal) {
[17:38:09.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.347]                     {
[17:38:09.347]                       inherits <- base::inherits
[17:38:09.347]                       invokeRestart <- base::invokeRestart
[17:38:09.347]                       is.null <- base::is.null
[17:38:09.347]                       muffled <- FALSE
[17:38:09.347]                       if (inherits(cond, "message")) {
[17:38:09.347]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.347]                         if (muffled) 
[17:38:09.347]                           invokeRestart("muffleMessage")
[17:38:09.347]                       }
[17:38:09.347]                       else if (inherits(cond, "warning")) {
[17:38:09.347]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.347]                         if (muffled) 
[17:38:09.347]                           invokeRestart("muffleWarning")
[17:38:09.347]                       }
[17:38:09.347]                       else if (inherits(cond, "condition")) {
[17:38:09.347]                         if (!is.null(pattern)) {
[17:38:09.347]                           computeRestarts <- base::computeRestarts
[17:38:09.347]                           grepl <- base::grepl
[17:38:09.347]                           restarts <- computeRestarts(cond)
[17:38:09.347]                           for (restart in restarts) {
[17:38:09.347]                             name <- restart$name
[17:38:09.347]                             if (is.null(name)) 
[17:38:09.347]                               next
[17:38:09.347]                             if (!grepl(pattern, name)) 
[17:38:09.347]                               next
[17:38:09.347]                             invokeRestart(restart)
[17:38:09.347]                             muffled <- TRUE
[17:38:09.347]                             break
[17:38:09.347]                           }
[17:38:09.347]                         }
[17:38:09.347]                       }
[17:38:09.347]                       invisible(muffled)
[17:38:09.347]                     }
[17:38:09.347]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.347]                   }
[17:38:09.347]                 }
[17:38:09.347]                 else {
[17:38:09.347]                   if (TRUE) {
[17:38:09.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.347]                     {
[17:38:09.347]                       inherits <- base::inherits
[17:38:09.347]                       invokeRestart <- base::invokeRestart
[17:38:09.347]                       is.null <- base::is.null
[17:38:09.347]                       muffled <- FALSE
[17:38:09.347]                       if (inherits(cond, "message")) {
[17:38:09.347]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.347]                         if (muffled) 
[17:38:09.347]                           invokeRestart("muffleMessage")
[17:38:09.347]                       }
[17:38:09.347]                       else if (inherits(cond, "warning")) {
[17:38:09.347]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.347]                         if (muffled) 
[17:38:09.347]                           invokeRestart("muffleWarning")
[17:38:09.347]                       }
[17:38:09.347]                       else if (inherits(cond, "condition")) {
[17:38:09.347]                         if (!is.null(pattern)) {
[17:38:09.347]                           computeRestarts <- base::computeRestarts
[17:38:09.347]                           grepl <- base::grepl
[17:38:09.347]                           restarts <- computeRestarts(cond)
[17:38:09.347]                           for (restart in restarts) {
[17:38:09.347]                             name <- restart$name
[17:38:09.347]                             if (is.null(name)) 
[17:38:09.347]                               next
[17:38:09.347]                             if (!grepl(pattern, name)) 
[17:38:09.347]                               next
[17:38:09.347]                             invokeRestart(restart)
[17:38:09.347]                             muffled <- TRUE
[17:38:09.347]                             break
[17:38:09.347]                           }
[17:38:09.347]                         }
[17:38:09.347]                       }
[17:38:09.347]                       invisible(muffled)
[17:38:09.347]                     }
[17:38:09.347]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.347]                   }
[17:38:09.347]                 }
[17:38:09.347]             }
[17:38:09.347]         }))
[17:38:09.347]     }, error = function(ex) {
[17:38:09.347]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:09.347]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.347]                 ...future.rng), started = ...future.startTime, 
[17:38:09.347]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:09.347]             version = "1.8"), class = "FutureResult")
[17:38:09.347]     }, finally = {
[17:38:09.347]         if (!identical(...future.workdir, getwd())) 
[17:38:09.347]             setwd(...future.workdir)
[17:38:09.347]         {
[17:38:09.347]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:09.347]                 ...future.oldOptions$nwarnings <- NULL
[17:38:09.347]             }
[17:38:09.347]             base::options(...future.oldOptions)
[17:38:09.347]             if (.Platform$OS.type == "windows") {
[17:38:09.347]                 old_names <- names(...future.oldEnvVars)
[17:38:09.347]                 envs <- base::Sys.getenv()
[17:38:09.347]                 names <- names(envs)
[17:38:09.347]                 common <- intersect(names, old_names)
[17:38:09.347]                 added <- setdiff(names, old_names)
[17:38:09.347]                 removed <- setdiff(old_names, names)
[17:38:09.347]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:09.347]                   envs[common]]
[17:38:09.347]                 NAMES <- toupper(changed)
[17:38:09.347]                 args <- list()
[17:38:09.347]                 for (kk in seq_along(NAMES)) {
[17:38:09.347]                   name <- changed[[kk]]
[17:38:09.347]                   NAME <- NAMES[[kk]]
[17:38:09.347]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.347]                     next
[17:38:09.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.347]                 }
[17:38:09.347]                 NAMES <- toupper(added)
[17:38:09.347]                 for (kk in seq_along(NAMES)) {
[17:38:09.347]                   name <- added[[kk]]
[17:38:09.347]                   NAME <- NAMES[[kk]]
[17:38:09.347]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.347]                     next
[17:38:09.347]                   args[[name]] <- ""
[17:38:09.347]                 }
[17:38:09.347]                 NAMES <- toupper(removed)
[17:38:09.347]                 for (kk in seq_along(NAMES)) {
[17:38:09.347]                   name <- removed[[kk]]
[17:38:09.347]                   NAME <- NAMES[[kk]]
[17:38:09.347]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.347]                     next
[17:38:09.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.347]                 }
[17:38:09.347]                 if (length(args) > 0) 
[17:38:09.347]                   base::do.call(base::Sys.setenv, args = args)
[17:38:09.347]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:09.347]             }
[17:38:09.347]             else {
[17:38:09.347]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:09.347]             }
[17:38:09.347]             {
[17:38:09.347]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:09.347]                   0L) {
[17:38:09.347]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:09.347]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:09.347]                   base::options(opts)
[17:38:09.347]                 }
[17:38:09.347]                 {
[17:38:09.347]                   {
[17:38:09.347]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:09.347]                     NULL
[17:38:09.347]                   }
[17:38:09.347]                   options(future.plan = NULL)
[17:38:09.347]                   if (is.na(NA_character_)) 
[17:38:09.347]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.347]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:09.347]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:09.347]                     .init = FALSE)
[17:38:09.347]                 }
[17:38:09.347]             }
[17:38:09.347]         }
[17:38:09.347]     })
[17:38:09.347]     if (TRUE) {
[17:38:09.347]         base::sink(type = "output", split = FALSE)
[17:38:09.347]         if (TRUE) {
[17:38:09.347]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:09.347]         }
[17:38:09.347]         else {
[17:38:09.347]             ...future.result["stdout"] <- base::list(NULL)
[17:38:09.347]         }
[17:38:09.347]         base::close(...future.stdout)
[17:38:09.347]         ...future.stdout <- NULL
[17:38:09.347]     }
[17:38:09.347]     ...future.result$conditions <- ...future.conditions
[17:38:09.347]     ...future.result$finished <- base::Sys.time()
[17:38:09.347]     ...future.result
[17:38:09.347] }
[17:38:09.350] assign_globals() ...
[17:38:09.350] List of 11
[17:38:09.350]  $ ...future.FUN            :function (x, ...)  
[17:38:09.350]  $ x_FUN                    :function (x)  
[17:38:09.350]  $ times                    : int 1
[17:38:09.350]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:09.350]  $ stop_if_not              :function (...)  
[17:38:09.350]  $ dim                      : NULL
[17:38:09.350]  $ valid_types              : chr [1:2] "logical" "integer"
[17:38:09.350]  $ future.call.arguments    : list()
[17:38:09.350]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.350]  $ ...future.elements_ii    :List of 1
[17:38:09.350]   ..$ a: num 1
[17:38:09.350]  $ ...future.seeds_ii       : NULL
[17:38:09.350]  $ ...future.globals.maxSize: NULL
[17:38:09.350]  - attr(*, "where")=List of 11
[17:38:09.350]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:09.350]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:09.350]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:09.350]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:09.350]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:09.350]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:09.350]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:09.350]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:09.350]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:09.350]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:09.350]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:09.350]  - attr(*, "resolved")= logi FALSE
[17:38:09.350]  - attr(*, "total_size")= num 94264
[17:38:09.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.350]  - attr(*, "already-done")= logi TRUE
[17:38:09.359] - copied ‘...future.FUN’ to environment
[17:38:09.359] - copied ‘x_FUN’ to environment
[17:38:09.359] - copied ‘times’ to environment
[17:38:09.359] - copied ‘stopf’ to environment
[17:38:09.359] - copied ‘stop_if_not’ to environment
[17:38:09.359] - copied ‘dim’ to environment
[17:38:09.359] - copied ‘valid_types’ to environment
[17:38:09.359] - copied ‘future.call.arguments’ to environment
[17:38:09.359] - copied ‘...future.elements_ii’ to environment
[17:38:09.359] - copied ‘...future.seeds_ii’ to environment
[17:38:09.360] - copied ‘...future.globals.maxSize’ to environment
[17:38:09.360] assign_globals() ... done
[17:38:09.360] requestCore(): workers = 2
[17:38:09.362] MulticoreFuture started
[17:38:09.363] - Launch lazy future ... done
[17:38:09.363] run() for ‘MulticoreFuture’ ... done
[17:38:09.363] Created future:
[17:38:09.364] plan(): Setting new future strategy stack:
[17:38:09.364] List of future strategies:
[17:38:09.364] 1. sequential:
[17:38:09.364]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:09.364]    - tweaked: FALSE
[17:38:09.364]    - call: NULL
[17:38:09.365] plan(): nbrOfWorkers() = 1
[17:38:09.367] plan(): Setting new future strategy stack:
[17:38:09.367] List of future strategies:
[17:38:09.367] 1. multicore:
[17:38:09.367]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:09.367]    - tweaked: FALSE
[17:38:09.367]    - call: plan(strategy)
[17:38:09.373] plan(): nbrOfWorkers() = 2
[17:38:09.363] MulticoreFuture:
[17:38:09.363] Label: ‘future_vapply-1’
[17:38:09.363] Expression:
[17:38:09.363] {
[17:38:09.363]     do.call(function(...) {
[17:38:09.363]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.363]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.363]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.363]             on.exit(options(oopts), add = TRUE)
[17:38:09.363]         }
[17:38:09.363]         {
[17:38:09.363]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.363]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.363]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.363]             })
[17:38:09.363]         }
[17:38:09.363]     }, args = future.call.arguments)
[17:38:09.363] }
[17:38:09.363] Lazy evaluation: FALSE
[17:38:09.363] Asynchronous evaluation: TRUE
[17:38:09.363] Local evaluation: TRUE
[17:38:09.363] Environment: R_GlobalEnv
[17:38:09.363] Capture standard output: TRUE
[17:38:09.363] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:09.363] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:09.363] Packages: 1 packages (‘future.apply’)
[17:38:09.363] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:09.363] Resolved: TRUE
[17:38:09.363] Value: <not collected>
[17:38:09.363] Conditions captured: <none>
[17:38:09.363] Early signaling: FALSE
[17:38:09.363] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:09.363] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.374] Chunk #1 of 2 ... DONE
[17:38:09.374] Chunk #2 of 2 ...
[17:38:09.374]  - Finding globals in 'X' for chunk #2 ...
[17:38:09.374] getGlobalsAndPackages() ...
[17:38:09.374] Searching for globals...
[17:38:09.375] 
[17:38:09.375] Searching for globals ... DONE
[17:38:09.375] - globals: [0] <none>
[17:38:09.375] getGlobalsAndPackages() ... DONE
[17:38:09.375]    + additional globals found: [n=0] 
[17:38:09.376]    + additional namespaces needed: [n=0] 
[17:38:09.376]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:09.376]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:09.376]  - seeds: <none>
[17:38:09.376]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.376] getGlobalsAndPackages() ...
[17:38:09.376] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.377] Resolving globals: FALSE
[17:38:09.377] Tweak future expression to call with '...' arguments ...
[17:38:09.377] {
[17:38:09.377]     do.call(function(...) {
[17:38:09.377]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.377]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.377]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.377]             on.exit(options(oopts), add = TRUE)
[17:38:09.377]         }
[17:38:09.377]         {
[17:38:09.377]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.377]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.377]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.377]             })
[17:38:09.377]         }
[17:38:09.377]     }, args = future.call.arguments)
[17:38:09.377] }
[17:38:09.377] Tweak future expression to call with '...' arguments ... DONE
[17:38:09.378] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.379] - packages: [1] ‘future.apply’
[17:38:09.379] getGlobalsAndPackages() ... DONE
[17:38:09.379] run() for ‘Future’ ...
[17:38:09.379] - state: ‘created’
[17:38:09.380] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:09.384] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.385] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:09.385]   - Field: ‘label’
[17:38:09.385]   - Field: ‘local’
[17:38:09.385]   - Field: ‘owner’
[17:38:09.385]   - Field: ‘envir’
[17:38:09.385]   - Field: ‘workers’
[17:38:09.386]   - Field: ‘packages’
[17:38:09.386]   - Field: ‘gc’
[17:38:09.386]   - Field: ‘job’
[17:38:09.386]   - Field: ‘conditions’
[17:38:09.386]   - Field: ‘expr’
[17:38:09.386]   - Field: ‘uuid’
[17:38:09.386]   - Field: ‘seed’
[17:38:09.387]   - Field: ‘version’
[17:38:09.387]   - Field: ‘result’
[17:38:09.387]   - Field: ‘asynchronous’
[17:38:09.387]   - Field: ‘calls’
[17:38:09.387]   - Field: ‘globals’
[17:38:09.387]   - Field: ‘stdout’
[17:38:09.388]   - Field: ‘earlySignal’
[17:38:09.388]   - Field: ‘lazy’
[17:38:09.388]   - Field: ‘state’
[17:38:09.388] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:09.388] - Launch lazy future ...
[17:38:09.389] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:09.393] Packages needed by future strategies (n = 0): <none>
[17:38:09.394] {
[17:38:09.394]     {
[17:38:09.394]         {
[17:38:09.394]             ...future.startTime <- base::Sys.time()
[17:38:09.394]             {
[17:38:09.394]                 {
[17:38:09.394]                   {
[17:38:09.394]                     {
[17:38:09.394]                       {
[17:38:09.394]                         base::local({
[17:38:09.394]                           has_future <- base::requireNamespace("future", 
[17:38:09.394]                             quietly = TRUE)
[17:38:09.394]                           if (has_future) {
[17:38:09.394]                             ns <- base::getNamespace("future")
[17:38:09.394]                             version <- ns[[".package"]][["version"]]
[17:38:09.394]                             if (is.null(version)) 
[17:38:09.394]                               version <- utils::packageVersion("future")
[17:38:09.394]                           }
[17:38:09.394]                           else {
[17:38:09.394]                             version <- NULL
[17:38:09.394]                           }
[17:38:09.394]                           if (!has_future || version < "1.8.0") {
[17:38:09.394]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:09.394]                               "", base::R.version$version.string), 
[17:38:09.394]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:09.394]                                 base::R.version$platform, 8 * 
[17:38:09.394]                                   base::.Machine$sizeof.pointer), 
[17:38:09.394]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:09.394]                                 "release", "version")], collapse = " "), 
[17:38:09.394]                               hostname = base::Sys.info()[["nodename"]])
[17:38:09.394]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:09.394]                               info)
[17:38:09.394]                             info <- base::paste(info, collapse = "; ")
[17:38:09.394]                             if (!has_future) {
[17:38:09.394]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:09.394]                                 info)
[17:38:09.394]                             }
[17:38:09.394]                             else {
[17:38:09.394]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:09.394]                                 info, version)
[17:38:09.394]                             }
[17:38:09.394]                             base::stop(msg)
[17:38:09.394]                           }
[17:38:09.394]                         })
[17:38:09.394]                       }
[17:38:09.394]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:09.394]                       base::options(mc.cores = 1L)
[17:38:09.394]                     }
[17:38:09.394]                     base::local({
[17:38:09.394]                       for (pkg in "future.apply") {
[17:38:09.394]                         base::loadNamespace(pkg)
[17:38:09.394]                         base::library(pkg, character.only = TRUE)
[17:38:09.394]                       }
[17:38:09.394]                     })
[17:38:09.394]                   }
[17:38:09.394]                   ...future.strategy.old <- future::plan("list")
[17:38:09.394]                   options(future.plan = NULL)
[17:38:09.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:09.394]                 }
[17:38:09.394]                 ...future.workdir <- getwd()
[17:38:09.394]             }
[17:38:09.394]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:09.394]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:09.394]         }
[17:38:09.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:09.394]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:09.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:09.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:09.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:09.394]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:09.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:09.394]             base::names(...future.oldOptions))
[17:38:09.394]     }
[17:38:09.394]     if (FALSE) {
[17:38:09.394]     }
[17:38:09.394]     else {
[17:38:09.394]         if (TRUE) {
[17:38:09.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:09.394]                 open = "w")
[17:38:09.394]         }
[17:38:09.394]         else {
[17:38:09.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:09.394]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:09.394]         }
[17:38:09.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:09.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:09.394]             base::sink(type = "output", split = FALSE)
[17:38:09.394]             base::close(...future.stdout)
[17:38:09.394]         }, add = TRUE)
[17:38:09.394]     }
[17:38:09.394]     ...future.frame <- base::sys.nframe()
[17:38:09.394]     ...future.conditions <- base::list()
[17:38:09.394]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:09.394]     if (FALSE) {
[17:38:09.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:09.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:09.394]     }
[17:38:09.394]     ...future.result <- base::tryCatch({
[17:38:09.394]         base::withCallingHandlers({
[17:38:09.394]             ...future.value <- base::withVisible(base::local({
[17:38:09.394]                 withCallingHandlers({
[17:38:09.394]                   {
[17:38:09.394]                     do.call(function(...) {
[17:38:09.394]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.394]                       if (!identical(...future.globals.maxSize.org, 
[17:38:09.394]                         ...future.globals.maxSize)) {
[17:38:09.394]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.394]                         on.exit(options(oopts), add = TRUE)
[17:38:09.394]                       }
[17:38:09.394]                       {
[17:38:09.394]                         lapply(seq_along(...future.elements_ii), 
[17:38:09.394]                           FUN = function(jj) {
[17:38:09.394]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.394]                             ...future.FUN(...future.X_jj, ...)
[17:38:09.394]                           })
[17:38:09.394]                       }
[17:38:09.394]                     }, args = future.call.arguments)
[17:38:09.394]                   }
[17:38:09.394]                 }, immediateCondition = function(cond) {
[17:38:09.394]                   save_rds <- function (object, pathname, ...) 
[17:38:09.394]                   {
[17:38:09.394]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:09.394]                     if (file_test("-f", pathname_tmp)) {
[17:38:09.394]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.394]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:09.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.394]                         fi_tmp[["mtime"]])
[17:38:09.394]                     }
[17:38:09.394]                     tryCatch({
[17:38:09.394]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:09.394]                     }, error = function(ex) {
[17:38:09.394]                       msg <- conditionMessage(ex)
[17:38:09.394]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.394]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:09.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.394]                         fi_tmp[["mtime"]], msg)
[17:38:09.394]                       ex$message <- msg
[17:38:09.394]                       stop(ex)
[17:38:09.394]                     })
[17:38:09.394]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:09.394]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:09.394]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:09.394]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.394]                       fi <- file.info(pathname)
[17:38:09.394]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:09.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.394]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:09.394]                         fi[["size"]], fi[["mtime"]])
[17:38:09.394]                       stop(msg)
[17:38:09.394]                     }
[17:38:09.394]                     invisible(pathname)
[17:38:09.394]                   }
[17:38:09.394]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:09.394]                     rootPath = tempdir()) 
[17:38:09.394]                   {
[17:38:09.394]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:09.394]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:09.394]                       tmpdir = path, fileext = ".rds")
[17:38:09.394]                     save_rds(obj, file)
[17:38:09.394]                   }
[17:38:09.394]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:09.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.394]                   {
[17:38:09.394]                     inherits <- base::inherits
[17:38:09.394]                     invokeRestart <- base::invokeRestart
[17:38:09.394]                     is.null <- base::is.null
[17:38:09.394]                     muffled <- FALSE
[17:38:09.394]                     if (inherits(cond, "message")) {
[17:38:09.394]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:09.394]                       if (muffled) 
[17:38:09.394]                         invokeRestart("muffleMessage")
[17:38:09.394]                     }
[17:38:09.394]                     else if (inherits(cond, "warning")) {
[17:38:09.394]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:09.394]                       if (muffled) 
[17:38:09.394]                         invokeRestart("muffleWarning")
[17:38:09.394]                     }
[17:38:09.394]                     else if (inherits(cond, "condition")) {
[17:38:09.394]                       if (!is.null(pattern)) {
[17:38:09.394]                         computeRestarts <- base::computeRestarts
[17:38:09.394]                         grepl <- base::grepl
[17:38:09.394]                         restarts <- computeRestarts(cond)
[17:38:09.394]                         for (restart in restarts) {
[17:38:09.394]                           name <- restart$name
[17:38:09.394]                           if (is.null(name)) 
[17:38:09.394]                             next
[17:38:09.394]                           if (!grepl(pattern, name)) 
[17:38:09.394]                             next
[17:38:09.394]                           invokeRestart(restart)
[17:38:09.394]                           muffled <- TRUE
[17:38:09.394]                           break
[17:38:09.394]                         }
[17:38:09.394]                       }
[17:38:09.394]                     }
[17:38:09.394]                     invisible(muffled)
[17:38:09.394]                   }
[17:38:09.394]                   muffleCondition(cond)
[17:38:09.394]                 })
[17:38:09.394]             }))
[17:38:09.394]             future::FutureResult(value = ...future.value$value, 
[17:38:09.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.394]                   ...future.rng), globalenv = if (FALSE) 
[17:38:09.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:09.394]                     ...future.globalenv.names))
[17:38:09.394]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:09.394]         }, condition = base::local({
[17:38:09.394]             c <- base::c
[17:38:09.394]             inherits <- base::inherits
[17:38:09.394]             invokeRestart <- base::invokeRestart
[17:38:09.394]             length <- base::length
[17:38:09.394]             list <- base::list
[17:38:09.394]             seq.int <- base::seq.int
[17:38:09.394]             signalCondition <- base::signalCondition
[17:38:09.394]             sys.calls <- base::sys.calls
[17:38:09.394]             `[[` <- base::`[[`
[17:38:09.394]             `+` <- base::`+`
[17:38:09.394]             `<<-` <- base::`<<-`
[17:38:09.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:09.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:09.394]                   3L)]
[17:38:09.394]             }
[17:38:09.394]             function(cond) {
[17:38:09.394]                 is_error <- inherits(cond, "error")
[17:38:09.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:09.394]                   NULL)
[17:38:09.394]                 if (is_error) {
[17:38:09.394]                   sessionInformation <- function() {
[17:38:09.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:09.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:09.394]                       search = base::search(), system = base::Sys.info())
[17:38:09.394]                   }
[17:38:09.394]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:09.394]                     cond$call), session = sessionInformation(), 
[17:38:09.394]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:09.394]                   signalCondition(cond)
[17:38:09.394]                 }
[17:38:09.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:09.394]                 "immediateCondition"))) {
[17:38:09.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:09.394]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:09.394]                   if (TRUE && !signal) {
[17:38:09.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.394]                     {
[17:38:09.394]                       inherits <- base::inherits
[17:38:09.394]                       invokeRestart <- base::invokeRestart
[17:38:09.394]                       is.null <- base::is.null
[17:38:09.394]                       muffled <- FALSE
[17:38:09.394]                       if (inherits(cond, "message")) {
[17:38:09.394]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.394]                         if (muffled) 
[17:38:09.394]                           invokeRestart("muffleMessage")
[17:38:09.394]                       }
[17:38:09.394]                       else if (inherits(cond, "warning")) {
[17:38:09.394]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.394]                         if (muffled) 
[17:38:09.394]                           invokeRestart("muffleWarning")
[17:38:09.394]                       }
[17:38:09.394]                       else if (inherits(cond, "condition")) {
[17:38:09.394]                         if (!is.null(pattern)) {
[17:38:09.394]                           computeRestarts <- base::computeRestarts
[17:38:09.394]                           grepl <- base::grepl
[17:38:09.394]                           restarts <- computeRestarts(cond)
[17:38:09.394]                           for (restart in restarts) {
[17:38:09.394]                             name <- restart$name
[17:38:09.394]                             if (is.null(name)) 
[17:38:09.394]                               next
[17:38:09.394]                             if (!grepl(pattern, name)) 
[17:38:09.394]                               next
[17:38:09.394]                             invokeRestart(restart)
[17:38:09.394]                             muffled <- TRUE
[17:38:09.394]                             break
[17:38:09.394]                           }
[17:38:09.394]                         }
[17:38:09.394]                       }
[17:38:09.394]                       invisible(muffled)
[17:38:09.394]                     }
[17:38:09.394]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.394]                   }
[17:38:09.394]                 }
[17:38:09.394]                 else {
[17:38:09.394]                   if (TRUE) {
[17:38:09.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.394]                     {
[17:38:09.394]                       inherits <- base::inherits
[17:38:09.394]                       invokeRestart <- base::invokeRestart
[17:38:09.394]                       is.null <- base::is.null
[17:38:09.394]                       muffled <- FALSE
[17:38:09.394]                       if (inherits(cond, "message")) {
[17:38:09.394]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.394]                         if (muffled) 
[17:38:09.394]                           invokeRestart("muffleMessage")
[17:38:09.394]                       }
[17:38:09.394]                       else if (inherits(cond, "warning")) {
[17:38:09.394]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.394]                         if (muffled) 
[17:38:09.394]                           invokeRestart("muffleWarning")
[17:38:09.394]                       }
[17:38:09.394]                       else if (inherits(cond, "condition")) {
[17:38:09.394]                         if (!is.null(pattern)) {
[17:38:09.394]                           computeRestarts <- base::computeRestarts
[17:38:09.394]                           grepl <- base::grepl
[17:38:09.394]                           restarts <- computeRestarts(cond)
[17:38:09.394]                           for (restart in restarts) {
[17:38:09.394]                             name <- restart$name
[17:38:09.394]                             if (is.null(name)) 
[17:38:09.394]                               next
[17:38:09.394]                             if (!grepl(pattern, name)) 
[17:38:09.394]                               next
[17:38:09.394]                             invokeRestart(restart)
[17:38:09.394]                             muffled <- TRUE
[17:38:09.394]                             break
[17:38:09.394]                           }
[17:38:09.394]                         }
[17:38:09.394]                       }
[17:38:09.394]                       invisible(muffled)
[17:38:09.394]                     }
[17:38:09.394]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.394]                   }
[17:38:09.394]                 }
[17:38:09.394]             }
[17:38:09.394]         }))
[17:38:09.394]     }, error = function(ex) {
[17:38:09.394]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:09.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.394]                 ...future.rng), started = ...future.startTime, 
[17:38:09.394]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:09.394]             version = "1.8"), class = "FutureResult")
[17:38:09.394]     }, finally = {
[17:38:09.394]         if (!identical(...future.workdir, getwd())) 
[17:38:09.394]             setwd(...future.workdir)
[17:38:09.394]         {
[17:38:09.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:09.394]                 ...future.oldOptions$nwarnings <- NULL
[17:38:09.394]             }
[17:38:09.394]             base::options(...future.oldOptions)
[17:38:09.394]             if (.Platform$OS.type == "windows") {
[17:38:09.394]                 old_names <- names(...future.oldEnvVars)
[17:38:09.394]                 envs <- base::Sys.getenv()
[17:38:09.394]                 names <- names(envs)
[17:38:09.394]                 common <- intersect(names, old_names)
[17:38:09.394]                 added <- setdiff(names, old_names)
[17:38:09.394]                 removed <- setdiff(old_names, names)
[17:38:09.394]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:09.394]                   envs[common]]
[17:38:09.394]                 NAMES <- toupper(changed)
[17:38:09.394]                 args <- list()
[17:38:09.394]                 for (kk in seq_along(NAMES)) {
[17:38:09.394]                   name <- changed[[kk]]
[17:38:09.394]                   NAME <- NAMES[[kk]]
[17:38:09.394]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.394]                     next
[17:38:09.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.394]                 }
[17:38:09.394]                 NAMES <- toupper(added)
[17:38:09.394]                 for (kk in seq_along(NAMES)) {
[17:38:09.394]                   name <- added[[kk]]
[17:38:09.394]                   NAME <- NAMES[[kk]]
[17:38:09.394]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.394]                     next
[17:38:09.394]                   args[[name]] <- ""
[17:38:09.394]                 }
[17:38:09.394]                 NAMES <- toupper(removed)
[17:38:09.394]                 for (kk in seq_along(NAMES)) {
[17:38:09.394]                   name <- removed[[kk]]
[17:38:09.394]                   NAME <- NAMES[[kk]]
[17:38:09.394]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.394]                     next
[17:38:09.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.394]                 }
[17:38:09.394]                 if (length(args) > 0) 
[17:38:09.394]                   base::do.call(base::Sys.setenv, args = args)
[17:38:09.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:09.394]             }
[17:38:09.394]             else {
[17:38:09.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:09.394]             }
[17:38:09.394]             {
[17:38:09.394]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:09.394]                   0L) {
[17:38:09.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:09.394]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:09.394]                   base::options(opts)
[17:38:09.394]                 }
[17:38:09.394]                 {
[17:38:09.394]                   {
[17:38:09.394]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:09.394]                     NULL
[17:38:09.394]                   }
[17:38:09.394]                   options(future.plan = NULL)
[17:38:09.394]                   if (is.na(NA_character_)) 
[17:38:09.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:09.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:09.394]                     .init = FALSE)
[17:38:09.394]                 }
[17:38:09.394]             }
[17:38:09.394]         }
[17:38:09.394]     })
[17:38:09.394]     if (TRUE) {
[17:38:09.394]         base::sink(type = "output", split = FALSE)
[17:38:09.394]         if (TRUE) {
[17:38:09.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:09.394]         }
[17:38:09.394]         else {
[17:38:09.394]             ...future.result["stdout"] <- base::list(NULL)
[17:38:09.394]         }
[17:38:09.394]         base::close(...future.stdout)
[17:38:09.394]         ...future.stdout <- NULL
[17:38:09.394]     }
[17:38:09.394]     ...future.result$conditions <- ...future.conditions
[17:38:09.394]     ...future.result$finished <- base::Sys.time()
[17:38:09.394]     ...future.result
[17:38:09.394] }
[17:38:09.397] assign_globals() ...
[17:38:09.398] List of 11
[17:38:09.398]  $ ...future.FUN            :function (x, ...)  
[17:38:09.398]  $ x_FUN                    :function (x)  
[17:38:09.398]  $ times                    : int 1
[17:38:09.398]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:09.398]  $ stop_if_not              :function (...)  
[17:38:09.398]  $ dim                      : NULL
[17:38:09.398]  $ valid_types              : chr [1:2] "logical" "integer"
[17:38:09.398]  $ future.call.arguments    : list()
[17:38:09.398]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.398]  $ ...future.elements_ii    :List of 2
[17:38:09.398]   ..$ b: num 2
[17:38:09.398]   ..$ c: num 3
[17:38:09.398]  $ ...future.seeds_ii       : NULL
[17:38:09.398]  $ ...future.globals.maxSize: NULL
[17:38:09.398]  - attr(*, "where")=List of 11
[17:38:09.398]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:09.398]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:09.398]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:09.398]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:09.398]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:09.398]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:09.398]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:09.398]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:09.398]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:09.398]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:09.398]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:09.398]  - attr(*, "resolved")= logi FALSE
[17:38:09.398]  - attr(*, "total_size")= num 94264
[17:38:09.398]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.398]  - attr(*, "already-done")= logi TRUE
[17:38:09.412] - copied ‘...future.FUN’ to environment
[17:38:09.412] - copied ‘x_FUN’ to environment
[17:38:09.412] - copied ‘times’ to environment
[17:38:09.412] - copied ‘stopf’ to environment
[17:38:09.412] - copied ‘stop_if_not’ to environment
[17:38:09.412] - copied ‘dim’ to environment
[17:38:09.413] - copied ‘valid_types’ to environment
[17:38:09.413] - copied ‘future.call.arguments’ to environment
[17:38:09.413] - copied ‘...future.elements_ii’ to environment
[17:38:09.413] - copied ‘...future.seeds_ii’ to environment
[17:38:09.413] - copied ‘...future.globals.maxSize’ to environment
[17:38:09.413] assign_globals() ... done
[17:38:09.413] requestCore(): workers = 2
[17:38:09.416] MulticoreFuture started
[17:38:09.416] - Launch lazy future ... done
[17:38:09.416] run() for ‘MulticoreFuture’ ... done
[17:38:09.417] Created future:
[17:38:09.417] plan(): Setting new future strategy stack:
[17:38:09.418] List of future strategies:
[17:38:09.418] 1. sequential:
[17:38:09.418]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:09.418]    - tweaked: FALSE
[17:38:09.418]    - call: NULL
[17:38:09.419] plan(): nbrOfWorkers() = 1
[17:38:09.421] plan(): Setting new future strategy stack:
[17:38:09.421] List of future strategies:
[17:38:09.421] 1. multicore:
[17:38:09.421]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:09.421]    - tweaked: FALSE
[17:38:09.421]    - call: plan(strategy)
[17:38:09.426] plan(): nbrOfWorkers() = 2
[17:38:09.417] MulticoreFuture:
[17:38:09.417] Label: ‘future_vapply-2’
[17:38:09.417] Expression:
[17:38:09.417] {
[17:38:09.417]     do.call(function(...) {
[17:38:09.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.417]             on.exit(options(oopts), add = TRUE)
[17:38:09.417]         }
[17:38:09.417]         {
[17:38:09.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.417]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.417]             })
[17:38:09.417]         }
[17:38:09.417]     }, args = future.call.arguments)
[17:38:09.417] }
[17:38:09.417] Lazy evaluation: FALSE
[17:38:09.417] Asynchronous evaluation: TRUE
[17:38:09.417] Local evaluation: TRUE
[17:38:09.417] Environment: R_GlobalEnv
[17:38:09.417] Capture standard output: TRUE
[17:38:09.417] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:09.417] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:09.417] Packages: 1 packages (‘future.apply’)
[17:38:09.417] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:09.417] Resolved: TRUE
[17:38:09.417] Value: <not collected>
[17:38:09.417] Conditions captured: <none>
[17:38:09.417] Early signaling: FALSE
[17:38:09.417] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:09.417] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.427] Chunk #2 of 2 ... DONE
[17:38:09.427] Launching 2 futures (chunks) ... DONE
[17:38:09.427] Resolving 2 futures (chunks) ...
[17:38:09.428] resolve() on list ...
[17:38:09.428]  recursive: 0
[17:38:09.428]  length: 2
[17:38:09.428] 
[17:38:09.428] Future #1
[17:38:09.429] result() for MulticoreFuture ...
[17:38:09.429] result() for MulticoreFuture ...
[17:38:09.430] result() for MulticoreFuture ... done
[17:38:09.430] result() for MulticoreFuture ... done
[17:38:09.430] result() for MulticoreFuture ...
[17:38:09.430] result() for MulticoreFuture ... done
[17:38:09.430] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:09.430] - nx: 2
[17:38:09.431] - relay: TRUE
[17:38:09.431] - stdout: TRUE
[17:38:09.431] - signal: TRUE
[17:38:09.431] - resignal: FALSE
[17:38:09.431] - force: TRUE
[17:38:09.431] - relayed: [n=2] FALSE, FALSE
[17:38:09.431] - queued futures: [n=2] FALSE, FALSE
[17:38:09.432]  - until=1
[17:38:09.432]  - relaying element #1
[17:38:09.432] result() for MulticoreFuture ...
[17:38:09.432] result() for MulticoreFuture ... done
[17:38:09.432] result() for MulticoreFuture ...
[17:38:09.432] result() for MulticoreFuture ... done
[17:38:09.433] result() for MulticoreFuture ...
[17:38:09.433] result() for MulticoreFuture ... done
[17:38:09.433] result() for MulticoreFuture ...
[17:38:09.433] result() for MulticoreFuture ... done
[17:38:09.433] - relayed: [n=2] TRUE, FALSE
[17:38:09.433] - queued futures: [n=2] TRUE, FALSE
[17:38:09.433] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:09.434]  length: 1 (resolved future 1)
[17:38:09.434] Future #2
[17:38:09.434] result() for MulticoreFuture ...
[17:38:09.435] result() for MulticoreFuture ...
[17:38:09.435] result() for MulticoreFuture ... done
[17:38:09.435] result() for MulticoreFuture ... done
[17:38:09.435] result() for MulticoreFuture ...
[17:38:09.435] result() for MulticoreFuture ... done
[17:38:09.436] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:38:09.436] - nx: 2
[17:38:09.436] - relay: TRUE
[17:38:09.436] - stdout: TRUE
[17:38:09.436] - signal: TRUE
[17:38:09.436] - resignal: FALSE
[17:38:09.437] - force: TRUE
[17:38:09.437] - relayed: [n=2] TRUE, FALSE
[17:38:09.437] - queued futures: [n=2] TRUE, FALSE
[17:38:09.437]  - until=2
[17:38:09.437]  - relaying element #2
[17:38:09.437] result() for MulticoreFuture ...
[17:38:09.437] result() for MulticoreFuture ... done
[17:38:09.437] result() for MulticoreFuture ...
[17:38:09.437] result() for MulticoreFuture ... done
[17:38:09.438] result() for MulticoreFuture ...
[17:38:09.441] result() for MulticoreFuture ... done
[17:38:09.441] result() for MulticoreFuture ...
[17:38:09.441] result() for MulticoreFuture ... done
[17:38:09.441] - relayed: [n=2] TRUE, TRUE
[17:38:09.442] - queued futures: [n=2] TRUE, TRUE
[17:38:09.442] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:38:09.442]  length: 0 (resolved future 2)
[17:38:09.442] Relaying remaining futures
[17:38:09.442] signalConditionsASAP(NULL, pos=0) ...
[17:38:09.442] - nx: 2
[17:38:09.442] - relay: TRUE
[17:38:09.443] - stdout: TRUE
[17:38:09.443] - signal: TRUE
[17:38:09.443] - resignal: FALSE
[17:38:09.443] - force: TRUE
[17:38:09.443] - relayed: [n=2] TRUE, TRUE
[17:38:09.443] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:09.444] - relayed: [n=2] TRUE, TRUE
[17:38:09.444] - queued futures: [n=2] TRUE, TRUE
[17:38:09.444] signalConditionsASAP(NULL, pos=0) ... done
[17:38:09.444] resolve() on list ... DONE
[17:38:09.444] result() for MulticoreFuture ...
[17:38:09.444] result() for MulticoreFuture ... done
[17:38:09.445] result() for MulticoreFuture ...
[17:38:09.445] result() for MulticoreFuture ... done
[17:38:09.445] result() for MulticoreFuture ...
[17:38:09.445] result() for MulticoreFuture ... done
[17:38:09.445] result() for MulticoreFuture ...
[17:38:09.445] result() for MulticoreFuture ... done
[17:38:09.446]  - Number of value chunks collected: 2
[17:38:09.446] Resolving 2 futures (chunks) ... DONE
[17:38:09.446] Reducing values from 2 chunks ...
[17:38:09.446]  - Number of values collected after concatenation: 3
[17:38:09.446]  - Number of values expected: 3
[17:38:09.446] Reducing values from 2 chunks ... DONE
[17:38:09.446] future_lapply() ... DONE
- exceptions ...
[17:38:09.447] future_lapply() ...
[17:38:09.454] Number of chunks: 2
[17:38:09.454] getGlobalsAndPackagesXApply() ...
[17:38:09.454]  - future.globals: TRUE
[17:38:09.454] getGlobalsAndPackages() ...
[17:38:09.454] Searching for globals...
[17:38:09.458] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:09.458] Searching for globals ... DONE
[17:38:09.458] Resolving globals: FALSE
[17:38:09.459] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[17:38:09.460] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:09.460] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:09.460] - packages: [1] ‘future.apply’
[17:38:09.460] getGlobalsAndPackages() ... DONE
[17:38:09.460]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:09.460]  - needed namespaces: [n=1] ‘future.apply’
[17:38:09.461] Finding globals ... DONE
[17:38:09.461]  - use_args: TRUE
[17:38:09.461]  - Getting '...' globals ...
[17:38:09.461] resolve() on list ...
[17:38:09.461]  recursive: 0
[17:38:09.461]  length: 1
[17:38:09.461]  elements: ‘...’
[17:38:09.461]  length: 0 (resolved future 1)
[17:38:09.462] resolve() on list ... DONE
[17:38:09.462]    - '...' content: [n=0] 
[17:38:09.462] List of 1
[17:38:09.462]  $ ...: list()
[17:38:09.462]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.462]  - attr(*, "where")=List of 1
[17:38:09.462]   ..$ ...:<environment: 0x560801628530> 
[17:38:09.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.462]  - attr(*, "resolved")= logi TRUE
[17:38:09.462]  - attr(*, "total_size")= num NA
[17:38:09.465]  - Getting '...' globals ... DONE
[17:38:09.465] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:09.465] List of 8
[17:38:09.465]  $ ...future.FUN:function (x, ...)  
[17:38:09.465]  $ x_FUN        :function (x)  
[17:38:09.465]  $ times        : int 2
[17:38:09.465]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:09.465]  $ stop_if_not  :function (...)  
[17:38:09.465]  $ dim          : NULL
[17:38:09.465]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:09.465]  $ ...          : list()
[17:38:09.465]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.465]  - attr(*, "where")=List of 8
[17:38:09.465]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:09.465]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:09.465]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:09.465]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:09.465]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:09.465]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:09.465]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:09.465]   ..$ ...          :<environment: 0x560801628530> 
[17:38:09.465]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.465]  - attr(*, "resolved")= logi FALSE
[17:38:09.465]  - attr(*, "total_size")= num 95128
[17:38:09.474] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:09.474] getGlobalsAndPackagesXApply() ... DONE
[17:38:09.474] Number of futures (= number of chunks): 2
[17:38:09.475] Launching 2 futures (chunks) ...
[17:38:09.475] Chunk #1 of 2 ...
[17:38:09.475]  - Finding globals in 'X' for chunk #1 ...
[17:38:09.475] getGlobalsAndPackages() ...
[17:38:09.475] Searching for globals...
[17:38:09.475] 
[17:38:09.475] Searching for globals ... DONE
[17:38:09.476] - globals: [0] <none>
[17:38:09.476] getGlobalsAndPackages() ... DONE
[17:38:09.476]    + additional globals found: [n=0] 
[17:38:09.476]    + additional namespaces needed: [n=0] 
[17:38:09.476]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:09.476]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:09.476]  - seeds: <none>
[17:38:09.476]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.477] getGlobalsAndPackages() ...
[17:38:09.477] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.477] Resolving globals: FALSE
[17:38:09.477] Tweak future expression to call with '...' arguments ...
[17:38:09.477] {
[17:38:09.477]     do.call(function(...) {
[17:38:09.477]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.477]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.477]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.477]             on.exit(options(oopts), add = TRUE)
[17:38:09.477]         }
[17:38:09.477]         {
[17:38:09.477]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.477]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.477]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.477]             })
[17:38:09.477]         }
[17:38:09.477]     }, args = future.call.arguments)
[17:38:09.477] }
[17:38:09.477] Tweak future expression to call with '...' arguments ... DONE
[17:38:09.478] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.478] - packages: [1] ‘future.apply’
[17:38:09.478] getGlobalsAndPackages() ... DONE
[17:38:09.478] run() for ‘Future’ ...
[17:38:09.479] - state: ‘created’
[17:38:09.479] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:09.483] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.483] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:09.483]   - Field: ‘label’
[17:38:09.483]   - Field: ‘local’
[17:38:09.483]   - Field: ‘owner’
[17:38:09.483]   - Field: ‘envir’
[17:38:09.483]   - Field: ‘workers’
[17:38:09.483]   - Field: ‘packages’
[17:38:09.483]   - Field: ‘gc’
[17:38:09.484]   - Field: ‘job’
[17:38:09.484]   - Field: ‘conditions’
[17:38:09.484]   - Field: ‘expr’
[17:38:09.484]   - Field: ‘uuid’
[17:38:09.484]   - Field: ‘seed’
[17:38:09.484]   - Field: ‘version’
[17:38:09.484]   - Field: ‘result’
[17:38:09.484]   - Field: ‘asynchronous’
[17:38:09.484]   - Field: ‘calls’
[17:38:09.484]   - Field: ‘globals’
[17:38:09.485]   - Field: ‘stdout’
[17:38:09.485]   - Field: ‘earlySignal’
[17:38:09.485]   - Field: ‘lazy’
[17:38:09.485]   - Field: ‘state’
[17:38:09.485] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:09.485] - Launch lazy future ...
[17:38:09.485] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:09.485] Packages needed by future strategies (n = 0): <none>
[17:38:09.486] {
[17:38:09.486]     {
[17:38:09.486]         {
[17:38:09.486]             ...future.startTime <- base::Sys.time()
[17:38:09.486]             {
[17:38:09.486]                 {
[17:38:09.486]                   {
[17:38:09.486]                     {
[17:38:09.486]                       {
[17:38:09.486]                         base::local({
[17:38:09.486]                           has_future <- base::requireNamespace("future", 
[17:38:09.486]                             quietly = TRUE)
[17:38:09.486]                           if (has_future) {
[17:38:09.486]                             ns <- base::getNamespace("future")
[17:38:09.486]                             version <- ns[[".package"]][["version"]]
[17:38:09.486]                             if (is.null(version)) 
[17:38:09.486]                               version <- utils::packageVersion("future")
[17:38:09.486]                           }
[17:38:09.486]                           else {
[17:38:09.486]                             version <- NULL
[17:38:09.486]                           }
[17:38:09.486]                           if (!has_future || version < "1.8.0") {
[17:38:09.486]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:09.486]                               "", base::R.version$version.string), 
[17:38:09.486]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:09.486]                                 base::R.version$platform, 8 * 
[17:38:09.486]                                   base::.Machine$sizeof.pointer), 
[17:38:09.486]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:09.486]                                 "release", "version")], collapse = " "), 
[17:38:09.486]                               hostname = base::Sys.info()[["nodename"]])
[17:38:09.486]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:09.486]                               info)
[17:38:09.486]                             info <- base::paste(info, collapse = "; ")
[17:38:09.486]                             if (!has_future) {
[17:38:09.486]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:09.486]                                 info)
[17:38:09.486]                             }
[17:38:09.486]                             else {
[17:38:09.486]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:09.486]                                 info, version)
[17:38:09.486]                             }
[17:38:09.486]                             base::stop(msg)
[17:38:09.486]                           }
[17:38:09.486]                         })
[17:38:09.486]                       }
[17:38:09.486]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:09.486]                       base::options(mc.cores = 1L)
[17:38:09.486]                     }
[17:38:09.486]                     base::local({
[17:38:09.486]                       for (pkg in "future.apply") {
[17:38:09.486]                         base::loadNamespace(pkg)
[17:38:09.486]                         base::library(pkg, character.only = TRUE)
[17:38:09.486]                       }
[17:38:09.486]                     })
[17:38:09.486]                   }
[17:38:09.486]                   ...future.strategy.old <- future::plan("list")
[17:38:09.486]                   options(future.plan = NULL)
[17:38:09.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:09.486]                 }
[17:38:09.486]                 ...future.workdir <- getwd()
[17:38:09.486]             }
[17:38:09.486]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:09.486]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:09.486]         }
[17:38:09.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:09.486]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:09.486]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:09.486]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:09.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:09.486]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:09.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:09.486]             base::names(...future.oldOptions))
[17:38:09.486]     }
[17:38:09.486]     if (FALSE) {
[17:38:09.486]     }
[17:38:09.486]     else {
[17:38:09.486]         if (TRUE) {
[17:38:09.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:09.486]                 open = "w")
[17:38:09.486]         }
[17:38:09.486]         else {
[17:38:09.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:09.486]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:09.486]         }
[17:38:09.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:09.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:09.486]             base::sink(type = "output", split = FALSE)
[17:38:09.486]             base::close(...future.stdout)
[17:38:09.486]         }, add = TRUE)
[17:38:09.486]     }
[17:38:09.486]     ...future.frame <- base::sys.nframe()
[17:38:09.486]     ...future.conditions <- base::list()
[17:38:09.486]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:09.486]     if (FALSE) {
[17:38:09.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:09.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:09.486]     }
[17:38:09.486]     ...future.result <- base::tryCatch({
[17:38:09.486]         base::withCallingHandlers({
[17:38:09.486]             ...future.value <- base::withVisible(base::local({
[17:38:09.486]                 withCallingHandlers({
[17:38:09.486]                   {
[17:38:09.486]                     do.call(function(...) {
[17:38:09.486]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.486]                       if (!identical(...future.globals.maxSize.org, 
[17:38:09.486]                         ...future.globals.maxSize)) {
[17:38:09.486]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.486]                         on.exit(options(oopts), add = TRUE)
[17:38:09.486]                       }
[17:38:09.486]                       {
[17:38:09.486]                         lapply(seq_along(...future.elements_ii), 
[17:38:09.486]                           FUN = function(jj) {
[17:38:09.486]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.486]                             ...future.FUN(...future.X_jj, ...)
[17:38:09.486]                           })
[17:38:09.486]                       }
[17:38:09.486]                     }, args = future.call.arguments)
[17:38:09.486]                   }
[17:38:09.486]                 }, immediateCondition = function(cond) {
[17:38:09.486]                   save_rds <- function (object, pathname, ...) 
[17:38:09.486]                   {
[17:38:09.486]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:09.486]                     if (file_test("-f", pathname_tmp)) {
[17:38:09.486]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.486]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:09.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.486]                         fi_tmp[["mtime"]])
[17:38:09.486]                     }
[17:38:09.486]                     tryCatch({
[17:38:09.486]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:09.486]                     }, error = function(ex) {
[17:38:09.486]                       msg <- conditionMessage(ex)
[17:38:09.486]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.486]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:09.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.486]                         fi_tmp[["mtime"]], msg)
[17:38:09.486]                       ex$message <- msg
[17:38:09.486]                       stop(ex)
[17:38:09.486]                     })
[17:38:09.486]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:09.486]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:09.486]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:09.486]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.486]                       fi <- file.info(pathname)
[17:38:09.486]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:09.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.486]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:09.486]                         fi[["size"]], fi[["mtime"]])
[17:38:09.486]                       stop(msg)
[17:38:09.486]                     }
[17:38:09.486]                     invisible(pathname)
[17:38:09.486]                   }
[17:38:09.486]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:09.486]                     rootPath = tempdir()) 
[17:38:09.486]                   {
[17:38:09.486]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:09.486]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:09.486]                       tmpdir = path, fileext = ".rds")
[17:38:09.486]                     save_rds(obj, file)
[17:38:09.486]                   }
[17:38:09.486]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:09.486]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.486]                   {
[17:38:09.486]                     inherits <- base::inherits
[17:38:09.486]                     invokeRestart <- base::invokeRestart
[17:38:09.486]                     is.null <- base::is.null
[17:38:09.486]                     muffled <- FALSE
[17:38:09.486]                     if (inherits(cond, "message")) {
[17:38:09.486]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:09.486]                       if (muffled) 
[17:38:09.486]                         invokeRestart("muffleMessage")
[17:38:09.486]                     }
[17:38:09.486]                     else if (inherits(cond, "warning")) {
[17:38:09.486]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:09.486]                       if (muffled) 
[17:38:09.486]                         invokeRestart("muffleWarning")
[17:38:09.486]                     }
[17:38:09.486]                     else if (inherits(cond, "condition")) {
[17:38:09.486]                       if (!is.null(pattern)) {
[17:38:09.486]                         computeRestarts <- base::computeRestarts
[17:38:09.486]                         grepl <- base::grepl
[17:38:09.486]                         restarts <- computeRestarts(cond)
[17:38:09.486]                         for (restart in restarts) {
[17:38:09.486]                           name <- restart$name
[17:38:09.486]                           if (is.null(name)) 
[17:38:09.486]                             next
[17:38:09.486]                           if (!grepl(pattern, name)) 
[17:38:09.486]                             next
[17:38:09.486]                           invokeRestart(restart)
[17:38:09.486]                           muffled <- TRUE
[17:38:09.486]                           break
[17:38:09.486]                         }
[17:38:09.486]                       }
[17:38:09.486]                     }
[17:38:09.486]                     invisible(muffled)
[17:38:09.486]                   }
[17:38:09.486]                   muffleCondition(cond)
[17:38:09.486]                 })
[17:38:09.486]             }))
[17:38:09.486]             future::FutureResult(value = ...future.value$value, 
[17:38:09.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.486]                   ...future.rng), globalenv = if (FALSE) 
[17:38:09.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:09.486]                     ...future.globalenv.names))
[17:38:09.486]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:09.486]         }, condition = base::local({
[17:38:09.486]             c <- base::c
[17:38:09.486]             inherits <- base::inherits
[17:38:09.486]             invokeRestart <- base::invokeRestart
[17:38:09.486]             length <- base::length
[17:38:09.486]             list <- base::list
[17:38:09.486]             seq.int <- base::seq.int
[17:38:09.486]             signalCondition <- base::signalCondition
[17:38:09.486]             sys.calls <- base::sys.calls
[17:38:09.486]             `[[` <- base::`[[`
[17:38:09.486]             `+` <- base::`+`
[17:38:09.486]             `<<-` <- base::`<<-`
[17:38:09.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:09.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:09.486]                   3L)]
[17:38:09.486]             }
[17:38:09.486]             function(cond) {
[17:38:09.486]                 is_error <- inherits(cond, "error")
[17:38:09.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:09.486]                   NULL)
[17:38:09.486]                 if (is_error) {
[17:38:09.486]                   sessionInformation <- function() {
[17:38:09.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:09.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:09.486]                       search = base::search(), system = base::Sys.info())
[17:38:09.486]                   }
[17:38:09.486]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:09.486]                     cond$call), session = sessionInformation(), 
[17:38:09.486]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:09.486]                   signalCondition(cond)
[17:38:09.486]                 }
[17:38:09.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:09.486]                 "immediateCondition"))) {
[17:38:09.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:09.486]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:09.486]                   if (TRUE && !signal) {
[17:38:09.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.486]                     {
[17:38:09.486]                       inherits <- base::inherits
[17:38:09.486]                       invokeRestart <- base::invokeRestart
[17:38:09.486]                       is.null <- base::is.null
[17:38:09.486]                       muffled <- FALSE
[17:38:09.486]                       if (inherits(cond, "message")) {
[17:38:09.486]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.486]                         if (muffled) 
[17:38:09.486]                           invokeRestart("muffleMessage")
[17:38:09.486]                       }
[17:38:09.486]                       else if (inherits(cond, "warning")) {
[17:38:09.486]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.486]                         if (muffled) 
[17:38:09.486]                           invokeRestart("muffleWarning")
[17:38:09.486]                       }
[17:38:09.486]                       else if (inherits(cond, "condition")) {
[17:38:09.486]                         if (!is.null(pattern)) {
[17:38:09.486]                           computeRestarts <- base::computeRestarts
[17:38:09.486]                           grepl <- base::grepl
[17:38:09.486]                           restarts <- computeRestarts(cond)
[17:38:09.486]                           for (restart in restarts) {
[17:38:09.486]                             name <- restart$name
[17:38:09.486]                             if (is.null(name)) 
[17:38:09.486]                               next
[17:38:09.486]                             if (!grepl(pattern, name)) 
[17:38:09.486]                               next
[17:38:09.486]                             invokeRestart(restart)
[17:38:09.486]                             muffled <- TRUE
[17:38:09.486]                             break
[17:38:09.486]                           }
[17:38:09.486]                         }
[17:38:09.486]                       }
[17:38:09.486]                       invisible(muffled)
[17:38:09.486]                     }
[17:38:09.486]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.486]                   }
[17:38:09.486]                 }
[17:38:09.486]                 else {
[17:38:09.486]                   if (TRUE) {
[17:38:09.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.486]                     {
[17:38:09.486]                       inherits <- base::inherits
[17:38:09.486]                       invokeRestart <- base::invokeRestart
[17:38:09.486]                       is.null <- base::is.null
[17:38:09.486]                       muffled <- FALSE
[17:38:09.486]                       if (inherits(cond, "message")) {
[17:38:09.486]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.486]                         if (muffled) 
[17:38:09.486]                           invokeRestart("muffleMessage")
[17:38:09.486]                       }
[17:38:09.486]                       else if (inherits(cond, "warning")) {
[17:38:09.486]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.486]                         if (muffled) 
[17:38:09.486]                           invokeRestart("muffleWarning")
[17:38:09.486]                       }
[17:38:09.486]                       else if (inherits(cond, "condition")) {
[17:38:09.486]                         if (!is.null(pattern)) {
[17:38:09.486]                           computeRestarts <- base::computeRestarts
[17:38:09.486]                           grepl <- base::grepl
[17:38:09.486]                           restarts <- computeRestarts(cond)
[17:38:09.486]                           for (restart in restarts) {
[17:38:09.486]                             name <- restart$name
[17:38:09.486]                             if (is.null(name)) 
[17:38:09.486]                               next
[17:38:09.486]                             if (!grepl(pattern, name)) 
[17:38:09.486]                               next
[17:38:09.486]                             invokeRestart(restart)
[17:38:09.486]                             muffled <- TRUE
[17:38:09.486]                             break
[17:38:09.486]                           }
[17:38:09.486]                         }
[17:38:09.486]                       }
[17:38:09.486]                       invisible(muffled)
[17:38:09.486]                     }
[17:38:09.486]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.486]                   }
[17:38:09.486]                 }
[17:38:09.486]             }
[17:38:09.486]         }))
[17:38:09.486]     }, error = function(ex) {
[17:38:09.486]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:09.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.486]                 ...future.rng), started = ...future.startTime, 
[17:38:09.486]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:09.486]             version = "1.8"), class = "FutureResult")
[17:38:09.486]     }, finally = {
[17:38:09.486]         if (!identical(...future.workdir, getwd())) 
[17:38:09.486]             setwd(...future.workdir)
[17:38:09.486]         {
[17:38:09.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:09.486]                 ...future.oldOptions$nwarnings <- NULL
[17:38:09.486]             }
[17:38:09.486]             base::options(...future.oldOptions)
[17:38:09.486]             if (.Platform$OS.type == "windows") {
[17:38:09.486]                 old_names <- names(...future.oldEnvVars)
[17:38:09.486]                 envs <- base::Sys.getenv()
[17:38:09.486]                 names <- names(envs)
[17:38:09.486]                 common <- intersect(names, old_names)
[17:38:09.486]                 added <- setdiff(names, old_names)
[17:38:09.486]                 removed <- setdiff(old_names, names)
[17:38:09.486]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:09.486]                   envs[common]]
[17:38:09.486]                 NAMES <- toupper(changed)
[17:38:09.486]                 args <- list()
[17:38:09.486]                 for (kk in seq_along(NAMES)) {
[17:38:09.486]                   name <- changed[[kk]]
[17:38:09.486]                   NAME <- NAMES[[kk]]
[17:38:09.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.486]                     next
[17:38:09.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.486]                 }
[17:38:09.486]                 NAMES <- toupper(added)
[17:38:09.486]                 for (kk in seq_along(NAMES)) {
[17:38:09.486]                   name <- added[[kk]]
[17:38:09.486]                   NAME <- NAMES[[kk]]
[17:38:09.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.486]                     next
[17:38:09.486]                   args[[name]] <- ""
[17:38:09.486]                 }
[17:38:09.486]                 NAMES <- toupper(removed)
[17:38:09.486]                 for (kk in seq_along(NAMES)) {
[17:38:09.486]                   name <- removed[[kk]]
[17:38:09.486]                   NAME <- NAMES[[kk]]
[17:38:09.486]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.486]                     next
[17:38:09.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.486]                 }
[17:38:09.486]                 if (length(args) > 0) 
[17:38:09.486]                   base::do.call(base::Sys.setenv, args = args)
[17:38:09.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:09.486]             }
[17:38:09.486]             else {
[17:38:09.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:09.486]             }
[17:38:09.486]             {
[17:38:09.486]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:09.486]                   0L) {
[17:38:09.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:09.486]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:09.486]                   base::options(opts)
[17:38:09.486]                 }
[17:38:09.486]                 {
[17:38:09.486]                   {
[17:38:09.486]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:09.486]                     NULL
[17:38:09.486]                   }
[17:38:09.486]                   options(future.plan = NULL)
[17:38:09.486]                   if (is.na(NA_character_)) 
[17:38:09.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:09.486]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:09.486]                     .init = FALSE)
[17:38:09.486]                 }
[17:38:09.486]             }
[17:38:09.486]         }
[17:38:09.486]     })
[17:38:09.486]     if (TRUE) {
[17:38:09.486]         base::sink(type = "output", split = FALSE)
[17:38:09.486]         if (TRUE) {
[17:38:09.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:09.486]         }
[17:38:09.486]         else {
[17:38:09.486]             ...future.result["stdout"] <- base::list(NULL)
[17:38:09.486]         }
[17:38:09.486]         base::close(...future.stdout)
[17:38:09.486]         ...future.stdout <- NULL
[17:38:09.486]     }
[17:38:09.486]     ...future.result$conditions <- ...future.conditions
[17:38:09.486]     ...future.result$finished <- base::Sys.time()
[17:38:09.486]     ...future.result
[17:38:09.486] }
[17:38:09.489] assign_globals() ...
[17:38:09.489] List of 11
[17:38:09.489]  $ ...future.FUN            :function (x, ...)  
[17:38:09.489]  $ x_FUN                    :function (x)  
[17:38:09.489]  $ times                    : int 2
[17:38:09.489]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:09.489]  $ stop_if_not              :function (...)  
[17:38:09.489]  $ dim                      : NULL
[17:38:09.489]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:09.489]  $ future.call.arguments    : list()
[17:38:09.489]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.489]  $ ...future.elements_ii    :List of 1
[17:38:09.489]   ..$ : int 1
[17:38:09.489]  $ ...future.seeds_ii       : NULL
[17:38:09.489]  $ ...future.globals.maxSize: NULL
[17:38:09.489]  - attr(*, "where")=List of 11
[17:38:09.489]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:09.489]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:09.489]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:09.489]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:09.489]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:09.489]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:09.489]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:09.489]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:09.489]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:09.489]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:09.489]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:09.489]  - attr(*, "resolved")= logi FALSE
[17:38:09.489]  - attr(*, "total_size")= num 95128
[17:38:09.489]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.489]  - attr(*, "already-done")= logi TRUE
[17:38:09.500] - copied ‘...future.FUN’ to environment
[17:38:09.500] - copied ‘x_FUN’ to environment
[17:38:09.500] - copied ‘times’ to environment
[17:38:09.500] - copied ‘stopf’ to environment
[17:38:09.500] - copied ‘stop_if_not’ to environment
[17:38:09.500] - copied ‘dim’ to environment
[17:38:09.500] - copied ‘valid_types’ to environment
[17:38:09.501] - copied ‘future.call.arguments’ to environment
[17:38:09.501] - copied ‘...future.elements_ii’ to environment
[17:38:09.501] - copied ‘...future.seeds_ii’ to environment
[17:38:09.501] - copied ‘...future.globals.maxSize’ to environment
[17:38:09.501] assign_globals() ... done
[17:38:09.501] requestCore(): workers = 2
[17:38:09.504] MulticoreFuture started
[17:38:09.504] - Launch lazy future ... done
[17:38:09.505] run() for ‘MulticoreFuture’ ... done
[17:38:09.505] Created future:
[17:38:09.506] plan(): Setting new future strategy stack:
[17:38:09.506] List of future strategies:
[17:38:09.506] 1. sequential:
[17:38:09.506]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:09.506]    - tweaked: FALSE
[17:38:09.506]    - call: NULL
[17:38:09.508] plan(): nbrOfWorkers() = 1
[17:38:09.511] plan(): Setting new future strategy stack:
[17:38:09.512] List of future strategies:
[17:38:09.512] 1. multicore:
[17:38:09.512]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:09.512]    - tweaked: FALSE
[17:38:09.512]    - call: plan(strategy)
[17:38:09.518] plan(): nbrOfWorkers() = 2
[17:38:09.506] MulticoreFuture:
[17:38:09.506] Label: ‘future_vapply-1’
[17:38:09.506] Expression:
[17:38:09.506] {
[17:38:09.506]     do.call(function(...) {
[17:38:09.506]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.506]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.506]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.506]             on.exit(options(oopts), add = TRUE)
[17:38:09.506]         }
[17:38:09.506]         {
[17:38:09.506]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.506]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.506]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.506]             })
[17:38:09.506]         }
[17:38:09.506]     }, args = future.call.arguments)
[17:38:09.506] }
[17:38:09.506] Lazy evaluation: FALSE
[17:38:09.506] Asynchronous evaluation: TRUE
[17:38:09.506] Local evaluation: TRUE
[17:38:09.506] Environment: R_GlobalEnv
[17:38:09.506] Capture standard output: TRUE
[17:38:09.506] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:09.506] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:09.506] Packages: 1 packages (‘future.apply’)
[17:38:09.506] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:09.506] Resolved: FALSE
[17:38:09.506] Value: <not collected>
[17:38:09.506] Conditions captured: <none>
[17:38:09.506] Early signaling: FALSE
[17:38:09.506] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:09.506] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.521] Chunk #1 of 2 ... DONE
[17:38:09.521] Chunk #2 of 2 ...
[17:38:09.522]  - Finding globals in 'X' for chunk #2 ...
[17:38:09.522] getGlobalsAndPackages() ...
[17:38:09.522] Searching for globals...
[17:38:09.523] 
[17:38:09.523] Searching for globals ... DONE
[17:38:09.523] - globals: [0] <none>
[17:38:09.523] getGlobalsAndPackages() ... DONE
[17:38:09.523]    + additional globals found: [n=0] 
[17:38:09.523]    + additional namespaces needed: [n=0] 
[17:38:09.524]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:09.524]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:09.524]  - seeds: <none>
[17:38:09.524]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.524] getGlobalsAndPackages() ...
[17:38:09.524] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.525] Resolving globals: FALSE
[17:38:09.525] Tweak future expression to call with '...' arguments ...
[17:38:09.525] {
[17:38:09.525]     do.call(function(...) {
[17:38:09.525]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.525]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.525]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.525]             on.exit(options(oopts), add = TRUE)
[17:38:09.525]         }
[17:38:09.525]         {
[17:38:09.525]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.525]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.525]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.525]             })
[17:38:09.525]         }
[17:38:09.525]     }, args = future.call.arguments)
[17:38:09.525] }
[17:38:09.525] Tweak future expression to call with '...' arguments ... DONE
[17:38:09.526] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:09.526] - packages: [1] ‘future.apply’
[17:38:09.527] getGlobalsAndPackages() ... DONE
[17:38:09.527] run() for ‘Future’ ...
[17:38:09.527] - state: ‘created’
[17:38:09.527] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:38:09.532] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.532] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:38:09.532]   - Field: ‘label’
[17:38:09.533]   - Field: ‘local’
[17:38:09.533]   - Field: ‘owner’
[17:38:09.533]   - Field: ‘envir’
[17:38:09.533]   - Field: ‘workers’
[17:38:09.533]   - Field: ‘packages’
[17:38:09.533]   - Field: ‘gc’
[17:38:09.533]   - Field: ‘job’
[17:38:09.533]   - Field: ‘conditions’
[17:38:09.534]   - Field: ‘expr’
[17:38:09.534]   - Field: ‘uuid’
[17:38:09.534]   - Field: ‘seed’
[17:38:09.534]   - Field: ‘version’
[17:38:09.534]   - Field: ‘result’
[17:38:09.534]   - Field: ‘asynchronous’
[17:38:09.534]   - Field: ‘calls’
[17:38:09.535]   - Field: ‘globals’
[17:38:09.535]   - Field: ‘stdout’
[17:38:09.535]   - Field: ‘earlySignal’
[17:38:09.535]   - Field: ‘lazy’
[17:38:09.535]   - Field: ‘state’
[17:38:09.535] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:38:09.535] - Launch lazy future ...
[17:38:09.536] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:09.536] Packages needed by future strategies (n = 0): <none>
[17:38:09.537] {
[17:38:09.537]     {
[17:38:09.537]         {
[17:38:09.537]             ...future.startTime <- base::Sys.time()
[17:38:09.537]             {
[17:38:09.537]                 {
[17:38:09.537]                   {
[17:38:09.537]                     {
[17:38:09.537]                       {
[17:38:09.537]                         base::local({
[17:38:09.537]                           has_future <- base::requireNamespace("future", 
[17:38:09.537]                             quietly = TRUE)
[17:38:09.537]                           if (has_future) {
[17:38:09.537]                             ns <- base::getNamespace("future")
[17:38:09.537]                             version <- ns[[".package"]][["version"]]
[17:38:09.537]                             if (is.null(version)) 
[17:38:09.537]                               version <- utils::packageVersion("future")
[17:38:09.537]                           }
[17:38:09.537]                           else {
[17:38:09.537]                             version <- NULL
[17:38:09.537]                           }
[17:38:09.537]                           if (!has_future || version < "1.8.0") {
[17:38:09.537]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:09.537]                               "", base::R.version$version.string), 
[17:38:09.537]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:09.537]                                 base::R.version$platform, 8 * 
[17:38:09.537]                                   base::.Machine$sizeof.pointer), 
[17:38:09.537]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:09.537]                                 "release", "version")], collapse = " "), 
[17:38:09.537]                               hostname = base::Sys.info()[["nodename"]])
[17:38:09.537]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:09.537]                               info)
[17:38:09.537]                             info <- base::paste(info, collapse = "; ")
[17:38:09.537]                             if (!has_future) {
[17:38:09.537]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:09.537]                                 info)
[17:38:09.537]                             }
[17:38:09.537]                             else {
[17:38:09.537]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:09.537]                                 info, version)
[17:38:09.537]                             }
[17:38:09.537]                             base::stop(msg)
[17:38:09.537]                           }
[17:38:09.537]                         })
[17:38:09.537]                       }
[17:38:09.537]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:09.537]                       base::options(mc.cores = 1L)
[17:38:09.537]                     }
[17:38:09.537]                     base::local({
[17:38:09.537]                       for (pkg in "future.apply") {
[17:38:09.537]                         base::loadNamespace(pkg)
[17:38:09.537]                         base::library(pkg, character.only = TRUE)
[17:38:09.537]                       }
[17:38:09.537]                     })
[17:38:09.537]                   }
[17:38:09.537]                   ...future.strategy.old <- future::plan("list")
[17:38:09.537]                   options(future.plan = NULL)
[17:38:09.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:09.537]                 }
[17:38:09.537]                 ...future.workdir <- getwd()
[17:38:09.537]             }
[17:38:09.537]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:09.537]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:09.537]         }
[17:38:09.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:09.537]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:09.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:09.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:09.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:09.537]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:09.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:09.537]             base::names(...future.oldOptions))
[17:38:09.537]     }
[17:38:09.537]     if (FALSE) {
[17:38:09.537]     }
[17:38:09.537]     else {
[17:38:09.537]         if (TRUE) {
[17:38:09.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:09.537]                 open = "w")
[17:38:09.537]         }
[17:38:09.537]         else {
[17:38:09.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:09.537]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:09.537]         }
[17:38:09.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:09.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:09.537]             base::sink(type = "output", split = FALSE)
[17:38:09.537]             base::close(...future.stdout)
[17:38:09.537]         }, add = TRUE)
[17:38:09.537]     }
[17:38:09.537]     ...future.frame <- base::sys.nframe()
[17:38:09.537]     ...future.conditions <- base::list()
[17:38:09.537]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:09.537]     if (FALSE) {
[17:38:09.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:09.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:09.537]     }
[17:38:09.537]     ...future.result <- base::tryCatch({
[17:38:09.537]         base::withCallingHandlers({
[17:38:09.537]             ...future.value <- base::withVisible(base::local({
[17:38:09.537]                 withCallingHandlers({
[17:38:09.537]                   {
[17:38:09.537]                     do.call(function(...) {
[17:38:09.537]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.537]                       if (!identical(...future.globals.maxSize.org, 
[17:38:09.537]                         ...future.globals.maxSize)) {
[17:38:09.537]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.537]                         on.exit(options(oopts), add = TRUE)
[17:38:09.537]                       }
[17:38:09.537]                       {
[17:38:09.537]                         lapply(seq_along(...future.elements_ii), 
[17:38:09.537]                           FUN = function(jj) {
[17:38:09.537]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.537]                             ...future.FUN(...future.X_jj, ...)
[17:38:09.537]                           })
[17:38:09.537]                       }
[17:38:09.537]                     }, args = future.call.arguments)
[17:38:09.537]                   }
[17:38:09.537]                 }, immediateCondition = function(cond) {
[17:38:09.537]                   save_rds <- function (object, pathname, ...) 
[17:38:09.537]                   {
[17:38:09.537]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:38:09.537]                     if (file_test("-f", pathname_tmp)) {
[17:38:09.537]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.537]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:38:09.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.537]                         fi_tmp[["mtime"]])
[17:38:09.537]                     }
[17:38:09.537]                     tryCatch({
[17:38:09.537]                       saveRDS(object, file = pathname_tmp, ...)
[17:38:09.537]                     }, error = function(ex) {
[17:38:09.537]                       msg <- conditionMessage(ex)
[17:38:09.537]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.537]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:38:09.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.537]                         fi_tmp[["mtime"]], msg)
[17:38:09.537]                       ex$message <- msg
[17:38:09.537]                       stop(ex)
[17:38:09.537]                     })
[17:38:09.537]                     stopifnot(file_test("-f", pathname_tmp))
[17:38:09.537]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:38:09.537]                     if (!res || file_test("-f", pathname_tmp)) {
[17:38:09.537]                       fi_tmp <- file.info(pathname_tmp)
[17:38:09.537]                       fi <- file.info(pathname)
[17:38:09.537]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:38:09.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:38:09.537]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:38:09.537]                         fi[["size"]], fi[["mtime"]])
[17:38:09.537]                       stop(msg)
[17:38:09.537]                     }
[17:38:09.537]                     invisible(pathname)
[17:38:09.537]                   }
[17:38:09.537]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:38:09.537]                     rootPath = tempdir()) 
[17:38:09.537]                   {
[17:38:09.537]                     obj <- list(time = Sys.time(), condition = cond)
[17:38:09.537]                     file <- tempfile(pattern = class(cond)[1], 
[17:38:09.537]                       tmpdir = path, fileext = ".rds")
[17:38:09.537]                     save_rds(obj, file)
[17:38:09.537]                   }
[17:38:09.537]                   saveImmediateCondition(cond, path = "/tmp/RtmpNIHBlX/.future/immediateConditions")
[17:38:09.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.537]                   {
[17:38:09.537]                     inherits <- base::inherits
[17:38:09.537]                     invokeRestart <- base::invokeRestart
[17:38:09.537]                     is.null <- base::is.null
[17:38:09.537]                     muffled <- FALSE
[17:38:09.537]                     if (inherits(cond, "message")) {
[17:38:09.537]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:09.537]                       if (muffled) 
[17:38:09.537]                         invokeRestart("muffleMessage")
[17:38:09.537]                     }
[17:38:09.537]                     else if (inherits(cond, "warning")) {
[17:38:09.537]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:09.537]                       if (muffled) 
[17:38:09.537]                         invokeRestart("muffleWarning")
[17:38:09.537]                     }
[17:38:09.537]                     else if (inherits(cond, "condition")) {
[17:38:09.537]                       if (!is.null(pattern)) {
[17:38:09.537]                         computeRestarts <- base::computeRestarts
[17:38:09.537]                         grepl <- base::grepl
[17:38:09.537]                         restarts <- computeRestarts(cond)
[17:38:09.537]                         for (restart in restarts) {
[17:38:09.537]                           name <- restart$name
[17:38:09.537]                           if (is.null(name)) 
[17:38:09.537]                             next
[17:38:09.537]                           if (!grepl(pattern, name)) 
[17:38:09.537]                             next
[17:38:09.537]                           invokeRestart(restart)
[17:38:09.537]                           muffled <- TRUE
[17:38:09.537]                           break
[17:38:09.537]                         }
[17:38:09.537]                       }
[17:38:09.537]                     }
[17:38:09.537]                     invisible(muffled)
[17:38:09.537]                   }
[17:38:09.537]                   muffleCondition(cond)
[17:38:09.537]                 })
[17:38:09.537]             }))
[17:38:09.537]             future::FutureResult(value = ...future.value$value, 
[17:38:09.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.537]                   ...future.rng), globalenv = if (FALSE) 
[17:38:09.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:09.537]                     ...future.globalenv.names))
[17:38:09.537]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:09.537]         }, condition = base::local({
[17:38:09.537]             c <- base::c
[17:38:09.537]             inherits <- base::inherits
[17:38:09.537]             invokeRestart <- base::invokeRestart
[17:38:09.537]             length <- base::length
[17:38:09.537]             list <- base::list
[17:38:09.537]             seq.int <- base::seq.int
[17:38:09.537]             signalCondition <- base::signalCondition
[17:38:09.537]             sys.calls <- base::sys.calls
[17:38:09.537]             `[[` <- base::`[[`
[17:38:09.537]             `+` <- base::`+`
[17:38:09.537]             `<<-` <- base::`<<-`
[17:38:09.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:09.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:09.537]                   3L)]
[17:38:09.537]             }
[17:38:09.537]             function(cond) {
[17:38:09.537]                 is_error <- inherits(cond, "error")
[17:38:09.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:09.537]                   NULL)
[17:38:09.537]                 if (is_error) {
[17:38:09.537]                   sessionInformation <- function() {
[17:38:09.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:09.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:09.537]                       search = base::search(), system = base::Sys.info())
[17:38:09.537]                   }
[17:38:09.537]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:09.537]                     cond$call), session = sessionInformation(), 
[17:38:09.537]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:09.537]                   signalCondition(cond)
[17:38:09.537]                 }
[17:38:09.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:09.537]                 "immediateCondition"))) {
[17:38:09.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:09.537]                   ...future.conditions[[length(...future.conditions) + 
[17:38:09.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:09.537]                   if (TRUE && !signal) {
[17:38:09.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.537]                     {
[17:38:09.537]                       inherits <- base::inherits
[17:38:09.537]                       invokeRestart <- base::invokeRestart
[17:38:09.537]                       is.null <- base::is.null
[17:38:09.537]                       muffled <- FALSE
[17:38:09.537]                       if (inherits(cond, "message")) {
[17:38:09.537]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.537]                         if (muffled) 
[17:38:09.537]                           invokeRestart("muffleMessage")
[17:38:09.537]                       }
[17:38:09.537]                       else if (inherits(cond, "warning")) {
[17:38:09.537]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.537]                         if (muffled) 
[17:38:09.537]                           invokeRestart("muffleWarning")
[17:38:09.537]                       }
[17:38:09.537]                       else if (inherits(cond, "condition")) {
[17:38:09.537]                         if (!is.null(pattern)) {
[17:38:09.537]                           computeRestarts <- base::computeRestarts
[17:38:09.537]                           grepl <- base::grepl
[17:38:09.537]                           restarts <- computeRestarts(cond)
[17:38:09.537]                           for (restart in restarts) {
[17:38:09.537]                             name <- restart$name
[17:38:09.537]                             if (is.null(name)) 
[17:38:09.537]                               next
[17:38:09.537]                             if (!grepl(pattern, name)) 
[17:38:09.537]                               next
[17:38:09.537]                             invokeRestart(restart)
[17:38:09.537]                             muffled <- TRUE
[17:38:09.537]                             break
[17:38:09.537]                           }
[17:38:09.537]                         }
[17:38:09.537]                       }
[17:38:09.537]                       invisible(muffled)
[17:38:09.537]                     }
[17:38:09.537]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.537]                   }
[17:38:09.537]                 }
[17:38:09.537]                 else {
[17:38:09.537]                   if (TRUE) {
[17:38:09.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:09.537]                     {
[17:38:09.537]                       inherits <- base::inherits
[17:38:09.537]                       invokeRestart <- base::invokeRestart
[17:38:09.537]                       is.null <- base::is.null
[17:38:09.537]                       muffled <- FALSE
[17:38:09.537]                       if (inherits(cond, "message")) {
[17:38:09.537]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:09.537]                         if (muffled) 
[17:38:09.537]                           invokeRestart("muffleMessage")
[17:38:09.537]                       }
[17:38:09.537]                       else if (inherits(cond, "warning")) {
[17:38:09.537]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:09.537]                         if (muffled) 
[17:38:09.537]                           invokeRestart("muffleWarning")
[17:38:09.537]                       }
[17:38:09.537]                       else if (inherits(cond, "condition")) {
[17:38:09.537]                         if (!is.null(pattern)) {
[17:38:09.537]                           computeRestarts <- base::computeRestarts
[17:38:09.537]                           grepl <- base::grepl
[17:38:09.537]                           restarts <- computeRestarts(cond)
[17:38:09.537]                           for (restart in restarts) {
[17:38:09.537]                             name <- restart$name
[17:38:09.537]                             if (is.null(name)) 
[17:38:09.537]                               next
[17:38:09.537]                             if (!grepl(pattern, name)) 
[17:38:09.537]                               next
[17:38:09.537]                             invokeRestart(restart)
[17:38:09.537]                             muffled <- TRUE
[17:38:09.537]                             break
[17:38:09.537]                           }
[17:38:09.537]                         }
[17:38:09.537]                       }
[17:38:09.537]                       invisible(muffled)
[17:38:09.537]                     }
[17:38:09.537]                     muffleCondition(cond, pattern = "^muffle")
[17:38:09.537]                   }
[17:38:09.537]                 }
[17:38:09.537]             }
[17:38:09.537]         }))
[17:38:09.537]     }, error = function(ex) {
[17:38:09.537]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:09.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:09.537]                 ...future.rng), started = ...future.startTime, 
[17:38:09.537]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:09.537]             version = "1.8"), class = "FutureResult")
[17:38:09.537]     }, finally = {
[17:38:09.537]         if (!identical(...future.workdir, getwd())) 
[17:38:09.537]             setwd(...future.workdir)
[17:38:09.537]         {
[17:38:09.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:09.537]                 ...future.oldOptions$nwarnings <- NULL
[17:38:09.537]             }
[17:38:09.537]             base::options(...future.oldOptions)
[17:38:09.537]             if (.Platform$OS.type == "windows") {
[17:38:09.537]                 old_names <- names(...future.oldEnvVars)
[17:38:09.537]                 envs <- base::Sys.getenv()
[17:38:09.537]                 names <- names(envs)
[17:38:09.537]                 common <- intersect(names, old_names)
[17:38:09.537]                 added <- setdiff(names, old_names)
[17:38:09.537]                 removed <- setdiff(old_names, names)
[17:38:09.537]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:09.537]                   envs[common]]
[17:38:09.537]                 NAMES <- toupper(changed)
[17:38:09.537]                 args <- list()
[17:38:09.537]                 for (kk in seq_along(NAMES)) {
[17:38:09.537]                   name <- changed[[kk]]
[17:38:09.537]                   NAME <- NAMES[[kk]]
[17:38:09.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.537]                     next
[17:38:09.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.537]                 }
[17:38:09.537]                 NAMES <- toupper(added)
[17:38:09.537]                 for (kk in seq_along(NAMES)) {
[17:38:09.537]                   name <- added[[kk]]
[17:38:09.537]                   NAME <- NAMES[[kk]]
[17:38:09.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.537]                     next
[17:38:09.537]                   args[[name]] <- ""
[17:38:09.537]                 }
[17:38:09.537]                 NAMES <- toupper(removed)
[17:38:09.537]                 for (kk in seq_along(NAMES)) {
[17:38:09.537]                   name <- removed[[kk]]
[17:38:09.537]                   NAME <- NAMES[[kk]]
[17:38:09.537]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:09.537]                     next
[17:38:09.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:09.537]                 }
[17:38:09.537]                 if (length(args) > 0) 
[17:38:09.537]                   base::do.call(base::Sys.setenv, args = args)
[17:38:09.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:09.537]             }
[17:38:09.537]             else {
[17:38:09.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:09.537]             }
[17:38:09.537]             {
[17:38:09.537]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:09.537]                   0L) {
[17:38:09.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:09.537]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:09.537]                   base::options(opts)
[17:38:09.537]                 }
[17:38:09.537]                 {
[17:38:09.537]                   {
[17:38:09.537]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:09.537]                     NULL
[17:38:09.537]                   }
[17:38:09.537]                   options(future.plan = NULL)
[17:38:09.537]                   if (is.na(NA_character_)) 
[17:38:09.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:09.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:09.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:09.537]                     .init = FALSE)
[17:38:09.537]                 }
[17:38:09.537]             }
[17:38:09.537]         }
[17:38:09.537]     })
[17:38:09.537]     if (TRUE) {
[17:38:09.537]         base::sink(type = "output", split = FALSE)
[17:38:09.537]         if (TRUE) {
[17:38:09.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:09.537]         }
[17:38:09.537]         else {
[17:38:09.537]             ...future.result["stdout"] <- base::list(NULL)
[17:38:09.537]         }
[17:38:09.537]         base::close(...future.stdout)
[17:38:09.537]         ...future.stdout <- NULL
[17:38:09.537]     }
[17:38:09.537]     ...future.result$conditions <- ...future.conditions
[17:38:09.537]     ...future.result$finished <- base::Sys.time()
[17:38:09.537]     ...future.result
[17:38:09.537] }
[17:38:09.540] assign_globals() ...
[17:38:09.540] List of 11
[17:38:09.540]  $ ...future.FUN            :function (x, ...)  
[17:38:09.540]  $ x_FUN                    :function (x)  
[17:38:09.540]  $ times                    : int 2
[17:38:09.540]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:09.540]  $ stop_if_not              :function (...)  
[17:38:09.540]  $ dim                      : NULL
[17:38:09.540]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:38:09.540]  $ future.call.arguments    : list()
[17:38:09.540]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:09.540]  $ ...future.elements_ii    :List of 2
[17:38:09.540]   ..$ : int 2
[17:38:09.540]   ..$ : int 3
[17:38:09.540]  $ ...future.seeds_ii       : NULL
[17:38:09.540]  $ ...future.globals.maxSize: NULL
[17:38:09.540]  - attr(*, "where")=List of 11
[17:38:09.540]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:38:09.540]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:38:09.540]   ..$ times                    :<environment: R_EmptyEnv> 
[17:38:09.540]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:38:09.540]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:38:09.540]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:38:09.540]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:38:09.540]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:38:09.540]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:38:09.540]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:38:09.540]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:38:09.540]  - attr(*, "resolved")= logi FALSE
[17:38:09.540]  - attr(*, "total_size")= num 95128
[17:38:09.540]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:09.540]  - attr(*, "already-done")= logi TRUE
[17:38:09.554] - copied ‘...future.FUN’ to environment
[17:38:09.555] - copied ‘x_FUN’ to environment
[17:38:09.555] - copied ‘times’ to environment
[17:38:09.555] - copied ‘stopf’ to environment
[17:38:09.555] - copied ‘stop_if_not’ to environment
[17:38:09.555] - copied ‘dim’ to environment
[17:38:09.555] - copied ‘valid_types’ to environment
[17:38:09.555] - copied ‘future.call.arguments’ to environment
[17:38:09.556] - copied ‘...future.elements_ii’ to environment
[17:38:09.556] - copied ‘...future.seeds_ii’ to environment
[17:38:09.556] - copied ‘...future.globals.maxSize’ to environment
[17:38:09.556] assign_globals() ... done
[17:38:09.556] requestCore(): workers = 2
[17:38:09.559] MulticoreFuture started
[17:38:09.559] - Launch lazy future ... done
[17:38:09.560] run() for ‘MulticoreFuture’ ... done
[17:38:09.561] Created future:
[17:38:09.561] plan(): Setting new future strategy stack:
[17:38:09.561] List of future strategies:
[17:38:09.561] 1. sequential:
[17:38:09.561]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:09.561]    - tweaked: FALSE
[17:38:09.561]    - call: NULL
[17:38:09.563] plan(): nbrOfWorkers() = 1
[17:38:09.565] plan(): Setting new future strategy stack:
[17:38:09.565] List of future strategies:
[17:38:09.565] 1. multicore:
[17:38:09.565]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:38:09.565]    - tweaked: FALSE
[17:38:09.565]    - call: plan(strategy)
[17:38:09.571] plan(): nbrOfWorkers() = 2
[17:38:09.561] MulticoreFuture:
[17:38:09.561] Label: ‘future_vapply-2’
[17:38:09.561] Expression:
[17:38:09.561] {
[17:38:09.561]     do.call(function(...) {
[17:38:09.561]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:09.561]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:09.561]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:09.561]             on.exit(options(oopts), add = TRUE)
[17:38:09.561]         }
[17:38:09.561]         {
[17:38:09.561]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:09.561]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:09.561]                 ...future.FUN(...future.X_jj, ...)
[17:38:09.561]             })
[17:38:09.561]         }
[17:38:09.561]     }, args = future.call.arguments)
[17:38:09.561] }
[17:38:09.561] Lazy evaluation: FALSE
[17:38:09.561] Asynchronous evaluation: TRUE
[17:38:09.561] Local evaluation: TRUE
[17:38:09.561] Environment: R_GlobalEnv
[17:38:09.561] Capture standard output: TRUE
[17:38:09.561] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:09.561] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:09.561] Packages: 1 packages (‘future.apply’)
[17:38:09.561] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:09.561] Resolved: FALSE
[17:38:09.561] Value: <not collected>
[17:38:09.561] Conditions captured: <none>
[17:38:09.561] Early signaling: FALSE
[17:38:09.561] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:09.561] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:09.575] Chunk #2 of 2 ... DONE
[17:38:09.575] Launching 2 futures (chunks) ... DONE
[17:38:09.575] Resolving 2 futures (chunks) ...
[17:38:09.575] resolve() on list ...
[17:38:09.575]  recursive: 0
[17:38:09.575]  length: 2
[17:38:09.576] 
[17:38:09.576] Future #1
[17:38:09.576] result() for MulticoreFuture ...
[17:38:09.583] result() for MulticoreFuture ...
[17:38:09.583] result() for MulticoreFuture ... done
[17:38:09.583] signalConditions() ...
[17:38:09.583]  - include = ‘immediateCondition’
[17:38:09.584]  - exclude = 
[17:38:09.584]  - resignal = FALSE
[17:38:09.584]  - Number of conditions: 1
[17:38:09.584] signalConditions() ... done
[17:38:09.584] result() for MulticoreFuture ... done
[17:38:09.584] result() for MulticoreFuture ...
[17:38:09.585] result() for MulticoreFuture ... done
[17:38:09.585] signalConditions() ...
[17:38:09.585]  - include = ‘immediateCondition’
[17:38:09.585]  - exclude = 
[17:38:09.585]  - resignal = FALSE
[17:38:09.585]  - Number of conditions: 1
[17:38:09.585] signalConditions() ... done
[17:38:09.586] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:38:09.586] - nx: 2
[17:38:09.586] - relay: TRUE
[17:38:09.586] - stdout: TRUE
[17:38:09.586] - signal: TRUE
[17:38:09.586] - resignal: FALSE
[17:38:09.586] - force: TRUE
[17:38:09.587] - relayed: [n=2] FALSE, FALSE
[17:38:09.587] - queued futures: [n=2] FALSE, FALSE
[17:38:09.587]  - until=1
[17:38:09.587]  - relaying element #1
[17:38:09.587] result() for MulticoreFuture ...
[17:38:09.587] result() for MulticoreFuture ... done
[17:38:09.587] result() for MulticoreFuture ...
[17:38:09.588] result() for MulticoreFuture ... done
[17:38:09.588] signalConditions() ...
[17:38:09.588]  - include = ‘immediateCondition’
[17:38:09.588]  - exclude = 
[17:38:09.588]  - resignal = FALSE
[17:38:09.588]  - Number of conditions: 1
[17:38:09.588] signalConditions() ... done
[17:38:09.589] result() for MulticoreFuture ...
[17:38:09.589] result() for MulticoreFuture ... done
[17:38:09.589] signalConditions() ...
[17:38:09.589]  - include = ‘immediateCondition’
[17:38:09.589]  - exclude = 
[17:38:09.589]  - resignal = FALSE
[17:38:09.589]  - Number of conditions: 1
[17:38:09.590] signalConditions() ... done
[17:38:09.590] result() for MulticoreFuture ...
[17:38:09.590] result() for MulticoreFuture ... done
[17:38:09.590] signalConditions() ...
[17:38:09.590]  - include = ‘condition’
[17:38:09.590]  - exclude = ‘immediateCondition’
[17:38:09.590]  - resignal = TRUE
[17:38:09.590]  - Number of conditions: 1
[17:38:09.591]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:38:09.595] signalConditions() ... done
[17:38:09.595] - relayed: [n=2] FALSE, FALSE
[17:38:09.595] - queued futures: [n=2] TRUE, FALSE
[17:38:09.595] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:38:09.596] plan(): Setting new future strategy stack:
[17:38:09.596] List of future strategies:
[17:38:09.596] 1. sequential:
[17:38:09.596]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:09.596]    - tweaked: FALSE
[17:38:09.596]    - call: plan(sequential)
[17:38:09.597] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:38:09.598] plan(): Setting new future strategy stack:
[17:38:09.598] List of future strategies:
[17:38:09.598] 1. multisession:
[17:38:09.598]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:38:09.598]    - tweaked: FALSE
[17:38:09.598]    - call: plan(strategy)
[17:38:09.599] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:38:09.599] multisession:
[17:38:09.599] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:38:09.599] - tweaked: FALSE
[17:38:09.599] - call: plan(strategy)
[17:38:09.607] getGlobalsAndPackages() ...
[17:38:09.607] Not searching for globals
[17:38:09.607] - globals: [0] <none>
[17:38:09.608] getGlobalsAndPackages() ... DONE
[17:38:09.608] [local output] makeClusterPSOCK() ...
[17:38:09.677] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:38:09.678] [local output] Base port: 11421
[17:38:09.678] [local output] Getting setup options for 2 cluster nodes ...
[17:38:09.678] [local output]  - Node 1 of 2 ...
[17:38:09.679] [local output] localMachine=TRUE => revtunnel=FALSE

[17:38:09.679] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpNIHBlX/worker.rank=1.parallelly.parent=36651.8f2b2d0cb1d.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpNIHBlX/worker.rank=1.parallelly.parent=36651.8f2b2d0cb1d.pid")'’
[17:38:09.869] - Possible to infer worker's PID: TRUE
[17:38:09.870] [local output] Rscript port: 11421

[17:38:09.870] [local output]  - Node 2 of 2 ...
[17:38:09.871] [local output] localMachine=TRUE => revtunnel=FALSE

[17:38:09.871] [local output] Rscript port: 11421

[17:38:09.871] [local output] Getting setup options for 2 cluster nodes ... done
[17:38:09.872] [local output]  - Parallel setup requested for some PSOCK nodes
[17:38:09.872] [local output] Setting up PSOCK nodes in parallel
[17:38:09.872] List of 36
[17:38:09.872]  $ worker          : chr "localhost"
[17:38:09.872]   ..- attr(*, "localhost")= logi TRUE
[17:38:09.872]  $ master          : chr "localhost"
[17:38:09.872]  $ port            : int 11421
[17:38:09.872]  $ connectTimeout  : num 120
[17:38:09.872]  $ timeout         : num 2592000
[17:38:09.872]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:38:09.872]  $ homogeneous     : logi TRUE
[17:38:09.872]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:38:09.872]  $ rscript_envs    : NULL
[17:38:09.872]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:38:09.872]  $ rscript_startup : NULL
[17:38:09.872]  $ rscript_sh      : chr "sh"
[17:38:09.872]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:38:09.872]  $ methods         : logi TRUE
[17:38:09.872]  $ socketOptions   : chr "no-delay"
[17:38:09.872]  $ useXDR          : logi FALSE
[17:38:09.872]  $ outfile         : chr "/dev/null"
[17:38:09.872]  $ renice          : int NA
[17:38:09.872]  $ rshcmd          : NULL
[17:38:09.872]  $ user            : chr(0) 
[17:38:09.872]  $ revtunnel       : logi FALSE
[17:38:09.872]  $ rshlogfile      : NULL
[17:38:09.872]  $ rshopts         : chr(0) 
[17:38:09.872]  $ rank            : int 1
[17:38:09.872]  $ manual          : logi FALSE
[17:38:09.872]  $ dryrun          : logi FALSE
[17:38:09.872]  $ quiet           : logi FALSE
[17:38:09.872]  $ setup_strategy  : chr "parallel"
[17:38:09.872]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:38:09.872]  $ pidfile         : chr "/tmp/RtmpNIHBlX/worker.rank=1.parallelly.parent=36651.8f2b2d0cb1d.pid"
[17:38:09.872]  $ rshcmd_label    : NULL
[17:38:09.872]  $ rsh_call        : NULL
[17:38:09.872]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:38:09.872]  $ localMachine    : logi TRUE
[17:38:09.872]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:38:09.872]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:38:09.872]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:38:09.872]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:38:09.872]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:38:09.872]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:38:09.872]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:38:09.872]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:38:09.872]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:38:09.872]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:38:09.872]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:38:09.872]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:38:09.872]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:38:09.872]  $ arguments       :List of 28
[17:38:09.872]   ..$ worker          : chr "localhost"
[17:38:09.872]   ..$ master          : NULL
[17:38:09.872]   ..$ port            : int 11421
[17:38:09.872]   ..$ connectTimeout  : num 120
[17:38:09.872]   ..$ timeout         : num 2592000
[17:38:09.872]   ..$ rscript         : NULL
[17:38:09.872]   ..$ homogeneous     : NULL
[17:38:09.872]   ..$ rscript_args    : NULL
[17:38:09.872]   ..$ rscript_envs    : NULL
[17:38:09.872]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:38:09.872]   ..$ rscript_startup : NULL
[17:38:09.872]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:38:09.872]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:38:09.872]   ..$ methods         : logi TRUE
[17:38:09.872]   ..$ socketOptions   : chr "no-delay"
[17:38:09.872]   ..$ useXDR          : logi FALSE
[17:38:09.872]   ..$ outfile         : chr "/dev/null"
[17:38:09.872]   ..$ renice          : int NA
[17:38:09.872]   ..$ rshcmd          : NULL
[17:38:09.872]   ..$ user            : NULL
[17:38:09.872]   ..$ revtunnel       : logi NA
[17:38:09.872]   ..$ rshlogfile      : NULL
[17:38:09.872]   ..$ rshopts         : NULL
[17:38:09.872]   ..$ rank            : int 1
[17:38:09.872]   ..$ manual          : logi FALSE
[17:38:09.872]   ..$ dryrun          : logi FALSE
[17:38:09.872]   ..$ quiet           : logi FALSE
[17:38:09.872]   ..$ setup_strategy  : chr "parallel"
[17:38:09.872]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:38:09.890] [local output] System call to launch all workers:
[17:38:09.890] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpNIHBlX/worker.rank=1.parallelly.parent=36651.8f2b2d0cb1d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11421 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:38:09.890] [local output] Starting PSOCK main server
[17:38:09.896] [local output] Workers launched
[17:38:09.896] [local output] Waiting for workers to connect back
[17:38:09.897]  - [local output] 0 workers out of 2 ready
[17:38:10.136]  - [local output] 0 workers out of 2 ready
[17:38:10.137]  - [local output] 1 workers out of 2 ready
[17:38:10.147]  - [local output] 1 workers out of 2 ready
[17:38:10.147]  - [local output] 2 workers out of 2 ready
[17:38:10.148] [local output] Launching of workers completed
[17:38:10.148] [local output] Collecting session information from workers
[17:38:10.149] [local output]  - Worker #1 of 2
[17:38:10.150] [local output]  - Worker #2 of 2
[17:38:10.150] [local output] makeClusterPSOCK() ... done
[17:38:10.162] Packages needed by the future expression (n = 0): <none>
[17:38:10.162] Packages needed by future strategies (n = 0): <none>
[17:38:10.162] {
[17:38:10.162]     {
[17:38:10.162]         {
[17:38:10.162]             ...future.startTime <- base::Sys.time()
[17:38:10.162]             {
[17:38:10.162]                 {
[17:38:10.162]                   {
[17:38:10.162]                     {
[17:38:10.162]                       base::local({
[17:38:10.162]                         has_future <- base::requireNamespace("future", 
[17:38:10.162]                           quietly = TRUE)
[17:38:10.162]                         if (has_future) {
[17:38:10.162]                           ns <- base::getNamespace("future")
[17:38:10.162]                           version <- ns[[".package"]][["version"]]
[17:38:10.162]                           if (is.null(version)) 
[17:38:10.162]                             version <- utils::packageVersion("future")
[17:38:10.162]                         }
[17:38:10.162]                         else {
[17:38:10.162]                           version <- NULL
[17:38:10.162]                         }
[17:38:10.162]                         if (!has_future || version < "1.8.0") {
[17:38:10.162]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:10.162]                             "", base::R.version$version.string), 
[17:38:10.162]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:10.162]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:10.162]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:10.162]                               "release", "version")], collapse = " "), 
[17:38:10.162]                             hostname = base::Sys.info()[["nodename"]])
[17:38:10.162]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:10.162]                             info)
[17:38:10.162]                           info <- base::paste(info, collapse = "; ")
[17:38:10.162]                           if (!has_future) {
[17:38:10.162]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:10.162]                               info)
[17:38:10.162]                           }
[17:38:10.162]                           else {
[17:38:10.162]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:10.162]                               info, version)
[17:38:10.162]                           }
[17:38:10.162]                           base::stop(msg)
[17:38:10.162]                         }
[17:38:10.162]                       })
[17:38:10.162]                     }
[17:38:10.162]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:10.162]                     base::options(mc.cores = 1L)
[17:38:10.162]                   }
[17:38:10.162]                   ...future.strategy.old <- future::plan("list")
[17:38:10.162]                   options(future.plan = NULL)
[17:38:10.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:10.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:10.162]                 }
[17:38:10.162]                 ...future.workdir <- getwd()
[17:38:10.162]             }
[17:38:10.162]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:10.162]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:10.162]         }
[17:38:10.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:10.162]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:38:10.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:10.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:10.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:10.162]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:10.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:10.162]             base::names(...future.oldOptions))
[17:38:10.162]     }
[17:38:10.162]     if (FALSE) {
[17:38:10.162]     }
[17:38:10.162]     else {
[17:38:10.162]         if (TRUE) {
[17:38:10.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:10.162]                 open = "w")
[17:38:10.162]         }
[17:38:10.162]         else {
[17:38:10.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:10.162]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:10.162]         }
[17:38:10.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:10.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:10.162]             base::sink(type = "output", split = FALSE)
[17:38:10.162]             base::close(...future.stdout)
[17:38:10.162]         }, add = TRUE)
[17:38:10.162]     }
[17:38:10.162]     ...future.frame <- base::sys.nframe()
[17:38:10.162]     ...future.conditions <- base::list()
[17:38:10.162]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:10.162]     if (FALSE) {
[17:38:10.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:10.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:10.162]     }
[17:38:10.162]     ...future.result <- base::tryCatch({
[17:38:10.162]         base::withCallingHandlers({
[17:38:10.162]             ...future.value <- base::withVisible(base::local({
[17:38:10.162]                 ...future.makeSendCondition <- base::local({
[17:38:10.162]                   sendCondition <- NULL
[17:38:10.162]                   function(frame = 1L) {
[17:38:10.162]                     if (is.function(sendCondition)) 
[17:38:10.162]                       return(sendCondition)
[17:38:10.162]                     ns <- getNamespace("parallel")
[17:38:10.162]                     if (exists("sendData", mode = "function", 
[17:38:10.162]                       envir = ns)) {
[17:38:10.162]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:10.162]                         envir = ns)
[17:38:10.162]                       envir <- sys.frame(frame)
[17:38:10.162]                       master <- NULL
[17:38:10.162]                       while (!identical(envir, .GlobalEnv) && 
[17:38:10.162]                         !identical(envir, emptyenv())) {
[17:38:10.162]                         if (exists("master", mode = "list", envir = envir, 
[17:38:10.162]                           inherits = FALSE)) {
[17:38:10.162]                           master <- get("master", mode = "list", 
[17:38:10.162]                             envir = envir, inherits = FALSE)
[17:38:10.162]                           if (inherits(master, c("SOCKnode", 
[17:38:10.162]                             "SOCK0node"))) {
[17:38:10.162]                             sendCondition <<- function(cond) {
[17:38:10.162]                               data <- list(type = "VALUE", value = cond, 
[17:38:10.162]                                 success = TRUE)
[17:38:10.162]                               parallel_sendData(master, data)
[17:38:10.162]                             }
[17:38:10.162]                             return(sendCondition)
[17:38:10.162]                           }
[17:38:10.162]                         }
[17:38:10.162]                         frame <- frame + 1L
[17:38:10.162]                         envir <- sys.frame(frame)
[17:38:10.162]                       }
[17:38:10.162]                     }
[17:38:10.162]                     sendCondition <<- function(cond) NULL
[17:38:10.162]                   }
[17:38:10.162]                 })
[17:38:10.162]                 withCallingHandlers({
[17:38:10.162]                   NA
[17:38:10.162]                 }, immediateCondition = function(cond) {
[17:38:10.162]                   sendCondition <- ...future.makeSendCondition()
[17:38:10.162]                   sendCondition(cond)
[17:38:10.162]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.162]                   {
[17:38:10.162]                     inherits <- base::inherits
[17:38:10.162]                     invokeRestart <- base::invokeRestart
[17:38:10.162]                     is.null <- base::is.null
[17:38:10.162]                     muffled <- FALSE
[17:38:10.162]                     if (inherits(cond, "message")) {
[17:38:10.162]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:10.162]                       if (muffled) 
[17:38:10.162]                         invokeRestart("muffleMessage")
[17:38:10.162]                     }
[17:38:10.162]                     else if (inherits(cond, "warning")) {
[17:38:10.162]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:10.162]                       if (muffled) 
[17:38:10.162]                         invokeRestart("muffleWarning")
[17:38:10.162]                     }
[17:38:10.162]                     else if (inherits(cond, "condition")) {
[17:38:10.162]                       if (!is.null(pattern)) {
[17:38:10.162]                         computeRestarts <- base::computeRestarts
[17:38:10.162]                         grepl <- base::grepl
[17:38:10.162]                         restarts <- computeRestarts(cond)
[17:38:10.162]                         for (restart in restarts) {
[17:38:10.162]                           name <- restart$name
[17:38:10.162]                           if (is.null(name)) 
[17:38:10.162]                             next
[17:38:10.162]                           if (!grepl(pattern, name)) 
[17:38:10.162]                             next
[17:38:10.162]                           invokeRestart(restart)
[17:38:10.162]                           muffled <- TRUE
[17:38:10.162]                           break
[17:38:10.162]                         }
[17:38:10.162]                       }
[17:38:10.162]                     }
[17:38:10.162]                     invisible(muffled)
[17:38:10.162]                   }
[17:38:10.162]                   muffleCondition(cond)
[17:38:10.162]                 })
[17:38:10.162]             }))
[17:38:10.162]             future::FutureResult(value = ...future.value$value, 
[17:38:10.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:10.162]                   ...future.rng), globalenv = if (FALSE) 
[17:38:10.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:10.162]                     ...future.globalenv.names))
[17:38:10.162]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:10.162]         }, condition = base::local({
[17:38:10.162]             c <- base::c
[17:38:10.162]             inherits <- base::inherits
[17:38:10.162]             invokeRestart <- base::invokeRestart
[17:38:10.162]             length <- base::length
[17:38:10.162]             list <- base::list
[17:38:10.162]             seq.int <- base::seq.int
[17:38:10.162]             signalCondition <- base::signalCondition
[17:38:10.162]             sys.calls <- base::sys.calls
[17:38:10.162]             `[[` <- base::`[[`
[17:38:10.162]             `+` <- base::`+`
[17:38:10.162]             `<<-` <- base::`<<-`
[17:38:10.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:10.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:10.162]                   3L)]
[17:38:10.162]             }
[17:38:10.162]             function(cond) {
[17:38:10.162]                 is_error <- inherits(cond, "error")
[17:38:10.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:10.162]                   NULL)
[17:38:10.162]                 if (is_error) {
[17:38:10.162]                   sessionInformation <- function() {
[17:38:10.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:10.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:10.162]                       search = base::search(), system = base::Sys.info())
[17:38:10.162]                   }
[17:38:10.162]                   ...future.conditions[[length(...future.conditions) + 
[17:38:10.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:10.162]                     cond$call), session = sessionInformation(), 
[17:38:10.162]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:10.162]                   signalCondition(cond)
[17:38:10.162]                 }
[17:38:10.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:10.162]                 "immediateCondition"))) {
[17:38:10.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:10.162]                   ...future.conditions[[length(...future.conditions) + 
[17:38:10.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:10.162]                   if (TRUE && !signal) {
[17:38:10.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.162]                     {
[17:38:10.162]                       inherits <- base::inherits
[17:38:10.162]                       invokeRestart <- base::invokeRestart
[17:38:10.162]                       is.null <- base::is.null
[17:38:10.162]                       muffled <- FALSE
[17:38:10.162]                       if (inherits(cond, "message")) {
[17:38:10.162]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:10.162]                         if (muffled) 
[17:38:10.162]                           invokeRestart("muffleMessage")
[17:38:10.162]                       }
[17:38:10.162]                       else if (inherits(cond, "warning")) {
[17:38:10.162]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:10.162]                         if (muffled) 
[17:38:10.162]                           invokeRestart("muffleWarning")
[17:38:10.162]                       }
[17:38:10.162]                       else if (inherits(cond, "condition")) {
[17:38:10.162]                         if (!is.null(pattern)) {
[17:38:10.162]                           computeRestarts <- base::computeRestarts
[17:38:10.162]                           grepl <- base::grepl
[17:38:10.162]                           restarts <- computeRestarts(cond)
[17:38:10.162]                           for (restart in restarts) {
[17:38:10.162]                             name <- restart$name
[17:38:10.162]                             if (is.null(name)) 
[17:38:10.162]                               next
[17:38:10.162]                             if (!grepl(pattern, name)) 
[17:38:10.162]                               next
[17:38:10.162]                             invokeRestart(restart)
[17:38:10.162]                             muffled <- TRUE
[17:38:10.162]                             break
[17:38:10.162]                           }
[17:38:10.162]                         }
[17:38:10.162]                       }
[17:38:10.162]                       invisible(muffled)
[17:38:10.162]                     }
[17:38:10.162]                     muffleCondition(cond, pattern = "^muffle")
[17:38:10.162]                   }
[17:38:10.162]                 }
[17:38:10.162]                 else {
[17:38:10.162]                   if (TRUE) {
[17:38:10.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.162]                     {
[17:38:10.162]                       inherits <- base::inherits
[17:38:10.162]                       invokeRestart <- base::invokeRestart
[17:38:10.162]                       is.null <- base::is.null
[17:38:10.162]                       muffled <- FALSE
[17:38:10.162]                       if (inherits(cond, "message")) {
[17:38:10.162]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:10.162]                         if (muffled) 
[17:38:10.162]                           invokeRestart("muffleMessage")
[17:38:10.162]                       }
[17:38:10.162]                       else if (inherits(cond, "warning")) {
[17:38:10.162]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:10.162]                         if (muffled) 
[17:38:10.162]                           invokeRestart("muffleWarning")
[17:38:10.162]                       }
[17:38:10.162]                       else if (inherits(cond, "condition")) {
[17:38:10.162]                         if (!is.null(pattern)) {
[17:38:10.162]                           computeRestarts <- base::computeRestarts
[17:38:10.162]                           grepl <- base::grepl
[17:38:10.162]                           restarts <- computeRestarts(cond)
[17:38:10.162]                           for (restart in restarts) {
[17:38:10.162]                             name <- restart$name
[17:38:10.162]                             if (is.null(name)) 
[17:38:10.162]                               next
[17:38:10.162]                             if (!grepl(pattern, name)) 
[17:38:10.162]                               next
[17:38:10.162]                             invokeRestart(restart)
[17:38:10.162]                             muffled <- TRUE
[17:38:10.162]                             break
[17:38:10.162]                           }
[17:38:10.162]                         }
[17:38:10.162]                       }
[17:38:10.162]                       invisible(muffled)
[17:38:10.162]                     }
[17:38:10.162]                     muffleCondition(cond, pattern = "^muffle")
[17:38:10.162]                   }
[17:38:10.162]                 }
[17:38:10.162]             }
[17:38:10.162]         }))
[17:38:10.162]     }, error = function(ex) {
[17:38:10.162]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:10.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:10.162]                 ...future.rng), started = ...future.startTime, 
[17:38:10.162]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:10.162]             version = "1.8"), class = "FutureResult")
[17:38:10.162]     }, finally = {
[17:38:10.162]         if (!identical(...future.workdir, getwd())) 
[17:38:10.162]             setwd(...future.workdir)
[17:38:10.162]         {
[17:38:10.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:10.162]                 ...future.oldOptions$nwarnings <- NULL
[17:38:10.162]             }
[17:38:10.162]             base::options(...future.oldOptions)
[17:38:10.162]             if (.Platform$OS.type == "windows") {
[17:38:10.162]                 old_names <- names(...future.oldEnvVars)
[17:38:10.162]                 envs <- base::Sys.getenv()
[17:38:10.162]                 names <- names(envs)
[17:38:10.162]                 common <- intersect(names, old_names)
[17:38:10.162]                 added <- setdiff(names, old_names)
[17:38:10.162]                 removed <- setdiff(old_names, names)
[17:38:10.162]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:10.162]                   envs[common]]
[17:38:10.162]                 NAMES <- toupper(changed)
[17:38:10.162]                 args <- list()
[17:38:10.162]                 for (kk in seq_along(NAMES)) {
[17:38:10.162]                   name <- changed[[kk]]
[17:38:10.162]                   NAME <- NAMES[[kk]]
[17:38:10.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.162]                     next
[17:38:10.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:10.162]                 }
[17:38:10.162]                 NAMES <- toupper(added)
[17:38:10.162]                 for (kk in seq_along(NAMES)) {
[17:38:10.162]                   name <- added[[kk]]
[17:38:10.162]                   NAME <- NAMES[[kk]]
[17:38:10.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.162]                     next
[17:38:10.162]                   args[[name]] <- ""
[17:38:10.162]                 }
[17:38:10.162]                 NAMES <- toupper(removed)
[17:38:10.162]                 for (kk in seq_along(NAMES)) {
[17:38:10.162]                   name <- removed[[kk]]
[17:38:10.162]                   NAME <- NAMES[[kk]]
[17:38:10.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.162]                     next
[17:38:10.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:10.162]                 }
[17:38:10.162]                 if (length(args) > 0) 
[17:38:10.162]                   base::do.call(base::Sys.setenv, args = args)
[17:38:10.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:10.162]             }
[17:38:10.162]             else {
[17:38:10.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:10.162]             }
[17:38:10.162]             {
[17:38:10.162]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:10.162]                   0L) {
[17:38:10.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:10.162]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:10.162]                   base::options(opts)
[17:38:10.162]                 }
[17:38:10.162]                 {
[17:38:10.162]                   {
[17:38:10.162]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:10.162]                     NULL
[17:38:10.162]                   }
[17:38:10.162]                   options(future.plan = NULL)
[17:38:10.162]                   if (is.na(NA_character_)) 
[17:38:10.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:10.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:10.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:10.162]                     .init = FALSE)
[17:38:10.162]                 }
[17:38:10.162]             }
[17:38:10.162]         }
[17:38:10.162]     })
[17:38:10.162]     if (TRUE) {
[17:38:10.162]         base::sink(type = "output", split = FALSE)
[17:38:10.162]         if (TRUE) {
[17:38:10.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:10.162]         }
[17:38:10.162]         else {
[17:38:10.162]             ...future.result["stdout"] <- base::list(NULL)
[17:38:10.162]         }
[17:38:10.162]         base::close(...future.stdout)
[17:38:10.162]         ...future.stdout <- NULL
[17:38:10.162]     }
[17:38:10.162]     ...future.result$conditions <- ...future.conditions
[17:38:10.162]     ...future.result$finished <- base::Sys.time()
[17:38:10.162]     ...future.result
[17:38:10.162] }
[17:38:10.215] MultisessionFuture started
[17:38:10.215] result() for ClusterFuture ...
[17:38:10.216] receiveMessageFromWorker() for ClusterFuture ...
[17:38:10.216] - Validating connection of MultisessionFuture
[17:38:10.247] - received message: FutureResult
[17:38:10.248] - Received FutureResult
[17:38:10.248] - Erased future from FutureRegistry
[17:38:10.248] result() for ClusterFuture ...
[17:38:10.248] - result already collected: FutureResult
[17:38:10.248] result() for ClusterFuture ... done
[17:38:10.248] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:10.248] result() for ClusterFuture ... done
[17:38:10.248] result() for ClusterFuture ...
[17:38:10.249] - result already collected: FutureResult
[17:38:10.249] result() for ClusterFuture ... done
[17:38:10.249] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:38:10.253] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[17:38:10.256] future_lapply() ...
[17:38:10.261] Number of chunks: 2
[17:38:10.262] getGlobalsAndPackagesXApply() ...
[17:38:10.262]  - future.globals: TRUE
[17:38:10.262] getGlobalsAndPackages() ...
[17:38:10.262] Searching for globals...
[17:38:10.266] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:10.266] Searching for globals ... DONE
[17:38:10.266] Resolving globals: FALSE
[17:38:10.267] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[17:38:10.267] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:10.268] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:10.268] - packages: [1] ‘future.apply’
[17:38:10.268] getGlobalsAndPackages() ... DONE
[17:38:10.268]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:10.268]  - needed namespaces: [n=1] ‘future.apply’
[17:38:10.268] Finding globals ... DONE
[17:38:10.268]  - use_args: TRUE
[17:38:10.269]  - Getting '...' globals ...
[17:38:10.269] resolve() on list ...
[17:38:10.269]  recursive: 0
[17:38:10.269]  length: 1
[17:38:10.269]  elements: ‘...’
[17:38:10.270]  length: 0 (resolved future 1)
[17:38:10.270] resolve() on list ... DONE
[17:38:10.270]    - '...' content: [n=0] 
[17:38:10.270] List of 1
[17:38:10.270]  $ ...: list()
[17:38:10.270]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:10.270]  - attr(*, "where")=List of 1
[17:38:10.270]   ..$ ...:<environment: 0x56080318a7d8> 
[17:38:10.270]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:10.270]  - attr(*, "resolved")= logi TRUE
[17:38:10.270]  - attr(*, "total_size")= num NA
[17:38:10.273]  - Getting '...' globals ... DONE
[17:38:10.273] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:10.273] List of 8
[17:38:10.273]  $ ...future.FUN:function (x, ...)  
[17:38:10.273]  $ x_FUN        :function (x)  
[17:38:10.273]  $ times        : int 1
[17:38:10.273]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:10.273]  $ stop_if_not  :function (...)  
[17:38:10.273]  $ dim          : NULL
[17:38:10.273]  $ valid_types  : chr "character"
[17:38:10.273]  $ ...          : list()
[17:38:10.273]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:10.273]  - attr(*, "where")=List of 8
[17:38:10.273]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:10.273]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:10.273]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:10.273]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:10.273]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:10.273]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:10.273]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:10.273]   ..$ ...          :<environment: 0x56080318a7d8> 
[17:38:10.273]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:10.273]  - attr(*, "resolved")= logi FALSE
[17:38:10.273]  - attr(*, "total_size")= num 94208
[17:38:10.280] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:10.280] getGlobalsAndPackagesXApply() ... DONE
[17:38:10.280] Number of futures (= number of chunks): 2
[17:38:10.280] Launching 2 futures (chunks) ...
[17:38:10.281] Chunk #1 of 2 ...
[17:38:10.281]  - Finding globals in 'X' for chunk #1 ...
[17:38:10.281] getGlobalsAndPackages() ...
[17:38:10.281] Searching for globals...
[17:38:10.281] 
[17:38:10.281] Searching for globals ... DONE
[17:38:10.281] - globals: [0] <none>
[17:38:10.282] getGlobalsAndPackages() ... DONE
[17:38:10.282]    + additional globals found: [n=0] 
[17:38:10.282]    + additional namespaces needed: [n=0] 
[17:38:10.282]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:10.282]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:10.282]  - seeds: <none>
[17:38:10.282]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:10.282] getGlobalsAndPackages() ...
[17:38:10.282] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:10.283] Resolving globals: FALSE
[17:38:10.283] Tweak future expression to call with '...' arguments ...
[17:38:10.283] {
[17:38:10.283]     do.call(function(...) {
[17:38:10.283]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:10.283]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:10.283]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:10.283]             on.exit(options(oopts), add = TRUE)
[17:38:10.283]         }
[17:38:10.283]         {
[17:38:10.283]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:10.283]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:10.283]                 ...future.FUN(...future.X_jj, ...)
[17:38:10.283]             })
[17:38:10.283]         }
[17:38:10.283]     }, args = future.call.arguments)
[17:38:10.283] }
[17:38:10.283] Tweak future expression to call with '...' arguments ... DONE
[17:38:10.284] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:10.284] - packages: [1] ‘future.apply’
[17:38:10.284] getGlobalsAndPackages() ... DONE
[17:38:10.284] run() for ‘Future’ ...
[17:38:10.285] - state: ‘created’
[17:38:10.285] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:10.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:10.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:10.300]   - Field: ‘node’
[17:38:10.300]   - Field: ‘label’
[17:38:10.300]   - Field: ‘local’
[17:38:10.300]   - Field: ‘owner’
[17:38:10.300]   - Field: ‘envir’
[17:38:10.300]   - Field: ‘workers’
[17:38:10.301]   - Field: ‘packages’
[17:38:10.301]   - Field: ‘gc’
[17:38:10.301]   - Field: ‘conditions’
[17:38:10.301]   - Field: ‘persistent’
[17:38:10.301]   - Field: ‘expr’
[17:38:10.301]   - Field: ‘uuid’
[17:38:10.301]   - Field: ‘seed’
[17:38:10.301]   - Field: ‘version’
[17:38:10.301]   - Field: ‘result’
[17:38:10.302]   - Field: ‘asynchronous’
[17:38:10.302]   - Field: ‘calls’
[17:38:10.302]   - Field: ‘globals’
[17:38:10.302]   - Field: ‘stdout’
[17:38:10.302]   - Field: ‘earlySignal’
[17:38:10.302]   - Field: ‘lazy’
[17:38:10.302]   - Field: ‘state’
[17:38:10.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:10.303] - Launch lazy future ...
[17:38:10.303] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:10.303] Packages needed by future strategies (n = 0): <none>
[17:38:10.304] {
[17:38:10.304]     {
[17:38:10.304]         {
[17:38:10.304]             ...future.startTime <- base::Sys.time()
[17:38:10.304]             {
[17:38:10.304]                 {
[17:38:10.304]                   {
[17:38:10.304]                     {
[17:38:10.304]                       {
[17:38:10.304]                         base::local({
[17:38:10.304]                           has_future <- base::requireNamespace("future", 
[17:38:10.304]                             quietly = TRUE)
[17:38:10.304]                           if (has_future) {
[17:38:10.304]                             ns <- base::getNamespace("future")
[17:38:10.304]                             version <- ns[[".package"]][["version"]]
[17:38:10.304]                             if (is.null(version)) 
[17:38:10.304]                               version <- utils::packageVersion("future")
[17:38:10.304]                           }
[17:38:10.304]                           else {
[17:38:10.304]                             version <- NULL
[17:38:10.304]                           }
[17:38:10.304]                           if (!has_future || version < "1.8.0") {
[17:38:10.304]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:10.304]                               "", base::R.version$version.string), 
[17:38:10.304]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:10.304]                                 base::R.version$platform, 8 * 
[17:38:10.304]                                   base::.Machine$sizeof.pointer), 
[17:38:10.304]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:10.304]                                 "release", "version")], collapse = " "), 
[17:38:10.304]                               hostname = base::Sys.info()[["nodename"]])
[17:38:10.304]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:10.304]                               info)
[17:38:10.304]                             info <- base::paste(info, collapse = "; ")
[17:38:10.304]                             if (!has_future) {
[17:38:10.304]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:10.304]                                 info)
[17:38:10.304]                             }
[17:38:10.304]                             else {
[17:38:10.304]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:10.304]                                 info, version)
[17:38:10.304]                             }
[17:38:10.304]                             base::stop(msg)
[17:38:10.304]                           }
[17:38:10.304]                         })
[17:38:10.304]                       }
[17:38:10.304]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:10.304]                       base::options(mc.cores = 1L)
[17:38:10.304]                     }
[17:38:10.304]                     base::local({
[17:38:10.304]                       for (pkg in "future.apply") {
[17:38:10.304]                         base::loadNamespace(pkg)
[17:38:10.304]                         base::library(pkg, character.only = TRUE)
[17:38:10.304]                       }
[17:38:10.304]                     })
[17:38:10.304]                   }
[17:38:10.304]                   ...future.strategy.old <- future::plan("list")
[17:38:10.304]                   options(future.plan = NULL)
[17:38:10.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:10.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:10.304]                 }
[17:38:10.304]                 ...future.workdir <- getwd()
[17:38:10.304]             }
[17:38:10.304]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:10.304]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:10.304]         }
[17:38:10.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:10.304]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:10.304]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:10.304]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:10.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:10.304]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:10.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:10.304]             base::names(...future.oldOptions))
[17:38:10.304]     }
[17:38:10.304]     if (FALSE) {
[17:38:10.304]     }
[17:38:10.304]     else {
[17:38:10.304]         if (TRUE) {
[17:38:10.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:10.304]                 open = "w")
[17:38:10.304]         }
[17:38:10.304]         else {
[17:38:10.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:10.304]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:10.304]         }
[17:38:10.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:10.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:10.304]             base::sink(type = "output", split = FALSE)
[17:38:10.304]             base::close(...future.stdout)
[17:38:10.304]         }, add = TRUE)
[17:38:10.304]     }
[17:38:10.304]     ...future.frame <- base::sys.nframe()
[17:38:10.304]     ...future.conditions <- base::list()
[17:38:10.304]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:10.304]     if (FALSE) {
[17:38:10.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:10.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:10.304]     }
[17:38:10.304]     ...future.result <- base::tryCatch({
[17:38:10.304]         base::withCallingHandlers({
[17:38:10.304]             ...future.value <- base::withVisible(base::local({
[17:38:10.304]                 ...future.makeSendCondition <- base::local({
[17:38:10.304]                   sendCondition <- NULL
[17:38:10.304]                   function(frame = 1L) {
[17:38:10.304]                     if (is.function(sendCondition)) 
[17:38:10.304]                       return(sendCondition)
[17:38:10.304]                     ns <- getNamespace("parallel")
[17:38:10.304]                     if (exists("sendData", mode = "function", 
[17:38:10.304]                       envir = ns)) {
[17:38:10.304]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:10.304]                         envir = ns)
[17:38:10.304]                       envir <- sys.frame(frame)
[17:38:10.304]                       master <- NULL
[17:38:10.304]                       while (!identical(envir, .GlobalEnv) && 
[17:38:10.304]                         !identical(envir, emptyenv())) {
[17:38:10.304]                         if (exists("master", mode = "list", envir = envir, 
[17:38:10.304]                           inherits = FALSE)) {
[17:38:10.304]                           master <- get("master", mode = "list", 
[17:38:10.304]                             envir = envir, inherits = FALSE)
[17:38:10.304]                           if (inherits(master, c("SOCKnode", 
[17:38:10.304]                             "SOCK0node"))) {
[17:38:10.304]                             sendCondition <<- function(cond) {
[17:38:10.304]                               data <- list(type = "VALUE", value = cond, 
[17:38:10.304]                                 success = TRUE)
[17:38:10.304]                               parallel_sendData(master, data)
[17:38:10.304]                             }
[17:38:10.304]                             return(sendCondition)
[17:38:10.304]                           }
[17:38:10.304]                         }
[17:38:10.304]                         frame <- frame + 1L
[17:38:10.304]                         envir <- sys.frame(frame)
[17:38:10.304]                       }
[17:38:10.304]                     }
[17:38:10.304]                     sendCondition <<- function(cond) NULL
[17:38:10.304]                   }
[17:38:10.304]                 })
[17:38:10.304]                 withCallingHandlers({
[17:38:10.304]                   {
[17:38:10.304]                     do.call(function(...) {
[17:38:10.304]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:10.304]                       if (!identical(...future.globals.maxSize.org, 
[17:38:10.304]                         ...future.globals.maxSize)) {
[17:38:10.304]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:10.304]                         on.exit(options(oopts), add = TRUE)
[17:38:10.304]                       }
[17:38:10.304]                       {
[17:38:10.304]                         lapply(seq_along(...future.elements_ii), 
[17:38:10.304]                           FUN = function(jj) {
[17:38:10.304]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:10.304]                             ...future.FUN(...future.X_jj, ...)
[17:38:10.304]                           })
[17:38:10.304]                       }
[17:38:10.304]                     }, args = future.call.arguments)
[17:38:10.304]                   }
[17:38:10.304]                 }, immediateCondition = function(cond) {
[17:38:10.304]                   sendCondition <- ...future.makeSendCondition()
[17:38:10.304]                   sendCondition(cond)
[17:38:10.304]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.304]                   {
[17:38:10.304]                     inherits <- base::inherits
[17:38:10.304]                     invokeRestart <- base::invokeRestart
[17:38:10.304]                     is.null <- base::is.null
[17:38:10.304]                     muffled <- FALSE
[17:38:10.304]                     if (inherits(cond, "message")) {
[17:38:10.304]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:10.304]                       if (muffled) 
[17:38:10.304]                         invokeRestart("muffleMessage")
[17:38:10.304]                     }
[17:38:10.304]                     else if (inherits(cond, "warning")) {
[17:38:10.304]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:10.304]                       if (muffled) 
[17:38:10.304]                         invokeRestart("muffleWarning")
[17:38:10.304]                     }
[17:38:10.304]                     else if (inherits(cond, "condition")) {
[17:38:10.304]                       if (!is.null(pattern)) {
[17:38:10.304]                         computeRestarts <- base::computeRestarts
[17:38:10.304]                         grepl <- base::grepl
[17:38:10.304]                         restarts <- computeRestarts(cond)
[17:38:10.304]                         for (restart in restarts) {
[17:38:10.304]                           name <- restart$name
[17:38:10.304]                           if (is.null(name)) 
[17:38:10.304]                             next
[17:38:10.304]                           if (!grepl(pattern, name)) 
[17:38:10.304]                             next
[17:38:10.304]                           invokeRestart(restart)
[17:38:10.304]                           muffled <- TRUE
[17:38:10.304]                           break
[17:38:10.304]                         }
[17:38:10.304]                       }
[17:38:10.304]                     }
[17:38:10.304]                     invisible(muffled)
[17:38:10.304]                   }
[17:38:10.304]                   muffleCondition(cond)
[17:38:10.304]                 })
[17:38:10.304]             }))
[17:38:10.304]             future::FutureResult(value = ...future.value$value, 
[17:38:10.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:10.304]                   ...future.rng), globalenv = if (FALSE) 
[17:38:10.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:10.304]                     ...future.globalenv.names))
[17:38:10.304]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:10.304]         }, condition = base::local({
[17:38:10.304]             c <- base::c
[17:38:10.304]             inherits <- base::inherits
[17:38:10.304]             invokeRestart <- base::invokeRestart
[17:38:10.304]             length <- base::length
[17:38:10.304]             list <- base::list
[17:38:10.304]             seq.int <- base::seq.int
[17:38:10.304]             signalCondition <- base::signalCondition
[17:38:10.304]             sys.calls <- base::sys.calls
[17:38:10.304]             `[[` <- base::`[[`
[17:38:10.304]             `+` <- base::`+`
[17:38:10.304]             `<<-` <- base::`<<-`
[17:38:10.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:10.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:10.304]                   3L)]
[17:38:10.304]             }
[17:38:10.304]             function(cond) {
[17:38:10.304]                 is_error <- inherits(cond, "error")
[17:38:10.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:10.304]                   NULL)
[17:38:10.304]                 if (is_error) {
[17:38:10.304]                   sessionInformation <- function() {
[17:38:10.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:10.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:10.304]                       search = base::search(), system = base::Sys.info())
[17:38:10.304]                   }
[17:38:10.304]                   ...future.conditions[[length(...future.conditions) + 
[17:38:10.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:10.304]                     cond$call), session = sessionInformation(), 
[17:38:10.304]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:10.304]                   signalCondition(cond)
[17:38:10.304]                 }
[17:38:10.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:10.304]                 "immediateCondition"))) {
[17:38:10.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:10.304]                   ...future.conditions[[length(...future.conditions) + 
[17:38:10.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:10.304]                   if (TRUE && !signal) {
[17:38:10.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.304]                     {
[17:38:10.304]                       inherits <- base::inherits
[17:38:10.304]                       invokeRestart <- base::invokeRestart
[17:38:10.304]                       is.null <- base::is.null
[17:38:10.304]                       muffled <- FALSE
[17:38:10.304]                       if (inherits(cond, "message")) {
[17:38:10.304]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:10.304]                         if (muffled) 
[17:38:10.304]                           invokeRestart("muffleMessage")
[17:38:10.304]                       }
[17:38:10.304]                       else if (inherits(cond, "warning")) {
[17:38:10.304]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:10.304]                         if (muffled) 
[17:38:10.304]                           invokeRestart("muffleWarning")
[17:38:10.304]                       }
[17:38:10.304]                       else if (inherits(cond, "condition")) {
[17:38:10.304]                         if (!is.null(pattern)) {
[17:38:10.304]                           computeRestarts <- base::computeRestarts
[17:38:10.304]                           grepl <- base::grepl
[17:38:10.304]                           restarts <- computeRestarts(cond)
[17:38:10.304]                           for (restart in restarts) {
[17:38:10.304]                             name <- restart$name
[17:38:10.304]                             if (is.null(name)) 
[17:38:10.304]                               next
[17:38:10.304]                             if (!grepl(pattern, name)) 
[17:38:10.304]                               next
[17:38:10.304]                             invokeRestart(restart)
[17:38:10.304]                             muffled <- TRUE
[17:38:10.304]                             break
[17:38:10.304]                           }
[17:38:10.304]                         }
[17:38:10.304]                       }
[17:38:10.304]                       invisible(muffled)
[17:38:10.304]                     }
[17:38:10.304]                     muffleCondition(cond, pattern = "^muffle")
[17:38:10.304]                   }
[17:38:10.304]                 }
[17:38:10.304]                 else {
[17:38:10.304]                   if (TRUE) {
[17:38:10.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.304]                     {
[17:38:10.304]                       inherits <- base::inherits
[17:38:10.304]                       invokeRestart <- base::invokeRestart
[17:38:10.304]                       is.null <- base::is.null
[17:38:10.304]                       muffled <- FALSE
[17:38:10.304]                       if (inherits(cond, "message")) {
[17:38:10.304]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:10.304]                         if (muffled) 
[17:38:10.304]                           invokeRestart("muffleMessage")
[17:38:10.304]                       }
[17:38:10.304]                       else if (inherits(cond, "warning")) {
[17:38:10.304]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:10.304]                         if (muffled) 
[17:38:10.304]                           invokeRestart("muffleWarning")
[17:38:10.304]                       }
[17:38:10.304]                       else if (inherits(cond, "condition")) {
[17:38:10.304]                         if (!is.null(pattern)) {
[17:38:10.304]                           computeRestarts <- base::computeRestarts
[17:38:10.304]                           grepl <- base::grepl
[17:38:10.304]                           restarts <- computeRestarts(cond)
[17:38:10.304]                           for (restart in restarts) {
[17:38:10.304]                             name <- restart$name
[17:38:10.304]                             if (is.null(name)) 
[17:38:10.304]                               next
[17:38:10.304]                             if (!grepl(pattern, name)) 
[17:38:10.304]                               next
[17:38:10.304]                             invokeRestart(restart)
[17:38:10.304]                             muffled <- TRUE
[17:38:10.304]                             break
[17:38:10.304]                           }
[17:38:10.304]                         }
[17:38:10.304]                       }
[17:38:10.304]                       invisible(muffled)
[17:38:10.304]                     }
[17:38:10.304]                     muffleCondition(cond, pattern = "^muffle")
[17:38:10.304]                   }
[17:38:10.304]                 }
[17:38:10.304]             }
[17:38:10.304]         }))
[17:38:10.304]     }, error = function(ex) {
[17:38:10.304]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:10.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:10.304]                 ...future.rng), started = ...future.startTime, 
[17:38:10.304]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:10.304]             version = "1.8"), class = "FutureResult")
[17:38:10.304]     }, finally = {
[17:38:10.304]         if (!identical(...future.workdir, getwd())) 
[17:38:10.304]             setwd(...future.workdir)
[17:38:10.304]         {
[17:38:10.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:10.304]                 ...future.oldOptions$nwarnings <- NULL
[17:38:10.304]             }
[17:38:10.304]             base::options(...future.oldOptions)
[17:38:10.304]             if (.Platform$OS.type == "windows") {
[17:38:10.304]                 old_names <- names(...future.oldEnvVars)
[17:38:10.304]                 envs <- base::Sys.getenv()
[17:38:10.304]                 names <- names(envs)
[17:38:10.304]                 common <- intersect(names, old_names)
[17:38:10.304]                 added <- setdiff(names, old_names)
[17:38:10.304]                 removed <- setdiff(old_names, names)
[17:38:10.304]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:10.304]                   envs[common]]
[17:38:10.304]                 NAMES <- toupper(changed)
[17:38:10.304]                 args <- list()
[17:38:10.304]                 for (kk in seq_along(NAMES)) {
[17:38:10.304]                   name <- changed[[kk]]
[17:38:10.304]                   NAME <- NAMES[[kk]]
[17:38:10.304]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.304]                     next
[17:38:10.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:10.304]                 }
[17:38:10.304]                 NAMES <- toupper(added)
[17:38:10.304]                 for (kk in seq_along(NAMES)) {
[17:38:10.304]                   name <- added[[kk]]
[17:38:10.304]                   NAME <- NAMES[[kk]]
[17:38:10.304]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.304]                     next
[17:38:10.304]                   args[[name]] <- ""
[17:38:10.304]                 }
[17:38:10.304]                 NAMES <- toupper(removed)
[17:38:10.304]                 for (kk in seq_along(NAMES)) {
[17:38:10.304]                   name <- removed[[kk]]
[17:38:10.304]                   NAME <- NAMES[[kk]]
[17:38:10.304]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.304]                     next
[17:38:10.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:10.304]                 }
[17:38:10.304]                 if (length(args) > 0) 
[17:38:10.304]                   base::do.call(base::Sys.setenv, args = args)
[17:38:10.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:10.304]             }
[17:38:10.304]             else {
[17:38:10.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:10.304]             }
[17:38:10.304]             {
[17:38:10.304]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:10.304]                   0L) {
[17:38:10.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:10.304]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:10.304]                   base::options(opts)
[17:38:10.304]                 }
[17:38:10.304]                 {
[17:38:10.304]                   {
[17:38:10.304]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:10.304]                     NULL
[17:38:10.304]                   }
[17:38:10.304]                   options(future.plan = NULL)
[17:38:10.304]                   if (is.na(NA_character_)) 
[17:38:10.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:10.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:10.304]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:10.304]                     .init = FALSE)
[17:38:10.304]                 }
[17:38:10.304]             }
[17:38:10.304]         }
[17:38:10.304]     })
[17:38:10.304]     if (TRUE) {
[17:38:10.304]         base::sink(type = "output", split = FALSE)
[17:38:10.304]         if (TRUE) {
[17:38:10.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:10.304]         }
[17:38:10.304]         else {
[17:38:10.304]             ...future.result["stdout"] <- base::list(NULL)
[17:38:10.304]         }
[17:38:10.304]         base::close(...future.stdout)
[17:38:10.304]         ...future.stdout <- NULL
[17:38:10.304]     }
[17:38:10.304]     ...future.result$conditions <- ...future.conditions
[17:38:10.304]     ...future.result$finished <- base::Sys.time()
[17:38:10.304]     ...future.result
[17:38:10.304] }
[17:38:10.307] Exporting 11 global objects (92.00 KiB) to cluster node #1 ...
[17:38:10.307] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:38:10.349] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:38:10.349] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:38:10.349] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:38:10.350] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:38:10.350] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:38:10.350] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:38:10.393] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:38:10.393] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:38:10.437] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:38:10.437] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:38:10.437] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:38:10.437] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ...
[17:38:10.438] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ... DONE
[17:38:10.438] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:10.439] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:10.439] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[17:38:10.439] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[17:38:10.439] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:10.440] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:10.440] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:10.440] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:10.441] Exporting 11 global objects (92.00 KiB) to cluster node #1 ... DONE
[17:38:10.441] MultisessionFuture started
[17:38:10.441] - Launch lazy future ... done
[17:38:10.442] run() for ‘MultisessionFuture’ ... done
[17:38:10.442] Created future:
[17:38:10.442] MultisessionFuture:
[17:38:10.442] Label: ‘future_vapply-1’
[17:38:10.442] Expression:
[17:38:10.442] {
[17:38:10.442]     do.call(function(...) {
[17:38:10.442]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:10.442]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:10.442]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:10.442]             on.exit(options(oopts), add = TRUE)
[17:38:10.442]         }
[17:38:10.442]         {
[17:38:10.442]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:10.442]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:10.442]                 ...future.FUN(...future.X_jj, ...)
[17:38:10.442]             })
[17:38:10.442]         }
[17:38:10.442]     }, args = future.call.arguments)
[17:38:10.442] }
[17:38:10.442] Lazy evaluation: FALSE
[17:38:10.442] Asynchronous evaluation: TRUE
[17:38:10.442] Local evaluation: TRUE
[17:38:10.442] Environment: R_GlobalEnv
[17:38:10.442] Capture standard output: TRUE
[17:38:10.442] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:10.442] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:10.442] Packages: 1 packages (‘future.apply’)
[17:38:10.442] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:10.442] Resolved: FALSE
[17:38:10.442] Value: <not collected>
[17:38:10.442] Conditions captured: <none>
[17:38:10.442] Early signaling: FALSE
[17:38:10.442] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:10.442] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:10.454] Chunk #1 of 2 ... DONE
[17:38:10.454] Chunk #2 of 2 ...
[17:38:10.455]  - Finding globals in 'X' for chunk #2 ...
[17:38:10.455] getGlobalsAndPackages() ...
[17:38:10.455] Searching for globals...
[17:38:10.455] 
[17:38:10.455] Searching for globals ... DONE
[17:38:10.456] - globals: [0] <none>
[17:38:10.456] getGlobalsAndPackages() ... DONE
[17:38:10.456]    + additional globals found: [n=0] 
[17:38:10.456]    + additional namespaces needed: [n=0] 
[17:38:10.456]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:10.456]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:10.456]  - seeds: <none>
[17:38:10.456]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:10.457] getGlobalsAndPackages() ...
[17:38:10.457] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:10.457] Resolving globals: FALSE
[17:38:10.457] Tweak future expression to call with '...' arguments ...
[17:38:10.457] {
[17:38:10.457]     do.call(function(...) {
[17:38:10.457]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:10.457]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:10.457]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:10.457]             on.exit(options(oopts), add = TRUE)
[17:38:10.457]         }
[17:38:10.457]         {
[17:38:10.457]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:10.457]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:10.457]                 ...future.FUN(...future.X_jj, ...)
[17:38:10.457]             })
[17:38:10.457]         }
[17:38:10.457]     }, args = future.call.arguments)
[17:38:10.457] }
[17:38:10.457] Tweak future expression to call with '...' arguments ... DONE
[17:38:10.458] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:10.458] - packages: [1] ‘future.apply’
[17:38:10.458] getGlobalsAndPackages() ... DONE
[17:38:10.459] run() for ‘Future’ ...
[17:38:10.459] - state: ‘created’
[17:38:10.459] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:10.474] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:10.474] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:10.475]   - Field: ‘node’
[17:38:10.475]   - Field: ‘label’
[17:38:10.475]   - Field: ‘local’
[17:38:10.475]   - Field: ‘owner’
[17:38:10.475]   - Field: ‘envir’
[17:38:10.475]   - Field: ‘workers’
[17:38:10.475]   - Field: ‘packages’
[17:38:10.475]   - Field: ‘gc’
[17:38:10.475]   - Field: ‘conditions’
[17:38:10.475]   - Field: ‘persistent’
[17:38:10.476]   - Field: ‘expr’
[17:38:10.476]   - Field: ‘uuid’
[17:38:10.476]   - Field: ‘seed’
[17:38:10.476]   - Field: ‘version’
[17:38:10.476]   - Field: ‘result’
[17:38:10.476]   - Field: ‘asynchronous’
[17:38:10.476]   - Field: ‘calls’
[17:38:10.476]   - Field: ‘globals’
[17:38:10.477]   - Field: ‘stdout’
[17:38:10.477]   - Field: ‘earlySignal’
[17:38:10.477]   - Field: ‘lazy’
[17:38:10.477]   - Field: ‘state’
[17:38:10.477] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:10.477] - Launch lazy future ...
[17:38:10.477] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:10.478] Packages needed by future strategies (n = 0): <none>
[17:38:10.478] {
[17:38:10.478]     {
[17:38:10.478]         {
[17:38:10.478]             ...future.startTime <- base::Sys.time()
[17:38:10.478]             {
[17:38:10.478]                 {
[17:38:10.478]                   {
[17:38:10.478]                     {
[17:38:10.478]                       {
[17:38:10.478]                         base::local({
[17:38:10.478]                           has_future <- base::requireNamespace("future", 
[17:38:10.478]                             quietly = TRUE)
[17:38:10.478]                           if (has_future) {
[17:38:10.478]                             ns <- base::getNamespace("future")
[17:38:10.478]                             version <- ns[[".package"]][["version"]]
[17:38:10.478]                             if (is.null(version)) 
[17:38:10.478]                               version <- utils::packageVersion("future")
[17:38:10.478]                           }
[17:38:10.478]                           else {
[17:38:10.478]                             version <- NULL
[17:38:10.478]                           }
[17:38:10.478]                           if (!has_future || version < "1.8.0") {
[17:38:10.478]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:10.478]                               "", base::R.version$version.string), 
[17:38:10.478]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:10.478]                                 base::R.version$platform, 8 * 
[17:38:10.478]                                   base::.Machine$sizeof.pointer), 
[17:38:10.478]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:10.478]                                 "release", "version")], collapse = " "), 
[17:38:10.478]                               hostname = base::Sys.info()[["nodename"]])
[17:38:10.478]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:10.478]                               info)
[17:38:10.478]                             info <- base::paste(info, collapse = "; ")
[17:38:10.478]                             if (!has_future) {
[17:38:10.478]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:10.478]                                 info)
[17:38:10.478]                             }
[17:38:10.478]                             else {
[17:38:10.478]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:10.478]                                 info, version)
[17:38:10.478]                             }
[17:38:10.478]                             base::stop(msg)
[17:38:10.478]                           }
[17:38:10.478]                         })
[17:38:10.478]                       }
[17:38:10.478]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:10.478]                       base::options(mc.cores = 1L)
[17:38:10.478]                     }
[17:38:10.478]                     base::local({
[17:38:10.478]                       for (pkg in "future.apply") {
[17:38:10.478]                         base::loadNamespace(pkg)
[17:38:10.478]                         base::library(pkg, character.only = TRUE)
[17:38:10.478]                       }
[17:38:10.478]                     })
[17:38:10.478]                   }
[17:38:10.478]                   ...future.strategy.old <- future::plan("list")
[17:38:10.478]                   options(future.plan = NULL)
[17:38:10.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:10.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:10.478]                 }
[17:38:10.478]                 ...future.workdir <- getwd()
[17:38:10.478]             }
[17:38:10.478]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:10.478]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:10.478]         }
[17:38:10.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:10.478]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:10.478]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:10.478]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:10.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:10.478]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:10.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:10.478]             base::names(...future.oldOptions))
[17:38:10.478]     }
[17:38:10.478]     if (FALSE) {
[17:38:10.478]     }
[17:38:10.478]     else {
[17:38:10.478]         if (TRUE) {
[17:38:10.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:10.478]                 open = "w")
[17:38:10.478]         }
[17:38:10.478]         else {
[17:38:10.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:10.478]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:10.478]         }
[17:38:10.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:10.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:10.478]             base::sink(type = "output", split = FALSE)
[17:38:10.478]             base::close(...future.stdout)
[17:38:10.478]         }, add = TRUE)
[17:38:10.478]     }
[17:38:10.478]     ...future.frame <- base::sys.nframe()
[17:38:10.478]     ...future.conditions <- base::list()
[17:38:10.478]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:10.478]     if (FALSE) {
[17:38:10.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:10.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:10.478]     }
[17:38:10.478]     ...future.result <- base::tryCatch({
[17:38:10.478]         base::withCallingHandlers({
[17:38:10.478]             ...future.value <- base::withVisible(base::local({
[17:38:10.478]                 ...future.makeSendCondition <- base::local({
[17:38:10.478]                   sendCondition <- NULL
[17:38:10.478]                   function(frame = 1L) {
[17:38:10.478]                     if (is.function(sendCondition)) 
[17:38:10.478]                       return(sendCondition)
[17:38:10.478]                     ns <- getNamespace("parallel")
[17:38:10.478]                     if (exists("sendData", mode = "function", 
[17:38:10.478]                       envir = ns)) {
[17:38:10.478]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:10.478]                         envir = ns)
[17:38:10.478]                       envir <- sys.frame(frame)
[17:38:10.478]                       master <- NULL
[17:38:10.478]                       while (!identical(envir, .GlobalEnv) && 
[17:38:10.478]                         !identical(envir, emptyenv())) {
[17:38:10.478]                         if (exists("master", mode = "list", envir = envir, 
[17:38:10.478]                           inherits = FALSE)) {
[17:38:10.478]                           master <- get("master", mode = "list", 
[17:38:10.478]                             envir = envir, inherits = FALSE)
[17:38:10.478]                           if (inherits(master, c("SOCKnode", 
[17:38:10.478]                             "SOCK0node"))) {
[17:38:10.478]                             sendCondition <<- function(cond) {
[17:38:10.478]                               data <- list(type = "VALUE", value = cond, 
[17:38:10.478]                                 success = TRUE)
[17:38:10.478]                               parallel_sendData(master, data)
[17:38:10.478]                             }
[17:38:10.478]                             return(sendCondition)
[17:38:10.478]                           }
[17:38:10.478]                         }
[17:38:10.478]                         frame <- frame + 1L
[17:38:10.478]                         envir <- sys.frame(frame)
[17:38:10.478]                       }
[17:38:10.478]                     }
[17:38:10.478]                     sendCondition <<- function(cond) NULL
[17:38:10.478]                   }
[17:38:10.478]                 })
[17:38:10.478]                 withCallingHandlers({
[17:38:10.478]                   {
[17:38:10.478]                     do.call(function(...) {
[17:38:10.478]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:10.478]                       if (!identical(...future.globals.maxSize.org, 
[17:38:10.478]                         ...future.globals.maxSize)) {
[17:38:10.478]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:10.478]                         on.exit(options(oopts), add = TRUE)
[17:38:10.478]                       }
[17:38:10.478]                       {
[17:38:10.478]                         lapply(seq_along(...future.elements_ii), 
[17:38:10.478]                           FUN = function(jj) {
[17:38:10.478]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:10.478]                             ...future.FUN(...future.X_jj, ...)
[17:38:10.478]                           })
[17:38:10.478]                       }
[17:38:10.478]                     }, args = future.call.arguments)
[17:38:10.478]                   }
[17:38:10.478]                 }, immediateCondition = function(cond) {
[17:38:10.478]                   sendCondition <- ...future.makeSendCondition()
[17:38:10.478]                   sendCondition(cond)
[17:38:10.478]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.478]                   {
[17:38:10.478]                     inherits <- base::inherits
[17:38:10.478]                     invokeRestart <- base::invokeRestart
[17:38:10.478]                     is.null <- base::is.null
[17:38:10.478]                     muffled <- FALSE
[17:38:10.478]                     if (inherits(cond, "message")) {
[17:38:10.478]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:10.478]                       if (muffled) 
[17:38:10.478]                         invokeRestart("muffleMessage")
[17:38:10.478]                     }
[17:38:10.478]                     else if (inherits(cond, "warning")) {
[17:38:10.478]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:10.478]                       if (muffled) 
[17:38:10.478]                         invokeRestart("muffleWarning")
[17:38:10.478]                     }
[17:38:10.478]                     else if (inherits(cond, "condition")) {
[17:38:10.478]                       if (!is.null(pattern)) {
[17:38:10.478]                         computeRestarts <- base::computeRestarts
[17:38:10.478]                         grepl <- base::grepl
[17:38:10.478]                         restarts <- computeRestarts(cond)
[17:38:10.478]                         for (restart in restarts) {
[17:38:10.478]                           name <- restart$name
[17:38:10.478]                           if (is.null(name)) 
[17:38:10.478]                             next
[17:38:10.478]                           if (!grepl(pattern, name)) 
[17:38:10.478]                             next
[17:38:10.478]                           invokeRestart(restart)
[17:38:10.478]                           muffled <- TRUE
[17:38:10.478]                           break
[17:38:10.478]                         }
[17:38:10.478]                       }
[17:38:10.478]                     }
[17:38:10.478]                     invisible(muffled)
[17:38:10.478]                   }
[17:38:10.478]                   muffleCondition(cond)
[17:38:10.478]                 })
[17:38:10.478]             }))
[17:38:10.478]             future::FutureResult(value = ...future.value$value, 
[17:38:10.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:10.478]                   ...future.rng), globalenv = if (FALSE) 
[17:38:10.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:10.478]                     ...future.globalenv.names))
[17:38:10.478]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:10.478]         }, condition = base::local({
[17:38:10.478]             c <- base::c
[17:38:10.478]             inherits <- base::inherits
[17:38:10.478]             invokeRestart <- base::invokeRestart
[17:38:10.478]             length <- base::length
[17:38:10.478]             list <- base::list
[17:38:10.478]             seq.int <- base::seq.int
[17:38:10.478]             signalCondition <- base::signalCondition
[17:38:10.478]             sys.calls <- base::sys.calls
[17:38:10.478]             `[[` <- base::`[[`
[17:38:10.478]             `+` <- base::`+`
[17:38:10.478]             `<<-` <- base::`<<-`
[17:38:10.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:10.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:10.478]                   3L)]
[17:38:10.478]             }
[17:38:10.478]             function(cond) {
[17:38:10.478]                 is_error <- inherits(cond, "error")
[17:38:10.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:10.478]                   NULL)
[17:38:10.478]                 if (is_error) {
[17:38:10.478]                   sessionInformation <- function() {
[17:38:10.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:10.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:10.478]                       search = base::search(), system = base::Sys.info())
[17:38:10.478]                   }
[17:38:10.478]                   ...future.conditions[[length(...future.conditions) + 
[17:38:10.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:10.478]                     cond$call), session = sessionInformation(), 
[17:38:10.478]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:10.478]                   signalCondition(cond)
[17:38:10.478]                 }
[17:38:10.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:10.478]                 "immediateCondition"))) {
[17:38:10.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:10.478]                   ...future.conditions[[length(...future.conditions) + 
[17:38:10.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:10.478]                   if (TRUE && !signal) {
[17:38:10.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.478]                     {
[17:38:10.478]                       inherits <- base::inherits
[17:38:10.478]                       invokeRestart <- base::invokeRestart
[17:38:10.478]                       is.null <- base::is.null
[17:38:10.478]                       muffled <- FALSE
[17:38:10.478]                       if (inherits(cond, "message")) {
[17:38:10.478]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:10.478]                         if (muffled) 
[17:38:10.478]                           invokeRestart("muffleMessage")
[17:38:10.478]                       }
[17:38:10.478]                       else if (inherits(cond, "warning")) {
[17:38:10.478]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:10.478]                         if (muffled) 
[17:38:10.478]                           invokeRestart("muffleWarning")
[17:38:10.478]                       }
[17:38:10.478]                       else if (inherits(cond, "condition")) {
[17:38:10.478]                         if (!is.null(pattern)) {
[17:38:10.478]                           computeRestarts <- base::computeRestarts
[17:38:10.478]                           grepl <- base::grepl
[17:38:10.478]                           restarts <- computeRestarts(cond)
[17:38:10.478]                           for (restart in restarts) {
[17:38:10.478]                             name <- restart$name
[17:38:10.478]                             if (is.null(name)) 
[17:38:10.478]                               next
[17:38:10.478]                             if (!grepl(pattern, name)) 
[17:38:10.478]                               next
[17:38:10.478]                             invokeRestart(restart)
[17:38:10.478]                             muffled <- TRUE
[17:38:10.478]                             break
[17:38:10.478]                           }
[17:38:10.478]                         }
[17:38:10.478]                       }
[17:38:10.478]                       invisible(muffled)
[17:38:10.478]                     }
[17:38:10.478]                     muffleCondition(cond, pattern = "^muffle")
[17:38:10.478]                   }
[17:38:10.478]                 }
[17:38:10.478]                 else {
[17:38:10.478]                   if (TRUE) {
[17:38:10.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.478]                     {
[17:38:10.478]                       inherits <- base::inherits
[17:38:10.478]                       invokeRestart <- base::invokeRestart
[17:38:10.478]                       is.null <- base::is.null
[17:38:10.478]                       muffled <- FALSE
[17:38:10.478]                       if (inherits(cond, "message")) {
[17:38:10.478]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:10.478]                         if (muffled) 
[17:38:10.478]                           invokeRestart("muffleMessage")
[17:38:10.478]                       }
[17:38:10.478]                       else if (inherits(cond, "warning")) {
[17:38:10.478]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:10.478]                         if (muffled) 
[17:38:10.478]                           invokeRestart("muffleWarning")
[17:38:10.478]                       }
[17:38:10.478]                       else if (inherits(cond, "condition")) {
[17:38:10.478]                         if (!is.null(pattern)) {
[17:38:10.478]                           computeRestarts <- base::computeRestarts
[17:38:10.478]                           grepl <- base::grepl
[17:38:10.478]                           restarts <- computeRestarts(cond)
[17:38:10.478]                           for (restart in restarts) {
[17:38:10.478]                             name <- restart$name
[17:38:10.478]                             if (is.null(name)) 
[17:38:10.478]                               next
[17:38:10.478]                             if (!grepl(pattern, name)) 
[17:38:10.478]                               next
[17:38:10.478]                             invokeRestart(restart)
[17:38:10.478]                             muffled <- TRUE
[17:38:10.478]                             break
[17:38:10.478]                           }
[17:38:10.478]                         }
[17:38:10.478]                       }
[17:38:10.478]                       invisible(muffled)
[17:38:10.478]                     }
[17:38:10.478]                     muffleCondition(cond, pattern = "^muffle")
[17:38:10.478]                   }
[17:38:10.478]                 }
[17:38:10.478]             }
[17:38:10.478]         }))
[17:38:10.478]     }, error = function(ex) {
[17:38:10.478]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:10.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:10.478]                 ...future.rng), started = ...future.startTime, 
[17:38:10.478]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:10.478]             version = "1.8"), class = "FutureResult")
[17:38:10.478]     }, finally = {
[17:38:10.478]         if (!identical(...future.workdir, getwd())) 
[17:38:10.478]             setwd(...future.workdir)
[17:38:10.478]         {
[17:38:10.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:10.478]                 ...future.oldOptions$nwarnings <- NULL
[17:38:10.478]             }
[17:38:10.478]             base::options(...future.oldOptions)
[17:38:10.478]             if (.Platform$OS.type == "windows") {
[17:38:10.478]                 old_names <- names(...future.oldEnvVars)
[17:38:10.478]                 envs <- base::Sys.getenv()
[17:38:10.478]                 names <- names(envs)
[17:38:10.478]                 common <- intersect(names, old_names)
[17:38:10.478]                 added <- setdiff(names, old_names)
[17:38:10.478]                 removed <- setdiff(old_names, names)
[17:38:10.478]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:10.478]                   envs[common]]
[17:38:10.478]                 NAMES <- toupper(changed)
[17:38:10.478]                 args <- list()
[17:38:10.478]                 for (kk in seq_along(NAMES)) {
[17:38:10.478]                   name <- changed[[kk]]
[17:38:10.478]                   NAME <- NAMES[[kk]]
[17:38:10.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.478]                     next
[17:38:10.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:10.478]                 }
[17:38:10.478]                 NAMES <- toupper(added)
[17:38:10.478]                 for (kk in seq_along(NAMES)) {
[17:38:10.478]                   name <- added[[kk]]
[17:38:10.478]                   NAME <- NAMES[[kk]]
[17:38:10.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.478]                     next
[17:38:10.478]                   args[[name]] <- ""
[17:38:10.478]                 }
[17:38:10.478]                 NAMES <- toupper(removed)
[17:38:10.478]                 for (kk in seq_along(NAMES)) {
[17:38:10.478]                   name <- removed[[kk]]
[17:38:10.478]                   NAME <- NAMES[[kk]]
[17:38:10.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.478]                     next
[17:38:10.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:10.478]                 }
[17:38:10.478]                 if (length(args) > 0) 
[17:38:10.478]                   base::do.call(base::Sys.setenv, args = args)
[17:38:10.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:10.478]             }
[17:38:10.478]             else {
[17:38:10.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:10.478]             }
[17:38:10.478]             {
[17:38:10.478]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:10.478]                   0L) {
[17:38:10.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:10.478]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:10.478]                   base::options(opts)
[17:38:10.478]                 }
[17:38:10.478]                 {
[17:38:10.478]                   {
[17:38:10.478]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:10.478]                     NULL
[17:38:10.478]                   }
[17:38:10.478]                   options(future.plan = NULL)
[17:38:10.478]                   if (is.na(NA_character_)) 
[17:38:10.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:10.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:10.478]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:10.478]                     .init = FALSE)
[17:38:10.478]                 }
[17:38:10.478]             }
[17:38:10.478]         }
[17:38:10.478]     })
[17:38:10.478]     if (TRUE) {
[17:38:10.478]         base::sink(type = "output", split = FALSE)
[17:38:10.478]         if (TRUE) {
[17:38:10.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:10.478]         }
[17:38:10.478]         else {
[17:38:10.478]             ...future.result["stdout"] <- base::list(NULL)
[17:38:10.478]         }
[17:38:10.478]         base::close(...future.stdout)
[17:38:10.478]         ...future.stdout <- NULL
[17:38:10.478]     }
[17:38:10.478]     ...future.result$conditions <- ...future.conditions
[17:38:10.478]     ...future.result$finished <- base::Sys.time()
[17:38:10.478]     ...future.result
[17:38:10.478] }
[17:38:10.534] Exporting 11 global objects (92.00 KiB) to cluster node #2 ...
[17:38:10.534] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:38:10.539] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:38:10.539] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[17:38:10.539] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[17:38:10.539] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:38:10.540] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:38:10.540] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:38:10.581] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:38:10.581] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:38:10.625] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:38:10.625] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:38:10.625] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:38:10.626] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ...
[17:38:10.626] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ... DONE
[17:38:10.626] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:10.627] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:10.627] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ...
[17:38:10.627] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ... DONE
[17:38:10.627] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:10.628] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:10.628] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:10.628] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:10.628] Exporting 11 global objects (92.00 KiB) to cluster node #2 ... DONE
[17:38:10.629] MultisessionFuture started
[17:38:10.629] - Launch lazy future ... done
[17:38:10.629] run() for ‘MultisessionFuture’ ... done
[17:38:10.632] Created future:
[17:38:10.632] MultisessionFuture:
[17:38:10.632] Label: ‘future_vapply-2’
[17:38:10.632] Expression:
[17:38:10.632] {
[17:38:10.632]     do.call(function(...) {
[17:38:10.632]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:10.632]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:10.632]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:10.632]             on.exit(options(oopts), add = TRUE)
[17:38:10.632]         }
[17:38:10.632]         {
[17:38:10.632]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:10.632]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:10.632]                 ...future.FUN(...future.X_jj, ...)
[17:38:10.632]             })
[17:38:10.632]         }
[17:38:10.632]     }, args = future.call.arguments)
[17:38:10.632] }
[17:38:10.632] Lazy evaluation: FALSE
[17:38:10.632] Asynchronous evaluation: TRUE
[17:38:10.632] Local evaluation: TRUE
[17:38:10.632] Environment: R_GlobalEnv
[17:38:10.632] Capture standard output: TRUE
[17:38:10.632] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:10.632] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:10.632] Packages: 1 packages (‘future.apply’)
[17:38:10.632] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:10.632] Resolved: FALSE
[17:38:10.632] Value: <not collected>
[17:38:10.632] Conditions captured: <none>
[17:38:10.632] Early signaling: FALSE
[17:38:10.632] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:10.632] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:10.643] Chunk #2 of 2 ... DONE
[17:38:10.644] Launching 2 futures (chunks) ... DONE
[17:38:10.644] Resolving 2 futures (chunks) ...
[17:38:10.644] resolve() on list ...
[17:38:10.644]  recursive: 0
[17:38:10.644]  length: 2
[17:38:10.644] 
[17:38:10.644] receiveMessageFromWorker() for ClusterFuture ...
[17:38:10.645] - Validating connection of MultisessionFuture
[17:38:10.645] - received message: FutureResult
[17:38:10.645] - Received FutureResult
[17:38:10.645] - Erased future from FutureRegistry
[17:38:10.645] result() for ClusterFuture ...
[17:38:10.645] - result already collected: FutureResult
[17:38:10.645] result() for ClusterFuture ... done
[17:38:10.645] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:10.645] Future #1
[17:38:10.645] result() for ClusterFuture ...
[17:38:10.646] - result already collected: FutureResult
[17:38:10.646] result() for ClusterFuture ... done
[17:38:10.646] result() for ClusterFuture ...
[17:38:10.646] - result already collected: FutureResult
[17:38:10.646] result() for ClusterFuture ... done
[17:38:10.646] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:10.646] - nx: 2
[17:38:10.646] - relay: TRUE
[17:38:10.646] - stdout: TRUE
[17:38:10.646] - signal: TRUE
[17:38:10.646] - resignal: FALSE
[17:38:10.646] - force: TRUE
[17:38:10.647] - relayed: [n=2] FALSE, FALSE
[17:38:10.647] - queued futures: [n=2] FALSE, FALSE
[17:38:10.647]  - until=1
[17:38:10.647]  - relaying element #1
[17:38:10.647] result() for ClusterFuture ...
[17:38:10.647] - result already collected: FutureResult
[17:38:10.647] result() for ClusterFuture ... done
[17:38:10.647] result() for ClusterFuture ...
[17:38:10.647] - result already collected: FutureResult
[17:38:10.647] result() for ClusterFuture ... done
[17:38:10.647] result() for ClusterFuture ...
[17:38:10.648] - result already collected: FutureResult
[17:38:10.648] result() for ClusterFuture ... done
[17:38:10.648] result() for ClusterFuture ...
[17:38:10.648] - result already collected: FutureResult
[17:38:10.648] result() for ClusterFuture ... done
[17:38:10.648] - relayed: [n=2] TRUE, FALSE
[17:38:10.648] - queued futures: [n=2] TRUE, FALSE
[17:38:10.648] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:10.648]  length: 1 (resolved future 1)
[17:38:10.715] receiveMessageFromWorker() for ClusterFuture ...
[17:38:10.715] - Validating connection of MultisessionFuture
[17:38:10.715] - received message: FutureResult
[17:38:10.715] - Received FutureResult
[17:38:10.715] - Erased future from FutureRegistry
[17:38:10.716] result() for ClusterFuture ...
[17:38:10.716] - result already collected: FutureResult
[17:38:10.716] result() for ClusterFuture ... done
[17:38:10.716] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:10.716] Future #2
[17:38:10.716] result() for ClusterFuture ...
[17:38:10.716] - result already collected: FutureResult
[17:38:10.716] result() for ClusterFuture ... done
[17:38:10.716] result() for ClusterFuture ...
[17:38:10.716] - result already collected: FutureResult
[17:38:10.717] result() for ClusterFuture ... done
[17:38:10.717] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:10.717] - nx: 2
[17:38:10.717] - relay: TRUE
[17:38:10.717] - stdout: TRUE
[17:38:10.717] - signal: TRUE
[17:38:10.717] - resignal: FALSE
[17:38:10.717] - force: TRUE
[17:38:10.717] - relayed: [n=2] TRUE, FALSE
[17:38:10.717] - queued futures: [n=2] TRUE, FALSE
[17:38:10.717]  - until=2
[17:38:10.718]  - relaying element #2
[17:38:10.718] result() for ClusterFuture ...
[17:38:10.718] - result already collected: FutureResult
[17:38:10.718] result() for ClusterFuture ... done
[17:38:10.718] result() for ClusterFuture ...
[17:38:10.718] - result already collected: FutureResult
[17:38:10.718] result() for ClusterFuture ... done
[17:38:10.718] result() for ClusterFuture ...
[17:38:10.718] - result already collected: FutureResult
[17:38:10.718] result() for ClusterFuture ... done
[17:38:10.718] result() for ClusterFuture ...
[17:38:10.718] - result already collected: FutureResult
[17:38:10.719] result() for ClusterFuture ... done
[17:38:10.719] - relayed: [n=2] TRUE, TRUE
[17:38:10.719] - queued futures: [n=2] TRUE, TRUE
[17:38:10.719] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:10.719]  length: 0 (resolved future 2)
[17:38:10.719] Relaying remaining futures
[17:38:10.719] signalConditionsASAP(NULL, pos=0) ...
[17:38:10.719] - nx: 2
[17:38:10.719] - relay: TRUE
[17:38:10.719] - stdout: TRUE
[17:38:10.719] - signal: TRUE
[17:38:10.719] - resignal: FALSE
[17:38:10.720] - force: TRUE
[17:38:10.720] - relayed: [n=2] TRUE, TRUE
[17:38:10.720] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:10.720] - relayed: [n=2] TRUE, TRUE
[17:38:10.720] - queued futures: [n=2] TRUE, TRUE
[17:38:10.720] signalConditionsASAP(NULL, pos=0) ... done
[17:38:10.720] resolve() on list ... DONE
[17:38:10.720] result() for ClusterFuture ...
[17:38:10.720] - result already collected: FutureResult
[17:38:10.720] result() for ClusterFuture ... done
[17:38:10.721] result() for ClusterFuture ...
[17:38:10.721] - result already collected: FutureResult
[17:38:10.721] result() for ClusterFuture ... done
[17:38:10.721] result() for ClusterFuture ...
[17:38:10.721] - result already collected: FutureResult
[17:38:10.721] result() for ClusterFuture ... done
[17:38:10.721] result() for ClusterFuture ...
[17:38:10.721] - result already collected: FutureResult
[17:38:10.721] result() for ClusterFuture ... done
[17:38:10.721]  - Number of value chunks collected: 2
[17:38:10.721] Resolving 2 futures (chunks) ... DONE
[17:38:10.722] Reducing values from 2 chunks ...
[17:38:10.722]  - Number of values collected after concatenation: 2
[17:38:10.722]  - Number of values expected: 2
[17:38:10.722] Reducing values from 2 chunks ... DONE
[17:38:10.722] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[17:38:10.723] future_lapply() ...
[17:38:10.728] Number of chunks: 2
[17:38:10.728] getGlobalsAndPackagesXApply() ...
[17:38:10.729]  - future.globals: TRUE
[17:38:10.729] getGlobalsAndPackages() ...
[17:38:10.729] Searching for globals...
[17:38:10.732] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[17:38:10.732] Searching for globals ... DONE
[17:38:10.733] Resolving globals: FALSE
[17:38:10.733] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[17:38:10.734] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:10.734] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:10.734] - packages: [1] ‘future.apply’
[17:38:10.734] getGlobalsAndPackages() ... DONE
[17:38:10.734]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:10.734]  - needed namespaces: [n=1] ‘future.apply’
[17:38:10.735] Finding globals ... DONE
[17:38:10.735]  - use_args: TRUE
[17:38:10.735]  - Getting '...' globals ...
[17:38:10.735] resolve() on list ...
[17:38:10.735]  recursive: 0
[17:38:10.735]  length: 1
[17:38:10.735]  elements: ‘...’
[17:38:10.735]  length: 0 (resolved future 1)
[17:38:10.736] resolve() on list ... DONE
[17:38:10.736]    - '...' content: [n=0] 
[17:38:10.736] List of 1
[17:38:10.736]  $ ...: list()
[17:38:10.736]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:10.736]  - attr(*, "where")=List of 1
[17:38:10.736]   ..$ ...:<environment: 0x560801126758> 
[17:38:10.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:10.736]  - attr(*, "resolved")= logi TRUE
[17:38:10.736]  - attr(*, "total_size")= num NA
[17:38:10.738]  - Getting '...' globals ... DONE
[17:38:10.738] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:10.739] List of 8
[17:38:10.739]  $ ...future.FUN:function (x, ...)  
[17:38:10.739]  $ x_FUN        :function (x)  
[17:38:10.739]  $ times        : int 0
[17:38:10.739]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:10.739]  $ stop_if_not  :function (...)  
[17:38:10.739]  $ dim          : NULL
[17:38:10.739]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:10.739]  $ ...          : list()
[17:38:10.739]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:10.739]  - attr(*, "where")=List of 8
[17:38:10.739]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:10.739]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:10.739]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:10.739]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:10.739]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:10.739]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:10.739]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:10.739]   ..$ ...          :<environment: 0x560801126758> 
[17:38:10.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:10.739]  - attr(*, "resolved")= logi FALSE
[17:38:10.739]  - attr(*, "total_size")= num 95472
[17:38:10.744] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:10.744] getGlobalsAndPackagesXApply() ... DONE
[17:38:10.744] Number of futures (= number of chunks): 2
[17:38:10.744] Launching 2 futures (chunks) ...
[17:38:10.744] Chunk #1 of 2 ...
[17:38:10.744]  - Finding globals in 'X' for chunk #1 ...
[17:38:10.744] getGlobalsAndPackages() ...
[17:38:10.745] Searching for globals...
[17:38:10.745] 
[17:38:10.745] Searching for globals ... DONE
[17:38:10.745] - globals: [0] <none>
[17:38:10.745] getGlobalsAndPackages() ... DONE
[17:38:10.745]    + additional globals found: [n=0] 
[17:38:10.745]    + additional namespaces needed: [n=0] 
[17:38:10.745]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:10.745]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:10.746]  - seeds: <none>
[17:38:10.746]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:10.746] getGlobalsAndPackages() ...
[17:38:10.746] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:10.746] Resolving globals: FALSE
[17:38:10.746] Tweak future expression to call with '...' arguments ...
[17:38:10.746] {
[17:38:10.746]     do.call(function(...) {
[17:38:10.746]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:10.746]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:10.746]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:10.746]             on.exit(options(oopts), add = TRUE)
[17:38:10.746]         }
[17:38:10.746]         {
[17:38:10.746]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:10.746]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:10.746]                 ...future.FUN(...future.X_jj, ...)
[17:38:10.746]             })
[17:38:10.746]         }
[17:38:10.746]     }, args = future.call.arguments)
[17:38:10.746] }
[17:38:10.746] Tweak future expression to call with '...' arguments ... DONE
[17:38:10.747] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:10.747] - packages: [1] ‘future.apply’
[17:38:10.747] getGlobalsAndPackages() ... DONE
[17:38:10.747] run() for ‘Future’ ...
[17:38:10.748] - state: ‘created’
[17:38:10.748] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:10.762] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:10.762] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:10.762]   - Field: ‘node’
[17:38:10.762]   - Field: ‘label’
[17:38:10.762]   - Field: ‘local’
[17:38:10.763]   - Field: ‘owner’
[17:38:10.763]   - Field: ‘envir’
[17:38:10.763]   - Field: ‘workers’
[17:38:10.763]   - Field: ‘packages’
[17:38:10.763]   - Field: ‘gc’
[17:38:10.763]   - Field: ‘conditions’
[17:38:10.763]   - Field: ‘persistent’
[17:38:10.763]   - Field: ‘expr’
[17:38:10.763]   - Field: ‘uuid’
[17:38:10.763]   - Field: ‘seed’
[17:38:10.763]   - Field: ‘version’
[17:38:10.764]   - Field: ‘result’
[17:38:10.764]   - Field: ‘asynchronous’
[17:38:10.764]   - Field: ‘calls’
[17:38:10.764]   - Field: ‘globals’
[17:38:10.764]   - Field: ‘stdout’
[17:38:10.764]   - Field: ‘earlySignal’
[17:38:10.764]   - Field: ‘lazy’
[17:38:10.764]   - Field: ‘state’
[17:38:10.764] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:10.764] - Launch lazy future ...
[17:38:10.765] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:10.765] Packages needed by future strategies (n = 0): <none>
[17:38:10.765] {
[17:38:10.765]     {
[17:38:10.765]         {
[17:38:10.765]             ...future.startTime <- base::Sys.time()
[17:38:10.765]             {
[17:38:10.765]                 {
[17:38:10.765]                   {
[17:38:10.765]                     {
[17:38:10.765]                       {
[17:38:10.765]                         base::local({
[17:38:10.765]                           has_future <- base::requireNamespace("future", 
[17:38:10.765]                             quietly = TRUE)
[17:38:10.765]                           if (has_future) {
[17:38:10.765]                             ns <- base::getNamespace("future")
[17:38:10.765]                             version <- ns[[".package"]][["version"]]
[17:38:10.765]                             if (is.null(version)) 
[17:38:10.765]                               version <- utils::packageVersion("future")
[17:38:10.765]                           }
[17:38:10.765]                           else {
[17:38:10.765]                             version <- NULL
[17:38:10.765]                           }
[17:38:10.765]                           if (!has_future || version < "1.8.0") {
[17:38:10.765]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:10.765]                               "", base::R.version$version.string), 
[17:38:10.765]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:10.765]                                 base::R.version$platform, 8 * 
[17:38:10.765]                                   base::.Machine$sizeof.pointer), 
[17:38:10.765]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:10.765]                                 "release", "version")], collapse = " "), 
[17:38:10.765]                               hostname = base::Sys.info()[["nodename"]])
[17:38:10.765]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:10.765]                               info)
[17:38:10.765]                             info <- base::paste(info, collapse = "; ")
[17:38:10.765]                             if (!has_future) {
[17:38:10.765]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:10.765]                                 info)
[17:38:10.765]                             }
[17:38:10.765]                             else {
[17:38:10.765]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:10.765]                                 info, version)
[17:38:10.765]                             }
[17:38:10.765]                             base::stop(msg)
[17:38:10.765]                           }
[17:38:10.765]                         })
[17:38:10.765]                       }
[17:38:10.765]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:10.765]                       base::options(mc.cores = 1L)
[17:38:10.765]                     }
[17:38:10.765]                     base::local({
[17:38:10.765]                       for (pkg in "future.apply") {
[17:38:10.765]                         base::loadNamespace(pkg)
[17:38:10.765]                         base::library(pkg, character.only = TRUE)
[17:38:10.765]                       }
[17:38:10.765]                     })
[17:38:10.765]                   }
[17:38:10.765]                   ...future.strategy.old <- future::plan("list")
[17:38:10.765]                   options(future.plan = NULL)
[17:38:10.765]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:10.765]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:10.765]                 }
[17:38:10.765]                 ...future.workdir <- getwd()
[17:38:10.765]             }
[17:38:10.765]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:10.765]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:10.765]         }
[17:38:10.765]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:10.765]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:10.765]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:10.765]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:10.765]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:10.765]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:10.765]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:10.765]             base::names(...future.oldOptions))
[17:38:10.765]     }
[17:38:10.765]     if (FALSE) {
[17:38:10.765]     }
[17:38:10.765]     else {
[17:38:10.765]         if (TRUE) {
[17:38:10.765]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:10.765]                 open = "w")
[17:38:10.765]         }
[17:38:10.765]         else {
[17:38:10.765]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:10.765]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:10.765]         }
[17:38:10.765]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:10.765]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:10.765]             base::sink(type = "output", split = FALSE)
[17:38:10.765]             base::close(...future.stdout)
[17:38:10.765]         }, add = TRUE)
[17:38:10.765]     }
[17:38:10.765]     ...future.frame <- base::sys.nframe()
[17:38:10.765]     ...future.conditions <- base::list()
[17:38:10.765]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:10.765]     if (FALSE) {
[17:38:10.765]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:10.765]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:10.765]     }
[17:38:10.765]     ...future.result <- base::tryCatch({
[17:38:10.765]         base::withCallingHandlers({
[17:38:10.765]             ...future.value <- base::withVisible(base::local({
[17:38:10.765]                 ...future.makeSendCondition <- base::local({
[17:38:10.765]                   sendCondition <- NULL
[17:38:10.765]                   function(frame = 1L) {
[17:38:10.765]                     if (is.function(sendCondition)) 
[17:38:10.765]                       return(sendCondition)
[17:38:10.765]                     ns <- getNamespace("parallel")
[17:38:10.765]                     if (exists("sendData", mode = "function", 
[17:38:10.765]                       envir = ns)) {
[17:38:10.765]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:10.765]                         envir = ns)
[17:38:10.765]                       envir <- sys.frame(frame)
[17:38:10.765]                       master <- NULL
[17:38:10.765]                       while (!identical(envir, .GlobalEnv) && 
[17:38:10.765]                         !identical(envir, emptyenv())) {
[17:38:10.765]                         if (exists("master", mode = "list", envir = envir, 
[17:38:10.765]                           inherits = FALSE)) {
[17:38:10.765]                           master <- get("master", mode = "list", 
[17:38:10.765]                             envir = envir, inherits = FALSE)
[17:38:10.765]                           if (inherits(master, c("SOCKnode", 
[17:38:10.765]                             "SOCK0node"))) {
[17:38:10.765]                             sendCondition <<- function(cond) {
[17:38:10.765]                               data <- list(type = "VALUE", value = cond, 
[17:38:10.765]                                 success = TRUE)
[17:38:10.765]                               parallel_sendData(master, data)
[17:38:10.765]                             }
[17:38:10.765]                             return(sendCondition)
[17:38:10.765]                           }
[17:38:10.765]                         }
[17:38:10.765]                         frame <- frame + 1L
[17:38:10.765]                         envir <- sys.frame(frame)
[17:38:10.765]                       }
[17:38:10.765]                     }
[17:38:10.765]                     sendCondition <<- function(cond) NULL
[17:38:10.765]                   }
[17:38:10.765]                 })
[17:38:10.765]                 withCallingHandlers({
[17:38:10.765]                   {
[17:38:10.765]                     do.call(function(...) {
[17:38:10.765]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:10.765]                       if (!identical(...future.globals.maxSize.org, 
[17:38:10.765]                         ...future.globals.maxSize)) {
[17:38:10.765]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:10.765]                         on.exit(options(oopts), add = TRUE)
[17:38:10.765]                       }
[17:38:10.765]                       {
[17:38:10.765]                         lapply(seq_along(...future.elements_ii), 
[17:38:10.765]                           FUN = function(jj) {
[17:38:10.765]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:10.765]                             ...future.FUN(...future.X_jj, ...)
[17:38:10.765]                           })
[17:38:10.765]                       }
[17:38:10.765]                     }, args = future.call.arguments)
[17:38:10.765]                   }
[17:38:10.765]                 }, immediateCondition = function(cond) {
[17:38:10.765]                   sendCondition <- ...future.makeSendCondition()
[17:38:10.765]                   sendCondition(cond)
[17:38:10.765]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.765]                   {
[17:38:10.765]                     inherits <- base::inherits
[17:38:10.765]                     invokeRestart <- base::invokeRestart
[17:38:10.765]                     is.null <- base::is.null
[17:38:10.765]                     muffled <- FALSE
[17:38:10.765]                     if (inherits(cond, "message")) {
[17:38:10.765]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:10.765]                       if (muffled) 
[17:38:10.765]                         invokeRestart("muffleMessage")
[17:38:10.765]                     }
[17:38:10.765]                     else if (inherits(cond, "warning")) {
[17:38:10.765]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:10.765]                       if (muffled) 
[17:38:10.765]                         invokeRestart("muffleWarning")
[17:38:10.765]                     }
[17:38:10.765]                     else if (inherits(cond, "condition")) {
[17:38:10.765]                       if (!is.null(pattern)) {
[17:38:10.765]                         computeRestarts <- base::computeRestarts
[17:38:10.765]                         grepl <- base::grepl
[17:38:10.765]                         restarts <- computeRestarts(cond)
[17:38:10.765]                         for (restart in restarts) {
[17:38:10.765]                           name <- restart$name
[17:38:10.765]                           if (is.null(name)) 
[17:38:10.765]                             next
[17:38:10.765]                           if (!grepl(pattern, name)) 
[17:38:10.765]                             next
[17:38:10.765]                           invokeRestart(restart)
[17:38:10.765]                           muffled <- TRUE
[17:38:10.765]                           break
[17:38:10.765]                         }
[17:38:10.765]                       }
[17:38:10.765]                     }
[17:38:10.765]                     invisible(muffled)
[17:38:10.765]                   }
[17:38:10.765]                   muffleCondition(cond)
[17:38:10.765]                 })
[17:38:10.765]             }))
[17:38:10.765]             future::FutureResult(value = ...future.value$value, 
[17:38:10.765]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:10.765]                   ...future.rng), globalenv = if (FALSE) 
[17:38:10.765]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:10.765]                     ...future.globalenv.names))
[17:38:10.765]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:10.765]         }, condition = base::local({
[17:38:10.765]             c <- base::c
[17:38:10.765]             inherits <- base::inherits
[17:38:10.765]             invokeRestart <- base::invokeRestart
[17:38:10.765]             length <- base::length
[17:38:10.765]             list <- base::list
[17:38:10.765]             seq.int <- base::seq.int
[17:38:10.765]             signalCondition <- base::signalCondition
[17:38:10.765]             sys.calls <- base::sys.calls
[17:38:10.765]             `[[` <- base::`[[`
[17:38:10.765]             `+` <- base::`+`
[17:38:10.765]             `<<-` <- base::`<<-`
[17:38:10.765]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:10.765]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:10.765]                   3L)]
[17:38:10.765]             }
[17:38:10.765]             function(cond) {
[17:38:10.765]                 is_error <- inherits(cond, "error")
[17:38:10.765]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:10.765]                   NULL)
[17:38:10.765]                 if (is_error) {
[17:38:10.765]                   sessionInformation <- function() {
[17:38:10.765]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:10.765]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:10.765]                       search = base::search(), system = base::Sys.info())
[17:38:10.765]                   }
[17:38:10.765]                   ...future.conditions[[length(...future.conditions) + 
[17:38:10.765]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:10.765]                     cond$call), session = sessionInformation(), 
[17:38:10.765]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:10.765]                   signalCondition(cond)
[17:38:10.765]                 }
[17:38:10.765]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:10.765]                 "immediateCondition"))) {
[17:38:10.765]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:10.765]                   ...future.conditions[[length(...future.conditions) + 
[17:38:10.765]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:10.765]                   if (TRUE && !signal) {
[17:38:10.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.765]                     {
[17:38:10.765]                       inherits <- base::inherits
[17:38:10.765]                       invokeRestart <- base::invokeRestart
[17:38:10.765]                       is.null <- base::is.null
[17:38:10.765]                       muffled <- FALSE
[17:38:10.765]                       if (inherits(cond, "message")) {
[17:38:10.765]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:10.765]                         if (muffled) 
[17:38:10.765]                           invokeRestart("muffleMessage")
[17:38:10.765]                       }
[17:38:10.765]                       else if (inherits(cond, "warning")) {
[17:38:10.765]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:10.765]                         if (muffled) 
[17:38:10.765]                           invokeRestart("muffleWarning")
[17:38:10.765]                       }
[17:38:10.765]                       else if (inherits(cond, "condition")) {
[17:38:10.765]                         if (!is.null(pattern)) {
[17:38:10.765]                           computeRestarts <- base::computeRestarts
[17:38:10.765]                           grepl <- base::grepl
[17:38:10.765]                           restarts <- computeRestarts(cond)
[17:38:10.765]                           for (restart in restarts) {
[17:38:10.765]                             name <- restart$name
[17:38:10.765]                             if (is.null(name)) 
[17:38:10.765]                               next
[17:38:10.765]                             if (!grepl(pattern, name)) 
[17:38:10.765]                               next
[17:38:10.765]                             invokeRestart(restart)
[17:38:10.765]                             muffled <- TRUE
[17:38:10.765]                             break
[17:38:10.765]                           }
[17:38:10.765]                         }
[17:38:10.765]                       }
[17:38:10.765]                       invisible(muffled)
[17:38:10.765]                     }
[17:38:10.765]                     muffleCondition(cond, pattern = "^muffle")
[17:38:10.765]                   }
[17:38:10.765]                 }
[17:38:10.765]                 else {
[17:38:10.765]                   if (TRUE) {
[17:38:10.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.765]                     {
[17:38:10.765]                       inherits <- base::inherits
[17:38:10.765]                       invokeRestart <- base::invokeRestart
[17:38:10.765]                       is.null <- base::is.null
[17:38:10.765]                       muffled <- FALSE
[17:38:10.765]                       if (inherits(cond, "message")) {
[17:38:10.765]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:10.765]                         if (muffled) 
[17:38:10.765]                           invokeRestart("muffleMessage")
[17:38:10.765]                       }
[17:38:10.765]                       else if (inherits(cond, "warning")) {
[17:38:10.765]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:10.765]                         if (muffled) 
[17:38:10.765]                           invokeRestart("muffleWarning")
[17:38:10.765]                       }
[17:38:10.765]                       else if (inherits(cond, "condition")) {
[17:38:10.765]                         if (!is.null(pattern)) {
[17:38:10.765]                           computeRestarts <- base::computeRestarts
[17:38:10.765]                           grepl <- base::grepl
[17:38:10.765]                           restarts <- computeRestarts(cond)
[17:38:10.765]                           for (restart in restarts) {
[17:38:10.765]                             name <- restart$name
[17:38:10.765]                             if (is.null(name)) 
[17:38:10.765]                               next
[17:38:10.765]                             if (!grepl(pattern, name)) 
[17:38:10.765]                               next
[17:38:10.765]                             invokeRestart(restart)
[17:38:10.765]                             muffled <- TRUE
[17:38:10.765]                             break
[17:38:10.765]                           }
[17:38:10.765]                         }
[17:38:10.765]                       }
[17:38:10.765]                       invisible(muffled)
[17:38:10.765]                     }
[17:38:10.765]                     muffleCondition(cond, pattern = "^muffle")
[17:38:10.765]                   }
[17:38:10.765]                 }
[17:38:10.765]             }
[17:38:10.765]         }))
[17:38:10.765]     }, error = function(ex) {
[17:38:10.765]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:10.765]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:10.765]                 ...future.rng), started = ...future.startTime, 
[17:38:10.765]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:10.765]             version = "1.8"), class = "FutureResult")
[17:38:10.765]     }, finally = {
[17:38:10.765]         if (!identical(...future.workdir, getwd())) 
[17:38:10.765]             setwd(...future.workdir)
[17:38:10.765]         {
[17:38:10.765]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:10.765]                 ...future.oldOptions$nwarnings <- NULL
[17:38:10.765]             }
[17:38:10.765]             base::options(...future.oldOptions)
[17:38:10.765]             if (.Platform$OS.type == "windows") {
[17:38:10.765]                 old_names <- names(...future.oldEnvVars)
[17:38:10.765]                 envs <- base::Sys.getenv()
[17:38:10.765]                 names <- names(envs)
[17:38:10.765]                 common <- intersect(names, old_names)
[17:38:10.765]                 added <- setdiff(names, old_names)
[17:38:10.765]                 removed <- setdiff(old_names, names)
[17:38:10.765]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:10.765]                   envs[common]]
[17:38:10.765]                 NAMES <- toupper(changed)
[17:38:10.765]                 args <- list()
[17:38:10.765]                 for (kk in seq_along(NAMES)) {
[17:38:10.765]                   name <- changed[[kk]]
[17:38:10.765]                   NAME <- NAMES[[kk]]
[17:38:10.765]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.765]                     next
[17:38:10.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:10.765]                 }
[17:38:10.765]                 NAMES <- toupper(added)
[17:38:10.765]                 for (kk in seq_along(NAMES)) {
[17:38:10.765]                   name <- added[[kk]]
[17:38:10.765]                   NAME <- NAMES[[kk]]
[17:38:10.765]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.765]                     next
[17:38:10.765]                   args[[name]] <- ""
[17:38:10.765]                 }
[17:38:10.765]                 NAMES <- toupper(removed)
[17:38:10.765]                 for (kk in seq_along(NAMES)) {
[17:38:10.765]                   name <- removed[[kk]]
[17:38:10.765]                   NAME <- NAMES[[kk]]
[17:38:10.765]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.765]                     next
[17:38:10.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:10.765]                 }
[17:38:10.765]                 if (length(args) > 0) 
[17:38:10.765]                   base::do.call(base::Sys.setenv, args = args)
[17:38:10.765]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:10.765]             }
[17:38:10.765]             else {
[17:38:10.765]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:10.765]             }
[17:38:10.765]             {
[17:38:10.765]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:10.765]                   0L) {
[17:38:10.765]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:10.765]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:10.765]                   base::options(opts)
[17:38:10.765]                 }
[17:38:10.765]                 {
[17:38:10.765]                   {
[17:38:10.765]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:10.765]                     NULL
[17:38:10.765]                   }
[17:38:10.765]                   options(future.plan = NULL)
[17:38:10.765]                   if (is.na(NA_character_)) 
[17:38:10.765]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:10.765]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:10.765]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:10.765]                     .init = FALSE)
[17:38:10.765]                 }
[17:38:10.765]             }
[17:38:10.765]         }
[17:38:10.765]     })
[17:38:10.765]     if (TRUE) {
[17:38:10.765]         base::sink(type = "output", split = FALSE)
[17:38:10.765]         if (TRUE) {
[17:38:10.765]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:10.765]         }
[17:38:10.765]         else {
[17:38:10.765]             ...future.result["stdout"] <- base::list(NULL)
[17:38:10.765]         }
[17:38:10.765]         base::close(...future.stdout)
[17:38:10.765]         ...future.stdout <- NULL
[17:38:10.765]     }
[17:38:10.765]     ...future.result$conditions <- ...future.conditions
[17:38:10.765]     ...future.result$finished <- base::Sys.time()
[17:38:10.765]     ...future.result
[17:38:10.765] }
[17:38:10.768] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[17:38:10.768] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:38:10.813] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:38:10.813] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[17:38:10.813] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[17:38:10.813] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:38:10.814] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:38:10.814] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:38:10.856] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:38:10.857] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:38:10.901] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:38:10.901] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:38:10.901] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:38:10.901] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:38:10.902] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:38:10.902] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:10.902] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:10.902] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:38:10.903] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:38:10.903] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:10.903] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:10.903] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:10.903] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:10.904] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[17:38:10.904] MultisessionFuture started
[17:38:10.904] - Launch lazy future ... done
[17:38:10.904] run() for ‘MultisessionFuture’ ... done
[17:38:10.904] Created future:
[17:38:10.905] MultisessionFuture:
[17:38:10.905] Label: ‘future_vapply-1’
[17:38:10.905] Expression:
[17:38:10.905] {
[17:38:10.905]     do.call(function(...) {
[17:38:10.905]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:10.905]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:10.905]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:10.905]             on.exit(options(oopts), add = TRUE)
[17:38:10.905]         }
[17:38:10.905]         {
[17:38:10.905]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:10.905]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:10.905]                 ...future.FUN(...future.X_jj, ...)
[17:38:10.905]             })
[17:38:10.905]         }
[17:38:10.905]     }, args = future.call.arguments)
[17:38:10.905] }
[17:38:10.905] Lazy evaluation: FALSE
[17:38:10.905] Asynchronous evaluation: TRUE
[17:38:10.905] Local evaluation: TRUE
[17:38:10.905] Environment: R_GlobalEnv
[17:38:10.905] Capture standard output: TRUE
[17:38:10.905] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:10.905] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:10.905] Packages: 1 packages (‘future.apply’)
[17:38:10.905] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:10.905] Resolved: FALSE
[17:38:10.905] Value: <not collected>
[17:38:10.905] Conditions captured: <none>
[17:38:10.905] Early signaling: FALSE
[17:38:10.905] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:10.905] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:10.916] Chunk #1 of 2 ... DONE
[17:38:10.916] Chunk #2 of 2 ...
[17:38:10.917]  - Finding globals in 'X' for chunk #2 ...
[17:38:10.917] getGlobalsAndPackages() ...
[17:38:10.917] Searching for globals...
[17:38:10.917] 
[17:38:10.917] Searching for globals ... DONE
[17:38:10.917] - globals: [0] <none>
[17:38:10.917] getGlobalsAndPackages() ... DONE
[17:38:10.918]    + additional globals found: [n=0] 
[17:38:10.918]    + additional namespaces needed: [n=0] 
[17:38:10.918]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:10.918]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:10.918]  - seeds: <none>
[17:38:10.918]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:10.918] getGlobalsAndPackages() ...
[17:38:10.918] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:10.918] Resolving globals: FALSE
[17:38:10.918] Tweak future expression to call with '...' arguments ...
[17:38:10.919] {
[17:38:10.919]     do.call(function(...) {
[17:38:10.919]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:10.919]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:10.919]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:10.919]             on.exit(options(oopts), add = TRUE)
[17:38:10.919]         }
[17:38:10.919]         {
[17:38:10.919]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:10.919]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:10.919]                 ...future.FUN(...future.X_jj, ...)
[17:38:10.919]             })
[17:38:10.919]         }
[17:38:10.919]     }, args = future.call.arguments)
[17:38:10.919] }
[17:38:10.919] Tweak future expression to call with '...' arguments ... DONE
[17:38:10.919] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:10.920] - packages: [1] ‘future.apply’
[17:38:10.920] getGlobalsAndPackages() ... DONE
[17:38:10.920] run() for ‘Future’ ...
[17:38:10.920] - state: ‘created’
[17:38:10.920] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:10.934] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:10.934] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:10.935]   - Field: ‘node’
[17:38:10.935]   - Field: ‘label’
[17:38:10.935]   - Field: ‘local’
[17:38:10.935]   - Field: ‘owner’
[17:38:10.935]   - Field: ‘envir’
[17:38:10.935]   - Field: ‘workers’
[17:38:10.935]   - Field: ‘packages’
[17:38:10.935]   - Field: ‘gc’
[17:38:10.935]   - Field: ‘conditions’
[17:38:10.935]   - Field: ‘persistent’
[17:38:10.935]   - Field: ‘expr’
[17:38:10.936]   - Field: ‘uuid’
[17:38:10.936]   - Field: ‘seed’
[17:38:10.936]   - Field: ‘version’
[17:38:10.936]   - Field: ‘result’
[17:38:10.936]   - Field: ‘asynchronous’
[17:38:10.936]   - Field: ‘calls’
[17:38:10.936]   - Field: ‘globals’
[17:38:10.936]   - Field: ‘stdout’
[17:38:10.936]   - Field: ‘earlySignal’
[17:38:10.936]   - Field: ‘lazy’
[17:38:10.937]   - Field: ‘state’
[17:38:10.937] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:10.937] - Launch lazy future ...
[17:38:10.937] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:10.937] Packages needed by future strategies (n = 0): <none>
[17:38:10.938] {
[17:38:10.938]     {
[17:38:10.938]         {
[17:38:10.938]             ...future.startTime <- base::Sys.time()
[17:38:10.938]             {
[17:38:10.938]                 {
[17:38:10.938]                   {
[17:38:10.938]                     {
[17:38:10.938]                       {
[17:38:10.938]                         base::local({
[17:38:10.938]                           has_future <- base::requireNamespace("future", 
[17:38:10.938]                             quietly = TRUE)
[17:38:10.938]                           if (has_future) {
[17:38:10.938]                             ns <- base::getNamespace("future")
[17:38:10.938]                             version <- ns[[".package"]][["version"]]
[17:38:10.938]                             if (is.null(version)) 
[17:38:10.938]                               version <- utils::packageVersion("future")
[17:38:10.938]                           }
[17:38:10.938]                           else {
[17:38:10.938]                             version <- NULL
[17:38:10.938]                           }
[17:38:10.938]                           if (!has_future || version < "1.8.0") {
[17:38:10.938]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:10.938]                               "", base::R.version$version.string), 
[17:38:10.938]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:10.938]                                 base::R.version$platform, 8 * 
[17:38:10.938]                                   base::.Machine$sizeof.pointer), 
[17:38:10.938]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:10.938]                                 "release", "version")], collapse = " "), 
[17:38:10.938]                               hostname = base::Sys.info()[["nodename"]])
[17:38:10.938]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:10.938]                               info)
[17:38:10.938]                             info <- base::paste(info, collapse = "; ")
[17:38:10.938]                             if (!has_future) {
[17:38:10.938]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:10.938]                                 info)
[17:38:10.938]                             }
[17:38:10.938]                             else {
[17:38:10.938]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:10.938]                                 info, version)
[17:38:10.938]                             }
[17:38:10.938]                             base::stop(msg)
[17:38:10.938]                           }
[17:38:10.938]                         })
[17:38:10.938]                       }
[17:38:10.938]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:10.938]                       base::options(mc.cores = 1L)
[17:38:10.938]                     }
[17:38:10.938]                     base::local({
[17:38:10.938]                       for (pkg in "future.apply") {
[17:38:10.938]                         base::loadNamespace(pkg)
[17:38:10.938]                         base::library(pkg, character.only = TRUE)
[17:38:10.938]                       }
[17:38:10.938]                     })
[17:38:10.938]                   }
[17:38:10.938]                   ...future.strategy.old <- future::plan("list")
[17:38:10.938]                   options(future.plan = NULL)
[17:38:10.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:10.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:10.938]                 }
[17:38:10.938]                 ...future.workdir <- getwd()
[17:38:10.938]             }
[17:38:10.938]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:10.938]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:10.938]         }
[17:38:10.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:10.938]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:10.938]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:10.938]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:10.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:10.938]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:10.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:10.938]             base::names(...future.oldOptions))
[17:38:10.938]     }
[17:38:10.938]     if (FALSE) {
[17:38:10.938]     }
[17:38:10.938]     else {
[17:38:10.938]         if (TRUE) {
[17:38:10.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:10.938]                 open = "w")
[17:38:10.938]         }
[17:38:10.938]         else {
[17:38:10.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:10.938]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:10.938]         }
[17:38:10.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:10.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:10.938]             base::sink(type = "output", split = FALSE)
[17:38:10.938]             base::close(...future.stdout)
[17:38:10.938]         }, add = TRUE)
[17:38:10.938]     }
[17:38:10.938]     ...future.frame <- base::sys.nframe()
[17:38:10.938]     ...future.conditions <- base::list()
[17:38:10.938]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:10.938]     if (FALSE) {
[17:38:10.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:10.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:10.938]     }
[17:38:10.938]     ...future.result <- base::tryCatch({
[17:38:10.938]         base::withCallingHandlers({
[17:38:10.938]             ...future.value <- base::withVisible(base::local({
[17:38:10.938]                 ...future.makeSendCondition <- base::local({
[17:38:10.938]                   sendCondition <- NULL
[17:38:10.938]                   function(frame = 1L) {
[17:38:10.938]                     if (is.function(sendCondition)) 
[17:38:10.938]                       return(sendCondition)
[17:38:10.938]                     ns <- getNamespace("parallel")
[17:38:10.938]                     if (exists("sendData", mode = "function", 
[17:38:10.938]                       envir = ns)) {
[17:38:10.938]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:10.938]                         envir = ns)
[17:38:10.938]                       envir <- sys.frame(frame)
[17:38:10.938]                       master <- NULL
[17:38:10.938]                       while (!identical(envir, .GlobalEnv) && 
[17:38:10.938]                         !identical(envir, emptyenv())) {
[17:38:10.938]                         if (exists("master", mode = "list", envir = envir, 
[17:38:10.938]                           inherits = FALSE)) {
[17:38:10.938]                           master <- get("master", mode = "list", 
[17:38:10.938]                             envir = envir, inherits = FALSE)
[17:38:10.938]                           if (inherits(master, c("SOCKnode", 
[17:38:10.938]                             "SOCK0node"))) {
[17:38:10.938]                             sendCondition <<- function(cond) {
[17:38:10.938]                               data <- list(type = "VALUE", value = cond, 
[17:38:10.938]                                 success = TRUE)
[17:38:10.938]                               parallel_sendData(master, data)
[17:38:10.938]                             }
[17:38:10.938]                             return(sendCondition)
[17:38:10.938]                           }
[17:38:10.938]                         }
[17:38:10.938]                         frame <- frame + 1L
[17:38:10.938]                         envir <- sys.frame(frame)
[17:38:10.938]                       }
[17:38:10.938]                     }
[17:38:10.938]                     sendCondition <<- function(cond) NULL
[17:38:10.938]                   }
[17:38:10.938]                 })
[17:38:10.938]                 withCallingHandlers({
[17:38:10.938]                   {
[17:38:10.938]                     do.call(function(...) {
[17:38:10.938]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:10.938]                       if (!identical(...future.globals.maxSize.org, 
[17:38:10.938]                         ...future.globals.maxSize)) {
[17:38:10.938]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:10.938]                         on.exit(options(oopts), add = TRUE)
[17:38:10.938]                       }
[17:38:10.938]                       {
[17:38:10.938]                         lapply(seq_along(...future.elements_ii), 
[17:38:10.938]                           FUN = function(jj) {
[17:38:10.938]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:10.938]                             ...future.FUN(...future.X_jj, ...)
[17:38:10.938]                           })
[17:38:10.938]                       }
[17:38:10.938]                     }, args = future.call.arguments)
[17:38:10.938]                   }
[17:38:10.938]                 }, immediateCondition = function(cond) {
[17:38:10.938]                   sendCondition <- ...future.makeSendCondition()
[17:38:10.938]                   sendCondition(cond)
[17:38:10.938]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.938]                   {
[17:38:10.938]                     inherits <- base::inherits
[17:38:10.938]                     invokeRestart <- base::invokeRestart
[17:38:10.938]                     is.null <- base::is.null
[17:38:10.938]                     muffled <- FALSE
[17:38:10.938]                     if (inherits(cond, "message")) {
[17:38:10.938]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:10.938]                       if (muffled) 
[17:38:10.938]                         invokeRestart("muffleMessage")
[17:38:10.938]                     }
[17:38:10.938]                     else if (inherits(cond, "warning")) {
[17:38:10.938]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:10.938]                       if (muffled) 
[17:38:10.938]                         invokeRestart("muffleWarning")
[17:38:10.938]                     }
[17:38:10.938]                     else if (inherits(cond, "condition")) {
[17:38:10.938]                       if (!is.null(pattern)) {
[17:38:10.938]                         computeRestarts <- base::computeRestarts
[17:38:10.938]                         grepl <- base::grepl
[17:38:10.938]                         restarts <- computeRestarts(cond)
[17:38:10.938]                         for (restart in restarts) {
[17:38:10.938]                           name <- restart$name
[17:38:10.938]                           if (is.null(name)) 
[17:38:10.938]                             next
[17:38:10.938]                           if (!grepl(pattern, name)) 
[17:38:10.938]                             next
[17:38:10.938]                           invokeRestart(restart)
[17:38:10.938]                           muffled <- TRUE
[17:38:10.938]                           break
[17:38:10.938]                         }
[17:38:10.938]                       }
[17:38:10.938]                     }
[17:38:10.938]                     invisible(muffled)
[17:38:10.938]                   }
[17:38:10.938]                   muffleCondition(cond)
[17:38:10.938]                 })
[17:38:10.938]             }))
[17:38:10.938]             future::FutureResult(value = ...future.value$value, 
[17:38:10.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:10.938]                   ...future.rng), globalenv = if (FALSE) 
[17:38:10.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:10.938]                     ...future.globalenv.names))
[17:38:10.938]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:10.938]         }, condition = base::local({
[17:38:10.938]             c <- base::c
[17:38:10.938]             inherits <- base::inherits
[17:38:10.938]             invokeRestart <- base::invokeRestart
[17:38:10.938]             length <- base::length
[17:38:10.938]             list <- base::list
[17:38:10.938]             seq.int <- base::seq.int
[17:38:10.938]             signalCondition <- base::signalCondition
[17:38:10.938]             sys.calls <- base::sys.calls
[17:38:10.938]             `[[` <- base::`[[`
[17:38:10.938]             `+` <- base::`+`
[17:38:10.938]             `<<-` <- base::`<<-`
[17:38:10.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:10.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:10.938]                   3L)]
[17:38:10.938]             }
[17:38:10.938]             function(cond) {
[17:38:10.938]                 is_error <- inherits(cond, "error")
[17:38:10.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:10.938]                   NULL)
[17:38:10.938]                 if (is_error) {
[17:38:10.938]                   sessionInformation <- function() {
[17:38:10.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:10.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:10.938]                       search = base::search(), system = base::Sys.info())
[17:38:10.938]                   }
[17:38:10.938]                   ...future.conditions[[length(...future.conditions) + 
[17:38:10.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:10.938]                     cond$call), session = sessionInformation(), 
[17:38:10.938]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:10.938]                   signalCondition(cond)
[17:38:10.938]                 }
[17:38:10.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:10.938]                 "immediateCondition"))) {
[17:38:10.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:10.938]                   ...future.conditions[[length(...future.conditions) + 
[17:38:10.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:10.938]                   if (TRUE && !signal) {
[17:38:10.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.938]                     {
[17:38:10.938]                       inherits <- base::inherits
[17:38:10.938]                       invokeRestart <- base::invokeRestart
[17:38:10.938]                       is.null <- base::is.null
[17:38:10.938]                       muffled <- FALSE
[17:38:10.938]                       if (inherits(cond, "message")) {
[17:38:10.938]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:10.938]                         if (muffled) 
[17:38:10.938]                           invokeRestart("muffleMessage")
[17:38:10.938]                       }
[17:38:10.938]                       else if (inherits(cond, "warning")) {
[17:38:10.938]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:10.938]                         if (muffled) 
[17:38:10.938]                           invokeRestart("muffleWarning")
[17:38:10.938]                       }
[17:38:10.938]                       else if (inherits(cond, "condition")) {
[17:38:10.938]                         if (!is.null(pattern)) {
[17:38:10.938]                           computeRestarts <- base::computeRestarts
[17:38:10.938]                           grepl <- base::grepl
[17:38:10.938]                           restarts <- computeRestarts(cond)
[17:38:10.938]                           for (restart in restarts) {
[17:38:10.938]                             name <- restart$name
[17:38:10.938]                             if (is.null(name)) 
[17:38:10.938]                               next
[17:38:10.938]                             if (!grepl(pattern, name)) 
[17:38:10.938]                               next
[17:38:10.938]                             invokeRestart(restart)
[17:38:10.938]                             muffled <- TRUE
[17:38:10.938]                             break
[17:38:10.938]                           }
[17:38:10.938]                         }
[17:38:10.938]                       }
[17:38:10.938]                       invisible(muffled)
[17:38:10.938]                     }
[17:38:10.938]                     muffleCondition(cond, pattern = "^muffle")
[17:38:10.938]                   }
[17:38:10.938]                 }
[17:38:10.938]                 else {
[17:38:10.938]                   if (TRUE) {
[17:38:10.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:10.938]                     {
[17:38:10.938]                       inherits <- base::inherits
[17:38:10.938]                       invokeRestart <- base::invokeRestart
[17:38:10.938]                       is.null <- base::is.null
[17:38:10.938]                       muffled <- FALSE
[17:38:10.938]                       if (inherits(cond, "message")) {
[17:38:10.938]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:10.938]                         if (muffled) 
[17:38:10.938]                           invokeRestart("muffleMessage")
[17:38:10.938]                       }
[17:38:10.938]                       else if (inherits(cond, "warning")) {
[17:38:10.938]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:10.938]                         if (muffled) 
[17:38:10.938]                           invokeRestart("muffleWarning")
[17:38:10.938]                       }
[17:38:10.938]                       else if (inherits(cond, "condition")) {
[17:38:10.938]                         if (!is.null(pattern)) {
[17:38:10.938]                           computeRestarts <- base::computeRestarts
[17:38:10.938]                           grepl <- base::grepl
[17:38:10.938]                           restarts <- computeRestarts(cond)
[17:38:10.938]                           for (restart in restarts) {
[17:38:10.938]                             name <- restart$name
[17:38:10.938]                             if (is.null(name)) 
[17:38:10.938]                               next
[17:38:10.938]                             if (!grepl(pattern, name)) 
[17:38:10.938]                               next
[17:38:10.938]                             invokeRestart(restart)
[17:38:10.938]                             muffled <- TRUE
[17:38:10.938]                             break
[17:38:10.938]                           }
[17:38:10.938]                         }
[17:38:10.938]                       }
[17:38:10.938]                       invisible(muffled)
[17:38:10.938]                     }
[17:38:10.938]                     muffleCondition(cond, pattern = "^muffle")
[17:38:10.938]                   }
[17:38:10.938]                 }
[17:38:10.938]             }
[17:38:10.938]         }))
[17:38:10.938]     }, error = function(ex) {
[17:38:10.938]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:10.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:10.938]                 ...future.rng), started = ...future.startTime, 
[17:38:10.938]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:10.938]             version = "1.8"), class = "FutureResult")
[17:38:10.938]     }, finally = {
[17:38:10.938]         if (!identical(...future.workdir, getwd())) 
[17:38:10.938]             setwd(...future.workdir)
[17:38:10.938]         {
[17:38:10.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:10.938]                 ...future.oldOptions$nwarnings <- NULL
[17:38:10.938]             }
[17:38:10.938]             base::options(...future.oldOptions)
[17:38:10.938]             if (.Platform$OS.type == "windows") {
[17:38:10.938]                 old_names <- names(...future.oldEnvVars)
[17:38:10.938]                 envs <- base::Sys.getenv()
[17:38:10.938]                 names <- names(envs)
[17:38:10.938]                 common <- intersect(names, old_names)
[17:38:10.938]                 added <- setdiff(names, old_names)
[17:38:10.938]                 removed <- setdiff(old_names, names)
[17:38:10.938]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:10.938]                   envs[common]]
[17:38:10.938]                 NAMES <- toupper(changed)
[17:38:10.938]                 args <- list()
[17:38:10.938]                 for (kk in seq_along(NAMES)) {
[17:38:10.938]                   name <- changed[[kk]]
[17:38:10.938]                   NAME <- NAMES[[kk]]
[17:38:10.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.938]                     next
[17:38:10.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:10.938]                 }
[17:38:10.938]                 NAMES <- toupper(added)
[17:38:10.938]                 for (kk in seq_along(NAMES)) {
[17:38:10.938]                   name <- added[[kk]]
[17:38:10.938]                   NAME <- NAMES[[kk]]
[17:38:10.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.938]                     next
[17:38:10.938]                   args[[name]] <- ""
[17:38:10.938]                 }
[17:38:10.938]                 NAMES <- toupper(removed)
[17:38:10.938]                 for (kk in seq_along(NAMES)) {
[17:38:10.938]                   name <- removed[[kk]]
[17:38:10.938]                   NAME <- NAMES[[kk]]
[17:38:10.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:10.938]                     next
[17:38:10.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:10.938]                 }
[17:38:10.938]                 if (length(args) > 0) 
[17:38:10.938]                   base::do.call(base::Sys.setenv, args = args)
[17:38:10.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:10.938]             }
[17:38:10.938]             else {
[17:38:10.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:10.938]             }
[17:38:10.938]             {
[17:38:10.938]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:10.938]                   0L) {
[17:38:10.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:10.938]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:10.938]                   base::options(opts)
[17:38:10.938]                 }
[17:38:10.938]                 {
[17:38:10.938]                   {
[17:38:10.938]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:10.938]                     NULL
[17:38:10.938]                   }
[17:38:10.938]                   options(future.plan = NULL)
[17:38:10.938]                   if (is.na(NA_character_)) 
[17:38:10.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:10.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:10.938]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:10.938]                     .init = FALSE)
[17:38:10.938]                 }
[17:38:10.938]             }
[17:38:10.938]         }
[17:38:10.938]     })
[17:38:10.938]     if (TRUE) {
[17:38:10.938]         base::sink(type = "output", split = FALSE)
[17:38:10.938]         if (TRUE) {
[17:38:10.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:10.938]         }
[17:38:10.938]         else {
[17:38:10.938]             ...future.result["stdout"] <- base::list(NULL)
[17:38:10.938]         }
[17:38:10.938]         base::close(...future.stdout)
[17:38:10.938]         ...future.stdout <- NULL
[17:38:10.938]     }
[17:38:10.938]     ...future.result$conditions <- ...future.conditions
[17:38:10.938]     ...future.result$finished <- base::Sys.time()
[17:38:10.938]     ...future.result
[17:38:10.938] }
[17:38:10.940] Exporting 11 global objects (93.23 KiB) to cluster node #2 ...
[17:38:10.941] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:38:10.985] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:38:10.985] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[17:38:10.985] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[17:38:10.986] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:38:10.986] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:38:10.986] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:38:11.029] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:38:11.029] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:38:11.073] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:38:11.073] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:38:11.073] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:38:11.074] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:38:11.074] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:38:11.074] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:11.075] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:11.075] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:38:11.075] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:38:11.075] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:11.076] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:11.076] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:11.076] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:11.077] Exporting 11 global objects (93.23 KiB) to cluster node #2 ... DONE
[17:38:11.077] MultisessionFuture started
[17:38:11.077] - Launch lazy future ... done
[17:38:11.077] run() for ‘MultisessionFuture’ ... done
[17:38:11.077] Created future:
[17:38:11.079] receiveMessageFromWorker() for ClusterFuture ...
[17:38:11.079] - Validating connection of MultisessionFuture
[17:38:11.079] - received message: FutureResult
[17:38:11.079] - Received FutureResult
[17:38:11.079] - Erased future from FutureRegistry
[17:38:11.080] result() for ClusterFuture ...
[17:38:11.080] - result already collected: FutureResult
[17:38:11.080] result() for ClusterFuture ... done
[17:38:11.080] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:11.078] MultisessionFuture:
[17:38:11.078] Label: ‘future_vapply-2’
[17:38:11.078] Expression:
[17:38:11.078] {
[17:38:11.078]     do.call(function(...) {
[17:38:11.078]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.078]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:11.078]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.078]             on.exit(options(oopts), add = TRUE)
[17:38:11.078]         }
[17:38:11.078]         {
[17:38:11.078]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:11.078]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.078]                 ...future.FUN(...future.X_jj, ...)
[17:38:11.078]             })
[17:38:11.078]         }
[17:38:11.078]     }, args = future.call.arguments)
[17:38:11.078] }
[17:38:11.078] Lazy evaluation: FALSE
[17:38:11.078] Asynchronous evaluation: TRUE
[17:38:11.078] Local evaluation: TRUE
[17:38:11.078] Environment: R_GlobalEnv
[17:38:11.078] Capture standard output: TRUE
[17:38:11.078] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:11.078] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:11.078] Packages: 1 packages (‘future.apply’)
[17:38:11.078] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:11.078] Resolved: TRUE
[17:38:11.078] Value: <not collected>
[17:38:11.078] Conditions captured: <none>
[17:38:11.078] Early signaling: FALSE
[17:38:11.078] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:11.078] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:11.080] Chunk #2 of 2 ... DONE
[17:38:11.080] Launching 2 futures (chunks) ... DONE
[17:38:11.080] Resolving 2 futures (chunks) ...
[17:38:11.080] resolve() on list ...
[17:38:11.081]  recursive: 0
[17:38:11.081]  length: 2
[17:38:11.081] 
[17:38:11.081] receiveMessageFromWorker() for ClusterFuture ...
[17:38:11.081] - Validating connection of MultisessionFuture
[17:38:11.081] - received message: FutureResult
[17:38:11.081] - Received FutureResult
[17:38:11.082] - Erased future from FutureRegistry
[17:38:11.082] result() for ClusterFuture ...
[17:38:11.082] - result already collected: FutureResult
[17:38:11.082] result() for ClusterFuture ... done
[17:38:11.082] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:11.082] Future #1
[17:38:11.082] result() for ClusterFuture ...
[17:38:11.082] - result already collected: FutureResult
[17:38:11.082] result() for ClusterFuture ... done
[17:38:11.082] result() for ClusterFuture ...
[17:38:11.083] - result already collected: FutureResult
[17:38:11.083] result() for ClusterFuture ... done
[17:38:11.083] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:11.083] - nx: 2
[17:38:11.083] - relay: TRUE
[17:38:11.083] - stdout: TRUE
[17:38:11.083] - signal: TRUE
[17:38:11.083] - resignal: FALSE
[17:38:11.083] - force: TRUE
[17:38:11.083] - relayed: [n=2] FALSE, FALSE
[17:38:11.083] - queued futures: [n=2] FALSE, FALSE
[17:38:11.083]  - until=1
[17:38:11.084]  - relaying element #1
[17:38:11.084] result() for ClusterFuture ...
[17:38:11.084] - result already collected: FutureResult
[17:38:11.084] result() for ClusterFuture ... done
[17:38:11.084] result() for ClusterFuture ...
[17:38:11.084] - result already collected: FutureResult
[17:38:11.084] result() for ClusterFuture ... done
[17:38:11.084] result() for ClusterFuture ...
[17:38:11.084] - result already collected: FutureResult
[17:38:11.084] result() for ClusterFuture ... done
[17:38:11.084] result() for ClusterFuture ...
[17:38:11.085] - result already collected: FutureResult
[17:38:11.085] result() for ClusterFuture ... done
[17:38:11.085] - relayed: [n=2] TRUE, FALSE
[17:38:11.085] - queued futures: [n=2] TRUE, FALSE
[17:38:11.085] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:11.085]  length: 1 (resolved future 1)
[17:38:11.085] Future #2
[17:38:11.085] result() for ClusterFuture ...
[17:38:11.085] - result already collected: FutureResult
[17:38:11.085] result() for ClusterFuture ... done
[17:38:11.085] result() for ClusterFuture ...
[17:38:11.086] - result already collected: FutureResult
[17:38:11.086] result() for ClusterFuture ... done
[17:38:11.086] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:11.086] - nx: 2
[17:38:11.086] - relay: TRUE
[17:38:11.086] - stdout: TRUE
[17:38:11.086] - signal: TRUE
[17:38:11.086] - resignal: FALSE
[17:38:11.086] - force: TRUE
[17:38:11.086] - relayed: [n=2] TRUE, FALSE
[17:38:11.086] - queued futures: [n=2] TRUE, FALSE
[17:38:11.087]  - until=2
[17:38:11.087]  - relaying element #2
[17:38:11.087] result() for ClusterFuture ...
[17:38:11.087] - result already collected: FutureResult
[17:38:11.087] result() for ClusterFuture ... done
[17:38:11.087] result() for ClusterFuture ...
[17:38:11.087] - result already collected: FutureResult
[17:38:11.087] result() for ClusterFuture ... done
[17:38:11.087] result() for ClusterFuture ...
[17:38:11.087] - result already collected: FutureResult
[17:38:11.087] result() for ClusterFuture ... done
[17:38:11.087] result() for ClusterFuture ...
[17:38:11.088] - result already collected: FutureResult
[17:38:11.088] result() for ClusterFuture ... done
[17:38:11.088] - relayed: [n=2] TRUE, TRUE
[17:38:11.088] - queued futures: [n=2] TRUE, TRUE
[17:38:11.088] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:11.088]  length: 0 (resolved future 2)
[17:38:11.088] Relaying remaining futures
[17:38:11.088] signalConditionsASAP(NULL, pos=0) ...
[17:38:11.088] - nx: 2
[17:38:11.088] - relay: TRUE
[17:38:11.088] - stdout: TRUE
[17:38:11.088] - signal: TRUE
[17:38:11.089] - resignal: FALSE
[17:38:11.089] - force: TRUE
[17:38:11.089] - relayed: [n=2] TRUE, TRUE
[17:38:11.089] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:11.089] - relayed: [n=2] TRUE, TRUE
[17:38:11.089] - queued futures: [n=2] TRUE, TRUE
[17:38:11.089] signalConditionsASAP(NULL, pos=0) ... done
[17:38:11.089] resolve() on list ... DONE
[17:38:11.089] result() for ClusterFuture ...
[17:38:11.089] - result already collected: FutureResult
[17:38:11.089] result() for ClusterFuture ... done
[17:38:11.090] result() for ClusterFuture ...
[17:38:11.090] - result already collected: FutureResult
[17:38:11.090] result() for ClusterFuture ... done
[17:38:11.090] result() for ClusterFuture ...
[17:38:11.090] - result already collected: FutureResult
[17:38:11.090] result() for ClusterFuture ... done
[17:38:11.090] result() for ClusterFuture ...
[17:38:11.090] - result already collected: FutureResult
[17:38:11.090] result() for ClusterFuture ... done
[17:38:11.090]  - Number of value chunks collected: 2
[17:38:11.090] Resolving 2 futures (chunks) ... DONE
[17:38:11.091] Reducing values from 2 chunks ...
[17:38:11.091]  - Number of values collected after concatenation: 10
[17:38:11.091]  - Number of values expected: 10
[17:38:11.091] Reducing values from 2 chunks ... DONE
[17:38:11.091] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[17:38:11.092] future_lapply() ...
[17:38:11.097] Number of chunks: 2
[17:38:11.098] getGlobalsAndPackagesXApply() ...
[17:38:11.098]  - future.globals: TRUE
[17:38:11.098] getGlobalsAndPackages() ...
[17:38:11.098] Searching for globals...
[17:38:11.104] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[17:38:11.104] Searching for globals ... DONE
[17:38:11.104] Resolving globals: FALSE
[17:38:11.105] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[17:38:11.105] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:11.105] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:11.106] - packages: [1] ‘future.apply’
[17:38:11.106] getGlobalsAndPackages() ... DONE
[17:38:11.106]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:11.106]  - needed namespaces: [n=1] ‘future.apply’
[17:38:11.106] Finding globals ... DONE
[17:38:11.106]  - use_args: TRUE
[17:38:11.106]  - Getting '...' globals ...
[17:38:11.106] resolve() on list ...
[17:38:11.107]  recursive: 0
[17:38:11.107]  length: 1
[17:38:11.107]  elements: ‘...’
[17:38:11.107]  length: 0 (resolved future 1)
[17:38:11.107] resolve() on list ... DONE
[17:38:11.107]    - '...' content: [n=0] 
[17:38:11.107] List of 1
[17:38:11.107]  $ ...: list()
[17:38:11.107]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:11.107]  - attr(*, "where")=List of 1
[17:38:11.107]   ..$ ...:<environment: 0x56080469cc40> 
[17:38:11.107]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:11.107]  - attr(*, "resolved")= logi TRUE
[17:38:11.107]  - attr(*, "total_size")= num NA
[17:38:11.110]  - Getting '...' globals ... DONE
[17:38:11.110] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:11.110] List of 8
[17:38:11.110]  $ ...future.FUN:function (x, ...)  
[17:38:11.110]  $ x_FUN        :function (x)  
[17:38:11.110]  $ times        : int 0
[17:38:11.110]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:11.110]  $ stop_if_not  :function (...)  
[17:38:11.110]  $ dim          : NULL
[17:38:11.110]  $ valid_types  : chr [1:2] "logical" "integer"
[17:38:11.110]  $ ...          : list()
[17:38:11.110]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:11.110]  - attr(*, "where")=List of 8
[17:38:11.110]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:11.110]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:11.110]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:11.110]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:11.110]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:11.110]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:11.110]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:11.110]   ..$ ...          :<environment: 0x56080469cc40> 
[17:38:11.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:11.110]  - attr(*, "resolved")= logi FALSE
[17:38:11.110]  - attr(*, "total_size")= num 95400
[17:38:11.115] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:11.115] getGlobalsAndPackagesXApply() ... DONE
[17:38:11.115] Number of futures (= number of chunks): 2
[17:38:11.116] Launching 2 futures (chunks) ...
[17:38:11.116] Chunk #1 of 2 ...
[17:38:11.116]  - Finding globals in 'X' for chunk #1 ...
[17:38:11.116] getGlobalsAndPackages() ...
[17:38:11.116] Searching for globals...
[17:38:11.116] 
[17:38:11.116] Searching for globals ... DONE
[17:38:11.117] - globals: [0] <none>
[17:38:11.117] getGlobalsAndPackages() ... DONE
[17:38:11.117]    + additional globals found: [n=0] 
[17:38:11.117]    + additional namespaces needed: [n=0] 
[17:38:11.117]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:11.117]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:11.117]  - seeds: <none>
[17:38:11.117]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.117] getGlobalsAndPackages() ...
[17:38:11.117] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.118] Resolving globals: FALSE
[17:38:11.118] Tweak future expression to call with '...' arguments ...
[17:38:11.118] {
[17:38:11.118]     do.call(function(...) {
[17:38:11.118]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.118]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:11.118]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.118]             on.exit(options(oopts), add = TRUE)
[17:38:11.118]         }
[17:38:11.118]         {
[17:38:11.118]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:11.118]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.118]                 ...future.FUN(...future.X_jj, ...)
[17:38:11.118]             })
[17:38:11.118]         }
[17:38:11.118]     }, args = future.call.arguments)
[17:38:11.118] }
[17:38:11.118] Tweak future expression to call with '...' arguments ... DONE
[17:38:11.119] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.119] - packages: [1] ‘future.apply’
[17:38:11.119] getGlobalsAndPackages() ... DONE
[17:38:11.119] run() for ‘Future’ ...
[17:38:11.119] - state: ‘created’
[17:38:11.119] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:11.134] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:11.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:11.134]   - Field: ‘node’
[17:38:11.134]   - Field: ‘label’
[17:38:11.134]   - Field: ‘local’
[17:38:11.134]   - Field: ‘owner’
[17:38:11.135]   - Field: ‘envir’
[17:38:11.135]   - Field: ‘workers’
[17:38:11.135]   - Field: ‘packages’
[17:38:11.135]   - Field: ‘gc’
[17:38:11.135]   - Field: ‘conditions’
[17:38:11.135]   - Field: ‘persistent’
[17:38:11.135]   - Field: ‘expr’
[17:38:11.135]   - Field: ‘uuid’
[17:38:11.135]   - Field: ‘seed’
[17:38:11.135]   - Field: ‘version’
[17:38:11.135]   - Field: ‘result’
[17:38:11.136]   - Field: ‘asynchronous’
[17:38:11.136]   - Field: ‘calls’
[17:38:11.136]   - Field: ‘globals’
[17:38:11.136]   - Field: ‘stdout’
[17:38:11.136]   - Field: ‘earlySignal’
[17:38:11.136]   - Field: ‘lazy’
[17:38:11.136]   - Field: ‘state’
[17:38:11.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:11.136] - Launch lazy future ...
[17:38:11.137] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:11.137] Packages needed by future strategies (n = 0): <none>
[17:38:11.137] {
[17:38:11.137]     {
[17:38:11.137]         {
[17:38:11.137]             ...future.startTime <- base::Sys.time()
[17:38:11.137]             {
[17:38:11.137]                 {
[17:38:11.137]                   {
[17:38:11.137]                     {
[17:38:11.137]                       {
[17:38:11.137]                         base::local({
[17:38:11.137]                           has_future <- base::requireNamespace("future", 
[17:38:11.137]                             quietly = TRUE)
[17:38:11.137]                           if (has_future) {
[17:38:11.137]                             ns <- base::getNamespace("future")
[17:38:11.137]                             version <- ns[[".package"]][["version"]]
[17:38:11.137]                             if (is.null(version)) 
[17:38:11.137]                               version <- utils::packageVersion("future")
[17:38:11.137]                           }
[17:38:11.137]                           else {
[17:38:11.137]                             version <- NULL
[17:38:11.137]                           }
[17:38:11.137]                           if (!has_future || version < "1.8.0") {
[17:38:11.137]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:11.137]                               "", base::R.version$version.string), 
[17:38:11.137]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:11.137]                                 base::R.version$platform, 8 * 
[17:38:11.137]                                   base::.Machine$sizeof.pointer), 
[17:38:11.137]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:11.137]                                 "release", "version")], collapse = " "), 
[17:38:11.137]                               hostname = base::Sys.info()[["nodename"]])
[17:38:11.137]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:11.137]                               info)
[17:38:11.137]                             info <- base::paste(info, collapse = "; ")
[17:38:11.137]                             if (!has_future) {
[17:38:11.137]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:11.137]                                 info)
[17:38:11.137]                             }
[17:38:11.137]                             else {
[17:38:11.137]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:11.137]                                 info, version)
[17:38:11.137]                             }
[17:38:11.137]                             base::stop(msg)
[17:38:11.137]                           }
[17:38:11.137]                         })
[17:38:11.137]                       }
[17:38:11.137]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:11.137]                       base::options(mc.cores = 1L)
[17:38:11.137]                     }
[17:38:11.137]                     base::local({
[17:38:11.137]                       for (pkg in "future.apply") {
[17:38:11.137]                         base::loadNamespace(pkg)
[17:38:11.137]                         base::library(pkg, character.only = TRUE)
[17:38:11.137]                       }
[17:38:11.137]                     })
[17:38:11.137]                   }
[17:38:11.137]                   ...future.strategy.old <- future::plan("list")
[17:38:11.137]                   options(future.plan = NULL)
[17:38:11.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:11.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:11.137]                 }
[17:38:11.137]                 ...future.workdir <- getwd()
[17:38:11.137]             }
[17:38:11.137]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:11.137]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:11.137]         }
[17:38:11.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:11.137]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:11.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:11.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:11.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:11.137]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:11.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:11.137]             base::names(...future.oldOptions))
[17:38:11.137]     }
[17:38:11.137]     if (FALSE) {
[17:38:11.137]     }
[17:38:11.137]     else {
[17:38:11.137]         if (TRUE) {
[17:38:11.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:11.137]                 open = "w")
[17:38:11.137]         }
[17:38:11.137]         else {
[17:38:11.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:11.137]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:11.137]         }
[17:38:11.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:11.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:11.137]             base::sink(type = "output", split = FALSE)
[17:38:11.137]             base::close(...future.stdout)
[17:38:11.137]         }, add = TRUE)
[17:38:11.137]     }
[17:38:11.137]     ...future.frame <- base::sys.nframe()
[17:38:11.137]     ...future.conditions <- base::list()
[17:38:11.137]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:11.137]     if (FALSE) {
[17:38:11.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:11.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:11.137]     }
[17:38:11.137]     ...future.result <- base::tryCatch({
[17:38:11.137]         base::withCallingHandlers({
[17:38:11.137]             ...future.value <- base::withVisible(base::local({
[17:38:11.137]                 ...future.makeSendCondition <- base::local({
[17:38:11.137]                   sendCondition <- NULL
[17:38:11.137]                   function(frame = 1L) {
[17:38:11.137]                     if (is.function(sendCondition)) 
[17:38:11.137]                       return(sendCondition)
[17:38:11.137]                     ns <- getNamespace("parallel")
[17:38:11.137]                     if (exists("sendData", mode = "function", 
[17:38:11.137]                       envir = ns)) {
[17:38:11.137]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:11.137]                         envir = ns)
[17:38:11.137]                       envir <- sys.frame(frame)
[17:38:11.137]                       master <- NULL
[17:38:11.137]                       while (!identical(envir, .GlobalEnv) && 
[17:38:11.137]                         !identical(envir, emptyenv())) {
[17:38:11.137]                         if (exists("master", mode = "list", envir = envir, 
[17:38:11.137]                           inherits = FALSE)) {
[17:38:11.137]                           master <- get("master", mode = "list", 
[17:38:11.137]                             envir = envir, inherits = FALSE)
[17:38:11.137]                           if (inherits(master, c("SOCKnode", 
[17:38:11.137]                             "SOCK0node"))) {
[17:38:11.137]                             sendCondition <<- function(cond) {
[17:38:11.137]                               data <- list(type = "VALUE", value = cond, 
[17:38:11.137]                                 success = TRUE)
[17:38:11.137]                               parallel_sendData(master, data)
[17:38:11.137]                             }
[17:38:11.137]                             return(sendCondition)
[17:38:11.137]                           }
[17:38:11.137]                         }
[17:38:11.137]                         frame <- frame + 1L
[17:38:11.137]                         envir <- sys.frame(frame)
[17:38:11.137]                       }
[17:38:11.137]                     }
[17:38:11.137]                     sendCondition <<- function(cond) NULL
[17:38:11.137]                   }
[17:38:11.137]                 })
[17:38:11.137]                 withCallingHandlers({
[17:38:11.137]                   {
[17:38:11.137]                     do.call(function(...) {
[17:38:11.137]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.137]                       if (!identical(...future.globals.maxSize.org, 
[17:38:11.137]                         ...future.globals.maxSize)) {
[17:38:11.137]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.137]                         on.exit(options(oopts), add = TRUE)
[17:38:11.137]                       }
[17:38:11.137]                       {
[17:38:11.137]                         lapply(seq_along(...future.elements_ii), 
[17:38:11.137]                           FUN = function(jj) {
[17:38:11.137]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.137]                             ...future.FUN(...future.X_jj, ...)
[17:38:11.137]                           })
[17:38:11.137]                       }
[17:38:11.137]                     }, args = future.call.arguments)
[17:38:11.137]                   }
[17:38:11.137]                 }, immediateCondition = function(cond) {
[17:38:11.137]                   sendCondition <- ...future.makeSendCondition()
[17:38:11.137]                   sendCondition(cond)
[17:38:11.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.137]                   {
[17:38:11.137]                     inherits <- base::inherits
[17:38:11.137]                     invokeRestart <- base::invokeRestart
[17:38:11.137]                     is.null <- base::is.null
[17:38:11.137]                     muffled <- FALSE
[17:38:11.137]                     if (inherits(cond, "message")) {
[17:38:11.137]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:11.137]                       if (muffled) 
[17:38:11.137]                         invokeRestart("muffleMessage")
[17:38:11.137]                     }
[17:38:11.137]                     else if (inherits(cond, "warning")) {
[17:38:11.137]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:11.137]                       if (muffled) 
[17:38:11.137]                         invokeRestart("muffleWarning")
[17:38:11.137]                     }
[17:38:11.137]                     else if (inherits(cond, "condition")) {
[17:38:11.137]                       if (!is.null(pattern)) {
[17:38:11.137]                         computeRestarts <- base::computeRestarts
[17:38:11.137]                         grepl <- base::grepl
[17:38:11.137]                         restarts <- computeRestarts(cond)
[17:38:11.137]                         for (restart in restarts) {
[17:38:11.137]                           name <- restart$name
[17:38:11.137]                           if (is.null(name)) 
[17:38:11.137]                             next
[17:38:11.137]                           if (!grepl(pattern, name)) 
[17:38:11.137]                             next
[17:38:11.137]                           invokeRestart(restart)
[17:38:11.137]                           muffled <- TRUE
[17:38:11.137]                           break
[17:38:11.137]                         }
[17:38:11.137]                       }
[17:38:11.137]                     }
[17:38:11.137]                     invisible(muffled)
[17:38:11.137]                   }
[17:38:11.137]                   muffleCondition(cond)
[17:38:11.137]                 })
[17:38:11.137]             }))
[17:38:11.137]             future::FutureResult(value = ...future.value$value, 
[17:38:11.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:11.137]                   ...future.rng), globalenv = if (FALSE) 
[17:38:11.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:11.137]                     ...future.globalenv.names))
[17:38:11.137]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:11.137]         }, condition = base::local({
[17:38:11.137]             c <- base::c
[17:38:11.137]             inherits <- base::inherits
[17:38:11.137]             invokeRestart <- base::invokeRestart
[17:38:11.137]             length <- base::length
[17:38:11.137]             list <- base::list
[17:38:11.137]             seq.int <- base::seq.int
[17:38:11.137]             signalCondition <- base::signalCondition
[17:38:11.137]             sys.calls <- base::sys.calls
[17:38:11.137]             `[[` <- base::`[[`
[17:38:11.137]             `+` <- base::`+`
[17:38:11.137]             `<<-` <- base::`<<-`
[17:38:11.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:11.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:11.137]                   3L)]
[17:38:11.137]             }
[17:38:11.137]             function(cond) {
[17:38:11.137]                 is_error <- inherits(cond, "error")
[17:38:11.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:11.137]                   NULL)
[17:38:11.137]                 if (is_error) {
[17:38:11.137]                   sessionInformation <- function() {
[17:38:11.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:11.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:11.137]                       search = base::search(), system = base::Sys.info())
[17:38:11.137]                   }
[17:38:11.137]                   ...future.conditions[[length(...future.conditions) + 
[17:38:11.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:11.137]                     cond$call), session = sessionInformation(), 
[17:38:11.137]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:11.137]                   signalCondition(cond)
[17:38:11.137]                 }
[17:38:11.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:11.137]                 "immediateCondition"))) {
[17:38:11.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:11.137]                   ...future.conditions[[length(...future.conditions) + 
[17:38:11.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:11.137]                   if (TRUE && !signal) {
[17:38:11.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.137]                     {
[17:38:11.137]                       inherits <- base::inherits
[17:38:11.137]                       invokeRestart <- base::invokeRestart
[17:38:11.137]                       is.null <- base::is.null
[17:38:11.137]                       muffled <- FALSE
[17:38:11.137]                       if (inherits(cond, "message")) {
[17:38:11.137]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:11.137]                         if (muffled) 
[17:38:11.137]                           invokeRestart("muffleMessage")
[17:38:11.137]                       }
[17:38:11.137]                       else if (inherits(cond, "warning")) {
[17:38:11.137]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:11.137]                         if (muffled) 
[17:38:11.137]                           invokeRestart("muffleWarning")
[17:38:11.137]                       }
[17:38:11.137]                       else if (inherits(cond, "condition")) {
[17:38:11.137]                         if (!is.null(pattern)) {
[17:38:11.137]                           computeRestarts <- base::computeRestarts
[17:38:11.137]                           grepl <- base::grepl
[17:38:11.137]                           restarts <- computeRestarts(cond)
[17:38:11.137]                           for (restart in restarts) {
[17:38:11.137]                             name <- restart$name
[17:38:11.137]                             if (is.null(name)) 
[17:38:11.137]                               next
[17:38:11.137]                             if (!grepl(pattern, name)) 
[17:38:11.137]                               next
[17:38:11.137]                             invokeRestart(restart)
[17:38:11.137]                             muffled <- TRUE
[17:38:11.137]                             break
[17:38:11.137]                           }
[17:38:11.137]                         }
[17:38:11.137]                       }
[17:38:11.137]                       invisible(muffled)
[17:38:11.137]                     }
[17:38:11.137]                     muffleCondition(cond, pattern = "^muffle")
[17:38:11.137]                   }
[17:38:11.137]                 }
[17:38:11.137]                 else {
[17:38:11.137]                   if (TRUE) {
[17:38:11.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.137]                     {
[17:38:11.137]                       inherits <- base::inherits
[17:38:11.137]                       invokeRestart <- base::invokeRestart
[17:38:11.137]                       is.null <- base::is.null
[17:38:11.137]                       muffled <- FALSE
[17:38:11.137]                       if (inherits(cond, "message")) {
[17:38:11.137]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:11.137]                         if (muffled) 
[17:38:11.137]                           invokeRestart("muffleMessage")
[17:38:11.137]                       }
[17:38:11.137]                       else if (inherits(cond, "warning")) {
[17:38:11.137]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:11.137]                         if (muffled) 
[17:38:11.137]                           invokeRestart("muffleWarning")
[17:38:11.137]                       }
[17:38:11.137]                       else if (inherits(cond, "condition")) {
[17:38:11.137]                         if (!is.null(pattern)) {
[17:38:11.137]                           computeRestarts <- base::computeRestarts
[17:38:11.137]                           grepl <- base::grepl
[17:38:11.137]                           restarts <- computeRestarts(cond)
[17:38:11.137]                           for (restart in restarts) {
[17:38:11.137]                             name <- restart$name
[17:38:11.137]                             if (is.null(name)) 
[17:38:11.137]                               next
[17:38:11.137]                             if (!grepl(pattern, name)) 
[17:38:11.137]                               next
[17:38:11.137]                             invokeRestart(restart)
[17:38:11.137]                             muffled <- TRUE
[17:38:11.137]                             break
[17:38:11.137]                           }
[17:38:11.137]                         }
[17:38:11.137]                       }
[17:38:11.137]                       invisible(muffled)
[17:38:11.137]                     }
[17:38:11.137]                     muffleCondition(cond, pattern = "^muffle")
[17:38:11.137]                   }
[17:38:11.137]                 }
[17:38:11.137]             }
[17:38:11.137]         }))
[17:38:11.137]     }, error = function(ex) {
[17:38:11.137]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:11.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:11.137]                 ...future.rng), started = ...future.startTime, 
[17:38:11.137]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:11.137]             version = "1.8"), class = "FutureResult")
[17:38:11.137]     }, finally = {
[17:38:11.137]         if (!identical(...future.workdir, getwd())) 
[17:38:11.137]             setwd(...future.workdir)
[17:38:11.137]         {
[17:38:11.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:11.137]                 ...future.oldOptions$nwarnings <- NULL
[17:38:11.137]             }
[17:38:11.137]             base::options(...future.oldOptions)
[17:38:11.137]             if (.Platform$OS.type == "windows") {
[17:38:11.137]                 old_names <- names(...future.oldEnvVars)
[17:38:11.137]                 envs <- base::Sys.getenv()
[17:38:11.137]                 names <- names(envs)
[17:38:11.137]                 common <- intersect(names, old_names)
[17:38:11.137]                 added <- setdiff(names, old_names)
[17:38:11.137]                 removed <- setdiff(old_names, names)
[17:38:11.137]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:11.137]                   envs[common]]
[17:38:11.137]                 NAMES <- toupper(changed)
[17:38:11.137]                 args <- list()
[17:38:11.137]                 for (kk in seq_along(NAMES)) {
[17:38:11.137]                   name <- changed[[kk]]
[17:38:11.137]                   NAME <- NAMES[[kk]]
[17:38:11.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.137]                     next
[17:38:11.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:11.137]                 }
[17:38:11.137]                 NAMES <- toupper(added)
[17:38:11.137]                 for (kk in seq_along(NAMES)) {
[17:38:11.137]                   name <- added[[kk]]
[17:38:11.137]                   NAME <- NAMES[[kk]]
[17:38:11.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.137]                     next
[17:38:11.137]                   args[[name]] <- ""
[17:38:11.137]                 }
[17:38:11.137]                 NAMES <- toupper(removed)
[17:38:11.137]                 for (kk in seq_along(NAMES)) {
[17:38:11.137]                   name <- removed[[kk]]
[17:38:11.137]                   NAME <- NAMES[[kk]]
[17:38:11.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.137]                     next
[17:38:11.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:11.137]                 }
[17:38:11.137]                 if (length(args) > 0) 
[17:38:11.137]                   base::do.call(base::Sys.setenv, args = args)
[17:38:11.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:11.137]             }
[17:38:11.137]             else {
[17:38:11.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:11.137]             }
[17:38:11.137]             {
[17:38:11.137]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:11.137]                   0L) {
[17:38:11.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:11.137]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:11.137]                   base::options(opts)
[17:38:11.137]                 }
[17:38:11.137]                 {
[17:38:11.137]                   {
[17:38:11.137]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:11.137]                     NULL
[17:38:11.137]                   }
[17:38:11.137]                   options(future.plan = NULL)
[17:38:11.137]                   if (is.na(NA_character_)) 
[17:38:11.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:11.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:11.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:11.137]                     .init = FALSE)
[17:38:11.137]                 }
[17:38:11.137]             }
[17:38:11.137]         }
[17:38:11.137]     })
[17:38:11.137]     if (TRUE) {
[17:38:11.137]         base::sink(type = "output", split = FALSE)
[17:38:11.137]         if (TRUE) {
[17:38:11.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:11.137]         }
[17:38:11.137]         else {
[17:38:11.137]             ...future.result["stdout"] <- base::list(NULL)
[17:38:11.137]         }
[17:38:11.137]         base::close(...future.stdout)
[17:38:11.137]         ...future.stdout <- NULL
[17:38:11.137]     }
[17:38:11.137]     ...future.result$conditions <- ...future.conditions
[17:38:11.137]     ...future.result$finished <- base::Sys.time()
[17:38:11.137]     ...future.result
[17:38:11.137] }
[17:38:11.140] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[17:38:11.140] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:38:11.185] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:38:11.185] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[17:38:11.186] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[17:38:11.186] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:38:11.186] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:38:11.187] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:38:11.229] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:38:11.229] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:38:11.273] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:38:11.273] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:38:11.273] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:38:11.274] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[17:38:11.274] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[17:38:11.274] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:11.275] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:11.275] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:38:11.275] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:38:11.275] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:11.276] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:11.276] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:11.276] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:11.276] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[17:38:11.277] MultisessionFuture started
[17:38:11.277] - Launch lazy future ... done
[17:38:11.277] run() for ‘MultisessionFuture’ ... done
[17:38:11.278] Created future:
[17:38:11.278] MultisessionFuture:
[17:38:11.278] Label: ‘future_vapply-1’
[17:38:11.278] Expression:
[17:38:11.278] {
[17:38:11.278]     do.call(function(...) {
[17:38:11.278]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.278]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:11.278]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.278]             on.exit(options(oopts), add = TRUE)
[17:38:11.278]         }
[17:38:11.278]         {
[17:38:11.278]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:11.278]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.278]                 ...future.FUN(...future.X_jj, ...)
[17:38:11.278]             })
[17:38:11.278]         }
[17:38:11.278]     }, args = future.call.arguments)
[17:38:11.278] }
[17:38:11.278] Lazy evaluation: FALSE
[17:38:11.278] Asynchronous evaluation: TRUE
[17:38:11.278] Local evaluation: TRUE
[17:38:11.278] Environment: R_GlobalEnv
[17:38:11.278] Capture standard output: TRUE
[17:38:11.278] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:11.278] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:11.278] Packages: 1 packages (‘future.apply’)
[17:38:11.278] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:11.278] Resolved: FALSE
[17:38:11.278] Value: <not collected>
[17:38:11.278] Conditions captured: <none>
[17:38:11.278] Early signaling: FALSE
[17:38:11.278] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:11.278] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:11.290] Chunk #1 of 2 ... DONE
[17:38:11.290] Chunk #2 of 2 ...
[17:38:11.290]  - Finding globals in 'X' for chunk #2 ...
[17:38:11.290] getGlobalsAndPackages() ...
[17:38:11.290] Searching for globals...
[17:38:11.290] 
[17:38:11.290] Searching for globals ... DONE
[17:38:11.290] - globals: [0] <none>
[17:38:11.291] getGlobalsAndPackages() ... DONE
[17:38:11.291]    + additional globals found: [n=0] 
[17:38:11.291]    + additional namespaces needed: [n=0] 
[17:38:11.291]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:11.291]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:11.291]  - seeds: <none>
[17:38:11.291]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.291] getGlobalsAndPackages() ...
[17:38:11.291] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.291] Resolving globals: FALSE
[17:38:11.292] Tweak future expression to call with '...' arguments ...
[17:38:11.292] {
[17:38:11.292]     do.call(function(...) {
[17:38:11.292]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.292]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:11.292]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.292]             on.exit(options(oopts), add = TRUE)
[17:38:11.292]         }
[17:38:11.292]         {
[17:38:11.292]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:11.292]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.292]                 ...future.FUN(...future.X_jj, ...)
[17:38:11.292]             })
[17:38:11.292]         }
[17:38:11.292]     }, args = future.call.arguments)
[17:38:11.292] }
[17:38:11.292] Tweak future expression to call with '...' arguments ... DONE
[17:38:11.293] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.293] - packages: [1] ‘future.apply’
[17:38:11.293] getGlobalsAndPackages() ... DONE
[17:38:11.293] run() for ‘Future’ ...
[17:38:11.293] - state: ‘created’
[17:38:11.293] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:11.307] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:11.308] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:11.308]   - Field: ‘node’
[17:38:11.308]   - Field: ‘label’
[17:38:11.308]   - Field: ‘local’
[17:38:11.308]   - Field: ‘owner’
[17:38:11.308]   - Field: ‘envir’
[17:38:11.308]   - Field: ‘workers’
[17:38:11.308]   - Field: ‘packages’
[17:38:11.309]   - Field: ‘gc’
[17:38:11.309]   - Field: ‘conditions’
[17:38:11.309]   - Field: ‘persistent’
[17:38:11.309]   - Field: ‘expr’
[17:38:11.309]   - Field: ‘uuid’
[17:38:11.309]   - Field: ‘seed’
[17:38:11.309]   - Field: ‘version’
[17:38:11.309]   - Field: ‘result’
[17:38:11.309]   - Field: ‘asynchronous’
[17:38:11.309]   - Field: ‘calls’
[17:38:11.309]   - Field: ‘globals’
[17:38:11.309]   - Field: ‘stdout’
[17:38:11.310]   - Field: ‘earlySignal’
[17:38:11.310]   - Field: ‘lazy’
[17:38:11.310]   - Field: ‘state’
[17:38:11.310] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:11.310] - Launch lazy future ...
[17:38:11.310] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:11.310] Packages needed by future strategies (n = 0): <none>
[17:38:11.311] {
[17:38:11.311]     {
[17:38:11.311]         {
[17:38:11.311]             ...future.startTime <- base::Sys.time()
[17:38:11.311]             {
[17:38:11.311]                 {
[17:38:11.311]                   {
[17:38:11.311]                     {
[17:38:11.311]                       {
[17:38:11.311]                         base::local({
[17:38:11.311]                           has_future <- base::requireNamespace("future", 
[17:38:11.311]                             quietly = TRUE)
[17:38:11.311]                           if (has_future) {
[17:38:11.311]                             ns <- base::getNamespace("future")
[17:38:11.311]                             version <- ns[[".package"]][["version"]]
[17:38:11.311]                             if (is.null(version)) 
[17:38:11.311]                               version <- utils::packageVersion("future")
[17:38:11.311]                           }
[17:38:11.311]                           else {
[17:38:11.311]                             version <- NULL
[17:38:11.311]                           }
[17:38:11.311]                           if (!has_future || version < "1.8.0") {
[17:38:11.311]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:11.311]                               "", base::R.version$version.string), 
[17:38:11.311]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:11.311]                                 base::R.version$platform, 8 * 
[17:38:11.311]                                   base::.Machine$sizeof.pointer), 
[17:38:11.311]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:11.311]                                 "release", "version")], collapse = " "), 
[17:38:11.311]                               hostname = base::Sys.info()[["nodename"]])
[17:38:11.311]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:11.311]                               info)
[17:38:11.311]                             info <- base::paste(info, collapse = "; ")
[17:38:11.311]                             if (!has_future) {
[17:38:11.311]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:11.311]                                 info)
[17:38:11.311]                             }
[17:38:11.311]                             else {
[17:38:11.311]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:11.311]                                 info, version)
[17:38:11.311]                             }
[17:38:11.311]                             base::stop(msg)
[17:38:11.311]                           }
[17:38:11.311]                         })
[17:38:11.311]                       }
[17:38:11.311]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:11.311]                       base::options(mc.cores = 1L)
[17:38:11.311]                     }
[17:38:11.311]                     base::local({
[17:38:11.311]                       for (pkg in "future.apply") {
[17:38:11.311]                         base::loadNamespace(pkg)
[17:38:11.311]                         base::library(pkg, character.only = TRUE)
[17:38:11.311]                       }
[17:38:11.311]                     })
[17:38:11.311]                   }
[17:38:11.311]                   ...future.strategy.old <- future::plan("list")
[17:38:11.311]                   options(future.plan = NULL)
[17:38:11.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:11.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:11.311]                 }
[17:38:11.311]                 ...future.workdir <- getwd()
[17:38:11.311]             }
[17:38:11.311]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:11.311]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:11.311]         }
[17:38:11.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:11.311]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:11.311]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:11.311]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:11.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:11.311]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:11.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:11.311]             base::names(...future.oldOptions))
[17:38:11.311]     }
[17:38:11.311]     if (FALSE) {
[17:38:11.311]     }
[17:38:11.311]     else {
[17:38:11.311]         if (TRUE) {
[17:38:11.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:11.311]                 open = "w")
[17:38:11.311]         }
[17:38:11.311]         else {
[17:38:11.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:11.311]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:11.311]         }
[17:38:11.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:11.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:11.311]             base::sink(type = "output", split = FALSE)
[17:38:11.311]             base::close(...future.stdout)
[17:38:11.311]         }, add = TRUE)
[17:38:11.311]     }
[17:38:11.311]     ...future.frame <- base::sys.nframe()
[17:38:11.311]     ...future.conditions <- base::list()
[17:38:11.311]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:11.311]     if (FALSE) {
[17:38:11.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:11.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:11.311]     }
[17:38:11.311]     ...future.result <- base::tryCatch({
[17:38:11.311]         base::withCallingHandlers({
[17:38:11.311]             ...future.value <- base::withVisible(base::local({
[17:38:11.311]                 ...future.makeSendCondition <- base::local({
[17:38:11.311]                   sendCondition <- NULL
[17:38:11.311]                   function(frame = 1L) {
[17:38:11.311]                     if (is.function(sendCondition)) 
[17:38:11.311]                       return(sendCondition)
[17:38:11.311]                     ns <- getNamespace("parallel")
[17:38:11.311]                     if (exists("sendData", mode = "function", 
[17:38:11.311]                       envir = ns)) {
[17:38:11.311]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:11.311]                         envir = ns)
[17:38:11.311]                       envir <- sys.frame(frame)
[17:38:11.311]                       master <- NULL
[17:38:11.311]                       while (!identical(envir, .GlobalEnv) && 
[17:38:11.311]                         !identical(envir, emptyenv())) {
[17:38:11.311]                         if (exists("master", mode = "list", envir = envir, 
[17:38:11.311]                           inherits = FALSE)) {
[17:38:11.311]                           master <- get("master", mode = "list", 
[17:38:11.311]                             envir = envir, inherits = FALSE)
[17:38:11.311]                           if (inherits(master, c("SOCKnode", 
[17:38:11.311]                             "SOCK0node"))) {
[17:38:11.311]                             sendCondition <<- function(cond) {
[17:38:11.311]                               data <- list(type = "VALUE", value = cond, 
[17:38:11.311]                                 success = TRUE)
[17:38:11.311]                               parallel_sendData(master, data)
[17:38:11.311]                             }
[17:38:11.311]                             return(sendCondition)
[17:38:11.311]                           }
[17:38:11.311]                         }
[17:38:11.311]                         frame <- frame + 1L
[17:38:11.311]                         envir <- sys.frame(frame)
[17:38:11.311]                       }
[17:38:11.311]                     }
[17:38:11.311]                     sendCondition <<- function(cond) NULL
[17:38:11.311]                   }
[17:38:11.311]                 })
[17:38:11.311]                 withCallingHandlers({
[17:38:11.311]                   {
[17:38:11.311]                     do.call(function(...) {
[17:38:11.311]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.311]                       if (!identical(...future.globals.maxSize.org, 
[17:38:11.311]                         ...future.globals.maxSize)) {
[17:38:11.311]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.311]                         on.exit(options(oopts), add = TRUE)
[17:38:11.311]                       }
[17:38:11.311]                       {
[17:38:11.311]                         lapply(seq_along(...future.elements_ii), 
[17:38:11.311]                           FUN = function(jj) {
[17:38:11.311]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.311]                             ...future.FUN(...future.X_jj, ...)
[17:38:11.311]                           })
[17:38:11.311]                       }
[17:38:11.311]                     }, args = future.call.arguments)
[17:38:11.311]                   }
[17:38:11.311]                 }, immediateCondition = function(cond) {
[17:38:11.311]                   sendCondition <- ...future.makeSendCondition()
[17:38:11.311]                   sendCondition(cond)
[17:38:11.311]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.311]                   {
[17:38:11.311]                     inherits <- base::inherits
[17:38:11.311]                     invokeRestart <- base::invokeRestart
[17:38:11.311]                     is.null <- base::is.null
[17:38:11.311]                     muffled <- FALSE
[17:38:11.311]                     if (inherits(cond, "message")) {
[17:38:11.311]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:11.311]                       if (muffled) 
[17:38:11.311]                         invokeRestart("muffleMessage")
[17:38:11.311]                     }
[17:38:11.311]                     else if (inherits(cond, "warning")) {
[17:38:11.311]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:11.311]                       if (muffled) 
[17:38:11.311]                         invokeRestart("muffleWarning")
[17:38:11.311]                     }
[17:38:11.311]                     else if (inherits(cond, "condition")) {
[17:38:11.311]                       if (!is.null(pattern)) {
[17:38:11.311]                         computeRestarts <- base::computeRestarts
[17:38:11.311]                         grepl <- base::grepl
[17:38:11.311]                         restarts <- computeRestarts(cond)
[17:38:11.311]                         for (restart in restarts) {
[17:38:11.311]                           name <- restart$name
[17:38:11.311]                           if (is.null(name)) 
[17:38:11.311]                             next
[17:38:11.311]                           if (!grepl(pattern, name)) 
[17:38:11.311]                             next
[17:38:11.311]                           invokeRestart(restart)
[17:38:11.311]                           muffled <- TRUE
[17:38:11.311]                           break
[17:38:11.311]                         }
[17:38:11.311]                       }
[17:38:11.311]                     }
[17:38:11.311]                     invisible(muffled)
[17:38:11.311]                   }
[17:38:11.311]                   muffleCondition(cond)
[17:38:11.311]                 })
[17:38:11.311]             }))
[17:38:11.311]             future::FutureResult(value = ...future.value$value, 
[17:38:11.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:11.311]                   ...future.rng), globalenv = if (FALSE) 
[17:38:11.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:11.311]                     ...future.globalenv.names))
[17:38:11.311]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:11.311]         }, condition = base::local({
[17:38:11.311]             c <- base::c
[17:38:11.311]             inherits <- base::inherits
[17:38:11.311]             invokeRestart <- base::invokeRestart
[17:38:11.311]             length <- base::length
[17:38:11.311]             list <- base::list
[17:38:11.311]             seq.int <- base::seq.int
[17:38:11.311]             signalCondition <- base::signalCondition
[17:38:11.311]             sys.calls <- base::sys.calls
[17:38:11.311]             `[[` <- base::`[[`
[17:38:11.311]             `+` <- base::`+`
[17:38:11.311]             `<<-` <- base::`<<-`
[17:38:11.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:11.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:11.311]                   3L)]
[17:38:11.311]             }
[17:38:11.311]             function(cond) {
[17:38:11.311]                 is_error <- inherits(cond, "error")
[17:38:11.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:11.311]                   NULL)
[17:38:11.311]                 if (is_error) {
[17:38:11.311]                   sessionInformation <- function() {
[17:38:11.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:11.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:11.311]                       search = base::search(), system = base::Sys.info())
[17:38:11.311]                   }
[17:38:11.311]                   ...future.conditions[[length(...future.conditions) + 
[17:38:11.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:11.311]                     cond$call), session = sessionInformation(), 
[17:38:11.311]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:11.311]                   signalCondition(cond)
[17:38:11.311]                 }
[17:38:11.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:11.311]                 "immediateCondition"))) {
[17:38:11.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:11.311]                   ...future.conditions[[length(...future.conditions) + 
[17:38:11.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:11.311]                   if (TRUE && !signal) {
[17:38:11.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.311]                     {
[17:38:11.311]                       inherits <- base::inherits
[17:38:11.311]                       invokeRestart <- base::invokeRestart
[17:38:11.311]                       is.null <- base::is.null
[17:38:11.311]                       muffled <- FALSE
[17:38:11.311]                       if (inherits(cond, "message")) {
[17:38:11.311]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:11.311]                         if (muffled) 
[17:38:11.311]                           invokeRestart("muffleMessage")
[17:38:11.311]                       }
[17:38:11.311]                       else if (inherits(cond, "warning")) {
[17:38:11.311]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:11.311]                         if (muffled) 
[17:38:11.311]                           invokeRestart("muffleWarning")
[17:38:11.311]                       }
[17:38:11.311]                       else if (inherits(cond, "condition")) {
[17:38:11.311]                         if (!is.null(pattern)) {
[17:38:11.311]                           computeRestarts <- base::computeRestarts
[17:38:11.311]                           grepl <- base::grepl
[17:38:11.311]                           restarts <- computeRestarts(cond)
[17:38:11.311]                           for (restart in restarts) {
[17:38:11.311]                             name <- restart$name
[17:38:11.311]                             if (is.null(name)) 
[17:38:11.311]                               next
[17:38:11.311]                             if (!grepl(pattern, name)) 
[17:38:11.311]                               next
[17:38:11.311]                             invokeRestart(restart)
[17:38:11.311]                             muffled <- TRUE
[17:38:11.311]                             break
[17:38:11.311]                           }
[17:38:11.311]                         }
[17:38:11.311]                       }
[17:38:11.311]                       invisible(muffled)
[17:38:11.311]                     }
[17:38:11.311]                     muffleCondition(cond, pattern = "^muffle")
[17:38:11.311]                   }
[17:38:11.311]                 }
[17:38:11.311]                 else {
[17:38:11.311]                   if (TRUE) {
[17:38:11.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.311]                     {
[17:38:11.311]                       inherits <- base::inherits
[17:38:11.311]                       invokeRestart <- base::invokeRestart
[17:38:11.311]                       is.null <- base::is.null
[17:38:11.311]                       muffled <- FALSE
[17:38:11.311]                       if (inherits(cond, "message")) {
[17:38:11.311]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:11.311]                         if (muffled) 
[17:38:11.311]                           invokeRestart("muffleMessage")
[17:38:11.311]                       }
[17:38:11.311]                       else if (inherits(cond, "warning")) {
[17:38:11.311]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:11.311]                         if (muffled) 
[17:38:11.311]                           invokeRestart("muffleWarning")
[17:38:11.311]                       }
[17:38:11.311]                       else if (inherits(cond, "condition")) {
[17:38:11.311]                         if (!is.null(pattern)) {
[17:38:11.311]                           computeRestarts <- base::computeRestarts
[17:38:11.311]                           grepl <- base::grepl
[17:38:11.311]                           restarts <- computeRestarts(cond)
[17:38:11.311]                           for (restart in restarts) {
[17:38:11.311]                             name <- restart$name
[17:38:11.311]                             if (is.null(name)) 
[17:38:11.311]                               next
[17:38:11.311]                             if (!grepl(pattern, name)) 
[17:38:11.311]                               next
[17:38:11.311]                             invokeRestart(restart)
[17:38:11.311]                             muffled <- TRUE
[17:38:11.311]                             break
[17:38:11.311]                           }
[17:38:11.311]                         }
[17:38:11.311]                       }
[17:38:11.311]                       invisible(muffled)
[17:38:11.311]                     }
[17:38:11.311]                     muffleCondition(cond, pattern = "^muffle")
[17:38:11.311]                   }
[17:38:11.311]                 }
[17:38:11.311]             }
[17:38:11.311]         }))
[17:38:11.311]     }, error = function(ex) {
[17:38:11.311]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:11.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:11.311]                 ...future.rng), started = ...future.startTime, 
[17:38:11.311]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:11.311]             version = "1.8"), class = "FutureResult")
[17:38:11.311]     }, finally = {
[17:38:11.311]         if (!identical(...future.workdir, getwd())) 
[17:38:11.311]             setwd(...future.workdir)
[17:38:11.311]         {
[17:38:11.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:11.311]                 ...future.oldOptions$nwarnings <- NULL
[17:38:11.311]             }
[17:38:11.311]             base::options(...future.oldOptions)
[17:38:11.311]             if (.Platform$OS.type == "windows") {
[17:38:11.311]                 old_names <- names(...future.oldEnvVars)
[17:38:11.311]                 envs <- base::Sys.getenv()
[17:38:11.311]                 names <- names(envs)
[17:38:11.311]                 common <- intersect(names, old_names)
[17:38:11.311]                 added <- setdiff(names, old_names)
[17:38:11.311]                 removed <- setdiff(old_names, names)
[17:38:11.311]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:11.311]                   envs[common]]
[17:38:11.311]                 NAMES <- toupper(changed)
[17:38:11.311]                 args <- list()
[17:38:11.311]                 for (kk in seq_along(NAMES)) {
[17:38:11.311]                   name <- changed[[kk]]
[17:38:11.311]                   NAME <- NAMES[[kk]]
[17:38:11.311]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.311]                     next
[17:38:11.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:11.311]                 }
[17:38:11.311]                 NAMES <- toupper(added)
[17:38:11.311]                 for (kk in seq_along(NAMES)) {
[17:38:11.311]                   name <- added[[kk]]
[17:38:11.311]                   NAME <- NAMES[[kk]]
[17:38:11.311]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.311]                     next
[17:38:11.311]                   args[[name]] <- ""
[17:38:11.311]                 }
[17:38:11.311]                 NAMES <- toupper(removed)
[17:38:11.311]                 for (kk in seq_along(NAMES)) {
[17:38:11.311]                   name <- removed[[kk]]
[17:38:11.311]                   NAME <- NAMES[[kk]]
[17:38:11.311]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.311]                     next
[17:38:11.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:11.311]                 }
[17:38:11.311]                 if (length(args) > 0) 
[17:38:11.311]                   base::do.call(base::Sys.setenv, args = args)
[17:38:11.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:11.311]             }
[17:38:11.311]             else {
[17:38:11.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:11.311]             }
[17:38:11.311]             {
[17:38:11.311]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:11.311]                   0L) {
[17:38:11.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:11.311]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:11.311]                   base::options(opts)
[17:38:11.311]                 }
[17:38:11.311]                 {
[17:38:11.311]                   {
[17:38:11.311]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:11.311]                     NULL
[17:38:11.311]                   }
[17:38:11.311]                   options(future.plan = NULL)
[17:38:11.311]                   if (is.na(NA_character_)) 
[17:38:11.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:11.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:11.311]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:11.311]                     .init = FALSE)
[17:38:11.311]                 }
[17:38:11.311]             }
[17:38:11.311]         }
[17:38:11.311]     })
[17:38:11.311]     if (TRUE) {
[17:38:11.311]         base::sink(type = "output", split = FALSE)
[17:38:11.311]         if (TRUE) {
[17:38:11.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:11.311]         }
[17:38:11.311]         else {
[17:38:11.311]             ...future.result["stdout"] <- base::list(NULL)
[17:38:11.311]         }
[17:38:11.311]         base::close(...future.stdout)
[17:38:11.311]         ...future.stdout <- NULL
[17:38:11.311]     }
[17:38:11.311]     ...future.result$conditions <- ...future.conditions
[17:38:11.311]     ...future.result$finished <- base::Sys.time()
[17:38:11.311]     ...future.result
[17:38:11.311] }
[17:38:11.314] Exporting 11 global objects (93.16 KiB) to cluster node #2 ...
[17:38:11.314] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:38:11.357] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:38:11.357] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[17:38:11.357] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[17:38:11.358] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:38:11.358] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:38:11.358] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:38:11.401] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:38:11.401] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:38:11.445] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:38:11.445] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:38:11.446] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:38:11.446] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[17:38:11.446] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[17:38:11.446] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:11.447] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:11.447] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:38:11.448] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:38:11.448] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:11.448] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:11.448] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:11.449] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:11.449] Exporting 11 global objects (93.16 KiB) to cluster node #2 ... DONE
[17:38:11.450] MultisessionFuture started
[17:38:11.450] - Launch lazy future ... done
[17:38:11.450] run() for ‘MultisessionFuture’ ... done
[17:38:11.450] Created future:
[17:38:11.451] receiveMessageFromWorker() for ClusterFuture ...
[17:38:11.452] - Validating connection of MultisessionFuture
[17:38:11.452] - received message: FutureResult
[17:38:11.452] - Received FutureResult
[17:38:11.452] - Erased future from FutureRegistry
[17:38:11.452] result() for ClusterFuture ...
[17:38:11.452] - result already collected: FutureResult
[17:38:11.452] result() for ClusterFuture ... done
[17:38:11.452] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:11.450] MultisessionFuture:
[17:38:11.450] Label: ‘future_vapply-2’
[17:38:11.450] Expression:
[17:38:11.450] {
[17:38:11.450]     do.call(function(...) {
[17:38:11.450]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.450]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:11.450]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.450]             on.exit(options(oopts), add = TRUE)
[17:38:11.450]         }
[17:38:11.450]         {
[17:38:11.450]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:11.450]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.450]                 ...future.FUN(...future.X_jj, ...)
[17:38:11.450]             })
[17:38:11.450]         }
[17:38:11.450]     }, args = future.call.arguments)
[17:38:11.450] }
[17:38:11.450] Lazy evaluation: FALSE
[17:38:11.450] Asynchronous evaluation: TRUE
[17:38:11.450] Local evaluation: TRUE
[17:38:11.450] Environment: R_GlobalEnv
[17:38:11.450] Capture standard output: TRUE
[17:38:11.450] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:11.450] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:11.450] Packages: 1 packages (‘future.apply’)
[17:38:11.450] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:11.450] Resolved: TRUE
[17:38:11.450] Value: <not collected>
[17:38:11.450] Conditions captured: <none>
[17:38:11.450] Early signaling: FALSE
[17:38:11.450] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:11.450] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:11.453] Chunk #2 of 2 ... DONE
[17:38:11.453] Launching 2 futures (chunks) ... DONE
[17:38:11.453] Resolving 2 futures (chunks) ...
[17:38:11.453] resolve() on list ...
[17:38:11.453]  recursive: 0
[17:38:11.453]  length: 2
[17:38:11.453] 
[17:38:11.454] receiveMessageFromWorker() for ClusterFuture ...
[17:38:11.454] - Validating connection of MultisessionFuture
[17:38:11.454] - received message: FutureResult
[17:38:11.454] - Received FutureResult
[17:38:11.454] - Erased future from FutureRegistry
[17:38:11.454] result() for ClusterFuture ...
[17:38:11.455] - result already collected: FutureResult
[17:38:11.455] result() for ClusterFuture ... done
[17:38:11.455] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:11.455] Future #1
[17:38:11.455] result() for ClusterFuture ...
[17:38:11.455] - result already collected: FutureResult
[17:38:11.455] result() for ClusterFuture ... done
[17:38:11.455] result() for ClusterFuture ...
[17:38:11.455] - result already collected: FutureResult
[17:38:11.455] result() for ClusterFuture ... done
[17:38:11.455] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:11.455] - nx: 2
[17:38:11.456] - relay: TRUE
[17:38:11.456] - stdout: TRUE
[17:38:11.456] - signal: TRUE
[17:38:11.456] - resignal: FALSE
[17:38:11.456] - force: TRUE
[17:38:11.456] - relayed: [n=2] FALSE, FALSE
[17:38:11.456] - queued futures: [n=2] FALSE, FALSE
[17:38:11.456]  - until=1
[17:38:11.456]  - relaying element #1
[17:38:11.456] result() for ClusterFuture ...
[17:38:11.456] - result already collected: FutureResult
[17:38:11.456] result() for ClusterFuture ... done
[17:38:11.457] result() for ClusterFuture ...
[17:38:11.457] - result already collected: FutureResult
[17:38:11.457] result() for ClusterFuture ... done
[17:38:11.457] result() for ClusterFuture ...
[17:38:11.457] - result already collected: FutureResult
[17:38:11.457] result() for ClusterFuture ... done
[17:38:11.457] result() for ClusterFuture ...
[17:38:11.457] - result already collected: FutureResult
[17:38:11.457] result() for ClusterFuture ... done
[17:38:11.457] - relayed: [n=2] TRUE, FALSE
[17:38:11.458] - queued futures: [n=2] TRUE, FALSE
[17:38:11.458] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:11.458]  length: 1 (resolved future 1)
[17:38:11.458] Future #2
[17:38:11.458] result() for ClusterFuture ...
[17:38:11.458] - result already collected: FutureResult
[17:38:11.458] result() for ClusterFuture ... done
[17:38:11.458] result() for ClusterFuture ...
[17:38:11.458] - result already collected: FutureResult
[17:38:11.458] result() for ClusterFuture ... done
[17:38:11.458] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:11.459] - nx: 2
[17:38:11.459] - relay: TRUE
[17:38:11.459] - stdout: TRUE
[17:38:11.459] - signal: TRUE
[17:38:11.459] - resignal: FALSE
[17:38:11.459] - force: TRUE
[17:38:11.459] - relayed: [n=2] TRUE, FALSE
[17:38:11.459] - queued futures: [n=2] TRUE, FALSE
[17:38:11.459]  - until=2
[17:38:11.459]  - relaying element #2
[17:38:11.459] result() for ClusterFuture ...
[17:38:11.459] - result already collected: FutureResult
[17:38:11.460] result() for ClusterFuture ... done
[17:38:11.460] result() for ClusterFuture ...
[17:38:11.460] - result already collected: FutureResult
[17:38:11.460] result() for ClusterFuture ... done
[17:38:11.460] result() for ClusterFuture ...
[17:38:11.460] - result already collected: FutureResult
[17:38:11.460] result() for ClusterFuture ... done
[17:38:11.460] result() for ClusterFuture ...
[17:38:11.460] - result already collected: FutureResult
[17:38:11.460] result() for ClusterFuture ... done
[17:38:11.460] - relayed: [n=2] TRUE, TRUE
[17:38:11.461] - queued futures: [n=2] TRUE, TRUE
[17:38:11.461] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:11.461]  length: 0 (resolved future 2)
[17:38:11.461] Relaying remaining futures
[17:38:11.461] signalConditionsASAP(NULL, pos=0) ...
[17:38:11.461] - nx: 2
[17:38:11.461] - relay: TRUE
[17:38:11.461] - stdout: TRUE
[17:38:11.461] - signal: TRUE
[17:38:11.461] - resignal: FALSE
[17:38:11.461] - force: TRUE
[17:38:11.461] - relayed: [n=2] TRUE, TRUE
[17:38:11.461] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:11.462] - relayed: [n=2] TRUE, TRUE
[17:38:11.462] - queued futures: [n=2] TRUE, TRUE
[17:38:11.462] signalConditionsASAP(NULL, pos=0) ... done
[17:38:11.462] resolve() on list ... DONE
[17:38:11.462] result() for ClusterFuture ...
[17:38:11.462] - result already collected: FutureResult
[17:38:11.462] result() for ClusterFuture ... done
[17:38:11.462] result() for ClusterFuture ...
[17:38:11.462] - result already collected: FutureResult
[17:38:11.462] result() for ClusterFuture ... done
[17:38:11.463] result() for ClusterFuture ...
[17:38:11.463] - result already collected: FutureResult
[17:38:11.463] result() for ClusterFuture ... done
[17:38:11.463] result() for ClusterFuture ...
[17:38:11.463] - result already collected: FutureResult
[17:38:11.463] result() for ClusterFuture ... done
[17:38:11.463]  - Number of value chunks collected: 2
[17:38:11.463] Resolving 2 futures (chunks) ... DONE
[17:38:11.463] Reducing values from 2 chunks ...
[17:38:11.463]  - Number of values collected after concatenation: 10
[17:38:11.463]  - Number of values expected: 10
[17:38:11.463] Reducing values from 2 chunks ... DONE
[17:38:11.464] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[17:38:11.464] future_lapply() ...
[17:38:11.470] Number of chunks: 2
[17:38:11.470] getGlobalsAndPackagesXApply() ...
[17:38:11.470]  - future.globals: TRUE
[17:38:11.470] getGlobalsAndPackages() ...
[17:38:11.470] Searching for globals...
[17:38:11.473] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:11.473] Searching for globals ... DONE
[17:38:11.473] Resolving globals: FALSE
[17:38:11.474] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[17:38:11.475] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:11.475] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:11.475] - packages: [1] ‘future.apply’
[17:38:11.475] getGlobalsAndPackages() ... DONE
[17:38:11.475]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:11.475]  - needed namespaces: [n=1] ‘future.apply’
[17:38:11.475] Finding globals ... DONE
[17:38:11.475]  - use_args: TRUE
[17:38:11.475]  - Getting '...' globals ...
[17:38:11.476] resolve() on list ...
[17:38:11.476]  recursive: 0
[17:38:11.476]  length: 1
[17:38:11.476]  elements: ‘...’
[17:38:11.476]  length: 0 (resolved future 1)
[17:38:11.476] resolve() on list ... DONE
[17:38:11.476]    - '...' content: [n=0] 
[17:38:11.476] List of 1
[17:38:11.476]  $ ...: list()
[17:38:11.476]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:11.476]  - attr(*, "where")=List of 1
[17:38:11.476]   ..$ ...:<environment: 0x560803c20b10> 
[17:38:11.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:11.476]  - attr(*, "resolved")= logi TRUE
[17:38:11.476]  - attr(*, "total_size")= num NA
[17:38:11.479]  - Getting '...' globals ... DONE
[17:38:11.479] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:11.479] List of 8
[17:38:11.479]  $ ...future.FUN:function (x, ...)  
[17:38:11.479]  $ x_FUN        :function (x)  
[17:38:11.479]  $ times        : int 1
[17:38:11.479]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:11.479]  $ stop_if_not  :function (...)  
[17:38:11.479]  $ dim          : NULL
[17:38:11.479]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:11.479]  $ ...          : list()
[17:38:11.479]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:11.479]  - attr(*, "where")=List of 8
[17:38:11.479]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:11.479]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:11.479]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:11.479]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:11.479]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:11.479]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:11.479]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:11.479]   ..$ ...          :<environment: 0x560803c20b10> 
[17:38:11.479]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:11.479]  - attr(*, "resolved")= logi FALSE
[17:38:11.479]  - attr(*, "total_size")= num 94336
[17:38:11.484] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:11.484] getGlobalsAndPackagesXApply() ... DONE
[17:38:11.484] Number of futures (= number of chunks): 2
[17:38:11.485] Launching 2 futures (chunks) ...
[17:38:11.485] Chunk #1 of 2 ...
[17:38:11.485]  - Finding globals in 'X' for chunk #1 ...
[17:38:11.485] getGlobalsAndPackages() ...
[17:38:11.485] Searching for globals...
[17:38:11.485] 
[17:38:11.485] Searching for globals ... DONE
[17:38:11.485] - globals: [0] <none>
[17:38:11.486] getGlobalsAndPackages() ... DONE
[17:38:11.486]    + additional globals found: [n=0] 
[17:38:11.486]    + additional namespaces needed: [n=0] 
[17:38:11.486]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:11.486]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:11.486]  - seeds: <none>
[17:38:11.486]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.486] getGlobalsAndPackages() ...
[17:38:11.486] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.486] Resolving globals: FALSE
[17:38:11.486] Tweak future expression to call with '...' arguments ...
[17:38:11.487] {
[17:38:11.487]     do.call(function(...) {
[17:38:11.487]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.487]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:11.487]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.487]             on.exit(options(oopts), add = TRUE)
[17:38:11.487]         }
[17:38:11.487]         {
[17:38:11.487]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:11.487]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.487]                 ...future.FUN(...future.X_jj, ...)
[17:38:11.487]             })
[17:38:11.487]         }
[17:38:11.487]     }, args = future.call.arguments)
[17:38:11.487] }
[17:38:11.487] Tweak future expression to call with '...' arguments ... DONE
[17:38:11.487] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.487] - packages: [1] ‘future.apply’
[17:38:11.490] getGlobalsAndPackages() ... DONE
[17:38:11.490] run() for ‘Future’ ...
[17:38:11.490] - state: ‘created’
[17:38:11.490] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:11.504] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:11.505] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:11.505]   - Field: ‘node’
[17:38:11.505]   - Field: ‘label’
[17:38:11.505]   - Field: ‘local’
[17:38:11.505]   - Field: ‘owner’
[17:38:11.505]   - Field: ‘envir’
[17:38:11.505]   - Field: ‘workers’
[17:38:11.505]   - Field: ‘packages’
[17:38:11.505]   - Field: ‘gc’
[17:38:11.505]   - Field: ‘conditions’
[17:38:11.506]   - Field: ‘persistent’
[17:38:11.506]   - Field: ‘expr’
[17:38:11.506]   - Field: ‘uuid’
[17:38:11.506]   - Field: ‘seed’
[17:38:11.506]   - Field: ‘version’
[17:38:11.506]   - Field: ‘result’
[17:38:11.506]   - Field: ‘asynchronous’
[17:38:11.506]   - Field: ‘calls’
[17:38:11.506]   - Field: ‘globals’
[17:38:11.506]   - Field: ‘stdout’
[17:38:11.506]   - Field: ‘earlySignal’
[17:38:11.507]   - Field: ‘lazy’
[17:38:11.507]   - Field: ‘state’
[17:38:11.507] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:11.507] - Launch lazy future ...
[17:38:11.507] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:11.507] Packages needed by future strategies (n = 0): <none>
[17:38:11.508] {
[17:38:11.508]     {
[17:38:11.508]         {
[17:38:11.508]             ...future.startTime <- base::Sys.time()
[17:38:11.508]             {
[17:38:11.508]                 {
[17:38:11.508]                   {
[17:38:11.508]                     {
[17:38:11.508]                       {
[17:38:11.508]                         base::local({
[17:38:11.508]                           has_future <- base::requireNamespace("future", 
[17:38:11.508]                             quietly = TRUE)
[17:38:11.508]                           if (has_future) {
[17:38:11.508]                             ns <- base::getNamespace("future")
[17:38:11.508]                             version <- ns[[".package"]][["version"]]
[17:38:11.508]                             if (is.null(version)) 
[17:38:11.508]                               version <- utils::packageVersion("future")
[17:38:11.508]                           }
[17:38:11.508]                           else {
[17:38:11.508]                             version <- NULL
[17:38:11.508]                           }
[17:38:11.508]                           if (!has_future || version < "1.8.0") {
[17:38:11.508]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:11.508]                               "", base::R.version$version.string), 
[17:38:11.508]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:11.508]                                 base::R.version$platform, 8 * 
[17:38:11.508]                                   base::.Machine$sizeof.pointer), 
[17:38:11.508]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:11.508]                                 "release", "version")], collapse = " "), 
[17:38:11.508]                               hostname = base::Sys.info()[["nodename"]])
[17:38:11.508]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:11.508]                               info)
[17:38:11.508]                             info <- base::paste(info, collapse = "; ")
[17:38:11.508]                             if (!has_future) {
[17:38:11.508]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:11.508]                                 info)
[17:38:11.508]                             }
[17:38:11.508]                             else {
[17:38:11.508]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:11.508]                                 info, version)
[17:38:11.508]                             }
[17:38:11.508]                             base::stop(msg)
[17:38:11.508]                           }
[17:38:11.508]                         })
[17:38:11.508]                       }
[17:38:11.508]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:11.508]                       base::options(mc.cores = 1L)
[17:38:11.508]                     }
[17:38:11.508]                     base::local({
[17:38:11.508]                       for (pkg in "future.apply") {
[17:38:11.508]                         base::loadNamespace(pkg)
[17:38:11.508]                         base::library(pkg, character.only = TRUE)
[17:38:11.508]                       }
[17:38:11.508]                     })
[17:38:11.508]                   }
[17:38:11.508]                   ...future.strategy.old <- future::plan("list")
[17:38:11.508]                   options(future.plan = NULL)
[17:38:11.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:11.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:11.508]                 }
[17:38:11.508]                 ...future.workdir <- getwd()
[17:38:11.508]             }
[17:38:11.508]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:11.508]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:11.508]         }
[17:38:11.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:11.508]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:11.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:11.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:11.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:11.508]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:11.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:11.508]             base::names(...future.oldOptions))
[17:38:11.508]     }
[17:38:11.508]     if (FALSE) {
[17:38:11.508]     }
[17:38:11.508]     else {
[17:38:11.508]         if (TRUE) {
[17:38:11.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:11.508]                 open = "w")
[17:38:11.508]         }
[17:38:11.508]         else {
[17:38:11.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:11.508]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:11.508]         }
[17:38:11.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:11.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:11.508]             base::sink(type = "output", split = FALSE)
[17:38:11.508]             base::close(...future.stdout)
[17:38:11.508]         }, add = TRUE)
[17:38:11.508]     }
[17:38:11.508]     ...future.frame <- base::sys.nframe()
[17:38:11.508]     ...future.conditions <- base::list()
[17:38:11.508]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:11.508]     if (FALSE) {
[17:38:11.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:11.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:11.508]     }
[17:38:11.508]     ...future.result <- base::tryCatch({
[17:38:11.508]         base::withCallingHandlers({
[17:38:11.508]             ...future.value <- base::withVisible(base::local({
[17:38:11.508]                 ...future.makeSendCondition <- base::local({
[17:38:11.508]                   sendCondition <- NULL
[17:38:11.508]                   function(frame = 1L) {
[17:38:11.508]                     if (is.function(sendCondition)) 
[17:38:11.508]                       return(sendCondition)
[17:38:11.508]                     ns <- getNamespace("parallel")
[17:38:11.508]                     if (exists("sendData", mode = "function", 
[17:38:11.508]                       envir = ns)) {
[17:38:11.508]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:11.508]                         envir = ns)
[17:38:11.508]                       envir <- sys.frame(frame)
[17:38:11.508]                       master <- NULL
[17:38:11.508]                       while (!identical(envir, .GlobalEnv) && 
[17:38:11.508]                         !identical(envir, emptyenv())) {
[17:38:11.508]                         if (exists("master", mode = "list", envir = envir, 
[17:38:11.508]                           inherits = FALSE)) {
[17:38:11.508]                           master <- get("master", mode = "list", 
[17:38:11.508]                             envir = envir, inherits = FALSE)
[17:38:11.508]                           if (inherits(master, c("SOCKnode", 
[17:38:11.508]                             "SOCK0node"))) {
[17:38:11.508]                             sendCondition <<- function(cond) {
[17:38:11.508]                               data <- list(type = "VALUE", value = cond, 
[17:38:11.508]                                 success = TRUE)
[17:38:11.508]                               parallel_sendData(master, data)
[17:38:11.508]                             }
[17:38:11.508]                             return(sendCondition)
[17:38:11.508]                           }
[17:38:11.508]                         }
[17:38:11.508]                         frame <- frame + 1L
[17:38:11.508]                         envir <- sys.frame(frame)
[17:38:11.508]                       }
[17:38:11.508]                     }
[17:38:11.508]                     sendCondition <<- function(cond) NULL
[17:38:11.508]                   }
[17:38:11.508]                 })
[17:38:11.508]                 withCallingHandlers({
[17:38:11.508]                   {
[17:38:11.508]                     do.call(function(...) {
[17:38:11.508]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.508]                       if (!identical(...future.globals.maxSize.org, 
[17:38:11.508]                         ...future.globals.maxSize)) {
[17:38:11.508]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.508]                         on.exit(options(oopts), add = TRUE)
[17:38:11.508]                       }
[17:38:11.508]                       {
[17:38:11.508]                         lapply(seq_along(...future.elements_ii), 
[17:38:11.508]                           FUN = function(jj) {
[17:38:11.508]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.508]                             ...future.FUN(...future.X_jj, ...)
[17:38:11.508]                           })
[17:38:11.508]                       }
[17:38:11.508]                     }, args = future.call.arguments)
[17:38:11.508]                   }
[17:38:11.508]                 }, immediateCondition = function(cond) {
[17:38:11.508]                   sendCondition <- ...future.makeSendCondition()
[17:38:11.508]                   sendCondition(cond)
[17:38:11.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.508]                   {
[17:38:11.508]                     inherits <- base::inherits
[17:38:11.508]                     invokeRestart <- base::invokeRestart
[17:38:11.508]                     is.null <- base::is.null
[17:38:11.508]                     muffled <- FALSE
[17:38:11.508]                     if (inherits(cond, "message")) {
[17:38:11.508]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:11.508]                       if (muffled) 
[17:38:11.508]                         invokeRestart("muffleMessage")
[17:38:11.508]                     }
[17:38:11.508]                     else if (inherits(cond, "warning")) {
[17:38:11.508]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:11.508]                       if (muffled) 
[17:38:11.508]                         invokeRestart("muffleWarning")
[17:38:11.508]                     }
[17:38:11.508]                     else if (inherits(cond, "condition")) {
[17:38:11.508]                       if (!is.null(pattern)) {
[17:38:11.508]                         computeRestarts <- base::computeRestarts
[17:38:11.508]                         grepl <- base::grepl
[17:38:11.508]                         restarts <- computeRestarts(cond)
[17:38:11.508]                         for (restart in restarts) {
[17:38:11.508]                           name <- restart$name
[17:38:11.508]                           if (is.null(name)) 
[17:38:11.508]                             next
[17:38:11.508]                           if (!grepl(pattern, name)) 
[17:38:11.508]                             next
[17:38:11.508]                           invokeRestart(restart)
[17:38:11.508]                           muffled <- TRUE
[17:38:11.508]                           break
[17:38:11.508]                         }
[17:38:11.508]                       }
[17:38:11.508]                     }
[17:38:11.508]                     invisible(muffled)
[17:38:11.508]                   }
[17:38:11.508]                   muffleCondition(cond)
[17:38:11.508]                 })
[17:38:11.508]             }))
[17:38:11.508]             future::FutureResult(value = ...future.value$value, 
[17:38:11.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:11.508]                   ...future.rng), globalenv = if (FALSE) 
[17:38:11.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:11.508]                     ...future.globalenv.names))
[17:38:11.508]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:11.508]         }, condition = base::local({
[17:38:11.508]             c <- base::c
[17:38:11.508]             inherits <- base::inherits
[17:38:11.508]             invokeRestart <- base::invokeRestart
[17:38:11.508]             length <- base::length
[17:38:11.508]             list <- base::list
[17:38:11.508]             seq.int <- base::seq.int
[17:38:11.508]             signalCondition <- base::signalCondition
[17:38:11.508]             sys.calls <- base::sys.calls
[17:38:11.508]             `[[` <- base::`[[`
[17:38:11.508]             `+` <- base::`+`
[17:38:11.508]             `<<-` <- base::`<<-`
[17:38:11.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:11.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:11.508]                   3L)]
[17:38:11.508]             }
[17:38:11.508]             function(cond) {
[17:38:11.508]                 is_error <- inherits(cond, "error")
[17:38:11.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:11.508]                   NULL)
[17:38:11.508]                 if (is_error) {
[17:38:11.508]                   sessionInformation <- function() {
[17:38:11.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:11.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:11.508]                       search = base::search(), system = base::Sys.info())
[17:38:11.508]                   }
[17:38:11.508]                   ...future.conditions[[length(...future.conditions) + 
[17:38:11.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:11.508]                     cond$call), session = sessionInformation(), 
[17:38:11.508]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:11.508]                   signalCondition(cond)
[17:38:11.508]                 }
[17:38:11.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:11.508]                 "immediateCondition"))) {
[17:38:11.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:11.508]                   ...future.conditions[[length(...future.conditions) + 
[17:38:11.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:11.508]                   if (TRUE && !signal) {
[17:38:11.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.508]                     {
[17:38:11.508]                       inherits <- base::inherits
[17:38:11.508]                       invokeRestart <- base::invokeRestart
[17:38:11.508]                       is.null <- base::is.null
[17:38:11.508]                       muffled <- FALSE
[17:38:11.508]                       if (inherits(cond, "message")) {
[17:38:11.508]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:11.508]                         if (muffled) 
[17:38:11.508]                           invokeRestart("muffleMessage")
[17:38:11.508]                       }
[17:38:11.508]                       else if (inherits(cond, "warning")) {
[17:38:11.508]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:11.508]                         if (muffled) 
[17:38:11.508]                           invokeRestart("muffleWarning")
[17:38:11.508]                       }
[17:38:11.508]                       else if (inherits(cond, "condition")) {
[17:38:11.508]                         if (!is.null(pattern)) {
[17:38:11.508]                           computeRestarts <- base::computeRestarts
[17:38:11.508]                           grepl <- base::grepl
[17:38:11.508]                           restarts <- computeRestarts(cond)
[17:38:11.508]                           for (restart in restarts) {
[17:38:11.508]                             name <- restart$name
[17:38:11.508]                             if (is.null(name)) 
[17:38:11.508]                               next
[17:38:11.508]                             if (!grepl(pattern, name)) 
[17:38:11.508]                               next
[17:38:11.508]                             invokeRestart(restart)
[17:38:11.508]                             muffled <- TRUE
[17:38:11.508]                             break
[17:38:11.508]                           }
[17:38:11.508]                         }
[17:38:11.508]                       }
[17:38:11.508]                       invisible(muffled)
[17:38:11.508]                     }
[17:38:11.508]                     muffleCondition(cond, pattern = "^muffle")
[17:38:11.508]                   }
[17:38:11.508]                 }
[17:38:11.508]                 else {
[17:38:11.508]                   if (TRUE) {
[17:38:11.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.508]                     {
[17:38:11.508]                       inherits <- base::inherits
[17:38:11.508]                       invokeRestart <- base::invokeRestart
[17:38:11.508]                       is.null <- base::is.null
[17:38:11.508]                       muffled <- FALSE
[17:38:11.508]                       if (inherits(cond, "message")) {
[17:38:11.508]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:11.508]                         if (muffled) 
[17:38:11.508]                           invokeRestart("muffleMessage")
[17:38:11.508]                       }
[17:38:11.508]                       else if (inherits(cond, "warning")) {
[17:38:11.508]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:11.508]                         if (muffled) 
[17:38:11.508]                           invokeRestart("muffleWarning")
[17:38:11.508]                       }
[17:38:11.508]                       else if (inherits(cond, "condition")) {
[17:38:11.508]                         if (!is.null(pattern)) {
[17:38:11.508]                           computeRestarts <- base::computeRestarts
[17:38:11.508]                           grepl <- base::grepl
[17:38:11.508]                           restarts <- computeRestarts(cond)
[17:38:11.508]                           for (restart in restarts) {
[17:38:11.508]                             name <- restart$name
[17:38:11.508]                             if (is.null(name)) 
[17:38:11.508]                               next
[17:38:11.508]                             if (!grepl(pattern, name)) 
[17:38:11.508]                               next
[17:38:11.508]                             invokeRestart(restart)
[17:38:11.508]                             muffled <- TRUE
[17:38:11.508]                             break
[17:38:11.508]                           }
[17:38:11.508]                         }
[17:38:11.508]                       }
[17:38:11.508]                       invisible(muffled)
[17:38:11.508]                     }
[17:38:11.508]                     muffleCondition(cond, pattern = "^muffle")
[17:38:11.508]                   }
[17:38:11.508]                 }
[17:38:11.508]             }
[17:38:11.508]         }))
[17:38:11.508]     }, error = function(ex) {
[17:38:11.508]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:11.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:11.508]                 ...future.rng), started = ...future.startTime, 
[17:38:11.508]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:11.508]             version = "1.8"), class = "FutureResult")
[17:38:11.508]     }, finally = {
[17:38:11.508]         if (!identical(...future.workdir, getwd())) 
[17:38:11.508]             setwd(...future.workdir)
[17:38:11.508]         {
[17:38:11.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:11.508]                 ...future.oldOptions$nwarnings <- NULL
[17:38:11.508]             }
[17:38:11.508]             base::options(...future.oldOptions)
[17:38:11.508]             if (.Platform$OS.type == "windows") {
[17:38:11.508]                 old_names <- names(...future.oldEnvVars)
[17:38:11.508]                 envs <- base::Sys.getenv()
[17:38:11.508]                 names <- names(envs)
[17:38:11.508]                 common <- intersect(names, old_names)
[17:38:11.508]                 added <- setdiff(names, old_names)
[17:38:11.508]                 removed <- setdiff(old_names, names)
[17:38:11.508]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:11.508]                   envs[common]]
[17:38:11.508]                 NAMES <- toupper(changed)
[17:38:11.508]                 args <- list()
[17:38:11.508]                 for (kk in seq_along(NAMES)) {
[17:38:11.508]                   name <- changed[[kk]]
[17:38:11.508]                   NAME <- NAMES[[kk]]
[17:38:11.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.508]                     next
[17:38:11.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:11.508]                 }
[17:38:11.508]                 NAMES <- toupper(added)
[17:38:11.508]                 for (kk in seq_along(NAMES)) {
[17:38:11.508]                   name <- added[[kk]]
[17:38:11.508]                   NAME <- NAMES[[kk]]
[17:38:11.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.508]                     next
[17:38:11.508]                   args[[name]] <- ""
[17:38:11.508]                 }
[17:38:11.508]                 NAMES <- toupper(removed)
[17:38:11.508]                 for (kk in seq_along(NAMES)) {
[17:38:11.508]                   name <- removed[[kk]]
[17:38:11.508]                   NAME <- NAMES[[kk]]
[17:38:11.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.508]                     next
[17:38:11.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:11.508]                 }
[17:38:11.508]                 if (length(args) > 0) 
[17:38:11.508]                   base::do.call(base::Sys.setenv, args = args)
[17:38:11.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:11.508]             }
[17:38:11.508]             else {
[17:38:11.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:11.508]             }
[17:38:11.508]             {
[17:38:11.508]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:11.508]                   0L) {
[17:38:11.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:11.508]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:11.508]                   base::options(opts)
[17:38:11.508]                 }
[17:38:11.508]                 {
[17:38:11.508]                   {
[17:38:11.508]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:11.508]                     NULL
[17:38:11.508]                   }
[17:38:11.508]                   options(future.plan = NULL)
[17:38:11.508]                   if (is.na(NA_character_)) 
[17:38:11.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:11.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:11.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:11.508]                     .init = FALSE)
[17:38:11.508]                 }
[17:38:11.508]             }
[17:38:11.508]         }
[17:38:11.508]     })
[17:38:11.508]     if (TRUE) {
[17:38:11.508]         base::sink(type = "output", split = FALSE)
[17:38:11.508]         if (TRUE) {
[17:38:11.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:11.508]         }
[17:38:11.508]         else {
[17:38:11.508]             ...future.result["stdout"] <- base::list(NULL)
[17:38:11.508]         }
[17:38:11.508]         base::close(...future.stdout)
[17:38:11.508]         ...future.stdout <- NULL
[17:38:11.508]     }
[17:38:11.508]     ...future.result$conditions <- ...future.conditions
[17:38:11.508]     ...future.result$finished <- base::Sys.time()
[17:38:11.508]     ...future.result
[17:38:11.508] }
[17:38:11.510] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[17:38:11.511] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:38:11.553] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:38:11.553] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:38:11.553] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:38:11.553] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:38:11.554] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:38:11.554] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:38:11.601] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:38:11.601] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:38:11.645] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:38:11.645] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:38:11.645] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:38:11.645] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:38:11.646] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:38:11.646] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:11.646] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:11.647] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:38:11.647] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:38:11.647] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:11.647] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:11.648] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:11.648] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:11.648] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[17:38:11.649] MultisessionFuture started
[17:38:11.649] - Launch lazy future ... done
[17:38:11.649] run() for ‘MultisessionFuture’ ... done
[17:38:11.649] Created future:
[17:38:11.649] MultisessionFuture:
[17:38:11.649] Label: ‘future_vapply-1’
[17:38:11.649] Expression:
[17:38:11.649] {
[17:38:11.649]     do.call(function(...) {
[17:38:11.649]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.649]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:11.649]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.649]             on.exit(options(oopts), add = TRUE)
[17:38:11.649]         }
[17:38:11.649]         {
[17:38:11.649]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:11.649]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.649]                 ...future.FUN(...future.X_jj, ...)
[17:38:11.649]             })
[17:38:11.649]         }
[17:38:11.649]     }, args = future.call.arguments)
[17:38:11.649] }
[17:38:11.649] Lazy evaluation: FALSE
[17:38:11.649] Asynchronous evaluation: TRUE
[17:38:11.649] Local evaluation: TRUE
[17:38:11.649] Environment: R_GlobalEnv
[17:38:11.649] Capture standard output: TRUE
[17:38:11.649] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:11.649] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:11.649] Packages: 1 packages (‘future.apply’)
[17:38:11.649] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:11.649] Resolved: FALSE
[17:38:11.649] Value: <not collected>
[17:38:11.649] Conditions captured: <none>
[17:38:11.649] Early signaling: FALSE
[17:38:11.649] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:11.649] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:11.661] Chunk #1 of 2 ... DONE
[17:38:11.661] Chunk #2 of 2 ...
[17:38:11.661]  - Finding globals in 'X' for chunk #2 ...
[17:38:11.661] getGlobalsAndPackages() ...
[17:38:11.662] Searching for globals...
[17:38:11.662] 
[17:38:11.662] Searching for globals ... DONE
[17:38:11.662] - globals: [0] <none>
[17:38:11.662] getGlobalsAndPackages() ... DONE
[17:38:11.662]    + additional globals found: [n=0] 
[17:38:11.662]    + additional namespaces needed: [n=0] 
[17:38:11.662]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:11.662]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:11.663]  - seeds: <none>
[17:38:11.663]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.663] getGlobalsAndPackages() ...
[17:38:11.663] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.663] Resolving globals: FALSE
[17:38:11.663] Tweak future expression to call with '...' arguments ...
[17:38:11.663] {
[17:38:11.663]     do.call(function(...) {
[17:38:11.663]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.663]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:11.663]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.663]             on.exit(options(oopts), add = TRUE)
[17:38:11.663]         }
[17:38:11.663]         {
[17:38:11.663]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:11.663]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.663]                 ...future.FUN(...future.X_jj, ...)
[17:38:11.663]             })
[17:38:11.663]         }
[17:38:11.663]     }, args = future.call.arguments)
[17:38:11.663] }
[17:38:11.663] Tweak future expression to call with '...' arguments ... DONE
[17:38:11.664] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.664] - packages: [1] ‘future.apply’
[17:38:11.664] getGlobalsAndPackages() ... DONE
[17:38:11.665] run() for ‘Future’ ...
[17:38:11.665] - state: ‘created’
[17:38:11.665] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:11.682] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:11.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:11.682]   - Field: ‘node’
[17:38:11.682]   - Field: ‘label’
[17:38:11.682]   - Field: ‘local’
[17:38:11.682]   - Field: ‘owner’
[17:38:11.682]   - Field: ‘envir’
[17:38:11.683]   - Field: ‘workers’
[17:38:11.683]   - Field: ‘packages’
[17:38:11.683]   - Field: ‘gc’
[17:38:11.683]   - Field: ‘conditions’
[17:38:11.683]   - Field: ‘persistent’
[17:38:11.683]   - Field: ‘expr’
[17:38:11.683]   - Field: ‘uuid’
[17:38:11.683]   - Field: ‘seed’
[17:38:11.683]   - Field: ‘version’
[17:38:11.683]   - Field: ‘result’
[17:38:11.683]   - Field: ‘asynchronous’
[17:38:11.684]   - Field: ‘calls’
[17:38:11.684]   - Field: ‘globals’
[17:38:11.684]   - Field: ‘stdout’
[17:38:11.684]   - Field: ‘earlySignal’
[17:38:11.684]   - Field: ‘lazy’
[17:38:11.684]   - Field: ‘state’
[17:38:11.684] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:11.684] - Launch lazy future ...
[17:38:11.685] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:11.685] Packages needed by future strategies (n = 0): <none>
[17:38:11.685] {
[17:38:11.685]     {
[17:38:11.685]         {
[17:38:11.685]             ...future.startTime <- base::Sys.time()
[17:38:11.685]             {
[17:38:11.685]                 {
[17:38:11.685]                   {
[17:38:11.685]                     {
[17:38:11.685]                       {
[17:38:11.685]                         base::local({
[17:38:11.685]                           has_future <- base::requireNamespace("future", 
[17:38:11.685]                             quietly = TRUE)
[17:38:11.685]                           if (has_future) {
[17:38:11.685]                             ns <- base::getNamespace("future")
[17:38:11.685]                             version <- ns[[".package"]][["version"]]
[17:38:11.685]                             if (is.null(version)) 
[17:38:11.685]                               version <- utils::packageVersion("future")
[17:38:11.685]                           }
[17:38:11.685]                           else {
[17:38:11.685]                             version <- NULL
[17:38:11.685]                           }
[17:38:11.685]                           if (!has_future || version < "1.8.0") {
[17:38:11.685]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:11.685]                               "", base::R.version$version.string), 
[17:38:11.685]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:11.685]                                 base::R.version$platform, 8 * 
[17:38:11.685]                                   base::.Machine$sizeof.pointer), 
[17:38:11.685]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:11.685]                                 "release", "version")], collapse = " "), 
[17:38:11.685]                               hostname = base::Sys.info()[["nodename"]])
[17:38:11.685]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:11.685]                               info)
[17:38:11.685]                             info <- base::paste(info, collapse = "; ")
[17:38:11.685]                             if (!has_future) {
[17:38:11.685]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:11.685]                                 info)
[17:38:11.685]                             }
[17:38:11.685]                             else {
[17:38:11.685]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:11.685]                                 info, version)
[17:38:11.685]                             }
[17:38:11.685]                             base::stop(msg)
[17:38:11.685]                           }
[17:38:11.685]                         })
[17:38:11.685]                       }
[17:38:11.685]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:11.685]                       base::options(mc.cores = 1L)
[17:38:11.685]                     }
[17:38:11.685]                     base::local({
[17:38:11.685]                       for (pkg in "future.apply") {
[17:38:11.685]                         base::loadNamespace(pkg)
[17:38:11.685]                         base::library(pkg, character.only = TRUE)
[17:38:11.685]                       }
[17:38:11.685]                     })
[17:38:11.685]                   }
[17:38:11.685]                   ...future.strategy.old <- future::plan("list")
[17:38:11.685]                   options(future.plan = NULL)
[17:38:11.685]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:11.685]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:11.685]                 }
[17:38:11.685]                 ...future.workdir <- getwd()
[17:38:11.685]             }
[17:38:11.685]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:11.685]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:11.685]         }
[17:38:11.685]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:11.685]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:11.685]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:11.685]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:11.685]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:11.685]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:11.685]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:11.685]             base::names(...future.oldOptions))
[17:38:11.685]     }
[17:38:11.685]     if (FALSE) {
[17:38:11.685]     }
[17:38:11.685]     else {
[17:38:11.685]         if (TRUE) {
[17:38:11.685]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:11.685]                 open = "w")
[17:38:11.685]         }
[17:38:11.685]         else {
[17:38:11.685]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:11.685]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:11.685]         }
[17:38:11.685]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:11.685]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:11.685]             base::sink(type = "output", split = FALSE)
[17:38:11.685]             base::close(...future.stdout)
[17:38:11.685]         }, add = TRUE)
[17:38:11.685]     }
[17:38:11.685]     ...future.frame <- base::sys.nframe()
[17:38:11.685]     ...future.conditions <- base::list()
[17:38:11.685]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:11.685]     if (FALSE) {
[17:38:11.685]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:11.685]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:11.685]     }
[17:38:11.685]     ...future.result <- base::tryCatch({
[17:38:11.685]         base::withCallingHandlers({
[17:38:11.685]             ...future.value <- base::withVisible(base::local({
[17:38:11.685]                 ...future.makeSendCondition <- base::local({
[17:38:11.685]                   sendCondition <- NULL
[17:38:11.685]                   function(frame = 1L) {
[17:38:11.685]                     if (is.function(sendCondition)) 
[17:38:11.685]                       return(sendCondition)
[17:38:11.685]                     ns <- getNamespace("parallel")
[17:38:11.685]                     if (exists("sendData", mode = "function", 
[17:38:11.685]                       envir = ns)) {
[17:38:11.685]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:11.685]                         envir = ns)
[17:38:11.685]                       envir <- sys.frame(frame)
[17:38:11.685]                       master <- NULL
[17:38:11.685]                       while (!identical(envir, .GlobalEnv) && 
[17:38:11.685]                         !identical(envir, emptyenv())) {
[17:38:11.685]                         if (exists("master", mode = "list", envir = envir, 
[17:38:11.685]                           inherits = FALSE)) {
[17:38:11.685]                           master <- get("master", mode = "list", 
[17:38:11.685]                             envir = envir, inherits = FALSE)
[17:38:11.685]                           if (inherits(master, c("SOCKnode", 
[17:38:11.685]                             "SOCK0node"))) {
[17:38:11.685]                             sendCondition <<- function(cond) {
[17:38:11.685]                               data <- list(type = "VALUE", value = cond, 
[17:38:11.685]                                 success = TRUE)
[17:38:11.685]                               parallel_sendData(master, data)
[17:38:11.685]                             }
[17:38:11.685]                             return(sendCondition)
[17:38:11.685]                           }
[17:38:11.685]                         }
[17:38:11.685]                         frame <- frame + 1L
[17:38:11.685]                         envir <- sys.frame(frame)
[17:38:11.685]                       }
[17:38:11.685]                     }
[17:38:11.685]                     sendCondition <<- function(cond) NULL
[17:38:11.685]                   }
[17:38:11.685]                 })
[17:38:11.685]                 withCallingHandlers({
[17:38:11.685]                   {
[17:38:11.685]                     do.call(function(...) {
[17:38:11.685]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.685]                       if (!identical(...future.globals.maxSize.org, 
[17:38:11.685]                         ...future.globals.maxSize)) {
[17:38:11.685]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.685]                         on.exit(options(oopts), add = TRUE)
[17:38:11.685]                       }
[17:38:11.685]                       {
[17:38:11.685]                         lapply(seq_along(...future.elements_ii), 
[17:38:11.685]                           FUN = function(jj) {
[17:38:11.685]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.685]                             ...future.FUN(...future.X_jj, ...)
[17:38:11.685]                           })
[17:38:11.685]                       }
[17:38:11.685]                     }, args = future.call.arguments)
[17:38:11.685]                   }
[17:38:11.685]                 }, immediateCondition = function(cond) {
[17:38:11.685]                   sendCondition <- ...future.makeSendCondition()
[17:38:11.685]                   sendCondition(cond)
[17:38:11.685]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.685]                   {
[17:38:11.685]                     inherits <- base::inherits
[17:38:11.685]                     invokeRestart <- base::invokeRestart
[17:38:11.685]                     is.null <- base::is.null
[17:38:11.685]                     muffled <- FALSE
[17:38:11.685]                     if (inherits(cond, "message")) {
[17:38:11.685]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:11.685]                       if (muffled) 
[17:38:11.685]                         invokeRestart("muffleMessage")
[17:38:11.685]                     }
[17:38:11.685]                     else if (inherits(cond, "warning")) {
[17:38:11.685]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:11.685]                       if (muffled) 
[17:38:11.685]                         invokeRestart("muffleWarning")
[17:38:11.685]                     }
[17:38:11.685]                     else if (inherits(cond, "condition")) {
[17:38:11.685]                       if (!is.null(pattern)) {
[17:38:11.685]                         computeRestarts <- base::computeRestarts
[17:38:11.685]                         grepl <- base::grepl
[17:38:11.685]                         restarts <- computeRestarts(cond)
[17:38:11.685]                         for (restart in restarts) {
[17:38:11.685]                           name <- restart$name
[17:38:11.685]                           if (is.null(name)) 
[17:38:11.685]                             next
[17:38:11.685]                           if (!grepl(pattern, name)) 
[17:38:11.685]                             next
[17:38:11.685]                           invokeRestart(restart)
[17:38:11.685]                           muffled <- TRUE
[17:38:11.685]                           break
[17:38:11.685]                         }
[17:38:11.685]                       }
[17:38:11.685]                     }
[17:38:11.685]                     invisible(muffled)
[17:38:11.685]                   }
[17:38:11.685]                   muffleCondition(cond)
[17:38:11.685]                 })
[17:38:11.685]             }))
[17:38:11.685]             future::FutureResult(value = ...future.value$value, 
[17:38:11.685]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:11.685]                   ...future.rng), globalenv = if (FALSE) 
[17:38:11.685]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:11.685]                     ...future.globalenv.names))
[17:38:11.685]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:11.685]         }, condition = base::local({
[17:38:11.685]             c <- base::c
[17:38:11.685]             inherits <- base::inherits
[17:38:11.685]             invokeRestart <- base::invokeRestart
[17:38:11.685]             length <- base::length
[17:38:11.685]             list <- base::list
[17:38:11.685]             seq.int <- base::seq.int
[17:38:11.685]             signalCondition <- base::signalCondition
[17:38:11.685]             sys.calls <- base::sys.calls
[17:38:11.685]             `[[` <- base::`[[`
[17:38:11.685]             `+` <- base::`+`
[17:38:11.685]             `<<-` <- base::`<<-`
[17:38:11.685]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:11.685]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:11.685]                   3L)]
[17:38:11.685]             }
[17:38:11.685]             function(cond) {
[17:38:11.685]                 is_error <- inherits(cond, "error")
[17:38:11.685]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:11.685]                   NULL)
[17:38:11.685]                 if (is_error) {
[17:38:11.685]                   sessionInformation <- function() {
[17:38:11.685]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:11.685]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:11.685]                       search = base::search(), system = base::Sys.info())
[17:38:11.685]                   }
[17:38:11.685]                   ...future.conditions[[length(...future.conditions) + 
[17:38:11.685]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:11.685]                     cond$call), session = sessionInformation(), 
[17:38:11.685]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:11.685]                   signalCondition(cond)
[17:38:11.685]                 }
[17:38:11.685]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:11.685]                 "immediateCondition"))) {
[17:38:11.685]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:11.685]                   ...future.conditions[[length(...future.conditions) + 
[17:38:11.685]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:11.685]                   if (TRUE && !signal) {
[17:38:11.685]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.685]                     {
[17:38:11.685]                       inherits <- base::inherits
[17:38:11.685]                       invokeRestart <- base::invokeRestart
[17:38:11.685]                       is.null <- base::is.null
[17:38:11.685]                       muffled <- FALSE
[17:38:11.685]                       if (inherits(cond, "message")) {
[17:38:11.685]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:11.685]                         if (muffled) 
[17:38:11.685]                           invokeRestart("muffleMessage")
[17:38:11.685]                       }
[17:38:11.685]                       else if (inherits(cond, "warning")) {
[17:38:11.685]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:11.685]                         if (muffled) 
[17:38:11.685]                           invokeRestart("muffleWarning")
[17:38:11.685]                       }
[17:38:11.685]                       else if (inherits(cond, "condition")) {
[17:38:11.685]                         if (!is.null(pattern)) {
[17:38:11.685]                           computeRestarts <- base::computeRestarts
[17:38:11.685]                           grepl <- base::grepl
[17:38:11.685]                           restarts <- computeRestarts(cond)
[17:38:11.685]                           for (restart in restarts) {
[17:38:11.685]                             name <- restart$name
[17:38:11.685]                             if (is.null(name)) 
[17:38:11.685]                               next
[17:38:11.685]                             if (!grepl(pattern, name)) 
[17:38:11.685]                               next
[17:38:11.685]                             invokeRestart(restart)
[17:38:11.685]                             muffled <- TRUE
[17:38:11.685]                             break
[17:38:11.685]                           }
[17:38:11.685]                         }
[17:38:11.685]                       }
[17:38:11.685]                       invisible(muffled)
[17:38:11.685]                     }
[17:38:11.685]                     muffleCondition(cond, pattern = "^muffle")
[17:38:11.685]                   }
[17:38:11.685]                 }
[17:38:11.685]                 else {
[17:38:11.685]                   if (TRUE) {
[17:38:11.685]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.685]                     {
[17:38:11.685]                       inherits <- base::inherits
[17:38:11.685]                       invokeRestart <- base::invokeRestart
[17:38:11.685]                       is.null <- base::is.null
[17:38:11.685]                       muffled <- FALSE
[17:38:11.685]                       if (inherits(cond, "message")) {
[17:38:11.685]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:11.685]                         if (muffled) 
[17:38:11.685]                           invokeRestart("muffleMessage")
[17:38:11.685]                       }
[17:38:11.685]                       else if (inherits(cond, "warning")) {
[17:38:11.685]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:11.685]                         if (muffled) 
[17:38:11.685]                           invokeRestart("muffleWarning")
[17:38:11.685]                       }
[17:38:11.685]                       else if (inherits(cond, "condition")) {
[17:38:11.685]                         if (!is.null(pattern)) {
[17:38:11.685]                           computeRestarts <- base::computeRestarts
[17:38:11.685]                           grepl <- base::grepl
[17:38:11.685]                           restarts <- computeRestarts(cond)
[17:38:11.685]                           for (restart in restarts) {
[17:38:11.685]                             name <- restart$name
[17:38:11.685]                             if (is.null(name)) 
[17:38:11.685]                               next
[17:38:11.685]                             if (!grepl(pattern, name)) 
[17:38:11.685]                               next
[17:38:11.685]                             invokeRestart(restart)
[17:38:11.685]                             muffled <- TRUE
[17:38:11.685]                             break
[17:38:11.685]                           }
[17:38:11.685]                         }
[17:38:11.685]                       }
[17:38:11.685]                       invisible(muffled)
[17:38:11.685]                     }
[17:38:11.685]                     muffleCondition(cond, pattern = "^muffle")
[17:38:11.685]                   }
[17:38:11.685]                 }
[17:38:11.685]             }
[17:38:11.685]         }))
[17:38:11.685]     }, error = function(ex) {
[17:38:11.685]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:11.685]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:11.685]                 ...future.rng), started = ...future.startTime, 
[17:38:11.685]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:11.685]             version = "1.8"), class = "FutureResult")
[17:38:11.685]     }, finally = {
[17:38:11.685]         if (!identical(...future.workdir, getwd())) 
[17:38:11.685]             setwd(...future.workdir)
[17:38:11.685]         {
[17:38:11.685]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:11.685]                 ...future.oldOptions$nwarnings <- NULL
[17:38:11.685]             }
[17:38:11.685]             base::options(...future.oldOptions)
[17:38:11.685]             if (.Platform$OS.type == "windows") {
[17:38:11.685]                 old_names <- names(...future.oldEnvVars)
[17:38:11.685]                 envs <- base::Sys.getenv()
[17:38:11.685]                 names <- names(envs)
[17:38:11.685]                 common <- intersect(names, old_names)
[17:38:11.685]                 added <- setdiff(names, old_names)
[17:38:11.685]                 removed <- setdiff(old_names, names)
[17:38:11.685]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:11.685]                   envs[common]]
[17:38:11.685]                 NAMES <- toupper(changed)
[17:38:11.685]                 args <- list()
[17:38:11.685]                 for (kk in seq_along(NAMES)) {
[17:38:11.685]                   name <- changed[[kk]]
[17:38:11.685]                   NAME <- NAMES[[kk]]
[17:38:11.685]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.685]                     next
[17:38:11.685]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:11.685]                 }
[17:38:11.685]                 NAMES <- toupper(added)
[17:38:11.685]                 for (kk in seq_along(NAMES)) {
[17:38:11.685]                   name <- added[[kk]]
[17:38:11.685]                   NAME <- NAMES[[kk]]
[17:38:11.685]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.685]                     next
[17:38:11.685]                   args[[name]] <- ""
[17:38:11.685]                 }
[17:38:11.685]                 NAMES <- toupper(removed)
[17:38:11.685]                 for (kk in seq_along(NAMES)) {
[17:38:11.685]                   name <- removed[[kk]]
[17:38:11.685]                   NAME <- NAMES[[kk]]
[17:38:11.685]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.685]                     next
[17:38:11.685]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:11.685]                 }
[17:38:11.685]                 if (length(args) > 0) 
[17:38:11.685]                   base::do.call(base::Sys.setenv, args = args)
[17:38:11.685]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:11.685]             }
[17:38:11.685]             else {
[17:38:11.685]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:11.685]             }
[17:38:11.685]             {
[17:38:11.685]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:11.685]                   0L) {
[17:38:11.685]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:11.685]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:11.685]                   base::options(opts)
[17:38:11.685]                 }
[17:38:11.685]                 {
[17:38:11.685]                   {
[17:38:11.685]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:11.685]                     NULL
[17:38:11.685]                   }
[17:38:11.685]                   options(future.plan = NULL)
[17:38:11.685]                   if (is.na(NA_character_)) 
[17:38:11.685]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:11.685]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:11.685]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:11.685]                     .init = FALSE)
[17:38:11.685]                 }
[17:38:11.685]             }
[17:38:11.685]         }
[17:38:11.685]     })
[17:38:11.685]     if (TRUE) {
[17:38:11.685]         base::sink(type = "output", split = FALSE)
[17:38:11.685]         if (TRUE) {
[17:38:11.685]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:11.685]         }
[17:38:11.685]         else {
[17:38:11.685]             ...future.result["stdout"] <- base::list(NULL)
[17:38:11.685]         }
[17:38:11.685]         base::close(...future.stdout)
[17:38:11.685]         ...future.stdout <- NULL
[17:38:11.685]     }
[17:38:11.685]     ...future.result$conditions <- ...future.conditions
[17:38:11.685]     ...future.result$finished <- base::Sys.time()
[17:38:11.685]     ...future.result
[17:38:11.685] }
[17:38:11.688] Exporting 11 global objects (92.12 KiB) to cluster node #2 ...
[17:38:11.688] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:38:11.733] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:38:11.733] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[17:38:11.734] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[17:38:11.734] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:38:11.734] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:38:11.734] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:38:11.777] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:38:11.777] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:38:11.821] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:38:11.821] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:38:11.821] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:38:11.821] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:38:11.822] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:38:11.822] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:11.822] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:11.823] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:38:11.823] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:38:11.823] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:11.824] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:11.824] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:11.824] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:11.824] Exporting 11 global objects (92.12 KiB) to cluster node #2 ... DONE
[17:38:11.825] MultisessionFuture started
[17:38:11.825] - Launch lazy future ... done
[17:38:11.825] run() for ‘MultisessionFuture’ ... done
[17:38:11.825] Created future:
[17:38:11.827] receiveMessageFromWorker() for ClusterFuture ...
[17:38:11.827] - Validating connection of MultisessionFuture
[17:38:11.827] - received message: FutureResult
[17:38:11.827] - Received FutureResult
[17:38:11.827] - Erased future from FutureRegistry
[17:38:11.827] result() for ClusterFuture ...
[17:38:11.827] - result already collected: FutureResult
[17:38:11.827] result() for ClusterFuture ... done
[17:38:11.827] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:11.825] MultisessionFuture:
[17:38:11.825] Label: ‘future_vapply-2’
[17:38:11.825] Expression:
[17:38:11.825] {
[17:38:11.825]     do.call(function(...) {
[17:38:11.825]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.825]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:11.825]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.825]             on.exit(options(oopts), add = TRUE)
[17:38:11.825]         }
[17:38:11.825]         {
[17:38:11.825]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:11.825]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.825]                 ...future.FUN(...future.X_jj, ...)
[17:38:11.825]             })
[17:38:11.825]         }
[17:38:11.825]     }, args = future.call.arguments)
[17:38:11.825] }
[17:38:11.825] Lazy evaluation: FALSE
[17:38:11.825] Asynchronous evaluation: TRUE
[17:38:11.825] Local evaluation: TRUE
[17:38:11.825] Environment: R_GlobalEnv
[17:38:11.825] Capture standard output: TRUE
[17:38:11.825] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:11.825] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:11.825] Packages: 1 packages (‘future.apply’)
[17:38:11.825] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:11.825] Resolved: TRUE
[17:38:11.825] Value: <not collected>
[17:38:11.825] Conditions captured: <none>
[17:38:11.825] Early signaling: FALSE
[17:38:11.825] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:11.825] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:11.828] Chunk #2 of 2 ... DONE
[17:38:11.828] Launching 2 futures (chunks) ... DONE
[17:38:11.828] Resolving 2 futures (chunks) ...
[17:38:11.828] resolve() on list ...
[17:38:11.828]  recursive: 0
[17:38:11.828]  length: 2
[17:38:11.828] 
[17:38:11.829] receiveMessageFromWorker() for ClusterFuture ...
[17:38:11.829] - Validating connection of MultisessionFuture
[17:38:11.829] - received message: FutureResult
[17:38:11.829] - Received FutureResult
[17:38:11.829] - Erased future from FutureRegistry
[17:38:11.829] result() for ClusterFuture ...
[17:38:11.830] - result already collected: FutureResult
[17:38:11.830] result() for ClusterFuture ... done
[17:38:11.830] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:11.830] Future #1
[17:38:11.830] result() for ClusterFuture ...
[17:38:11.830] - result already collected: FutureResult
[17:38:11.830] result() for ClusterFuture ... done
[17:38:11.830] result() for ClusterFuture ...
[17:38:11.830] - result already collected: FutureResult
[17:38:11.830] result() for ClusterFuture ... done
[17:38:11.830] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:11.830] - nx: 2
[17:38:11.831] - relay: TRUE
[17:38:11.831] - stdout: TRUE
[17:38:11.831] - signal: TRUE
[17:38:11.831] - resignal: FALSE
[17:38:11.831] - force: TRUE
[17:38:11.831] - relayed: [n=2] FALSE, FALSE
[17:38:11.831] - queued futures: [n=2] FALSE, FALSE
[17:38:11.831]  - until=1
[17:38:11.831]  - relaying element #1
[17:38:11.831] result() for ClusterFuture ...
[17:38:11.831] - result already collected: FutureResult
[17:38:11.831] result() for ClusterFuture ... done
[17:38:11.832] result() for ClusterFuture ...
[17:38:11.832] - result already collected: FutureResult
[17:38:11.832] result() for ClusterFuture ... done
[17:38:11.832] result() for ClusterFuture ...
[17:38:11.832] - result already collected: FutureResult
[17:38:11.832] result() for ClusterFuture ... done
[17:38:11.832] result() for ClusterFuture ...
[17:38:11.832] - result already collected: FutureResult
[17:38:11.832] result() for ClusterFuture ... done
[17:38:11.832] - relayed: [n=2] TRUE, FALSE
[17:38:11.832] - queued futures: [n=2] TRUE, FALSE
[17:38:11.833] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:11.833]  length: 1 (resolved future 1)
[17:38:11.833] Future #2
[17:38:11.833] result() for ClusterFuture ...
[17:38:11.833] - result already collected: FutureResult
[17:38:11.833] result() for ClusterFuture ... done
[17:38:11.833] result() for ClusterFuture ...
[17:38:11.833] - result already collected: FutureResult
[17:38:11.833] result() for ClusterFuture ... done
[17:38:11.833] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:11.834] - nx: 2
[17:38:11.834] - relay: TRUE
[17:38:11.834] - stdout: TRUE
[17:38:11.834] - signal: TRUE
[17:38:11.834] - resignal: FALSE
[17:38:11.834] - force: TRUE
[17:38:11.834] - relayed: [n=2] TRUE, FALSE
[17:38:11.834] - queued futures: [n=2] TRUE, FALSE
[17:38:11.834]  - until=2
[17:38:11.834]  - relaying element #2
[17:38:11.834] result() for ClusterFuture ...
[17:38:11.834] - result already collected: FutureResult
[17:38:11.835] result() for ClusterFuture ... done
[17:38:11.835] result() for ClusterFuture ...
[17:38:11.835] - result already collected: FutureResult
[17:38:11.835] result() for ClusterFuture ... done
[17:38:11.835] result() for ClusterFuture ...
[17:38:11.835] - result already collected: FutureResult
[17:38:11.835] result() for ClusterFuture ... done
[17:38:11.835] result() for ClusterFuture ...
[17:38:11.835] - result already collected: FutureResult
[17:38:11.835] result() for ClusterFuture ... done
[17:38:11.835] - relayed: [n=2] TRUE, TRUE
[17:38:11.835] - queued futures: [n=2] TRUE, TRUE
[17:38:11.836] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:11.836]  length: 0 (resolved future 2)
[17:38:11.836] Relaying remaining futures
[17:38:11.836] signalConditionsASAP(NULL, pos=0) ...
[17:38:11.836] - nx: 2
[17:38:11.836] - relay: TRUE
[17:38:11.836] - stdout: TRUE
[17:38:11.836] - signal: TRUE
[17:38:11.836] - resignal: FALSE
[17:38:11.836] - force: TRUE
[17:38:11.836] - relayed: [n=2] TRUE, TRUE
[17:38:11.836] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:11.837] - relayed: [n=2] TRUE, TRUE
[17:38:11.837] - queued futures: [n=2] TRUE, TRUE
[17:38:11.837] signalConditionsASAP(NULL, pos=0) ... done
[17:38:11.837] resolve() on list ... DONE
[17:38:11.837] result() for ClusterFuture ...
[17:38:11.837] - result already collected: FutureResult
[17:38:11.837] result() for ClusterFuture ... done
[17:38:11.837] result() for ClusterFuture ...
[17:38:11.837] - result already collected: FutureResult
[17:38:11.837] result() for ClusterFuture ... done
[17:38:11.838] result() for ClusterFuture ...
[17:38:11.838] - result already collected: FutureResult
[17:38:11.838] result() for ClusterFuture ... done
[17:38:11.838] result() for ClusterFuture ...
[17:38:11.838] - result already collected: FutureResult
[17:38:11.838] result() for ClusterFuture ... done
[17:38:11.838]  - Number of value chunks collected: 2
[17:38:11.838] Resolving 2 futures (chunks) ... DONE
[17:38:11.838] Reducing values from 2 chunks ...
[17:38:11.838]  - Number of values collected after concatenation: 10
[17:38:11.838]  - Number of values expected: 10
[17:38:11.838] Reducing values from 2 chunks ... DONE
[17:38:11.839] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[17:38:11.839] future_lapply() ...
[17:38:11.845] Number of chunks: 2
[17:38:11.845] getGlobalsAndPackagesXApply() ...
[17:38:11.845]  - future.globals: TRUE
[17:38:11.845] getGlobalsAndPackages() ...
[17:38:11.845] Searching for globals...
[17:38:11.849] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[17:38:11.849] Searching for globals ... DONE
[17:38:11.849] Resolving globals: FALSE
[17:38:11.850] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[17:38:11.850] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:11.850] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:11.851] - packages: [1] ‘future.apply’
[17:38:11.851] getGlobalsAndPackages() ... DONE
[17:38:11.851]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:11.851]  - needed namespaces: [n=1] ‘future.apply’
[17:38:11.851] Finding globals ... DONE
[17:38:11.851]  - use_args: TRUE
[17:38:11.851]  - Getting '...' globals ...
[17:38:11.851] resolve() on list ...
[17:38:11.851]  recursive: 0
[17:38:11.852]  length: 1
[17:38:11.852]  elements: ‘...’
[17:38:11.852]  length: 0 (resolved future 1)
[17:38:11.852] resolve() on list ... DONE
[17:38:11.852]    - '...' content: [n=0] 
[17:38:11.852] List of 1
[17:38:11.852]  $ ...: list()
[17:38:11.852]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:11.852]  - attr(*, "where")=List of 1
[17:38:11.852]   ..$ ...:<environment: 0x560803391780> 
[17:38:11.852]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:11.852]  - attr(*, "resolved")= logi TRUE
[17:38:11.852]  - attr(*, "total_size")= num NA
[17:38:11.854]  - Getting '...' globals ... DONE
[17:38:11.855] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:11.855] List of 8
[17:38:11.855]  $ ...future.FUN:function (x, ...)  
[17:38:11.855]  $ x_FUN        :function (x)  
[17:38:11.855]  $ times        : int 2
[17:38:11.855]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:11.855]  $ stop_if_not  :function (...)  
[17:38:11.855]  $ dim          : NULL
[17:38:11.855]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:11.855]  $ ...          : list()
[17:38:11.855]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:11.855]  - attr(*, "where")=List of 8
[17:38:11.855]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:11.855]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:11.855]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:11.855]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:11.855]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:11.855]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:11.855]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:11.855]   ..$ ...          :<environment: 0x560803391780> 
[17:38:11.855]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:11.855]  - attr(*, "resolved")= logi FALSE
[17:38:11.855]  - attr(*, "total_size")= num 96456
[17:38:11.860] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:11.860] getGlobalsAndPackagesXApply() ... DONE
[17:38:11.860] Number of futures (= number of chunks): 2
[17:38:11.860] Launching 2 futures (chunks) ...
[17:38:11.860] Chunk #1 of 2 ...
[17:38:11.861]  - Finding globals in 'X' for chunk #1 ...
[17:38:11.861] getGlobalsAndPackages() ...
[17:38:11.861] Searching for globals...
[17:38:11.861] 
[17:38:11.861] Searching for globals ... DONE
[17:38:11.861] - globals: [0] <none>
[17:38:11.861] getGlobalsAndPackages() ... DONE
[17:38:11.861]    + additional globals found: [n=0] 
[17:38:11.861]    + additional namespaces needed: [n=0] 
[17:38:11.861]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:11.862]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:11.862]  - seeds: <none>
[17:38:11.862]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.862] getGlobalsAndPackages() ...
[17:38:11.862] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.862] Resolving globals: FALSE
[17:38:11.862] Tweak future expression to call with '...' arguments ...
[17:38:11.862] {
[17:38:11.862]     do.call(function(...) {
[17:38:11.862]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.862]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:11.862]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.862]             on.exit(options(oopts), add = TRUE)
[17:38:11.862]         }
[17:38:11.862]         {
[17:38:11.862]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:11.862]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.862]                 ...future.FUN(...future.X_jj, ...)
[17:38:11.862]             })
[17:38:11.862]         }
[17:38:11.862]     }, args = future.call.arguments)
[17:38:11.862] }
[17:38:11.863] Tweak future expression to call with '...' arguments ... DONE
[17:38:11.863] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:11.863] - packages: [1] ‘future.apply’
[17:38:11.863] getGlobalsAndPackages() ... DONE
[17:38:11.864] run() for ‘Future’ ...
[17:38:11.864] - state: ‘created’
[17:38:11.864] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:11.878] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:11.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:11.879]   - Field: ‘node’
[17:38:11.879]   - Field: ‘label’
[17:38:11.879]   - Field: ‘local’
[17:38:11.879]   - Field: ‘owner’
[17:38:11.879]   - Field: ‘envir’
[17:38:11.879]   - Field: ‘workers’
[17:38:11.879]   - Field: ‘packages’
[17:38:11.879]   - Field: ‘gc’
[17:38:11.880]   - Field: ‘conditions’
[17:38:11.880]   - Field: ‘persistent’
[17:38:11.880]   - Field: ‘expr’
[17:38:11.880]   - Field: ‘uuid’
[17:38:11.880]   - Field: ‘seed’
[17:38:11.880]   - Field: ‘version’
[17:38:11.880]   - Field: ‘result’
[17:38:11.880]   - Field: ‘asynchronous’
[17:38:11.880]   - Field: ‘calls’
[17:38:11.880]   - Field: ‘globals’
[17:38:11.880]   - Field: ‘stdout’
[17:38:11.881]   - Field: ‘earlySignal’
[17:38:11.881]   - Field: ‘lazy’
[17:38:11.881]   - Field: ‘state’
[17:38:11.881] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:11.881] - Launch lazy future ...
[17:38:11.881] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:11.881] Packages needed by future strategies (n = 0): <none>
[17:38:11.882] {
[17:38:11.882]     {
[17:38:11.882]         {
[17:38:11.882]             ...future.startTime <- base::Sys.time()
[17:38:11.882]             {
[17:38:11.882]                 {
[17:38:11.882]                   {
[17:38:11.882]                     {
[17:38:11.882]                       {
[17:38:11.882]                         base::local({
[17:38:11.882]                           has_future <- base::requireNamespace("future", 
[17:38:11.882]                             quietly = TRUE)
[17:38:11.882]                           if (has_future) {
[17:38:11.882]                             ns <- base::getNamespace("future")
[17:38:11.882]                             version <- ns[[".package"]][["version"]]
[17:38:11.882]                             if (is.null(version)) 
[17:38:11.882]                               version <- utils::packageVersion("future")
[17:38:11.882]                           }
[17:38:11.882]                           else {
[17:38:11.882]                             version <- NULL
[17:38:11.882]                           }
[17:38:11.882]                           if (!has_future || version < "1.8.0") {
[17:38:11.882]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:11.882]                               "", base::R.version$version.string), 
[17:38:11.882]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:11.882]                                 base::R.version$platform, 8 * 
[17:38:11.882]                                   base::.Machine$sizeof.pointer), 
[17:38:11.882]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:11.882]                                 "release", "version")], collapse = " "), 
[17:38:11.882]                               hostname = base::Sys.info()[["nodename"]])
[17:38:11.882]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:11.882]                               info)
[17:38:11.882]                             info <- base::paste(info, collapse = "; ")
[17:38:11.882]                             if (!has_future) {
[17:38:11.882]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:11.882]                                 info)
[17:38:11.882]                             }
[17:38:11.882]                             else {
[17:38:11.882]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:11.882]                                 info, version)
[17:38:11.882]                             }
[17:38:11.882]                             base::stop(msg)
[17:38:11.882]                           }
[17:38:11.882]                         })
[17:38:11.882]                       }
[17:38:11.882]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:11.882]                       base::options(mc.cores = 1L)
[17:38:11.882]                     }
[17:38:11.882]                     base::local({
[17:38:11.882]                       for (pkg in "future.apply") {
[17:38:11.882]                         base::loadNamespace(pkg)
[17:38:11.882]                         base::library(pkg, character.only = TRUE)
[17:38:11.882]                       }
[17:38:11.882]                     })
[17:38:11.882]                   }
[17:38:11.882]                   ...future.strategy.old <- future::plan("list")
[17:38:11.882]                   options(future.plan = NULL)
[17:38:11.882]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:11.882]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:11.882]                 }
[17:38:11.882]                 ...future.workdir <- getwd()
[17:38:11.882]             }
[17:38:11.882]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:11.882]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:11.882]         }
[17:38:11.882]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:11.882]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:11.882]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:11.882]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:11.882]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:11.882]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:11.882]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:11.882]             base::names(...future.oldOptions))
[17:38:11.882]     }
[17:38:11.882]     if (FALSE) {
[17:38:11.882]     }
[17:38:11.882]     else {
[17:38:11.882]         if (TRUE) {
[17:38:11.882]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:11.882]                 open = "w")
[17:38:11.882]         }
[17:38:11.882]         else {
[17:38:11.882]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:11.882]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:11.882]         }
[17:38:11.882]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:11.882]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:11.882]             base::sink(type = "output", split = FALSE)
[17:38:11.882]             base::close(...future.stdout)
[17:38:11.882]         }, add = TRUE)
[17:38:11.882]     }
[17:38:11.882]     ...future.frame <- base::sys.nframe()
[17:38:11.882]     ...future.conditions <- base::list()
[17:38:11.882]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:11.882]     if (FALSE) {
[17:38:11.882]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:11.882]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:11.882]     }
[17:38:11.882]     ...future.result <- base::tryCatch({
[17:38:11.882]         base::withCallingHandlers({
[17:38:11.882]             ...future.value <- base::withVisible(base::local({
[17:38:11.882]                 ...future.makeSendCondition <- base::local({
[17:38:11.882]                   sendCondition <- NULL
[17:38:11.882]                   function(frame = 1L) {
[17:38:11.882]                     if (is.function(sendCondition)) 
[17:38:11.882]                       return(sendCondition)
[17:38:11.882]                     ns <- getNamespace("parallel")
[17:38:11.882]                     if (exists("sendData", mode = "function", 
[17:38:11.882]                       envir = ns)) {
[17:38:11.882]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:11.882]                         envir = ns)
[17:38:11.882]                       envir <- sys.frame(frame)
[17:38:11.882]                       master <- NULL
[17:38:11.882]                       while (!identical(envir, .GlobalEnv) && 
[17:38:11.882]                         !identical(envir, emptyenv())) {
[17:38:11.882]                         if (exists("master", mode = "list", envir = envir, 
[17:38:11.882]                           inherits = FALSE)) {
[17:38:11.882]                           master <- get("master", mode = "list", 
[17:38:11.882]                             envir = envir, inherits = FALSE)
[17:38:11.882]                           if (inherits(master, c("SOCKnode", 
[17:38:11.882]                             "SOCK0node"))) {
[17:38:11.882]                             sendCondition <<- function(cond) {
[17:38:11.882]                               data <- list(type = "VALUE", value = cond, 
[17:38:11.882]                                 success = TRUE)
[17:38:11.882]                               parallel_sendData(master, data)
[17:38:11.882]                             }
[17:38:11.882]                             return(sendCondition)
[17:38:11.882]                           }
[17:38:11.882]                         }
[17:38:11.882]                         frame <- frame + 1L
[17:38:11.882]                         envir <- sys.frame(frame)
[17:38:11.882]                       }
[17:38:11.882]                     }
[17:38:11.882]                     sendCondition <<- function(cond) NULL
[17:38:11.882]                   }
[17:38:11.882]                 })
[17:38:11.882]                 withCallingHandlers({
[17:38:11.882]                   {
[17:38:11.882]                     do.call(function(...) {
[17:38:11.882]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:11.882]                       if (!identical(...future.globals.maxSize.org, 
[17:38:11.882]                         ...future.globals.maxSize)) {
[17:38:11.882]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:11.882]                         on.exit(options(oopts), add = TRUE)
[17:38:11.882]                       }
[17:38:11.882]                       {
[17:38:11.882]                         lapply(seq_along(...future.elements_ii), 
[17:38:11.882]                           FUN = function(jj) {
[17:38:11.882]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:11.882]                             ...future.FUN(...future.X_jj, ...)
[17:38:11.882]                           })
[17:38:11.882]                       }
[17:38:11.882]                     }, args = future.call.arguments)
[17:38:11.882]                   }
[17:38:11.882]                 }, immediateCondition = function(cond) {
[17:38:11.882]                   sendCondition <- ...future.makeSendCondition()
[17:38:11.882]                   sendCondition(cond)
[17:38:11.882]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.882]                   {
[17:38:11.882]                     inherits <- base::inherits
[17:38:11.882]                     invokeRestart <- base::invokeRestart
[17:38:11.882]                     is.null <- base::is.null
[17:38:11.882]                     muffled <- FALSE
[17:38:11.882]                     if (inherits(cond, "message")) {
[17:38:11.882]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:11.882]                       if (muffled) 
[17:38:11.882]                         invokeRestart("muffleMessage")
[17:38:11.882]                     }
[17:38:11.882]                     else if (inherits(cond, "warning")) {
[17:38:11.882]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:11.882]                       if (muffled) 
[17:38:11.882]                         invokeRestart("muffleWarning")
[17:38:11.882]                     }
[17:38:11.882]                     else if (inherits(cond, "condition")) {
[17:38:11.882]                       if (!is.null(pattern)) {
[17:38:11.882]                         computeRestarts <- base::computeRestarts
[17:38:11.882]                         grepl <- base::grepl
[17:38:11.882]                         restarts <- computeRestarts(cond)
[17:38:11.882]                         for (restart in restarts) {
[17:38:11.882]                           name <- restart$name
[17:38:11.882]                           if (is.null(name)) 
[17:38:11.882]                             next
[17:38:11.882]                           if (!grepl(pattern, name)) 
[17:38:11.882]                             next
[17:38:11.882]                           invokeRestart(restart)
[17:38:11.882]                           muffled <- TRUE
[17:38:11.882]                           break
[17:38:11.882]                         }
[17:38:11.882]                       }
[17:38:11.882]                     }
[17:38:11.882]                     invisible(muffled)
[17:38:11.882]                   }
[17:38:11.882]                   muffleCondition(cond)
[17:38:11.882]                 })
[17:38:11.882]             }))
[17:38:11.882]             future::FutureResult(value = ...future.value$value, 
[17:38:11.882]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:11.882]                   ...future.rng), globalenv = if (FALSE) 
[17:38:11.882]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:11.882]                     ...future.globalenv.names))
[17:38:11.882]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:11.882]         }, condition = base::local({
[17:38:11.882]             c <- base::c
[17:38:11.882]             inherits <- base::inherits
[17:38:11.882]             invokeRestart <- base::invokeRestart
[17:38:11.882]             length <- base::length
[17:38:11.882]             list <- base::list
[17:38:11.882]             seq.int <- base::seq.int
[17:38:11.882]             signalCondition <- base::signalCondition
[17:38:11.882]             sys.calls <- base::sys.calls
[17:38:11.882]             `[[` <- base::`[[`
[17:38:11.882]             `+` <- base::`+`
[17:38:11.882]             `<<-` <- base::`<<-`
[17:38:11.882]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:11.882]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:11.882]                   3L)]
[17:38:11.882]             }
[17:38:11.882]             function(cond) {
[17:38:11.882]                 is_error <- inherits(cond, "error")
[17:38:11.882]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:11.882]                   NULL)
[17:38:11.882]                 if (is_error) {
[17:38:11.882]                   sessionInformation <- function() {
[17:38:11.882]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:11.882]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:11.882]                       search = base::search(), system = base::Sys.info())
[17:38:11.882]                   }
[17:38:11.882]                   ...future.conditions[[length(...future.conditions) + 
[17:38:11.882]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:11.882]                     cond$call), session = sessionInformation(), 
[17:38:11.882]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:11.882]                   signalCondition(cond)
[17:38:11.882]                 }
[17:38:11.882]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:11.882]                 "immediateCondition"))) {
[17:38:11.882]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:11.882]                   ...future.conditions[[length(...future.conditions) + 
[17:38:11.882]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:11.882]                   if (TRUE && !signal) {
[17:38:11.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.882]                     {
[17:38:11.882]                       inherits <- base::inherits
[17:38:11.882]                       invokeRestart <- base::invokeRestart
[17:38:11.882]                       is.null <- base::is.null
[17:38:11.882]                       muffled <- FALSE
[17:38:11.882]                       if (inherits(cond, "message")) {
[17:38:11.882]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:11.882]                         if (muffled) 
[17:38:11.882]                           invokeRestart("muffleMessage")
[17:38:11.882]                       }
[17:38:11.882]                       else if (inherits(cond, "warning")) {
[17:38:11.882]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:11.882]                         if (muffled) 
[17:38:11.882]                           invokeRestart("muffleWarning")
[17:38:11.882]                       }
[17:38:11.882]                       else if (inherits(cond, "condition")) {
[17:38:11.882]                         if (!is.null(pattern)) {
[17:38:11.882]                           computeRestarts <- base::computeRestarts
[17:38:11.882]                           grepl <- base::grepl
[17:38:11.882]                           restarts <- computeRestarts(cond)
[17:38:11.882]                           for (restart in restarts) {
[17:38:11.882]                             name <- restart$name
[17:38:11.882]                             if (is.null(name)) 
[17:38:11.882]                               next
[17:38:11.882]                             if (!grepl(pattern, name)) 
[17:38:11.882]                               next
[17:38:11.882]                             invokeRestart(restart)
[17:38:11.882]                             muffled <- TRUE
[17:38:11.882]                             break
[17:38:11.882]                           }
[17:38:11.882]                         }
[17:38:11.882]                       }
[17:38:11.882]                       invisible(muffled)
[17:38:11.882]                     }
[17:38:11.882]                     muffleCondition(cond, pattern = "^muffle")
[17:38:11.882]                   }
[17:38:11.882]                 }
[17:38:11.882]                 else {
[17:38:11.882]                   if (TRUE) {
[17:38:11.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:11.882]                     {
[17:38:11.882]                       inherits <- base::inherits
[17:38:11.882]                       invokeRestart <- base::invokeRestart
[17:38:11.882]                       is.null <- base::is.null
[17:38:11.882]                       muffled <- FALSE
[17:38:11.882]                       if (inherits(cond, "message")) {
[17:38:11.882]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:11.882]                         if (muffled) 
[17:38:11.882]                           invokeRestart("muffleMessage")
[17:38:11.882]                       }
[17:38:11.882]                       else if (inherits(cond, "warning")) {
[17:38:11.882]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:11.882]                         if (muffled) 
[17:38:11.882]                           invokeRestart("muffleWarning")
[17:38:11.882]                       }
[17:38:11.882]                       else if (inherits(cond, "condition")) {
[17:38:11.882]                         if (!is.null(pattern)) {
[17:38:11.882]                           computeRestarts <- base::computeRestarts
[17:38:11.882]                           grepl <- base::grepl
[17:38:11.882]                           restarts <- computeRestarts(cond)
[17:38:11.882]                           for (restart in restarts) {
[17:38:11.882]                             name <- restart$name
[17:38:11.882]                             if (is.null(name)) 
[17:38:11.882]                               next
[17:38:11.882]                             if (!grepl(pattern, name)) 
[17:38:11.882]                               next
[17:38:11.882]                             invokeRestart(restart)
[17:38:11.882]                             muffled <- TRUE
[17:38:11.882]                             break
[17:38:11.882]                           }
[17:38:11.882]                         }
[17:38:11.882]                       }
[17:38:11.882]                       invisible(muffled)
[17:38:11.882]                     }
[17:38:11.882]                     muffleCondition(cond, pattern = "^muffle")
[17:38:11.882]                   }
[17:38:11.882]                 }
[17:38:11.882]             }
[17:38:11.882]         }))
[17:38:11.882]     }, error = function(ex) {
[17:38:11.882]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:11.882]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:11.882]                 ...future.rng), started = ...future.startTime, 
[17:38:11.882]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:11.882]             version = "1.8"), class = "FutureResult")
[17:38:11.882]     }, finally = {
[17:38:11.882]         if (!identical(...future.workdir, getwd())) 
[17:38:11.882]             setwd(...future.workdir)
[17:38:11.882]         {
[17:38:11.882]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:11.882]                 ...future.oldOptions$nwarnings <- NULL
[17:38:11.882]             }
[17:38:11.882]             base::options(...future.oldOptions)
[17:38:11.882]             if (.Platform$OS.type == "windows") {
[17:38:11.882]                 old_names <- names(...future.oldEnvVars)
[17:38:11.882]                 envs <- base::Sys.getenv()
[17:38:11.882]                 names <- names(envs)
[17:38:11.882]                 common <- intersect(names, old_names)
[17:38:11.882]                 added <- setdiff(names, old_names)
[17:38:11.882]                 removed <- setdiff(old_names, names)
[17:38:11.882]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:11.882]                   envs[common]]
[17:38:11.882]                 NAMES <- toupper(changed)
[17:38:11.882]                 args <- list()
[17:38:11.882]                 for (kk in seq_along(NAMES)) {
[17:38:11.882]                   name <- changed[[kk]]
[17:38:11.882]                   NAME <- NAMES[[kk]]
[17:38:11.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.882]                     next
[17:38:11.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:11.882]                 }
[17:38:11.882]                 NAMES <- toupper(added)
[17:38:11.882]                 for (kk in seq_along(NAMES)) {
[17:38:11.882]                   name <- added[[kk]]
[17:38:11.882]                   NAME <- NAMES[[kk]]
[17:38:11.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.882]                     next
[17:38:11.882]                   args[[name]] <- ""
[17:38:11.882]                 }
[17:38:11.882]                 NAMES <- toupper(removed)
[17:38:11.882]                 for (kk in seq_along(NAMES)) {
[17:38:11.882]                   name <- removed[[kk]]
[17:38:11.882]                   NAME <- NAMES[[kk]]
[17:38:11.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:11.882]                     next
[17:38:11.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:11.882]                 }
[17:38:11.882]                 if (length(args) > 0) 
[17:38:11.882]                   base::do.call(base::Sys.setenv, args = args)
[17:38:11.882]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:11.882]             }
[17:38:11.882]             else {
[17:38:11.882]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:11.882]             }
[17:38:11.882]             {
[17:38:11.882]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:11.882]                   0L) {
[17:38:11.882]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:11.882]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:11.882]                   base::options(opts)
[17:38:11.882]                 }
[17:38:11.882]                 {
[17:38:11.882]                   {
[17:38:11.882]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:11.882]                     NULL
[17:38:11.882]                   }
[17:38:11.882]                   options(future.plan = NULL)
[17:38:11.882]                   if (is.na(NA_character_)) 
[17:38:11.882]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:11.882]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:11.882]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:11.882]                     .init = FALSE)
[17:38:11.882]                 }
[17:38:11.882]             }
[17:38:11.882]         }
[17:38:11.882]     })
[17:38:11.882]     if (TRUE) {
[17:38:11.882]         base::sink(type = "output", split = FALSE)
[17:38:11.882]         if (TRUE) {
[17:38:11.882]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:11.882]         }
[17:38:11.882]         else {
[17:38:11.882]             ...future.result["stdout"] <- base::list(NULL)
[17:38:11.882]         }
[17:38:11.882]         base::close(...future.stdout)
[17:38:11.882]         ...future.stdout <- NULL
[17:38:11.882]     }
[17:38:11.882]     ...future.result$conditions <- ...future.conditions
[17:38:11.882]     ...future.result$finished <- base::Sys.time()
[17:38:11.882]     ...future.result
[17:38:11.882] }
[17:38:11.885] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[17:38:11.885] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:38:11.929] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:38:11.929] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[17:38:11.929] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[17:38:11.929] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:38:11.930] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:38:11.930] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:38:11.973] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:38:11.973] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:38:12.017] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:38:12.017] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:38:12.017] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:38:12.018] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:38:12.018] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:38:12.018] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:12.019] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:12.019] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:38:12.019] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:38:12.019] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:12.020] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:12.020] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:12.020] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:12.020] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[17:38:12.021] MultisessionFuture started
[17:38:12.021] - Launch lazy future ... done
[17:38:12.021] run() for ‘MultisessionFuture’ ... done
[17:38:12.022] Created future:
[17:38:12.022] MultisessionFuture:
[17:38:12.022] Label: ‘future_vapply-1’
[17:38:12.022] Expression:
[17:38:12.022] {
[17:38:12.022]     do.call(function(...) {
[17:38:12.022]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.022]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:12.022]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.022]             on.exit(options(oopts), add = TRUE)
[17:38:12.022]         }
[17:38:12.022]         {
[17:38:12.022]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:12.022]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.022]                 ...future.FUN(...future.X_jj, ...)
[17:38:12.022]             })
[17:38:12.022]         }
[17:38:12.022]     }, args = future.call.arguments)
[17:38:12.022] }
[17:38:12.022] Lazy evaluation: FALSE
[17:38:12.022] Asynchronous evaluation: TRUE
[17:38:12.022] Local evaluation: TRUE
[17:38:12.022] Environment: R_GlobalEnv
[17:38:12.022] Capture standard output: TRUE
[17:38:12.022] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:12.022] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:12.022] Packages: 1 packages (‘future.apply’)
[17:38:12.022] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:12.022] Resolved: FALSE
[17:38:12.022] Value: <not collected>
[17:38:12.022] Conditions captured: <none>
[17:38:12.022] Early signaling: FALSE
[17:38:12.022] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:12.022] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:12.033] Chunk #1 of 2 ... DONE
[17:38:12.033] Chunk #2 of 2 ...
[17:38:12.034]  - Finding globals in 'X' for chunk #2 ...
[17:38:12.034] getGlobalsAndPackages() ...
[17:38:12.034] Searching for globals...
[17:38:12.034] 
[17:38:12.034] Searching for globals ... DONE
[17:38:12.034] - globals: [0] <none>
[17:38:12.034] getGlobalsAndPackages() ... DONE
[17:38:12.034]    + additional globals found: [n=0] 
[17:38:12.035]    + additional namespaces needed: [n=0] 
[17:38:12.035]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:12.035]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:12.035]  - seeds: <none>
[17:38:12.035]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.035] getGlobalsAndPackages() ...
[17:38:12.035] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.035] Resolving globals: FALSE
[17:38:12.035] Tweak future expression to call with '...' arguments ...
[17:38:12.035] {
[17:38:12.035]     do.call(function(...) {
[17:38:12.035]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.035]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:12.035]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.035]             on.exit(options(oopts), add = TRUE)
[17:38:12.035]         }
[17:38:12.035]         {
[17:38:12.035]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:12.035]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.035]                 ...future.FUN(...future.X_jj, ...)
[17:38:12.035]             })
[17:38:12.035]         }
[17:38:12.035]     }, args = future.call.arguments)
[17:38:12.035] }
[17:38:12.036] Tweak future expression to call with '...' arguments ... DONE
[17:38:12.036] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.036] - packages: [1] ‘future.apply’
[17:38:12.036] getGlobalsAndPackages() ... DONE
[17:38:12.037] run() for ‘Future’ ...
[17:38:12.037] - state: ‘created’
[17:38:12.037] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:12.052] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:12.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:12.054]   - Field: ‘node’
[17:38:12.054]   - Field: ‘label’
[17:38:12.054]   - Field: ‘local’
[17:38:12.054]   - Field: ‘owner’
[17:38:12.055]   - Field: ‘envir’
[17:38:12.055]   - Field: ‘workers’
[17:38:12.055]   - Field: ‘packages’
[17:38:12.055]   - Field: ‘gc’
[17:38:12.055]   - Field: ‘conditions’
[17:38:12.055]   - Field: ‘persistent’
[17:38:12.055]   - Field: ‘expr’
[17:38:12.055]   - Field: ‘uuid’
[17:38:12.055]   - Field: ‘seed’
[17:38:12.055]   - Field: ‘version’
[17:38:12.055]   - Field: ‘result’
[17:38:12.056]   - Field: ‘asynchronous’
[17:38:12.056]   - Field: ‘calls’
[17:38:12.056]   - Field: ‘globals’
[17:38:12.056]   - Field: ‘stdout’
[17:38:12.056]   - Field: ‘earlySignal’
[17:38:12.056]   - Field: ‘lazy’
[17:38:12.056]   - Field: ‘state’
[17:38:12.056] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:12.056] - Launch lazy future ...
[17:38:12.057] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:12.057] Packages needed by future strategies (n = 0): <none>
[17:38:12.057] {
[17:38:12.057]     {
[17:38:12.057]         {
[17:38:12.057]             ...future.startTime <- base::Sys.time()
[17:38:12.057]             {
[17:38:12.057]                 {
[17:38:12.057]                   {
[17:38:12.057]                     {
[17:38:12.057]                       {
[17:38:12.057]                         base::local({
[17:38:12.057]                           has_future <- base::requireNamespace("future", 
[17:38:12.057]                             quietly = TRUE)
[17:38:12.057]                           if (has_future) {
[17:38:12.057]                             ns <- base::getNamespace("future")
[17:38:12.057]                             version <- ns[[".package"]][["version"]]
[17:38:12.057]                             if (is.null(version)) 
[17:38:12.057]                               version <- utils::packageVersion("future")
[17:38:12.057]                           }
[17:38:12.057]                           else {
[17:38:12.057]                             version <- NULL
[17:38:12.057]                           }
[17:38:12.057]                           if (!has_future || version < "1.8.0") {
[17:38:12.057]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:12.057]                               "", base::R.version$version.string), 
[17:38:12.057]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:12.057]                                 base::R.version$platform, 8 * 
[17:38:12.057]                                   base::.Machine$sizeof.pointer), 
[17:38:12.057]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:12.057]                                 "release", "version")], collapse = " "), 
[17:38:12.057]                               hostname = base::Sys.info()[["nodename"]])
[17:38:12.057]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:12.057]                               info)
[17:38:12.057]                             info <- base::paste(info, collapse = "; ")
[17:38:12.057]                             if (!has_future) {
[17:38:12.057]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:12.057]                                 info)
[17:38:12.057]                             }
[17:38:12.057]                             else {
[17:38:12.057]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:12.057]                                 info, version)
[17:38:12.057]                             }
[17:38:12.057]                             base::stop(msg)
[17:38:12.057]                           }
[17:38:12.057]                         })
[17:38:12.057]                       }
[17:38:12.057]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:12.057]                       base::options(mc.cores = 1L)
[17:38:12.057]                     }
[17:38:12.057]                     base::local({
[17:38:12.057]                       for (pkg in "future.apply") {
[17:38:12.057]                         base::loadNamespace(pkg)
[17:38:12.057]                         base::library(pkg, character.only = TRUE)
[17:38:12.057]                       }
[17:38:12.057]                     })
[17:38:12.057]                   }
[17:38:12.057]                   ...future.strategy.old <- future::plan("list")
[17:38:12.057]                   options(future.plan = NULL)
[17:38:12.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:12.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:12.057]                 }
[17:38:12.057]                 ...future.workdir <- getwd()
[17:38:12.057]             }
[17:38:12.057]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:12.057]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:12.057]         }
[17:38:12.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:12.057]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:12.057]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:12.057]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:12.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:12.057]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:12.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:12.057]             base::names(...future.oldOptions))
[17:38:12.057]     }
[17:38:12.057]     if (FALSE) {
[17:38:12.057]     }
[17:38:12.057]     else {
[17:38:12.057]         if (TRUE) {
[17:38:12.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:12.057]                 open = "w")
[17:38:12.057]         }
[17:38:12.057]         else {
[17:38:12.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:12.057]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:12.057]         }
[17:38:12.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:12.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:12.057]             base::sink(type = "output", split = FALSE)
[17:38:12.057]             base::close(...future.stdout)
[17:38:12.057]         }, add = TRUE)
[17:38:12.057]     }
[17:38:12.057]     ...future.frame <- base::sys.nframe()
[17:38:12.057]     ...future.conditions <- base::list()
[17:38:12.057]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:12.057]     if (FALSE) {
[17:38:12.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:12.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:12.057]     }
[17:38:12.057]     ...future.result <- base::tryCatch({
[17:38:12.057]         base::withCallingHandlers({
[17:38:12.057]             ...future.value <- base::withVisible(base::local({
[17:38:12.057]                 ...future.makeSendCondition <- base::local({
[17:38:12.057]                   sendCondition <- NULL
[17:38:12.057]                   function(frame = 1L) {
[17:38:12.057]                     if (is.function(sendCondition)) 
[17:38:12.057]                       return(sendCondition)
[17:38:12.057]                     ns <- getNamespace("parallel")
[17:38:12.057]                     if (exists("sendData", mode = "function", 
[17:38:12.057]                       envir = ns)) {
[17:38:12.057]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:12.057]                         envir = ns)
[17:38:12.057]                       envir <- sys.frame(frame)
[17:38:12.057]                       master <- NULL
[17:38:12.057]                       while (!identical(envir, .GlobalEnv) && 
[17:38:12.057]                         !identical(envir, emptyenv())) {
[17:38:12.057]                         if (exists("master", mode = "list", envir = envir, 
[17:38:12.057]                           inherits = FALSE)) {
[17:38:12.057]                           master <- get("master", mode = "list", 
[17:38:12.057]                             envir = envir, inherits = FALSE)
[17:38:12.057]                           if (inherits(master, c("SOCKnode", 
[17:38:12.057]                             "SOCK0node"))) {
[17:38:12.057]                             sendCondition <<- function(cond) {
[17:38:12.057]                               data <- list(type = "VALUE", value = cond, 
[17:38:12.057]                                 success = TRUE)
[17:38:12.057]                               parallel_sendData(master, data)
[17:38:12.057]                             }
[17:38:12.057]                             return(sendCondition)
[17:38:12.057]                           }
[17:38:12.057]                         }
[17:38:12.057]                         frame <- frame + 1L
[17:38:12.057]                         envir <- sys.frame(frame)
[17:38:12.057]                       }
[17:38:12.057]                     }
[17:38:12.057]                     sendCondition <<- function(cond) NULL
[17:38:12.057]                   }
[17:38:12.057]                 })
[17:38:12.057]                 withCallingHandlers({
[17:38:12.057]                   {
[17:38:12.057]                     do.call(function(...) {
[17:38:12.057]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.057]                       if (!identical(...future.globals.maxSize.org, 
[17:38:12.057]                         ...future.globals.maxSize)) {
[17:38:12.057]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.057]                         on.exit(options(oopts), add = TRUE)
[17:38:12.057]                       }
[17:38:12.057]                       {
[17:38:12.057]                         lapply(seq_along(...future.elements_ii), 
[17:38:12.057]                           FUN = function(jj) {
[17:38:12.057]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.057]                             ...future.FUN(...future.X_jj, ...)
[17:38:12.057]                           })
[17:38:12.057]                       }
[17:38:12.057]                     }, args = future.call.arguments)
[17:38:12.057]                   }
[17:38:12.057]                 }, immediateCondition = function(cond) {
[17:38:12.057]                   sendCondition <- ...future.makeSendCondition()
[17:38:12.057]                   sendCondition(cond)
[17:38:12.057]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.057]                   {
[17:38:12.057]                     inherits <- base::inherits
[17:38:12.057]                     invokeRestart <- base::invokeRestart
[17:38:12.057]                     is.null <- base::is.null
[17:38:12.057]                     muffled <- FALSE
[17:38:12.057]                     if (inherits(cond, "message")) {
[17:38:12.057]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:12.057]                       if (muffled) 
[17:38:12.057]                         invokeRestart("muffleMessage")
[17:38:12.057]                     }
[17:38:12.057]                     else if (inherits(cond, "warning")) {
[17:38:12.057]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:12.057]                       if (muffled) 
[17:38:12.057]                         invokeRestart("muffleWarning")
[17:38:12.057]                     }
[17:38:12.057]                     else if (inherits(cond, "condition")) {
[17:38:12.057]                       if (!is.null(pattern)) {
[17:38:12.057]                         computeRestarts <- base::computeRestarts
[17:38:12.057]                         grepl <- base::grepl
[17:38:12.057]                         restarts <- computeRestarts(cond)
[17:38:12.057]                         for (restart in restarts) {
[17:38:12.057]                           name <- restart$name
[17:38:12.057]                           if (is.null(name)) 
[17:38:12.057]                             next
[17:38:12.057]                           if (!grepl(pattern, name)) 
[17:38:12.057]                             next
[17:38:12.057]                           invokeRestart(restart)
[17:38:12.057]                           muffled <- TRUE
[17:38:12.057]                           break
[17:38:12.057]                         }
[17:38:12.057]                       }
[17:38:12.057]                     }
[17:38:12.057]                     invisible(muffled)
[17:38:12.057]                   }
[17:38:12.057]                   muffleCondition(cond)
[17:38:12.057]                 })
[17:38:12.057]             }))
[17:38:12.057]             future::FutureResult(value = ...future.value$value, 
[17:38:12.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:12.057]                   ...future.rng), globalenv = if (FALSE) 
[17:38:12.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:12.057]                     ...future.globalenv.names))
[17:38:12.057]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:12.057]         }, condition = base::local({
[17:38:12.057]             c <- base::c
[17:38:12.057]             inherits <- base::inherits
[17:38:12.057]             invokeRestart <- base::invokeRestart
[17:38:12.057]             length <- base::length
[17:38:12.057]             list <- base::list
[17:38:12.057]             seq.int <- base::seq.int
[17:38:12.057]             signalCondition <- base::signalCondition
[17:38:12.057]             sys.calls <- base::sys.calls
[17:38:12.057]             `[[` <- base::`[[`
[17:38:12.057]             `+` <- base::`+`
[17:38:12.057]             `<<-` <- base::`<<-`
[17:38:12.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:12.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:12.057]                   3L)]
[17:38:12.057]             }
[17:38:12.057]             function(cond) {
[17:38:12.057]                 is_error <- inherits(cond, "error")
[17:38:12.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:12.057]                   NULL)
[17:38:12.057]                 if (is_error) {
[17:38:12.057]                   sessionInformation <- function() {
[17:38:12.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:12.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:12.057]                       search = base::search(), system = base::Sys.info())
[17:38:12.057]                   }
[17:38:12.057]                   ...future.conditions[[length(...future.conditions) + 
[17:38:12.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:12.057]                     cond$call), session = sessionInformation(), 
[17:38:12.057]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:12.057]                   signalCondition(cond)
[17:38:12.057]                 }
[17:38:12.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:12.057]                 "immediateCondition"))) {
[17:38:12.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:12.057]                   ...future.conditions[[length(...future.conditions) + 
[17:38:12.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:12.057]                   if (TRUE && !signal) {
[17:38:12.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.057]                     {
[17:38:12.057]                       inherits <- base::inherits
[17:38:12.057]                       invokeRestart <- base::invokeRestart
[17:38:12.057]                       is.null <- base::is.null
[17:38:12.057]                       muffled <- FALSE
[17:38:12.057]                       if (inherits(cond, "message")) {
[17:38:12.057]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:12.057]                         if (muffled) 
[17:38:12.057]                           invokeRestart("muffleMessage")
[17:38:12.057]                       }
[17:38:12.057]                       else if (inherits(cond, "warning")) {
[17:38:12.057]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:12.057]                         if (muffled) 
[17:38:12.057]                           invokeRestart("muffleWarning")
[17:38:12.057]                       }
[17:38:12.057]                       else if (inherits(cond, "condition")) {
[17:38:12.057]                         if (!is.null(pattern)) {
[17:38:12.057]                           computeRestarts <- base::computeRestarts
[17:38:12.057]                           grepl <- base::grepl
[17:38:12.057]                           restarts <- computeRestarts(cond)
[17:38:12.057]                           for (restart in restarts) {
[17:38:12.057]                             name <- restart$name
[17:38:12.057]                             if (is.null(name)) 
[17:38:12.057]                               next
[17:38:12.057]                             if (!grepl(pattern, name)) 
[17:38:12.057]                               next
[17:38:12.057]                             invokeRestart(restart)
[17:38:12.057]                             muffled <- TRUE
[17:38:12.057]                             break
[17:38:12.057]                           }
[17:38:12.057]                         }
[17:38:12.057]                       }
[17:38:12.057]                       invisible(muffled)
[17:38:12.057]                     }
[17:38:12.057]                     muffleCondition(cond, pattern = "^muffle")
[17:38:12.057]                   }
[17:38:12.057]                 }
[17:38:12.057]                 else {
[17:38:12.057]                   if (TRUE) {
[17:38:12.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.057]                     {
[17:38:12.057]                       inherits <- base::inherits
[17:38:12.057]                       invokeRestart <- base::invokeRestart
[17:38:12.057]                       is.null <- base::is.null
[17:38:12.057]                       muffled <- FALSE
[17:38:12.057]                       if (inherits(cond, "message")) {
[17:38:12.057]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:12.057]                         if (muffled) 
[17:38:12.057]                           invokeRestart("muffleMessage")
[17:38:12.057]                       }
[17:38:12.057]                       else if (inherits(cond, "warning")) {
[17:38:12.057]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:12.057]                         if (muffled) 
[17:38:12.057]                           invokeRestart("muffleWarning")
[17:38:12.057]                       }
[17:38:12.057]                       else if (inherits(cond, "condition")) {
[17:38:12.057]                         if (!is.null(pattern)) {
[17:38:12.057]                           computeRestarts <- base::computeRestarts
[17:38:12.057]                           grepl <- base::grepl
[17:38:12.057]                           restarts <- computeRestarts(cond)
[17:38:12.057]                           for (restart in restarts) {
[17:38:12.057]                             name <- restart$name
[17:38:12.057]                             if (is.null(name)) 
[17:38:12.057]                               next
[17:38:12.057]                             if (!grepl(pattern, name)) 
[17:38:12.057]                               next
[17:38:12.057]                             invokeRestart(restart)
[17:38:12.057]                             muffled <- TRUE
[17:38:12.057]                             break
[17:38:12.057]                           }
[17:38:12.057]                         }
[17:38:12.057]                       }
[17:38:12.057]                       invisible(muffled)
[17:38:12.057]                     }
[17:38:12.057]                     muffleCondition(cond, pattern = "^muffle")
[17:38:12.057]                   }
[17:38:12.057]                 }
[17:38:12.057]             }
[17:38:12.057]         }))
[17:38:12.057]     }, error = function(ex) {
[17:38:12.057]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:12.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:12.057]                 ...future.rng), started = ...future.startTime, 
[17:38:12.057]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:12.057]             version = "1.8"), class = "FutureResult")
[17:38:12.057]     }, finally = {
[17:38:12.057]         if (!identical(...future.workdir, getwd())) 
[17:38:12.057]             setwd(...future.workdir)
[17:38:12.057]         {
[17:38:12.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:12.057]                 ...future.oldOptions$nwarnings <- NULL
[17:38:12.057]             }
[17:38:12.057]             base::options(...future.oldOptions)
[17:38:12.057]             if (.Platform$OS.type == "windows") {
[17:38:12.057]                 old_names <- names(...future.oldEnvVars)
[17:38:12.057]                 envs <- base::Sys.getenv()
[17:38:12.057]                 names <- names(envs)
[17:38:12.057]                 common <- intersect(names, old_names)
[17:38:12.057]                 added <- setdiff(names, old_names)
[17:38:12.057]                 removed <- setdiff(old_names, names)
[17:38:12.057]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:12.057]                   envs[common]]
[17:38:12.057]                 NAMES <- toupper(changed)
[17:38:12.057]                 args <- list()
[17:38:12.057]                 for (kk in seq_along(NAMES)) {
[17:38:12.057]                   name <- changed[[kk]]
[17:38:12.057]                   NAME <- NAMES[[kk]]
[17:38:12.057]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.057]                     next
[17:38:12.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:12.057]                 }
[17:38:12.057]                 NAMES <- toupper(added)
[17:38:12.057]                 for (kk in seq_along(NAMES)) {
[17:38:12.057]                   name <- added[[kk]]
[17:38:12.057]                   NAME <- NAMES[[kk]]
[17:38:12.057]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.057]                     next
[17:38:12.057]                   args[[name]] <- ""
[17:38:12.057]                 }
[17:38:12.057]                 NAMES <- toupper(removed)
[17:38:12.057]                 for (kk in seq_along(NAMES)) {
[17:38:12.057]                   name <- removed[[kk]]
[17:38:12.057]                   NAME <- NAMES[[kk]]
[17:38:12.057]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.057]                     next
[17:38:12.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:12.057]                 }
[17:38:12.057]                 if (length(args) > 0) 
[17:38:12.057]                   base::do.call(base::Sys.setenv, args = args)
[17:38:12.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:12.057]             }
[17:38:12.057]             else {
[17:38:12.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:12.057]             }
[17:38:12.057]             {
[17:38:12.057]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:12.057]                   0L) {
[17:38:12.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:12.057]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:12.057]                   base::options(opts)
[17:38:12.057]                 }
[17:38:12.057]                 {
[17:38:12.057]                   {
[17:38:12.057]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:12.057]                     NULL
[17:38:12.057]                   }
[17:38:12.057]                   options(future.plan = NULL)
[17:38:12.057]                   if (is.na(NA_character_)) 
[17:38:12.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:12.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:12.057]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:12.057]                     .init = FALSE)
[17:38:12.057]                 }
[17:38:12.057]             }
[17:38:12.057]         }
[17:38:12.057]     })
[17:38:12.057]     if (TRUE) {
[17:38:12.057]         base::sink(type = "output", split = FALSE)
[17:38:12.057]         if (TRUE) {
[17:38:12.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:12.057]         }
[17:38:12.057]         else {
[17:38:12.057]             ...future.result["stdout"] <- base::list(NULL)
[17:38:12.057]         }
[17:38:12.057]         base::close(...future.stdout)
[17:38:12.057]         ...future.stdout <- NULL
[17:38:12.057]     }
[17:38:12.057]     ...future.result$conditions <- ...future.conditions
[17:38:12.057]     ...future.result$finished <- base::Sys.time()
[17:38:12.057]     ...future.result
[17:38:12.057] }
[17:38:12.060] Exporting 11 global objects (94.20 KiB) to cluster node #2 ...
[17:38:12.060] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:38:12.101] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:38:12.101] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ...
[17:38:12.101] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ... DONE
[17:38:12.101] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:38:12.102] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:38:12.102] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:38:12.145] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:38:12.145] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:38:12.189] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:38:12.189] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:38:12.190] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:38:12.190] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:38:12.190] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:38:12.190] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:12.191] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:12.191] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:38:12.191] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:38:12.191] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:12.192] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:12.192] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:12.192] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:12.192] Exporting 11 global objects (94.20 KiB) to cluster node #2 ... DONE
[17:38:12.193] MultisessionFuture started
[17:38:12.193] - Launch lazy future ... done
[17:38:12.193] run() for ‘MultisessionFuture’ ... done
[17:38:12.193] Created future:
[17:38:12.193] MultisessionFuture:
[17:38:12.193] Label: ‘future_vapply-2’
[17:38:12.193] Expression:
[17:38:12.193] {
[17:38:12.193]     do.call(function(...) {
[17:38:12.193]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.193]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:12.193]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.193]             on.exit(options(oopts), add = TRUE)
[17:38:12.193]         }
[17:38:12.193]         {
[17:38:12.193]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:12.193]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.193]                 ...future.FUN(...future.X_jj, ...)
[17:38:12.193]             })
[17:38:12.193]         }
[17:38:12.193]     }, args = future.call.arguments)
[17:38:12.193] }
[17:38:12.193] Lazy evaluation: FALSE
[17:38:12.193] Asynchronous evaluation: TRUE
[17:38:12.193] Local evaluation: TRUE
[17:38:12.193] Environment: R_GlobalEnv
[17:38:12.193] Capture standard output: TRUE
[17:38:12.193] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:12.193] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:12.193] Packages: 1 packages (‘future.apply’)
[17:38:12.193] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:12.193] Resolved: FALSE
[17:38:12.193] Value: <not collected>
[17:38:12.193] Conditions captured: <none>
[17:38:12.193] Early signaling: FALSE
[17:38:12.193] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:12.193] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:12.205] Chunk #2 of 2 ... DONE
[17:38:12.205] Launching 2 futures (chunks) ... DONE
[17:38:12.205] Resolving 2 futures (chunks) ...
[17:38:12.205] resolve() on list ...
[17:38:12.206]  recursive: 0
[17:38:12.206]  length: 2
[17:38:12.206] 
[17:38:12.206] receiveMessageFromWorker() for ClusterFuture ...
[17:38:12.206] - Validating connection of MultisessionFuture
[17:38:12.207] - received message: FutureResult
[17:38:12.207] - Received FutureResult
[17:38:12.207] - Erased future from FutureRegistry
[17:38:12.207] result() for ClusterFuture ...
[17:38:12.207] - result already collected: FutureResult
[17:38:12.207] result() for ClusterFuture ... done
[17:38:12.207] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:12.207] Future #1
[17:38:12.207] result() for ClusterFuture ...
[17:38:12.207] - result already collected: FutureResult
[17:38:12.207] result() for ClusterFuture ... done
[17:38:12.208] result() for ClusterFuture ...
[17:38:12.208] - result already collected: FutureResult
[17:38:12.208] result() for ClusterFuture ... done
[17:38:12.208] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:12.208] - nx: 2
[17:38:12.208] - relay: TRUE
[17:38:12.208] - stdout: TRUE
[17:38:12.208] - signal: TRUE
[17:38:12.208] - resignal: FALSE
[17:38:12.208] - force: TRUE
[17:38:12.208] - relayed: [n=2] FALSE, FALSE
[17:38:12.208] - queued futures: [n=2] FALSE, FALSE
[17:38:12.209]  - until=1
[17:38:12.209]  - relaying element #1
[17:38:12.209] result() for ClusterFuture ...
[17:38:12.209] - result already collected: FutureResult
[17:38:12.209] result() for ClusterFuture ... done
[17:38:12.209] result() for ClusterFuture ...
[17:38:12.209] - result already collected: FutureResult
[17:38:12.209] result() for ClusterFuture ... done
[17:38:12.209] result() for ClusterFuture ...
[17:38:12.209] - result already collected: FutureResult
[17:38:12.209] result() for ClusterFuture ... done
[17:38:12.210] result() for ClusterFuture ...
[17:38:12.210] - result already collected: FutureResult
[17:38:12.210] result() for ClusterFuture ... done
[17:38:12.210] - relayed: [n=2] TRUE, FALSE
[17:38:12.210] - queued futures: [n=2] TRUE, FALSE
[17:38:12.210] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:12.210]  length: 1 (resolved future 1)
[17:38:12.238] receiveMessageFromWorker() for ClusterFuture ...
[17:38:12.238] - Validating connection of MultisessionFuture
[17:38:12.239] - received message: FutureResult
[17:38:12.239] - Received FutureResult
[17:38:12.239] - Erased future from FutureRegistry
[17:38:12.239] result() for ClusterFuture ...
[17:38:12.239] - result already collected: FutureResult
[17:38:12.239] result() for ClusterFuture ... done
[17:38:12.239] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:12.239] Future #2
[17:38:12.239] result() for ClusterFuture ...
[17:38:12.239] - result already collected: FutureResult
[17:38:12.239] result() for ClusterFuture ... done
[17:38:12.240] result() for ClusterFuture ...
[17:38:12.240] - result already collected: FutureResult
[17:38:12.240] result() for ClusterFuture ... done
[17:38:12.240] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:12.240] - nx: 2
[17:38:12.240] - relay: TRUE
[17:38:12.240] - stdout: TRUE
[17:38:12.240] - signal: TRUE
[17:38:12.240] - resignal: FALSE
[17:38:12.240] - force: TRUE
[17:38:12.241] - relayed: [n=2] TRUE, FALSE
[17:38:12.241] - queued futures: [n=2] TRUE, FALSE
[17:38:12.241]  - until=2
[17:38:12.241]  - relaying element #2
[17:38:12.241] result() for ClusterFuture ...
[17:38:12.241] - result already collected: FutureResult
[17:38:12.241] result() for ClusterFuture ... done
[17:38:12.241] result() for ClusterFuture ...
[17:38:12.241] - result already collected: FutureResult
[17:38:12.241] result() for ClusterFuture ... done
[17:38:12.242] result() for ClusterFuture ...
[17:38:12.242] - result already collected: FutureResult
[17:38:12.242] result() for ClusterFuture ... done
[17:38:12.242] result() for ClusterFuture ...
[17:38:12.242] - result already collected: FutureResult
[17:38:12.242] result() for ClusterFuture ... done
[17:38:12.242] - relayed: [n=2] TRUE, TRUE
[17:38:12.242] - queued futures: [n=2] TRUE, TRUE
[17:38:12.242] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:12.242]  length: 0 (resolved future 2)
[17:38:12.242] Relaying remaining futures
[17:38:12.242] signalConditionsASAP(NULL, pos=0) ...
[17:38:12.243] - nx: 2
[17:38:12.243] - relay: TRUE
[17:38:12.243] - stdout: TRUE
[17:38:12.243] - signal: TRUE
[17:38:12.243] - resignal: FALSE
[17:38:12.243] - force: TRUE
[17:38:12.243] - relayed: [n=2] TRUE, TRUE
[17:38:12.243] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:12.243] - relayed: [n=2] TRUE, TRUE
[17:38:12.243] - queued futures: [n=2] TRUE, TRUE
[17:38:12.243] signalConditionsASAP(NULL, pos=0) ... done
[17:38:12.244] resolve() on list ... DONE
[17:38:12.244] result() for ClusterFuture ...
[17:38:12.244] - result already collected: FutureResult
[17:38:12.244] result() for ClusterFuture ... done
[17:38:12.244] result() for ClusterFuture ...
[17:38:12.244] - result already collected: FutureResult
[17:38:12.244] result() for ClusterFuture ... done
[17:38:12.244] result() for ClusterFuture ...
[17:38:12.244] - result already collected: FutureResult
[17:38:12.244] result() for ClusterFuture ... done
[17:38:12.245] result() for ClusterFuture ...
[17:38:12.245] - result already collected: FutureResult
[17:38:12.245] result() for ClusterFuture ... done
[17:38:12.245]  - Number of value chunks collected: 2
[17:38:12.245] Resolving 2 futures (chunks) ... DONE
[17:38:12.245] Reducing values from 2 chunks ...
[17:38:12.245]  - Number of values collected after concatenation: 10
[17:38:12.245]  - Number of values expected: 10
[17:38:12.245] Reducing values from 2 chunks ... DONE
[17:38:12.245] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:38:12.246] future_lapply() ...
[17:38:12.252] Number of chunks: 2
[17:38:12.252] getGlobalsAndPackagesXApply() ...
[17:38:12.252]  - future.globals: TRUE
[17:38:12.252] getGlobalsAndPackages() ...
[17:38:12.252] Searching for globals...
[17:38:12.256] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:38:12.256] Searching for globals ... DONE
[17:38:12.256] Resolving globals: FALSE
[17:38:12.257] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[17:38:12.257] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:12.257] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:12.257] - packages: [1] ‘future.apply’
[17:38:12.258] getGlobalsAndPackages() ... DONE
[17:38:12.258]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:12.258]  - needed namespaces: [n=1] ‘future.apply’
[17:38:12.258] Finding globals ... DONE
[17:38:12.258]  - use_args: TRUE
[17:38:12.258]  - Getting '...' globals ...
[17:38:12.258] resolve() on list ...
[17:38:12.258]  recursive: 0
[17:38:12.259]  length: 1
[17:38:12.259]  elements: ‘...’
[17:38:12.259]  length: 0 (resolved future 1)
[17:38:12.259] resolve() on list ... DONE
[17:38:12.259]    - '...' content: [n=0] 
[17:38:12.259] List of 1
[17:38:12.259]  $ ...: list()
[17:38:12.259]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:12.259]  - attr(*, "where")=List of 1
[17:38:12.259]   ..$ ...:<environment: 0x560802b14828> 
[17:38:12.259]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:12.259]  - attr(*, "resolved")= logi TRUE
[17:38:12.259]  - attr(*, "total_size")= num NA
[17:38:12.262]  - Getting '...' globals ... DONE
[17:38:12.262] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:12.262] List of 8
[17:38:12.262]  $ ...future.FUN:function (x, ...)  
[17:38:12.262]  $ x_FUN        :function (x)  
[17:38:12.262]  $ times        : int 4
[17:38:12.262]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:12.262]  $ stop_if_not  :function (...)  
[17:38:12.262]  $ dim          : int [1:2] 2 2
[17:38:12.262]  $ valid_types  : chr [1:2] "logical" "integer"
[17:38:12.262]  $ ...          : list()
[17:38:12.262]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:12.262]  - attr(*, "where")=List of 8
[17:38:12.262]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:12.262]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:12.262]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:12.262]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:12.262]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:12.262]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:12.262]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:12.262]   ..$ ...          :<environment: 0x560802b14828> 
[17:38:12.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:12.262]  - attr(*, "resolved")= logi FALSE
[17:38:12.262]  - attr(*, "total_size")= num 97232
[17:38:12.267] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:12.267] getGlobalsAndPackagesXApply() ... DONE
[17:38:12.267] Number of futures (= number of chunks): 2
[17:38:12.268] Launching 2 futures (chunks) ...
[17:38:12.268] Chunk #1 of 2 ...
[17:38:12.268]  - Finding globals in 'X' for chunk #1 ...
[17:38:12.268] getGlobalsAndPackages() ...
[17:38:12.268] Searching for globals...
[17:38:12.268] 
[17:38:12.268] Searching for globals ... DONE
[17:38:12.269] - globals: [0] <none>
[17:38:12.269] getGlobalsAndPackages() ... DONE
[17:38:12.269]    + additional globals found: [n=0] 
[17:38:12.269]    + additional namespaces needed: [n=0] 
[17:38:12.269]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:12.269]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:12.269]  - seeds: <none>
[17:38:12.269]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.269] getGlobalsAndPackages() ...
[17:38:12.269] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.270] Resolving globals: FALSE
[17:38:12.270] Tweak future expression to call with '...' arguments ...
[17:38:12.270] {
[17:38:12.270]     do.call(function(...) {
[17:38:12.270]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.270]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:12.270]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.270]             on.exit(options(oopts), add = TRUE)
[17:38:12.270]         }
[17:38:12.270]         {
[17:38:12.270]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:12.270]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.270]                 ...future.FUN(...future.X_jj, ...)
[17:38:12.270]             })
[17:38:12.270]         }
[17:38:12.270]     }, args = future.call.arguments)
[17:38:12.270] }
[17:38:12.270] Tweak future expression to call with '...' arguments ... DONE
[17:38:12.270] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.271] - packages: [1] ‘future.apply’
[17:38:12.271] getGlobalsAndPackages() ... DONE
[17:38:12.271] run() for ‘Future’ ...
[17:38:12.271] - state: ‘created’
[17:38:12.271] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:12.285] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:12.285] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:12.286]   - Field: ‘node’
[17:38:12.286]   - Field: ‘label’
[17:38:12.286]   - Field: ‘local’
[17:38:12.286]   - Field: ‘owner’
[17:38:12.286]   - Field: ‘envir’
[17:38:12.286]   - Field: ‘workers’
[17:38:12.286]   - Field: ‘packages’
[17:38:12.286]   - Field: ‘gc’
[17:38:12.286]   - Field: ‘conditions’
[17:38:12.286]   - Field: ‘persistent’
[17:38:12.287]   - Field: ‘expr’
[17:38:12.287]   - Field: ‘uuid’
[17:38:12.287]   - Field: ‘seed’
[17:38:12.287]   - Field: ‘version’
[17:38:12.287]   - Field: ‘result’
[17:38:12.287]   - Field: ‘asynchronous’
[17:38:12.287]   - Field: ‘calls’
[17:38:12.287]   - Field: ‘globals’
[17:38:12.287]   - Field: ‘stdout’
[17:38:12.287]   - Field: ‘earlySignal’
[17:38:12.287]   - Field: ‘lazy’
[17:38:12.287]   - Field: ‘state’
[17:38:12.288] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:12.288] - Launch lazy future ...
[17:38:12.288] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:12.288] Packages needed by future strategies (n = 0): <none>
[17:38:12.289] {
[17:38:12.289]     {
[17:38:12.289]         {
[17:38:12.289]             ...future.startTime <- base::Sys.time()
[17:38:12.289]             {
[17:38:12.289]                 {
[17:38:12.289]                   {
[17:38:12.289]                     {
[17:38:12.289]                       {
[17:38:12.289]                         base::local({
[17:38:12.289]                           has_future <- base::requireNamespace("future", 
[17:38:12.289]                             quietly = TRUE)
[17:38:12.289]                           if (has_future) {
[17:38:12.289]                             ns <- base::getNamespace("future")
[17:38:12.289]                             version <- ns[[".package"]][["version"]]
[17:38:12.289]                             if (is.null(version)) 
[17:38:12.289]                               version <- utils::packageVersion("future")
[17:38:12.289]                           }
[17:38:12.289]                           else {
[17:38:12.289]                             version <- NULL
[17:38:12.289]                           }
[17:38:12.289]                           if (!has_future || version < "1.8.0") {
[17:38:12.289]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:12.289]                               "", base::R.version$version.string), 
[17:38:12.289]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:12.289]                                 base::R.version$platform, 8 * 
[17:38:12.289]                                   base::.Machine$sizeof.pointer), 
[17:38:12.289]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:12.289]                                 "release", "version")], collapse = " "), 
[17:38:12.289]                               hostname = base::Sys.info()[["nodename"]])
[17:38:12.289]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:12.289]                               info)
[17:38:12.289]                             info <- base::paste(info, collapse = "; ")
[17:38:12.289]                             if (!has_future) {
[17:38:12.289]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:12.289]                                 info)
[17:38:12.289]                             }
[17:38:12.289]                             else {
[17:38:12.289]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:12.289]                                 info, version)
[17:38:12.289]                             }
[17:38:12.289]                             base::stop(msg)
[17:38:12.289]                           }
[17:38:12.289]                         })
[17:38:12.289]                       }
[17:38:12.289]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:12.289]                       base::options(mc.cores = 1L)
[17:38:12.289]                     }
[17:38:12.289]                     base::local({
[17:38:12.289]                       for (pkg in "future.apply") {
[17:38:12.289]                         base::loadNamespace(pkg)
[17:38:12.289]                         base::library(pkg, character.only = TRUE)
[17:38:12.289]                       }
[17:38:12.289]                     })
[17:38:12.289]                   }
[17:38:12.289]                   ...future.strategy.old <- future::plan("list")
[17:38:12.289]                   options(future.plan = NULL)
[17:38:12.289]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:12.289]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:12.289]                 }
[17:38:12.289]                 ...future.workdir <- getwd()
[17:38:12.289]             }
[17:38:12.289]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:12.289]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:12.289]         }
[17:38:12.289]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:12.289]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:12.289]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:12.289]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:12.289]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:12.289]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:12.289]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:12.289]             base::names(...future.oldOptions))
[17:38:12.289]     }
[17:38:12.289]     if (FALSE) {
[17:38:12.289]     }
[17:38:12.289]     else {
[17:38:12.289]         if (TRUE) {
[17:38:12.289]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:12.289]                 open = "w")
[17:38:12.289]         }
[17:38:12.289]         else {
[17:38:12.289]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:12.289]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:12.289]         }
[17:38:12.289]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:12.289]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:12.289]             base::sink(type = "output", split = FALSE)
[17:38:12.289]             base::close(...future.stdout)
[17:38:12.289]         }, add = TRUE)
[17:38:12.289]     }
[17:38:12.289]     ...future.frame <- base::sys.nframe()
[17:38:12.289]     ...future.conditions <- base::list()
[17:38:12.289]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:12.289]     if (FALSE) {
[17:38:12.289]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:12.289]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:12.289]     }
[17:38:12.289]     ...future.result <- base::tryCatch({
[17:38:12.289]         base::withCallingHandlers({
[17:38:12.289]             ...future.value <- base::withVisible(base::local({
[17:38:12.289]                 ...future.makeSendCondition <- base::local({
[17:38:12.289]                   sendCondition <- NULL
[17:38:12.289]                   function(frame = 1L) {
[17:38:12.289]                     if (is.function(sendCondition)) 
[17:38:12.289]                       return(sendCondition)
[17:38:12.289]                     ns <- getNamespace("parallel")
[17:38:12.289]                     if (exists("sendData", mode = "function", 
[17:38:12.289]                       envir = ns)) {
[17:38:12.289]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:12.289]                         envir = ns)
[17:38:12.289]                       envir <- sys.frame(frame)
[17:38:12.289]                       master <- NULL
[17:38:12.289]                       while (!identical(envir, .GlobalEnv) && 
[17:38:12.289]                         !identical(envir, emptyenv())) {
[17:38:12.289]                         if (exists("master", mode = "list", envir = envir, 
[17:38:12.289]                           inherits = FALSE)) {
[17:38:12.289]                           master <- get("master", mode = "list", 
[17:38:12.289]                             envir = envir, inherits = FALSE)
[17:38:12.289]                           if (inherits(master, c("SOCKnode", 
[17:38:12.289]                             "SOCK0node"))) {
[17:38:12.289]                             sendCondition <<- function(cond) {
[17:38:12.289]                               data <- list(type = "VALUE", value = cond, 
[17:38:12.289]                                 success = TRUE)
[17:38:12.289]                               parallel_sendData(master, data)
[17:38:12.289]                             }
[17:38:12.289]                             return(sendCondition)
[17:38:12.289]                           }
[17:38:12.289]                         }
[17:38:12.289]                         frame <- frame + 1L
[17:38:12.289]                         envir <- sys.frame(frame)
[17:38:12.289]                       }
[17:38:12.289]                     }
[17:38:12.289]                     sendCondition <<- function(cond) NULL
[17:38:12.289]                   }
[17:38:12.289]                 })
[17:38:12.289]                 withCallingHandlers({
[17:38:12.289]                   {
[17:38:12.289]                     do.call(function(...) {
[17:38:12.289]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.289]                       if (!identical(...future.globals.maxSize.org, 
[17:38:12.289]                         ...future.globals.maxSize)) {
[17:38:12.289]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.289]                         on.exit(options(oopts), add = TRUE)
[17:38:12.289]                       }
[17:38:12.289]                       {
[17:38:12.289]                         lapply(seq_along(...future.elements_ii), 
[17:38:12.289]                           FUN = function(jj) {
[17:38:12.289]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.289]                             ...future.FUN(...future.X_jj, ...)
[17:38:12.289]                           })
[17:38:12.289]                       }
[17:38:12.289]                     }, args = future.call.arguments)
[17:38:12.289]                   }
[17:38:12.289]                 }, immediateCondition = function(cond) {
[17:38:12.289]                   sendCondition <- ...future.makeSendCondition()
[17:38:12.289]                   sendCondition(cond)
[17:38:12.289]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.289]                   {
[17:38:12.289]                     inherits <- base::inherits
[17:38:12.289]                     invokeRestart <- base::invokeRestart
[17:38:12.289]                     is.null <- base::is.null
[17:38:12.289]                     muffled <- FALSE
[17:38:12.289]                     if (inherits(cond, "message")) {
[17:38:12.289]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:12.289]                       if (muffled) 
[17:38:12.289]                         invokeRestart("muffleMessage")
[17:38:12.289]                     }
[17:38:12.289]                     else if (inherits(cond, "warning")) {
[17:38:12.289]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:12.289]                       if (muffled) 
[17:38:12.289]                         invokeRestart("muffleWarning")
[17:38:12.289]                     }
[17:38:12.289]                     else if (inherits(cond, "condition")) {
[17:38:12.289]                       if (!is.null(pattern)) {
[17:38:12.289]                         computeRestarts <- base::computeRestarts
[17:38:12.289]                         grepl <- base::grepl
[17:38:12.289]                         restarts <- computeRestarts(cond)
[17:38:12.289]                         for (restart in restarts) {
[17:38:12.289]                           name <- restart$name
[17:38:12.289]                           if (is.null(name)) 
[17:38:12.289]                             next
[17:38:12.289]                           if (!grepl(pattern, name)) 
[17:38:12.289]                             next
[17:38:12.289]                           invokeRestart(restart)
[17:38:12.289]                           muffled <- TRUE
[17:38:12.289]                           break
[17:38:12.289]                         }
[17:38:12.289]                       }
[17:38:12.289]                     }
[17:38:12.289]                     invisible(muffled)
[17:38:12.289]                   }
[17:38:12.289]                   muffleCondition(cond)
[17:38:12.289]                 })
[17:38:12.289]             }))
[17:38:12.289]             future::FutureResult(value = ...future.value$value, 
[17:38:12.289]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:12.289]                   ...future.rng), globalenv = if (FALSE) 
[17:38:12.289]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:12.289]                     ...future.globalenv.names))
[17:38:12.289]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:12.289]         }, condition = base::local({
[17:38:12.289]             c <- base::c
[17:38:12.289]             inherits <- base::inherits
[17:38:12.289]             invokeRestart <- base::invokeRestart
[17:38:12.289]             length <- base::length
[17:38:12.289]             list <- base::list
[17:38:12.289]             seq.int <- base::seq.int
[17:38:12.289]             signalCondition <- base::signalCondition
[17:38:12.289]             sys.calls <- base::sys.calls
[17:38:12.289]             `[[` <- base::`[[`
[17:38:12.289]             `+` <- base::`+`
[17:38:12.289]             `<<-` <- base::`<<-`
[17:38:12.289]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:12.289]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:12.289]                   3L)]
[17:38:12.289]             }
[17:38:12.289]             function(cond) {
[17:38:12.289]                 is_error <- inherits(cond, "error")
[17:38:12.289]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:12.289]                   NULL)
[17:38:12.289]                 if (is_error) {
[17:38:12.289]                   sessionInformation <- function() {
[17:38:12.289]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:12.289]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:12.289]                       search = base::search(), system = base::Sys.info())
[17:38:12.289]                   }
[17:38:12.289]                   ...future.conditions[[length(...future.conditions) + 
[17:38:12.289]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:12.289]                     cond$call), session = sessionInformation(), 
[17:38:12.289]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:12.289]                   signalCondition(cond)
[17:38:12.289]                 }
[17:38:12.289]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:12.289]                 "immediateCondition"))) {
[17:38:12.289]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:12.289]                   ...future.conditions[[length(...future.conditions) + 
[17:38:12.289]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:12.289]                   if (TRUE && !signal) {
[17:38:12.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.289]                     {
[17:38:12.289]                       inherits <- base::inherits
[17:38:12.289]                       invokeRestart <- base::invokeRestart
[17:38:12.289]                       is.null <- base::is.null
[17:38:12.289]                       muffled <- FALSE
[17:38:12.289]                       if (inherits(cond, "message")) {
[17:38:12.289]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:12.289]                         if (muffled) 
[17:38:12.289]                           invokeRestart("muffleMessage")
[17:38:12.289]                       }
[17:38:12.289]                       else if (inherits(cond, "warning")) {
[17:38:12.289]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:12.289]                         if (muffled) 
[17:38:12.289]                           invokeRestart("muffleWarning")
[17:38:12.289]                       }
[17:38:12.289]                       else if (inherits(cond, "condition")) {
[17:38:12.289]                         if (!is.null(pattern)) {
[17:38:12.289]                           computeRestarts <- base::computeRestarts
[17:38:12.289]                           grepl <- base::grepl
[17:38:12.289]                           restarts <- computeRestarts(cond)
[17:38:12.289]                           for (restart in restarts) {
[17:38:12.289]                             name <- restart$name
[17:38:12.289]                             if (is.null(name)) 
[17:38:12.289]                               next
[17:38:12.289]                             if (!grepl(pattern, name)) 
[17:38:12.289]                               next
[17:38:12.289]                             invokeRestart(restart)
[17:38:12.289]                             muffled <- TRUE
[17:38:12.289]                             break
[17:38:12.289]                           }
[17:38:12.289]                         }
[17:38:12.289]                       }
[17:38:12.289]                       invisible(muffled)
[17:38:12.289]                     }
[17:38:12.289]                     muffleCondition(cond, pattern = "^muffle")
[17:38:12.289]                   }
[17:38:12.289]                 }
[17:38:12.289]                 else {
[17:38:12.289]                   if (TRUE) {
[17:38:12.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.289]                     {
[17:38:12.289]                       inherits <- base::inherits
[17:38:12.289]                       invokeRestart <- base::invokeRestart
[17:38:12.289]                       is.null <- base::is.null
[17:38:12.289]                       muffled <- FALSE
[17:38:12.289]                       if (inherits(cond, "message")) {
[17:38:12.289]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:12.289]                         if (muffled) 
[17:38:12.289]                           invokeRestart("muffleMessage")
[17:38:12.289]                       }
[17:38:12.289]                       else if (inherits(cond, "warning")) {
[17:38:12.289]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:12.289]                         if (muffled) 
[17:38:12.289]                           invokeRestart("muffleWarning")
[17:38:12.289]                       }
[17:38:12.289]                       else if (inherits(cond, "condition")) {
[17:38:12.289]                         if (!is.null(pattern)) {
[17:38:12.289]                           computeRestarts <- base::computeRestarts
[17:38:12.289]                           grepl <- base::grepl
[17:38:12.289]                           restarts <- computeRestarts(cond)
[17:38:12.289]                           for (restart in restarts) {
[17:38:12.289]                             name <- restart$name
[17:38:12.289]                             if (is.null(name)) 
[17:38:12.289]                               next
[17:38:12.289]                             if (!grepl(pattern, name)) 
[17:38:12.289]                               next
[17:38:12.289]                             invokeRestart(restart)
[17:38:12.289]                             muffled <- TRUE
[17:38:12.289]                             break
[17:38:12.289]                           }
[17:38:12.289]                         }
[17:38:12.289]                       }
[17:38:12.289]                       invisible(muffled)
[17:38:12.289]                     }
[17:38:12.289]                     muffleCondition(cond, pattern = "^muffle")
[17:38:12.289]                   }
[17:38:12.289]                 }
[17:38:12.289]             }
[17:38:12.289]         }))
[17:38:12.289]     }, error = function(ex) {
[17:38:12.289]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:12.289]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:12.289]                 ...future.rng), started = ...future.startTime, 
[17:38:12.289]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:12.289]             version = "1.8"), class = "FutureResult")
[17:38:12.289]     }, finally = {
[17:38:12.289]         if (!identical(...future.workdir, getwd())) 
[17:38:12.289]             setwd(...future.workdir)
[17:38:12.289]         {
[17:38:12.289]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:12.289]                 ...future.oldOptions$nwarnings <- NULL
[17:38:12.289]             }
[17:38:12.289]             base::options(...future.oldOptions)
[17:38:12.289]             if (.Platform$OS.type == "windows") {
[17:38:12.289]                 old_names <- names(...future.oldEnvVars)
[17:38:12.289]                 envs <- base::Sys.getenv()
[17:38:12.289]                 names <- names(envs)
[17:38:12.289]                 common <- intersect(names, old_names)
[17:38:12.289]                 added <- setdiff(names, old_names)
[17:38:12.289]                 removed <- setdiff(old_names, names)
[17:38:12.289]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:12.289]                   envs[common]]
[17:38:12.289]                 NAMES <- toupper(changed)
[17:38:12.289]                 args <- list()
[17:38:12.289]                 for (kk in seq_along(NAMES)) {
[17:38:12.289]                   name <- changed[[kk]]
[17:38:12.289]                   NAME <- NAMES[[kk]]
[17:38:12.289]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.289]                     next
[17:38:12.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:12.289]                 }
[17:38:12.289]                 NAMES <- toupper(added)
[17:38:12.289]                 for (kk in seq_along(NAMES)) {
[17:38:12.289]                   name <- added[[kk]]
[17:38:12.289]                   NAME <- NAMES[[kk]]
[17:38:12.289]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.289]                     next
[17:38:12.289]                   args[[name]] <- ""
[17:38:12.289]                 }
[17:38:12.289]                 NAMES <- toupper(removed)
[17:38:12.289]                 for (kk in seq_along(NAMES)) {
[17:38:12.289]                   name <- removed[[kk]]
[17:38:12.289]                   NAME <- NAMES[[kk]]
[17:38:12.289]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.289]                     next
[17:38:12.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:12.289]                 }
[17:38:12.289]                 if (length(args) > 0) 
[17:38:12.289]                   base::do.call(base::Sys.setenv, args = args)
[17:38:12.289]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:12.289]             }
[17:38:12.289]             else {
[17:38:12.289]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:12.289]             }
[17:38:12.289]             {
[17:38:12.289]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:12.289]                   0L) {
[17:38:12.289]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:12.289]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:12.289]                   base::options(opts)
[17:38:12.289]                 }
[17:38:12.289]                 {
[17:38:12.289]                   {
[17:38:12.289]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:12.289]                     NULL
[17:38:12.289]                   }
[17:38:12.289]                   options(future.plan = NULL)
[17:38:12.289]                   if (is.na(NA_character_)) 
[17:38:12.289]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:12.289]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:12.289]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:12.289]                     .init = FALSE)
[17:38:12.289]                 }
[17:38:12.289]             }
[17:38:12.289]         }
[17:38:12.289]     })
[17:38:12.289]     if (TRUE) {
[17:38:12.289]         base::sink(type = "output", split = FALSE)
[17:38:12.289]         if (TRUE) {
[17:38:12.289]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:12.289]         }
[17:38:12.289]         else {
[17:38:12.289]             ...future.result["stdout"] <- base::list(NULL)
[17:38:12.289]         }
[17:38:12.289]         base::close(...future.stdout)
[17:38:12.289]         ...future.stdout <- NULL
[17:38:12.289]     }
[17:38:12.289]     ...future.result$conditions <- ...future.conditions
[17:38:12.289]     ...future.result$finished <- base::Sys.time()
[17:38:12.289]     ...future.result
[17:38:12.289] }
[17:38:12.291] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[17:38:12.292] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:38:12.333] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:38:12.333] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[17:38:12.333] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[17:38:12.334] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:38:12.334] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:38:12.334] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:38:12.377] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:38:12.377] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:38:12.421] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:38:12.421] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:38:12.421] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:38:12.421] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[17:38:12.422] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[17:38:12.422] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:12.422] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:12.423] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:38:12.423] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:38:12.423] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:12.423] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:12.424] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:12.424] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:12.424] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[17:38:12.425] MultisessionFuture started
[17:38:12.425] - Launch lazy future ... done
[17:38:12.425] run() for ‘MultisessionFuture’ ... done
[17:38:12.425] Created future:
[17:38:12.425] MultisessionFuture:
[17:38:12.425] Label: ‘future_vapply-1’
[17:38:12.425] Expression:
[17:38:12.425] {
[17:38:12.425]     do.call(function(...) {
[17:38:12.425]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.425]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:12.425]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.425]             on.exit(options(oopts), add = TRUE)
[17:38:12.425]         }
[17:38:12.425]         {
[17:38:12.425]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:12.425]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.425]                 ...future.FUN(...future.X_jj, ...)
[17:38:12.425]             })
[17:38:12.425]         }
[17:38:12.425]     }, args = future.call.arguments)
[17:38:12.425] }
[17:38:12.425] Lazy evaluation: FALSE
[17:38:12.425] Asynchronous evaluation: TRUE
[17:38:12.425] Local evaluation: TRUE
[17:38:12.425] Environment: R_GlobalEnv
[17:38:12.425] Capture standard output: TRUE
[17:38:12.425] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:12.425] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:12.425] Packages: 1 packages (‘future.apply’)
[17:38:12.425] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:12.425] Resolved: FALSE
[17:38:12.425] Value: <not collected>
[17:38:12.425] Conditions captured: <none>
[17:38:12.425] Early signaling: FALSE
[17:38:12.425] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:12.425] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:12.437] Chunk #1 of 2 ... DONE
[17:38:12.437] Chunk #2 of 2 ...
[17:38:12.437]  - Finding globals in 'X' for chunk #2 ...
[17:38:12.437] getGlobalsAndPackages() ...
[17:38:12.438] Searching for globals...
[17:38:12.438] 
[17:38:12.438] Searching for globals ... DONE
[17:38:12.438] - globals: [0] <none>
[17:38:12.438] getGlobalsAndPackages() ... DONE
[17:38:12.438]    + additional globals found: [n=0] 
[17:38:12.438]    + additional namespaces needed: [n=0] 
[17:38:12.438]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:12.438]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:12.439]  - seeds: <none>
[17:38:12.439]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.439] getGlobalsAndPackages() ...
[17:38:12.439] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.439] Resolving globals: FALSE
[17:38:12.439] Tweak future expression to call with '...' arguments ...
[17:38:12.439] {
[17:38:12.439]     do.call(function(...) {
[17:38:12.439]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.439]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:12.439]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.439]             on.exit(options(oopts), add = TRUE)
[17:38:12.439]         }
[17:38:12.439]         {
[17:38:12.439]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:12.439]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.439]                 ...future.FUN(...future.X_jj, ...)
[17:38:12.439]             })
[17:38:12.439]         }
[17:38:12.439]     }, args = future.call.arguments)
[17:38:12.439] }
[17:38:12.439] Tweak future expression to call with '...' arguments ... DONE
[17:38:12.440] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.440] - packages: [1] ‘future.apply’
[17:38:12.440] getGlobalsAndPackages() ... DONE
[17:38:12.441] run() for ‘Future’ ...
[17:38:12.441] - state: ‘created’
[17:38:12.441] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:12.455] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:12.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:12.455]   - Field: ‘node’
[17:38:12.455]   - Field: ‘label’
[17:38:12.456]   - Field: ‘local’
[17:38:12.456]   - Field: ‘owner’
[17:38:12.456]   - Field: ‘envir’
[17:38:12.456]   - Field: ‘workers’
[17:38:12.456]   - Field: ‘packages’
[17:38:12.456]   - Field: ‘gc’
[17:38:12.456]   - Field: ‘conditions’
[17:38:12.456]   - Field: ‘persistent’
[17:38:12.456]   - Field: ‘expr’
[17:38:12.456]   - Field: ‘uuid’
[17:38:12.457]   - Field: ‘seed’
[17:38:12.457]   - Field: ‘version’
[17:38:12.457]   - Field: ‘result’
[17:38:12.457]   - Field: ‘asynchronous’
[17:38:12.457]   - Field: ‘calls’
[17:38:12.457]   - Field: ‘globals’
[17:38:12.457]   - Field: ‘stdout’
[17:38:12.457]   - Field: ‘earlySignal’
[17:38:12.457]   - Field: ‘lazy’
[17:38:12.457]   - Field: ‘state’
[17:38:12.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:12.458] - Launch lazy future ...
[17:38:12.458] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:12.458] Packages needed by future strategies (n = 0): <none>
[17:38:12.458] {
[17:38:12.458]     {
[17:38:12.458]         {
[17:38:12.458]             ...future.startTime <- base::Sys.time()
[17:38:12.458]             {
[17:38:12.458]                 {
[17:38:12.458]                   {
[17:38:12.458]                     {
[17:38:12.458]                       {
[17:38:12.458]                         base::local({
[17:38:12.458]                           has_future <- base::requireNamespace("future", 
[17:38:12.458]                             quietly = TRUE)
[17:38:12.458]                           if (has_future) {
[17:38:12.458]                             ns <- base::getNamespace("future")
[17:38:12.458]                             version <- ns[[".package"]][["version"]]
[17:38:12.458]                             if (is.null(version)) 
[17:38:12.458]                               version <- utils::packageVersion("future")
[17:38:12.458]                           }
[17:38:12.458]                           else {
[17:38:12.458]                             version <- NULL
[17:38:12.458]                           }
[17:38:12.458]                           if (!has_future || version < "1.8.0") {
[17:38:12.458]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:12.458]                               "", base::R.version$version.string), 
[17:38:12.458]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:12.458]                                 base::R.version$platform, 8 * 
[17:38:12.458]                                   base::.Machine$sizeof.pointer), 
[17:38:12.458]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:12.458]                                 "release", "version")], collapse = " "), 
[17:38:12.458]                               hostname = base::Sys.info()[["nodename"]])
[17:38:12.458]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:12.458]                               info)
[17:38:12.458]                             info <- base::paste(info, collapse = "; ")
[17:38:12.458]                             if (!has_future) {
[17:38:12.458]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:12.458]                                 info)
[17:38:12.458]                             }
[17:38:12.458]                             else {
[17:38:12.458]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:12.458]                                 info, version)
[17:38:12.458]                             }
[17:38:12.458]                             base::stop(msg)
[17:38:12.458]                           }
[17:38:12.458]                         })
[17:38:12.458]                       }
[17:38:12.458]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:12.458]                       base::options(mc.cores = 1L)
[17:38:12.458]                     }
[17:38:12.458]                     base::local({
[17:38:12.458]                       for (pkg in "future.apply") {
[17:38:12.458]                         base::loadNamespace(pkg)
[17:38:12.458]                         base::library(pkg, character.only = TRUE)
[17:38:12.458]                       }
[17:38:12.458]                     })
[17:38:12.458]                   }
[17:38:12.458]                   ...future.strategy.old <- future::plan("list")
[17:38:12.458]                   options(future.plan = NULL)
[17:38:12.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:12.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:12.458]                 }
[17:38:12.458]                 ...future.workdir <- getwd()
[17:38:12.458]             }
[17:38:12.458]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:12.458]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:12.458]         }
[17:38:12.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:12.458]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:12.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:12.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:12.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:12.458]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:12.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:12.458]             base::names(...future.oldOptions))
[17:38:12.458]     }
[17:38:12.458]     if (FALSE) {
[17:38:12.458]     }
[17:38:12.458]     else {
[17:38:12.458]         if (TRUE) {
[17:38:12.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:12.458]                 open = "w")
[17:38:12.458]         }
[17:38:12.458]         else {
[17:38:12.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:12.458]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:12.458]         }
[17:38:12.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:12.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:12.458]             base::sink(type = "output", split = FALSE)
[17:38:12.458]             base::close(...future.stdout)
[17:38:12.458]         }, add = TRUE)
[17:38:12.458]     }
[17:38:12.458]     ...future.frame <- base::sys.nframe()
[17:38:12.458]     ...future.conditions <- base::list()
[17:38:12.458]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:12.458]     if (FALSE) {
[17:38:12.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:12.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:12.458]     }
[17:38:12.458]     ...future.result <- base::tryCatch({
[17:38:12.458]         base::withCallingHandlers({
[17:38:12.458]             ...future.value <- base::withVisible(base::local({
[17:38:12.458]                 ...future.makeSendCondition <- base::local({
[17:38:12.458]                   sendCondition <- NULL
[17:38:12.458]                   function(frame = 1L) {
[17:38:12.458]                     if (is.function(sendCondition)) 
[17:38:12.458]                       return(sendCondition)
[17:38:12.458]                     ns <- getNamespace("parallel")
[17:38:12.458]                     if (exists("sendData", mode = "function", 
[17:38:12.458]                       envir = ns)) {
[17:38:12.458]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:12.458]                         envir = ns)
[17:38:12.458]                       envir <- sys.frame(frame)
[17:38:12.458]                       master <- NULL
[17:38:12.458]                       while (!identical(envir, .GlobalEnv) && 
[17:38:12.458]                         !identical(envir, emptyenv())) {
[17:38:12.458]                         if (exists("master", mode = "list", envir = envir, 
[17:38:12.458]                           inherits = FALSE)) {
[17:38:12.458]                           master <- get("master", mode = "list", 
[17:38:12.458]                             envir = envir, inherits = FALSE)
[17:38:12.458]                           if (inherits(master, c("SOCKnode", 
[17:38:12.458]                             "SOCK0node"))) {
[17:38:12.458]                             sendCondition <<- function(cond) {
[17:38:12.458]                               data <- list(type = "VALUE", value = cond, 
[17:38:12.458]                                 success = TRUE)
[17:38:12.458]                               parallel_sendData(master, data)
[17:38:12.458]                             }
[17:38:12.458]                             return(sendCondition)
[17:38:12.458]                           }
[17:38:12.458]                         }
[17:38:12.458]                         frame <- frame + 1L
[17:38:12.458]                         envir <- sys.frame(frame)
[17:38:12.458]                       }
[17:38:12.458]                     }
[17:38:12.458]                     sendCondition <<- function(cond) NULL
[17:38:12.458]                   }
[17:38:12.458]                 })
[17:38:12.458]                 withCallingHandlers({
[17:38:12.458]                   {
[17:38:12.458]                     do.call(function(...) {
[17:38:12.458]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.458]                       if (!identical(...future.globals.maxSize.org, 
[17:38:12.458]                         ...future.globals.maxSize)) {
[17:38:12.458]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.458]                         on.exit(options(oopts), add = TRUE)
[17:38:12.458]                       }
[17:38:12.458]                       {
[17:38:12.458]                         lapply(seq_along(...future.elements_ii), 
[17:38:12.458]                           FUN = function(jj) {
[17:38:12.458]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.458]                             ...future.FUN(...future.X_jj, ...)
[17:38:12.458]                           })
[17:38:12.458]                       }
[17:38:12.458]                     }, args = future.call.arguments)
[17:38:12.458]                   }
[17:38:12.458]                 }, immediateCondition = function(cond) {
[17:38:12.458]                   sendCondition <- ...future.makeSendCondition()
[17:38:12.458]                   sendCondition(cond)
[17:38:12.458]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.458]                   {
[17:38:12.458]                     inherits <- base::inherits
[17:38:12.458]                     invokeRestart <- base::invokeRestart
[17:38:12.458]                     is.null <- base::is.null
[17:38:12.458]                     muffled <- FALSE
[17:38:12.458]                     if (inherits(cond, "message")) {
[17:38:12.458]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:12.458]                       if (muffled) 
[17:38:12.458]                         invokeRestart("muffleMessage")
[17:38:12.458]                     }
[17:38:12.458]                     else if (inherits(cond, "warning")) {
[17:38:12.458]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:12.458]                       if (muffled) 
[17:38:12.458]                         invokeRestart("muffleWarning")
[17:38:12.458]                     }
[17:38:12.458]                     else if (inherits(cond, "condition")) {
[17:38:12.458]                       if (!is.null(pattern)) {
[17:38:12.458]                         computeRestarts <- base::computeRestarts
[17:38:12.458]                         grepl <- base::grepl
[17:38:12.458]                         restarts <- computeRestarts(cond)
[17:38:12.458]                         for (restart in restarts) {
[17:38:12.458]                           name <- restart$name
[17:38:12.458]                           if (is.null(name)) 
[17:38:12.458]                             next
[17:38:12.458]                           if (!grepl(pattern, name)) 
[17:38:12.458]                             next
[17:38:12.458]                           invokeRestart(restart)
[17:38:12.458]                           muffled <- TRUE
[17:38:12.458]                           break
[17:38:12.458]                         }
[17:38:12.458]                       }
[17:38:12.458]                     }
[17:38:12.458]                     invisible(muffled)
[17:38:12.458]                   }
[17:38:12.458]                   muffleCondition(cond)
[17:38:12.458]                 })
[17:38:12.458]             }))
[17:38:12.458]             future::FutureResult(value = ...future.value$value, 
[17:38:12.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:12.458]                   ...future.rng), globalenv = if (FALSE) 
[17:38:12.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:12.458]                     ...future.globalenv.names))
[17:38:12.458]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:12.458]         }, condition = base::local({
[17:38:12.458]             c <- base::c
[17:38:12.458]             inherits <- base::inherits
[17:38:12.458]             invokeRestart <- base::invokeRestart
[17:38:12.458]             length <- base::length
[17:38:12.458]             list <- base::list
[17:38:12.458]             seq.int <- base::seq.int
[17:38:12.458]             signalCondition <- base::signalCondition
[17:38:12.458]             sys.calls <- base::sys.calls
[17:38:12.458]             `[[` <- base::`[[`
[17:38:12.458]             `+` <- base::`+`
[17:38:12.458]             `<<-` <- base::`<<-`
[17:38:12.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:12.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:12.458]                   3L)]
[17:38:12.458]             }
[17:38:12.458]             function(cond) {
[17:38:12.458]                 is_error <- inherits(cond, "error")
[17:38:12.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:12.458]                   NULL)
[17:38:12.458]                 if (is_error) {
[17:38:12.458]                   sessionInformation <- function() {
[17:38:12.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:12.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:12.458]                       search = base::search(), system = base::Sys.info())
[17:38:12.458]                   }
[17:38:12.458]                   ...future.conditions[[length(...future.conditions) + 
[17:38:12.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:12.458]                     cond$call), session = sessionInformation(), 
[17:38:12.458]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:12.458]                   signalCondition(cond)
[17:38:12.458]                 }
[17:38:12.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:12.458]                 "immediateCondition"))) {
[17:38:12.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:12.458]                   ...future.conditions[[length(...future.conditions) + 
[17:38:12.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:12.458]                   if (TRUE && !signal) {
[17:38:12.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.458]                     {
[17:38:12.458]                       inherits <- base::inherits
[17:38:12.458]                       invokeRestart <- base::invokeRestart
[17:38:12.458]                       is.null <- base::is.null
[17:38:12.458]                       muffled <- FALSE
[17:38:12.458]                       if (inherits(cond, "message")) {
[17:38:12.458]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:12.458]                         if (muffled) 
[17:38:12.458]                           invokeRestart("muffleMessage")
[17:38:12.458]                       }
[17:38:12.458]                       else if (inherits(cond, "warning")) {
[17:38:12.458]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:12.458]                         if (muffled) 
[17:38:12.458]                           invokeRestart("muffleWarning")
[17:38:12.458]                       }
[17:38:12.458]                       else if (inherits(cond, "condition")) {
[17:38:12.458]                         if (!is.null(pattern)) {
[17:38:12.458]                           computeRestarts <- base::computeRestarts
[17:38:12.458]                           grepl <- base::grepl
[17:38:12.458]                           restarts <- computeRestarts(cond)
[17:38:12.458]                           for (restart in restarts) {
[17:38:12.458]                             name <- restart$name
[17:38:12.458]                             if (is.null(name)) 
[17:38:12.458]                               next
[17:38:12.458]                             if (!grepl(pattern, name)) 
[17:38:12.458]                               next
[17:38:12.458]                             invokeRestart(restart)
[17:38:12.458]                             muffled <- TRUE
[17:38:12.458]                             break
[17:38:12.458]                           }
[17:38:12.458]                         }
[17:38:12.458]                       }
[17:38:12.458]                       invisible(muffled)
[17:38:12.458]                     }
[17:38:12.458]                     muffleCondition(cond, pattern = "^muffle")
[17:38:12.458]                   }
[17:38:12.458]                 }
[17:38:12.458]                 else {
[17:38:12.458]                   if (TRUE) {
[17:38:12.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.458]                     {
[17:38:12.458]                       inherits <- base::inherits
[17:38:12.458]                       invokeRestart <- base::invokeRestart
[17:38:12.458]                       is.null <- base::is.null
[17:38:12.458]                       muffled <- FALSE
[17:38:12.458]                       if (inherits(cond, "message")) {
[17:38:12.458]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:12.458]                         if (muffled) 
[17:38:12.458]                           invokeRestart("muffleMessage")
[17:38:12.458]                       }
[17:38:12.458]                       else if (inherits(cond, "warning")) {
[17:38:12.458]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:12.458]                         if (muffled) 
[17:38:12.458]                           invokeRestart("muffleWarning")
[17:38:12.458]                       }
[17:38:12.458]                       else if (inherits(cond, "condition")) {
[17:38:12.458]                         if (!is.null(pattern)) {
[17:38:12.458]                           computeRestarts <- base::computeRestarts
[17:38:12.458]                           grepl <- base::grepl
[17:38:12.458]                           restarts <- computeRestarts(cond)
[17:38:12.458]                           for (restart in restarts) {
[17:38:12.458]                             name <- restart$name
[17:38:12.458]                             if (is.null(name)) 
[17:38:12.458]                               next
[17:38:12.458]                             if (!grepl(pattern, name)) 
[17:38:12.458]                               next
[17:38:12.458]                             invokeRestart(restart)
[17:38:12.458]                             muffled <- TRUE
[17:38:12.458]                             break
[17:38:12.458]                           }
[17:38:12.458]                         }
[17:38:12.458]                       }
[17:38:12.458]                       invisible(muffled)
[17:38:12.458]                     }
[17:38:12.458]                     muffleCondition(cond, pattern = "^muffle")
[17:38:12.458]                   }
[17:38:12.458]                 }
[17:38:12.458]             }
[17:38:12.458]         }))
[17:38:12.458]     }, error = function(ex) {
[17:38:12.458]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:12.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:12.458]                 ...future.rng), started = ...future.startTime, 
[17:38:12.458]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:12.458]             version = "1.8"), class = "FutureResult")
[17:38:12.458]     }, finally = {
[17:38:12.458]         if (!identical(...future.workdir, getwd())) 
[17:38:12.458]             setwd(...future.workdir)
[17:38:12.458]         {
[17:38:12.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:12.458]                 ...future.oldOptions$nwarnings <- NULL
[17:38:12.458]             }
[17:38:12.458]             base::options(...future.oldOptions)
[17:38:12.458]             if (.Platform$OS.type == "windows") {
[17:38:12.458]                 old_names <- names(...future.oldEnvVars)
[17:38:12.458]                 envs <- base::Sys.getenv()
[17:38:12.458]                 names <- names(envs)
[17:38:12.458]                 common <- intersect(names, old_names)
[17:38:12.458]                 added <- setdiff(names, old_names)
[17:38:12.458]                 removed <- setdiff(old_names, names)
[17:38:12.458]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:12.458]                   envs[common]]
[17:38:12.458]                 NAMES <- toupper(changed)
[17:38:12.458]                 args <- list()
[17:38:12.458]                 for (kk in seq_along(NAMES)) {
[17:38:12.458]                   name <- changed[[kk]]
[17:38:12.458]                   NAME <- NAMES[[kk]]
[17:38:12.458]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.458]                     next
[17:38:12.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:12.458]                 }
[17:38:12.458]                 NAMES <- toupper(added)
[17:38:12.458]                 for (kk in seq_along(NAMES)) {
[17:38:12.458]                   name <- added[[kk]]
[17:38:12.458]                   NAME <- NAMES[[kk]]
[17:38:12.458]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.458]                     next
[17:38:12.458]                   args[[name]] <- ""
[17:38:12.458]                 }
[17:38:12.458]                 NAMES <- toupper(removed)
[17:38:12.458]                 for (kk in seq_along(NAMES)) {
[17:38:12.458]                   name <- removed[[kk]]
[17:38:12.458]                   NAME <- NAMES[[kk]]
[17:38:12.458]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.458]                     next
[17:38:12.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:12.458]                 }
[17:38:12.458]                 if (length(args) > 0) 
[17:38:12.458]                   base::do.call(base::Sys.setenv, args = args)
[17:38:12.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:12.458]             }
[17:38:12.458]             else {
[17:38:12.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:12.458]             }
[17:38:12.458]             {
[17:38:12.458]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:12.458]                   0L) {
[17:38:12.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:12.458]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:12.458]                   base::options(opts)
[17:38:12.458]                 }
[17:38:12.458]                 {
[17:38:12.458]                   {
[17:38:12.458]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:12.458]                     NULL
[17:38:12.458]                   }
[17:38:12.458]                   options(future.plan = NULL)
[17:38:12.458]                   if (is.na(NA_character_)) 
[17:38:12.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:12.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:12.458]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:12.458]                     .init = FALSE)
[17:38:12.458]                 }
[17:38:12.458]             }
[17:38:12.458]         }
[17:38:12.458]     })
[17:38:12.458]     if (TRUE) {
[17:38:12.458]         base::sink(type = "output", split = FALSE)
[17:38:12.458]         if (TRUE) {
[17:38:12.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:12.458]         }
[17:38:12.458]         else {
[17:38:12.458]             ...future.result["stdout"] <- base::list(NULL)
[17:38:12.458]         }
[17:38:12.458]         base::close(...future.stdout)
[17:38:12.458]         ...future.stdout <- NULL
[17:38:12.458]     }
[17:38:12.458]     ...future.result$conditions <- ...future.conditions
[17:38:12.458]     ...future.result$finished <- base::Sys.time()
[17:38:12.458]     ...future.result
[17:38:12.458] }
[17:38:12.461] Exporting 11 global objects (94.95 KiB) to cluster node #2 ...
[17:38:12.461] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:38:12.505] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:38:12.505] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[17:38:12.505] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[17:38:12.505] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:38:12.506] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:38:12.506] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:38:12.549] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:38:12.549] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:38:12.593] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:38:12.593] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[17:38:12.593] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[17:38:12.594] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[17:38:12.594] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[17:38:12.595] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:12.595] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:12.595] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:38:12.596] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:38:12.596] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:12.596] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:12.596] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:12.597] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:12.597] Exporting 11 global objects (94.95 KiB) to cluster node #2 ... DONE
[17:38:12.597] MultisessionFuture started
[17:38:12.598] - Launch lazy future ... done
[17:38:12.598] run() for ‘MultisessionFuture’ ... done
[17:38:12.598] Created future:
[17:38:12.598] MultisessionFuture:
[17:38:12.598] Label: ‘future_vapply-2’
[17:38:12.598] Expression:
[17:38:12.598] {
[17:38:12.598]     do.call(function(...) {
[17:38:12.598]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.598]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:12.598]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.598]             on.exit(options(oopts), add = TRUE)
[17:38:12.598]         }
[17:38:12.598]         {
[17:38:12.598]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:12.598]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.598]                 ...future.FUN(...future.X_jj, ...)
[17:38:12.598]             })
[17:38:12.598]         }
[17:38:12.598]     }, args = future.call.arguments)
[17:38:12.598] }
[17:38:12.598] Lazy evaluation: FALSE
[17:38:12.598] Asynchronous evaluation: TRUE
[17:38:12.598] Local evaluation: TRUE
[17:38:12.598] Environment: R_GlobalEnv
[17:38:12.598] Capture standard output: TRUE
[17:38:12.598] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:12.598] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:12.598] Packages: 1 packages (‘future.apply’)
[17:38:12.598] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:12.598] Resolved: FALSE
[17:38:12.598] Value: <not collected>
[17:38:12.598] Conditions captured: <none>
[17:38:12.598] Early signaling: FALSE
[17:38:12.598] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:12.598] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:12.610] Chunk #2 of 2 ... DONE
[17:38:12.610] Launching 2 futures (chunks) ... DONE
[17:38:12.610] Resolving 2 futures (chunks) ...
[17:38:12.610] resolve() on list ...
[17:38:12.610]  recursive: 0
[17:38:12.610]  length: 2
[17:38:12.610] 
[17:38:12.611] receiveMessageFromWorker() for ClusterFuture ...
[17:38:12.611] - Validating connection of MultisessionFuture
[17:38:12.611] - received message: FutureResult
[17:38:12.611] - Received FutureResult
[17:38:12.611] - Erased future from FutureRegistry
[17:38:12.611] result() for ClusterFuture ...
[17:38:12.612] - result already collected: FutureResult
[17:38:12.612] result() for ClusterFuture ... done
[17:38:12.612] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:12.612] Future #1
[17:38:12.612] result() for ClusterFuture ...
[17:38:12.612] - result already collected: FutureResult
[17:38:12.612] result() for ClusterFuture ... done
[17:38:12.612] result() for ClusterFuture ...
[17:38:12.612] - result already collected: FutureResult
[17:38:12.612] result() for ClusterFuture ... done
[17:38:12.612] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:12.613] - nx: 2
[17:38:12.613] - relay: TRUE
[17:38:12.613] - stdout: TRUE
[17:38:12.613] - signal: TRUE
[17:38:12.613] - resignal: FALSE
[17:38:12.613] - force: TRUE
[17:38:12.613] - relayed: [n=2] FALSE, FALSE
[17:38:12.613] - queued futures: [n=2] FALSE, FALSE
[17:38:12.613]  - until=1
[17:38:12.613]  - relaying element #1
[17:38:12.613] result() for ClusterFuture ...
[17:38:12.613] - result already collected: FutureResult
[17:38:12.614] result() for ClusterFuture ... done
[17:38:12.614] result() for ClusterFuture ...
[17:38:12.614] - result already collected: FutureResult
[17:38:12.614] result() for ClusterFuture ... done
[17:38:12.614] result() for ClusterFuture ...
[17:38:12.614] - result already collected: FutureResult
[17:38:12.614] result() for ClusterFuture ... done
[17:38:12.614] result() for ClusterFuture ...
[17:38:12.614] - result already collected: FutureResult
[17:38:12.614] result() for ClusterFuture ... done
[17:38:12.614] - relayed: [n=2] TRUE, FALSE
[17:38:12.614] - queued futures: [n=2] TRUE, FALSE
[17:38:12.615] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:12.615]  length: 1 (resolved future 1)
[17:38:12.642] receiveMessageFromWorker() for ClusterFuture ...
[17:38:12.642] - Validating connection of MultisessionFuture
[17:38:12.643] - received message: FutureResult
[17:38:12.643] - Received FutureResult
[17:38:12.643] - Erased future from FutureRegistry
[17:38:12.643] result() for ClusterFuture ...
[17:38:12.643] - result already collected: FutureResult
[17:38:12.643] result() for ClusterFuture ... done
[17:38:12.643] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:12.643] Future #2
[17:38:12.643] result() for ClusterFuture ...
[17:38:12.643] - result already collected: FutureResult
[17:38:12.643] result() for ClusterFuture ... done
[17:38:12.644] result() for ClusterFuture ...
[17:38:12.644] - result already collected: FutureResult
[17:38:12.644] result() for ClusterFuture ... done
[17:38:12.644] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:12.644] - nx: 2
[17:38:12.644] - relay: TRUE
[17:38:12.644] - stdout: TRUE
[17:38:12.644] - signal: TRUE
[17:38:12.644] - resignal: FALSE
[17:38:12.644] - force: TRUE
[17:38:12.644] - relayed: [n=2] TRUE, FALSE
[17:38:12.645] - queued futures: [n=2] TRUE, FALSE
[17:38:12.645]  - until=2
[17:38:12.645]  - relaying element #2
[17:38:12.647] result() for ClusterFuture ...
[17:38:12.647] - result already collected: FutureResult
[17:38:12.647] result() for ClusterFuture ... done
[17:38:12.647] result() for ClusterFuture ...
[17:38:12.648] - result already collected: FutureResult
[17:38:12.648] result() for ClusterFuture ... done
[17:38:12.648] result() for ClusterFuture ...
[17:38:12.648] - result already collected: FutureResult
[17:38:12.648] result() for ClusterFuture ... done
[17:38:12.648] result() for ClusterFuture ...
[17:38:12.648] - result already collected: FutureResult
[17:38:12.648] result() for ClusterFuture ... done
[17:38:12.648] - relayed: [n=2] TRUE, TRUE
[17:38:12.648] - queued futures: [n=2] TRUE, TRUE
[17:38:12.648] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:12.649]  length: 0 (resolved future 2)
[17:38:12.649] Relaying remaining futures
[17:38:12.649] signalConditionsASAP(NULL, pos=0) ...
[17:38:12.649] - nx: 2
[17:38:12.649] - relay: TRUE
[17:38:12.649] - stdout: TRUE
[17:38:12.649] - signal: TRUE
[17:38:12.649] - resignal: FALSE
[17:38:12.649] - force: TRUE
[17:38:12.649] - relayed: [n=2] TRUE, TRUE
[17:38:12.649] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:12.649] - relayed: [n=2] TRUE, TRUE
[17:38:12.650] - queued futures: [n=2] TRUE, TRUE
[17:38:12.650] signalConditionsASAP(NULL, pos=0) ... done
[17:38:12.650] resolve() on list ... DONE
[17:38:12.650] result() for ClusterFuture ...
[17:38:12.650] - result already collected: FutureResult
[17:38:12.650] result() for ClusterFuture ... done
[17:38:12.650] result() for ClusterFuture ...
[17:38:12.650] - result already collected: FutureResult
[17:38:12.650] result() for ClusterFuture ... done
[17:38:12.650] result() for ClusterFuture ...
[17:38:12.650] - result already collected: FutureResult
[17:38:12.651] result() for ClusterFuture ... done
[17:38:12.651] result() for ClusterFuture ...
[17:38:12.651] - result already collected: FutureResult
[17:38:12.651] result() for ClusterFuture ... done
[17:38:12.651]  - Number of value chunks collected: 2
[17:38:12.651] Resolving 2 futures (chunks) ... DONE
[17:38:12.651] Reducing values from 2 chunks ...
[17:38:12.651]  - Number of values collected after concatenation: 10
[17:38:12.651]  - Number of values expected: 10
[17:38:12.651] Reducing values from 2 chunks ... DONE
[17:38:12.651] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:38:12.652] future_lapply() ...
[17:38:12.658] Number of chunks: 2
[17:38:12.658] getGlobalsAndPackagesXApply() ...
[17:38:12.658]  - future.globals: TRUE
[17:38:12.658] getGlobalsAndPackages() ...
[17:38:12.658] Searching for globals...
[17:38:12.662] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:38:12.662] Searching for globals ... DONE
[17:38:12.662] Resolving globals: FALSE
[17:38:12.663] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[17:38:12.663] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:12.663] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:12.664] - packages: [1] ‘future.apply’
[17:38:12.664] getGlobalsAndPackages() ... DONE
[17:38:12.664]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:12.664]  - needed namespaces: [n=1] ‘future.apply’
[17:38:12.664] Finding globals ... DONE
[17:38:12.664]  - use_args: TRUE
[17:38:12.664]  - Getting '...' globals ...
[17:38:12.665] resolve() on list ...
[17:38:12.665]  recursive: 0
[17:38:12.665]  length: 1
[17:38:12.665]  elements: ‘...’
[17:38:12.665]  length: 0 (resolved future 1)
[17:38:12.665] resolve() on list ... DONE
[17:38:12.665]    - '...' content: [n=0] 
[17:38:12.665] List of 1
[17:38:12.665]  $ ...: list()
[17:38:12.665]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:12.665]  - attr(*, "where")=List of 1
[17:38:12.665]   ..$ ...:<environment: 0x560801bd9b88> 
[17:38:12.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:12.665]  - attr(*, "resolved")= logi TRUE
[17:38:12.665]  - attr(*, "total_size")= num NA
[17:38:12.668]  - Getting '...' globals ... DONE
[17:38:12.668] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:12.668] List of 8
[17:38:12.668]  $ ...future.FUN:function (x, ...)  
[17:38:12.668]  $ x_FUN        :function (x)  
[17:38:12.668]  $ times        : int 4
[17:38:12.668]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:12.668]  $ stop_if_not  :function (...)  
[17:38:12.668]  $ dim          : int [1:2] 2 2
[17:38:12.668]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:12.668]  $ ...          : list()
[17:38:12.668]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:12.668]  - attr(*, "where")=List of 8
[17:38:12.668]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:12.668]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:12.668]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:12.668]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:12.668]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:12.668]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:12.668]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:12.668]   ..$ ...          :<environment: 0x560801bd9b88> 
[17:38:12.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:12.668]  - attr(*, "resolved")= logi FALSE
[17:38:12.668]  - attr(*, "total_size")= num 97304
[17:38:12.674] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:12.674] getGlobalsAndPackagesXApply() ... DONE
[17:38:12.674] Number of futures (= number of chunks): 2
[17:38:12.674] Launching 2 futures (chunks) ...
[17:38:12.674] Chunk #1 of 2 ...
[17:38:12.674]  - Finding globals in 'X' for chunk #1 ...
[17:38:12.674] getGlobalsAndPackages() ...
[17:38:12.674] Searching for globals...
[17:38:12.675] 
[17:38:12.675] Searching for globals ... DONE
[17:38:12.675] - globals: [0] <none>
[17:38:12.675] getGlobalsAndPackages() ... DONE
[17:38:12.675]    + additional globals found: [n=0] 
[17:38:12.675]    + additional namespaces needed: [n=0] 
[17:38:12.675]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:12.675]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:12.675]  - seeds: <none>
[17:38:12.676]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.676] getGlobalsAndPackages() ...
[17:38:12.676] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.676] Resolving globals: FALSE
[17:38:12.676] Tweak future expression to call with '...' arguments ...
[17:38:12.676] {
[17:38:12.676]     do.call(function(...) {
[17:38:12.676]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.676]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:12.676]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.676]             on.exit(options(oopts), add = TRUE)
[17:38:12.676]         }
[17:38:12.676]         {
[17:38:12.676]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:12.676]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.676]                 ...future.FUN(...future.X_jj, ...)
[17:38:12.676]             })
[17:38:12.676]         }
[17:38:12.676]     }, args = future.call.arguments)
[17:38:12.676] }
[17:38:12.676] Tweak future expression to call with '...' arguments ... DONE
[17:38:12.677] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.677] - packages: [1] ‘future.apply’
[17:38:12.677] getGlobalsAndPackages() ... DONE
[17:38:12.677] run() for ‘Future’ ...
[17:38:12.678] - state: ‘created’
[17:38:12.678] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:12.693] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:12.693] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:12.693]   - Field: ‘node’
[17:38:12.693]   - Field: ‘label’
[17:38:12.693]   - Field: ‘local’
[17:38:12.694]   - Field: ‘owner’
[17:38:12.694]   - Field: ‘envir’
[17:38:12.694]   - Field: ‘workers’
[17:38:12.694]   - Field: ‘packages’
[17:38:12.694]   - Field: ‘gc’
[17:38:12.694]   - Field: ‘conditions’
[17:38:12.694]   - Field: ‘persistent’
[17:38:12.694]   - Field: ‘expr’
[17:38:12.694]   - Field: ‘uuid’
[17:38:12.694]   - Field: ‘seed’
[17:38:12.694]   - Field: ‘version’
[17:38:12.695]   - Field: ‘result’
[17:38:12.695]   - Field: ‘asynchronous’
[17:38:12.695]   - Field: ‘calls’
[17:38:12.695]   - Field: ‘globals’
[17:38:12.695]   - Field: ‘stdout’
[17:38:12.695]   - Field: ‘earlySignal’
[17:38:12.695]   - Field: ‘lazy’
[17:38:12.695]   - Field: ‘state’
[17:38:12.695] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:12.695] - Launch lazy future ...
[17:38:12.696] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:12.696] Packages needed by future strategies (n = 0): <none>
[17:38:12.696] {
[17:38:12.696]     {
[17:38:12.696]         {
[17:38:12.696]             ...future.startTime <- base::Sys.time()
[17:38:12.696]             {
[17:38:12.696]                 {
[17:38:12.696]                   {
[17:38:12.696]                     {
[17:38:12.696]                       {
[17:38:12.696]                         base::local({
[17:38:12.696]                           has_future <- base::requireNamespace("future", 
[17:38:12.696]                             quietly = TRUE)
[17:38:12.696]                           if (has_future) {
[17:38:12.696]                             ns <- base::getNamespace("future")
[17:38:12.696]                             version <- ns[[".package"]][["version"]]
[17:38:12.696]                             if (is.null(version)) 
[17:38:12.696]                               version <- utils::packageVersion("future")
[17:38:12.696]                           }
[17:38:12.696]                           else {
[17:38:12.696]                             version <- NULL
[17:38:12.696]                           }
[17:38:12.696]                           if (!has_future || version < "1.8.0") {
[17:38:12.696]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:12.696]                               "", base::R.version$version.string), 
[17:38:12.696]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:12.696]                                 base::R.version$platform, 8 * 
[17:38:12.696]                                   base::.Machine$sizeof.pointer), 
[17:38:12.696]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:12.696]                                 "release", "version")], collapse = " "), 
[17:38:12.696]                               hostname = base::Sys.info()[["nodename"]])
[17:38:12.696]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:12.696]                               info)
[17:38:12.696]                             info <- base::paste(info, collapse = "; ")
[17:38:12.696]                             if (!has_future) {
[17:38:12.696]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:12.696]                                 info)
[17:38:12.696]                             }
[17:38:12.696]                             else {
[17:38:12.696]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:12.696]                                 info, version)
[17:38:12.696]                             }
[17:38:12.696]                             base::stop(msg)
[17:38:12.696]                           }
[17:38:12.696]                         })
[17:38:12.696]                       }
[17:38:12.696]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:12.696]                       base::options(mc.cores = 1L)
[17:38:12.696]                     }
[17:38:12.696]                     base::local({
[17:38:12.696]                       for (pkg in "future.apply") {
[17:38:12.696]                         base::loadNamespace(pkg)
[17:38:12.696]                         base::library(pkg, character.only = TRUE)
[17:38:12.696]                       }
[17:38:12.696]                     })
[17:38:12.696]                   }
[17:38:12.696]                   ...future.strategy.old <- future::plan("list")
[17:38:12.696]                   options(future.plan = NULL)
[17:38:12.696]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:12.696]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:12.696]                 }
[17:38:12.696]                 ...future.workdir <- getwd()
[17:38:12.696]             }
[17:38:12.696]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:12.696]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:12.696]         }
[17:38:12.696]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:12.696]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:12.696]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:12.696]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:12.696]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:12.696]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:12.696]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:12.696]             base::names(...future.oldOptions))
[17:38:12.696]     }
[17:38:12.696]     if (FALSE) {
[17:38:12.696]     }
[17:38:12.696]     else {
[17:38:12.696]         if (TRUE) {
[17:38:12.696]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:12.696]                 open = "w")
[17:38:12.696]         }
[17:38:12.696]         else {
[17:38:12.696]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:12.696]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:12.696]         }
[17:38:12.696]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:12.696]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:12.696]             base::sink(type = "output", split = FALSE)
[17:38:12.696]             base::close(...future.stdout)
[17:38:12.696]         }, add = TRUE)
[17:38:12.696]     }
[17:38:12.696]     ...future.frame <- base::sys.nframe()
[17:38:12.696]     ...future.conditions <- base::list()
[17:38:12.696]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:12.696]     if (FALSE) {
[17:38:12.696]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:12.696]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:12.696]     }
[17:38:12.696]     ...future.result <- base::tryCatch({
[17:38:12.696]         base::withCallingHandlers({
[17:38:12.696]             ...future.value <- base::withVisible(base::local({
[17:38:12.696]                 ...future.makeSendCondition <- base::local({
[17:38:12.696]                   sendCondition <- NULL
[17:38:12.696]                   function(frame = 1L) {
[17:38:12.696]                     if (is.function(sendCondition)) 
[17:38:12.696]                       return(sendCondition)
[17:38:12.696]                     ns <- getNamespace("parallel")
[17:38:12.696]                     if (exists("sendData", mode = "function", 
[17:38:12.696]                       envir = ns)) {
[17:38:12.696]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:12.696]                         envir = ns)
[17:38:12.696]                       envir <- sys.frame(frame)
[17:38:12.696]                       master <- NULL
[17:38:12.696]                       while (!identical(envir, .GlobalEnv) && 
[17:38:12.696]                         !identical(envir, emptyenv())) {
[17:38:12.696]                         if (exists("master", mode = "list", envir = envir, 
[17:38:12.696]                           inherits = FALSE)) {
[17:38:12.696]                           master <- get("master", mode = "list", 
[17:38:12.696]                             envir = envir, inherits = FALSE)
[17:38:12.696]                           if (inherits(master, c("SOCKnode", 
[17:38:12.696]                             "SOCK0node"))) {
[17:38:12.696]                             sendCondition <<- function(cond) {
[17:38:12.696]                               data <- list(type = "VALUE", value = cond, 
[17:38:12.696]                                 success = TRUE)
[17:38:12.696]                               parallel_sendData(master, data)
[17:38:12.696]                             }
[17:38:12.696]                             return(sendCondition)
[17:38:12.696]                           }
[17:38:12.696]                         }
[17:38:12.696]                         frame <- frame + 1L
[17:38:12.696]                         envir <- sys.frame(frame)
[17:38:12.696]                       }
[17:38:12.696]                     }
[17:38:12.696]                     sendCondition <<- function(cond) NULL
[17:38:12.696]                   }
[17:38:12.696]                 })
[17:38:12.696]                 withCallingHandlers({
[17:38:12.696]                   {
[17:38:12.696]                     do.call(function(...) {
[17:38:12.696]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.696]                       if (!identical(...future.globals.maxSize.org, 
[17:38:12.696]                         ...future.globals.maxSize)) {
[17:38:12.696]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.696]                         on.exit(options(oopts), add = TRUE)
[17:38:12.696]                       }
[17:38:12.696]                       {
[17:38:12.696]                         lapply(seq_along(...future.elements_ii), 
[17:38:12.696]                           FUN = function(jj) {
[17:38:12.696]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.696]                             ...future.FUN(...future.X_jj, ...)
[17:38:12.696]                           })
[17:38:12.696]                       }
[17:38:12.696]                     }, args = future.call.arguments)
[17:38:12.696]                   }
[17:38:12.696]                 }, immediateCondition = function(cond) {
[17:38:12.696]                   sendCondition <- ...future.makeSendCondition()
[17:38:12.696]                   sendCondition(cond)
[17:38:12.696]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.696]                   {
[17:38:12.696]                     inherits <- base::inherits
[17:38:12.696]                     invokeRestart <- base::invokeRestart
[17:38:12.696]                     is.null <- base::is.null
[17:38:12.696]                     muffled <- FALSE
[17:38:12.696]                     if (inherits(cond, "message")) {
[17:38:12.696]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:12.696]                       if (muffled) 
[17:38:12.696]                         invokeRestart("muffleMessage")
[17:38:12.696]                     }
[17:38:12.696]                     else if (inherits(cond, "warning")) {
[17:38:12.696]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:12.696]                       if (muffled) 
[17:38:12.696]                         invokeRestart("muffleWarning")
[17:38:12.696]                     }
[17:38:12.696]                     else if (inherits(cond, "condition")) {
[17:38:12.696]                       if (!is.null(pattern)) {
[17:38:12.696]                         computeRestarts <- base::computeRestarts
[17:38:12.696]                         grepl <- base::grepl
[17:38:12.696]                         restarts <- computeRestarts(cond)
[17:38:12.696]                         for (restart in restarts) {
[17:38:12.696]                           name <- restart$name
[17:38:12.696]                           if (is.null(name)) 
[17:38:12.696]                             next
[17:38:12.696]                           if (!grepl(pattern, name)) 
[17:38:12.696]                             next
[17:38:12.696]                           invokeRestart(restart)
[17:38:12.696]                           muffled <- TRUE
[17:38:12.696]                           break
[17:38:12.696]                         }
[17:38:12.696]                       }
[17:38:12.696]                     }
[17:38:12.696]                     invisible(muffled)
[17:38:12.696]                   }
[17:38:12.696]                   muffleCondition(cond)
[17:38:12.696]                 })
[17:38:12.696]             }))
[17:38:12.696]             future::FutureResult(value = ...future.value$value, 
[17:38:12.696]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:12.696]                   ...future.rng), globalenv = if (FALSE) 
[17:38:12.696]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:12.696]                     ...future.globalenv.names))
[17:38:12.696]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:12.696]         }, condition = base::local({
[17:38:12.696]             c <- base::c
[17:38:12.696]             inherits <- base::inherits
[17:38:12.696]             invokeRestart <- base::invokeRestart
[17:38:12.696]             length <- base::length
[17:38:12.696]             list <- base::list
[17:38:12.696]             seq.int <- base::seq.int
[17:38:12.696]             signalCondition <- base::signalCondition
[17:38:12.696]             sys.calls <- base::sys.calls
[17:38:12.696]             `[[` <- base::`[[`
[17:38:12.696]             `+` <- base::`+`
[17:38:12.696]             `<<-` <- base::`<<-`
[17:38:12.696]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:12.696]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:12.696]                   3L)]
[17:38:12.696]             }
[17:38:12.696]             function(cond) {
[17:38:12.696]                 is_error <- inherits(cond, "error")
[17:38:12.696]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:12.696]                   NULL)
[17:38:12.696]                 if (is_error) {
[17:38:12.696]                   sessionInformation <- function() {
[17:38:12.696]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:12.696]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:12.696]                       search = base::search(), system = base::Sys.info())
[17:38:12.696]                   }
[17:38:12.696]                   ...future.conditions[[length(...future.conditions) + 
[17:38:12.696]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:12.696]                     cond$call), session = sessionInformation(), 
[17:38:12.696]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:12.696]                   signalCondition(cond)
[17:38:12.696]                 }
[17:38:12.696]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:12.696]                 "immediateCondition"))) {
[17:38:12.696]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:12.696]                   ...future.conditions[[length(...future.conditions) + 
[17:38:12.696]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:12.696]                   if (TRUE && !signal) {
[17:38:12.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.696]                     {
[17:38:12.696]                       inherits <- base::inherits
[17:38:12.696]                       invokeRestart <- base::invokeRestart
[17:38:12.696]                       is.null <- base::is.null
[17:38:12.696]                       muffled <- FALSE
[17:38:12.696]                       if (inherits(cond, "message")) {
[17:38:12.696]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:12.696]                         if (muffled) 
[17:38:12.696]                           invokeRestart("muffleMessage")
[17:38:12.696]                       }
[17:38:12.696]                       else if (inherits(cond, "warning")) {
[17:38:12.696]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:12.696]                         if (muffled) 
[17:38:12.696]                           invokeRestart("muffleWarning")
[17:38:12.696]                       }
[17:38:12.696]                       else if (inherits(cond, "condition")) {
[17:38:12.696]                         if (!is.null(pattern)) {
[17:38:12.696]                           computeRestarts <- base::computeRestarts
[17:38:12.696]                           grepl <- base::grepl
[17:38:12.696]                           restarts <- computeRestarts(cond)
[17:38:12.696]                           for (restart in restarts) {
[17:38:12.696]                             name <- restart$name
[17:38:12.696]                             if (is.null(name)) 
[17:38:12.696]                               next
[17:38:12.696]                             if (!grepl(pattern, name)) 
[17:38:12.696]                               next
[17:38:12.696]                             invokeRestart(restart)
[17:38:12.696]                             muffled <- TRUE
[17:38:12.696]                             break
[17:38:12.696]                           }
[17:38:12.696]                         }
[17:38:12.696]                       }
[17:38:12.696]                       invisible(muffled)
[17:38:12.696]                     }
[17:38:12.696]                     muffleCondition(cond, pattern = "^muffle")
[17:38:12.696]                   }
[17:38:12.696]                 }
[17:38:12.696]                 else {
[17:38:12.696]                   if (TRUE) {
[17:38:12.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.696]                     {
[17:38:12.696]                       inherits <- base::inherits
[17:38:12.696]                       invokeRestart <- base::invokeRestart
[17:38:12.696]                       is.null <- base::is.null
[17:38:12.696]                       muffled <- FALSE
[17:38:12.696]                       if (inherits(cond, "message")) {
[17:38:12.696]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:12.696]                         if (muffled) 
[17:38:12.696]                           invokeRestart("muffleMessage")
[17:38:12.696]                       }
[17:38:12.696]                       else if (inherits(cond, "warning")) {
[17:38:12.696]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:12.696]                         if (muffled) 
[17:38:12.696]                           invokeRestart("muffleWarning")
[17:38:12.696]                       }
[17:38:12.696]                       else if (inherits(cond, "condition")) {
[17:38:12.696]                         if (!is.null(pattern)) {
[17:38:12.696]                           computeRestarts <- base::computeRestarts
[17:38:12.696]                           grepl <- base::grepl
[17:38:12.696]                           restarts <- computeRestarts(cond)
[17:38:12.696]                           for (restart in restarts) {
[17:38:12.696]                             name <- restart$name
[17:38:12.696]                             if (is.null(name)) 
[17:38:12.696]                               next
[17:38:12.696]                             if (!grepl(pattern, name)) 
[17:38:12.696]                               next
[17:38:12.696]                             invokeRestart(restart)
[17:38:12.696]                             muffled <- TRUE
[17:38:12.696]                             break
[17:38:12.696]                           }
[17:38:12.696]                         }
[17:38:12.696]                       }
[17:38:12.696]                       invisible(muffled)
[17:38:12.696]                     }
[17:38:12.696]                     muffleCondition(cond, pattern = "^muffle")
[17:38:12.696]                   }
[17:38:12.696]                 }
[17:38:12.696]             }
[17:38:12.696]         }))
[17:38:12.696]     }, error = function(ex) {
[17:38:12.696]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:12.696]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:12.696]                 ...future.rng), started = ...future.startTime, 
[17:38:12.696]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:12.696]             version = "1.8"), class = "FutureResult")
[17:38:12.696]     }, finally = {
[17:38:12.696]         if (!identical(...future.workdir, getwd())) 
[17:38:12.696]             setwd(...future.workdir)
[17:38:12.696]         {
[17:38:12.696]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:12.696]                 ...future.oldOptions$nwarnings <- NULL
[17:38:12.696]             }
[17:38:12.696]             base::options(...future.oldOptions)
[17:38:12.696]             if (.Platform$OS.type == "windows") {
[17:38:12.696]                 old_names <- names(...future.oldEnvVars)
[17:38:12.696]                 envs <- base::Sys.getenv()
[17:38:12.696]                 names <- names(envs)
[17:38:12.696]                 common <- intersect(names, old_names)
[17:38:12.696]                 added <- setdiff(names, old_names)
[17:38:12.696]                 removed <- setdiff(old_names, names)
[17:38:12.696]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:12.696]                   envs[common]]
[17:38:12.696]                 NAMES <- toupper(changed)
[17:38:12.696]                 args <- list()
[17:38:12.696]                 for (kk in seq_along(NAMES)) {
[17:38:12.696]                   name <- changed[[kk]]
[17:38:12.696]                   NAME <- NAMES[[kk]]
[17:38:12.696]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.696]                     next
[17:38:12.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:12.696]                 }
[17:38:12.696]                 NAMES <- toupper(added)
[17:38:12.696]                 for (kk in seq_along(NAMES)) {
[17:38:12.696]                   name <- added[[kk]]
[17:38:12.696]                   NAME <- NAMES[[kk]]
[17:38:12.696]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.696]                     next
[17:38:12.696]                   args[[name]] <- ""
[17:38:12.696]                 }
[17:38:12.696]                 NAMES <- toupper(removed)
[17:38:12.696]                 for (kk in seq_along(NAMES)) {
[17:38:12.696]                   name <- removed[[kk]]
[17:38:12.696]                   NAME <- NAMES[[kk]]
[17:38:12.696]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.696]                     next
[17:38:12.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:12.696]                 }
[17:38:12.696]                 if (length(args) > 0) 
[17:38:12.696]                   base::do.call(base::Sys.setenv, args = args)
[17:38:12.696]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:12.696]             }
[17:38:12.696]             else {
[17:38:12.696]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:12.696]             }
[17:38:12.696]             {
[17:38:12.696]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:12.696]                   0L) {
[17:38:12.696]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:12.696]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:12.696]                   base::options(opts)
[17:38:12.696]                 }
[17:38:12.696]                 {
[17:38:12.696]                   {
[17:38:12.696]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:12.696]                     NULL
[17:38:12.696]                   }
[17:38:12.696]                   options(future.plan = NULL)
[17:38:12.696]                   if (is.na(NA_character_)) 
[17:38:12.696]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:12.696]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:12.696]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:12.696]                     .init = FALSE)
[17:38:12.696]                 }
[17:38:12.696]             }
[17:38:12.696]         }
[17:38:12.696]     })
[17:38:12.696]     if (TRUE) {
[17:38:12.696]         base::sink(type = "output", split = FALSE)
[17:38:12.696]         if (TRUE) {
[17:38:12.696]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:12.696]         }
[17:38:12.696]         else {
[17:38:12.696]             ...future.result["stdout"] <- base::list(NULL)
[17:38:12.696]         }
[17:38:12.696]         base::close(...future.stdout)
[17:38:12.696]         ...future.stdout <- NULL
[17:38:12.696]     }
[17:38:12.696]     ...future.result$conditions <- ...future.conditions
[17:38:12.696]     ...future.result$finished <- base::Sys.time()
[17:38:12.696]     ...future.result
[17:38:12.696] }
[17:38:12.699] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[17:38:12.699] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:38:12.741] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:38:12.741] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[17:38:12.741] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[17:38:12.742] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:38:12.742] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:38:12.742] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:38:12.785] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:38:12.785] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:38:12.829] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:38:12.829] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:38:12.829] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:38:12.829] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:38:12.830] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:38:12.830] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:12.830] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:12.831] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:38:12.831] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:38:12.831] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:12.831] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:12.832] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:12.832] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:12.832] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[17:38:12.833] MultisessionFuture started
[17:38:12.833] - Launch lazy future ... done
[17:38:12.833] run() for ‘MultisessionFuture’ ... done
[17:38:12.833] Created future:
[17:38:12.833] MultisessionFuture:
[17:38:12.833] Label: ‘future_vapply-1’
[17:38:12.833] Expression:
[17:38:12.833] {
[17:38:12.833]     do.call(function(...) {
[17:38:12.833]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.833]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:12.833]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.833]             on.exit(options(oopts), add = TRUE)
[17:38:12.833]         }
[17:38:12.833]         {
[17:38:12.833]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:12.833]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.833]                 ...future.FUN(...future.X_jj, ...)
[17:38:12.833]             })
[17:38:12.833]         }
[17:38:12.833]     }, args = future.call.arguments)
[17:38:12.833] }
[17:38:12.833] Lazy evaluation: FALSE
[17:38:12.833] Asynchronous evaluation: TRUE
[17:38:12.833] Local evaluation: TRUE
[17:38:12.833] Environment: R_GlobalEnv
[17:38:12.833] Capture standard output: TRUE
[17:38:12.833] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:12.833] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:12.833] Packages: 1 packages (‘future.apply’)
[17:38:12.833] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:12.833] Resolved: FALSE
[17:38:12.833] Value: <not collected>
[17:38:12.833] Conditions captured: <none>
[17:38:12.833] Early signaling: FALSE
[17:38:12.833] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:12.833] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:12.845] Chunk #1 of 2 ... DONE
[17:38:12.845] Chunk #2 of 2 ...
[17:38:12.845]  - Finding globals in 'X' for chunk #2 ...
[17:38:12.846] getGlobalsAndPackages() ...
[17:38:12.846] Searching for globals...
[17:38:12.846] 
[17:38:12.846] Searching for globals ... DONE
[17:38:12.846] - globals: [0] <none>
[17:38:12.846] getGlobalsAndPackages() ... DONE
[17:38:12.846]    + additional globals found: [n=0] 
[17:38:12.846]    + additional namespaces needed: [n=0] 
[17:38:12.846]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:12.847]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:12.847]  - seeds: <none>
[17:38:12.847]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.847] getGlobalsAndPackages() ...
[17:38:12.847] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.847] Resolving globals: FALSE
[17:38:12.847] Tweak future expression to call with '...' arguments ...
[17:38:12.847] {
[17:38:12.847]     do.call(function(...) {
[17:38:12.847]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.847]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:12.847]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.847]             on.exit(options(oopts), add = TRUE)
[17:38:12.847]         }
[17:38:12.847]         {
[17:38:12.847]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:12.847]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.847]                 ...future.FUN(...future.X_jj, ...)
[17:38:12.847]             })
[17:38:12.847]         }
[17:38:12.847]     }, args = future.call.arguments)
[17:38:12.847] }
[17:38:12.848] Tweak future expression to call with '...' arguments ... DONE
[17:38:12.848] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:12.848] - packages: [1] ‘future.apply’
[17:38:12.848] getGlobalsAndPackages() ... DONE
[17:38:12.849] run() for ‘Future’ ...
[17:38:12.849] - state: ‘created’
[17:38:12.849] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:12.863] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:12.863] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:12.863]   - Field: ‘node’
[17:38:12.863]   - Field: ‘label’
[17:38:12.864]   - Field: ‘local’
[17:38:12.864]   - Field: ‘owner’
[17:38:12.864]   - Field: ‘envir’
[17:38:12.864]   - Field: ‘workers’
[17:38:12.864]   - Field: ‘packages’
[17:38:12.864]   - Field: ‘gc’
[17:38:12.864]   - Field: ‘conditions’
[17:38:12.864]   - Field: ‘persistent’
[17:38:12.864]   - Field: ‘expr’
[17:38:12.864]   - Field: ‘uuid’
[17:38:12.865]   - Field: ‘seed’
[17:38:12.865]   - Field: ‘version’
[17:38:12.865]   - Field: ‘result’
[17:38:12.865]   - Field: ‘asynchronous’
[17:38:12.865]   - Field: ‘calls’
[17:38:12.865]   - Field: ‘globals’
[17:38:12.865]   - Field: ‘stdout’
[17:38:12.865]   - Field: ‘earlySignal’
[17:38:12.865]   - Field: ‘lazy’
[17:38:12.865]   - Field: ‘state’
[17:38:12.865] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:12.866] - Launch lazy future ...
[17:38:12.866] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:12.866] Packages needed by future strategies (n = 0): <none>
[17:38:12.866] {
[17:38:12.866]     {
[17:38:12.866]         {
[17:38:12.866]             ...future.startTime <- base::Sys.time()
[17:38:12.866]             {
[17:38:12.866]                 {
[17:38:12.866]                   {
[17:38:12.866]                     {
[17:38:12.866]                       {
[17:38:12.866]                         base::local({
[17:38:12.866]                           has_future <- base::requireNamespace("future", 
[17:38:12.866]                             quietly = TRUE)
[17:38:12.866]                           if (has_future) {
[17:38:12.866]                             ns <- base::getNamespace("future")
[17:38:12.866]                             version <- ns[[".package"]][["version"]]
[17:38:12.866]                             if (is.null(version)) 
[17:38:12.866]                               version <- utils::packageVersion("future")
[17:38:12.866]                           }
[17:38:12.866]                           else {
[17:38:12.866]                             version <- NULL
[17:38:12.866]                           }
[17:38:12.866]                           if (!has_future || version < "1.8.0") {
[17:38:12.866]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:12.866]                               "", base::R.version$version.string), 
[17:38:12.866]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:12.866]                                 base::R.version$platform, 8 * 
[17:38:12.866]                                   base::.Machine$sizeof.pointer), 
[17:38:12.866]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:12.866]                                 "release", "version")], collapse = " "), 
[17:38:12.866]                               hostname = base::Sys.info()[["nodename"]])
[17:38:12.866]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:12.866]                               info)
[17:38:12.866]                             info <- base::paste(info, collapse = "; ")
[17:38:12.866]                             if (!has_future) {
[17:38:12.866]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:12.866]                                 info)
[17:38:12.866]                             }
[17:38:12.866]                             else {
[17:38:12.866]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:12.866]                                 info, version)
[17:38:12.866]                             }
[17:38:12.866]                             base::stop(msg)
[17:38:12.866]                           }
[17:38:12.866]                         })
[17:38:12.866]                       }
[17:38:12.866]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:12.866]                       base::options(mc.cores = 1L)
[17:38:12.866]                     }
[17:38:12.866]                     base::local({
[17:38:12.866]                       for (pkg in "future.apply") {
[17:38:12.866]                         base::loadNamespace(pkg)
[17:38:12.866]                         base::library(pkg, character.only = TRUE)
[17:38:12.866]                       }
[17:38:12.866]                     })
[17:38:12.866]                   }
[17:38:12.866]                   ...future.strategy.old <- future::plan("list")
[17:38:12.866]                   options(future.plan = NULL)
[17:38:12.866]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:12.866]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:12.866]                 }
[17:38:12.866]                 ...future.workdir <- getwd()
[17:38:12.866]             }
[17:38:12.866]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:12.866]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:12.866]         }
[17:38:12.866]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:12.866]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:12.866]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:12.866]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:12.866]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:12.866]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:12.866]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:12.866]             base::names(...future.oldOptions))
[17:38:12.866]     }
[17:38:12.866]     if (FALSE) {
[17:38:12.866]     }
[17:38:12.866]     else {
[17:38:12.866]         if (TRUE) {
[17:38:12.866]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:12.866]                 open = "w")
[17:38:12.866]         }
[17:38:12.866]         else {
[17:38:12.866]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:12.866]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:12.866]         }
[17:38:12.866]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:12.866]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:12.866]             base::sink(type = "output", split = FALSE)
[17:38:12.866]             base::close(...future.stdout)
[17:38:12.866]         }, add = TRUE)
[17:38:12.866]     }
[17:38:12.866]     ...future.frame <- base::sys.nframe()
[17:38:12.866]     ...future.conditions <- base::list()
[17:38:12.866]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:12.866]     if (FALSE) {
[17:38:12.866]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:12.866]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:12.866]     }
[17:38:12.866]     ...future.result <- base::tryCatch({
[17:38:12.866]         base::withCallingHandlers({
[17:38:12.866]             ...future.value <- base::withVisible(base::local({
[17:38:12.866]                 ...future.makeSendCondition <- base::local({
[17:38:12.866]                   sendCondition <- NULL
[17:38:12.866]                   function(frame = 1L) {
[17:38:12.866]                     if (is.function(sendCondition)) 
[17:38:12.866]                       return(sendCondition)
[17:38:12.866]                     ns <- getNamespace("parallel")
[17:38:12.866]                     if (exists("sendData", mode = "function", 
[17:38:12.866]                       envir = ns)) {
[17:38:12.866]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:12.866]                         envir = ns)
[17:38:12.866]                       envir <- sys.frame(frame)
[17:38:12.866]                       master <- NULL
[17:38:12.866]                       while (!identical(envir, .GlobalEnv) && 
[17:38:12.866]                         !identical(envir, emptyenv())) {
[17:38:12.866]                         if (exists("master", mode = "list", envir = envir, 
[17:38:12.866]                           inherits = FALSE)) {
[17:38:12.866]                           master <- get("master", mode = "list", 
[17:38:12.866]                             envir = envir, inherits = FALSE)
[17:38:12.866]                           if (inherits(master, c("SOCKnode", 
[17:38:12.866]                             "SOCK0node"))) {
[17:38:12.866]                             sendCondition <<- function(cond) {
[17:38:12.866]                               data <- list(type = "VALUE", value = cond, 
[17:38:12.866]                                 success = TRUE)
[17:38:12.866]                               parallel_sendData(master, data)
[17:38:12.866]                             }
[17:38:12.866]                             return(sendCondition)
[17:38:12.866]                           }
[17:38:12.866]                         }
[17:38:12.866]                         frame <- frame + 1L
[17:38:12.866]                         envir <- sys.frame(frame)
[17:38:12.866]                       }
[17:38:12.866]                     }
[17:38:12.866]                     sendCondition <<- function(cond) NULL
[17:38:12.866]                   }
[17:38:12.866]                 })
[17:38:12.866]                 withCallingHandlers({
[17:38:12.866]                   {
[17:38:12.866]                     do.call(function(...) {
[17:38:12.866]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:12.866]                       if (!identical(...future.globals.maxSize.org, 
[17:38:12.866]                         ...future.globals.maxSize)) {
[17:38:12.866]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:12.866]                         on.exit(options(oopts), add = TRUE)
[17:38:12.866]                       }
[17:38:12.866]                       {
[17:38:12.866]                         lapply(seq_along(...future.elements_ii), 
[17:38:12.866]                           FUN = function(jj) {
[17:38:12.866]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:12.866]                             ...future.FUN(...future.X_jj, ...)
[17:38:12.866]                           })
[17:38:12.866]                       }
[17:38:12.866]                     }, args = future.call.arguments)
[17:38:12.866]                   }
[17:38:12.866]                 }, immediateCondition = function(cond) {
[17:38:12.866]                   sendCondition <- ...future.makeSendCondition()
[17:38:12.866]                   sendCondition(cond)
[17:38:12.866]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.866]                   {
[17:38:12.866]                     inherits <- base::inherits
[17:38:12.866]                     invokeRestart <- base::invokeRestart
[17:38:12.866]                     is.null <- base::is.null
[17:38:12.866]                     muffled <- FALSE
[17:38:12.866]                     if (inherits(cond, "message")) {
[17:38:12.866]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:12.866]                       if (muffled) 
[17:38:12.866]                         invokeRestart("muffleMessage")
[17:38:12.866]                     }
[17:38:12.866]                     else if (inherits(cond, "warning")) {
[17:38:12.866]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:12.866]                       if (muffled) 
[17:38:12.866]                         invokeRestart("muffleWarning")
[17:38:12.866]                     }
[17:38:12.866]                     else if (inherits(cond, "condition")) {
[17:38:12.866]                       if (!is.null(pattern)) {
[17:38:12.866]                         computeRestarts <- base::computeRestarts
[17:38:12.866]                         grepl <- base::grepl
[17:38:12.866]                         restarts <- computeRestarts(cond)
[17:38:12.866]                         for (restart in restarts) {
[17:38:12.866]                           name <- restart$name
[17:38:12.866]                           if (is.null(name)) 
[17:38:12.866]                             next
[17:38:12.866]                           if (!grepl(pattern, name)) 
[17:38:12.866]                             next
[17:38:12.866]                           invokeRestart(restart)
[17:38:12.866]                           muffled <- TRUE
[17:38:12.866]                           break
[17:38:12.866]                         }
[17:38:12.866]                       }
[17:38:12.866]                     }
[17:38:12.866]                     invisible(muffled)
[17:38:12.866]                   }
[17:38:12.866]                   muffleCondition(cond)
[17:38:12.866]                 })
[17:38:12.866]             }))
[17:38:12.866]             future::FutureResult(value = ...future.value$value, 
[17:38:12.866]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:12.866]                   ...future.rng), globalenv = if (FALSE) 
[17:38:12.866]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:12.866]                     ...future.globalenv.names))
[17:38:12.866]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:12.866]         }, condition = base::local({
[17:38:12.866]             c <- base::c
[17:38:12.866]             inherits <- base::inherits
[17:38:12.866]             invokeRestart <- base::invokeRestart
[17:38:12.866]             length <- base::length
[17:38:12.866]             list <- base::list
[17:38:12.866]             seq.int <- base::seq.int
[17:38:12.866]             signalCondition <- base::signalCondition
[17:38:12.866]             sys.calls <- base::sys.calls
[17:38:12.866]             `[[` <- base::`[[`
[17:38:12.866]             `+` <- base::`+`
[17:38:12.866]             `<<-` <- base::`<<-`
[17:38:12.866]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:12.866]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:12.866]                   3L)]
[17:38:12.866]             }
[17:38:12.866]             function(cond) {
[17:38:12.866]                 is_error <- inherits(cond, "error")
[17:38:12.866]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:12.866]                   NULL)
[17:38:12.866]                 if (is_error) {
[17:38:12.866]                   sessionInformation <- function() {
[17:38:12.866]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:12.866]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:12.866]                       search = base::search(), system = base::Sys.info())
[17:38:12.866]                   }
[17:38:12.866]                   ...future.conditions[[length(...future.conditions) + 
[17:38:12.866]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:12.866]                     cond$call), session = sessionInformation(), 
[17:38:12.866]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:12.866]                   signalCondition(cond)
[17:38:12.866]                 }
[17:38:12.866]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:12.866]                 "immediateCondition"))) {
[17:38:12.866]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:12.866]                   ...future.conditions[[length(...future.conditions) + 
[17:38:12.866]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:12.866]                   if (TRUE && !signal) {
[17:38:12.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.866]                     {
[17:38:12.866]                       inherits <- base::inherits
[17:38:12.866]                       invokeRestart <- base::invokeRestart
[17:38:12.866]                       is.null <- base::is.null
[17:38:12.866]                       muffled <- FALSE
[17:38:12.866]                       if (inherits(cond, "message")) {
[17:38:12.866]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:12.866]                         if (muffled) 
[17:38:12.866]                           invokeRestart("muffleMessage")
[17:38:12.866]                       }
[17:38:12.866]                       else if (inherits(cond, "warning")) {
[17:38:12.866]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:12.866]                         if (muffled) 
[17:38:12.866]                           invokeRestart("muffleWarning")
[17:38:12.866]                       }
[17:38:12.866]                       else if (inherits(cond, "condition")) {
[17:38:12.866]                         if (!is.null(pattern)) {
[17:38:12.866]                           computeRestarts <- base::computeRestarts
[17:38:12.866]                           grepl <- base::grepl
[17:38:12.866]                           restarts <- computeRestarts(cond)
[17:38:12.866]                           for (restart in restarts) {
[17:38:12.866]                             name <- restart$name
[17:38:12.866]                             if (is.null(name)) 
[17:38:12.866]                               next
[17:38:12.866]                             if (!grepl(pattern, name)) 
[17:38:12.866]                               next
[17:38:12.866]                             invokeRestart(restart)
[17:38:12.866]                             muffled <- TRUE
[17:38:12.866]                             break
[17:38:12.866]                           }
[17:38:12.866]                         }
[17:38:12.866]                       }
[17:38:12.866]                       invisible(muffled)
[17:38:12.866]                     }
[17:38:12.866]                     muffleCondition(cond, pattern = "^muffle")
[17:38:12.866]                   }
[17:38:12.866]                 }
[17:38:12.866]                 else {
[17:38:12.866]                   if (TRUE) {
[17:38:12.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:12.866]                     {
[17:38:12.866]                       inherits <- base::inherits
[17:38:12.866]                       invokeRestart <- base::invokeRestart
[17:38:12.866]                       is.null <- base::is.null
[17:38:12.866]                       muffled <- FALSE
[17:38:12.866]                       if (inherits(cond, "message")) {
[17:38:12.866]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:12.866]                         if (muffled) 
[17:38:12.866]                           invokeRestart("muffleMessage")
[17:38:12.866]                       }
[17:38:12.866]                       else if (inherits(cond, "warning")) {
[17:38:12.866]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:12.866]                         if (muffled) 
[17:38:12.866]                           invokeRestart("muffleWarning")
[17:38:12.866]                       }
[17:38:12.866]                       else if (inherits(cond, "condition")) {
[17:38:12.866]                         if (!is.null(pattern)) {
[17:38:12.866]                           computeRestarts <- base::computeRestarts
[17:38:12.866]                           grepl <- base::grepl
[17:38:12.866]                           restarts <- computeRestarts(cond)
[17:38:12.866]                           for (restart in restarts) {
[17:38:12.866]                             name <- restart$name
[17:38:12.866]                             if (is.null(name)) 
[17:38:12.866]                               next
[17:38:12.866]                             if (!grepl(pattern, name)) 
[17:38:12.866]                               next
[17:38:12.866]                             invokeRestart(restart)
[17:38:12.866]                             muffled <- TRUE
[17:38:12.866]                             break
[17:38:12.866]                           }
[17:38:12.866]                         }
[17:38:12.866]                       }
[17:38:12.866]                       invisible(muffled)
[17:38:12.866]                     }
[17:38:12.866]                     muffleCondition(cond, pattern = "^muffle")
[17:38:12.866]                   }
[17:38:12.866]                 }
[17:38:12.866]             }
[17:38:12.866]         }))
[17:38:12.866]     }, error = function(ex) {
[17:38:12.866]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:12.866]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:12.866]                 ...future.rng), started = ...future.startTime, 
[17:38:12.866]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:12.866]             version = "1.8"), class = "FutureResult")
[17:38:12.866]     }, finally = {
[17:38:12.866]         if (!identical(...future.workdir, getwd())) 
[17:38:12.866]             setwd(...future.workdir)
[17:38:12.866]         {
[17:38:12.866]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:12.866]                 ...future.oldOptions$nwarnings <- NULL
[17:38:12.866]             }
[17:38:12.866]             base::options(...future.oldOptions)
[17:38:12.866]             if (.Platform$OS.type == "windows") {
[17:38:12.866]                 old_names <- names(...future.oldEnvVars)
[17:38:12.866]                 envs <- base::Sys.getenv()
[17:38:12.866]                 names <- names(envs)
[17:38:12.866]                 common <- intersect(names, old_names)
[17:38:12.866]                 added <- setdiff(names, old_names)
[17:38:12.866]                 removed <- setdiff(old_names, names)
[17:38:12.866]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:12.866]                   envs[common]]
[17:38:12.866]                 NAMES <- toupper(changed)
[17:38:12.866]                 args <- list()
[17:38:12.866]                 for (kk in seq_along(NAMES)) {
[17:38:12.866]                   name <- changed[[kk]]
[17:38:12.866]                   NAME <- NAMES[[kk]]
[17:38:12.866]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.866]                     next
[17:38:12.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:12.866]                 }
[17:38:12.866]                 NAMES <- toupper(added)
[17:38:12.866]                 for (kk in seq_along(NAMES)) {
[17:38:12.866]                   name <- added[[kk]]
[17:38:12.866]                   NAME <- NAMES[[kk]]
[17:38:12.866]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.866]                     next
[17:38:12.866]                   args[[name]] <- ""
[17:38:12.866]                 }
[17:38:12.866]                 NAMES <- toupper(removed)
[17:38:12.866]                 for (kk in seq_along(NAMES)) {
[17:38:12.866]                   name <- removed[[kk]]
[17:38:12.866]                   NAME <- NAMES[[kk]]
[17:38:12.866]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:12.866]                     next
[17:38:12.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:12.866]                 }
[17:38:12.866]                 if (length(args) > 0) 
[17:38:12.866]                   base::do.call(base::Sys.setenv, args = args)
[17:38:12.866]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:12.866]             }
[17:38:12.866]             else {
[17:38:12.866]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:12.866]             }
[17:38:12.866]             {
[17:38:12.866]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:12.866]                   0L) {
[17:38:12.866]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:12.866]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:12.866]                   base::options(opts)
[17:38:12.866]                 }
[17:38:12.866]                 {
[17:38:12.866]                   {
[17:38:12.866]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:12.866]                     NULL
[17:38:12.866]                   }
[17:38:12.866]                   options(future.plan = NULL)
[17:38:12.866]                   if (is.na(NA_character_)) 
[17:38:12.866]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:12.866]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:12.866]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:12.866]                     .init = FALSE)
[17:38:12.866]                 }
[17:38:12.866]             }
[17:38:12.866]         }
[17:38:12.866]     })
[17:38:12.866]     if (TRUE) {
[17:38:12.866]         base::sink(type = "output", split = FALSE)
[17:38:12.866]         if (TRUE) {
[17:38:12.866]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:12.866]         }
[17:38:12.866]         else {
[17:38:12.866]             ...future.result["stdout"] <- base::list(NULL)
[17:38:12.866]         }
[17:38:12.866]         base::close(...future.stdout)
[17:38:12.866]         ...future.stdout <- NULL
[17:38:12.866]     }
[17:38:12.866]     ...future.result$conditions <- ...future.conditions
[17:38:12.866]     ...future.result$finished <- base::Sys.time()
[17:38:12.866]     ...future.result
[17:38:12.866] }
[17:38:12.869] Exporting 11 global objects (95.02 KiB) to cluster node #2 ...
[17:38:12.869] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:38:12.913] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:38:12.913] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[17:38:12.913] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[17:38:12.913] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:38:12.914] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:38:12.914] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:38:12.957] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:38:12.957] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:38:13.001] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:38:13.001] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[17:38:13.001] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[17:38:13.002] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:38:13.002] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:38:13.002] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:13.003] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:13.003] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:38:13.003] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:38:13.003] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:13.004] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:13.004] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:13.004] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:13.004] Exporting 11 global objects (95.02 KiB) to cluster node #2 ... DONE
[17:38:13.005] MultisessionFuture started
[17:38:13.005] - Launch lazy future ... done
[17:38:13.005] run() for ‘MultisessionFuture’ ... done
[17:38:13.005] Created future:
[17:38:13.007] receiveMessageFromWorker() for ClusterFuture ...
[17:38:13.007] - Validating connection of MultisessionFuture
[17:38:13.007] - received message: FutureResult
[17:38:13.007] - Received FutureResult
[17:38:13.007] - Erased future from FutureRegistry
[17:38:13.008] result() for ClusterFuture ...
[17:38:13.008] - result already collected: FutureResult
[17:38:13.008] result() for ClusterFuture ... done
[17:38:13.008] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:13.005] MultisessionFuture:
[17:38:13.005] Label: ‘future_vapply-2’
[17:38:13.005] Expression:
[17:38:13.005] {
[17:38:13.005]     do.call(function(...) {
[17:38:13.005]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.005]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:13.005]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.005]             on.exit(options(oopts), add = TRUE)
[17:38:13.005]         }
[17:38:13.005]         {
[17:38:13.005]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:13.005]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.005]                 ...future.FUN(...future.X_jj, ...)
[17:38:13.005]             })
[17:38:13.005]         }
[17:38:13.005]     }, args = future.call.arguments)
[17:38:13.005] }
[17:38:13.005] Lazy evaluation: FALSE
[17:38:13.005] Asynchronous evaluation: TRUE
[17:38:13.005] Local evaluation: TRUE
[17:38:13.005] Environment: R_GlobalEnv
[17:38:13.005] Capture standard output: TRUE
[17:38:13.005] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:13.005] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:13.005] Packages: 1 packages (‘future.apply’)
[17:38:13.005] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:13.005] Resolved: TRUE
[17:38:13.005] Value: <not collected>
[17:38:13.005] Conditions captured: <none>
[17:38:13.005] Early signaling: FALSE
[17:38:13.005] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:13.005] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:13.008] Chunk #2 of 2 ... DONE
[17:38:13.008] Launching 2 futures (chunks) ... DONE
[17:38:13.008] Resolving 2 futures (chunks) ...
[17:38:13.009] resolve() on list ...
[17:38:13.009]  recursive: 0
[17:38:13.009]  length: 2
[17:38:13.009] 
[17:38:13.009] receiveMessageFromWorker() for ClusterFuture ...
[17:38:13.009] - Validating connection of MultisessionFuture
[17:38:13.010] - received message: FutureResult
[17:38:13.010] - Received FutureResult
[17:38:13.010] - Erased future from FutureRegistry
[17:38:13.010] result() for ClusterFuture ...
[17:38:13.010] - result already collected: FutureResult
[17:38:13.010] result() for ClusterFuture ... done
[17:38:13.010] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:13.010] Future #1
[17:38:13.010] result() for ClusterFuture ...
[17:38:13.010] - result already collected: FutureResult
[17:38:13.010] result() for ClusterFuture ... done
[17:38:13.010] result() for ClusterFuture ...
[17:38:13.011] - result already collected: FutureResult
[17:38:13.011] result() for ClusterFuture ... done
[17:38:13.011] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:13.011] - nx: 2
[17:38:13.011] - relay: TRUE
[17:38:13.011] - stdout: TRUE
[17:38:13.011] - signal: TRUE
[17:38:13.011] - resignal: FALSE
[17:38:13.011] - force: TRUE
[17:38:13.011] - relayed: [n=2] FALSE, FALSE
[17:38:13.011] - queued futures: [n=2] FALSE, FALSE
[17:38:13.012]  - until=1
[17:38:13.012]  - relaying element #1
[17:38:13.012] result() for ClusterFuture ...
[17:38:13.012] - result already collected: FutureResult
[17:38:13.012] result() for ClusterFuture ... done
[17:38:13.012] result() for ClusterFuture ...
[17:38:13.012] - result already collected: FutureResult
[17:38:13.012] result() for ClusterFuture ... done
[17:38:13.012] result() for ClusterFuture ...
[17:38:13.012] - result already collected: FutureResult
[17:38:13.012] result() for ClusterFuture ... done
[17:38:13.013] result() for ClusterFuture ...
[17:38:13.013] - result already collected: FutureResult
[17:38:13.013] result() for ClusterFuture ... done
[17:38:13.013] - relayed: [n=2] TRUE, FALSE
[17:38:13.013] - queued futures: [n=2] TRUE, FALSE
[17:38:13.013] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:13.013]  length: 1 (resolved future 1)
[17:38:13.013] Future #2
[17:38:13.013] result() for ClusterFuture ...
[17:38:13.013] - result already collected: FutureResult
[17:38:13.013] result() for ClusterFuture ... done
[17:38:13.013] result() for ClusterFuture ...
[17:38:13.014] - result already collected: FutureResult
[17:38:13.014] result() for ClusterFuture ... done
[17:38:13.014] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:13.014] - nx: 2
[17:38:13.014] - relay: TRUE
[17:38:13.014] - stdout: TRUE
[17:38:13.014] - signal: TRUE
[17:38:13.014] - resignal: FALSE
[17:38:13.014] - force: TRUE
[17:38:13.014] - relayed: [n=2] TRUE, FALSE
[17:38:13.014] - queued futures: [n=2] TRUE, FALSE
[17:38:13.014]  - until=2
[17:38:13.015]  - relaying element #2
[17:38:13.015] result() for ClusterFuture ...
[17:38:13.015] - result already collected: FutureResult
[17:38:13.015] result() for ClusterFuture ... done
[17:38:13.015] result() for ClusterFuture ...
[17:38:13.015] - result already collected: FutureResult
[17:38:13.015] result() for ClusterFuture ... done
[17:38:13.015] result() for ClusterFuture ...
[17:38:13.015] - result already collected: FutureResult
[17:38:13.015] result() for ClusterFuture ... done
[17:38:13.015] result() for ClusterFuture ...
[17:38:13.015] - result already collected: FutureResult
[17:38:13.016] result() for ClusterFuture ... done
[17:38:13.016] - relayed: [n=2] TRUE, TRUE
[17:38:13.016] - queued futures: [n=2] TRUE, TRUE
[17:38:13.016] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:13.016]  length: 0 (resolved future 2)
[17:38:13.016] Relaying remaining futures
[17:38:13.016] signalConditionsASAP(NULL, pos=0) ...
[17:38:13.016] - nx: 2
[17:38:13.016] - relay: TRUE
[17:38:13.016] - stdout: TRUE
[17:38:13.016] - signal: TRUE
[17:38:13.017] - resignal: FALSE
[17:38:13.017] - force: TRUE
[17:38:13.017] - relayed: [n=2] TRUE, TRUE
[17:38:13.017] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:13.017] - relayed: [n=2] TRUE, TRUE
[17:38:13.017] - queued futures: [n=2] TRUE, TRUE
[17:38:13.017] signalConditionsASAP(NULL, pos=0) ... done
[17:38:13.017] resolve() on list ... DONE
[17:38:13.017] result() for ClusterFuture ...
[17:38:13.017] - result already collected: FutureResult
[17:38:13.017] result() for ClusterFuture ... done
[17:38:13.018] result() for ClusterFuture ...
[17:38:13.018] - result already collected: FutureResult
[17:38:13.018] result() for ClusterFuture ... done
[17:38:13.018] result() for ClusterFuture ...
[17:38:13.018] - result already collected: FutureResult
[17:38:13.018] result() for ClusterFuture ... done
[17:38:13.018] result() for ClusterFuture ...
[17:38:13.018] - result already collected: FutureResult
[17:38:13.018] result() for ClusterFuture ... done
[17:38:13.018]  - Number of value chunks collected: 2
[17:38:13.018] Resolving 2 futures (chunks) ... DONE
[17:38:13.019] Reducing values from 2 chunks ...
[17:38:13.019]  - Number of values collected after concatenation: 10
[17:38:13.019]  - Number of values expected: 10
[17:38:13.019] Reducing values from 2 chunks ... DONE
[17:38:13.019] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[17:38:13.021] future_lapply() ...
[17:38:13.027] Number of chunks: 2
[17:38:13.027] getGlobalsAndPackagesXApply() ...
[17:38:13.027]  - future.globals: TRUE
[17:38:13.027] getGlobalsAndPackages() ...
[17:38:13.027] Searching for globals...
[17:38:13.031] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[17:38:13.031] Searching for globals ... DONE
[17:38:13.031] Resolving globals: FALSE
[17:38:13.032] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[17:38:13.033] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:13.033] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:13.033] - packages: [1] ‘future.apply’
[17:38:13.033] getGlobalsAndPackages() ... DONE
[17:38:13.033]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:13.033]  - needed namespaces: [n=1] ‘future.apply’
[17:38:13.033] Finding globals ... DONE
[17:38:13.033]  - use_args: TRUE
[17:38:13.034]  - Getting '...' globals ...
[17:38:13.034] resolve() on list ...
[17:38:13.034]  recursive: 0
[17:38:13.034]  length: 1
[17:38:13.034]  elements: ‘...’
[17:38:13.037]  length: 0 (resolved future 1)
[17:38:13.037] resolve() on list ... DONE
[17:38:13.037]    - '...' content: [n=0] 
[17:38:13.037] List of 1
[17:38:13.037]  $ ...: list()
[17:38:13.037]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:13.037]  - attr(*, "where")=List of 1
[17:38:13.037]   ..$ ...:<environment: 0x56080426d728> 
[17:38:13.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:13.037]  - attr(*, "resolved")= logi TRUE
[17:38:13.037]  - attr(*, "total_size")= num NA
[17:38:13.040]  - Getting '...' globals ... DONE
[17:38:13.040] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:13.040] List of 8
[17:38:13.040]  $ ...future.FUN:function (x, ...)  
[17:38:13.040]  $ x_FUN        :function (x)  
[17:38:13.040]  $ times        : int 4
[17:38:13.040]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:13.040]  $ stop_if_not  :function (...)  
[17:38:13.040]  $ dim          : int [1:2] 2 2
[17:38:13.040]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:13.040]  $ ...          : list()
[17:38:13.040]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:13.040]  - attr(*, "where")=List of 8
[17:38:13.040]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:13.040]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:13.040]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:13.040]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:13.040]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:13.040]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:13.040]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:13.040]   ..$ ...          :<environment: 0x56080426d728> 
[17:38:13.040]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:13.040]  - attr(*, "resolved")= logi FALSE
[17:38:13.040]  - attr(*, "total_size")= num 105552
[17:38:13.046] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:13.046] getGlobalsAndPackagesXApply() ... DONE
[17:38:13.046] Number of futures (= number of chunks): 2
[17:38:13.046] Launching 2 futures (chunks) ...
[17:38:13.046] Chunk #1 of 2 ...
[17:38:13.046]  - Finding globals in 'X' for chunk #1 ...
[17:38:13.046] getGlobalsAndPackages() ...
[17:38:13.046] Searching for globals...
[17:38:13.047] 
[17:38:13.047] Searching for globals ... DONE
[17:38:13.047] - globals: [0] <none>
[17:38:13.047] getGlobalsAndPackages() ... DONE
[17:38:13.047]    + additional globals found: [n=0] 
[17:38:13.047]    + additional namespaces needed: [n=0] 
[17:38:13.047]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:13.047]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:13.047]  - seeds: <none>
[17:38:13.048]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.048] getGlobalsAndPackages() ...
[17:38:13.048] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.048] Resolving globals: FALSE
[17:38:13.048] Tweak future expression to call with '...' arguments ...
[17:38:13.048] {
[17:38:13.048]     do.call(function(...) {
[17:38:13.048]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.048]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:13.048]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.048]             on.exit(options(oopts), add = TRUE)
[17:38:13.048]         }
[17:38:13.048]         {
[17:38:13.048]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:13.048]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.048]                 ...future.FUN(...future.X_jj, ...)
[17:38:13.048]             })
[17:38:13.048]         }
[17:38:13.048]     }, args = future.call.arguments)
[17:38:13.048] }
[17:38:13.048] Tweak future expression to call with '...' arguments ... DONE
[17:38:13.049] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.049] - packages: [1] ‘future.apply’
[17:38:13.049] getGlobalsAndPackages() ... DONE
[17:38:13.049] run() for ‘Future’ ...
[17:38:13.050] - state: ‘created’
[17:38:13.050] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:13.064] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:13.064] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:13.065]   - Field: ‘node’
[17:38:13.065]   - Field: ‘label’
[17:38:13.065]   - Field: ‘local’
[17:38:13.065]   - Field: ‘owner’
[17:38:13.065]   - Field: ‘envir’
[17:38:13.065]   - Field: ‘workers’
[17:38:13.065]   - Field: ‘packages’
[17:38:13.065]   - Field: ‘gc’
[17:38:13.065]   - Field: ‘conditions’
[17:38:13.065]   - Field: ‘persistent’
[17:38:13.066]   - Field: ‘expr’
[17:38:13.066]   - Field: ‘uuid’
[17:38:13.066]   - Field: ‘seed’
[17:38:13.066]   - Field: ‘version’
[17:38:13.066]   - Field: ‘result’
[17:38:13.066]   - Field: ‘asynchronous’
[17:38:13.066]   - Field: ‘calls’
[17:38:13.066]   - Field: ‘globals’
[17:38:13.066]   - Field: ‘stdout’
[17:38:13.066]   - Field: ‘earlySignal’
[17:38:13.067]   - Field: ‘lazy’
[17:38:13.067]   - Field: ‘state’
[17:38:13.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:13.067] - Launch lazy future ...
[17:38:13.067] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:13.067] Packages needed by future strategies (n = 0): <none>
[17:38:13.068] {
[17:38:13.068]     {
[17:38:13.068]         {
[17:38:13.068]             ...future.startTime <- base::Sys.time()
[17:38:13.068]             {
[17:38:13.068]                 {
[17:38:13.068]                   {
[17:38:13.068]                     {
[17:38:13.068]                       {
[17:38:13.068]                         base::local({
[17:38:13.068]                           has_future <- base::requireNamespace("future", 
[17:38:13.068]                             quietly = TRUE)
[17:38:13.068]                           if (has_future) {
[17:38:13.068]                             ns <- base::getNamespace("future")
[17:38:13.068]                             version <- ns[[".package"]][["version"]]
[17:38:13.068]                             if (is.null(version)) 
[17:38:13.068]                               version <- utils::packageVersion("future")
[17:38:13.068]                           }
[17:38:13.068]                           else {
[17:38:13.068]                             version <- NULL
[17:38:13.068]                           }
[17:38:13.068]                           if (!has_future || version < "1.8.0") {
[17:38:13.068]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:13.068]                               "", base::R.version$version.string), 
[17:38:13.068]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:13.068]                                 base::R.version$platform, 8 * 
[17:38:13.068]                                   base::.Machine$sizeof.pointer), 
[17:38:13.068]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:13.068]                                 "release", "version")], collapse = " "), 
[17:38:13.068]                               hostname = base::Sys.info()[["nodename"]])
[17:38:13.068]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:13.068]                               info)
[17:38:13.068]                             info <- base::paste(info, collapse = "; ")
[17:38:13.068]                             if (!has_future) {
[17:38:13.068]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:13.068]                                 info)
[17:38:13.068]                             }
[17:38:13.068]                             else {
[17:38:13.068]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:13.068]                                 info, version)
[17:38:13.068]                             }
[17:38:13.068]                             base::stop(msg)
[17:38:13.068]                           }
[17:38:13.068]                         })
[17:38:13.068]                       }
[17:38:13.068]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:13.068]                       base::options(mc.cores = 1L)
[17:38:13.068]                     }
[17:38:13.068]                     base::local({
[17:38:13.068]                       for (pkg in "future.apply") {
[17:38:13.068]                         base::loadNamespace(pkg)
[17:38:13.068]                         base::library(pkg, character.only = TRUE)
[17:38:13.068]                       }
[17:38:13.068]                     })
[17:38:13.068]                   }
[17:38:13.068]                   ...future.strategy.old <- future::plan("list")
[17:38:13.068]                   options(future.plan = NULL)
[17:38:13.068]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:13.068]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:13.068]                 }
[17:38:13.068]                 ...future.workdir <- getwd()
[17:38:13.068]             }
[17:38:13.068]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:13.068]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:13.068]         }
[17:38:13.068]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:13.068]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:13.068]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:13.068]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:13.068]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:13.068]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:13.068]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:13.068]             base::names(...future.oldOptions))
[17:38:13.068]     }
[17:38:13.068]     if (FALSE) {
[17:38:13.068]     }
[17:38:13.068]     else {
[17:38:13.068]         if (TRUE) {
[17:38:13.068]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:13.068]                 open = "w")
[17:38:13.068]         }
[17:38:13.068]         else {
[17:38:13.068]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:13.068]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:13.068]         }
[17:38:13.068]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:13.068]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:13.068]             base::sink(type = "output", split = FALSE)
[17:38:13.068]             base::close(...future.stdout)
[17:38:13.068]         }, add = TRUE)
[17:38:13.068]     }
[17:38:13.068]     ...future.frame <- base::sys.nframe()
[17:38:13.068]     ...future.conditions <- base::list()
[17:38:13.068]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:13.068]     if (FALSE) {
[17:38:13.068]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:13.068]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:13.068]     }
[17:38:13.068]     ...future.result <- base::tryCatch({
[17:38:13.068]         base::withCallingHandlers({
[17:38:13.068]             ...future.value <- base::withVisible(base::local({
[17:38:13.068]                 ...future.makeSendCondition <- base::local({
[17:38:13.068]                   sendCondition <- NULL
[17:38:13.068]                   function(frame = 1L) {
[17:38:13.068]                     if (is.function(sendCondition)) 
[17:38:13.068]                       return(sendCondition)
[17:38:13.068]                     ns <- getNamespace("parallel")
[17:38:13.068]                     if (exists("sendData", mode = "function", 
[17:38:13.068]                       envir = ns)) {
[17:38:13.068]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:13.068]                         envir = ns)
[17:38:13.068]                       envir <- sys.frame(frame)
[17:38:13.068]                       master <- NULL
[17:38:13.068]                       while (!identical(envir, .GlobalEnv) && 
[17:38:13.068]                         !identical(envir, emptyenv())) {
[17:38:13.068]                         if (exists("master", mode = "list", envir = envir, 
[17:38:13.068]                           inherits = FALSE)) {
[17:38:13.068]                           master <- get("master", mode = "list", 
[17:38:13.068]                             envir = envir, inherits = FALSE)
[17:38:13.068]                           if (inherits(master, c("SOCKnode", 
[17:38:13.068]                             "SOCK0node"))) {
[17:38:13.068]                             sendCondition <<- function(cond) {
[17:38:13.068]                               data <- list(type = "VALUE", value = cond, 
[17:38:13.068]                                 success = TRUE)
[17:38:13.068]                               parallel_sendData(master, data)
[17:38:13.068]                             }
[17:38:13.068]                             return(sendCondition)
[17:38:13.068]                           }
[17:38:13.068]                         }
[17:38:13.068]                         frame <- frame + 1L
[17:38:13.068]                         envir <- sys.frame(frame)
[17:38:13.068]                       }
[17:38:13.068]                     }
[17:38:13.068]                     sendCondition <<- function(cond) NULL
[17:38:13.068]                   }
[17:38:13.068]                 })
[17:38:13.068]                 withCallingHandlers({
[17:38:13.068]                   {
[17:38:13.068]                     do.call(function(...) {
[17:38:13.068]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.068]                       if (!identical(...future.globals.maxSize.org, 
[17:38:13.068]                         ...future.globals.maxSize)) {
[17:38:13.068]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.068]                         on.exit(options(oopts), add = TRUE)
[17:38:13.068]                       }
[17:38:13.068]                       {
[17:38:13.068]                         lapply(seq_along(...future.elements_ii), 
[17:38:13.068]                           FUN = function(jj) {
[17:38:13.068]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.068]                             ...future.FUN(...future.X_jj, ...)
[17:38:13.068]                           })
[17:38:13.068]                       }
[17:38:13.068]                     }, args = future.call.arguments)
[17:38:13.068]                   }
[17:38:13.068]                 }, immediateCondition = function(cond) {
[17:38:13.068]                   sendCondition <- ...future.makeSendCondition()
[17:38:13.068]                   sendCondition(cond)
[17:38:13.068]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.068]                   {
[17:38:13.068]                     inherits <- base::inherits
[17:38:13.068]                     invokeRestart <- base::invokeRestart
[17:38:13.068]                     is.null <- base::is.null
[17:38:13.068]                     muffled <- FALSE
[17:38:13.068]                     if (inherits(cond, "message")) {
[17:38:13.068]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:13.068]                       if (muffled) 
[17:38:13.068]                         invokeRestart("muffleMessage")
[17:38:13.068]                     }
[17:38:13.068]                     else if (inherits(cond, "warning")) {
[17:38:13.068]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:13.068]                       if (muffled) 
[17:38:13.068]                         invokeRestart("muffleWarning")
[17:38:13.068]                     }
[17:38:13.068]                     else if (inherits(cond, "condition")) {
[17:38:13.068]                       if (!is.null(pattern)) {
[17:38:13.068]                         computeRestarts <- base::computeRestarts
[17:38:13.068]                         grepl <- base::grepl
[17:38:13.068]                         restarts <- computeRestarts(cond)
[17:38:13.068]                         for (restart in restarts) {
[17:38:13.068]                           name <- restart$name
[17:38:13.068]                           if (is.null(name)) 
[17:38:13.068]                             next
[17:38:13.068]                           if (!grepl(pattern, name)) 
[17:38:13.068]                             next
[17:38:13.068]                           invokeRestart(restart)
[17:38:13.068]                           muffled <- TRUE
[17:38:13.068]                           break
[17:38:13.068]                         }
[17:38:13.068]                       }
[17:38:13.068]                     }
[17:38:13.068]                     invisible(muffled)
[17:38:13.068]                   }
[17:38:13.068]                   muffleCondition(cond)
[17:38:13.068]                 })
[17:38:13.068]             }))
[17:38:13.068]             future::FutureResult(value = ...future.value$value, 
[17:38:13.068]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:13.068]                   ...future.rng), globalenv = if (FALSE) 
[17:38:13.068]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:13.068]                     ...future.globalenv.names))
[17:38:13.068]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:13.068]         }, condition = base::local({
[17:38:13.068]             c <- base::c
[17:38:13.068]             inherits <- base::inherits
[17:38:13.068]             invokeRestart <- base::invokeRestart
[17:38:13.068]             length <- base::length
[17:38:13.068]             list <- base::list
[17:38:13.068]             seq.int <- base::seq.int
[17:38:13.068]             signalCondition <- base::signalCondition
[17:38:13.068]             sys.calls <- base::sys.calls
[17:38:13.068]             `[[` <- base::`[[`
[17:38:13.068]             `+` <- base::`+`
[17:38:13.068]             `<<-` <- base::`<<-`
[17:38:13.068]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:13.068]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:13.068]                   3L)]
[17:38:13.068]             }
[17:38:13.068]             function(cond) {
[17:38:13.068]                 is_error <- inherits(cond, "error")
[17:38:13.068]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:13.068]                   NULL)
[17:38:13.068]                 if (is_error) {
[17:38:13.068]                   sessionInformation <- function() {
[17:38:13.068]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:13.068]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:13.068]                       search = base::search(), system = base::Sys.info())
[17:38:13.068]                   }
[17:38:13.068]                   ...future.conditions[[length(...future.conditions) + 
[17:38:13.068]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:13.068]                     cond$call), session = sessionInformation(), 
[17:38:13.068]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:13.068]                   signalCondition(cond)
[17:38:13.068]                 }
[17:38:13.068]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:13.068]                 "immediateCondition"))) {
[17:38:13.068]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:13.068]                   ...future.conditions[[length(...future.conditions) + 
[17:38:13.068]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:13.068]                   if (TRUE && !signal) {
[17:38:13.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.068]                     {
[17:38:13.068]                       inherits <- base::inherits
[17:38:13.068]                       invokeRestart <- base::invokeRestart
[17:38:13.068]                       is.null <- base::is.null
[17:38:13.068]                       muffled <- FALSE
[17:38:13.068]                       if (inherits(cond, "message")) {
[17:38:13.068]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:13.068]                         if (muffled) 
[17:38:13.068]                           invokeRestart("muffleMessage")
[17:38:13.068]                       }
[17:38:13.068]                       else if (inherits(cond, "warning")) {
[17:38:13.068]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:13.068]                         if (muffled) 
[17:38:13.068]                           invokeRestart("muffleWarning")
[17:38:13.068]                       }
[17:38:13.068]                       else if (inherits(cond, "condition")) {
[17:38:13.068]                         if (!is.null(pattern)) {
[17:38:13.068]                           computeRestarts <- base::computeRestarts
[17:38:13.068]                           grepl <- base::grepl
[17:38:13.068]                           restarts <- computeRestarts(cond)
[17:38:13.068]                           for (restart in restarts) {
[17:38:13.068]                             name <- restart$name
[17:38:13.068]                             if (is.null(name)) 
[17:38:13.068]                               next
[17:38:13.068]                             if (!grepl(pattern, name)) 
[17:38:13.068]                               next
[17:38:13.068]                             invokeRestart(restart)
[17:38:13.068]                             muffled <- TRUE
[17:38:13.068]                             break
[17:38:13.068]                           }
[17:38:13.068]                         }
[17:38:13.068]                       }
[17:38:13.068]                       invisible(muffled)
[17:38:13.068]                     }
[17:38:13.068]                     muffleCondition(cond, pattern = "^muffle")
[17:38:13.068]                   }
[17:38:13.068]                 }
[17:38:13.068]                 else {
[17:38:13.068]                   if (TRUE) {
[17:38:13.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.068]                     {
[17:38:13.068]                       inherits <- base::inherits
[17:38:13.068]                       invokeRestart <- base::invokeRestart
[17:38:13.068]                       is.null <- base::is.null
[17:38:13.068]                       muffled <- FALSE
[17:38:13.068]                       if (inherits(cond, "message")) {
[17:38:13.068]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:13.068]                         if (muffled) 
[17:38:13.068]                           invokeRestart("muffleMessage")
[17:38:13.068]                       }
[17:38:13.068]                       else if (inherits(cond, "warning")) {
[17:38:13.068]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:13.068]                         if (muffled) 
[17:38:13.068]                           invokeRestart("muffleWarning")
[17:38:13.068]                       }
[17:38:13.068]                       else if (inherits(cond, "condition")) {
[17:38:13.068]                         if (!is.null(pattern)) {
[17:38:13.068]                           computeRestarts <- base::computeRestarts
[17:38:13.068]                           grepl <- base::grepl
[17:38:13.068]                           restarts <- computeRestarts(cond)
[17:38:13.068]                           for (restart in restarts) {
[17:38:13.068]                             name <- restart$name
[17:38:13.068]                             if (is.null(name)) 
[17:38:13.068]                               next
[17:38:13.068]                             if (!grepl(pattern, name)) 
[17:38:13.068]                               next
[17:38:13.068]                             invokeRestart(restart)
[17:38:13.068]                             muffled <- TRUE
[17:38:13.068]                             break
[17:38:13.068]                           }
[17:38:13.068]                         }
[17:38:13.068]                       }
[17:38:13.068]                       invisible(muffled)
[17:38:13.068]                     }
[17:38:13.068]                     muffleCondition(cond, pattern = "^muffle")
[17:38:13.068]                   }
[17:38:13.068]                 }
[17:38:13.068]             }
[17:38:13.068]         }))
[17:38:13.068]     }, error = function(ex) {
[17:38:13.068]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:13.068]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:13.068]                 ...future.rng), started = ...future.startTime, 
[17:38:13.068]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:13.068]             version = "1.8"), class = "FutureResult")
[17:38:13.068]     }, finally = {
[17:38:13.068]         if (!identical(...future.workdir, getwd())) 
[17:38:13.068]             setwd(...future.workdir)
[17:38:13.068]         {
[17:38:13.068]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:13.068]                 ...future.oldOptions$nwarnings <- NULL
[17:38:13.068]             }
[17:38:13.068]             base::options(...future.oldOptions)
[17:38:13.068]             if (.Platform$OS.type == "windows") {
[17:38:13.068]                 old_names <- names(...future.oldEnvVars)
[17:38:13.068]                 envs <- base::Sys.getenv()
[17:38:13.068]                 names <- names(envs)
[17:38:13.068]                 common <- intersect(names, old_names)
[17:38:13.068]                 added <- setdiff(names, old_names)
[17:38:13.068]                 removed <- setdiff(old_names, names)
[17:38:13.068]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:13.068]                   envs[common]]
[17:38:13.068]                 NAMES <- toupper(changed)
[17:38:13.068]                 args <- list()
[17:38:13.068]                 for (kk in seq_along(NAMES)) {
[17:38:13.068]                   name <- changed[[kk]]
[17:38:13.068]                   NAME <- NAMES[[kk]]
[17:38:13.068]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.068]                     next
[17:38:13.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:13.068]                 }
[17:38:13.068]                 NAMES <- toupper(added)
[17:38:13.068]                 for (kk in seq_along(NAMES)) {
[17:38:13.068]                   name <- added[[kk]]
[17:38:13.068]                   NAME <- NAMES[[kk]]
[17:38:13.068]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.068]                     next
[17:38:13.068]                   args[[name]] <- ""
[17:38:13.068]                 }
[17:38:13.068]                 NAMES <- toupper(removed)
[17:38:13.068]                 for (kk in seq_along(NAMES)) {
[17:38:13.068]                   name <- removed[[kk]]
[17:38:13.068]                   NAME <- NAMES[[kk]]
[17:38:13.068]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.068]                     next
[17:38:13.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:13.068]                 }
[17:38:13.068]                 if (length(args) > 0) 
[17:38:13.068]                   base::do.call(base::Sys.setenv, args = args)
[17:38:13.068]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:13.068]             }
[17:38:13.068]             else {
[17:38:13.068]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:13.068]             }
[17:38:13.068]             {
[17:38:13.068]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:13.068]                   0L) {
[17:38:13.068]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:13.068]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:13.068]                   base::options(opts)
[17:38:13.068]                 }
[17:38:13.068]                 {
[17:38:13.068]                   {
[17:38:13.068]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:13.068]                     NULL
[17:38:13.068]                   }
[17:38:13.068]                   options(future.plan = NULL)
[17:38:13.068]                   if (is.na(NA_character_)) 
[17:38:13.068]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:13.068]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:13.068]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:13.068]                     .init = FALSE)
[17:38:13.068]                 }
[17:38:13.068]             }
[17:38:13.068]         }
[17:38:13.068]     })
[17:38:13.068]     if (TRUE) {
[17:38:13.068]         base::sink(type = "output", split = FALSE)
[17:38:13.068]         if (TRUE) {
[17:38:13.068]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:13.068]         }
[17:38:13.068]         else {
[17:38:13.068]             ...future.result["stdout"] <- base::list(NULL)
[17:38:13.068]         }
[17:38:13.068]         base::close(...future.stdout)
[17:38:13.068]         ...future.stdout <- NULL
[17:38:13.068]     }
[17:38:13.068]     ...future.result$conditions <- ...future.conditions
[17:38:13.068]     ...future.result$finished <- base::Sys.time()
[17:38:13.068]     ...future.result
[17:38:13.068] }
[17:38:13.071] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[17:38:13.071] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:38:13.113] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:38:13.113] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[17:38:13.113] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[17:38:13.114] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:38:13.114] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:38:13.114] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:38:13.157] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:38:13.157] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:38:13.201] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:38:13.201] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:38:13.202] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:38:13.202] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:38:13.202] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:38:13.202] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:13.203] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:13.203] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:38:13.203] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:38:13.203] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:13.204] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:13.204] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:13.204] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:13.204] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[17:38:13.205] MultisessionFuture started
[17:38:13.205] - Launch lazy future ... done
[17:38:13.205] run() for ‘MultisessionFuture’ ... done
[17:38:13.206] Created future:
[17:38:13.206] MultisessionFuture:
[17:38:13.206] Label: ‘future_vapply-1’
[17:38:13.206] Expression:
[17:38:13.206] {
[17:38:13.206]     do.call(function(...) {
[17:38:13.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:13.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.206]             on.exit(options(oopts), add = TRUE)
[17:38:13.206]         }
[17:38:13.206]         {
[17:38:13.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:13.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.206]                 ...future.FUN(...future.X_jj, ...)
[17:38:13.206]             })
[17:38:13.206]         }
[17:38:13.206]     }, args = future.call.arguments)
[17:38:13.206] }
[17:38:13.206] Lazy evaluation: FALSE
[17:38:13.206] Asynchronous evaluation: TRUE
[17:38:13.206] Local evaluation: TRUE
[17:38:13.206] Environment: R_GlobalEnv
[17:38:13.206] Capture standard output: TRUE
[17:38:13.206] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:13.206] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:13.206] Packages: 1 packages (‘future.apply’)
[17:38:13.206] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:13.206] Resolved: FALSE
[17:38:13.206] Value: <not collected>
[17:38:13.206] Conditions captured: <none>
[17:38:13.206] Early signaling: FALSE
[17:38:13.206] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:13.206] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:13.217] Chunk #1 of 2 ... DONE
[17:38:13.217] Chunk #2 of 2 ...
[17:38:13.218]  - Finding globals in 'X' for chunk #2 ...
[17:38:13.218] getGlobalsAndPackages() ...
[17:38:13.218] Searching for globals...
[17:38:13.218] 
[17:38:13.218] Searching for globals ... DONE
[17:38:13.218] - globals: [0] <none>
[17:38:13.218] getGlobalsAndPackages() ... DONE
[17:38:13.218]    + additional globals found: [n=0] 
[17:38:13.219]    + additional namespaces needed: [n=0] 
[17:38:13.219]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:13.219]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:13.219]  - seeds: <none>
[17:38:13.219]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.219] getGlobalsAndPackages() ...
[17:38:13.219] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.219] Resolving globals: FALSE
[17:38:13.219] Tweak future expression to call with '...' arguments ...
[17:38:13.219] {
[17:38:13.219]     do.call(function(...) {
[17:38:13.219]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.219]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:13.219]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.219]             on.exit(options(oopts), add = TRUE)
[17:38:13.219]         }
[17:38:13.219]         {
[17:38:13.219]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:13.219]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.219]                 ...future.FUN(...future.X_jj, ...)
[17:38:13.219]             })
[17:38:13.219]         }
[17:38:13.219]     }, args = future.call.arguments)
[17:38:13.219] }
[17:38:13.220] Tweak future expression to call with '...' arguments ... DONE
[17:38:13.220] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.220] - packages: [1] ‘future.apply’
[17:38:13.220] getGlobalsAndPackages() ... DONE
[17:38:13.221] run() for ‘Future’ ...
[17:38:13.221] - state: ‘created’
[17:38:13.221] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:13.236] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:13.236] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:13.236]   - Field: ‘node’
[17:38:13.236]   - Field: ‘label’
[17:38:13.236]   - Field: ‘local’
[17:38:13.236]   - Field: ‘owner’
[17:38:13.236]   - Field: ‘envir’
[17:38:13.236]   - Field: ‘workers’
[17:38:13.236]   - Field: ‘packages’
[17:38:13.237]   - Field: ‘gc’
[17:38:13.237]   - Field: ‘conditions’
[17:38:13.237]   - Field: ‘persistent’
[17:38:13.237]   - Field: ‘expr’
[17:38:13.237]   - Field: ‘uuid’
[17:38:13.237]   - Field: ‘seed’
[17:38:13.237]   - Field: ‘version’
[17:38:13.237]   - Field: ‘result’
[17:38:13.237]   - Field: ‘asynchronous’
[17:38:13.237]   - Field: ‘calls’
[17:38:13.238]   - Field: ‘globals’
[17:38:13.238]   - Field: ‘stdout’
[17:38:13.238]   - Field: ‘earlySignal’
[17:38:13.238]   - Field: ‘lazy’
[17:38:13.238]   - Field: ‘state’
[17:38:13.238] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:13.238] - Launch lazy future ...
[17:38:13.238] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:13.238] Packages needed by future strategies (n = 0): <none>
[17:38:13.239] {
[17:38:13.239]     {
[17:38:13.239]         {
[17:38:13.239]             ...future.startTime <- base::Sys.time()
[17:38:13.239]             {
[17:38:13.239]                 {
[17:38:13.239]                   {
[17:38:13.239]                     {
[17:38:13.239]                       {
[17:38:13.239]                         base::local({
[17:38:13.239]                           has_future <- base::requireNamespace("future", 
[17:38:13.239]                             quietly = TRUE)
[17:38:13.239]                           if (has_future) {
[17:38:13.239]                             ns <- base::getNamespace("future")
[17:38:13.239]                             version <- ns[[".package"]][["version"]]
[17:38:13.239]                             if (is.null(version)) 
[17:38:13.239]                               version <- utils::packageVersion("future")
[17:38:13.239]                           }
[17:38:13.239]                           else {
[17:38:13.239]                             version <- NULL
[17:38:13.239]                           }
[17:38:13.239]                           if (!has_future || version < "1.8.0") {
[17:38:13.239]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:13.239]                               "", base::R.version$version.string), 
[17:38:13.239]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:13.239]                                 base::R.version$platform, 8 * 
[17:38:13.239]                                   base::.Machine$sizeof.pointer), 
[17:38:13.239]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:13.239]                                 "release", "version")], collapse = " "), 
[17:38:13.239]                               hostname = base::Sys.info()[["nodename"]])
[17:38:13.239]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:13.239]                               info)
[17:38:13.239]                             info <- base::paste(info, collapse = "; ")
[17:38:13.239]                             if (!has_future) {
[17:38:13.239]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:13.239]                                 info)
[17:38:13.239]                             }
[17:38:13.239]                             else {
[17:38:13.239]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:13.239]                                 info, version)
[17:38:13.239]                             }
[17:38:13.239]                             base::stop(msg)
[17:38:13.239]                           }
[17:38:13.239]                         })
[17:38:13.239]                       }
[17:38:13.239]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:13.239]                       base::options(mc.cores = 1L)
[17:38:13.239]                     }
[17:38:13.239]                     base::local({
[17:38:13.239]                       for (pkg in "future.apply") {
[17:38:13.239]                         base::loadNamespace(pkg)
[17:38:13.239]                         base::library(pkg, character.only = TRUE)
[17:38:13.239]                       }
[17:38:13.239]                     })
[17:38:13.239]                   }
[17:38:13.239]                   ...future.strategy.old <- future::plan("list")
[17:38:13.239]                   options(future.plan = NULL)
[17:38:13.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:13.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:13.239]                 }
[17:38:13.239]                 ...future.workdir <- getwd()
[17:38:13.239]             }
[17:38:13.239]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:13.239]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:13.239]         }
[17:38:13.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:13.239]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:13.239]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:13.239]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:13.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:13.239]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:13.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:13.239]             base::names(...future.oldOptions))
[17:38:13.239]     }
[17:38:13.239]     if (FALSE) {
[17:38:13.239]     }
[17:38:13.239]     else {
[17:38:13.239]         if (TRUE) {
[17:38:13.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:13.239]                 open = "w")
[17:38:13.239]         }
[17:38:13.239]         else {
[17:38:13.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:13.239]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:13.239]         }
[17:38:13.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:13.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:13.239]             base::sink(type = "output", split = FALSE)
[17:38:13.239]             base::close(...future.stdout)
[17:38:13.239]         }, add = TRUE)
[17:38:13.239]     }
[17:38:13.239]     ...future.frame <- base::sys.nframe()
[17:38:13.239]     ...future.conditions <- base::list()
[17:38:13.239]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:13.239]     if (FALSE) {
[17:38:13.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:13.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:13.239]     }
[17:38:13.239]     ...future.result <- base::tryCatch({
[17:38:13.239]         base::withCallingHandlers({
[17:38:13.239]             ...future.value <- base::withVisible(base::local({
[17:38:13.239]                 ...future.makeSendCondition <- base::local({
[17:38:13.239]                   sendCondition <- NULL
[17:38:13.239]                   function(frame = 1L) {
[17:38:13.239]                     if (is.function(sendCondition)) 
[17:38:13.239]                       return(sendCondition)
[17:38:13.239]                     ns <- getNamespace("parallel")
[17:38:13.239]                     if (exists("sendData", mode = "function", 
[17:38:13.239]                       envir = ns)) {
[17:38:13.239]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:13.239]                         envir = ns)
[17:38:13.239]                       envir <- sys.frame(frame)
[17:38:13.239]                       master <- NULL
[17:38:13.239]                       while (!identical(envir, .GlobalEnv) && 
[17:38:13.239]                         !identical(envir, emptyenv())) {
[17:38:13.239]                         if (exists("master", mode = "list", envir = envir, 
[17:38:13.239]                           inherits = FALSE)) {
[17:38:13.239]                           master <- get("master", mode = "list", 
[17:38:13.239]                             envir = envir, inherits = FALSE)
[17:38:13.239]                           if (inherits(master, c("SOCKnode", 
[17:38:13.239]                             "SOCK0node"))) {
[17:38:13.239]                             sendCondition <<- function(cond) {
[17:38:13.239]                               data <- list(type = "VALUE", value = cond, 
[17:38:13.239]                                 success = TRUE)
[17:38:13.239]                               parallel_sendData(master, data)
[17:38:13.239]                             }
[17:38:13.239]                             return(sendCondition)
[17:38:13.239]                           }
[17:38:13.239]                         }
[17:38:13.239]                         frame <- frame + 1L
[17:38:13.239]                         envir <- sys.frame(frame)
[17:38:13.239]                       }
[17:38:13.239]                     }
[17:38:13.239]                     sendCondition <<- function(cond) NULL
[17:38:13.239]                   }
[17:38:13.239]                 })
[17:38:13.239]                 withCallingHandlers({
[17:38:13.239]                   {
[17:38:13.239]                     do.call(function(...) {
[17:38:13.239]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.239]                       if (!identical(...future.globals.maxSize.org, 
[17:38:13.239]                         ...future.globals.maxSize)) {
[17:38:13.239]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.239]                         on.exit(options(oopts), add = TRUE)
[17:38:13.239]                       }
[17:38:13.239]                       {
[17:38:13.239]                         lapply(seq_along(...future.elements_ii), 
[17:38:13.239]                           FUN = function(jj) {
[17:38:13.239]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.239]                             ...future.FUN(...future.X_jj, ...)
[17:38:13.239]                           })
[17:38:13.239]                       }
[17:38:13.239]                     }, args = future.call.arguments)
[17:38:13.239]                   }
[17:38:13.239]                 }, immediateCondition = function(cond) {
[17:38:13.239]                   sendCondition <- ...future.makeSendCondition()
[17:38:13.239]                   sendCondition(cond)
[17:38:13.239]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.239]                   {
[17:38:13.239]                     inherits <- base::inherits
[17:38:13.239]                     invokeRestart <- base::invokeRestart
[17:38:13.239]                     is.null <- base::is.null
[17:38:13.239]                     muffled <- FALSE
[17:38:13.239]                     if (inherits(cond, "message")) {
[17:38:13.239]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:13.239]                       if (muffled) 
[17:38:13.239]                         invokeRestart("muffleMessage")
[17:38:13.239]                     }
[17:38:13.239]                     else if (inherits(cond, "warning")) {
[17:38:13.239]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:13.239]                       if (muffled) 
[17:38:13.239]                         invokeRestart("muffleWarning")
[17:38:13.239]                     }
[17:38:13.239]                     else if (inherits(cond, "condition")) {
[17:38:13.239]                       if (!is.null(pattern)) {
[17:38:13.239]                         computeRestarts <- base::computeRestarts
[17:38:13.239]                         grepl <- base::grepl
[17:38:13.239]                         restarts <- computeRestarts(cond)
[17:38:13.239]                         for (restart in restarts) {
[17:38:13.239]                           name <- restart$name
[17:38:13.239]                           if (is.null(name)) 
[17:38:13.239]                             next
[17:38:13.239]                           if (!grepl(pattern, name)) 
[17:38:13.239]                             next
[17:38:13.239]                           invokeRestart(restart)
[17:38:13.239]                           muffled <- TRUE
[17:38:13.239]                           break
[17:38:13.239]                         }
[17:38:13.239]                       }
[17:38:13.239]                     }
[17:38:13.239]                     invisible(muffled)
[17:38:13.239]                   }
[17:38:13.239]                   muffleCondition(cond)
[17:38:13.239]                 })
[17:38:13.239]             }))
[17:38:13.239]             future::FutureResult(value = ...future.value$value, 
[17:38:13.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:13.239]                   ...future.rng), globalenv = if (FALSE) 
[17:38:13.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:13.239]                     ...future.globalenv.names))
[17:38:13.239]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:13.239]         }, condition = base::local({
[17:38:13.239]             c <- base::c
[17:38:13.239]             inherits <- base::inherits
[17:38:13.239]             invokeRestart <- base::invokeRestart
[17:38:13.239]             length <- base::length
[17:38:13.239]             list <- base::list
[17:38:13.239]             seq.int <- base::seq.int
[17:38:13.239]             signalCondition <- base::signalCondition
[17:38:13.239]             sys.calls <- base::sys.calls
[17:38:13.239]             `[[` <- base::`[[`
[17:38:13.239]             `+` <- base::`+`
[17:38:13.239]             `<<-` <- base::`<<-`
[17:38:13.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:13.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:13.239]                   3L)]
[17:38:13.239]             }
[17:38:13.239]             function(cond) {
[17:38:13.239]                 is_error <- inherits(cond, "error")
[17:38:13.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:13.239]                   NULL)
[17:38:13.239]                 if (is_error) {
[17:38:13.239]                   sessionInformation <- function() {
[17:38:13.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:13.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:13.239]                       search = base::search(), system = base::Sys.info())
[17:38:13.239]                   }
[17:38:13.239]                   ...future.conditions[[length(...future.conditions) + 
[17:38:13.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:13.239]                     cond$call), session = sessionInformation(), 
[17:38:13.239]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:13.239]                   signalCondition(cond)
[17:38:13.239]                 }
[17:38:13.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:13.239]                 "immediateCondition"))) {
[17:38:13.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:13.239]                   ...future.conditions[[length(...future.conditions) + 
[17:38:13.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:13.239]                   if (TRUE && !signal) {
[17:38:13.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.239]                     {
[17:38:13.239]                       inherits <- base::inherits
[17:38:13.239]                       invokeRestart <- base::invokeRestart
[17:38:13.239]                       is.null <- base::is.null
[17:38:13.239]                       muffled <- FALSE
[17:38:13.239]                       if (inherits(cond, "message")) {
[17:38:13.239]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:13.239]                         if (muffled) 
[17:38:13.239]                           invokeRestart("muffleMessage")
[17:38:13.239]                       }
[17:38:13.239]                       else if (inherits(cond, "warning")) {
[17:38:13.239]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:13.239]                         if (muffled) 
[17:38:13.239]                           invokeRestart("muffleWarning")
[17:38:13.239]                       }
[17:38:13.239]                       else if (inherits(cond, "condition")) {
[17:38:13.239]                         if (!is.null(pattern)) {
[17:38:13.239]                           computeRestarts <- base::computeRestarts
[17:38:13.239]                           grepl <- base::grepl
[17:38:13.239]                           restarts <- computeRestarts(cond)
[17:38:13.239]                           for (restart in restarts) {
[17:38:13.239]                             name <- restart$name
[17:38:13.239]                             if (is.null(name)) 
[17:38:13.239]                               next
[17:38:13.239]                             if (!grepl(pattern, name)) 
[17:38:13.239]                               next
[17:38:13.239]                             invokeRestart(restart)
[17:38:13.239]                             muffled <- TRUE
[17:38:13.239]                             break
[17:38:13.239]                           }
[17:38:13.239]                         }
[17:38:13.239]                       }
[17:38:13.239]                       invisible(muffled)
[17:38:13.239]                     }
[17:38:13.239]                     muffleCondition(cond, pattern = "^muffle")
[17:38:13.239]                   }
[17:38:13.239]                 }
[17:38:13.239]                 else {
[17:38:13.239]                   if (TRUE) {
[17:38:13.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.239]                     {
[17:38:13.239]                       inherits <- base::inherits
[17:38:13.239]                       invokeRestart <- base::invokeRestart
[17:38:13.239]                       is.null <- base::is.null
[17:38:13.239]                       muffled <- FALSE
[17:38:13.239]                       if (inherits(cond, "message")) {
[17:38:13.239]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:13.239]                         if (muffled) 
[17:38:13.239]                           invokeRestart("muffleMessage")
[17:38:13.239]                       }
[17:38:13.239]                       else if (inherits(cond, "warning")) {
[17:38:13.239]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:13.239]                         if (muffled) 
[17:38:13.239]                           invokeRestart("muffleWarning")
[17:38:13.239]                       }
[17:38:13.239]                       else if (inherits(cond, "condition")) {
[17:38:13.239]                         if (!is.null(pattern)) {
[17:38:13.239]                           computeRestarts <- base::computeRestarts
[17:38:13.239]                           grepl <- base::grepl
[17:38:13.239]                           restarts <- computeRestarts(cond)
[17:38:13.239]                           for (restart in restarts) {
[17:38:13.239]                             name <- restart$name
[17:38:13.239]                             if (is.null(name)) 
[17:38:13.239]                               next
[17:38:13.239]                             if (!grepl(pattern, name)) 
[17:38:13.239]                               next
[17:38:13.239]                             invokeRestart(restart)
[17:38:13.239]                             muffled <- TRUE
[17:38:13.239]                             break
[17:38:13.239]                           }
[17:38:13.239]                         }
[17:38:13.239]                       }
[17:38:13.239]                       invisible(muffled)
[17:38:13.239]                     }
[17:38:13.239]                     muffleCondition(cond, pattern = "^muffle")
[17:38:13.239]                   }
[17:38:13.239]                 }
[17:38:13.239]             }
[17:38:13.239]         }))
[17:38:13.239]     }, error = function(ex) {
[17:38:13.239]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:13.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:13.239]                 ...future.rng), started = ...future.startTime, 
[17:38:13.239]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:13.239]             version = "1.8"), class = "FutureResult")
[17:38:13.239]     }, finally = {
[17:38:13.239]         if (!identical(...future.workdir, getwd())) 
[17:38:13.239]             setwd(...future.workdir)
[17:38:13.239]         {
[17:38:13.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:13.239]                 ...future.oldOptions$nwarnings <- NULL
[17:38:13.239]             }
[17:38:13.239]             base::options(...future.oldOptions)
[17:38:13.239]             if (.Platform$OS.type == "windows") {
[17:38:13.239]                 old_names <- names(...future.oldEnvVars)
[17:38:13.239]                 envs <- base::Sys.getenv()
[17:38:13.239]                 names <- names(envs)
[17:38:13.239]                 common <- intersect(names, old_names)
[17:38:13.239]                 added <- setdiff(names, old_names)
[17:38:13.239]                 removed <- setdiff(old_names, names)
[17:38:13.239]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:13.239]                   envs[common]]
[17:38:13.239]                 NAMES <- toupper(changed)
[17:38:13.239]                 args <- list()
[17:38:13.239]                 for (kk in seq_along(NAMES)) {
[17:38:13.239]                   name <- changed[[kk]]
[17:38:13.239]                   NAME <- NAMES[[kk]]
[17:38:13.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.239]                     next
[17:38:13.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:13.239]                 }
[17:38:13.239]                 NAMES <- toupper(added)
[17:38:13.239]                 for (kk in seq_along(NAMES)) {
[17:38:13.239]                   name <- added[[kk]]
[17:38:13.239]                   NAME <- NAMES[[kk]]
[17:38:13.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.239]                     next
[17:38:13.239]                   args[[name]] <- ""
[17:38:13.239]                 }
[17:38:13.239]                 NAMES <- toupper(removed)
[17:38:13.239]                 for (kk in seq_along(NAMES)) {
[17:38:13.239]                   name <- removed[[kk]]
[17:38:13.239]                   NAME <- NAMES[[kk]]
[17:38:13.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.239]                     next
[17:38:13.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:13.239]                 }
[17:38:13.239]                 if (length(args) > 0) 
[17:38:13.239]                   base::do.call(base::Sys.setenv, args = args)
[17:38:13.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:13.239]             }
[17:38:13.239]             else {
[17:38:13.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:13.239]             }
[17:38:13.239]             {
[17:38:13.239]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:13.239]                   0L) {
[17:38:13.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:13.239]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:13.239]                   base::options(opts)
[17:38:13.239]                 }
[17:38:13.239]                 {
[17:38:13.239]                   {
[17:38:13.239]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:13.239]                     NULL
[17:38:13.239]                   }
[17:38:13.239]                   options(future.plan = NULL)
[17:38:13.239]                   if (is.na(NA_character_)) 
[17:38:13.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:13.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:13.239]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:13.239]                     .init = FALSE)
[17:38:13.239]                 }
[17:38:13.239]             }
[17:38:13.239]         }
[17:38:13.239]     })
[17:38:13.239]     if (TRUE) {
[17:38:13.239]         base::sink(type = "output", split = FALSE)
[17:38:13.239]         if (TRUE) {
[17:38:13.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:13.239]         }
[17:38:13.239]         else {
[17:38:13.239]             ...future.result["stdout"] <- base::list(NULL)
[17:38:13.239]         }
[17:38:13.239]         base::close(...future.stdout)
[17:38:13.239]         ...future.stdout <- NULL
[17:38:13.239]     }
[17:38:13.239]     ...future.result$conditions <- ...future.conditions
[17:38:13.239]     ...future.result$finished <- base::Sys.time()
[17:38:13.239]     ...future.result
[17:38:13.239] }
[17:38:13.242] Exporting 11 global objects (103.08 KiB) to cluster node #2 ...
[17:38:13.242] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:38:13.285] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:38:13.285] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ...
[17:38:13.286] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ... DONE
[17:38:13.286] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:38:13.286] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:38:13.286] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:38:13.329] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:38:13.329] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:38:13.373] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:38:13.373] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[17:38:13.373] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[17:38:13.374] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:38:13.374] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:38:13.374] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:13.375] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:13.375] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:38:13.375] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:38:13.375] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:13.376] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:13.376] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:13.376] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:13.376] Exporting 11 global objects (103.08 KiB) to cluster node #2 ... DONE
[17:38:13.377] MultisessionFuture started
[17:38:13.377] - Launch lazy future ... done
[17:38:13.377] run() for ‘MultisessionFuture’ ... done
[17:38:13.377] Created future:
[17:38:13.377] MultisessionFuture:
[17:38:13.377] Label: ‘future_vapply-2’
[17:38:13.377] Expression:
[17:38:13.377] {
[17:38:13.377]     do.call(function(...) {
[17:38:13.377]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.377]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:13.377]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.377]             on.exit(options(oopts), add = TRUE)
[17:38:13.377]         }
[17:38:13.377]         {
[17:38:13.377]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:13.377]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.377]                 ...future.FUN(...future.X_jj, ...)
[17:38:13.377]             })
[17:38:13.377]         }
[17:38:13.377]     }, args = future.call.arguments)
[17:38:13.377] }
[17:38:13.377] Lazy evaluation: FALSE
[17:38:13.377] Asynchronous evaluation: TRUE
[17:38:13.377] Local evaluation: TRUE
[17:38:13.377] Environment: R_GlobalEnv
[17:38:13.377] Capture standard output: TRUE
[17:38:13.377] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:13.377] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:13.377] Packages: 1 packages (‘future.apply’)
[17:38:13.377] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:13.377] Resolved: FALSE
[17:38:13.377] Value: <not collected>
[17:38:13.377] Conditions captured: <none>
[17:38:13.377] Early signaling: FALSE
[17:38:13.377] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:13.377] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:13.389] Chunk #2 of 2 ... DONE
[17:38:13.389] Launching 2 futures (chunks) ... DONE
[17:38:13.389] Resolving 2 futures (chunks) ...
[17:38:13.390] resolve() on list ...
[17:38:13.390]  recursive: 0
[17:38:13.390]  length: 2
[17:38:13.390] 
[17:38:13.390] receiveMessageFromWorker() for ClusterFuture ...
[17:38:13.390] - Validating connection of MultisessionFuture
[17:38:13.391] - received message: FutureResult
[17:38:13.391] - Received FutureResult
[17:38:13.391] - Erased future from FutureRegistry
[17:38:13.391] result() for ClusterFuture ...
[17:38:13.391] - result already collected: FutureResult
[17:38:13.391] result() for ClusterFuture ... done
[17:38:13.391] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:13.391] Future #1
[17:38:13.391] result() for ClusterFuture ...
[17:38:13.391] - result already collected: FutureResult
[17:38:13.392] result() for ClusterFuture ... done
[17:38:13.392] result() for ClusterFuture ...
[17:38:13.392] - result already collected: FutureResult
[17:38:13.392] result() for ClusterFuture ... done
[17:38:13.392] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:13.392] - nx: 2
[17:38:13.392] - relay: TRUE
[17:38:13.392] - stdout: TRUE
[17:38:13.392] - signal: TRUE
[17:38:13.392] - resignal: FALSE
[17:38:13.392] - force: TRUE
[17:38:13.392] - relayed: [n=2] FALSE, FALSE
[17:38:13.393] - queued futures: [n=2] FALSE, FALSE
[17:38:13.393]  - until=1
[17:38:13.393]  - relaying element #1
[17:38:13.393] result() for ClusterFuture ...
[17:38:13.393] - result already collected: FutureResult
[17:38:13.393] result() for ClusterFuture ... done
[17:38:13.393] result() for ClusterFuture ...
[17:38:13.393] - result already collected: FutureResult
[17:38:13.393] result() for ClusterFuture ... done
[17:38:13.393] result() for ClusterFuture ...
[17:38:13.394] - result already collected: FutureResult
[17:38:13.394] result() for ClusterFuture ... done
[17:38:13.394] result() for ClusterFuture ...
[17:38:13.394] - result already collected: FutureResult
[17:38:13.394] result() for ClusterFuture ... done
[17:38:13.394] - relayed: [n=2] TRUE, FALSE
[17:38:13.394] - queued futures: [n=2] TRUE, FALSE
[17:38:13.394] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:13.394]  length: 1 (resolved future 1)
[17:38:13.422] receiveMessageFromWorker() for ClusterFuture ...
[17:38:13.422] - Validating connection of MultisessionFuture
[17:38:13.422] - received message: FutureResult
[17:38:13.423] - Received FutureResult
[17:38:13.423] - Erased future from FutureRegistry
[17:38:13.423] result() for ClusterFuture ...
[17:38:13.423] - result already collected: FutureResult
[17:38:13.423] result() for ClusterFuture ... done
[17:38:13.423] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:13.423] Future #2
[17:38:13.423] result() for ClusterFuture ...
[17:38:13.423] - result already collected: FutureResult
[17:38:13.423] result() for ClusterFuture ... done
[17:38:13.424] result() for ClusterFuture ...
[17:38:13.424] - result already collected: FutureResult
[17:38:13.424] result() for ClusterFuture ... done
[17:38:13.424] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:13.424] - nx: 2
[17:38:13.424] - relay: TRUE
[17:38:13.424] - stdout: TRUE
[17:38:13.424] - signal: TRUE
[17:38:13.424] - resignal: FALSE
[17:38:13.424] - force: TRUE
[17:38:13.424] - relayed: [n=2] TRUE, FALSE
[17:38:13.424] - queued futures: [n=2] TRUE, FALSE
[17:38:13.425]  - until=2
[17:38:13.425]  - relaying element #2
[17:38:13.425] result() for ClusterFuture ...
[17:38:13.425] - result already collected: FutureResult
[17:38:13.425] result() for ClusterFuture ... done
[17:38:13.425] result() for ClusterFuture ...
[17:38:13.425] - result already collected: FutureResult
[17:38:13.425] result() for ClusterFuture ... done
[17:38:13.425] result() for ClusterFuture ...
[17:38:13.425] - result already collected: FutureResult
[17:38:13.426] result() for ClusterFuture ... done
[17:38:13.426] result() for ClusterFuture ...
[17:38:13.426] - result already collected: FutureResult
[17:38:13.426] result() for ClusterFuture ... done
[17:38:13.426] - relayed: [n=2] TRUE, TRUE
[17:38:13.426] - queued futures: [n=2] TRUE, TRUE
[17:38:13.426] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:13.426]  length: 0 (resolved future 2)
[17:38:13.426] Relaying remaining futures
[17:38:13.426] signalConditionsASAP(NULL, pos=0) ...
[17:38:13.426] - nx: 2
[17:38:13.426] - relay: TRUE
[17:38:13.427] - stdout: TRUE
[17:38:13.427] - signal: TRUE
[17:38:13.427] - resignal: FALSE
[17:38:13.427] - force: TRUE
[17:38:13.427] - relayed: [n=2] TRUE, TRUE
[17:38:13.427] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:13.427] - relayed: [n=2] TRUE, TRUE
[17:38:13.427] - queued futures: [n=2] TRUE, TRUE
[17:38:13.427] signalConditionsASAP(NULL, pos=0) ... done
[17:38:13.427] resolve() on list ... DONE
[17:38:13.427] result() for ClusterFuture ...
[17:38:13.428] - result already collected: FutureResult
[17:38:13.428] result() for ClusterFuture ... done
[17:38:13.428] result() for ClusterFuture ...
[17:38:13.428] - result already collected: FutureResult
[17:38:13.428] result() for ClusterFuture ... done
[17:38:13.428] result() for ClusterFuture ...
[17:38:13.428] - result already collected: FutureResult
[17:38:13.428] result() for ClusterFuture ... done
[17:38:13.428] result() for ClusterFuture ...
[17:38:13.428] - result already collected: FutureResult
[17:38:13.428] result() for ClusterFuture ... done
[17:38:13.429]  - Number of value chunks collected: 2
[17:38:13.429] Resolving 2 futures (chunks) ... DONE
[17:38:13.429] Reducing values from 2 chunks ...
[17:38:13.429]  - Number of values collected after concatenation: 10
[17:38:13.429]  - Number of values expected: 10
[17:38:13.429] Reducing values from 2 chunks ... DONE
[17:38:13.429] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[17:38:13.431] future_lapply() ...
[17:38:13.437] Number of chunks: 2
[17:38:13.437] getGlobalsAndPackagesXApply() ...
[17:38:13.437]  - future.globals: TRUE
[17:38:13.437] getGlobalsAndPackages() ...
[17:38:13.437] Searching for globals...
[17:38:13.441] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[17:38:13.441] Searching for globals ... DONE
[17:38:13.441] Resolving globals: FALSE
[17:38:13.442] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[17:38:13.442] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:13.442] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:13.443] - packages: [2] ‘stats’, ‘future.apply’
[17:38:13.443] getGlobalsAndPackages() ... DONE
[17:38:13.443]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:13.443]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:38:13.443] Finding globals ... DONE
[17:38:13.443]  - use_args: TRUE
[17:38:13.443]  - Getting '...' globals ...
[17:38:13.443] resolve() on list ...
[17:38:13.444]  recursive: 0
[17:38:13.444]  length: 1
[17:38:13.444]  elements: ‘...’
[17:38:13.444]  length: 0 (resolved future 1)
[17:38:13.444] resolve() on list ... DONE
[17:38:13.444]    - '...' content: [n=0] 
[17:38:13.444] List of 1
[17:38:13.444]  $ ...: list()
[17:38:13.444]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:13.444]  - attr(*, "where")=List of 1
[17:38:13.444]   ..$ ...:<environment: 0x560803a0ad18> 
[17:38:13.444]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:13.444]  - attr(*, "resolved")= logi TRUE
[17:38:13.444]  - attr(*, "total_size")= num NA
[17:38:13.447]  - Getting '...' globals ... DONE
[17:38:13.447] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:13.447] List of 8
[17:38:13.447]  $ ...future.FUN:function (x, ...)  
[17:38:13.447]  $ x_FUN        :function (x, ...)  
[17:38:13.447]  $ times        : int 5
[17:38:13.447]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:13.447]  $ stop_if_not  :function (...)  
[17:38:13.447]  $ dim          : NULL
[17:38:13.447]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:13.447]  $ ...          : list()
[17:38:13.447]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:13.447]  - attr(*, "where")=List of 8
[17:38:13.447]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:13.447]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:13.447]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:13.447]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:13.447]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:13.447]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:13.447]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:13.447]   ..$ ...          :<environment: 0x560803a0ad18> 
[17:38:13.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:13.447]  - attr(*, "resolved")= logi FALSE
[17:38:13.447]  - attr(*, "total_size")= num 95528
[17:38:13.452] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:38:13.452] getGlobalsAndPackagesXApply() ... DONE
[17:38:13.453] Number of futures (= number of chunks): 2
[17:38:13.453] Launching 2 futures (chunks) ...
[17:38:13.453] Chunk #1 of 2 ...
[17:38:13.453]  - Finding globals in 'X' for chunk #1 ...
[17:38:13.453] getGlobalsAndPackages() ...
[17:38:13.453] Searching for globals...
[17:38:13.453] 
[17:38:13.453] Searching for globals ... DONE
[17:38:13.453] - globals: [0] <none>
[17:38:13.454] getGlobalsAndPackages() ... DONE
[17:38:13.454]    + additional globals found: [n=0] 
[17:38:13.454]    + additional namespaces needed: [n=0] 
[17:38:13.454]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:13.454]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:13.454]  - seeds: <none>
[17:38:13.454]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.454] getGlobalsAndPackages() ...
[17:38:13.454] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.454] Resolving globals: FALSE
[17:38:13.455] Tweak future expression to call with '...' arguments ...
[17:38:13.455] {
[17:38:13.455]     do.call(function(...) {
[17:38:13.455]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.455]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:13.455]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.455]             on.exit(options(oopts), add = TRUE)
[17:38:13.455]         }
[17:38:13.455]         {
[17:38:13.455]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:13.455]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.455]                 ...future.FUN(...future.X_jj, ...)
[17:38:13.455]             })
[17:38:13.455]         }
[17:38:13.455]     }, args = future.call.arguments)
[17:38:13.455] }
[17:38:13.455] Tweak future expression to call with '...' arguments ... DONE
[17:38:13.455] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.456] - packages: [2] ‘stats’, ‘future.apply’
[17:38:13.456] getGlobalsAndPackages() ... DONE
[17:38:13.456] run() for ‘Future’ ...
[17:38:13.456] - state: ‘created’
[17:38:13.456] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:13.473] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:13.473] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:13.473]   - Field: ‘node’
[17:38:13.473]   - Field: ‘label’
[17:38:13.473]   - Field: ‘local’
[17:38:13.473]   - Field: ‘owner’
[17:38:13.473]   - Field: ‘envir’
[17:38:13.474]   - Field: ‘workers’
[17:38:13.474]   - Field: ‘packages’
[17:38:13.474]   - Field: ‘gc’
[17:38:13.474]   - Field: ‘conditions’
[17:38:13.474]   - Field: ‘persistent’
[17:38:13.474]   - Field: ‘expr’
[17:38:13.474]   - Field: ‘uuid’
[17:38:13.474]   - Field: ‘seed’
[17:38:13.474]   - Field: ‘version’
[17:38:13.474]   - Field: ‘result’
[17:38:13.474]   - Field: ‘asynchronous’
[17:38:13.474]   - Field: ‘calls’
[17:38:13.475]   - Field: ‘globals’
[17:38:13.475]   - Field: ‘stdout’
[17:38:13.475]   - Field: ‘earlySignal’
[17:38:13.475]   - Field: ‘lazy’
[17:38:13.475]   - Field: ‘state’
[17:38:13.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:13.475] - Launch lazy future ...
[17:38:13.475] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:38:13.476] Packages needed by future strategies (n = 0): <none>
[17:38:13.476] {
[17:38:13.476]     {
[17:38:13.476]         {
[17:38:13.476]             ...future.startTime <- base::Sys.time()
[17:38:13.476]             {
[17:38:13.476]                 {
[17:38:13.476]                   {
[17:38:13.476]                     {
[17:38:13.476]                       {
[17:38:13.476]                         base::local({
[17:38:13.476]                           has_future <- base::requireNamespace("future", 
[17:38:13.476]                             quietly = TRUE)
[17:38:13.476]                           if (has_future) {
[17:38:13.476]                             ns <- base::getNamespace("future")
[17:38:13.476]                             version <- ns[[".package"]][["version"]]
[17:38:13.476]                             if (is.null(version)) 
[17:38:13.476]                               version <- utils::packageVersion("future")
[17:38:13.476]                           }
[17:38:13.476]                           else {
[17:38:13.476]                             version <- NULL
[17:38:13.476]                           }
[17:38:13.476]                           if (!has_future || version < "1.8.0") {
[17:38:13.476]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:13.476]                               "", base::R.version$version.string), 
[17:38:13.476]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:13.476]                                 base::R.version$platform, 8 * 
[17:38:13.476]                                   base::.Machine$sizeof.pointer), 
[17:38:13.476]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:13.476]                                 "release", "version")], collapse = " "), 
[17:38:13.476]                               hostname = base::Sys.info()[["nodename"]])
[17:38:13.476]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:13.476]                               info)
[17:38:13.476]                             info <- base::paste(info, collapse = "; ")
[17:38:13.476]                             if (!has_future) {
[17:38:13.476]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:13.476]                                 info)
[17:38:13.476]                             }
[17:38:13.476]                             else {
[17:38:13.476]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:13.476]                                 info, version)
[17:38:13.476]                             }
[17:38:13.476]                             base::stop(msg)
[17:38:13.476]                           }
[17:38:13.476]                         })
[17:38:13.476]                       }
[17:38:13.476]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:13.476]                       base::options(mc.cores = 1L)
[17:38:13.476]                     }
[17:38:13.476]                     base::local({
[17:38:13.476]                       for (pkg in c("stats", "future.apply")) {
[17:38:13.476]                         base::loadNamespace(pkg)
[17:38:13.476]                         base::library(pkg, character.only = TRUE)
[17:38:13.476]                       }
[17:38:13.476]                     })
[17:38:13.476]                   }
[17:38:13.476]                   ...future.strategy.old <- future::plan("list")
[17:38:13.476]                   options(future.plan = NULL)
[17:38:13.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:13.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:13.476]                 }
[17:38:13.476]                 ...future.workdir <- getwd()
[17:38:13.476]             }
[17:38:13.476]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:13.476]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:13.476]         }
[17:38:13.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:13.476]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:13.476]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:13.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:13.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:13.476]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:13.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:13.476]             base::names(...future.oldOptions))
[17:38:13.476]     }
[17:38:13.476]     if (FALSE) {
[17:38:13.476]     }
[17:38:13.476]     else {
[17:38:13.476]         if (TRUE) {
[17:38:13.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:13.476]                 open = "w")
[17:38:13.476]         }
[17:38:13.476]         else {
[17:38:13.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:13.476]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:13.476]         }
[17:38:13.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:13.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:13.476]             base::sink(type = "output", split = FALSE)
[17:38:13.476]             base::close(...future.stdout)
[17:38:13.476]         }, add = TRUE)
[17:38:13.476]     }
[17:38:13.476]     ...future.frame <- base::sys.nframe()
[17:38:13.476]     ...future.conditions <- base::list()
[17:38:13.476]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:13.476]     if (FALSE) {
[17:38:13.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:13.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:13.476]     }
[17:38:13.476]     ...future.result <- base::tryCatch({
[17:38:13.476]         base::withCallingHandlers({
[17:38:13.476]             ...future.value <- base::withVisible(base::local({
[17:38:13.476]                 ...future.makeSendCondition <- base::local({
[17:38:13.476]                   sendCondition <- NULL
[17:38:13.476]                   function(frame = 1L) {
[17:38:13.476]                     if (is.function(sendCondition)) 
[17:38:13.476]                       return(sendCondition)
[17:38:13.476]                     ns <- getNamespace("parallel")
[17:38:13.476]                     if (exists("sendData", mode = "function", 
[17:38:13.476]                       envir = ns)) {
[17:38:13.476]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:13.476]                         envir = ns)
[17:38:13.476]                       envir <- sys.frame(frame)
[17:38:13.476]                       master <- NULL
[17:38:13.476]                       while (!identical(envir, .GlobalEnv) && 
[17:38:13.476]                         !identical(envir, emptyenv())) {
[17:38:13.476]                         if (exists("master", mode = "list", envir = envir, 
[17:38:13.476]                           inherits = FALSE)) {
[17:38:13.476]                           master <- get("master", mode = "list", 
[17:38:13.476]                             envir = envir, inherits = FALSE)
[17:38:13.476]                           if (inherits(master, c("SOCKnode", 
[17:38:13.476]                             "SOCK0node"))) {
[17:38:13.476]                             sendCondition <<- function(cond) {
[17:38:13.476]                               data <- list(type = "VALUE", value = cond, 
[17:38:13.476]                                 success = TRUE)
[17:38:13.476]                               parallel_sendData(master, data)
[17:38:13.476]                             }
[17:38:13.476]                             return(sendCondition)
[17:38:13.476]                           }
[17:38:13.476]                         }
[17:38:13.476]                         frame <- frame + 1L
[17:38:13.476]                         envir <- sys.frame(frame)
[17:38:13.476]                       }
[17:38:13.476]                     }
[17:38:13.476]                     sendCondition <<- function(cond) NULL
[17:38:13.476]                   }
[17:38:13.476]                 })
[17:38:13.476]                 withCallingHandlers({
[17:38:13.476]                   {
[17:38:13.476]                     do.call(function(...) {
[17:38:13.476]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.476]                       if (!identical(...future.globals.maxSize.org, 
[17:38:13.476]                         ...future.globals.maxSize)) {
[17:38:13.476]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.476]                         on.exit(options(oopts), add = TRUE)
[17:38:13.476]                       }
[17:38:13.476]                       {
[17:38:13.476]                         lapply(seq_along(...future.elements_ii), 
[17:38:13.476]                           FUN = function(jj) {
[17:38:13.476]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.476]                             ...future.FUN(...future.X_jj, ...)
[17:38:13.476]                           })
[17:38:13.476]                       }
[17:38:13.476]                     }, args = future.call.arguments)
[17:38:13.476]                   }
[17:38:13.476]                 }, immediateCondition = function(cond) {
[17:38:13.476]                   sendCondition <- ...future.makeSendCondition()
[17:38:13.476]                   sendCondition(cond)
[17:38:13.476]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.476]                   {
[17:38:13.476]                     inherits <- base::inherits
[17:38:13.476]                     invokeRestart <- base::invokeRestart
[17:38:13.476]                     is.null <- base::is.null
[17:38:13.476]                     muffled <- FALSE
[17:38:13.476]                     if (inherits(cond, "message")) {
[17:38:13.476]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:13.476]                       if (muffled) 
[17:38:13.476]                         invokeRestart("muffleMessage")
[17:38:13.476]                     }
[17:38:13.476]                     else if (inherits(cond, "warning")) {
[17:38:13.476]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:13.476]                       if (muffled) 
[17:38:13.476]                         invokeRestart("muffleWarning")
[17:38:13.476]                     }
[17:38:13.476]                     else if (inherits(cond, "condition")) {
[17:38:13.476]                       if (!is.null(pattern)) {
[17:38:13.476]                         computeRestarts <- base::computeRestarts
[17:38:13.476]                         grepl <- base::grepl
[17:38:13.476]                         restarts <- computeRestarts(cond)
[17:38:13.476]                         for (restart in restarts) {
[17:38:13.476]                           name <- restart$name
[17:38:13.476]                           if (is.null(name)) 
[17:38:13.476]                             next
[17:38:13.476]                           if (!grepl(pattern, name)) 
[17:38:13.476]                             next
[17:38:13.476]                           invokeRestart(restart)
[17:38:13.476]                           muffled <- TRUE
[17:38:13.476]                           break
[17:38:13.476]                         }
[17:38:13.476]                       }
[17:38:13.476]                     }
[17:38:13.476]                     invisible(muffled)
[17:38:13.476]                   }
[17:38:13.476]                   muffleCondition(cond)
[17:38:13.476]                 })
[17:38:13.476]             }))
[17:38:13.476]             future::FutureResult(value = ...future.value$value, 
[17:38:13.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:13.476]                   ...future.rng), globalenv = if (FALSE) 
[17:38:13.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:13.476]                     ...future.globalenv.names))
[17:38:13.476]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:13.476]         }, condition = base::local({
[17:38:13.476]             c <- base::c
[17:38:13.476]             inherits <- base::inherits
[17:38:13.476]             invokeRestart <- base::invokeRestart
[17:38:13.476]             length <- base::length
[17:38:13.476]             list <- base::list
[17:38:13.476]             seq.int <- base::seq.int
[17:38:13.476]             signalCondition <- base::signalCondition
[17:38:13.476]             sys.calls <- base::sys.calls
[17:38:13.476]             `[[` <- base::`[[`
[17:38:13.476]             `+` <- base::`+`
[17:38:13.476]             `<<-` <- base::`<<-`
[17:38:13.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:13.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:13.476]                   3L)]
[17:38:13.476]             }
[17:38:13.476]             function(cond) {
[17:38:13.476]                 is_error <- inherits(cond, "error")
[17:38:13.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:13.476]                   NULL)
[17:38:13.476]                 if (is_error) {
[17:38:13.476]                   sessionInformation <- function() {
[17:38:13.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:13.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:13.476]                       search = base::search(), system = base::Sys.info())
[17:38:13.476]                   }
[17:38:13.476]                   ...future.conditions[[length(...future.conditions) + 
[17:38:13.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:13.476]                     cond$call), session = sessionInformation(), 
[17:38:13.476]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:13.476]                   signalCondition(cond)
[17:38:13.476]                 }
[17:38:13.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:13.476]                 "immediateCondition"))) {
[17:38:13.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:13.476]                   ...future.conditions[[length(...future.conditions) + 
[17:38:13.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:13.476]                   if (TRUE && !signal) {
[17:38:13.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.476]                     {
[17:38:13.476]                       inherits <- base::inherits
[17:38:13.476]                       invokeRestart <- base::invokeRestart
[17:38:13.476]                       is.null <- base::is.null
[17:38:13.476]                       muffled <- FALSE
[17:38:13.476]                       if (inherits(cond, "message")) {
[17:38:13.476]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:13.476]                         if (muffled) 
[17:38:13.476]                           invokeRestart("muffleMessage")
[17:38:13.476]                       }
[17:38:13.476]                       else if (inherits(cond, "warning")) {
[17:38:13.476]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:13.476]                         if (muffled) 
[17:38:13.476]                           invokeRestart("muffleWarning")
[17:38:13.476]                       }
[17:38:13.476]                       else if (inherits(cond, "condition")) {
[17:38:13.476]                         if (!is.null(pattern)) {
[17:38:13.476]                           computeRestarts <- base::computeRestarts
[17:38:13.476]                           grepl <- base::grepl
[17:38:13.476]                           restarts <- computeRestarts(cond)
[17:38:13.476]                           for (restart in restarts) {
[17:38:13.476]                             name <- restart$name
[17:38:13.476]                             if (is.null(name)) 
[17:38:13.476]                               next
[17:38:13.476]                             if (!grepl(pattern, name)) 
[17:38:13.476]                               next
[17:38:13.476]                             invokeRestart(restart)
[17:38:13.476]                             muffled <- TRUE
[17:38:13.476]                             break
[17:38:13.476]                           }
[17:38:13.476]                         }
[17:38:13.476]                       }
[17:38:13.476]                       invisible(muffled)
[17:38:13.476]                     }
[17:38:13.476]                     muffleCondition(cond, pattern = "^muffle")
[17:38:13.476]                   }
[17:38:13.476]                 }
[17:38:13.476]                 else {
[17:38:13.476]                   if (TRUE) {
[17:38:13.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.476]                     {
[17:38:13.476]                       inherits <- base::inherits
[17:38:13.476]                       invokeRestart <- base::invokeRestart
[17:38:13.476]                       is.null <- base::is.null
[17:38:13.476]                       muffled <- FALSE
[17:38:13.476]                       if (inherits(cond, "message")) {
[17:38:13.476]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:13.476]                         if (muffled) 
[17:38:13.476]                           invokeRestart("muffleMessage")
[17:38:13.476]                       }
[17:38:13.476]                       else if (inherits(cond, "warning")) {
[17:38:13.476]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:13.476]                         if (muffled) 
[17:38:13.476]                           invokeRestart("muffleWarning")
[17:38:13.476]                       }
[17:38:13.476]                       else if (inherits(cond, "condition")) {
[17:38:13.476]                         if (!is.null(pattern)) {
[17:38:13.476]                           computeRestarts <- base::computeRestarts
[17:38:13.476]                           grepl <- base::grepl
[17:38:13.476]                           restarts <- computeRestarts(cond)
[17:38:13.476]                           for (restart in restarts) {
[17:38:13.476]                             name <- restart$name
[17:38:13.476]                             if (is.null(name)) 
[17:38:13.476]                               next
[17:38:13.476]                             if (!grepl(pattern, name)) 
[17:38:13.476]                               next
[17:38:13.476]                             invokeRestart(restart)
[17:38:13.476]                             muffled <- TRUE
[17:38:13.476]                             break
[17:38:13.476]                           }
[17:38:13.476]                         }
[17:38:13.476]                       }
[17:38:13.476]                       invisible(muffled)
[17:38:13.476]                     }
[17:38:13.476]                     muffleCondition(cond, pattern = "^muffle")
[17:38:13.476]                   }
[17:38:13.476]                 }
[17:38:13.476]             }
[17:38:13.476]         }))
[17:38:13.476]     }, error = function(ex) {
[17:38:13.476]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:13.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:13.476]                 ...future.rng), started = ...future.startTime, 
[17:38:13.476]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:13.476]             version = "1.8"), class = "FutureResult")
[17:38:13.476]     }, finally = {
[17:38:13.476]         if (!identical(...future.workdir, getwd())) 
[17:38:13.476]             setwd(...future.workdir)
[17:38:13.476]         {
[17:38:13.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:13.476]                 ...future.oldOptions$nwarnings <- NULL
[17:38:13.476]             }
[17:38:13.476]             base::options(...future.oldOptions)
[17:38:13.476]             if (.Platform$OS.type == "windows") {
[17:38:13.476]                 old_names <- names(...future.oldEnvVars)
[17:38:13.476]                 envs <- base::Sys.getenv()
[17:38:13.476]                 names <- names(envs)
[17:38:13.476]                 common <- intersect(names, old_names)
[17:38:13.476]                 added <- setdiff(names, old_names)
[17:38:13.476]                 removed <- setdiff(old_names, names)
[17:38:13.476]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:13.476]                   envs[common]]
[17:38:13.476]                 NAMES <- toupper(changed)
[17:38:13.476]                 args <- list()
[17:38:13.476]                 for (kk in seq_along(NAMES)) {
[17:38:13.476]                   name <- changed[[kk]]
[17:38:13.476]                   NAME <- NAMES[[kk]]
[17:38:13.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.476]                     next
[17:38:13.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:13.476]                 }
[17:38:13.476]                 NAMES <- toupper(added)
[17:38:13.476]                 for (kk in seq_along(NAMES)) {
[17:38:13.476]                   name <- added[[kk]]
[17:38:13.476]                   NAME <- NAMES[[kk]]
[17:38:13.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.476]                     next
[17:38:13.476]                   args[[name]] <- ""
[17:38:13.476]                 }
[17:38:13.476]                 NAMES <- toupper(removed)
[17:38:13.476]                 for (kk in seq_along(NAMES)) {
[17:38:13.476]                   name <- removed[[kk]]
[17:38:13.476]                   NAME <- NAMES[[kk]]
[17:38:13.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.476]                     next
[17:38:13.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:13.476]                 }
[17:38:13.476]                 if (length(args) > 0) 
[17:38:13.476]                   base::do.call(base::Sys.setenv, args = args)
[17:38:13.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:13.476]             }
[17:38:13.476]             else {
[17:38:13.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:13.476]             }
[17:38:13.476]             {
[17:38:13.476]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:13.476]                   0L) {
[17:38:13.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:13.476]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:13.476]                   base::options(opts)
[17:38:13.476]                 }
[17:38:13.476]                 {
[17:38:13.476]                   {
[17:38:13.476]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:13.476]                     NULL
[17:38:13.476]                   }
[17:38:13.476]                   options(future.plan = NULL)
[17:38:13.476]                   if (is.na(NA_character_)) 
[17:38:13.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:13.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:13.476]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:13.476]                     .init = FALSE)
[17:38:13.476]                 }
[17:38:13.476]             }
[17:38:13.476]         }
[17:38:13.476]     })
[17:38:13.476]     if (TRUE) {
[17:38:13.476]         base::sink(type = "output", split = FALSE)
[17:38:13.476]         if (TRUE) {
[17:38:13.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:13.476]         }
[17:38:13.476]         else {
[17:38:13.476]             ...future.result["stdout"] <- base::list(NULL)
[17:38:13.476]         }
[17:38:13.476]         base::close(...future.stdout)
[17:38:13.476]         ...future.stdout <- NULL
[17:38:13.476]     }
[17:38:13.476]     ...future.result$conditions <- ...future.conditions
[17:38:13.476]     ...future.result$finished <- base::Sys.time()
[17:38:13.476]     ...future.result
[17:38:13.476] }
[17:38:13.479] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[17:38:13.479] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:38:13.521] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:38:13.521] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[17:38:13.521] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:38:13.521] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:38:13.522] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:38:13.522] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:38:13.565] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:38:13.565] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:38:13.613] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:38:13.613] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:38:13.613] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:38:13.613] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:38:13.614] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:38:13.614] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:13.614] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:13.614] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[17:38:13.615] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[17:38:13.615] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:13.615] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:13.615] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:13.616] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:13.616] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[17:38:13.616] MultisessionFuture started
[17:38:13.616] - Launch lazy future ... done
[17:38:13.617] run() for ‘MultisessionFuture’ ... done
[17:38:13.617] Created future:
[17:38:13.617] MultisessionFuture:
[17:38:13.617] Label: ‘future_vapply-1’
[17:38:13.617] Expression:
[17:38:13.617] {
[17:38:13.617]     do.call(function(...) {
[17:38:13.617]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.617]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:13.617]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.617]             on.exit(options(oopts), add = TRUE)
[17:38:13.617]         }
[17:38:13.617]         {
[17:38:13.617]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:13.617]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.617]                 ...future.FUN(...future.X_jj, ...)
[17:38:13.617]             })
[17:38:13.617]         }
[17:38:13.617]     }, args = future.call.arguments)
[17:38:13.617] }
[17:38:13.617] Lazy evaluation: FALSE
[17:38:13.617] Asynchronous evaluation: TRUE
[17:38:13.617] Local evaluation: TRUE
[17:38:13.617] Environment: R_GlobalEnv
[17:38:13.617] Capture standard output: TRUE
[17:38:13.617] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:13.617] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:13.617] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:38:13.617] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:13.617] Resolved: FALSE
[17:38:13.617] Value: <not collected>
[17:38:13.617] Conditions captured: <none>
[17:38:13.617] Early signaling: FALSE
[17:38:13.617] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:13.617] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:13.629] Chunk #1 of 2 ... DONE
[17:38:13.629] Chunk #2 of 2 ...
[17:38:13.629]  - Finding globals in 'X' for chunk #2 ...
[17:38:13.629] getGlobalsAndPackages() ...
[17:38:13.629] Searching for globals...
[17:38:13.629] 
[17:38:13.629] Searching for globals ... DONE
[17:38:13.630] - globals: [0] <none>
[17:38:13.630] getGlobalsAndPackages() ... DONE
[17:38:13.630]    + additional globals found: [n=0] 
[17:38:13.630]    + additional namespaces needed: [n=0] 
[17:38:13.630]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:13.630]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:13.630]  - seeds: <none>
[17:38:13.630]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.630] getGlobalsAndPackages() ...
[17:38:13.630] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.631] Resolving globals: FALSE
[17:38:13.631] Tweak future expression to call with '...' arguments ...
[17:38:13.631] {
[17:38:13.631]     do.call(function(...) {
[17:38:13.631]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.631]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:13.631]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.631]             on.exit(options(oopts), add = TRUE)
[17:38:13.631]         }
[17:38:13.631]         {
[17:38:13.631]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:13.631]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.631]                 ...future.FUN(...future.X_jj, ...)
[17:38:13.631]             })
[17:38:13.631]         }
[17:38:13.631]     }, args = future.call.arguments)
[17:38:13.631] }
[17:38:13.631] Tweak future expression to call with '...' arguments ... DONE
[17:38:13.632] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.632] - packages: [2] ‘stats’, ‘future.apply’
[17:38:13.632] getGlobalsAndPackages() ... DONE
[17:38:13.632] run() for ‘Future’ ...
[17:38:13.632] - state: ‘created’
[17:38:13.632] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:13.647] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:13.647] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:13.647]   - Field: ‘node’
[17:38:13.647]   - Field: ‘label’
[17:38:13.647]   - Field: ‘local’
[17:38:13.647]   - Field: ‘owner’
[17:38:13.647]   - Field: ‘envir’
[17:38:13.647]   - Field: ‘workers’
[17:38:13.648]   - Field: ‘packages’
[17:38:13.648]   - Field: ‘gc’
[17:38:13.648]   - Field: ‘conditions’
[17:38:13.648]   - Field: ‘persistent’
[17:38:13.648]   - Field: ‘expr’
[17:38:13.648]   - Field: ‘uuid’
[17:38:13.648]   - Field: ‘seed’
[17:38:13.648]   - Field: ‘version’
[17:38:13.648]   - Field: ‘result’
[17:38:13.648]   - Field: ‘asynchronous’
[17:38:13.649]   - Field: ‘calls’
[17:38:13.649]   - Field: ‘globals’
[17:38:13.649]   - Field: ‘stdout’
[17:38:13.649]   - Field: ‘earlySignal’
[17:38:13.649]   - Field: ‘lazy’
[17:38:13.649]   - Field: ‘state’
[17:38:13.649] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:13.649] - Launch lazy future ...
[17:38:13.650] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:38:13.650] Packages needed by future strategies (n = 0): <none>
[17:38:13.650] {
[17:38:13.650]     {
[17:38:13.650]         {
[17:38:13.650]             ...future.startTime <- base::Sys.time()
[17:38:13.650]             {
[17:38:13.650]                 {
[17:38:13.650]                   {
[17:38:13.650]                     {
[17:38:13.650]                       {
[17:38:13.650]                         base::local({
[17:38:13.650]                           has_future <- base::requireNamespace("future", 
[17:38:13.650]                             quietly = TRUE)
[17:38:13.650]                           if (has_future) {
[17:38:13.650]                             ns <- base::getNamespace("future")
[17:38:13.650]                             version <- ns[[".package"]][["version"]]
[17:38:13.650]                             if (is.null(version)) 
[17:38:13.650]                               version <- utils::packageVersion("future")
[17:38:13.650]                           }
[17:38:13.650]                           else {
[17:38:13.650]                             version <- NULL
[17:38:13.650]                           }
[17:38:13.650]                           if (!has_future || version < "1.8.0") {
[17:38:13.650]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:13.650]                               "", base::R.version$version.string), 
[17:38:13.650]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:13.650]                                 base::R.version$platform, 8 * 
[17:38:13.650]                                   base::.Machine$sizeof.pointer), 
[17:38:13.650]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:13.650]                                 "release", "version")], collapse = " "), 
[17:38:13.650]                               hostname = base::Sys.info()[["nodename"]])
[17:38:13.650]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:13.650]                               info)
[17:38:13.650]                             info <- base::paste(info, collapse = "; ")
[17:38:13.650]                             if (!has_future) {
[17:38:13.650]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:13.650]                                 info)
[17:38:13.650]                             }
[17:38:13.650]                             else {
[17:38:13.650]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:13.650]                                 info, version)
[17:38:13.650]                             }
[17:38:13.650]                             base::stop(msg)
[17:38:13.650]                           }
[17:38:13.650]                         })
[17:38:13.650]                       }
[17:38:13.650]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:13.650]                       base::options(mc.cores = 1L)
[17:38:13.650]                     }
[17:38:13.650]                     base::local({
[17:38:13.650]                       for (pkg in c("stats", "future.apply")) {
[17:38:13.650]                         base::loadNamespace(pkg)
[17:38:13.650]                         base::library(pkg, character.only = TRUE)
[17:38:13.650]                       }
[17:38:13.650]                     })
[17:38:13.650]                   }
[17:38:13.650]                   ...future.strategy.old <- future::plan("list")
[17:38:13.650]                   options(future.plan = NULL)
[17:38:13.650]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:13.650]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:13.650]                 }
[17:38:13.650]                 ...future.workdir <- getwd()
[17:38:13.650]             }
[17:38:13.650]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:13.650]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:13.650]         }
[17:38:13.650]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:13.650]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:13.650]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:13.650]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:13.650]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:13.650]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:13.650]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:13.650]             base::names(...future.oldOptions))
[17:38:13.650]     }
[17:38:13.650]     if (FALSE) {
[17:38:13.650]     }
[17:38:13.650]     else {
[17:38:13.650]         if (TRUE) {
[17:38:13.650]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:13.650]                 open = "w")
[17:38:13.650]         }
[17:38:13.650]         else {
[17:38:13.650]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:13.650]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:13.650]         }
[17:38:13.650]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:13.650]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:13.650]             base::sink(type = "output", split = FALSE)
[17:38:13.650]             base::close(...future.stdout)
[17:38:13.650]         }, add = TRUE)
[17:38:13.650]     }
[17:38:13.650]     ...future.frame <- base::sys.nframe()
[17:38:13.650]     ...future.conditions <- base::list()
[17:38:13.650]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:13.650]     if (FALSE) {
[17:38:13.650]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:13.650]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:13.650]     }
[17:38:13.650]     ...future.result <- base::tryCatch({
[17:38:13.650]         base::withCallingHandlers({
[17:38:13.650]             ...future.value <- base::withVisible(base::local({
[17:38:13.650]                 ...future.makeSendCondition <- base::local({
[17:38:13.650]                   sendCondition <- NULL
[17:38:13.650]                   function(frame = 1L) {
[17:38:13.650]                     if (is.function(sendCondition)) 
[17:38:13.650]                       return(sendCondition)
[17:38:13.650]                     ns <- getNamespace("parallel")
[17:38:13.650]                     if (exists("sendData", mode = "function", 
[17:38:13.650]                       envir = ns)) {
[17:38:13.650]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:13.650]                         envir = ns)
[17:38:13.650]                       envir <- sys.frame(frame)
[17:38:13.650]                       master <- NULL
[17:38:13.650]                       while (!identical(envir, .GlobalEnv) && 
[17:38:13.650]                         !identical(envir, emptyenv())) {
[17:38:13.650]                         if (exists("master", mode = "list", envir = envir, 
[17:38:13.650]                           inherits = FALSE)) {
[17:38:13.650]                           master <- get("master", mode = "list", 
[17:38:13.650]                             envir = envir, inherits = FALSE)
[17:38:13.650]                           if (inherits(master, c("SOCKnode", 
[17:38:13.650]                             "SOCK0node"))) {
[17:38:13.650]                             sendCondition <<- function(cond) {
[17:38:13.650]                               data <- list(type = "VALUE", value = cond, 
[17:38:13.650]                                 success = TRUE)
[17:38:13.650]                               parallel_sendData(master, data)
[17:38:13.650]                             }
[17:38:13.650]                             return(sendCondition)
[17:38:13.650]                           }
[17:38:13.650]                         }
[17:38:13.650]                         frame <- frame + 1L
[17:38:13.650]                         envir <- sys.frame(frame)
[17:38:13.650]                       }
[17:38:13.650]                     }
[17:38:13.650]                     sendCondition <<- function(cond) NULL
[17:38:13.650]                   }
[17:38:13.650]                 })
[17:38:13.650]                 withCallingHandlers({
[17:38:13.650]                   {
[17:38:13.650]                     do.call(function(...) {
[17:38:13.650]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.650]                       if (!identical(...future.globals.maxSize.org, 
[17:38:13.650]                         ...future.globals.maxSize)) {
[17:38:13.650]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.650]                         on.exit(options(oopts), add = TRUE)
[17:38:13.650]                       }
[17:38:13.650]                       {
[17:38:13.650]                         lapply(seq_along(...future.elements_ii), 
[17:38:13.650]                           FUN = function(jj) {
[17:38:13.650]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.650]                             ...future.FUN(...future.X_jj, ...)
[17:38:13.650]                           })
[17:38:13.650]                       }
[17:38:13.650]                     }, args = future.call.arguments)
[17:38:13.650]                   }
[17:38:13.650]                 }, immediateCondition = function(cond) {
[17:38:13.650]                   sendCondition <- ...future.makeSendCondition()
[17:38:13.650]                   sendCondition(cond)
[17:38:13.650]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.650]                   {
[17:38:13.650]                     inherits <- base::inherits
[17:38:13.650]                     invokeRestart <- base::invokeRestart
[17:38:13.650]                     is.null <- base::is.null
[17:38:13.650]                     muffled <- FALSE
[17:38:13.650]                     if (inherits(cond, "message")) {
[17:38:13.650]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:13.650]                       if (muffled) 
[17:38:13.650]                         invokeRestart("muffleMessage")
[17:38:13.650]                     }
[17:38:13.650]                     else if (inherits(cond, "warning")) {
[17:38:13.650]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:13.650]                       if (muffled) 
[17:38:13.650]                         invokeRestart("muffleWarning")
[17:38:13.650]                     }
[17:38:13.650]                     else if (inherits(cond, "condition")) {
[17:38:13.650]                       if (!is.null(pattern)) {
[17:38:13.650]                         computeRestarts <- base::computeRestarts
[17:38:13.650]                         grepl <- base::grepl
[17:38:13.650]                         restarts <- computeRestarts(cond)
[17:38:13.650]                         for (restart in restarts) {
[17:38:13.650]                           name <- restart$name
[17:38:13.650]                           if (is.null(name)) 
[17:38:13.650]                             next
[17:38:13.650]                           if (!grepl(pattern, name)) 
[17:38:13.650]                             next
[17:38:13.650]                           invokeRestart(restart)
[17:38:13.650]                           muffled <- TRUE
[17:38:13.650]                           break
[17:38:13.650]                         }
[17:38:13.650]                       }
[17:38:13.650]                     }
[17:38:13.650]                     invisible(muffled)
[17:38:13.650]                   }
[17:38:13.650]                   muffleCondition(cond)
[17:38:13.650]                 })
[17:38:13.650]             }))
[17:38:13.650]             future::FutureResult(value = ...future.value$value, 
[17:38:13.650]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:13.650]                   ...future.rng), globalenv = if (FALSE) 
[17:38:13.650]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:13.650]                     ...future.globalenv.names))
[17:38:13.650]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:13.650]         }, condition = base::local({
[17:38:13.650]             c <- base::c
[17:38:13.650]             inherits <- base::inherits
[17:38:13.650]             invokeRestart <- base::invokeRestart
[17:38:13.650]             length <- base::length
[17:38:13.650]             list <- base::list
[17:38:13.650]             seq.int <- base::seq.int
[17:38:13.650]             signalCondition <- base::signalCondition
[17:38:13.650]             sys.calls <- base::sys.calls
[17:38:13.650]             `[[` <- base::`[[`
[17:38:13.650]             `+` <- base::`+`
[17:38:13.650]             `<<-` <- base::`<<-`
[17:38:13.650]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:13.650]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:13.650]                   3L)]
[17:38:13.650]             }
[17:38:13.650]             function(cond) {
[17:38:13.650]                 is_error <- inherits(cond, "error")
[17:38:13.650]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:13.650]                   NULL)
[17:38:13.650]                 if (is_error) {
[17:38:13.650]                   sessionInformation <- function() {
[17:38:13.650]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:13.650]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:13.650]                       search = base::search(), system = base::Sys.info())
[17:38:13.650]                   }
[17:38:13.650]                   ...future.conditions[[length(...future.conditions) + 
[17:38:13.650]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:13.650]                     cond$call), session = sessionInformation(), 
[17:38:13.650]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:13.650]                   signalCondition(cond)
[17:38:13.650]                 }
[17:38:13.650]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:13.650]                 "immediateCondition"))) {
[17:38:13.650]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:13.650]                   ...future.conditions[[length(...future.conditions) + 
[17:38:13.650]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:13.650]                   if (TRUE && !signal) {
[17:38:13.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.650]                     {
[17:38:13.650]                       inherits <- base::inherits
[17:38:13.650]                       invokeRestart <- base::invokeRestart
[17:38:13.650]                       is.null <- base::is.null
[17:38:13.650]                       muffled <- FALSE
[17:38:13.650]                       if (inherits(cond, "message")) {
[17:38:13.650]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:13.650]                         if (muffled) 
[17:38:13.650]                           invokeRestart("muffleMessage")
[17:38:13.650]                       }
[17:38:13.650]                       else if (inherits(cond, "warning")) {
[17:38:13.650]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:13.650]                         if (muffled) 
[17:38:13.650]                           invokeRestart("muffleWarning")
[17:38:13.650]                       }
[17:38:13.650]                       else if (inherits(cond, "condition")) {
[17:38:13.650]                         if (!is.null(pattern)) {
[17:38:13.650]                           computeRestarts <- base::computeRestarts
[17:38:13.650]                           grepl <- base::grepl
[17:38:13.650]                           restarts <- computeRestarts(cond)
[17:38:13.650]                           for (restart in restarts) {
[17:38:13.650]                             name <- restart$name
[17:38:13.650]                             if (is.null(name)) 
[17:38:13.650]                               next
[17:38:13.650]                             if (!grepl(pattern, name)) 
[17:38:13.650]                               next
[17:38:13.650]                             invokeRestart(restart)
[17:38:13.650]                             muffled <- TRUE
[17:38:13.650]                             break
[17:38:13.650]                           }
[17:38:13.650]                         }
[17:38:13.650]                       }
[17:38:13.650]                       invisible(muffled)
[17:38:13.650]                     }
[17:38:13.650]                     muffleCondition(cond, pattern = "^muffle")
[17:38:13.650]                   }
[17:38:13.650]                 }
[17:38:13.650]                 else {
[17:38:13.650]                   if (TRUE) {
[17:38:13.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.650]                     {
[17:38:13.650]                       inherits <- base::inherits
[17:38:13.650]                       invokeRestart <- base::invokeRestart
[17:38:13.650]                       is.null <- base::is.null
[17:38:13.650]                       muffled <- FALSE
[17:38:13.650]                       if (inherits(cond, "message")) {
[17:38:13.650]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:13.650]                         if (muffled) 
[17:38:13.650]                           invokeRestart("muffleMessage")
[17:38:13.650]                       }
[17:38:13.650]                       else if (inherits(cond, "warning")) {
[17:38:13.650]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:13.650]                         if (muffled) 
[17:38:13.650]                           invokeRestart("muffleWarning")
[17:38:13.650]                       }
[17:38:13.650]                       else if (inherits(cond, "condition")) {
[17:38:13.650]                         if (!is.null(pattern)) {
[17:38:13.650]                           computeRestarts <- base::computeRestarts
[17:38:13.650]                           grepl <- base::grepl
[17:38:13.650]                           restarts <- computeRestarts(cond)
[17:38:13.650]                           for (restart in restarts) {
[17:38:13.650]                             name <- restart$name
[17:38:13.650]                             if (is.null(name)) 
[17:38:13.650]                               next
[17:38:13.650]                             if (!grepl(pattern, name)) 
[17:38:13.650]                               next
[17:38:13.650]                             invokeRestart(restart)
[17:38:13.650]                             muffled <- TRUE
[17:38:13.650]                             break
[17:38:13.650]                           }
[17:38:13.650]                         }
[17:38:13.650]                       }
[17:38:13.650]                       invisible(muffled)
[17:38:13.650]                     }
[17:38:13.650]                     muffleCondition(cond, pattern = "^muffle")
[17:38:13.650]                   }
[17:38:13.650]                 }
[17:38:13.650]             }
[17:38:13.650]         }))
[17:38:13.650]     }, error = function(ex) {
[17:38:13.650]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:13.650]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:13.650]                 ...future.rng), started = ...future.startTime, 
[17:38:13.650]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:13.650]             version = "1.8"), class = "FutureResult")
[17:38:13.650]     }, finally = {
[17:38:13.650]         if (!identical(...future.workdir, getwd())) 
[17:38:13.650]             setwd(...future.workdir)
[17:38:13.650]         {
[17:38:13.650]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:13.650]                 ...future.oldOptions$nwarnings <- NULL
[17:38:13.650]             }
[17:38:13.650]             base::options(...future.oldOptions)
[17:38:13.650]             if (.Platform$OS.type == "windows") {
[17:38:13.650]                 old_names <- names(...future.oldEnvVars)
[17:38:13.650]                 envs <- base::Sys.getenv()
[17:38:13.650]                 names <- names(envs)
[17:38:13.650]                 common <- intersect(names, old_names)
[17:38:13.650]                 added <- setdiff(names, old_names)
[17:38:13.650]                 removed <- setdiff(old_names, names)
[17:38:13.650]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:13.650]                   envs[common]]
[17:38:13.650]                 NAMES <- toupper(changed)
[17:38:13.650]                 args <- list()
[17:38:13.650]                 for (kk in seq_along(NAMES)) {
[17:38:13.650]                   name <- changed[[kk]]
[17:38:13.650]                   NAME <- NAMES[[kk]]
[17:38:13.650]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.650]                     next
[17:38:13.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:13.650]                 }
[17:38:13.650]                 NAMES <- toupper(added)
[17:38:13.650]                 for (kk in seq_along(NAMES)) {
[17:38:13.650]                   name <- added[[kk]]
[17:38:13.650]                   NAME <- NAMES[[kk]]
[17:38:13.650]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.650]                     next
[17:38:13.650]                   args[[name]] <- ""
[17:38:13.650]                 }
[17:38:13.650]                 NAMES <- toupper(removed)
[17:38:13.650]                 for (kk in seq_along(NAMES)) {
[17:38:13.650]                   name <- removed[[kk]]
[17:38:13.650]                   NAME <- NAMES[[kk]]
[17:38:13.650]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.650]                     next
[17:38:13.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:13.650]                 }
[17:38:13.650]                 if (length(args) > 0) 
[17:38:13.650]                   base::do.call(base::Sys.setenv, args = args)
[17:38:13.650]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:13.650]             }
[17:38:13.650]             else {
[17:38:13.650]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:13.650]             }
[17:38:13.650]             {
[17:38:13.650]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:13.650]                   0L) {
[17:38:13.650]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:13.650]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:13.650]                   base::options(opts)
[17:38:13.650]                 }
[17:38:13.650]                 {
[17:38:13.650]                   {
[17:38:13.650]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:13.650]                     NULL
[17:38:13.650]                   }
[17:38:13.650]                   options(future.plan = NULL)
[17:38:13.650]                   if (is.na(NA_character_)) 
[17:38:13.650]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:13.650]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:13.650]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:13.650]                     .init = FALSE)
[17:38:13.650]                 }
[17:38:13.650]             }
[17:38:13.650]         }
[17:38:13.650]     })
[17:38:13.650]     if (TRUE) {
[17:38:13.650]         base::sink(type = "output", split = FALSE)
[17:38:13.650]         if (TRUE) {
[17:38:13.650]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:13.650]         }
[17:38:13.650]         else {
[17:38:13.650]             ...future.result["stdout"] <- base::list(NULL)
[17:38:13.650]         }
[17:38:13.650]         base::close(...future.stdout)
[17:38:13.650]         ...future.stdout <- NULL
[17:38:13.650]     }
[17:38:13.650]     ...future.result$conditions <- ...future.conditions
[17:38:13.650]     ...future.result$finished <- base::Sys.time()
[17:38:13.650]     ...future.result
[17:38:13.650] }
[17:38:13.653] Exporting 11 global objects (93.29 KiB) to cluster node #2 ...
[17:38:13.653] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:38:13.697] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:38:13.697] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ...
[17:38:13.697] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:38:13.697] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:38:13.698] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:38:13.698] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:38:13.741] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:38:13.741] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:38:13.785] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:38:13.785] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:38:13.785] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:38:13.786] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:38:13.786] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:38:13.786] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:13.787] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:13.787] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ...
[17:38:13.787] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ... DONE
[17:38:13.787] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:13.788] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:13.788] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:13.788] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:13.788] Exporting 11 global objects (93.29 KiB) to cluster node #2 ... DONE
[17:38:13.789] MultisessionFuture started
[17:38:13.789] - Launch lazy future ... done
[17:38:13.789] run() for ‘MultisessionFuture’ ... done
[17:38:13.789] Created future:
[17:38:13.793] receiveMessageFromWorker() for ClusterFuture ...
[17:38:13.793] - Validating connection of MultisessionFuture
[17:38:13.793] - received message: FutureResult
[17:38:13.793] - Received FutureResult
[17:38:13.793] - Erased future from FutureRegistry
[17:38:13.793] result() for ClusterFuture ...
[17:38:13.794] - result already collected: FutureResult
[17:38:13.794] result() for ClusterFuture ... done
[17:38:13.794] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:13.789] MultisessionFuture:
[17:38:13.789] Label: ‘future_vapply-2’
[17:38:13.789] Expression:
[17:38:13.789] {
[17:38:13.789]     do.call(function(...) {
[17:38:13.789]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.789]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:13.789]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.789]             on.exit(options(oopts), add = TRUE)
[17:38:13.789]         }
[17:38:13.789]         {
[17:38:13.789]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:13.789]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.789]                 ...future.FUN(...future.X_jj, ...)
[17:38:13.789]             })
[17:38:13.789]         }
[17:38:13.789]     }, args = future.call.arguments)
[17:38:13.789] }
[17:38:13.789] Lazy evaluation: FALSE
[17:38:13.789] Asynchronous evaluation: TRUE
[17:38:13.789] Local evaluation: TRUE
[17:38:13.789] Environment: R_GlobalEnv
[17:38:13.789] Capture standard output: TRUE
[17:38:13.789] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:13.789] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:13.789] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:38:13.789] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:13.789] Resolved: TRUE
[17:38:13.789] Value: <not collected>
[17:38:13.789] Conditions captured: <none>
[17:38:13.789] Early signaling: FALSE
[17:38:13.789] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:13.789] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:13.794] Chunk #2 of 2 ... DONE
[17:38:13.794] Launching 2 futures (chunks) ... DONE
[17:38:13.794] Resolving 2 futures (chunks) ...
[17:38:13.794] resolve() on list ...
[17:38:13.794]  recursive: 0
[17:38:13.794]  length: 2
[17:38:13.795] 
[17:38:13.795] receiveMessageFromWorker() for ClusterFuture ...
[17:38:13.795] - Validating connection of MultisessionFuture
[17:38:13.795] - received message: FutureResult
[17:38:13.795] - Received FutureResult
[17:38:13.795] - Erased future from FutureRegistry
[17:38:13.796] result() for ClusterFuture ...
[17:38:13.796] - result already collected: FutureResult
[17:38:13.796] result() for ClusterFuture ... done
[17:38:13.796] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:13.796] Future #1
[17:38:13.796] result() for ClusterFuture ...
[17:38:13.796] - result already collected: FutureResult
[17:38:13.796] result() for ClusterFuture ... done
[17:38:13.796] result() for ClusterFuture ...
[17:38:13.796] - result already collected: FutureResult
[17:38:13.796] result() for ClusterFuture ... done
[17:38:13.797] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:13.797] - nx: 2
[17:38:13.797] - relay: TRUE
[17:38:13.797] - stdout: TRUE
[17:38:13.797] - signal: TRUE
[17:38:13.797] - resignal: FALSE
[17:38:13.797] - force: TRUE
[17:38:13.797] - relayed: [n=2] FALSE, FALSE
[17:38:13.797] - queued futures: [n=2] FALSE, FALSE
[17:38:13.797]  - until=1
[17:38:13.797]  - relaying element #1
[17:38:13.798] result() for ClusterFuture ...
[17:38:13.798] - result already collected: FutureResult
[17:38:13.798] result() for ClusterFuture ... done
[17:38:13.798] result() for ClusterFuture ...
[17:38:13.798] - result already collected: FutureResult
[17:38:13.798] result() for ClusterFuture ... done
[17:38:13.798] result() for ClusterFuture ...
[17:38:13.798] - result already collected: FutureResult
[17:38:13.798] result() for ClusterFuture ... done
[17:38:13.798] result() for ClusterFuture ...
[17:38:13.798] - result already collected: FutureResult
[17:38:13.798] result() for ClusterFuture ... done
[17:38:13.799] - relayed: [n=2] TRUE, FALSE
[17:38:13.799] - queued futures: [n=2] TRUE, FALSE
[17:38:13.799] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:13.799]  length: 1 (resolved future 1)
[17:38:13.799] Future #2
[17:38:13.799] result() for ClusterFuture ...
[17:38:13.799] - result already collected: FutureResult
[17:38:13.799] result() for ClusterFuture ... done
[17:38:13.799] result() for ClusterFuture ...
[17:38:13.799] - result already collected: FutureResult
[17:38:13.799] result() for ClusterFuture ... done
[17:38:13.800] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:13.800] - nx: 2
[17:38:13.800] - relay: TRUE
[17:38:13.800] - stdout: TRUE
[17:38:13.800] - signal: TRUE
[17:38:13.800] - resignal: FALSE
[17:38:13.800] - force: TRUE
[17:38:13.800] - relayed: [n=2] TRUE, FALSE
[17:38:13.800] - queued futures: [n=2] TRUE, FALSE
[17:38:13.800]  - until=2
[17:38:13.800]  - relaying element #2
[17:38:13.801] result() for ClusterFuture ...
[17:38:13.801] - result already collected: FutureResult
[17:38:13.801] result() for ClusterFuture ... done
[17:38:13.801] result() for ClusterFuture ...
[17:38:13.801] - result already collected: FutureResult
[17:38:13.801] result() for ClusterFuture ... done
[17:38:13.801] result() for ClusterFuture ...
[17:38:13.801] - result already collected: FutureResult
[17:38:13.801] result() for ClusterFuture ... done
[17:38:13.801] result() for ClusterFuture ...
[17:38:13.801] - result already collected: FutureResult
[17:38:13.801] result() for ClusterFuture ... done
[17:38:13.802] - relayed: [n=2] TRUE, TRUE
[17:38:13.802] - queued futures: [n=2] TRUE, TRUE
[17:38:13.802] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:13.802]  length: 0 (resolved future 2)
[17:38:13.802] Relaying remaining futures
[17:38:13.802] signalConditionsASAP(NULL, pos=0) ...
[17:38:13.802] - nx: 2
[17:38:13.802] - relay: TRUE
[17:38:13.802] - stdout: TRUE
[17:38:13.802] - signal: TRUE
[17:38:13.802] - resignal: FALSE
[17:38:13.802] - force: TRUE
[17:38:13.803] - relayed: [n=2] TRUE, TRUE
[17:38:13.803] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:13.803] - relayed: [n=2] TRUE, TRUE
[17:38:13.803] - queued futures: [n=2] TRUE, TRUE
[17:38:13.803] signalConditionsASAP(NULL, pos=0) ... done
[17:38:13.803] resolve() on list ... DONE
[17:38:13.803] result() for ClusterFuture ...
[17:38:13.803] - result already collected: FutureResult
[17:38:13.803] result() for ClusterFuture ... done
[17:38:13.803] result() for ClusterFuture ...
[17:38:13.803] - result already collected: FutureResult
[17:38:13.804] result() for ClusterFuture ... done
[17:38:13.804] result() for ClusterFuture ...
[17:38:13.804] - result already collected: FutureResult
[17:38:13.804] result() for ClusterFuture ... done
[17:38:13.804] result() for ClusterFuture ...
[17:38:13.804] - result already collected: FutureResult
[17:38:13.804] result() for ClusterFuture ... done
[17:38:13.804]  - Number of value chunks collected: 2
[17:38:13.804] Resolving 2 futures (chunks) ... DONE
[17:38:13.804] Reducing values from 2 chunks ...
[17:38:13.804]  - Number of values collected after concatenation: 3
[17:38:13.805]  - Number of values expected: 3
[17:38:13.805] Reducing values from 2 chunks ... DONE
[17:38:13.805] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[17:38:13.806] future_lapply() ...
[17:38:13.814] Number of chunks: 2
[17:38:13.814] getGlobalsAndPackagesXApply() ...
[17:38:13.814]  - future.globals: TRUE
[17:38:13.814] getGlobalsAndPackages() ...
[17:38:13.814] Searching for globals...
[17:38:13.819] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:38:13.819] Searching for globals ... DONE
[17:38:13.819] Resolving globals: FALSE
[17:38:13.820] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[17:38:13.820] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[17:38:13.820] - globals: [1] ‘FUN’
[17:38:13.820] - packages: [1] ‘stats’
[17:38:13.820] getGlobalsAndPackages() ... DONE
[17:38:13.820]  - globals found/used: [n=1] ‘FUN’
[17:38:13.820]  - needed namespaces: [n=1] ‘stats’
[17:38:13.821] Finding globals ... DONE
[17:38:13.821]  - use_args: TRUE
[17:38:13.821]  - Getting '...' globals ...
[17:38:13.821] resolve() on list ...
[17:38:13.821]  recursive: 0
[17:38:13.821]  length: 1
[17:38:13.821]  elements: ‘...’
[17:38:13.821]  length: 0 (resolved future 1)
[17:38:13.822] resolve() on list ... DONE
[17:38:13.822]    - '...' content: [n=0] 
[17:38:13.822] List of 1
[17:38:13.822]  $ ...: list()
[17:38:13.822]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:13.822]  - attr(*, "where")=List of 1
[17:38:13.822]   ..$ ...:<environment: 0x5608032e0598> 
[17:38:13.822]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:13.822]  - attr(*, "resolved")= logi TRUE
[17:38:13.822]  - attr(*, "total_size")= num NA
[17:38:13.824]  - Getting '...' globals ... DONE
[17:38:13.824] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:13.824] List of 2
[17:38:13.824]  $ ...future.FUN:function (x, na.rm = TRUE)  
[17:38:13.824]  $ ...          : list()
[17:38:13.824]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:13.824]  - attr(*, "where")=List of 2
[17:38:13.824]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:13.824]   ..$ ...          :<environment: 0x5608032e0598> 
[17:38:13.824]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:13.824]  - attr(*, "resolved")= logi FALSE
[17:38:13.824]  - attr(*, "total_size")= num 46960
[17:38:13.827] Packages to be attached in all futures: [n=1] ‘stats’
[17:38:13.827] getGlobalsAndPackagesXApply() ... DONE
[17:38:13.827] Number of futures (= number of chunks): 2
[17:38:13.827] Launching 2 futures (chunks) ...
[17:38:13.827] Chunk #1 of 2 ...
[17:38:13.828]  - Finding globals in 'X' for chunk #1 ...
[17:38:13.828] getGlobalsAndPackages() ...
[17:38:13.828] Searching for globals...
[17:38:13.828] 
[17:38:13.828] Searching for globals ... DONE
[17:38:13.828] - globals: [0] <none>
[17:38:13.828] getGlobalsAndPackages() ... DONE
[17:38:13.828]    + additional globals found: [n=0] 
[17:38:13.828]    + additional namespaces needed: [n=0] 
[17:38:13.829]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:13.829]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:13.829]  - seeds: <none>
[17:38:13.829]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.829] getGlobalsAndPackages() ...
[17:38:13.829] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.829] Resolving globals: FALSE
[17:38:13.829] Tweak future expression to call with '...' arguments ...
[17:38:13.829] {
[17:38:13.829]     do.call(function(...) {
[17:38:13.829]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.829]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:13.829]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.829]             on.exit(options(oopts), add = TRUE)
[17:38:13.829]         }
[17:38:13.829]         {
[17:38:13.829]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:13.829]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.829]                 ...future.FUN(...future.X_jj, ...)
[17:38:13.829]             })
[17:38:13.829]         }
[17:38:13.829]     }, args = future.call.arguments)
[17:38:13.829] }
[17:38:13.830] Tweak future expression to call with '...' arguments ... DONE
[17:38:13.830] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.830] - packages: [1] ‘stats’
[17:38:13.830] getGlobalsAndPackages() ... DONE
[17:38:13.830] run() for ‘Future’ ...
[17:38:13.830] - state: ‘created’
[17:38:13.831] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:13.845] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:13.845] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:13.845]   - Field: ‘node’
[17:38:13.845]   - Field: ‘label’
[17:38:13.845]   - Field: ‘local’
[17:38:13.845]   - Field: ‘owner’
[17:38:13.845]   - Field: ‘envir’
[17:38:13.845]   - Field: ‘workers’
[17:38:13.846]   - Field: ‘packages’
[17:38:13.846]   - Field: ‘gc’
[17:38:13.846]   - Field: ‘conditions’
[17:38:13.846]   - Field: ‘persistent’
[17:38:13.846]   - Field: ‘expr’
[17:38:13.846]   - Field: ‘uuid’
[17:38:13.846]   - Field: ‘seed’
[17:38:13.846]   - Field: ‘version’
[17:38:13.846]   - Field: ‘result’
[17:38:13.846]   - Field: ‘asynchronous’
[17:38:13.846]   - Field: ‘calls’
[17:38:13.847]   - Field: ‘globals’
[17:38:13.847]   - Field: ‘stdout’
[17:38:13.847]   - Field: ‘earlySignal’
[17:38:13.847]   - Field: ‘lazy’
[17:38:13.847]   - Field: ‘state’
[17:38:13.847] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:13.847] - Launch lazy future ...
[17:38:13.847] Packages needed by the future expression (n = 1): ‘stats’
[17:38:13.848] Packages needed by future strategies (n = 0): <none>
[17:38:13.848] {
[17:38:13.848]     {
[17:38:13.848]         {
[17:38:13.848]             ...future.startTime <- base::Sys.time()
[17:38:13.848]             {
[17:38:13.848]                 {
[17:38:13.848]                   {
[17:38:13.848]                     {
[17:38:13.848]                       {
[17:38:13.848]                         base::local({
[17:38:13.848]                           has_future <- base::requireNamespace("future", 
[17:38:13.848]                             quietly = TRUE)
[17:38:13.848]                           if (has_future) {
[17:38:13.848]                             ns <- base::getNamespace("future")
[17:38:13.848]                             version <- ns[[".package"]][["version"]]
[17:38:13.848]                             if (is.null(version)) 
[17:38:13.848]                               version <- utils::packageVersion("future")
[17:38:13.848]                           }
[17:38:13.848]                           else {
[17:38:13.848]                             version <- NULL
[17:38:13.848]                           }
[17:38:13.848]                           if (!has_future || version < "1.8.0") {
[17:38:13.848]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:13.848]                               "", base::R.version$version.string), 
[17:38:13.848]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:13.848]                                 base::R.version$platform, 8 * 
[17:38:13.848]                                   base::.Machine$sizeof.pointer), 
[17:38:13.848]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:13.848]                                 "release", "version")], collapse = " "), 
[17:38:13.848]                               hostname = base::Sys.info()[["nodename"]])
[17:38:13.848]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:13.848]                               info)
[17:38:13.848]                             info <- base::paste(info, collapse = "; ")
[17:38:13.848]                             if (!has_future) {
[17:38:13.848]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:13.848]                                 info)
[17:38:13.848]                             }
[17:38:13.848]                             else {
[17:38:13.848]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:13.848]                                 info, version)
[17:38:13.848]                             }
[17:38:13.848]                             base::stop(msg)
[17:38:13.848]                           }
[17:38:13.848]                         })
[17:38:13.848]                       }
[17:38:13.848]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:13.848]                       base::options(mc.cores = 1L)
[17:38:13.848]                     }
[17:38:13.848]                     base::local({
[17:38:13.848]                       for (pkg in "stats") {
[17:38:13.848]                         base::loadNamespace(pkg)
[17:38:13.848]                         base::library(pkg, character.only = TRUE)
[17:38:13.848]                       }
[17:38:13.848]                     })
[17:38:13.848]                   }
[17:38:13.848]                   ...future.strategy.old <- future::plan("list")
[17:38:13.848]                   options(future.plan = NULL)
[17:38:13.848]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:13.848]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:13.848]                 }
[17:38:13.848]                 ...future.workdir <- getwd()
[17:38:13.848]             }
[17:38:13.848]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:13.848]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:13.848]         }
[17:38:13.848]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:13.848]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:13.848]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:13.848]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:13.848]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:13.848]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:13.848]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:13.848]             base::names(...future.oldOptions))
[17:38:13.848]     }
[17:38:13.848]     if (FALSE) {
[17:38:13.848]     }
[17:38:13.848]     else {
[17:38:13.848]         if (TRUE) {
[17:38:13.848]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:13.848]                 open = "w")
[17:38:13.848]         }
[17:38:13.848]         else {
[17:38:13.848]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:13.848]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:13.848]         }
[17:38:13.848]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:13.848]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:13.848]             base::sink(type = "output", split = FALSE)
[17:38:13.848]             base::close(...future.stdout)
[17:38:13.848]         }, add = TRUE)
[17:38:13.848]     }
[17:38:13.848]     ...future.frame <- base::sys.nframe()
[17:38:13.848]     ...future.conditions <- base::list()
[17:38:13.848]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:13.848]     if (FALSE) {
[17:38:13.848]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:13.848]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:13.848]     }
[17:38:13.848]     ...future.result <- base::tryCatch({
[17:38:13.848]         base::withCallingHandlers({
[17:38:13.848]             ...future.value <- base::withVisible(base::local({
[17:38:13.848]                 ...future.makeSendCondition <- base::local({
[17:38:13.848]                   sendCondition <- NULL
[17:38:13.848]                   function(frame = 1L) {
[17:38:13.848]                     if (is.function(sendCondition)) 
[17:38:13.848]                       return(sendCondition)
[17:38:13.848]                     ns <- getNamespace("parallel")
[17:38:13.848]                     if (exists("sendData", mode = "function", 
[17:38:13.848]                       envir = ns)) {
[17:38:13.848]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:13.848]                         envir = ns)
[17:38:13.848]                       envir <- sys.frame(frame)
[17:38:13.848]                       master <- NULL
[17:38:13.848]                       while (!identical(envir, .GlobalEnv) && 
[17:38:13.848]                         !identical(envir, emptyenv())) {
[17:38:13.848]                         if (exists("master", mode = "list", envir = envir, 
[17:38:13.848]                           inherits = FALSE)) {
[17:38:13.848]                           master <- get("master", mode = "list", 
[17:38:13.848]                             envir = envir, inherits = FALSE)
[17:38:13.848]                           if (inherits(master, c("SOCKnode", 
[17:38:13.848]                             "SOCK0node"))) {
[17:38:13.848]                             sendCondition <<- function(cond) {
[17:38:13.848]                               data <- list(type = "VALUE", value = cond, 
[17:38:13.848]                                 success = TRUE)
[17:38:13.848]                               parallel_sendData(master, data)
[17:38:13.848]                             }
[17:38:13.848]                             return(sendCondition)
[17:38:13.848]                           }
[17:38:13.848]                         }
[17:38:13.848]                         frame <- frame + 1L
[17:38:13.848]                         envir <- sys.frame(frame)
[17:38:13.848]                       }
[17:38:13.848]                     }
[17:38:13.848]                     sendCondition <<- function(cond) NULL
[17:38:13.848]                   }
[17:38:13.848]                 })
[17:38:13.848]                 withCallingHandlers({
[17:38:13.848]                   {
[17:38:13.848]                     do.call(function(...) {
[17:38:13.848]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.848]                       if (!identical(...future.globals.maxSize.org, 
[17:38:13.848]                         ...future.globals.maxSize)) {
[17:38:13.848]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.848]                         on.exit(options(oopts), add = TRUE)
[17:38:13.848]                       }
[17:38:13.848]                       {
[17:38:13.848]                         lapply(seq_along(...future.elements_ii), 
[17:38:13.848]                           FUN = function(jj) {
[17:38:13.848]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.848]                             ...future.FUN(...future.X_jj, ...)
[17:38:13.848]                           })
[17:38:13.848]                       }
[17:38:13.848]                     }, args = future.call.arguments)
[17:38:13.848]                   }
[17:38:13.848]                 }, immediateCondition = function(cond) {
[17:38:13.848]                   sendCondition <- ...future.makeSendCondition()
[17:38:13.848]                   sendCondition(cond)
[17:38:13.848]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.848]                   {
[17:38:13.848]                     inherits <- base::inherits
[17:38:13.848]                     invokeRestart <- base::invokeRestart
[17:38:13.848]                     is.null <- base::is.null
[17:38:13.848]                     muffled <- FALSE
[17:38:13.848]                     if (inherits(cond, "message")) {
[17:38:13.848]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:13.848]                       if (muffled) 
[17:38:13.848]                         invokeRestart("muffleMessage")
[17:38:13.848]                     }
[17:38:13.848]                     else if (inherits(cond, "warning")) {
[17:38:13.848]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:13.848]                       if (muffled) 
[17:38:13.848]                         invokeRestart("muffleWarning")
[17:38:13.848]                     }
[17:38:13.848]                     else if (inherits(cond, "condition")) {
[17:38:13.848]                       if (!is.null(pattern)) {
[17:38:13.848]                         computeRestarts <- base::computeRestarts
[17:38:13.848]                         grepl <- base::grepl
[17:38:13.848]                         restarts <- computeRestarts(cond)
[17:38:13.848]                         for (restart in restarts) {
[17:38:13.848]                           name <- restart$name
[17:38:13.848]                           if (is.null(name)) 
[17:38:13.848]                             next
[17:38:13.848]                           if (!grepl(pattern, name)) 
[17:38:13.848]                             next
[17:38:13.848]                           invokeRestart(restart)
[17:38:13.848]                           muffled <- TRUE
[17:38:13.848]                           break
[17:38:13.848]                         }
[17:38:13.848]                       }
[17:38:13.848]                     }
[17:38:13.848]                     invisible(muffled)
[17:38:13.848]                   }
[17:38:13.848]                   muffleCondition(cond)
[17:38:13.848]                 })
[17:38:13.848]             }))
[17:38:13.848]             future::FutureResult(value = ...future.value$value, 
[17:38:13.848]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:13.848]                   ...future.rng), globalenv = if (FALSE) 
[17:38:13.848]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:13.848]                     ...future.globalenv.names))
[17:38:13.848]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:13.848]         }, condition = base::local({
[17:38:13.848]             c <- base::c
[17:38:13.848]             inherits <- base::inherits
[17:38:13.848]             invokeRestart <- base::invokeRestart
[17:38:13.848]             length <- base::length
[17:38:13.848]             list <- base::list
[17:38:13.848]             seq.int <- base::seq.int
[17:38:13.848]             signalCondition <- base::signalCondition
[17:38:13.848]             sys.calls <- base::sys.calls
[17:38:13.848]             `[[` <- base::`[[`
[17:38:13.848]             `+` <- base::`+`
[17:38:13.848]             `<<-` <- base::`<<-`
[17:38:13.848]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:13.848]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:13.848]                   3L)]
[17:38:13.848]             }
[17:38:13.848]             function(cond) {
[17:38:13.848]                 is_error <- inherits(cond, "error")
[17:38:13.848]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:13.848]                   NULL)
[17:38:13.848]                 if (is_error) {
[17:38:13.848]                   sessionInformation <- function() {
[17:38:13.848]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:13.848]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:13.848]                       search = base::search(), system = base::Sys.info())
[17:38:13.848]                   }
[17:38:13.848]                   ...future.conditions[[length(...future.conditions) + 
[17:38:13.848]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:13.848]                     cond$call), session = sessionInformation(), 
[17:38:13.848]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:13.848]                   signalCondition(cond)
[17:38:13.848]                 }
[17:38:13.848]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:13.848]                 "immediateCondition"))) {
[17:38:13.848]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:13.848]                   ...future.conditions[[length(...future.conditions) + 
[17:38:13.848]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:13.848]                   if (TRUE && !signal) {
[17:38:13.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.848]                     {
[17:38:13.848]                       inherits <- base::inherits
[17:38:13.848]                       invokeRestart <- base::invokeRestart
[17:38:13.848]                       is.null <- base::is.null
[17:38:13.848]                       muffled <- FALSE
[17:38:13.848]                       if (inherits(cond, "message")) {
[17:38:13.848]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:13.848]                         if (muffled) 
[17:38:13.848]                           invokeRestart("muffleMessage")
[17:38:13.848]                       }
[17:38:13.848]                       else if (inherits(cond, "warning")) {
[17:38:13.848]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:13.848]                         if (muffled) 
[17:38:13.848]                           invokeRestart("muffleWarning")
[17:38:13.848]                       }
[17:38:13.848]                       else if (inherits(cond, "condition")) {
[17:38:13.848]                         if (!is.null(pattern)) {
[17:38:13.848]                           computeRestarts <- base::computeRestarts
[17:38:13.848]                           grepl <- base::grepl
[17:38:13.848]                           restarts <- computeRestarts(cond)
[17:38:13.848]                           for (restart in restarts) {
[17:38:13.848]                             name <- restart$name
[17:38:13.848]                             if (is.null(name)) 
[17:38:13.848]                               next
[17:38:13.848]                             if (!grepl(pattern, name)) 
[17:38:13.848]                               next
[17:38:13.848]                             invokeRestart(restart)
[17:38:13.848]                             muffled <- TRUE
[17:38:13.848]                             break
[17:38:13.848]                           }
[17:38:13.848]                         }
[17:38:13.848]                       }
[17:38:13.848]                       invisible(muffled)
[17:38:13.848]                     }
[17:38:13.848]                     muffleCondition(cond, pattern = "^muffle")
[17:38:13.848]                   }
[17:38:13.848]                 }
[17:38:13.848]                 else {
[17:38:13.848]                   if (TRUE) {
[17:38:13.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.848]                     {
[17:38:13.848]                       inherits <- base::inherits
[17:38:13.848]                       invokeRestart <- base::invokeRestart
[17:38:13.848]                       is.null <- base::is.null
[17:38:13.848]                       muffled <- FALSE
[17:38:13.848]                       if (inherits(cond, "message")) {
[17:38:13.848]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:13.848]                         if (muffled) 
[17:38:13.848]                           invokeRestart("muffleMessage")
[17:38:13.848]                       }
[17:38:13.848]                       else if (inherits(cond, "warning")) {
[17:38:13.848]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:13.848]                         if (muffled) 
[17:38:13.848]                           invokeRestart("muffleWarning")
[17:38:13.848]                       }
[17:38:13.848]                       else if (inherits(cond, "condition")) {
[17:38:13.848]                         if (!is.null(pattern)) {
[17:38:13.848]                           computeRestarts <- base::computeRestarts
[17:38:13.848]                           grepl <- base::grepl
[17:38:13.848]                           restarts <- computeRestarts(cond)
[17:38:13.848]                           for (restart in restarts) {
[17:38:13.848]                             name <- restart$name
[17:38:13.848]                             if (is.null(name)) 
[17:38:13.848]                               next
[17:38:13.848]                             if (!grepl(pattern, name)) 
[17:38:13.848]                               next
[17:38:13.848]                             invokeRestart(restart)
[17:38:13.848]                             muffled <- TRUE
[17:38:13.848]                             break
[17:38:13.848]                           }
[17:38:13.848]                         }
[17:38:13.848]                       }
[17:38:13.848]                       invisible(muffled)
[17:38:13.848]                     }
[17:38:13.848]                     muffleCondition(cond, pattern = "^muffle")
[17:38:13.848]                   }
[17:38:13.848]                 }
[17:38:13.848]             }
[17:38:13.848]         }))
[17:38:13.848]     }, error = function(ex) {
[17:38:13.848]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:13.848]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:13.848]                 ...future.rng), started = ...future.startTime, 
[17:38:13.848]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:13.848]             version = "1.8"), class = "FutureResult")
[17:38:13.848]     }, finally = {
[17:38:13.848]         if (!identical(...future.workdir, getwd())) 
[17:38:13.848]             setwd(...future.workdir)
[17:38:13.848]         {
[17:38:13.848]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:13.848]                 ...future.oldOptions$nwarnings <- NULL
[17:38:13.848]             }
[17:38:13.848]             base::options(...future.oldOptions)
[17:38:13.848]             if (.Platform$OS.type == "windows") {
[17:38:13.848]                 old_names <- names(...future.oldEnvVars)
[17:38:13.848]                 envs <- base::Sys.getenv()
[17:38:13.848]                 names <- names(envs)
[17:38:13.848]                 common <- intersect(names, old_names)
[17:38:13.848]                 added <- setdiff(names, old_names)
[17:38:13.848]                 removed <- setdiff(old_names, names)
[17:38:13.848]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:13.848]                   envs[common]]
[17:38:13.848]                 NAMES <- toupper(changed)
[17:38:13.848]                 args <- list()
[17:38:13.848]                 for (kk in seq_along(NAMES)) {
[17:38:13.848]                   name <- changed[[kk]]
[17:38:13.848]                   NAME <- NAMES[[kk]]
[17:38:13.848]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.848]                     next
[17:38:13.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:13.848]                 }
[17:38:13.848]                 NAMES <- toupper(added)
[17:38:13.848]                 for (kk in seq_along(NAMES)) {
[17:38:13.848]                   name <- added[[kk]]
[17:38:13.848]                   NAME <- NAMES[[kk]]
[17:38:13.848]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.848]                     next
[17:38:13.848]                   args[[name]] <- ""
[17:38:13.848]                 }
[17:38:13.848]                 NAMES <- toupper(removed)
[17:38:13.848]                 for (kk in seq_along(NAMES)) {
[17:38:13.848]                   name <- removed[[kk]]
[17:38:13.848]                   NAME <- NAMES[[kk]]
[17:38:13.848]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.848]                     next
[17:38:13.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:13.848]                 }
[17:38:13.848]                 if (length(args) > 0) 
[17:38:13.848]                   base::do.call(base::Sys.setenv, args = args)
[17:38:13.848]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:13.848]             }
[17:38:13.848]             else {
[17:38:13.848]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:13.848]             }
[17:38:13.848]             {
[17:38:13.848]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:13.848]                   0L) {
[17:38:13.848]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:13.848]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:13.848]                   base::options(opts)
[17:38:13.848]                 }
[17:38:13.848]                 {
[17:38:13.848]                   {
[17:38:13.848]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:13.848]                     NULL
[17:38:13.848]                   }
[17:38:13.848]                   options(future.plan = NULL)
[17:38:13.848]                   if (is.na(NA_character_)) 
[17:38:13.848]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:13.848]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:13.848]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:13.848]                     .init = FALSE)
[17:38:13.848]                 }
[17:38:13.848]             }
[17:38:13.848]         }
[17:38:13.848]     })
[17:38:13.848]     if (TRUE) {
[17:38:13.848]         base::sink(type = "output", split = FALSE)
[17:38:13.848]         if (TRUE) {
[17:38:13.848]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:13.848]         }
[17:38:13.848]         else {
[17:38:13.848]             ...future.result["stdout"] <- base::list(NULL)
[17:38:13.848]         }
[17:38:13.848]         base::close(...future.stdout)
[17:38:13.848]         ...future.stdout <- NULL
[17:38:13.848]     }
[17:38:13.848]     ...future.result$conditions <- ...future.conditions
[17:38:13.848]     ...future.result$finished <- base::Sys.time()
[17:38:13.848]     ...future.result
[17:38:13.848] }
[17:38:13.851] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[17:38:13.851] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[17:38:13.893] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[17:38:13.893] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:13.894] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:13.894] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[17:38:13.894] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[17:38:13.894] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:13.894] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:13.895] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:13.895] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:13.895] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[17:38:13.896] MultisessionFuture started
[17:38:13.896] - Launch lazy future ... done
[17:38:13.896] run() for ‘MultisessionFuture’ ... done
[17:38:13.896] Created future:
[17:38:13.896] MultisessionFuture:
[17:38:13.896] Label: ‘future_sapply-1’
[17:38:13.896] Expression:
[17:38:13.896] {
[17:38:13.896]     do.call(function(...) {
[17:38:13.896]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.896]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:13.896]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.896]             on.exit(options(oopts), add = TRUE)
[17:38:13.896]         }
[17:38:13.896]         {
[17:38:13.896]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:13.896]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.896]                 ...future.FUN(...future.X_jj, ...)
[17:38:13.896]             })
[17:38:13.896]         }
[17:38:13.896]     }, args = future.call.arguments)
[17:38:13.896] }
[17:38:13.896] Lazy evaluation: FALSE
[17:38:13.896] Asynchronous evaluation: TRUE
[17:38:13.896] Local evaluation: TRUE
[17:38:13.896] Environment: R_GlobalEnv
[17:38:13.896] Capture standard output: TRUE
[17:38:13.896] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:13.896] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:13.896] Packages: 1 packages (‘stats’)
[17:38:13.896] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:13.896] Resolved: FALSE
[17:38:13.896] Value: <not collected>
[17:38:13.896] Conditions captured: <none>
[17:38:13.896] Early signaling: FALSE
[17:38:13.896] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:13.896] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:13.908] Chunk #1 of 2 ... DONE
[17:38:13.908] Chunk #2 of 2 ...
[17:38:13.908]  - Finding globals in 'X' for chunk #2 ...
[17:38:13.908] getGlobalsAndPackages() ...
[17:38:13.908] Searching for globals...
[17:38:13.908] 
[17:38:13.908] Searching for globals ... DONE
[17:38:13.909] - globals: [0] <none>
[17:38:13.909] getGlobalsAndPackages() ... DONE
[17:38:13.909]    + additional globals found: [n=0] 
[17:38:13.909]    + additional namespaces needed: [n=0] 
[17:38:13.909]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:13.909]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:13.909]  - seeds: <none>
[17:38:13.909]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.909] getGlobalsAndPackages() ...
[17:38:13.909] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.909] Resolving globals: FALSE
[17:38:13.910] Tweak future expression to call with '...' arguments ...
[17:38:13.910] {
[17:38:13.910]     do.call(function(...) {
[17:38:13.910]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.910]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:13.910]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.910]             on.exit(options(oopts), add = TRUE)
[17:38:13.910]         }
[17:38:13.910]         {
[17:38:13.910]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:13.910]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.910]                 ...future.FUN(...future.X_jj, ...)
[17:38:13.910]             })
[17:38:13.910]         }
[17:38:13.910]     }, args = future.call.arguments)
[17:38:13.910] }
[17:38:13.910] Tweak future expression to call with '...' arguments ... DONE
[17:38:13.910] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:13.910] - packages: [1] ‘stats’
[17:38:13.911] getGlobalsAndPackages() ... DONE
[17:38:13.911] run() for ‘Future’ ...
[17:38:13.911] - state: ‘created’
[17:38:13.911] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:13.925] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:13.926] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:13.926]   - Field: ‘node’
[17:38:13.926]   - Field: ‘label’
[17:38:13.926]   - Field: ‘local’
[17:38:13.926]   - Field: ‘owner’
[17:38:13.926]   - Field: ‘envir’
[17:38:13.926]   - Field: ‘workers’
[17:38:13.926]   - Field: ‘packages’
[17:38:13.926]   - Field: ‘gc’
[17:38:13.927]   - Field: ‘conditions’
[17:38:13.927]   - Field: ‘persistent’
[17:38:13.929]   - Field: ‘expr’
[17:38:13.929]   - Field: ‘uuid’
[17:38:13.929]   - Field: ‘seed’
[17:38:13.929]   - Field: ‘version’
[17:38:13.929]   - Field: ‘result’
[17:38:13.930]   - Field: ‘asynchronous’
[17:38:13.930]   - Field: ‘calls’
[17:38:13.930]   - Field: ‘globals’
[17:38:13.930]   - Field: ‘stdout’
[17:38:13.930]   - Field: ‘earlySignal’
[17:38:13.930]   - Field: ‘lazy’
[17:38:13.930]   - Field: ‘state’
[17:38:13.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:13.930] - Launch lazy future ...
[17:38:13.931] Packages needed by the future expression (n = 1): ‘stats’
[17:38:13.931] Packages needed by future strategies (n = 0): <none>
[17:38:13.931] {
[17:38:13.931]     {
[17:38:13.931]         {
[17:38:13.931]             ...future.startTime <- base::Sys.time()
[17:38:13.931]             {
[17:38:13.931]                 {
[17:38:13.931]                   {
[17:38:13.931]                     {
[17:38:13.931]                       {
[17:38:13.931]                         base::local({
[17:38:13.931]                           has_future <- base::requireNamespace("future", 
[17:38:13.931]                             quietly = TRUE)
[17:38:13.931]                           if (has_future) {
[17:38:13.931]                             ns <- base::getNamespace("future")
[17:38:13.931]                             version <- ns[[".package"]][["version"]]
[17:38:13.931]                             if (is.null(version)) 
[17:38:13.931]                               version <- utils::packageVersion("future")
[17:38:13.931]                           }
[17:38:13.931]                           else {
[17:38:13.931]                             version <- NULL
[17:38:13.931]                           }
[17:38:13.931]                           if (!has_future || version < "1.8.0") {
[17:38:13.931]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:13.931]                               "", base::R.version$version.string), 
[17:38:13.931]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:13.931]                                 base::R.version$platform, 8 * 
[17:38:13.931]                                   base::.Machine$sizeof.pointer), 
[17:38:13.931]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:13.931]                                 "release", "version")], collapse = " "), 
[17:38:13.931]                               hostname = base::Sys.info()[["nodename"]])
[17:38:13.931]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:13.931]                               info)
[17:38:13.931]                             info <- base::paste(info, collapse = "; ")
[17:38:13.931]                             if (!has_future) {
[17:38:13.931]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:13.931]                                 info)
[17:38:13.931]                             }
[17:38:13.931]                             else {
[17:38:13.931]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:13.931]                                 info, version)
[17:38:13.931]                             }
[17:38:13.931]                             base::stop(msg)
[17:38:13.931]                           }
[17:38:13.931]                         })
[17:38:13.931]                       }
[17:38:13.931]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:13.931]                       base::options(mc.cores = 1L)
[17:38:13.931]                     }
[17:38:13.931]                     base::local({
[17:38:13.931]                       for (pkg in "stats") {
[17:38:13.931]                         base::loadNamespace(pkg)
[17:38:13.931]                         base::library(pkg, character.only = TRUE)
[17:38:13.931]                       }
[17:38:13.931]                     })
[17:38:13.931]                   }
[17:38:13.931]                   ...future.strategy.old <- future::plan("list")
[17:38:13.931]                   options(future.plan = NULL)
[17:38:13.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:13.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:13.931]                 }
[17:38:13.931]                 ...future.workdir <- getwd()
[17:38:13.931]             }
[17:38:13.931]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:13.931]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:13.931]         }
[17:38:13.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:13.931]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:13.931]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:13.931]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:13.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:13.931]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:13.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:13.931]             base::names(...future.oldOptions))
[17:38:13.931]     }
[17:38:13.931]     if (FALSE) {
[17:38:13.931]     }
[17:38:13.931]     else {
[17:38:13.931]         if (TRUE) {
[17:38:13.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:13.931]                 open = "w")
[17:38:13.931]         }
[17:38:13.931]         else {
[17:38:13.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:13.931]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:13.931]         }
[17:38:13.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:13.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:13.931]             base::sink(type = "output", split = FALSE)
[17:38:13.931]             base::close(...future.stdout)
[17:38:13.931]         }, add = TRUE)
[17:38:13.931]     }
[17:38:13.931]     ...future.frame <- base::sys.nframe()
[17:38:13.931]     ...future.conditions <- base::list()
[17:38:13.931]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:13.931]     if (FALSE) {
[17:38:13.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:13.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:13.931]     }
[17:38:13.931]     ...future.result <- base::tryCatch({
[17:38:13.931]         base::withCallingHandlers({
[17:38:13.931]             ...future.value <- base::withVisible(base::local({
[17:38:13.931]                 ...future.makeSendCondition <- base::local({
[17:38:13.931]                   sendCondition <- NULL
[17:38:13.931]                   function(frame = 1L) {
[17:38:13.931]                     if (is.function(sendCondition)) 
[17:38:13.931]                       return(sendCondition)
[17:38:13.931]                     ns <- getNamespace("parallel")
[17:38:13.931]                     if (exists("sendData", mode = "function", 
[17:38:13.931]                       envir = ns)) {
[17:38:13.931]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:13.931]                         envir = ns)
[17:38:13.931]                       envir <- sys.frame(frame)
[17:38:13.931]                       master <- NULL
[17:38:13.931]                       while (!identical(envir, .GlobalEnv) && 
[17:38:13.931]                         !identical(envir, emptyenv())) {
[17:38:13.931]                         if (exists("master", mode = "list", envir = envir, 
[17:38:13.931]                           inherits = FALSE)) {
[17:38:13.931]                           master <- get("master", mode = "list", 
[17:38:13.931]                             envir = envir, inherits = FALSE)
[17:38:13.931]                           if (inherits(master, c("SOCKnode", 
[17:38:13.931]                             "SOCK0node"))) {
[17:38:13.931]                             sendCondition <<- function(cond) {
[17:38:13.931]                               data <- list(type = "VALUE", value = cond, 
[17:38:13.931]                                 success = TRUE)
[17:38:13.931]                               parallel_sendData(master, data)
[17:38:13.931]                             }
[17:38:13.931]                             return(sendCondition)
[17:38:13.931]                           }
[17:38:13.931]                         }
[17:38:13.931]                         frame <- frame + 1L
[17:38:13.931]                         envir <- sys.frame(frame)
[17:38:13.931]                       }
[17:38:13.931]                     }
[17:38:13.931]                     sendCondition <<- function(cond) NULL
[17:38:13.931]                   }
[17:38:13.931]                 })
[17:38:13.931]                 withCallingHandlers({
[17:38:13.931]                   {
[17:38:13.931]                     do.call(function(...) {
[17:38:13.931]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.931]                       if (!identical(...future.globals.maxSize.org, 
[17:38:13.931]                         ...future.globals.maxSize)) {
[17:38:13.931]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.931]                         on.exit(options(oopts), add = TRUE)
[17:38:13.931]                       }
[17:38:13.931]                       {
[17:38:13.931]                         lapply(seq_along(...future.elements_ii), 
[17:38:13.931]                           FUN = function(jj) {
[17:38:13.931]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.931]                             ...future.FUN(...future.X_jj, ...)
[17:38:13.931]                           })
[17:38:13.931]                       }
[17:38:13.931]                     }, args = future.call.arguments)
[17:38:13.931]                   }
[17:38:13.931]                 }, immediateCondition = function(cond) {
[17:38:13.931]                   sendCondition <- ...future.makeSendCondition()
[17:38:13.931]                   sendCondition(cond)
[17:38:13.931]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.931]                   {
[17:38:13.931]                     inherits <- base::inherits
[17:38:13.931]                     invokeRestart <- base::invokeRestart
[17:38:13.931]                     is.null <- base::is.null
[17:38:13.931]                     muffled <- FALSE
[17:38:13.931]                     if (inherits(cond, "message")) {
[17:38:13.931]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:13.931]                       if (muffled) 
[17:38:13.931]                         invokeRestart("muffleMessage")
[17:38:13.931]                     }
[17:38:13.931]                     else if (inherits(cond, "warning")) {
[17:38:13.931]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:13.931]                       if (muffled) 
[17:38:13.931]                         invokeRestart("muffleWarning")
[17:38:13.931]                     }
[17:38:13.931]                     else if (inherits(cond, "condition")) {
[17:38:13.931]                       if (!is.null(pattern)) {
[17:38:13.931]                         computeRestarts <- base::computeRestarts
[17:38:13.931]                         grepl <- base::grepl
[17:38:13.931]                         restarts <- computeRestarts(cond)
[17:38:13.931]                         for (restart in restarts) {
[17:38:13.931]                           name <- restart$name
[17:38:13.931]                           if (is.null(name)) 
[17:38:13.931]                             next
[17:38:13.931]                           if (!grepl(pattern, name)) 
[17:38:13.931]                             next
[17:38:13.931]                           invokeRestart(restart)
[17:38:13.931]                           muffled <- TRUE
[17:38:13.931]                           break
[17:38:13.931]                         }
[17:38:13.931]                       }
[17:38:13.931]                     }
[17:38:13.931]                     invisible(muffled)
[17:38:13.931]                   }
[17:38:13.931]                   muffleCondition(cond)
[17:38:13.931]                 })
[17:38:13.931]             }))
[17:38:13.931]             future::FutureResult(value = ...future.value$value, 
[17:38:13.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:13.931]                   ...future.rng), globalenv = if (FALSE) 
[17:38:13.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:13.931]                     ...future.globalenv.names))
[17:38:13.931]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:13.931]         }, condition = base::local({
[17:38:13.931]             c <- base::c
[17:38:13.931]             inherits <- base::inherits
[17:38:13.931]             invokeRestart <- base::invokeRestart
[17:38:13.931]             length <- base::length
[17:38:13.931]             list <- base::list
[17:38:13.931]             seq.int <- base::seq.int
[17:38:13.931]             signalCondition <- base::signalCondition
[17:38:13.931]             sys.calls <- base::sys.calls
[17:38:13.931]             `[[` <- base::`[[`
[17:38:13.931]             `+` <- base::`+`
[17:38:13.931]             `<<-` <- base::`<<-`
[17:38:13.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:13.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:13.931]                   3L)]
[17:38:13.931]             }
[17:38:13.931]             function(cond) {
[17:38:13.931]                 is_error <- inherits(cond, "error")
[17:38:13.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:13.931]                   NULL)
[17:38:13.931]                 if (is_error) {
[17:38:13.931]                   sessionInformation <- function() {
[17:38:13.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:13.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:13.931]                       search = base::search(), system = base::Sys.info())
[17:38:13.931]                   }
[17:38:13.931]                   ...future.conditions[[length(...future.conditions) + 
[17:38:13.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:13.931]                     cond$call), session = sessionInformation(), 
[17:38:13.931]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:13.931]                   signalCondition(cond)
[17:38:13.931]                 }
[17:38:13.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:13.931]                 "immediateCondition"))) {
[17:38:13.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:13.931]                   ...future.conditions[[length(...future.conditions) + 
[17:38:13.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:13.931]                   if (TRUE && !signal) {
[17:38:13.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.931]                     {
[17:38:13.931]                       inherits <- base::inherits
[17:38:13.931]                       invokeRestart <- base::invokeRestart
[17:38:13.931]                       is.null <- base::is.null
[17:38:13.931]                       muffled <- FALSE
[17:38:13.931]                       if (inherits(cond, "message")) {
[17:38:13.931]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:13.931]                         if (muffled) 
[17:38:13.931]                           invokeRestart("muffleMessage")
[17:38:13.931]                       }
[17:38:13.931]                       else if (inherits(cond, "warning")) {
[17:38:13.931]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:13.931]                         if (muffled) 
[17:38:13.931]                           invokeRestart("muffleWarning")
[17:38:13.931]                       }
[17:38:13.931]                       else if (inherits(cond, "condition")) {
[17:38:13.931]                         if (!is.null(pattern)) {
[17:38:13.931]                           computeRestarts <- base::computeRestarts
[17:38:13.931]                           grepl <- base::grepl
[17:38:13.931]                           restarts <- computeRestarts(cond)
[17:38:13.931]                           for (restart in restarts) {
[17:38:13.931]                             name <- restart$name
[17:38:13.931]                             if (is.null(name)) 
[17:38:13.931]                               next
[17:38:13.931]                             if (!grepl(pattern, name)) 
[17:38:13.931]                               next
[17:38:13.931]                             invokeRestart(restart)
[17:38:13.931]                             muffled <- TRUE
[17:38:13.931]                             break
[17:38:13.931]                           }
[17:38:13.931]                         }
[17:38:13.931]                       }
[17:38:13.931]                       invisible(muffled)
[17:38:13.931]                     }
[17:38:13.931]                     muffleCondition(cond, pattern = "^muffle")
[17:38:13.931]                   }
[17:38:13.931]                 }
[17:38:13.931]                 else {
[17:38:13.931]                   if (TRUE) {
[17:38:13.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:13.931]                     {
[17:38:13.931]                       inherits <- base::inherits
[17:38:13.931]                       invokeRestart <- base::invokeRestart
[17:38:13.931]                       is.null <- base::is.null
[17:38:13.931]                       muffled <- FALSE
[17:38:13.931]                       if (inherits(cond, "message")) {
[17:38:13.931]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:13.931]                         if (muffled) 
[17:38:13.931]                           invokeRestart("muffleMessage")
[17:38:13.931]                       }
[17:38:13.931]                       else if (inherits(cond, "warning")) {
[17:38:13.931]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:13.931]                         if (muffled) 
[17:38:13.931]                           invokeRestart("muffleWarning")
[17:38:13.931]                       }
[17:38:13.931]                       else if (inherits(cond, "condition")) {
[17:38:13.931]                         if (!is.null(pattern)) {
[17:38:13.931]                           computeRestarts <- base::computeRestarts
[17:38:13.931]                           grepl <- base::grepl
[17:38:13.931]                           restarts <- computeRestarts(cond)
[17:38:13.931]                           for (restart in restarts) {
[17:38:13.931]                             name <- restart$name
[17:38:13.931]                             if (is.null(name)) 
[17:38:13.931]                               next
[17:38:13.931]                             if (!grepl(pattern, name)) 
[17:38:13.931]                               next
[17:38:13.931]                             invokeRestart(restart)
[17:38:13.931]                             muffled <- TRUE
[17:38:13.931]                             break
[17:38:13.931]                           }
[17:38:13.931]                         }
[17:38:13.931]                       }
[17:38:13.931]                       invisible(muffled)
[17:38:13.931]                     }
[17:38:13.931]                     muffleCondition(cond, pattern = "^muffle")
[17:38:13.931]                   }
[17:38:13.931]                 }
[17:38:13.931]             }
[17:38:13.931]         }))
[17:38:13.931]     }, error = function(ex) {
[17:38:13.931]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:13.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:13.931]                 ...future.rng), started = ...future.startTime, 
[17:38:13.931]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:13.931]             version = "1.8"), class = "FutureResult")
[17:38:13.931]     }, finally = {
[17:38:13.931]         if (!identical(...future.workdir, getwd())) 
[17:38:13.931]             setwd(...future.workdir)
[17:38:13.931]         {
[17:38:13.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:13.931]                 ...future.oldOptions$nwarnings <- NULL
[17:38:13.931]             }
[17:38:13.931]             base::options(...future.oldOptions)
[17:38:13.931]             if (.Platform$OS.type == "windows") {
[17:38:13.931]                 old_names <- names(...future.oldEnvVars)
[17:38:13.931]                 envs <- base::Sys.getenv()
[17:38:13.931]                 names <- names(envs)
[17:38:13.931]                 common <- intersect(names, old_names)
[17:38:13.931]                 added <- setdiff(names, old_names)
[17:38:13.931]                 removed <- setdiff(old_names, names)
[17:38:13.931]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:13.931]                   envs[common]]
[17:38:13.931]                 NAMES <- toupper(changed)
[17:38:13.931]                 args <- list()
[17:38:13.931]                 for (kk in seq_along(NAMES)) {
[17:38:13.931]                   name <- changed[[kk]]
[17:38:13.931]                   NAME <- NAMES[[kk]]
[17:38:13.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.931]                     next
[17:38:13.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:13.931]                 }
[17:38:13.931]                 NAMES <- toupper(added)
[17:38:13.931]                 for (kk in seq_along(NAMES)) {
[17:38:13.931]                   name <- added[[kk]]
[17:38:13.931]                   NAME <- NAMES[[kk]]
[17:38:13.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.931]                     next
[17:38:13.931]                   args[[name]] <- ""
[17:38:13.931]                 }
[17:38:13.931]                 NAMES <- toupper(removed)
[17:38:13.931]                 for (kk in seq_along(NAMES)) {
[17:38:13.931]                   name <- removed[[kk]]
[17:38:13.931]                   NAME <- NAMES[[kk]]
[17:38:13.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:13.931]                     next
[17:38:13.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:13.931]                 }
[17:38:13.931]                 if (length(args) > 0) 
[17:38:13.931]                   base::do.call(base::Sys.setenv, args = args)
[17:38:13.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:13.931]             }
[17:38:13.931]             else {
[17:38:13.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:13.931]             }
[17:38:13.931]             {
[17:38:13.931]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:13.931]                   0L) {
[17:38:13.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:13.931]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:13.931]                   base::options(opts)
[17:38:13.931]                 }
[17:38:13.931]                 {
[17:38:13.931]                   {
[17:38:13.931]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:13.931]                     NULL
[17:38:13.931]                   }
[17:38:13.931]                   options(future.plan = NULL)
[17:38:13.931]                   if (is.na(NA_character_)) 
[17:38:13.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:13.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:13.931]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:13.931]                     .init = FALSE)
[17:38:13.931]                 }
[17:38:13.931]             }
[17:38:13.931]         }
[17:38:13.931]     })
[17:38:13.931]     if (TRUE) {
[17:38:13.931]         base::sink(type = "output", split = FALSE)
[17:38:13.931]         if (TRUE) {
[17:38:13.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:13.931]         }
[17:38:13.931]         else {
[17:38:13.931]             ...future.result["stdout"] <- base::list(NULL)
[17:38:13.931]         }
[17:38:13.931]         base::close(...future.stdout)
[17:38:13.931]         ...future.stdout <- NULL
[17:38:13.931]     }
[17:38:13.931]     ...future.result$conditions <- ...future.conditions
[17:38:13.931]     ...future.result$finished <- base::Sys.time()
[17:38:13.931]     ...future.result
[17:38:13.931] }
[17:38:13.934] Exporting 5 global objects (45.86 KiB) to cluster node #2 ...
[17:38:13.934] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ...
[17:38:13.977] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ... DONE
[17:38:13.977] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:13.977] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:13.978] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[17:38:13.978] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[17:38:13.978] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:13.978] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:13.979] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:13.979] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:13.979] Exporting 5 global objects (45.86 KiB) to cluster node #2 ... DONE
[17:38:13.979] MultisessionFuture started
[17:38:13.980] - Launch lazy future ... done
[17:38:13.980] run() for ‘MultisessionFuture’ ... done
[17:38:13.980] Created future:
[17:38:13.980] MultisessionFuture:
[17:38:13.980] Label: ‘future_sapply-2’
[17:38:13.980] Expression:
[17:38:13.980] {
[17:38:13.980]     do.call(function(...) {
[17:38:13.980]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:13.980]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:13.980]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:13.980]             on.exit(options(oopts), add = TRUE)
[17:38:13.980]         }
[17:38:13.980]         {
[17:38:13.980]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:13.980]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:13.980]                 ...future.FUN(...future.X_jj, ...)
[17:38:13.980]             })
[17:38:13.980]         }
[17:38:13.980]     }, args = future.call.arguments)
[17:38:13.980] }
[17:38:13.980] Lazy evaluation: FALSE
[17:38:13.980] Asynchronous evaluation: TRUE
[17:38:13.980] Local evaluation: TRUE
[17:38:13.980] Environment: R_GlobalEnv
[17:38:13.980] Capture standard output: TRUE
[17:38:13.980] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:13.980] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:13.980] Packages: 1 packages (‘stats’)
[17:38:13.980] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:13.980] Resolved: FALSE
[17:38:13.980] Value: <not collected>
[17:38:13.980] Conditions captured: <none>
[17:38:13.980] Early signaling: FALSE
[17:38:13.980] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:13.980] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:13.992] Chunk #2 of 2 ... DONE
[17:38:13.992] Launching 2 futures (chunks) ... DONE
[17:38:13.992] Resolving 2 futures (chunks) ...
[17:38:13.992] resolve() on list ...
[17:38:13.992]  recursive: 0
[17:38:13.992]  length: 2
[17:38:13.992] 
[17:38:13.993] receiveMessageFromWorker() for ClusterFuture ...
[17:38:13.993] - Validating connection of MultisessionFuture
[17:38:13.993] - received message: FutureResult
[17:38:13.993] - Received FutureResult
[17:38:13.993] - Erased future from FutureRegistry
[17:38:13.993] result() for ClusterFuture ...
[17:38:13.993] - result already collected: FutureResult
[17:38:13.993] result() for ClusterFuture ... done
[17:38:13.994] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:13.994] Future #1
[17:38:13.994] result() for ClusterFuture ...
[17:38:13.994] - result already collected: FutureResult
[17:38:13.994] result() for ClusterFuture ... done
[17:38:13.994] result() for ClusterFuture ...
[17:38:13.994] - result already collected: FutureResult
[17:38:13.994] result() for ClusterFuture ... done
[17:38:13.994] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:13.994] - nx: 2
[17:38:13.994] - relay: TRUE
[17:38:13.995] - stdout: TRUE
[17:38:13.995] - signal: TRUE
[17:38:13.995] - resignal: FALSE
[17:38:13.995] - force: TRUE
[17:38:13.995] - relayed: [n=2] FALSE, FALSE
[17:38:13.995] - queued futures: [n=2] FALSE, FALSE
[17:38:13.995]  - until=1
[17:38:13.995]  - relaying element #1
[17:38:13.995] result() for ClusterFuture ...
[17:38:13.995] - result already collected: FutureResult
[17:38:13.995] result() for ClusterFuture ... done
[17:38:13.995] result() for ClusterFuture ...
[17:38:13.996] - result already collected: FutureResult
[17:38:13.996] result() for ClusterFuture ... done
[17:38:13.996] result() for ClusterFuture ...
[17:38:13.996] - result already collected: FutureResult
[17:38:13.996] result() for ClusterFuture ... done
[17:38:13.996] result() for ClusterFuture ...
[17:38:13.996] - result already collected: FutureResult
[17:38:13.996] result() for ClusterFuture ... done
[17:38:13.996] - relayed: [n=2] TRUE, FALSE
[17:38:13.996] - queued futures: [n=2] TRUE, FALSE
[17:38:13.996] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:13.997]  length: 1 (resolved future 1)
[17:38:14.022] receiveMessageFromWorker() for ClusterFuture ...
[17:38:14.022] - Validating connection of MultisessionFuture
[17:38:14.023] - received message: FutureResult
[17:38:14.023] - Received FutureResult
[17:38:14.023] - Erased future from FutureRegistry
[17:38:14.023] result() for ClusterFuture ...
[17:38:14.023] - result already collected: FutureResult
[17:38:14.023] result() for ClusterFuture ... done
[17:38:14.023] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:14.023] Future #2
[17:38:14.023] result() for ClusterFuture ...
[17:38:14.023] - result already collected: FutureResult
[17:38:14.024] result() for ClusterFuture ... done
[17:38:14.024] result() for ClusterFuture ...
[17:38:14.024] - result already collected: FutureResult
[17:38:14.024] result() for ClusterFuture ... done
[17:38:14.024] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:14.024] - nx: 2
[17:38:14.024] - relay: TRUE
[17:38:14.024] - stdout: TRUE
[17:38:14.024] - signal: TRUE
[17:38:14.024] - resignal: FALSE
[17:38:14.024] - force: TRUE
[17:38:14.025] - relayed: [n=2] TRUE, FALSE
[17:38:14.025] - queued futures: [n=2] TRUE, FALSE
[17:38:14.025]  - until=2
[17:38:14.025]  - relaying element #2
[17:38:14.025] result() for ClusterFuture ...
[17:38:14.025] - result already collected: FutureResult
[17:38:14.025] result() for ClusterFuture ... done
[17:38:14.025] result() for ClusterFuture ...
[17:38:14.025] - result already collected: FutureResult
[17:38:14.025] result() for ClusterFuture ... done
[17:38:14.026] result() for ClusterFuture ...
[17:38:14.026] - result already collected: FutureResult
[17:38:14.026] result() for ClusterFuture ... done
[17:38:14.026] result() for ClusterFuture ...
[17:38:14.026] - result already collected: FutureResult
[17:38:14.026] result() for ClusterFuture ... done
[17:38:14.026] - relayed: [n=2] TRUE, TRUE
[17:38:14.026] - queued futures: [n=2] TRUE, TRUE
[17:38:14.026] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:14.026]  length: 0 (resolved future 2)
[17:38:14.026] Relaying remaining futures
[17:38:14.027] signalConditionsASAP(NULL, pos=0) ...
[17:38:14.027] - nx: 2
[17:38:14.027] - relay: TRUE
[17:38:14.027] - stdout: TRUE
[17:38:14.027] - signal: TRUE
[17:38:14.027] - resignal: FALSE
[17:38:14.027] - force: TRUE
[17:38:14.027] - relayed: [n=2] TRUE, TRUE
[17:38:14.027] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:14.027] - relayed: [n=2] TRUE, TRUE
[17:38:14.027] - queued futures: [n=2] TRUE, TRUE
[17:38:14.027] signalConditionsASAP(NULL, pos=0) ... done
[17:38:14.028] resolve() on list ... DONE
[17:38:14.028] result() for ClusterFuture ...
[17:38:14.028] - result already collected: FutureResult
[17:38:14.028] result() for ClusterFuture ... done
[17:38:14.028] result() for ClusterFuture ...
[17:38:14.028] - result already collected: FutureResult
[17:38:14.028] result() for ClusterFuture ... done
[17:38:14.028] result() for ClusterFuture ...
[17:38:14.028] - result already collected: FutureResult
[17:38:14.028] result() for ClusterFuture ... done
[17:38:14.029] result() for ClusterFuture ...
[17:38:14.029] - result already collected: FutureResult
[17:38:14.029] result() for ClusterFuture ... done
[17:38:14.029]  - Number of value chunks collected: 2
[17:38:14.029] Resolving 2 futures (chunks) ... DONE
[17:38:14.029] Reducing values from 2 chunks ...
[17:38:14.029]  - Number of values collected after concatenation: 7
[17:38:14.029]  - Number of values expected: 7
[17:38:14.029] Reducing values from 2 chunks ... DONE
[17:38:14.029] future_lapply() ... DONE
[17:38:14.030] future_lapply() ...
[17:38:14.035] Number of chunks: 2
[17:38:14.035] getGlobalsAndPackagesXApply() ...
[17:38:14.035]  - future.globals: TRUE
[17:38:14.036] getGlobalsAndPackages() ...
[17:38:14.036] Searching for globals...
[17:38:14.042] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:38:14.043] Searching for globals ... DONE
[17:38:14.043] Resolving globals: FALSE
[17:38:14.044] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[17:38:14.044] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[17:38:14.044] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:14.045] - packages: [2] ‘stats’, ‘future.apply’
[17:38:14.045] getGlobalsAndPackages() ... DONE
[17:38:14.045]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:14.045]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:38:14.045] Finding globals ... DONE
[17:38:14.045]  - use_args: TRUE
[17:38:14.045]  - Getting '...' globals ...
[17:38:14.046] resolve() on list ...
[17:38:14.046]  recursive: 0
[17:38:14.046]  length: 1
[17:38:14.046]  elements: ‘...’
[17:38:14.046]  length: 0 (resolved future 1)
[17:38:14.046] resolve() on list ... DONE
[17:38:14.046]    - '...' content: [n=0] 
[17:38:14.046] List of 1
[17:38:14.046]  $ ...: list()
[17:38:14.046]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:14.046]  - attr(*, "where")=List of 1
[17:38:14.046]   ..$ ...:<environment: 0x5607fff78138> 
[17:38:14.046]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:14.046]  - attr(*, "resolved")= logi TRUE
[17:38:14.046]  - attr(*, "total_size")= num NA
[17:38:14.049]  - Getting '...' globals ... DONE
[17:38:14.049] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:14.049] List of 8
[17:38:14.049]  $ ...future.FUN:function (x, ...)  
[17:38:14.049]  $ x_FUN        :function (x, na.rm = TRUE)  
[17:38:14.049]  $ times        : int 5
[17:38:14.049]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:14.049]  $ stop_if_not  :function (...)  
[17:38:14.049]  $ dim          : NULL
[17:38:14.049]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:14.049]  $ ...          : list()
[17:38:14.049]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:14.049]  - attr(*, "where")=List of 8
[17:38:14.049]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:14.049]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:14.049]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:14.049]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:14.049]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:14.049]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:14.049]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:14.049]   ..$ ...          :<environment: 0x5607fff78138> 
[17:38:14.049]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:14.049]  - attr(*, "resolved")= logi FALSE
[17:38:14.049]  - attr(*, "total_size")= num 141240
[17:38:14.054] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:38:14.054] getGlobalsAndPackagesXApply() ... DONE
[17:38:14.054] Number of futures (= number of chunks): 2
[17:38:14.054] Launching 2 futures (chunks) ...
[17:38:14.055] Chunk #1 of 2 ...
[17:38:14.055]  - Finding globals in 'X' for chunk #1 ...
[17:38:14.055] getGlobalsAndPackages() ...
[17:38:14.055] Searching for globals...
[17:38:14.055] 
[17:38:14.055] Searching for globals ... DONE
[17:38:14.055] - globals: [0] <none>
[17:38:14.055] getGlobalsAndPackages() ... DONE
[17:38:14.055]    + additional globals found: [n=0] 
[17:38:14.056]    + additional namespaces needed: [n=0] 
[17:38:14.056]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:14.056]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:14.056]  - seeds: <none>
[17:38:14.056]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.056] getGlobalsAndPackages() ...
[17:38:14.056] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.056] Resolving globals: FALSE
[17:38:14.056] Tweak future expression to call with '...' arguments ...
[17:38:14.056] {
[17:38:14.056]     do.call(function(...) {
[17:38:14.056]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.056]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:14.056]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.056]             on.exit(options(oopts), add = TRUE)
[17:38:14.056]         }
[17:38:14.056]         {
[17:38:14.056]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:14.056]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.056]                 ...future.FUN(...future.X_jj, ...)
[17:38:14.056]             })
[17:38:14.056]         }
[17:38:14.056]     }, args = future.call.arguments)
[17:38:14.056] }
[17:38:14.057] Tweak future expression to call with '...' arguments ... DONE
[17:38:14.057] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.057] - packages: [2] ‘stats’, ‘future.apply’
[17:38:14.057] getGlobalsAndPackages() ... DONE
[17:38:14.058] run() for ‘Future’ ...
[17:38:14.058] - state: ‘created’
[17:38:14.058] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:14.072] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:14.072] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:14.072]   - Field: ‘node’
[17:38:14.072]   - Field: ‘label’
[17:38:14.073]   - Field: ‘local’
[17:38:14.073]   - Field: ‘owner’
[17:38:14.073]   - Field: ‘envir’
[17:38:14.073]   - Field: ‘workers’
[17:38:14.073]   - Field: ‘packages’
[17:38:14.073]   - Field: ‘gc’
[17:38:14.073]   - Field: ‘conditions’
[17:38:14.073]   - Field: ‘persistent’
[17:38:14.073]   - Field: ‘expr’
[17:38:14.073]   - Field: ‘uuid’
[17:38:14.073]   - Field: ‘seed’
[17:38:14.074]   - Field: ‘version’
[17:38:14.074]   - Field: ‘result’
[17:38:14.074]   - Field: ‘asynchronous’
[17:38:14.074]   - Field: ‘calls’
[17:38:14.074]   - Field: ‘globals’
[17:38:14.074]   - Field: ‘stdout’
[17:38:14.074]   - Field: ‘earlySignal’
[17:38:14.074]   - Field: ‘lazy’
[17:38:14.074]   - Field: ‘state’
[17:38:14.074] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:14.074] - Launch lazy future ...
[17:38:14.075] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:38:14.075] Packages needed by future strategies (n = 0): <none>
[17:38:14.075] {
[17:38:14.075]     {
[17:38:14.075]         {
[17:38:14.075]             ...future.startTime <- base::Sys.time()
[17:38:14.075]             {
[17:38:14.075]                 {
[17:38:14.075]                   {
[17:38:14.075]                     {
[17:38:14.075]                       {
[17:38:14.075]                         base::local({
[17:38:14.075]                           has_future <- base::requireNamespace("future", 
[17:38:14.075]                             quietly = TRUE)
[17:38:14.075]                           if (has_future) {
[17:38:14.075]                             ns <- base::getNamespace("future")
[17:38:14.075]                             version <- ns[[".package"]][["version"]]
[17:38:14.075]                             if (is.null(version)) 
[17:38:14.075]                               version <- utils::packageVersion("future")
[17:38:14.075]                           }
[17:38:14.075]                           else {
[17:38:14.075]                             version <- NULL
[17:38:14.075]                           }
[17:38:14.075]                           if (!has_future || version < "1.8.0") {
[17:38:14.075]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:14.075]                               "", base::R.version$version.string), 
[17:38:14.075]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:14.075]                                 base::R.version$platform, 8 * 
[17:38:14.075]                                   base::.Machine$sizeof.pointer), 
[17:38:14.075]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:14.075]                                 "release", "version")], collapse = " "), 
[17:38:14.075]                               hostname = base::Sys.info()[["nodename"]])
[17:38:14.075]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:14.075]                               info)
[17:38:14.075]                             info <- base::paste(info, collapse = "; ")
[17:38:14.075]                             if (!has_future) {
[17:38:14.075]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:14.075]                                 info)
[17:38:14.075]                             }
[17:38:14.075]                             else {
[17:38:14.075]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:14.075]                                 info, version)
[17:38:14.075]                             }
[17:38:14.075]                             base::stop(msg)
[17:38:14.075]                           }
[17:38:14.075]                         })
[17:38:14.075]                       }
[17:38:14.075]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:14.075]                       base::options(mc.cores = 1L)
[17:38:14.075]                     }
[17:38:14.075]                     base::local({
[17:38:14.075]                       for (pkg in c("stats", "future.apply")) {
[17:38:14.075]                         base::loadNamespace(pkg)
[17:38:14.075]                         base::library(pkg, character.only = TRUE)
[17:38:14.075]                       }
[17:38:14.075]                     })
[17:38:14.075]                   }
[17:38:14.075]                   ...future.strategy.old <- future::plan("list")
[17:38:14.075]                   options(future.plan = NULL)
[17:38:14.075]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:14.075]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:14.075]                 }
[17:38:14.075]                 ...future.workdir <- getwd()
[17:38:14.075]             }
[17:38:14.075]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:14.075]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:14.075]         }
[17:38:14.075]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:14.075]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:14.075]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:14.075]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:14.075]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:14.075]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:14.075]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:14.075]             base::names(...future.oldOptions))
[17:38:14.075]     }
[17:38:14.075]     if (FALSE) {
[17:38:14.075]     }
[17:38:14.075]     else {
[17:38:14.075]         if (TRUE) {
[17:38:14.075]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:14.075]                 open = "w")
[17:38:14.075]         }
[17:38:14.075]         else {
[17:38:14.075]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:14.075]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:14.075]         }
[17:38:14.075]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:14.075]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:14.075]             base::sink(type = "output", split = FALSE)
[17:38:14.075]             base::close(...future.stdout)
[17:38:14.075]         }, add = TRUE)
[17:38:14.075]     }
[17:38:14.075]     ...future.frame <- base::sys.nframe()
[17:38:14.075]     ...future.conditions <- base::list()
[17:38:14.075]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:14.075]     if (FALSE) {
[17:38:14.075]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:14.075]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:14.075]     }
[17:38:14.075]     ...future.result <- base::tryCatch({
[17:38:14.075]         base::withCallingHandlers({
[17:38:14.075]             ...future.value <- base::withVisible(base::local({
[17:38:14.075]                 ...future.makeSendCondition <- base::local({
[17:38:14.075]                   sendCondition <- NULL
[17:38:14.075]                   function(frame = 1L) {
[17:38:14.075]                     if (is.function(sendCondition)) 
[17:38:14.075]                       return(sendCondition)
[17:38:14.075]                     ns <- getNamespace("parallel")
[17:38:14.075]                     if (exists("sendData", mode = "function", 
[17:38:14.075]                       envir = ns)) {
[17:38:14.075]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:14.075]                         envir = ns)
[17:38:14.075]                       envir <- sys.frame(frame)
[17:38:14.075]                       master <- NULL
[17:38:14.075]                       while (!identical(envir, .GlobalEnv) && 
[17:38:14.075]                         !identical(envir, emptyenv())) {
[17:38:14.075]                         if (exists("master", mode = "list", envir = envir, 
[17:38:14.075]                           inherits = FALSE)) {
[17:38:14.075]                           master <- get("master", mode = "list", 
[17:38:14.075]                             envir = envir, inherits = FALSE)
[17:38:14.075]                           if (inherits(master, c("SOCKnode", 
[17:38:14.075]                             "SOCK0node"))) {
[17:38:14.075]                             sendCondition <<- function(cond) {
[17:38:14.075]                               data <- list(type = "VALUE", value = cond, 
[17:38:14.075]                                 success = TRUE)
[17:38:14.075]                               parallel_sendData(master, data)
[17:38:14.075]                             }
[17:38:14.075]                             return(sendCondition)
[17:38:14.075]                           }
[17:38:14.075]                         }
[17:38:14.075]                         frame <- frame + 1L
[17:38:14.075]                         envir <- sys.frame(frame)
[17:38:14.075]                       }
[17:38:14.075]                     }
[17:38:14.075]                     sendCondition <<- function(cond) NULL
[17:38:14.075]                   }
[17:38:14.075]                 })
[17:38:14.075]                 withCallingHandlers({
[17:38:14.075]                   {
[17:38:14.075]                     do.call(function(...) {
[17:38:14.075]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.075]                       if (!identical(...future.globals.maxSize.org, 
[17:38:14.075]                         ...future.globals.maxSize)) {
[17:38:14.075]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.075]                         on.exit(options(oopts), add = TRUE)
[17:38:14.075]                       }
[17:38:14.075]                       {
[17:38:14.075]                         lapply(seq_along(...future.elements_ii), 
[17:38:14.075]                           FUN = function(jj) {
[17:38:14.075]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.075]                             ...future.FUN(...future.X_jj, ...)
[17:38:14.075]                           })
[17:38:14.075]                       }
[17:38:14.075]                     }, args = future.call.arguments)
[17:38:14.075]                   }
[17:38:14.075]                 }, immediateCondition = function(cond) {
[17:38:14.075]                   sendCondition <- ...future.makeSendCondition()
[17:38:14.075]                   sendCondition(cond)
[17:38:14.075]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.075]                   {
[17:38:14.075]                     inherits <- base::inherits
[17:38:14.075]                     invokeRestart <- base::invokeRestart
[17:38:14.075]                     is.null <- base::is.null
[17:38:14.075]                     muffled <- FALSE
[17:38:14.075]                     if (inherits(cond, "message")) {
[17:38:14.075]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:14.075]                       if (muffled) 
[17:38:14.075]                         invokeRestart("muffleMessage")
[17:38:14.075]                     }
[17:38:14.075]                     else if (inherits(cond, "warning")) {
[17:38:14.075]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:14.075]                       if (muffled) 
[17:38:14.075]                         invokeRestart("muffleWarning")
[17:38:14.075]                     }
[17:38:14.075]                     else if (inherits(cond, "condition")) {
[17:38:14.075]                       if (!is.null(pattern)) {
[17:38:14.075]                         computeRestarts <- base::computeRestarts
[17:38:14.075]                         grepl <- base::grepl
[17:38:14.075]                         restarts <- computeRestarts(cond)
[17:38:14.075]                         for (restart in restarts) {
[17:38:14.075]                           name <- restart$name
[17:38:14.075]                           if (is.null(name)) 
[17:38:14.075]                             next
[17:38:14.075]                           if (!grepl(pattern, name)) 
[17:38:14.075]                             next
[17:38:14.075]                           invokeRestart(restart)
[17:38:14.075]                           muffled <- TRUE
[17:38:14.075]                           break
[17:38:14.075]                         }
[17:38:14.075]                       }
[17:38:14.075]                     }
[17:38:14.075]                     invisible(muffled)
[17:38:14.075]                   }
[17:38:14.075]                   muffleCondition(cond)
[17:38:14.075]                 })
[17:38:14.075]             }))
[17:38:14.075]             future::FutureResult(value = ...future.value$value, 
[17:38:14.075]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:14.075]                   ...future.rng), globalenv = if (FALSE) 
[17:38:14.075]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:14.075]                     ...future.globalenv.names))
[17:38:14.075]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:14.075]         }, condition = base::local({
[17:38:14.075]             c <- base::c
[17:38:14.075]             inherits <- base::inherits
[17:38:14.075]             invokeRestart <- base::invokeRestart
[17:38:14.075]             length <- base::length
[17:38:14.075]             list <- base::list
[17:38:14.075]             seq.int <- base::seq.int
[17:38:14.075]             signalCondition <- base::signalCondition
[17:38:14.075]             sys.calls <- base::sys.calls
[17:38:14.075]             `[[` <- base::`[[`
[17:38:14.075]             `+` <- base::`+`
[17:38:14.075]             `<<-` <- base::`<<-`
[17:38:14.075]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:14.075]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:14.075]                   3L)]
[17:38:14.075]             }
[17:38:14.075]             function(cond) {
[17:38:14.075]                 is_error <- inherits(cond, "error")
[17:38:14.075]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:14.075]                   NULL)
[17:38:14.075]                 if (is_error) {
[17:38:14.075]                   sessionInformation <- function() {
[17:38:14.075]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:14.075]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:14.075]                       search = base::search(), system = base::Sys.info())
[17:38:14.075]                   }
[17:38:14.075]                   ...future.conditions[[length(...future.conditions) + 
[17:38:14.075]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:14.075]                     cond$call), session = sessionInformation(), 
[17:38:14.075]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:14.075]                   signalCondition(cond)
[17:38:14.075]                 }
[17:38:14.075]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:14.075]                 "immediateCondition"))) {
[17:38:14.075]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:14.075]                   ...future.conditions[[length(...future.conditions) + 
[17:38:14.075]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:14.075]                   if (TRUE && !signal) {
[17:38:14.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.075]                     {
[17:38:14.075]                       inherits <- base::inherits
[17:38:14.075]                       invokeRestart <- base::invokeRestart
[17:38:14.075]                       is.null <- base::is.null
[17:38:14.075]                       muffled <- FALSE
[17:38:14.075]                       if (inherits(cond, "message")) {
[17:38:14.075]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:14.075]                         if (muffled) 
[17:38:14.075]                           invokeRestart("muffleMessage")
[17:38:14.075]                       }
[17:38:14.075]                       else if (inherits(cond, "warning")) {
[17:38:14.075]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:14.075]                         if (muffled) 
[17:38:14.075]                           invokeRestart("muffleWarning")
[17:38:14.075]                       }
[17:38:14.075]                       else if (inherits(cond, "condition")) {
[17:38:14.075]                         if (!is.null(pattern)) {
[17:38:14.075]                           computeRestarts <- base::computeRestarts
[17:38:14.075]                           grepl <- base::grepl
[17:38:14.075]                           restarts <- computeRestarts(cond)
[17:38:14.075]                           for (restart in restarts) {
[17:38:14.075]                             name <- restart$name
[17:38:14.075]                             if (is.null(name)) 
[17:38:14.075]                               next
[17:38:14.075]                             if (!grepl(pattern, name)) 
[17:38:14.075]                               next
[17:38:14.075]                             invokeRestart(restart)
[17:38:14.075]                             muffled <- TRUE
[17:38:14.075]                             break
[17:38:14.075]                           }
[17:38:14.075]                         }
[17:38:14.075]                       }
[17:38:14.075]                       invisible(muffled)
[17:38:14.075]                     }
[17:38:14.075]                     muffleCondition(cond, pattern = "^muffle")
[17:38:14.075]                   }
[17:38:14.075]                 }
[17:38:14.075]                 else {
[17:38:14.075]                   if (TRUE) {
[17:38:14.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.075]                     {
[17:38:14.075]                       inherits <- base::inherits
[17:38:14.075]                       invokeRestart <- base::invokeRestart
[17:38:14.075]                       is.null <- base::is.null
[17:38:14.075]                       muffled <- FALSE
[17:38:14.075]                       if (inherits(cond, "message")) {
[17:38:14.075]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:14.075]                         if (muffled) 
[17:38:14.075]                           invokeRestart("muffleMessage")
[17:38:14.075]                       }
[17:38:14.075]                       else if (inherits(cond, "warning")) {
[17:38:14.075]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:14.075]                         if (muffled) 
[17:38:14.075]                           invokeRestart("muffleWarning")
[17:38:14.075]                       }
[17:38:14.075]                       else if (inherits(cond, "condition")) {
[17:38:14.075]                         if (!is.null(pattern)) {
[17:38:14.075]                           computeRestarts <- base::computeRestarts
[17:38:14.075]                           grepl <- base::grepl
[17:38:14.075]                           restarts <- computeRestarts(cond)
[17:38:14.075]                           for (restart in restarts) {
[17:38:14.075]                             name <- restart$name
[17:38:14.075]                             if (is.null(name)) 
[17:38:14.075]                               next
[17:38:14.075]                             if (!grepl(pattern, name)) 
[17:38:14.075]                               next
[17:38:14.075]                             invokeRestart(restart)
[17:38:14.075]                             muffled <- TRUE
[17:38:14.075]                             break
[17:38:14.075]                           }
[17:38:14.075]                         }
[17:38:14.075]                       }
[17:38:14.075]                       invisible(muffled)
[17:38:14.075]                     }
[17:38:14.075]                     muffleCondition(cond, pattern = "^muffle")
[17:38:14.075]                   }
[17:38:14.075]                 }
[17:38:14.075]             }
[17:38:14.075]         }))
[17:38:14.075]     }, error = function(ex) {
[17:38:14.075]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:14.075]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:14.075]                 ...future.rng), started = ...future.startTime, 
[17:38:14.075]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:14.075]             version = "1.8"), class = "FutureResult")
[17:38:14.075]     }, finally = {
[17:38:14.075]         if (!identical(...future.workdir, getwd())) 
[17:38:14.075]             setwd(...future.workdir)
[17:38:14.075]         {
[17:38:14.075]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:14.075]                 ...future.oldOptions$nwarnings <- NULL
[17:38:14.075]             }
[17:38:14.075]             base::options(...future.oldOptions)
[17:38:14.075]             if (.Platform$OS.type == "windows") {
[17:38:14.075]                 old_names <- names(...future.oldEnvVars)
[17:38:14.075]                 envs <- base::Sys.getenv()
[17:38:14.075]                 names <- names(envs)
[17:38:14.075]                 common <- intersect(names, old_names)
[17:38:14.075]                 added <- setdiff(names, old_names)
[17:38:14.075]                 removed <- setdiff(old_names, names)
[17:38:14.075]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:14.075]                   envs[common]]
[17:38:14.075]                 NAMES <- toupper(changed)
[17:38:14.075]                 args <- list()
[17:38:14.075]                 for (kk in seq_along(NAMES)) {
[17:38:14.075]                   name <- changed[[kk]]
[17:38:14.075]                   NAME <- NAMES[[kk]]
[17:38:14.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.075]                     next
[17:38:14.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:14.075]                 }
[17:38:14.075]                 NAMES <- toupper(added)
[17:38:14.075]                 for (kk in seq_along(NAMES)) {
[17:38:14.075]                   name <- added[[kk]]
[17:38:14.075]                   NAME <- NAMES[[kk]]
[17:38:14.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.075]                     next
[17:38:14.075]                   args[[name]] <- ""
[17:38:14.075]                 }
[17:38:14.075]                 NAMES <- toupper(removed)
[17:38:14.075]                 for (kk in seq_along(NAMES)) {
[17:38:14.075]                   name <- removed[[kk]]
[17:38:14.075]                   NAME <- NAMES[[kk]]
[17:38:14.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.075]                     next
[17:38:14.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:14.075]                 }
[17:38:14.075]                 if (length(args) > 0) 
[17:38:14.075]                   base::do.call(base::Sys.setenv, args = args)
[17:38:14.075]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:14.075]             }
[17:38:14.075]             else {
[17:38:14.075]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:14.075]             }
[17:38:14.075]             {
[17:38:14.075]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:14.075]                   0L) {
[17:38:14.075]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:14.075]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:14.075]                   base::options(opts)
[17:38:14.075]                 }
[17:38:14.075]                 {
[17:38:14.075]                   {
[17:38:14.075]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:14.075]                     NULL
[17:38:14.075]                   }
[17:38:14.075]                   options(future.plan = NULL)
[17:38:14.075]                   if (is.na(NA_character_)) 
[17:38:14.075]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:14.075]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:14.075]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:14.075]                     .init = FALSE)
[17:38:14.075]                 }
[17:38:14.075]             }
[17:38:14.075]         }
[17:38:14.075]     })
[17:38:14.075]     if (TRUE) {
[17:38:14.075]         base::sink(type = "output", split = FALSE)
[17:38:14.075]         if (TRUE) {
[17:38:14.075]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:14.075]         }
[17:38:14.075]         else {
[17:38:14.075]             ...future.result["stdout"] <- base::list(NULL)
[17:38:14.075]         }
[17:38:14.075]         base::close(...future.stdout)
[17:38:14.075]         ...future.stdout <- NULL
[17:38:14.075]     }
[17:38:14.075]     ...future.result$conditions <- ...future.conditions
[17:38:14.075]     ...future.result$finished <- base::Sys.time()
[17:38:14.075]     ...future.result
[17:38:14.075] }
[17:38:14.078] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[17:38:14.078] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:38:14.121] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:38:14.121] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[17:38:14.165] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[17:38:14.165] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:38:14.165] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:38:14.165] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:38:14.209] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:38:14.209] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:38:14.253] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:38:14.253] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:38:14.253] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:38:14.254] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:38:14.254] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:38:14.254] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:14.255] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:14.255] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[17:38:14.255] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[17:38:14.255] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:14.256] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:14.256] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:14.256] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:14.256] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[17:38:14.257] MultisessionFuture started
[17:38:14.257] - Launch lazy future ... done
[17:38:14.257] run() for ‘MultisessionFuture’ ... done
[17:38:14.257] Created future:
[17:38:14.257] MultisessionFuture:
[17:38:14.257] Label: ‘future_vapply-1’
[17:38:14.257] Expression:
[17:38:14.257] {
[17:38:14.257]     do.call(function(...) {
[17:38:14.257]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.257]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:14.257]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.257]             on.exit(options(oopts), add = TRUE)
[17:38:14.257]         }
[17:38:14.257]         {
[17:38:14.257]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:14.257]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.257]                 ...future.FUN(...future.X_jj, ...)
[17:38:14.257]             })
[17:38:14.257]         }
[17:38:14.257]     }, args = future.call.arguments)
[17:38:14.257] }
[17:38:14.257] Lazy evaluation: FALSE
[17:38:14.257] Asynchronous evaluation: TRUE
[17:38:14.257] Local evaluation: TRUE
[17:38:14.257] Environment: R_GlobalEnv
[17:38:14.257] Capture standard output: TRUE
[17:38:14.257] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:14.257] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:14.257] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:38:14.257] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:14.257] Resolved: FALSE
[17:38:14.257] Value: <not collected>
[17:38:14.257] Conditions captured: <none>
[17:38:14.257] Early signaling: FALSE
[17:38:14.257] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:14.257] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:14.269] Chunk #1 of 2 ... DONE
[17:38:14.269] Chunk #2 of 2 ...
[17:38:14.269]  - Finding globals in 'X' for chunk #2 ...
[17:38:14.269] getGlobalsAndPackages() ...
[17:38:14.270] Searching for globals...
[17:38:14.270] 
[17:38:14.270] Searching for globals ... DONE
[17:38:14.270] - globals: [0] <none>
[17:38:14.270] getGlobalsAndPackages() ... DONE
[17:38:14.270]    + additional globals found: [n=0] 
[17:38:14.270]    + additional namespaces needed: [n=0] 
[17:38:14.270]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:14.270]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:14.271]  - seeds: <none>
[17:38:14.271]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.271] getGlobalsAndPackages() ...
[17:38:14.271] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.271] Resolving globals: FALSE
[17:38:14.271] Tweak future expression to call with '...' arguments ...
[17:38:14.271] {
[17:38:14.271]     do.call(function(...) {
[17:38:14.271]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.271]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:14.271]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.271]             on.exit(options(oopts), add = TRUE)
[17:38:14.271]         }
[17:38:14.271]         {
[17:38:14.271]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:14.271]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.271]                 ...future.FUN(...future.X_jj, ...)
[17:38:14.271]             })
[17:38:14.271]         }
[17:38:14.271]     }, args = future.call.arguments)
[17:38:14.271] }
[17:38:14.271] Tweak future expression to call with '...' arguments ... DONE
[17:38:14.272] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.272] - packages: [2] ‘stats’, ‘future.apply’
[17:38:14.272] getGlobalsAndPackages() ... DONE
[17:38:14.273] run() for ‘Future’ ...
[17:38:14.273] - state: ‘created’
[17:38:14.273] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:14.287] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:14.287] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:14.287]   - Field: ‘node’
[17:38:14.287]   - Field: ‘label’
[17:38:14.287]   - Field: ‘local’
[17:38:14.288]   - Field: ‘owner’
[17:38:14.288]   - Field: ‘envir’
[17:38:14.288]   - Field: ‘workers’
[17:38:14.288]   - Field: ‘packages’
[17:38:14.288]   - Field: ‘gc’
[17:38:14.288]   - Field: ‘conditions’
[17:38:14.288]   - Field: ‘persistent’
[17:38:14.288]   - Field: ‘expr’
[17:38:14.288]   - Field: ‘uuid’
[17:38:14.288]   - Field: ‘seed’
[17:38:14.289]   - Field: ‘version’
[17:38:14.289]   - Field: ‘result’
[17:38:14.289]   - Field: ‘asynchronous’
[17:38:14.289]   - Field: ‘calls’
[17:38:14.289]   - Field: ‘globals’
[17:38:14.289]   - Field: ‘stdout’
[17:38:14.289]   - Field: ‘earlySignal’
[17:38:14.289]   - Field: ‘lazy’
[17:38:14.289]   - Field: ‘state’
[17:38:14.289] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:14.289] - Launch lazy future ...
[17:38:14.290] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:38:14.290] Packages needed by future strategies (n = 0): <none>
[17:38:14.290] {
[17:38:14.290]     {
[17:38:14.290]         {
[17:38:14.290]             ...future.startTime <- base::Sys.time()
[17:38:14.290]             {
[17:38:14.290]                 {
[17:38:14.290]                   {
[17:38:14.290]                     {
[17:38:14.290]                       {
[17:38:14.290]                         base::local({
[17:38:14.290]                           has_future <- base::requireNamespace("future", 
[17:38:14.290]                             quietly = TRUE)
[17:38:14.290]                           if (has_future) {
[17:38:14.290]                             ns <- base::getNamespace("future")
[17:38:14.290]                             version <- ns[[".package"]][["version"]]
[17:38:14.290]                             if (is.null(version)) 
[17:38:14.290]                               version <- utils::packageVersion("future")
[17:38:14.290]                           }
[17:38:14.290]                           else {
[17:38:14.290]                             version <- NULL
[17:38:14.290]                           }
[17:38:14.290]                           if (!has_future || version < "1.8.0") {
[17:38:14.290]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:14.290]                               "", base::R.version$version.string), 
[17:38:14.290]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:14.290]                                 base::R.version$platform, 8 * 
[17:38:14.290]                                   base::.Machine$sizeof.pointer), 
[17:38:14.290]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:14.290]                                 "release", "version")], collapse = " "), 
[17:38:14.290]                               hostname = base::Sys.info()[["nodename"]])
[17:38:14.290]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:14.290]                               info)
[17:38:14.290]                             info <- base::paste(info, collapse = "; ")
[17:38:14.290]                             if (!has_future) {
[17:38:14.290]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:14.290]                                 info)
[17:38:14.290]                             }
[17:38:14.290]                             else {
[17:38:14.290]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:14.290]                                 info, version)
[17:38:14.290]                             }
[17:38:14.290]                             base::stop(msg)
[17:38:14.290]                           }
[17:38:14.290]                         })
[17:38:14.290]                       }
[17:38:14.290]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:14.290]                       base::options(mc.cores = 1L)
[17:38:14.290]                     }
[17:38:14.290]                     base::local({
[17:38:14.290]                       for (pkg in c("stats", "future.apply")) {
[17:38:14.290]                         base::loadNamespace(pkg)
[17:38:14.290]                         base::library(pkg, character.only = TRUE)
[17:38:14.290]                       }
[17:38:14.290]                     })
[17:38:14.290]                   }
[17:38:14.290]                   ...future.strategy.old <- future::plan("list")
[17:38:14.290]                   options(future.plan = NULL)
[17:38:14.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:14.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:14.290]                 }
[17:38:14.290]                 ...future.workdir <- getwd()
[17:38:14.290]             }
[17:38:14.290]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:14.290]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:14.290]         }
[17:38:14.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:14.290]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:14.290]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:14.290]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:14.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:14.290]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:14.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:14.290]             base::names(...future.oldOptions))
[17:38:14.290]     }
[17:38:14.290]     if (FALSE) {
[17:38:14.290]     }
[17:38:14.290]     else {
[17:38:14.290]         if (TRUE) {
[17:38:14.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:14.290]                 open = "w")
[17:38:14.290]         }
[17:38:14.290]         else {
[17:38:14.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:14.290]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:14.290]         }
[17:38:14.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:14.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:14.290]             base::sink(type = "output", split = FALSE)
[17:38:14.290]             base::close(...future.stdout)
[17:38:14.290]         }, add = TRUE)
[17:38:14.290]     }
[17:38:14.290]     ...future.frame <- base::sys.nframe()
[17:38:14.290]     ...future.conditions <- base::list()
[17:38:14.290]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:14.290]     if (FALSE) {
[17:38:14.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:14.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:14.290]     }
[17:38:14.290]     ...future.result <- base::tryCatch({
[17:38:14.290]         base::withCallingHandlers({
[17:38:14.290]             ...future.value <- base::withVisible(base::local({
[17:38:14.290]                 ...future.makeSendCondition <- base::local({
[17:38:14.290]                   sendCondition <- NULL
[17:38:14.290]                   function(frame = 1L) {
[17:38:14.290]                     if (is.function(sendCondition)) 
[17:38:14.290]                       return(sendCondition)
[17:38:14.290]                     ns <- getNamespace("parallel")
[17:38:14.290]                     if (exists("sendData", mode = "function", 
[17:38:14.290]                       envir = ns)) {
[17:38:14.290]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:14.290]                         envir = ns)
[17:38:14.290]                       envir <- sys.frame(frame)
[17:38:14.290]                       master <- NULL
[17:38:14.290]                       while (!identical(envir, .GlobalEnv) && 
[17:38:14.290]                         !identical(envir, emptyenv())) {
[17:38:14.290]                         if (exists("master", mode = "list", envir = envir, 
[17:38:14.290]                           inherits = FALSE)) {
[17:38:14.290]                           master <- get("master", mode = "list", 
[17:38:14.290]                             envir = envir, inherits = FALSE)
[17:38:14.290]                           if (inherits(master, c("SOCKnode", 
[17:38:14.290]                             "SOCK0node"))) {
[17:38:14.290]                             sendCondition <<- function(cond) {
[17:38:14.290]                               data <- list(type = "VALUE", value = cond, 
[17:38:14.290]                                 success = TRUE)
[17:38:14.290]                               parallel_sendData(master, data)
[17:38:14.290]                             }
[17:38:14.290]                             return(sendCondition)
[17:38:14.290]                           }
[17:38:14.290]                         }
[17:38:14.290]                         frame <- frame + 1L
[17:38:14.290]                         envir <- sys.frame(frame)
[17:38:14.290]                       }
[17:38:14.290]                     }
[17:38:14.290]                     sendCondition <<- function(cond) NULL
[17:38:14.290]                   }
[17:38:14.290]                 })
[17:38:14.290]                 withCallingHandlers({
[17:38:14.290]                   {
[17:38:14.290]                     do.call(function(...) {
[17:38:14.290]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.290]                       if (!identical(...future.globals.maxSize.org, 
[17:38:14.290]                         ...future.globals.maxSize)) {
[17:38:14.290]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.290]                         on.exit(options(oopts), add = TRUE)
[17:38:14.290]                       }
[17:38:14.290]                       {
[17:38:14.290]                         lapply(seq_along(...future.elements_ii), 
[17:38:14.290]                           FUN = function(jj) {
[17:38:14.290]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.290]                             ...future.FUN(...future.X_jj, ...)
[17:38:14.290]                           })
[17:38:14.290]                       }
[17:38:14.290]                     }, args = future.call.arguments)
[17:38:14.290]                   }
[17:38:14.290]                 }, immediateCondition = function(cond) {
[17:38:14.290]                   sendCondition <- ...future.makeSendCondition()
[17:38:14.290]                   sendCondition(cond)
[17:38:14.290]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.290]                   {
[17:38:14.290]                     inherits <- base::inherits
[17:38:14.290]                     invokeRestart <- base::invokeRestart
[17:38:14.290]                     is.null <- base::is.null
[17:38:14.290]                     muffled <- FALSE
[17:38:14.290]                     if (inherits(cond, "message")) {
[17:38:14.290]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:14.290]                       if (muffled) 
[17:38:14.290]                         invokeRestart("muffleMessage")
[17:38:14.290]                     }
[17:38:14.290]                     else if (inherits(cond, "warning")) {
[17:38:14.290]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:14.290]                       if (muffled) 
[17:38:14.290]                         invokeRestart("muffleWarning")
[17:38:14.290]                     }
[17:38:14.290]                     else if (inherits(cond, "condition")) {
[17:38:14.290]                       if (!is.null(pattern)) {
[17:38:14.290]                         computeRestarts <- base::computeRestarts
[17:38:14.290]                         grepl <- base::grepl
[17:38:14.290]                         restarts <- computeRestarts(cond)
[17:38:14.290]                         for (restart in restarts) {
[17:38:14.290]                           name <- restart$name
[17:38:14.290]                           if (is.null(name)) 
[17:38:14.290]                             next
[17:38:14.290]                           if (!grepl(pattern, name)) 
[17:38:14.290]                             next
[17:38:14.290]                           invokeRestart(restart)
[17:38:14.290]                           muffled <- TRUE
[17:38:14.290]                           break
[17:38:14.290]                         }
[17:38:14.290]                       }
[17:38:14.290]                     }
[17:38:14.290]                     invisible(muffled)
[17:38:14.290]                   }
[17:38:14.290]                   muffleCondition(cond)
[17:38:14.290]                 })
[17:38:14.290]             }))
[17:38:14.290]             future::FutureResult(value = ...future.value$value, 
[17:38:14.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:14.290]                   ...future.rng), globalenv = if (FALSE) 
[17:38:14.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:14.290]                     ...future.globalenv.names))
[17:38:14.290]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:14.290]         }, condition = base::local({
[17:38:14.290]             c <- base::c
[17:38:14.290]             inherits <- base::inherits
[17:38:14.290]             invokeRestart <- base::invokeRestart
[17:38:14.290]             length <- base::length
[17:38:14.290]             list <- base::list
[17:38:14.290]             seq.int <- base::seq.int
[17:38:14.290]             signalCondition <- base::signalCondition
[17:38:14.290]             sys.calls <- base::sys.calls
[17:38:14.290]             `[[` <- base::`[[`
[17:38:14.290]             `+` <- base::`+`
[17:38:14.290]             `<<-` <- base::`<<-`
[17:38:14.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:14.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:14.290]                   3L)]
[17:38:14.290]             }
[17:38:14.290]             function(cond) {
[17:38:14.290]                 is_error <- inherits(cond, "error")
[17:38:14.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:14.290]                   NULL)
[17:38:14.290]                 if (is_error) {
[17:38:14.290]                   sessionInformation <- function() {
[17:38:14.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:14.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:14.290]                       search = base::search(), system = base::Sys.info())
[17:38:14.290]                   }
[17:38:14.290]                   ...future.conditions[[length(...future.conditions) + 
[17:38:14.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:14.290]                     cond$call), session = sessionInformation(), 
[17:38:14.290]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:14.290]                   signalCondition(cond)
[17:38:14.290]                 }
[17:38:14.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:14.290]                 "immediateCondition"))) {
[17:38:14.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:14.290]                   ...future.conditions[[length(...future.conditions) + 
[17:38:14.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:14.290]                   if (TRUE && !signal) {
[17:38:14.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.290]                     {
[17:38:14.290]                       inherits <- base::inherits
[17:38:14.290]                       invokeRestart <- base::invokeRestart
[17:38:14.290]                       is.null <- base::is.null
[17:38:14.290]                       muffled <- FALSE
[17:38:14.290]                       if (inherits(cond, "message")) {
[17:38:14.290]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:14.290]                         if (muffled) 
[17:38:14.290]                           invokeRestart("muffleMessage")
[17:38:14.290]                       }
[17:38:14.290]                       else if (inherits(cond, "warning")) {
[17:38:14.290]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:14.290]                         if (muffled) 
[17:38:14.290]                           invokeRestart("muffleWarning")
[17:38:14.290]                       }
[17:38:14.290]                       else if (inherits(cond, "condition")) {
[17:38:14.290]                         if (!is.null(pattern)) {
[17:38:14.290]                           computeRestarts <- base::computeRestarts
[17:38:14.290]                           grepl <- base::grepl
[17:38:14.290]                           restarts <- computeRestarts(cond)
[17:38:14.290]                           for (restart in restarts) {
[17:38:14.290]                             name <- restart$name
[17:38:14.290]                             if (is.null(name)) 
[17:38:14.290]                               next
[17:38:14.290]                             if (!grepl(pattern, name)) 
[17:38:14.290]                               next
[17:38:14.290]                             invokeRestart(restart)
[17:38:14.290]                             muffled <- TRUE
[17:38:14.290]                             break
[17:38:14.290]                           }
[17:38:14.290]                         }
[17:38:14.290]                       }
[17:38:14.290]                       invisible(muffled)
[17:38:14.290]                     }
[17:38:14.290]                     muffleCondition(cond, pattern = "^muffle")
[17:38:14.290]                   }
[17:38:14.290]                 }
[17:38:14.290]                 else {
[17:38:14.290]                   if (TRUE) {
[17:38:14.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.290]                     {
[17:38:14.290]                       inherits <- base::inherits
[17:38:14.290]                       invokeRestart <- base::invokeRestart
[17:38:14.290]                       is.null <- base::is.null
[17:38:14.290]                       muffled <- FALSE
[17:38:14.290]                       if (inherits(cond, "message")) {
[17:38:14.290]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:14.290]                         if (muffled) 
[17:38:14.290]                           invokeRestart("muffleMessage")
[17:38:14.290]                       }
[17:38:14.290]                       else if (inherits(cond, "warning")) {
[17:38:14.290]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:14.290]                         if (muffled) 
[17:38:14.290]                           invokeRestart("muffleWarning")
[17:38:14.290]                       }
[17:38:14.290]                       else if (inherits(cond, "condition")) {
[17:38:14.290]                         if (!is.null(pattern)) {
[17:38:14.290]                           computeRestarts <- base::computeRestarts
[17:38:14.290]                           grepl <- base::grepl
[17:38:14.290]                           restarts <- computeRestarts(cond)
[17:38:14.290]                           for (restart in restarts) {
[17:38:14.290]                             name <- restart$name
[17:38:14.290]                             if (is.null(name)) 
[17:38:14.290]                               next
[17:38:14.290]                             if (!grepl(pattern, name)) 
[17:38:14.290]                               next
[17:38:14.290]                             invokeRestart(restart)
[17:38:14.290]                             muffled <- TRUE
[17:38:14.290]                             break
[17:38:14.290]                           }
[17:38:14.290]                         }
[17:38:14.290]                       }
[17:38:14.290]                       invisible(muffled)
[17:38:14.290]                     }
[17:38:14.290]                     muffleCondition(cond, pattern = "^muffle")
[17:38:14.290]                   }
[17:38:14.290]                 }
[17:38:14.290]             }
[17:38:14.290]         }))
[17:38:14.290]     }, error = function(ex) {
[17:38:14.290]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:14.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:14.290]                 ...future.rng), started = ...future.startTime, 
[17:38:14.290]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:14.290]             version = "1.8"), class = "FutureResult")
[17:38:14.290]     }, finally = {
[17:38:14.290]         if (!identical(...future.workdir, getwd())) 
[17:38:14.290]             setwd(...future.workdir)
[17:38:14.290]         {
[17:38:14.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:14.290]                 ...future.oldOptions$nwarnings <- NULL
[17:38:14.290]             }
[17:38:14.290]             base::options(...future.oldOptions)
[17:38:14.290]             if (.Platform$OS.type == "windows") {
[17:38:14.290]                 old_names <- names(...future.oldEnvVars)
[17:38:14.290]                 envs <- base::Sys.getenv()
[17:38:14.290]                 names <- names(envs)
[17:38:14.290]                 common <- intersect(names, old_names)
[17:38:14.290]                 added <- setdiff(names, old_names)
[17:38:14.290]                 removed <- setdiff(old_names, names)
[17:38:14.290]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:14.290]                   envs[common]]
[17:38:14.290]                 NAMES <- toupper(changed)
[17:38:14.290]                 args <- list()
[17:38:14.290]                 for (kk in seq_along(NAMES)) {
[17:38:14.290]                   name <- changed[[kk]]
[17:38:14.290]                   NAME <- NAMES[[kk]]
[17:38:14.290]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.290]                     next
[17:38:14.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:14.290]                 }
[17:38:14.290]                 NAMES <- toupper(added)
[17:38:14.290]                 for (kk in seq_along(NAMES)) {
[17:38:14.290]                   name <- added[[kk]]
[17:38:14.290]                   NAME <- NAMES[[kk]]
[17:38:14.290]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.290]                     next
[17:38:14.290]                   args[[name]] <- ""
[17:38:14.290]                 }
[17:38:14.290]                 NAMES <- toupper(removed)
[17:38:14.290]                 for (kk in seq_along(NAMES)) {
[17:38:14.290]                   name <- removed[[kk]]
[17:38:14.290]                   NAME <- NAMES[[kk]]
[17:38:14.290]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.290]                     next
[17:38:14.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:14.290]                 }
[17:38:14.290]                 if (length(args) > 0) 
[17:38:14.290]                   base::do.call(base::Sys.setenv, args = args)
[17:38:14.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:14.290]             }
[17:38:14.290]             else {
[17:38:14.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:14.290]             }
[17:38:14.290]             {
[17:38:14.290]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:14.290]                   0L) {
[17:38:14.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:14.290]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:14.290]                   base::options(opts)
[17:38:14.290]                 }
[17:38:14.290]                 {
[17:38:14.290]                   {
[17:38:14.290]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:14.290]                     NULL
[17:38:14.290]                   }
[17:38:14.290]                   options(future.plan = NULL)
[17:38:14.290]                   if (is.na(NA_character_)) 
[17:38:14.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:14.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:14.290]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:14.290]                     .init = FALSE)
[17:38:14.290]                 }
[17:38:14.290]             }
[17:38:14.290]         }
[17:38:14.290]     })
[17:38:14.290]     if (TRUE) {
[17:38:14.290]         base::sink(type = "output", split = FALSE)
[17:38:14.290]         if (TRUE) {
[17:38:14.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:14.290]         }
[17:38:14.290]         else {
[17:38:14.290]             ...future.result["stdout"] <- base::list(NULL)
[17:38:14.290]         }
[17:38:14.290]         base::close(...future.stdout)
[17:38:14.290]         ...future.stdout <- NULL
[17:38:14.290]     }
[17:38:14.290]     ...future.result$conditions <- ...future.conditions
[17:38:14.290]     ...future.result$finished <- base::Sys.time()
[17:38:14.290]     ...future.result
[17:38:14.290] }
[17:38:14.293] Exporting 11 global objects (137.93 KiB) to cluster node #2 ...
[17:38:14.293] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:38:14.337] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:38:14.337] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ...
[17:38:14.381] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ... DONE
[17:38:14.381] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:38:14.381] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:38:14.381] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:38:14.425] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:38:14.425] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:38:14.469] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:38:14.469] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:38:14.470] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:38:14.470] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:38:14.470] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:38:14.470] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:14.471] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:14.471] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[17:38:14.471] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[17:38:14.472] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:14.472] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:14.472] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:14.473] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:14.473] Exporting 11 global objects (137.93 KiB) to cluster node #2 ... DONE
[17:38:14.473] MultisessionFuture started
[17:38:14.474] - Launch lazy future ... done
[17:38:14.474] run() for ‘MultisessionFuture’ ... done
[17:38:14.474] Created future:
[17:38:14.475] receiveMessageFromWorker() for ClusterFuture ...
[17:38:14.475] - Validating connection of MultisessionFuture
[17:38:14.476] - received message: FutureResult
[17:38:14.476] - Received FutureResult
[17:38:14.476] - Erased future from FutureRegistry
[17:38:14.476] result() for ClusterFuture ...
[17:38:14.476] - result already collected: FutureResult
[17:38:14.476] result() for ClusterFuture ... done
[17:38:14.476] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:14.474] MultisessionFuture:
[17:38:14.474] Label: ‘future_vapply-2’
[17:38:14.474] Expression:
[17:38:14.474] {
[17:38:14.474]     do.call(function(...) {
[17:38:14.474]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.474]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:14.474]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.474]             on.exit(options(oopts), add = TRUE)
[17:38:14.474]         }
[17:38:14.474]         {
[17:38:14.474]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:14.474]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.474]                 ...future.FUN(...future.X_jj, ...)
[17:38:14.474]             })
[17:38:14.474]         }
[17:38:14.474]     }, args = future.call.arguments)
[17:38:14.474] }
[17:38:14.474] Lazy evaluation: FALSE
[17:38:14.474] Asynchronous evaluation: TRUE
[17:38:14.474] Local evaluation: TRUE
[17:38:14.474] Environment: R_GlobalEnv
[17:38:14.474] Capture standard output: TRUE
[17:38:14.474] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:14.474] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:14.474] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:38:14.474] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:14.474] Resolved: TRUE
[17:38:14.474] Value: <not collected>
[17:38:14.474] Conditions captured: <none>
[17:38:14.474] Early signaling: FALSE
[17:38:14.474] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:14.474] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:14.477] Chunk #2 of 2 ... DONE
[17:38:14.477] Launching 2 futures (chunks) ... DONE
[17:38:14.477] Resolving 2 futures (chunks) ...
[17:38:14.477] resolve() on list ...
[17:38:14.477]  recursive: 0
[17:38:14.477]  length: 2
[17:38:14.477] 
[17:38:14.477] receiveMessageFromWorker() for ClusterFuture ...
[17:38:14.478] - Validating connection of MultisessionFuture
[17:38:14.478] - received message: FutureResult
[17:38:14.478] - Received FutureResult
[17:38:14.478] - Erased future from FutureRegistry
[17:38:14.478] result() for ClusterFuture ...
[17:38:14.478] - result already collected: FutureResult
[17:38:14.478] result() for ClusterFuture ... done
[17:38:14.478] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:14.478] Future #1
[17:38:14.478] result() for ClusterFuture ...
[17:38:14.479] - result already collected: FutureResult
[17:38:14.479] result() for ClusterFuture ... done
[17:38:14.479] result() for ClusterFuture ...
[17:38:14.479] - result already collected: FutureResult
[17:38:14.479] result() for ClusterFuture ... done
[17:38:14.479] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:14.479] - nx: 2
[17:38:14.479] - relay: TRUE
[17:38:14.479] - stdout: TRUE
[17:38:14.479] - signal: TRUE
[17:38:14.479] - resignal: FALSE
[17:38:14.480] - force: TRUE
[17:38:14.480] - relayed: [n=2] FALSE, FALSE
[17:38:14.480] - queued futures: [n=2] FALSE, FALSE
[17:38:14.488]  - until=1
[17:38:14.488]  - relaying element #1
[17:38:14.488] result() for ClusterFuture ...
[17:38:14.488] - result already collected: FutureResult
[17:38:14.488] result() for ClusterFuture ... done
[17:38:14.488] result() for ClusterFuture ...
[17:38:14.489] - result already collected: FutureResult
[17:38:14.489] result() for ClusterFuture ... done
[17:38:14.489] result() for ClusterFuture ...
[17:38:14.489] - result already collected: FutureResult
[17:38:14.489] result() for ClusterFuture ... done
[17:38:14.489] result() for ClusterFuture ...
[17:38:14.489] - result already collected: FutureResult
[17:38:14.489] result() for ClusterFuture ... done
[17:38:14.489] - relayed: [n=2] TRUE, FALSE
[17:38:14.489] - queued futures: [n=2] TRUE, FALSE
[17:38:14.489] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:14.490]  length: 1 (resolved future 1)
[17:38:14.490] Future #2
[17:38:14.490] result() for ClusterFuture ...
[17:38:14.490] - result already collected: FutureResult
[17:38:14.490] result() for ClusterFuture ... done
[17:38:14.490] result() for ClusterFuture ...
[17:38:14.490] - result already collected: FutureResult
[17:38:14.490] result() for ClusterFuture ... done
[17:38:14.490] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:14.490] - nx: 2
[17:38:14.490] - relay: TRUE
[17:38:14.491] - stdout: TRUE
[17:38:14.491] - signal: TRUE
[17:38:14.491] - resignal: FALSE
[17:38:14.491] - force: TRUE
[17:38:14.491] - relayed: [n=2] TRUE, FALSE
[17:38:14.491] - queued futures: [n=2] TRUE, FALSE
[17:38:14.491]  - until=2
[17:38:14.491]  - relaying element #2
[17:38:14.491] result() for ClusterFuture ...
[17:38:14.491] - result already collected: FutureResult
[17:38:14.491] result() for ClusterFuture ... done
[17:38:14.491] result() for ClusterFuture ...
[17:38:14.492] - result already collected: FutureResult
[17:38:14.492] result() for ClusterFuture ... done
[17:38:14.492] result() for ClusterFuture ...
[17:38:14.492] - result already collected: FutureResult
[17:38:14.492] result() for ClusterFuture ... done
[17:38:14.492] result() for ClusterFuture ...
[17:38:14.492] - result already collected: FutureResult
[17:38:14.492] result() for ClusterFuture ... done
[17:38:14.492] - relayed: [n=2] TRUE, TRUE
[17:38:14.492] - queued futures: [n=2] TRUE, TRUE
[17:38:14.492] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:14.493]  length: 0 (resolved future 2)
[17:38:14.493] Relaying remaining futures
[17:38:14.493] signalConditionsASAP(NULL, pos=0) ...
[17:38:14.493] - nx: 2
[17:38:14.493] - relay: TRUE
[17:38:14.493] - stdout: TRUE
[17:38:14.493] - signal: TRUE
[17:38:14.493] - resignal: FALSE
[17:38:14.493] - force: TRUE
[17:38:14.493] - relayed: [n=2] TRUE, TRUE
[17:38:14.493] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:14.493] - relayed: [n=2] TRUE, TRUE
[17:38:14.494] - queued futures: [n=2] TRUE, TRUE
[17:38:14.494] signalConditionsASAP(NULL, pos=0) ... done
[17:38:14.494] resolve() on list ... DONE
[17:38:14.494] result() for ClusterFuture ...
[17:38:14.494] - result already collected: FutureResult
[17:38:14.494] result() for ClusterFuture ... done
[17:38:14.494] result() for ClusterFuture ...
[17:38:14.494] - result already collected: FutureResult
[17:38:14.494] result() for ClusterFuture ... done
[17:38:14.494] result() for ClusterFuture ...
[17:38:14.494] - result already collected: FutureResult
[17:38:14.494] result() for ClusterFuture ... done
[17:38:14.495] result() for ClusterFuture ...
[17:38:14.495] - result already collected: FutureResult
[17:38:14.495] result() for ClusterFuture ... done
[17:38:14.495]  - Number of value chunks collected: 2
[17:38:14.495] Resolving 2 futures (chunks) ... DONE
[17:38:14.495] Reducing values from 2 chunks ...
[17:38:14.495]  - Number of values collected after concatenation: 7
[17:38:14.495]  - Number of values expected: 7
[17:38:14.495] Reducing values from 2 chunks ... DONE
[17:38:14.495] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[17:38:14.497] future_lapply() ...
[17:38:14.502] Number of chunks: 2
[17:38:14.502] getGlobalsAndPackagesXApply() ...
[17:38:14.502]  - future.globals: TRUE
[17:38:14.502] getGlobalsAndPackages() ...
[17:38:14.502] Searching for globals...
[17:38:14.503] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[17:38:14.504] Searching for globals ... DONE
[17:38:14.504] Resolving globals: FALSE
[17:38:14.504] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[17:38:14.504] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[17:38:14.505] - globals: [1] ‘FUN’
[17:38:14.505] 
[17:38:14.505] getGlobalsAndPackages() ... DONE
[17:38:14.505]  - globals found/used: [n=1] ‘FUN’
[17:38:14.505]  - needed namespaces: [n=0] 
[17:38:14.505] Finding globals ... DONE
[17:38:14.505]  - use_args: TRUE
[17:38:14.505]  - Getting '...' globals ...
[17:38:14.506] resolve() on list ...
[17:38:14.506]  recursive: 0
[17:38:14.506]  length: 1
[17:38:14.506]  elements: ‘...’
[17:38:14.506]  length: 0 (resolved future 1)
[17:38:14.506] resolve() on list ... DONE
[17:38:14.506]    - '...' content: [n=1] ‘y’
[17:38:14.506] List of 1
[17:38:14.506]  $ ...:List of 1
[17:38:14.506]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:14.506]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:14.506]  - attr(*, "where")=List of 1
[17:38:14.506]   ..$ ...:<environment: 0x5608019abdf0> 
[17:38:14.506]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:14.506]  - attr(*, "resolved")= logi TRUE
[17:38:14.506]  - attr(*, "total_size")= num NA
[17:38:14.510]  - Getting '...' globals ... DONE
[17:38:14.510] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:38:14.510] List of 2
[17:38:14.510]  $ ...future.FUN:function (x, y)  
[17:38:14.510]  $ ...          :List of 1
[17:38:14.510]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:14.510]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:14.510]  - attr(*, "where")=List of 2
[17:38:14.510]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:14.510]   ..$ ...          :<environment: 0x5608019abdf0> 
[17:38:14.510]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:14.510]  - attr(*, "resolved")= logi FALSE
[17:38:14.510]  - attr(*, "total_size")= num 4264
[17:38:14.513] Packages to be attached in all futures: [n=0] 
[17:38:14.513] getGlobalsAndPackagesXApply() ... DONE
[17:38:14.513] Number of futures (= number of chunks): 2
[17:38:14.514] Launching 2 futures (chunks) ...
[17:38:14.514] Chunk #1 of 2 ...
[17:38:14.514]  - Finding globals in 'X' for chunk #1 ...
[17:38:14.514] getGlobalsAndPackages() ...
[17:38:14.514] Searching for globals...
[17:38:14.514] 
[17:38:14.514] Searching for globals ... DONE
[17:38:14.514] - globals: [0] <none>
[17:38:14.514] getGlobalsAndPackages() ... DONE
[17:38:14.515]    + additional globals found: [n=0] 
[17:38:14.515]    + additional namespaces needed: [n=0] 
[17:38:14.515]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:14.515]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:14.515]  - seeds: <none>
[17:38:14.515]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.515] getGlobalsAndPackages() ...
[17:38:14.515] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.515] Resolving globals: FALSE
[17:38:14.515] Tweak future expression to call with '...' arguments ...
[17:38:14.516] {
[17:38:14.516]     do.call(function(...) {
[17:38:14.516]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.516]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:14.516]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.516]             on.exit(options(oopts), add = TRUE)
[17:38:14.516]         }
[17:38:14.516]         {
[17:38:14.516]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:14.516]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.516]                 ...future.FUN(...future.X_jj, ...)
[17:38:14.516]             })
[17:38:14.516]         }
[17:38:14.516]     }, args = future.call.arguments)
[17:38:14.516] }
[17:38:14.516] Tweak future expression to call with '...' arguments ... DONE
[17:38:14.516] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.516] 
[17:38:14.517] getGlobalsAndPackages() ... DONE
[17:38:14.517] run() for ‘Future’ ...
[17:38:14.517] - state: ‘created’
[17:38:14.517] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:14.532] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:14.532] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:14.532]   - Field: ‘node’
[17:38:14.532]   - Field: ‘label’
[17:38:14.532]   - Field: ‘local’
[17:38:14.532]   - Field: ‘owner’
[17:38:14.532]   - Field: ‘envir’
[17:38:14.533]   - Field: ‘workers’
[17:38:14.533]   - Field: ‘packages’
[17:38:14.533]   - Field: ‘gc’
[17:38:14.533]   - Field: ‘conditions’
[17:38:14.533]   - Field: ‘persistent’
[17:38:14.533]   - Field: ‘expr’
[17:38:14.533]   - Field: ‘uuid’
[17:38:14.533]   - Field: ‘seed’
[17:38:14.533]   - Field: ‘version’
[17:38:14.533]   - Field: ‘result’
[17:38:14.533]   - Field: ‘asynchronous’
[17:38:14.534]   - Field: ‘calls’
[17:38:14.534]   - Field: ‘globals’
[17:38:14.534]   - Field: ‘stdout’
[17:38:14.534]   - Field: ‘earlySignal’
[17:38:14.534]   - Field: ‘lazy’
[17:38:14.534]   - Field: ‘state’
[17:38:14.534] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:14.534] - Launch lazy future ...
[17:38:14.535] Packages needed by the future expression (n = 0): <none>
[17:38:14.535] Packages needed by future strategies (n = 0): <none>
[17:38:14.535] {
[17:38:14.535]     {
[17:38:14.535]         {
[17:38:14.535]             ...future.startTime <- base::Sys.time()
[17:38:14.535]             {
[17:38:14.535]                 {
[17:38:14.535]                   {
[17:38:14.535]                     {
[17:38:14.535]                       base::local({
[17:38:14.535]                         has_future <- base::requireNamespace("future", 
[17:38:14.535]                           quietly = TRUE)
[17:38:14.535]                         if (has_future) {
[17:38:14.535]                           ns <- base::getNamespace("future")
[17:38:14.535]                           version <- ns[[".package"]][["version"]]
[17:38:14.535]                           if (is.null(version)) 
[17:38:14.535]                             version <- utils::packageVersion("future")
[17:38:14.535]                         }
[17:38:14.535]                         else {
[17:38:14.535]                           version <- NULL
[17:38:14.535]                         }
[17:38:14.535]                         if (!has_future || version < "1.8.0") {
[17:38:14.535]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:14.535]                             "", base::R.version$version.string), 
[17:38:14.535]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:14.535]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:14.535]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:14.535]                               "release", "version")], collapse = " "), 
[17:38:14.535]                             hostname = base::Sys.info()[["nodename"]])
[17:38:14.535]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:14.535]                             info)
[17:38:14.535]                           info <- base::paste(info, collapse = "; ")
[17:38:14.535]                           if (!has_future) {
[17:38:14.535]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:14.535]                               info)
[17:38:14.535]                           }
[17:38:14.535]                           else {
[17:38:14.535]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:14.535]                               info, version)
[17:38:14.535]                           }
[17:38:14.535]                           base::stop(msg)
[17:38:14.535]                         }
[17:38:14.535]                       })
[17:38:14.535]                     }
[17:38:14.535]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:14.535]                     base::options(mc.cores = 1L)
[17:38:14.535]                   }
[17:38:14.535]                   ...future.strategy.old <- future::plan("list")
[17:38:14.535]                   options(future.plan = NULL)
[17:38:14.535]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:14.535]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:14.535]                 }
[17:38:14.535]                 ...future.workdir <- getwd()
[17:38:14.535]             }
[17:38:14.535]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:14.535]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:14.535]         }
[17:38:14.535]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:14.535]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:14.535]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:14.535]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:14.535]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:14.535]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:14.535]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:14.535]             base::names(...future.oldOptions))
[17:38:14.535]     }
[17:38:14.535]     if (FALSE) {
[17:38:14.535]     }
[17:38:14.535]     else {
[17:38:14.535]         if (TRUE) {
[17:38:14.535]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:14.535]                 open = "w")
[17:38:14.535]         }
[17:38:14.535]         else {
[17:38:14.535]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:14.535]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:14.535]         }
[17:38:14.535]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:14.535]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:14.535]             base::sink(type = "output", split = FALSE)
[17:38:14.535]             base::close(...future.stdout)
[17:38:14.535]         }, add = TRUE)
[17:38:14.535]     }
[17:38:14.535]     ...future.frame <- base::sys.nframe()
[17:38:14.535]     ...future.conditions <- base::list()
[17:38:14.535]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:14.535]     if (FALSE) {
[17:38:14.535]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:14.535]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:14.535]     }
[17:38:14.535]     ...future.result <- base::tryCatch({
[17:38:14.535]         base::withCallingHandlers({
[17:38:14.535]             ...future.value <- base::withVisible(base::local({
[17:38:14.535]                 ...future.makeSendCondition <- base::local({
[17:38:14.535]                   sendCondition <- NULL
[17:38:14.535]                   function(frame = 1L) {
[17:38:14.535]                     if (is.function(sendCondition)) 
[17:38:14.535]                       return(sendCondition)
[17:38:14.535]                     ns <- getNamespace("parallel")
[17:38:14.535]                     if (exists("sendData", mode = "function", 
[17:38:14.535]                       envir = ns)) {
[17:38:14.535]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:14.535]                         envir = ns)
[17:38:14.535]                       envir <- sys.frame(frame)
[17:38:14.535]                       master <- NULL
[17:38:14.535]                       while (!identical(envir, .GlobalEnv) && 
[17:38:14.535]                         !identical(envir, emptyenv())) {
[17:38:14.535]                         if (exists("master", mode = "list", envir = envir, 
[17:38:14.535]                           inherits = FALSE)) {
[17:38:14.535]                           master <- get("master", mode = "list", 
[17:38:14.535]                             envir = envir, inherits = FALSE)
[17:38:14.535]                           if (inherits(master, c("SOCKnode", 
[17:38:14.535]                             "SOCK0node"))) {
[17:38:14.535]                             sendCondition <<- function(cond) {
[17:38:14.535]                               data <- list(type = "VALUE", value = cond, 
[17:38:14.535]                                 success = TRUE)
[17:38:14.535]                               parallel_sendData(master, data)
[17:38:14.535]                             }
[17:38:14.535]                             return(sendCondition)
[17:38:14.535]                           }
[17:38:14.535]                         }
[17:38:14.535]                         frame <- frame + 1L
[17:38:14.535]                         envir <- sys.frame(frame)
[17:38:14.535]                       }
[17:38:14.535]                     }
[17:38:14.535]                     sendCondition <<- function(cond) NULL
[17:38:14.535]                   }
[17:38:14.535]                 })
[17:38:14.535]                 withCallingHandlers({
[17:38:14.535]                   {
[17:38:14.535]                     do.call(function(...) {
[17:38:14.535]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.535]                       if (!identical(...future.globals.maxSize.org, 
[17:38:14.535]                         ...future.globals.maxSize)) {
[17:38:14.535]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.535]                         on.exit(options(oopts), add = TRUE)
[17:38:14.535]                       }
[17:38:14.535]                       {
[17:38:14.535]                         lapply(seq_along(...future.elements_ii), 
[17:38:14.535]                           FUN = function(jj) {
[17:38:14.535]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.535]                             ...future.FUN(...future.X_jj, ...)
[17:38:14.535]                           })
[17:38:14.535]                       }
[17:38:14.535]                     }, args = future.call.arguments)
[17:38:14.535]                   }
[17:38:14.535]                 }, immediateCondition = function(cond) {
[17:38:14.535]                   sendCondition <- ...future.makeSendCondition()
[17:38:14.535]                   sendCondition(cond)
[17:38:14.535]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.535]                   {
[17:38:14.535]                     inherits <- base::inherits
[17:38:14.535]                     invokeRestart <- base::invokeRestart
[17:38:14.535]                     is.null <- base::is.null
[17:38:14.535]                     muffled <- FALSE
[17:38:14.535]                     if (inherits(cond, "message")) {
[17:38:14.535]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:14.535]                       if (muffled) 
[17:38:14.535]                         invokeRestart("muffleMessage")
[17:38:14.535]                     }
[17:38:14.535]                     else if (inherits(cond, "warning")) {
[17:38:14.535]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:14.535]                       if (muffled) 
[17:38:14.535]                         invokeRestart("muffleWarning")
[17:38:14.535]                     }
[17:38:14.535]                     else if (inherits(cond, "condition")) {
[17:38:14.535]                       if (!is.null(pattern)) {
[17:38:14.535]                         computeRestarts <- base::computeRestarts
[17:38:14.535]                         grepl <- base::grepl
[17:38:14.535]                         restarts <- computeRestarts(cond)
[17:38:14.535]                         for (restart in restarts) {
[17:38:14.535]                           name <- restart$name
[17:38:14.535]                           if (is.null(name)) 
[17:38:14.535]                             next
[17:38:14.535]                           if (!grepl(pattern, name)) 
[17:38:14.535]                             next
[17:38:14.535]                           invokeRestart(restart)
[17:38:14.535]                           muffled <- TRUE
[17:38:14.535]                           break
[17:38:14.535]                         }
[17:38:14.535]                       }
[17:38:14.535]                     }
[17:38:14.535]                     invisible(muffled)
[17:38:14.535]                   }
[17:38:14.535]                   muffleCondition(cond)
[17:38:14.535]                 })
[17:38:14.535]             }))
[17:38:14.535]             future::FutureResult(value = ...future.value$value, 
[17:38:14.535]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:14.535]                   ...future.rng), globalenv = if (FALSE) 
[17:38:14.535]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:14.535]                     ...future.globalenv.names))
[17:38:14.535]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:14.535]         }, condition = base::local({
[17:38:14.535]             c <- base::c
[17:38:14.535]             inherits <- base::inherits
[17:38:14.535]             invokeRestart <- base::invokeRestart
[17:38:14.535]             length <- base::length
[17:38:14.535]             list <- base::list
[17:38:14.535]             seq.int <- base::seq.int
[17:38:14.535]             signalCondition <- base::signalCondition
[17:38:14.535]             sys.calls <- base::sys.calls
[17:38:14.535]             `[[` <- base::`[[`
[17:38:14.535]             `+` <- base::`+`
[17:38:14.535]             `<<-` <- base::`<<-`
[17:38:14.535]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:14.535]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:14.535]                   3L)]
[17:38:14.535]             }
[17:38:14.535]             function(cond) {
[17:38:14.535]                 is_error <- inherits(cond, "error")
[17:38:14.535]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:14.535]                   NULL)
[17:38:14.535]                 if (is_error) {
[17:38:14.535]                   sessionInformation <- function() {
[17:38:14.535]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:14.535]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:14.535]                       search = base::search(), system = base::Sys.info())
[17:38:14.535]                   }
[17:38:14.535]                   ...future.conditions[[length(...future.conditions) + 
[17:38:14.535]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:14.535]                     cond$call), session = sessionInformation(), 
[17:38:14.535]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:14.535]                   signalCondition(cond)
[17:38:14.535]                 }
[17:38:14.535]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:14.535]                 "immediateCondition"))) {
[17:38:14.535]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:14.535]                   ...future.conditions[[length(...future.conditions) + 
[17:38:14.535]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:14.535]                   if (TRUE && !signal) {
[17:38:14.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.535]                     {
[17:38:14.535]                       inherits <- base::inherits
[17:38:14.535]                       invokeRestart <- base::invokeRestart
[17:38:14.535]                       is.null <- base::is.null
[17:38:14.535]                       muffled <- FALSE
[17:38:14.535]                       if (inherits(cond, "message")) {
[17:38:14.535]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:14.535]                         if (muffled) 
[17:38:14.535]                           invokeRestart("muffleMessage")
[17:38:14.535]                       }
[17:38:14.535]                       else if (inherits(cond, "warning")) {
[17:38:14.535]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:14.535]                         if (muffled) 
[17:38:14.535]                           invokeRestart("muffleWarning")
[17:38:14.535]                       }
[17:38:14.535]                       else if (inherits(cond, "condition")) {
[17:38:14.535]                         if (!is.null(pattern)) {
[17:38:14.535]                           computeRestarts <- base::computeRestarts
[17:38:14.535]                           grepl <- base::grepl
[17:38:14.535]                           restarts <- computeRestarts(cond)
[17:38:14.535]                           for (restart in restarts) {
[17:38:14.535]                             name <- restart$name
[17:38:14.535]                             if (is.null(name)) 
[17:38:14.535]                               next
[17:38:14.535]                             if (!grepl(pattern, name)) 
[17:38:14.535]                               next
[17:38:14.535]                             invokeRestart(restart)
[17:38:14.535]                             muffled <- TRUE
[17:38:14.535]                             break
[17:38:14.535]                           }
[17:38:14.535]                         }
[17:38:14.535]                       }
[17:38:14.535]                       invisible(muffled)
[17:38:14.535]                     }
[17:38:14.535]                     muffleCondition(cond, pattern = "^muffle")
[17:38:14.535]                   }
[17:38:14.535]                 }
[17:38:14.535]                 else {
[17:38:14.535]                   if (TRUE) {
[17:38:14.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.535]                     {
[17:38:14.535]                       inherits <- base::inherits
[17:38:14.535]                       invokeRestart <- base::invokeRestart
[17:38:14.535]                       is.null <- base::is.null
[17:38:14.535]                       muffled <- FALSE
[17:38:14.535]                       if (inherits(cond, "message")) {
[17:38:14.535]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:14.535]                         if (muffled) 
[17:38:14.535]                           invokeRestart("muffleMessage")
[17:38:14.535]                       }
[17:38:14.535]                       else if (inherits(cond, "warning")) {
[17:38:14.535]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:14.535]                         if (muffled) 
[17:38:14.535]                           invokeRestart("muffleWarning")
[17:38:14.535]                       }
[17:38:14.535]                       else if (inherits(cond, "condition")) {
[17:38:14.535]                         if (!is.null(pattern)) {
[17:38:14.535]                           computeRestarts <- base::computeRestarts
[17:38:14.535]                           grepl <- base::grepl
[17:38:14.535]                           restarts <- computeRestarts(cond)
[17:38:14.535]                           for (restart in restarts) {
[17:38:14.535]                             name <- restart$name
[17:38:14.535]                             if (is.null(name)) 
[17:38:14.535]                               next
[17:38:14.535]                             if (!grepl(pattern, name)) 
[17:38:14.535]                               next
[17:38:14.535]                             invokeRestart(restart)
[17:38:14.535]                             muffled <- TRUE
[17:38:14.535]                             break
[17:38:14.535]                           }
[17:38:14.535]                         }
[17:38:14.535]                       }
[17:38:14.535]                       invisible(muffled)
[17:38:14.535]                     }
[17:38:14.535]                     muffleCondition(cond, pattern = "^muffle")
[17:38:14.535]                   }
[17:38:14.535]                 }
[17:38:14.535]             }
[17:38:14.535]         }))
[17:38:14.535]     }, error = function(ex) {
[17:38:14.535]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:14.535]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:14.535]                 ...future.rng), started = ...future.startTime, 
[17:38:14.535]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:14.535]             version = "1.8"), class = "FutureResult")
[17:38:14.535]     }, finally = {
[17:38:14.535]         if (!identical(...future.workdir, getwd())) 
[17:38:14.535]             setwd(...future.workdir)
[17:38:14.535]         {
[17:38:14.535]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:14.535]                 ...future.oldOptions$nwarnings <- NULL
[17:38:14.535]             }
[17:38:14.535]             base::options(...future.oldOptions)
[17:38:14.535]             if (.Platform$OS.type == "windows") {
[17:38:14.535]                 old_names <- names(...future.oldEnvVars)
[17:38:14.535]                 envs <- base::Sys.getenv()
[17:38:14.535]                 names <- names(envs)
[17:38:14.535]                 common <- intersect(names, old_names)
[17:38:14.535]                 added <- setdiff(names, old_names)
[17:38:14.535]                 removed <- setdiff(old_names, names)
[17:38:14.535]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:14.535]                   envs[common]]
[17:38:14.535]                 NAMES <- toupper(changed)
[17:38:14.535]                 args <- list()
[17:38:14.535]                 for (kk in seq_along(NAMES)) {
[17:38:14.535]                   name <- changed[[kk]]
[17:38:14.535]                   NAME <- NAMES[[kk]]
[17:38:14.535]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.535]                     next
[17:38:14.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:14.535]                 }
[17:38:14.535]                 NAMES <- toupper(added)
[17:38:14.535]                 for (kk in seq_along(NAMES)) {
[17:38:14.535]                   name <- added[[kk]]
[17:38:14.535]                   NAME <- NAMES[[kk]]
[17:38:14.535]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.535]                     next
[17:38:14.535]                   args[[name]] <- ""
[17:38:14.535]                 }
[17:38:14.535]                 NAMES <- toupper(removed)
[17:38:14.535]                 for (kk in seq_along(NAMES)) {
[17:38:14.535]                   name <- removed[[kk]]
[17:38:14.535]                   NAME <- NAMES[[kk]]
[17:38:14.535]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.535]                     next
[17:38:14.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:14.535]                 }
[17:38:14.535]                 if (length(args) > 0) 
[17:38:14.535]                   base::do.call(base::Sys.setenv, args = args)
[17:38:14.535]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:14.535]             }
[17:38:14.535]             else {
[17:38:14.535]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:14.535]             }
[17:38:14.535]             {
[17:38:14.535]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:14.535]                   0L) {
[17:38:14.535]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:14.535]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:14.535]                   base::options(opts)
[17:38:14.535]                 }
[17:38:14.535]                 {
[17:38:14.535]                   {
[17:38:14.535]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:14.535]                     NULL
[17:38:14.535]                   }
[17:38:14.535]                   options(future.plan = NULL)
[17:38:14.535]                   if (is.na(NA_character_)) 
[17:38:14.535]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:14.535]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:14.535]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:14.535]                     .init = FALSE)
[17:38:14.535]                 }
[17:38:14.535]             }
[17:38:14.535]         }
[17:38:14.535]     })
[17:38:14.535]     if (TRUE) {
[17:38:14.535]         base::sink(type = "output", split = FALSE)
[17:38:14.535]         if (TRUE) {
[17:38:14.535]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:14.535]         }
[17:38:14.535]         else {
[17:38:14.535]             ...future.result["stdout"] <- base::list(NULL)
[17:38:14.535]         }
[17:38:14.535]         base::close(...future.stdout)
[17:38:14.535]         ...future.stdout <- NULL
[17:38:14.535]     }
[17:38:14.535]     ...future.result$conditions <- ...future.conditions
[17:38:14.535]     ...future.result$finished <- base::Sys.time()
[17:38:14.535]     ...future.result
[17:38:14.535] }
[17:38:14.538] Exporting 5 global objects (4.16 KiB) to cluster node #1 ...
[17:38:14.538] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ...
[17:38:14.538] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ... DONE
[17:38:14.539] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[17:38:14.539] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[17:38:14.539] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:38:14.540] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:38:14.540] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:14.540] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:14.540] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:14.541] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:14.541] Exporting 5 global objects (4.16 KiB) to cluster node #1 ... DONE
[17:38:14.541] MultisessionFuture started
[17:38:14.542] - Launch lazy future ... done
[17:38:14.542] run() for ‘MultisessionFuture’ ... done
[17:38:14.542] Created future:
[17:38:14.542] MultisessionFuture:
[17:38:14.542] Label: ‘future_sapply-1’
[17:38:14.542] Expression:
[17:38:14.542] {
[17:38:14.542]     do.call(function(...) {
[17:38:14.542]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.542]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:14.542]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.542]             on.exit(options(oopts), add = TRUE)
[17:38:14.542]         }
[17:38:14.542]         {
[17:38:14.542]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:14.542]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.542]                 ...future.FUN(...future.X_jj, ...)
[17:38:14.542]             })
[17:38:14.542]         }
[17:38:14.542]     }, args = future.call.arguments)
[17:38:14.542] }
[17:38:14.542] Lazy evaluation: FALSE
[17:38:14.542] Asynchronous evaluation: TRUE
[17:38:14.542] Local evaluation: TRUE
[17:38:14.542] Environment: R_GlobalEnv
[17:38:14.542] Capture standard output: TRUE
[17:38:14.542] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:14.542] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:14.542] Packages: <none>
[17:38:14.542] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:14.542] Resolved: FALSE
[17:38:14.542] Value: <not collected>
[17:38:14.542] Conditions captured: <none>
[17:38:14.542] Early signaling: FALSE
[17:38:14.542] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:14.542] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:14.553] Chunk #1 of 2 ... DONE
[17:38:14.554] Chunk #2 of 2 ...
[17:38:14.554]  - Finding globals in 'X' for chunk #2 ...
[17:38:14.554] getGlobalsAndPackages() ...
[17:38:14.554] Searching for globals...
[17:38:14.554] 
[17:38:14.554] Searching for globals ... DONE
[17:38:14.554] - globals: [0] <none>
[17:38:14.554] getGlobalsAndPackages() ... DONE
[17:38:14.554]    + additional globals found: [n=0] 
[17:38:14.555]    + additional namespaces needed: [n=0] 
[17:38:14.555]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:14.555]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:14.555]  - seeds: <none>
[17:38:14.555]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.555] getGlobalsAndPackages() ...
[17:38:14.555] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.555] Resolving globals: FALSE
[17:38:14.555] Tweak future expression to call with '...' arguments ...
[17:38:14.555] {
[17:38:14.555]     do.call(function(...) {
[17:38:14.555]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.555]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:14.555]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.555]             on.exit(options(oopts), add = TRUE)
[17:38:14.555]         }
[17:38:14.555]         {
[17:38:14.555]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:14.555]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.555]                 ...future.FUN(...future.X_jj, ...)
[17:38:14.555]             })
[17:38:14.555]         }
[17:38:14.555]     }, args = future.call.arguments)
[17:38:14.555] }
[17:38:14.556] Tweak future expression to call with '...' arguments ... DONE
[17:38:14.556] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.556] 
[17:38:14.556] getGlobalsAndPackages() ... DONE
[17:38:14.557] run() for ‘Future’ ...
[17:38:14.557] - state: ‘created’
[17:38:14.557] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:14.571] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:14.571] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:14.572]   - Field: ‘node’
[17:38:14.572]   - Field: ‘label’
[17:38:14.572]   - Field: ‘local’
[17:38:14.572]   - Field: ‘owner’
[17:38:14.572]   - Field: ‘envir’
[17:38:14.572]   - Field: ‘workers’
[17:38:14.572]   - Field: ‘packages’
[17:38:14.572]   - Field: ‘gc’
[17:38:14.572]   - Field: ‘conditions’
[17:38:14.572]   - Field: ‘persistent’
[17:38:14.573]   - Field: ‘expr’
[17:38:14.573]   - Field: ‘uuid’
[17:38:14.573]   - Field: ‘seed’
[17:38:14.573]   - Field: ‘version’
[17:38:14.573]   - Field: ‘result’
[17:38:14.573]   - Field: ‘asynchronous’
[17:38:14.573]   - Field: ‘calls’
[17:38:14.573]   - Field: ‘globals’
[17:38:14.573]   - Field: ‘stdout’
[17:38:14.573]   - Field: ‘earlySignal’
[17:38:14.574]   - Field: ‘lazy’
[17:38:14.574]   - Field: ‘state’
[17:38:14.574] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:14.574] - Launch lazy future ...
[17:38:14.574] Packages needed by the future expression (n = 0): <none>
[17:38:14.574] Packages needed by future strategies (n = 0): <none>
[17:38:14.575] {
[17:38:14.575]     {
[17:38:14.575]         {
[17:38:14.575]             ...future.startTime <- base::Sys.time()
[17:38:14.575]             {
[17:38:14.575]                 {
[17:38:14.575]                   {
[17:38:14.575]                     {
[17:38:14.575]                       base::local({
[17:38:14.575]                         has_future <- base::requireNamespace("future", 
[17:38:14.575]                           quietly = TRUE)
[17:38:14.575]                         if (has_future) {
[17:38:14.575]                           ns <- base::getNamespace("future")
[17:38:14.575]                           version <- ns[[".package"]][["version"]]
[17:38:14.575]                           if (is.null(version)) 
[17:38:14.575]                             version <- utils::packageVersion("future")
[17:38:14.575]                         }
[17:38:14.575]                         else {
[17:38:14.575]                           version <- NULL
[17:38:14.575]                         }
[17:38:14.575]                         if (!has_future || version < "1.8.0") {
[17:38:14.575]                           info <- base::c(r_version = base::gsub("R version ", 
[17:38:14.575]                             "", base::R.version$version.string), 
[17:38:14.575]                             platform = base::sprintf("%s (%s-bit)", 
[17:38:14.575]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:38:14.575]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:14.575]                               "release", "version")], collapse = " "), 
[17:38:14.575]                             hostname = base::Sys.info()[["nodename"]])
[17:38:14.575]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:38:14.575]                             info)
[17:38:14.575]                           info <- base::paste(info, collapse = "; ")
[17:38:14.575]                           if (!has_future) {
[17:38:14.575]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:14.575]                               info)
[17:38:14.575]                           }
[17:38:14.575]                           else {
[17:38:14.575]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:14.575]                               info, version)
[17:38:14.575]                           }
[17:38:14.575]                           base::stop(msg)
[17:38:14.575]                         }
[17:38:14.575]                       })
[17:38:14.575]                     }
[17:38:14.575]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:14.575]                     base::options(mc.cores = 1L)
[17:38:14.575]                   }
[17:38:14.575]                   ...future.strategy.old <- future::plan("list")
[17:38:14.575]                   options(future.plan = NULL)
[17:38:14.575]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:14.575]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:14.575]                 }
[17:38:14.575]                 ...future.workdir <- getwd()
[17:38:14.575]             }
[17:38:14.575]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:14.575]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:14.575]         }
[17:38:14.575]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:14.575]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:14.575]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:14.575]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:14.575]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:14.575]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:14.575]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:14.575]             base::names(...future.oldOptions))
[17:38:14.575]     }
[17:38:14.575]     if (FALSE) {
[17:38:14.575]     }
[17:38:14.575]     else {
[17:38:14.575]         if (TRUE) {
[17:38:14.575]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:14.575]                 open = "w")
[17:38:14.575]         }
[17:38:14.575]         else {
[17:38:14.575]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:14.575]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:14.575]         }
[17:38:14.575]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:14.575]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:14.575]             base::sink(type = "output", split = FALSE)
[17:38:14.575]             base::close(...future.stdout)
[17:38:14.575]         }, add = TRUE)
[17:38:14.575]     }
[17:38:14.575]     ...future.frame <- base::sys.nframe()
[17:38:14.575]     ...future.conditions <- base::list()
[17:38:14.575]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:14.575]     if (FALSE) {
[17:38:14.575]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:14.575]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:14.575]     }
[17:38:14.575]     ...future.result <- base::tryCatch({
[17:38:14.575]         base::withCallingHandlers({
[17:38:14.575]             ...future.value <- base::withVisible(base::local({
[17:38:14.575]                 ...future.makeSendCondition <- base::local({
[17:38:14.575]                   sendCondition <- NULL
[17:38:14.575]                   function(frame = 1L) {
[17:38:14.575]                     if (is.function(sendCondition)) 
[17:38:14.575]                       return(sendCondition)
[17:38:14.575]                     ns <- getNamespace("parallel")
[17:38:14.575]                     if (exists("sendData", mode = "function", 
[17:38:14.575]                       envir = ns)) {
[17:38:14.575]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:14.575]                         envir = ns)
[17:38:14.575]                       envir <- sys.frame(frame)
[17:38:14.575]                       master <- NULL
[17:38:14.575]                       while (!identical(envir, .GlobalEnv) && 
[17:38:14.575]                         !identical(envir, emptyenv())) {
[17:38:14.575]                         if (exists("master", mode = "list", envir = envir, 
[17:38:14.575]                           inherits = FALSE)) {
[17:38:14.575]                           master <- get("master", mode = "list", 
[17:38:14.575]                             envir = envir, inherits = FALSE)
[17:38:14.575]                           if (inherits(master, c("SOCKnode", 
[17:38:14.575]                             "SOCK0node"))) {
[17:38:14.575]                             sendCondition <<- function(cond) {
[17:38:14.575]                               data <- list(type = "VALUE", value = cond, 
[17:38:14.575]                                 success = TRUE)
[17:38:14.575]                               parallel_sendData(master, data)
[17:38:14.575]                             }
[17:38:14.575]                             return(sendCondition)
[17:38:14.575]                           }
[17:38:14.575]                         }
[17:38:14.575]                         frame <- frame + 1L
[17:38:14.575]                         envir <- sys.frame(frame)
[17:38:14.575]                       }
[17:38:14.575]                     }
[17:38:14.575]                     sendCondition <<- function(cond) NULL
[17:38:14.575]                   }
[17:38:14.575]                 })
[17:38:14.575]                 withCallingHandlers({
[17:38:14.575]                   {
[17:38:14.575]                     do.call(function(...) {
[17:38:14.575]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.575]                       if (!identical(...future.globals.maxSize.org, 
[17:38:14.575]                         ...future.globals.maxSize)) {
[17:38:14.575]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.575]                         on.exit(options(oopts), add = TRUE)
[17:38:14.575]                       }
[17:38:14.575]                       {
[17:38:14.575]                         lapply(seq_along(...future.elements_ii), 
[17:38:14.575]                           FUN = function(jj) {
[17:38:14.575]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.575]                             ...future.FUN(...future.X_jj, ...)
[17:38:14.575]                           })
[17:38:14.575]                       }
[17:38:14.575]                     }, args = future.call.arguments)
[17:38:14.575]                   }
[17:38:14.575]                 }, immediateCondition = function(cond) {
[17:38:14.575]                   sendCondition <- ...future.makeSendCondition()
[17:38:14.575]                   sendCondition(cond)
[17:38:14.575]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.575]                   {
[17:38:14.575]                     inherits <- base::inherits
[17:38:14.575]                     invokeRestart <- base::invokeRestart
[17:38:14.575]                     is.null <- base::is.null
[17:38:14.575]                     muffled <- FALSE
[17:38:14.575]                     if (inherits(cond, "message")) {
[17:38:14.575]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:14.575]                       if (muffled) 
[17:38:14.575]                         invokeRestart("muffleMessage")
[17:38:14.575]                     }
[17:38:14.575]                     else if (inherits(cond, "warning")) {
[17:38:14.575]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:14.575]                       if (muffled) 
[17:38:14.575]                         invokeRestart("muffleWarning")
[17:38:14.575]                     }
[17:38:14.575]                     else if (inherits(cond, "condition")) {
[17:38:14.575]                       if (!is.null(pattern)) {
[17:38:14.575]                         computeRestarts <- base::computeRestarts
[17:38:14.575]                         grepl <- base::grepl
[17:38:14.575]                         restarts <- computeRestarts(cond)
[17:38:14.575]                         for (restart in restarts) {
[17:38:14.575]                           name <- restart$name
[17:38:14.575]                           if (is.null(name)) 
[17:38:14.575]                             next
[17:38:14.575]                           if (!grepl(pattern, name)) 
[17:38:14.575]                             next
[17:38:14.575]                           invokeRestart(restart)
[17:38:14.575]                           muffled <- TRUE
[17:38:14.575]                           break
[17:38:14.575]                         }
[17:38:14.575]                       }
[17:38:14.575]                     }
[17:38:14.575]                     invisible(muffled)
[17:38:14.575]                   }
[17:38:14.575]                   muffleCondition(cond)
[17:38:14.575]                 })
[17:38:14.575]             }))
[17:38:14.575]             future::FutureResult(value = ...future.value$value, 
[17:38:14.575]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:14.575]                   ...future.rng), globalenv = if (FALSE) 
[17:38:14.575]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:14.575]                     ...future.globalenv.names))
[17:38:14.575]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:14.575]         }, condition = base::local({
[17:38:14.575]             c <- base::c
[17:38:14.575]             inherits <- base::inherits
[17:38:14.575]             invokeRestart <- base::invokeRestart
[17:38:14.575]             length <- base::length
[17:38:14.575]             list <- base::list
[17:38:14.575]             seq.int <- base::seq.int
[17:38:14.575]             signalCondition <- base::signalCondition
[17:38:14.575]             sys.calls <- base::sys.calls
[17:38:14.575]             `[[` <- base::`[[`
[17:38:14.575]             `+` <- base::`+`
[17:38:14.575]             `<<-` <- base::`<<-`
[17:38:14.575]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:14.575]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:14.575]                   3L)]
[17:38:14.575]             }
[17:38:14.575]             function(cond) {
[17:38:14.575]                 is_error <- inherits(cond, "error")
[17:38:14.575]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:14.575]                   NULL)
[17:38:14.575]                 if (is_error) {
[17:38:14.575]                   sessionInformation <- function() {
[17:38:14.575]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:14.575]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:14.575]                       search = base::search(), system = base::Sys.info())
[17:38:14.575]                   }
[17:38:14.575]                   ...future.conditions[[length(...future.conditions) + 
[17:38:14.575]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:14.575]                     cond$call), session = sessionInformation(), 
[17:38:14.575]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:14.575]                   signalCondition(cond)
[17:38:14.575]                 }
[17:38:14.575]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:14.575]                 "immediateCondition"))) {
[17:38:14.575]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:14.575]                   ...future.conditions[[length(...future.conditions) + 
[17:38:14.575]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:14.575]                   if (TRUE && !signal) {
[17:38:14.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.575]                     {
[17:38:14.575]                       inherits <- base::inherits
[17:38:14.575]                       invokeRestart <- base::invokeRestart
[17:38:14.575]                       is.null <- base::is.null
[17:38:14.575]                       muffled <- FALSE
[17:38:14.575]                       if (inherits(cond, "message")) {
[17:38:14.575]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:14.575]                         if (muffled) 
[17:38:14.575]                           invokeRestart("muffleMessage")
[17:38:14.575]                       }
[17:38:14.575]                       else if (inherits(cond, "warning")) {
[17:38:14.575]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:14.575]                         if (muffled) 
[17:38:14.575]                           invokeRestart("muffleWarning")
[17:38:14.575]                       }
[17:38:14.575]                       else if (inherits(cond, "condition")) {
[17:38:14.575]                         if (!is.null(pattern)) {
[17:38:14.575]                           computeRestarts <- base::computeRestarts
[17:38:14.575]                           grepl <- base::grepl
[17:38:14.575]                           restarts <- computeRestarts(cond)
[17:38:14.575]                           for (restart in restarts) {
[17:38:14.575]                             name <- restart$name
[17:38:14.575]                             if (is.null(name)) 
[17:38:14.575]                               next
[17:38:14.575]                             if (!grepl(pattern, name)) 
[17:38:14.575]                               next
[17:38:14.575]                             invokeRestart(restart)
[17:38:14.575]                             muffled <- TRUE
[17:38:14.575]                             break
[17:38:14.575]                           }
[17:38:14.575]                         }
[17:38:14.575]                       }
[17:38:14.575]                       invisible(muffled)
[17:38:14.575]                     }
[17:38:14.575]                     muffleCondition(cond, pattern = "^muffle")
[17:38:14.575]                   }
[17:38:14.575]                 }
[17:38:14.575]                 else {
[17:38:14.575]                   if (TRUE) {
[17:38:14.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.575]                     {
[17:38:14.575]                       inherits <- base::inherits
[17:38:14.575]                       invokeRestart <- base::invokeRestart
[17:38:14.575]                       is.null <- base::is.null
[17:38:14.575]                       muffled <- FALSE
[17:38:14.575]                       if (inherits(cond, "message")) {
[17:38:14.575]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:14.575]                         if (muffled) 
[17:38:14.575]                           invokeRestart("muffleMessage")
[17:38:14.575]                       }
[17:38:14.575]                       else if (inherits(cond, "warning")) {
[17:38:14.575]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:14.575]                         if (muffled) 
[17:38:14.575]                           invokeRestart("muffleWarning")
[17:38:14.575]                       }
[17:38:14.575]                       else if (inherits(cond, "condition")) {
[17:38:14.575]                         if (!is.null(pattern)) {
[17:38:14.575]                           computeRestarts <- base::computeRestarts
[17:38:14.575]                           grepl <- base::grepl
[17:38:14.575]                           restarts <- computeRestarts(cond)
[17:38:14.575]                           for (restart in restarts) {
[17:38:14.575]                             name <- restart$name
[17:38:14.575]                             if (is.null(name)) 
[17:38:14.575]                               next
[17:38:14.575]                             if (!grepl(pattern, name)) 
[17:38:14.575]                               next
[17:38:14.575]                             invokeRestart(restart)
[17:38:14.575]                             muffled <- TRUE
[17:38:14.575]                             break
[17:38:14.575]                           }
[17:38:14.575]                         }
[17:38:14.575]                       }
[17:38:14.575]                       invisible(muffled)
[17:38:14.575]                     }
[17:38:14.575]                     muffleCondition(cond, pattern = "^muffle")
[17:38:14.575]                   }
[17:38:14.575]                 }
[17:38:14.575]             }
[17:38:14.575]         }))
[17:38:14.575]     }, error = function(ex) {
[17:38:14.575]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:14.575]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:14.575]                 ...future.rng), started = ...future.startTime, 
[17:38:14.575]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:14.575]             version = "1.8"), class = "FutureResult")
[17:38:14.575]     }, finally = {
[17:38:14.575]         if (!identical(...future.workdir, getwd())) 
[17:38:14.575]             setwd(...future.workdir)
[17:38:14.575]         {
[17:38:14.575]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:14.575]                 ...future.oldOptions$nwarnings <- NULL
[17:38:14.575]             }
[17:38:14.575]             base::options(...future.oldOptions)
[17:38:14.575]             if (.Platform$OS.type == "windows") {
[17:38:14.575]                 old_names <- names(...future.oldEnvVars)
[17:38:14.575]                 envs <- base::Sys.getenv()
[17:38:14.575]                 names <- names(envs)
[17:38:14.575]                 common <- intersect(names, old_names)
[17:38:14.575]                 added <- setdiff(names, old_names)
[17:38:14.575]                 removed <- setdiff(old_names, names)
[17:38:14.575]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:14.575]                   envs[common]]
[17:38:14.575]                 NAMES <- toupper(changed)
[17:38:14.575]                 args <- list()
[17:38:14.575]                 for (kk in seq_along(NAMES)) {
[17:38:14.575]                   name <- changed[[kk]]
[17:38:14.575]                   NAME <- NAMES[[kk]]
[17:38:14.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.575]                     next
[17:38:14.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:14.575]                 }
[17:38:14.575]                 NAMES <- toupper(added)
[17:38:14.575]                 for (kk in seq_along(NAMES)) {
[17:38:14.575]                   name <- added[[kk]]
[17:38:14.575]                   NAME <- NAMES[[kk]]
[17:38:14.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.575]                     next
[17:38:14.575]                   args[[name]] <- ""
[17:38:14.575]                 }
[17:38:14.575]                 NAMES <- toupper(removed)
[17:38:14.575]                 for (kk in seq_along(NAMES)) {
[17:38:14.575]                   name <- removed[[kk]]
[17:38:14.575]                   NAME <- NAMES[[kk]]
[17:38:14.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.575]                     next
[17:38:14.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:14.575]                 }
[17:38:14.575]                 if (length(args) > 0) 
[17:38:14.575]                   base::do.call(base::Sys.setenv, args = args)
[17:38:14.575]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:14.575]             }
[17:38:14.575]             else {
[17:38:14.575]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:14.575]             }
[17:38:14.575]             {
[17:38:14.575]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:14.575]                   0L) {
[17:38:14.575]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:14.575]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:14.575]                   base::options(opts)
[17:38:14.575]                 }
[17:38:14.575]                 {
[17:38:14.575]                   {
[17:38:14.575]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:14.575]                     NULL
[17:38:14.575]                   }
[17:38:14.575]                   options(future.plan = NULL)
[17:38:14.575]                   if (is.na(NA_character_)) 
[17:38:14.575]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:14.575]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:14.575]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:14.575]                     .init = FALSE)
[17:38:14.575]                 }
[17:38:14.575]             }
[17:38:14.575]         }
[17:38:14.575]     })
[17:38:14.575]     if (TRUE) {
[17:38:14.575]         base::sink(type = "output", split = FALSE)
[17:38:14.575]         if (TRUE) {
[17:38:14.575]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:14.575]         }
[17:38:14.575]         else {
[17:38:14.575]             ...future.result["stdout"] <- base::list(NULL)
[17:38:14.575]         }
[17:38:14.575]         base::close(...future.stdout)
[17:38:14.575]         ...future.stdout <- NULL
[17:38:14.575]     }
[17:38:14.575]     ...future.result$conditions <- ...future.conditions
[17:38:14.575]     ...future.result$finished <- base::Sys.time()
[17:38:14.575]     ...future.result
[17:38:14.575] }
[17:38:14.577] Exporting 5 global objects (4.16 KiB) to cluster node #2 ...
[17:38:14.578] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ...
[17:38:14.578] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ... DONE
[17:38:14.578] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[17:38:14.579] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[17:38:14.579] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:38:14.579] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:38:14.579] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:14.580] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:14.580] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:14.580] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:14.580] Exporting 5 global objects (4.16 KiB) to cluster node #2 ... DONE
[17:38:14.581] MultisessionFuture started
[17:38:14.581] - Launch lazy future ... done
[17:38:14.581] run() for ‘MultisessionFuture’ ... done
[17:38:14.581] Created future:
[17:38:14.581] MultisessionFuture:
[17:38:14.581] Label: ‘future_sapply-2’
[17:38:14.581] Expression:
[17:38:14.581] {
[17:38:14.581]     do.call(function(...) {
[17:38:14.581]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.581]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:14.581]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.581]             on.exit(options(oopts), add = TRUE)
[17:38:14.581]         }
[17:38:14.581]         {
[17:38:14.581]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:14.581]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.581]                 ...future.FUN(...future.X_jj, ...)
[17:38:14.581]             })
[17:38:14.581]         }
[17:38:14.581]     }, args = future.call.arguments)
[17:38:14.581] }
[17:38:14.581] Lazy evaluation: FALSE
[17:38:14.581] Asynchronous evaluation: TRUE
[17:38:14.581] Local evaluation: TRUE
[17:38:14.581] Environment: R_GlobalEnv
[17:38:14.581] Capture standard output: TRUE
[17:38:14.581] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:14.581] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:38:14.581] Packages: <none>
[17:38:14.581] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:14.581] Resolved: FALSE
[17:38:14.581] Value: <not collected>
[17:38:14.581] Conditions captured: <none>
[17:38:14.581] Early signaling: FALSE
[17:38:14.581] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:14.581] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:14.593] Chunk #2 of 2 ... DONE
[17:38:14.593] Launching 2 futures (chunks) ... DONE
[17:38:14.593] Resolving 2 futures (chunks) ...
[17:38:14.593] resolve() on list ...
[17:38:14.593]  recursive: 0
[17:38:14.593]  length: 2
[17:38:14.594] 
[17:38:14.594] receiveMessageFromWorker() for ClusterFuture ...
[17:38:14.594] - Validating connection of MultisessionFuture
[17:38:14.594] - received message: FutureResult
[17:38:14.594] - Received FutureResult
[17:38:14.595] - Erased future from FutureRegistry
[17:38:14.595] result() for ClusterFuture ...
[17:38:14.595] - result already collected: FutureResult
[17:38:14.595] result() for ClusterFuture ... done
[17:38:14.595] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:14.595] Future #1
[17:38:14.595] result() for ClusterFuture ...
[17:38:14.595] - result already collected: FutureResult
[17:38:14.595] result() for ClusterFuture ... done
[17:38:14.595] result() for ClusterFuture ...
[17:38:14.595] - result already collected: FutureResult
[17:38:14.596] result() for ClusterFuture ... done
[17:38:14.596] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:14.596] - nx: 2
[17:38:14.596] - relay: TRUE
[17:38:14.596] - stdout: TRUE
[17:38:14.596] - signal: TRUE
[17:38:14.596] - resignal: FALSE
[17:38:14.596] - force: TRUE
[17:38:14.596] - relayed: [n=2] FALSE, FALSE
[17:38:14.596] - queued futures: [n=2] FALSE, FALSE
[17:38:14.596]  - until=1
[17:38:14.597]  - relaying element #1
[17:38:14.597] result() for ClusterFuture ...
[17:38:14.597] - result already collected: FutureResult
[17:38:14.597] result() for ClusterFuture ... done
[17:38:14.597] result() for ClusterFuture ...
[17:38:14.597] - result already collected: FutureResult
[17:38:14.597] result() for ClusterFuture ... done
[17:38:14.597] result() for ClusterFuture ...
[17:38:14.597] - result already collected: FutureResult
[17:38:14.597] result() for ClusterFuture ... done
[17:38:14.597] result() for ClusterFuture ...
[17:38:14.598] - result already collected: FutureResult
[17:38:14.598] result() for ClusterFuture ... done
[17:38:14.598] - relayed: [n=2] TRUE, FALSE
[17:38:14.598] - queued futures: [n=2] TRUE, FALSE
[17:38:14.598] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:14.598]  length: 1 (resolved future 1)
[17:38:14.626] receiveMessageFromWorker() for ClusterFuture ...
[17:38:14.627] - Validating connection of MultisessionFuture
[17:38:14.627] - received message: FutureResult
[17:38:14.627] - Received FutureResult
[17:38:14.627] - Erased future from FutureRegistry
[17:38:14.627] result() for ClusterFuture ...
[17:38:14.627] - result already collected: FutureResult
[17:38:14.627] result() for ClusterFuture ... done
[17:38:14.627] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:14.627] Future #2
[17:38:14.628] result() for ClusterFuture ...
[17:38:14.628] - result already collected: FutureResult
[17:38:14.628] result() for ClusterFuture ... done
[17:38:14.628] result() for ClusterFuture ...
[17:38:14.628] - result already collected: FutureResult
[17:38:14.628] result() for ClusterFuture ... done
[17:38:14.628] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:14.628] - nx: 2
[17:38:14.628] - relay: TRUE
[17:38:14.628] - stdout: TRUE
[17:38:14.628] - signal: TRUE
[17:38:14.629] - resignal: FALSE
[17:38:14.629] - force: TRUE
[17:38:14.629] - relayed: [n=2] TRUE, FALSE
[17:38:14.629] - queued futures: [n=2] TRUE, FALSE
[17:38:14.629]  - until=2
[17:38:14.629]  - relaying element #2
[17:38:14.629] result() for ClusterFuture ...
[17:38:14.629] - result already collected: FutureResult
[17:38:14.629] result() for ClusterFuture ... done
[17:38:14.629] result() for ClusterFuture ...
[17:38:14.629] - result already collected: FutureResult
[17:38:14.630] result() for ClusterFuture ... done
[17:38:14.630] result() for ClusterFuture ...
[17:38:14.630] - result already collected: FutureResult
[17:38:14.630] result() for ClusterFuture ... done
[17:38:14.630] result() for ClusterFuture ...
[17:38:14.630] - result already collected: FutureResult
[17:38:14.630] result() for ClusterFuture ... done
[17:38:14.630] - relayed: [n=2] TRUE, TRUE
[17:38:14.630] - queued futures: [n=2] TRUE, TRUE
[17:38:14.630] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:14.630]  length: 0 (resolved future 2)
[17:38:14.631] Relaying remaining futures
[17:38:14.631] signalConditionsASAP(NULL, pos=0) ...
[17:38:14.631] - nx: 2
[17:38:14.631] - relay: TRUE
[17:38:14.631] - stdout: TRUE
[17:38:14.631] - signal: TRUE
[17:38:14.631] - resignal: FALSE
[17:38:14.631] - force: TRUE
[17:38:14.631] - relayed: [n=2] TRUE, TRUE
[17:38:14.631] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:14.631] - relayed: [n=2] TRUE, TRUE
[17:38:14.632] - queued futures: [n=2] TRUE, TRUE
[17:38:14.632] signalConditionsASAP(NULL, pos=0) ... done
[17:38:14.632] resolve() on list ... DONE
[17:38:14.632] result() for ClusterFuture ...
[17:38:14.632] - result already collected: FutureResult
[17:38:14.632] result() for ClusterFuture ... done
[17:38:14.632] result() for ClusterFuture ...
[17:38:14.632] - result already collected: FutureResult
[17:38:14.632] result() for ClusterFuture ... done
[17:38:14.632] result() for ClusterFuture ...
[17:38:14.632] - result already collected: FutureResult
[17:38:14.633] result() for ClusterFuture ... done
[17:38:14.633] result() for ClusterFuture ...
[17:38:14.633] - result already collected: FutureResult
[17:38:14.633] result() for ClusterFuture ... done
[17:38:14.633]  - Number of value chunks collected: 2
[17:38:14.633] Resolving 2 futures (chunks) ... DONE
[17:38:14.633] Reducing values from 2 chunks ...
[17:38:14.633]  - Number of values collected after concatenation: 4
[17:38:14.633]  - Number of values expected: 4
[17:38:14.633] Reducing values from 2 chunks ... DONE
[17:38:14.633] future_lapply() ... DONE
[17:38:14.634] future_lapply() ...
[17:38:14.639] Number of chunks: 2
[17:38:14.640] getGlobalsAndPackagesXApply() ...
[17:38:14.640]  - future.globals: TRUE
[17:38:14.640] getGlobalsAndPackages() ...
[17:38:14.640] Searching for globals...
[17:38:14.644] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[17:38:14.644] Searching for globals ... DONE
[17:38:14.644] Resolving globals: FALSE
[17:38:14.645] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[17:38:14.645] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:14.645] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:14.645] - packages: [1] ‘future.apply’
[17:38:14.646] getGlobalsAndPackages() ... DONE
[17:38:14.646]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:14.646]  - needed namespaces: [n=1] ‘future.apply’
[17:38:14.646] Finding globals ... DONE
[17:38:14.646]  - use_args: TRUE
[17:38:14.646]  - Getting '...' globals ...
[17:38:14.646] resolve() on list ...
[17:38:14.646]  recursive: 0
[17:38:14.647]  length: 1
[17:38:14.647]  elements: ‘...’
[17:38:14.647]  length: 0 (resolved future 1)
[17:38:14.647] resolve() on list ... DONE
[17:38:14.647]    - '...' content: [n=1] ‘y’
[17:38:14.647] List of 1
[17:38:14.647]  $ ...:List of 1
[17:38:14.647]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:14.647]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:14.647]  - attr(*, "where")=List of 1
[17:38:14.647]   ..$ ...:<environment: 0x5608040f0bd8> 
[17:38:14.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:14.647]  - attr(*, "resolved")= logi TRUE
[17:38:14.647]  - attr(*, "total_size")= num NA
[17:38:14.650]  - Getting '...' globals ... DONE
[17:38:14.650] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:14.650] List of 8
[17:38:14.650]  $ ...future.FUN:function (x, ...)  
[17:38:14.650]  $ x_FUN        :function (x, y)  
[17:38:14.650]  $ times        : int 15
[17:38:14.650]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:14.650]  $ stop_if_not  :function (...)  
[17:38:14.650]  $ dim          : int [1:2] 3 5
[17:38:14.650]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:14.650]  $ ...          :List of 1
[17:38:14.650]   ..$ y: num [1:5] 2 4 6 8 10
[17:38:14.650]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:14.650]  - attr(*, "where")=List of 8
[17:38:14.650]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:14.650]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:14.650]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:14.650]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:14.650]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:14.650]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:14.650]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:14.650]   ..$ ...          :<environment: 0x5608040f0bd8> 
[17:38:14.650]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:14.650]  - attr(*, "resolved")= logi FALSE
[17:38:14.650]  - attr(*, "total_size")= num 98600
[17:38:14.659] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:14.659] getGlobalsAndPackagesXApply() ... DONE
[17:38:14.660] Number of futures (= number of chunks): 2
[17:38:14.660] Launching 2 futures (chunks) ...
[17:38:14.660] Chunk #1 of 2 ...
[17:38:14.660]  - Finding globals in 'X' for chunk #1 ...
[17:38:14.660] getGlobalsAndPackages() ...
[17:38:14.660] Searching for globals...
[17:38:14.660] 
[17:38:14.661] Searching for globals ... DONE
[17:38:14.661] - globals: [0] <none>
[17:38:14.661] getGlobalsAndPackages() ... DONE
[17:38:14.661]    + additional globals found: [n=0] 
[17:38:14.661]    + additional namespaces needed: [n=0] 
[17:38:14.661]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:14.661]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:14.661]  - seeds: <none>
[17:38:14.661]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.661] getGlobalsAndPackages() ...
[17:38:14.661] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.662] Resolving globals: FALSE
[17:38:14.662] Tweak future expression to call with '...' arguments ...
[17:38:14.662] {
[17:38:14.662]     do.call(function(...) {
[17:38:14.662]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.662]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:14.662]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.662]             on.exit(options(oopts), add = TRUE)
[17:38:14.662]         }
[17:38:14.662]         {
[17:38:14.662]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:14.662]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.662]                 ...future.FUN(...future.X_jj, ...)
[17:38:14.662]             })
[17:38:14.662]         }
[17:38:14.662]     }, args = future.call.arguments)
[17:38:14.662] }
[17:38:14.662] Tweak future expression to call with '...' arguments ... DONE
[17:38:14.663] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.663] - packages: [1] ‘future.apply’
[17:38:14.663] getGlobalsAndPackages() ... DONE
[17:38:14.663] run() for ‘Future’ ...
[17:38:14.663] - state: ‘created’
[17:38:14.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:14.678] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:14.678] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:14.678]   - Field: ‘node’
[17:38:14.679]   - Field: ‘label’
[17:38:14.679]   - Field: ‘local’
[17:38:14.679]   - Field: ‘owner’
[17:38:14.679]   - Field: ‘envir’
[17:38:14.679]   - Field: ‘workers’
[17:38:14.679]   - Field: ‘packages’
[17:38:14.679]   - Field: ‘gc’
[17:38:14.679]   - Field: ‘conditions’
[17:38:14.679]   - Field: ‘persistent’
[17:38:14.679]   - Field: ‘expr’
[17:38:14.679]   - Field: ‘uuid’
[17:38:14.680]   - Field: ‘seed’
[17:38:14.680]   - Field: ‘version’
[17:38:14.680]   - Field: ‘result’
[17:38:14.680]   - Field: ‘asynchronous’
[17:38:14.680]   - Field: ‘calls’
[17:38:14.680]   - Field: ‘globals’
[17:38:14.680]   - Field: ‘stdout’
[17:38:14.680]   - Field: ‘earlySignal’
[17:38:14.680]   - Field: ‘lazy’
[17:38:14.680]   - Field: ‘state’
[17:38:14.680] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:14.681] - Launch lazy future ...
[17:38:14.681] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:14.681] Packages needed by future strategies (n = 0): <none>
[17:38:14.682] {
[17:38:14.682]     {
[17:38:14.682]         {
[17:38:14.682]             ...future.startTime <- base::Sys.time()
[17:38:14.682]             {
[17:38:14.682]                 {
[17:38:14.682]                   {
[17:38:14.682]                     {
[17:38:14.682]                       {
[17:38:14.682]                         base::local({
[17:38:14.682]                           has_future <- base::requireNamespace("future", 
[17:38:14.682]                             quietly = TRUE)
[17:38:14.682]                           if (has_future) {
[17:38:14.682]                             ns <- base::getNamespace("future")
[17:38:14.682]                             version <- ns[[".package"]][["version"]]
[17:38:14.682]                             if (is.null(version)) 
[17:38:14.682]                               version <- utils::packageVersion("future")
[17:38:14.682]                           }
[17:38:14.682]                           else {
[17:38:14.682]                             version <- NULL
[17:38:14.682]                           }
[17:38:14.682]                           if (!has_future || version < "1.8.0") {
[17:38:14.682]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:14.682]                               "", base::R.version$version.string), 
[17:38:14.682]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:14.682]                                 base::R.version$platform, 8 * 
[17:38:14.682]                                   base::.Machine$sizeof.pointer), 
[17:38:14.682]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:14.682]                                 "release", "version")], collapse = " "), 
[17:38:14.682]                               hostname = base::Sys.info()[["nodename"]])
[17:38:14.682]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:14.682]                               info)
[17:38:14.682]                             info <- base::paste(info, collapse = "; ")
[17:38:14.682]                             if (!has_future) {
[17:38:14.682]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:14.682]                                 info)
[17:38:14.682]                             }
[17:38:14.682]                             else {
[17:38:14.682]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:14.682]                                 info, version)
[17:38:14.682]                             }
[17:38:14.682]                             base::stop(msg)
[17:38:14.682]                           }
[17:38:14.682]                         })
[17:38:14.682]                       }
[17:38:14.682]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:14.682]                       base::options(mc.cores = 1L)
[17:38:14.682]                     }
[17:38:14.682]                     base::local({
[17:38:14.682]                       for (pkg in "future.apply") {
[17:38:14.682]                         base::loadNamespace(pkg)
[17:38:14.682]                         base::library(pkg, character.only = TRUE)
[17:38:14.682]                       }
[17:38:14.682]                     })
[17:38:14.682]                   }
[17:38:14.682]                   ...future.strategy.old <- future::plan("list")
[17:38:14.682]                   options(future.plan = NULL)
[17:38:14.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:14.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:14.682]                 }
[17:38:14.682]                 ...future.workdir <- getwd()
[17:38:14.682]             }
[17:38:14.682]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:14.682]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:14.682]         }
[17:38:14.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:14.682]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:14.682]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:14.682]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:14.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:14.682]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:14.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:14.682]             base::names(...future.oldOptions))
[17:38:14.682]     }
[17:38:14.682]     if (FALSE) {
[17:38:14.682]     }
[17:38:14.682]     else {
[17:38:14.682]         if (TRUE) {
[17:38:14.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:14.682]                 open = "w")
[17:38:14.682]         }
[17:38:14.682]         else {
[17:38:14.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:14.682]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:14.682]         }
[17:38:14.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:14.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:14.682]             base::sink(type = "output", split = FALSE)
[17:38:14.682]             base::close(...future.stdout)
[17:38:14.682]         }, add = TRUE)
[17:38:14.682]     }
[17:38:14.682]     ...future.frame <- base::sys.nframe()
[17:38:14.682]     ...future.conditions <- base::list()
[17:38:14.682]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:14.682]     if (FALSE) {
[17:38:14.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:14.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:14.682]     }
[17:38:14.682]     ...future.result <- base::tryCatch({
[17:38:14.682]         base::withCallingHandlers({
[17:38:14.682]             ...future.value <- base::withVisible(base::local({
[17:38:14.682]                 ...future.makeSendCondition <- base::local({
[17:38:14.682]                   sendCondition <- NULL
[17:38:14.682]                   function(frame = 1L) {
[17:38:14.682]                     if (is.function(sendCondition)) 
[17:38:14.682]                       return(sendCondition)
[17:38:14.682]                     ns <- getNamespace("parallel")
[17:38:14.682]                     if (exists("sendData", mode = "function", 
[17:38:14.682]                       envir = ns)) {
[17:38:14.682]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:14.682]                         envir = ns)
[17:38:14.682]                       envir <- sys.frame(frame)
[17:38:14.682]                       master <- NULL
[17:38:14.682]                       while (!identical(envir, .GlobalEnv) && 
[17:38:14.682]                         !identical(envir, emptyenv())) {
[17:38:14.682]                         if (exists("master", mode = "list", envir = envir, 
[17:38:14.682]                           inherits = FALSE)) {
[17:38:14.682]                           master <- get("master", mode = "list", 
[17:38:14.682]                             envir = envir, inherits = FALSE)
[17:38:14.682]                           if (inherits(master, c("SOCKnode", 
[17:38:14.682]                             "SOCK0node"))) {
[17:38:14.682]                             sendCondition <<- function(cond) {
[17:38:14.682]                               data <- list(type = "VALUE", value = cond, 
[17:38:14.682]                                 success = TRUE)
[17:38:14.682]                               parallel_sendData(master, data)
[17:38:14.682]                             }
[17:38:14.682]                             return(sendCondition)
[17:38:14.682]                           }
[17:38:14.682]                         }
[17:38:14.682]                         frame <- frame + 1L
[17:38:14.682]                         envir <- sys.frame(frame)
[17:38:14.682]                       }
[17:38:14.682]                     }
[17:38:14.682]                     sendCondition <<- function(cond) NULL
[17:38:14.682]                   }
[17:38:14.682]                 })
[17:38:14.682]                 withCallingHandlers({
[17:38:14.682]                   {
[17:38:14.682]                     do.call(function(...) {
[17:38:14.682]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.682]                       if (!identical(...future.globals.maxSize.org, 
[17:38:14.682]                         ...future.globals.maxSize)) {
[17:38:14.682]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.682]                         on.exit(options(oopts), add = TRUE)
[17:38:14.682]                       }
[17:38:14.682]                       {
[17:38:14.682]                         lapply(seq_along(...future.elements_ii), 
[17:38:14.682]                           FUN = function(jj) {
[17:38:14.682]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.682]                             ...future.FUN(...future.X_jj, ...)
[17:38:14.682]                           })
[17:38:14.682]                       }
[17:38:14.682]                     }, args = future.call.arguments)
[17:38:14.682]                   }
[17:38:14.682]                 }, immediateCondition = function(cond) {
[17:38:14.682]                   sendCondition <- ...future.makeSendCondition()
[17:38:14.682]                   sendCondition(cond)
[17:38:14.682]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.682]                   {
[17:38:14.682]                     inherits <- base::inherits
[17:38:14.682]                     invokeRestart <- base::invokeRestart
[17:38:14.682]                     is.null <- base::is.null
[17:38:14.682]                     muffled <- FALSE
[17:38:14.682]                     if (inherits(cond, "message")) {
[17:38:14.682]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:14.682]                       if (muffled) 
[17:38:14.682]                         invokeRestart("muffleMessage")
[17:38:14.682]                     }
[17:38:14.682]                     else if (inherits(cond, "warning")) {
[17:38:14.682]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:14.682]                       if (muffled) 
[17:38:14.682]                         invokeRestart("muffleWarning")
[17:38:14.682]                     }
[17:38:14.682]                     else if (inherits(cond, "condition")) {
[17:38:14.682]                       if (!is.null(pattern)) {
[17:38:14.682]                         computeRestarts <- base::computeRestarts
[17:38:14.682]                         grepl <- base::grepl
[17:38:14.682]                         restarts <- computeRestarts(cond)
[17:38:14.682]                         for (restart in restarts) {
[17:38:14.682]                           name <- restart$name
[17:38:14.682]                           if (is.null(name)) 
[17:38:14.682]                             next
[17:38:14.682]                           if (!grepl(pattern, name)) 
[17:38:14.682]                             next
[17:38:14.682]                           invokeRestart(restart)
[17:38:14.682]                           muffled <- TRUE
[17:38:14.682]                           break
[17:38:14.682]                         }
[17:38:14.682]                       }
[17:38:14.682]                     }
[17:38:14.682]                     invisible(muffled)
[17:38:14.682]                   }
[17:38:14.682]                   muffleCondition(cond)
[17:38:14.682]                 })
[17:38:14.682]             }))
[17:38:14.682]             future::FutureResult(value = ...future.value$value, 
[17:38:14.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:14.682]                   ...future.rng), globalenv = if (FALSE) 
[17:38:14.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:14.682]                     ...future.globalenv.names))
[17:38:14.682]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:14.682]         }, condition = base::local({
[17:38:14.682]             c <- base::c
[17:38:14.682]             inherits <- base::inherits
[17:38:14.682]             invokeRestart <- base::invokeRestart
[17:38:14.682]             length <- base::length
[17:38:14.682]             list <- base::list
[17:38:14.682]             seq.int <- base::seq.int
[17:38:14.682]             signalCondition <- base::signalCondition
[17:38:14.682]             sys.calls <- base::sys.calls
[17:38:14.682]             `[[` <- base::`[[`
[17:38:14.682]             `+` <- base::`+`
[17:38:14.682]             `<<-` <- base::`<<-`
[17:38:14.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:14.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:14.682]                   3L)]
[17:38:14.682]             }
[17:38:14.682]             function(cond) {
[17:38:14.682]                 is_error <- inherits(cond, "error")
[17:38:14.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:14.682]                   NULL)
[17:38:14.682]                 if (is_error) {
[17:38:14.682]                   sessionInformation <- function() {
[17:38:14.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:14.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:14.682]                       search = base::search(), system = base::Sys.info())
[17:38:14.682]                   }
[17:38:14.682]                   ...future.conditions[[length(...future.conditions) + 
[17:38:14.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:14.682]                     cond$call), session = sessionInformation(), 
[17:38:14.682]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:14.682]                   signalCondition(cond)
[17:38:14.682]                 }
[17:38:14.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:14.682]                 "immediateCondition"))) {
[17:38:14.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:14.682]                   ...future.conditions[[length(...future.conditions) + 
[17:38:14.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:14.682]                   if (TRUE && !signal) {
[17:38:14.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.682]                     {
[17:38:14.682]                       inherits <- base::inherits
[17:38:14.682]                       invokeRestart <- base::invokeRestart
[17:38:14.682]                       is.null <- base::is.null
[17:38:14.682]                       muffled <- FALSE
[17:38:14.682]                       if (inherits(cond, "message")) {
[17:38:14.682]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:14.682]                         if (muffled) 
[17:38:14.682]                           invokeRestart("muffleMessage")
[17:38:14.682]                       }
[17:38:14.682]                       else if (inherits(cond, "warning")) {
[17:38:14.682]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:14.682]                         if (muffled) 
[17:38:14.682]                           invokeRestart("muffleWarning")
[17:38:14.682]                       }
[17:38:14.682]                       else if (inherits(cond, "condition")) {
[17:38:14.682]                         if (!is.null(pattern)) {
[17:38:14.682]                           computeRestarts <- base::computeRestarts
[17:38:14.682]                           grepl <- base::grepl
[17:38:14.682]                           restarts <- computeRestarts(cond)
[17:38:14.682]                           for (restart in restarts) {
[17:38:14.682]                             name <- restart$name
[17:38:14.682]                             if (is.null(name)) 
[17:38:14.682]                               next
[17:38:14.682]                             if (!grepl(pattern, name)) 
[17:38:14.682]                               next
[17:38:14.682]                             invokeRestart(restart)
[17:38:14.682]                             muffled <- TRUE
[17:38:14.682]                             break
[17:38:14.682]                           }
[17:38:14.682]                         }
[17:38:14.682]                       }
[17:38:14.682]                       invisible(muffled)
[17:38:14.682]                     }
[17:38:14.682]                     muffleCondition(cond, pattern = "^muffle")
[17:38:14.682]                   }
[17:38:14.682]                 }
[17:38:14.682]                 else {
[17:38:14.682]                   if (TRUE) {
[17:38:14.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.682]                     {
[17:38:14.682]                       inherits <- base::inherits
[17:38:14.682]                       invokeRestart <- base::invokeRestart
[17:38:14.682]                       is.null <- base::is.null
[17:38:14.682]                       muffled <- FALSE
[17:38:14.682]                       if (inherits(cond, "message")) {
[17:38:14.682]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:14.682]                         if (muffled) 
[17:38:14.682]                           invokeRestart("muffleMessage")
[17:38:14.682]                       }
[17:38:14.682]                       else if (inherits(cond, "warning")) {
[17:38:14.682]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:14.682]                         if (muffled) 
[17:38:14.682]                           invokeRestart("muffleWarning")
[17:38:14.682]                       }
[17:38:14.682]                       else if (inherits(cond, "condition")) {
[17:38:14.682]                         if (!is.null(pattern)) {
[17:38:14.682]                           computeRestarts <- base::computeRestarts
[17:38:14.682]                           grepl <- base::grepl
[17:38:14.682]                           restarts <- computeRestarts(cond)
[17:38:14.682]                           for (restart in restarts) {
[17:38:14.682]                             name <- restart$name
[17:38:14.682]                             if (is.null(name)) 
[17:38:14.682]                               next
[17:38:14.682]                             if (!grepl(pattern, name)) 
[17:38:14.682]                               next
[17:38:14.682]                             invokeRestart(restart)
[17:38:14.682]                             muffled <- TRUE
[17:38:14.682]                             break
[17:38:14.682]                           }
[17:38:14.682]                         }
[17:38:14.682]                       }
[17:38:14.682]                       invisible(muffled)
[17:38:14.682]                     }
[17:38:14.682]                     muffleCondition(cond, pattern = "^muffle")
[17:38:14.682]                   }
[17:38:14.682]                 }
[17:38:14.682]             }
[17:38:14.682]         }))
[17:38:14.682]     }, error = function(ex) {
[17:38:14.682]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:14.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:14.682]                 ...future.rng), started = ...future.startTime, 
[17:38:14.682]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:14.682]             version = "1.8"), class = "FutureResult")
[17:38:14.682]     }, finally = {
[17:38:14.682]         if (!identical(...future.workdir, getwd())) 
[17:38:14.682]             setwd(...future.workdir)
[17:38:14.682]         {
[17:38:14.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:14.682]                 ...future.oldOptions$nwarnings <- NULL
[17:38:14.682]             }
[17:38:14.682]             base::options(...future.oldOptions)
[17:38:14.682]             if (.Platform$OS.type == "windows") {
[17:38:14.682]                 old_names <- names(...future.oldEnvVars)
[17:38:14.682]                 envs <- base::Sys.getenv()
[17:38:14.682]                 names <- names(envs)
[17:38:14.682]                 common <- intersect(names, old_names)
[17:38:14.682]                 added <- setdiff(names, old_names)
[17:38:14.682]                 removed <- setdiff(old_names, names)
[17:38:14.682]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:14.682]                   envs[common]]
[17:38:14.682]                 NAMES <- toupper(changed)
[17:38:14.682]                 args <- list()
[17:38:14.682]                 for (kk in seq_along(NAMES)) {
[17:38:14.682]                   name <- changed[[kk]]
[17:38:14.682]                   NAME <- NAMES[[kk]]
[17:38:14.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.682]                     next
[17:38:14.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:14.682]                 }
[17:38:14.682]                 NAMES <- toupper(added)
[17:38:14.682]                 for (kk in seq_along(NAMES)) {
[17:38:14.682]                   name <- added[[kk]]
[17:38:14.682]                   NAME <- NAMES[[kk]]
[17:38:14.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.682]                     next
[17:38:14.682]                   args[[name]] <- ""
[17:38:14.682]                 }
[17:38:14.682]                 NAMES <- toupper(removed)
[17:38:14.682]                 for (kk in seq_along(NAMES)) {
[17:38:14.682]                   name <- removed[[kk]]
[17:38:14.682]                   NAME <- NAMES[[kk]]
[17:38:14.682]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.682]                     next
[17:38:14.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:14.682]                 }
[17:38:14.682]                 if (length(args) > 0) 
[17:38:14.682]                   base::do.call(base::Sys.setenv, args = args)
[17:38:14.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:14.682]             }
[17:38:14.682]             else {
[17:38:14.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:14.682]             }
[17:38:14.682]             {
[17:38:14.682]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:14.682]                   0L) {
[17:38:14.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:14.682]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:14.682]                   base::options(opts)
[17:38:14.682]                 }
[17:38:14.682]                 {
[17:38:14.682]                   {
[17:38:14.682]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:14.682]                     NULL
[17:38:14.682]                   }
[17:38:14.682]                   options(future.plan = NULL)
[17:38:14.682]                   if (is.na(NA_character_)) 
[17:38:14.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:14.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:14.682]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:14.682]                     .init = FALSE)
[17:38:14.682]                 }
[17:38:14.682]             }
[17:38:14.682]         }
[17:38:14.682]     })
[17:38:14.682]     if (TRUE) {
[17:38:14.682]         base::sink(type = "output", split = FALSE)
[17:38:14.682]         if (TRUE) {
[17:38:14.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:14.682]         }
[17:38:14.682]         else {
[17:38:14.682]             ...future.result["stdout"] <- base::list(NULL)
[17:38:14.682]         }
[17:38:14.682]         base::close(...future.stdout)
[17:38:14.682]         ...future.stdout <- NULL
[17:38:14.682]     }
[17:38:14.682]     ...future.result$conditions <- ...future.conditions
[17:38:14.682]     ...future.result$finished <- base::Sys.time()
[17:38:14.682]     ...future.result
[17:38:14.682] }
[17:38:14.684] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[17:38:14.685] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:38:14.729] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:38:14.729] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[17:38:14.729] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[17:38:14.729] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:38:14.730] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:38:14.730] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:38:14.773] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:38:14.773] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:38:14.817] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:38:14.817] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:38:14.817] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:38:14.817] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:38:14.818] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:38:14.818] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[17:38:14.818] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[17:38:14.818] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:38:14.819] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:38:14.819] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:14.819] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:14.819] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:14.819] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:14.820] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[17:38:14.820] MultisessionFuture started
[17:38:14.820] - Launch lazy future ... done
[17:38:14.820] run() for ‘MultisessionFuture’ ... done
[17:38:14.821] Created future:
[17:38:14.821] MultisessionFuture:
[17:38:14.821] Label: ‘future_vapply-1’
[17:38:14.821] Expression:
[17:38:14.821] {
[17:38:14.821]     do.call(function(...) {
[17:38:14.821]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.821]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:14.821]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.821]             on.exit(options(oopts), add = TRUE)
[17:38:14.821]         }
[17:38:14.821]         {
[17:38:14.821]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:14.821]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.821]                 ...future.FUN(...future.X_jj, ...)
[17:38:14.821]             })
[17:38:14.821]         }
[17:38:14.821]     }, args = future.call.arguments)
[17:38:14.821] }
[17:38:14.821] Lazy evaluation: FALSE
[17:38:14.821] Asynchronous evaluation: TRUE
[17:38:14.821] Local evaluation: TRUE
[17:38:14.821] Environment: R_GlobalEnv
[17:38:14.821] Capture standard output: TRUE
[17:38:14.821] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:14.821] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:14.821] Packages: 1 packages (‘future.apply’)
[17:38:14.821] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:14.821] Resolved: FALSE
[17:38:14.821] Value: <not collected>
[17:38:14.821] Conditions captured: <none>
[17:38:14.821] Early signaling: FALSE
[17:38:14.821] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:14.821] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:14.832] Chunk #1 of 2 ... DONE
[17:38:14.833] Chunk #2 of 2 ...
[17:38:14.833]  - Finding globals in 'X' for chunk #2 ...
[17:38:14.833] getGlobalsAndPackages() ...
[17:38:14.833] Searching for globals...
[17:38:14.833] 
[17:38:14.833] Searching for globals ... DONE
[17:38:14.834] - globals: [0] <none>
[17:38:14.834] getGlobalsAndPackages() ... DONE
[17:38:14.834]    + additional globals found: [n=0] 
[17:38:14.834]    + additional namespaces needed: [n=0] 
[17:38:14.834]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:14.834]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:14.834]  - seeds: <none>
[17:38:14.834]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.834] getGlobalsAndPackages() ...
[17:38:14.834] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.835] Resolving globals: FALSE
[17:38:14.835] Tweak future expression to call with '...' arguments ...
[17:38:14.835] {
[17:38:14.835]     do.call(function(...) {
[17:38:14.835]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.835]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:14.835]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.835]             on.exit(options(oopts), add = TRUE)
[17:38:14.835]         }
[17:38:14.835]         {
[17:38:14.835]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:14.835]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.835]                 ...future.FUN(...future.X_jj, ...)
[17:38:14.835]             })
[17:38:14.835]         }
[17:38:14.835]     }, args = future.call.arguments)
[17:38:14.835] }
[17:38:14.835] Tweak future expression to call with '...' arguments ... DONE
[17:38:14.836] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:14.836] - packages: [1] ‘future.apply’
[17:38:14.836] getGlobalsAndPackages() ... DONE
[17:38:14.836] run() for ‘Future’ ...
[17:38:14.836] - state: ‘created’
[17:38:14.836] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:14.851] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:14.851] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:14.851]   - Field: ‘node’
[17:38:14.851]   - Field: ‘label’
[17:38:14.851]   - Field: ‘local’
[17:38:14.851]   - Field: ‘owner’
[17:38:14.851]   - Field: ‘envir’
[17:38:14.851]   - Field: ‘workers’
[17:38:14.852]   - Field: ‘packages’
[17:38:14.852]   - Field: ‘gc’
[17:38:14.852]   - Field: ‘conditions’
[17:38:14.852]   - Field: ‘persistent’
[17:38:14.852]   - Field: ‘expr’
[17:38:14.852]   - Field: ‘uuid’
[17:38:14.852]   - Field: ‘seed’
[17:38:14.852]   - Field: ‘version’
[17:38:14.852]   - Field: ‘result’
[17:38:14.852]   - Field: ‘asynchronous’
[17:38:14.853]   - Field: ‘calls’
[17:38:14.853]   - Field: ‘globals’
[17:38:14.853]   - Field: ‘stdout’
[17:38:14.853]   - Field: ‘earlySignal’
[17:38:14.853]   - Field: ‘lazy’
[17:38:14.853]   - Field: ‘state’
[17:38:14.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:14.853] - Launch lazy future ...
[17:38:14.853] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:14.854] Packages needed by future strategies (n = 0): <none>
[17:38:14.854] {
[17:38:14.854]     {
[17:38:14.854]         {
[17:38:14.854]             ...future.startTime <- base::Sys.time()
[17:38:14.854]             {
[17:38:14.854]                 {
[17:38:14.854]                   {
[17:38:14.854]                     {
[17:38:14.854]                       {
[17:38:14.854]                         base::local({
[17:38:14.854]                           has_future <- base::requireNamespace("future", 
[17:38:14.854]                             quietly = TRUE)
[17:38:14.854]                           if (has_future) {
[17:38:14.854]                             ns <- base::getNamespace("future")
[17:38:14.854]                             version <- ns[[".package"]][["version"]]
[17:38:14.854]                             if (is.null(version)) 
[17:38:14.854]                               version <- utils::packageVersion("future")
[17:38:14.854]                           }
[17:38:14.854]                           else {
[17:38:14.854]                             version <- NULL
[17:38:14.854]                           }
[17:38:14.854]                           if (!has_future || version < "1.8.0") {
[17:38:14.854]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:14.854]                               "", base::R.version$version.string), 
[17:38:14.854]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:14.854]                                 base::R.version$platform, 8 * 
[17:38:14.854]                                   base::.Machine$sizeof.pointer), 
[17:38:14.854]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:14.854]                                 "release", "version")], collapse = " "), 
[17:38:14.854]                               hostname = base::Sys.info()[["nodename"]])
[17:38:14.854]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:14.854]                               info)
[17:38:14.854]                             info <- base::paste(info, collapse = "; ")
[17:38:14.854]                             if (!has_future) {
[17:38:14.854]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:14.854]                                 info)
[17:38:14.854]                             }
[17:38:14.854]                             else {
[17:38:14.854]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:14.854]                                 info, version)
[17:38:14.854]                             }
[17:38:14.854]                             base::stop(msg)
[17:38:14.854]                           }
[17:38:14.854]                         })
[17:38:14.854]                       }
[17:38:14.854]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:14.854]                       base::options(mc.cores = 1L)
[17:38:14.854]                     }
[17:38:14.854]                     base::local({
[17:38:14.854]                       for (pkg in "future.apply") {
[17:38:14.854]                         base::loadNamespace(pkg)
[17:38:14.854]                         base::library(pkg, character.only = TRUE)
[17:38:14.854]                       }
[17:38:14.854]                     })
[17:38:14.854]                   }
[17:38:14.854]                   ...future.strategy.old <- future::plan("list")
[17:38:14.854]                   options(future.plan = NULL)
[17:38:14.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:14.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:14.854]                 }
[17:38:14.854]                 ...future.workdir <- getwd()
[17:38:14.854]             }
[17:38:14.854]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:14.854]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:14.854]         }
[17:38:14.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:14.854]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:14.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:14.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:14.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:14.854]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:14.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:14.854]             base::names(...future.oldOptions))
[17:38:14.854]     }
[17:38:14.854]     if (FALSE) {
[17:38:14.854]     }
[17:38:14.854]     else {
[17:38:14.854]         if (TRUE) {
[17:38:14.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:14.854]                 open = "w")
[17:38:14.854]         }
[17:38:14.854]         else {
[17:38:14.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:14.854]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:14.854]         }
[17:38:14.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:14.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:14.854]             base::sink(type = "output", split = FALSE)
[17:38:14.854]             base::close(...future.stdout)
[17:38:14.854]         }, add = TRUE)
[17:38:14.854]     }
[17:38:14.854]     ...future.frame <- base::sys.nframe()
[17:38:14.854]     ...future.conditions <- base::list()
[17:38:14.854]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:14.854]     if (FALSE) {
[17:38:14.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:14.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:14.854]     }
[17:38:14.854]     ...future.result <- base::tryCatch({
[17:38:14.854]         base::withCallingHandlers({
[17:38:14.854]             ...future.value <- base::withVisible(base::local({
[17:38:14.854]                 ...future.makeSendCondition <- base::local({
[17:38:14.854]                   sendCondition <- NULL
[17:38:14.854]                   function(frame = 1L) {
[17:38:14.854]                     if (is.function(sendCondition)) 
[17:38:14.854]                       return(sendCondition)
[17:38:14.854]                     ns <- getNamespace("parallel")
[17:38:14.854]                     if (exists("sendData", mode = "function", 
[17:38:14.854]                       envir = ns)) {
[17:38:14.854]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:14.854]                         envir = ns)
[17:38:14.854]                       envir <- sys.frame(frame)
[17:38:14.854]                       master <- NULL
[17:38:14.854]                       while (!identical(envir, .GlobalEnv) && 
[17:38:14.854]                         !identical(envir, emptyenv())) {
[17:38:14.854]                         if (exists("master", mode = "list", envir = envir, 
[17:38:14.854]                           inherits = FALSE)) {
[17:38:14.854]                           master <- get("master", mode = "list", 
[17:38:14.854]                             envir = envir, inherits = FALSE)
[17:38:14.854]                           if (inherits(master, c("SOCKnode", 
[17:38:14.854]                             "SOCK0node"))) {
[17:38:14.854]                             sendCondition <<- function(cond) {
[17:38:14.854]                               data <- list(type = "VALUE", value = cond, 
[17:38:14.854]                                 success = TRUE)
[17:38:14.854]                               parallel_sendData(master, data)
[17:38:14.854]                             }
[17:38:14.854]                             return(sendCondition)
[17:38:14.854]                           }
[17:38:14.854]                         }
[17:38:14.854]                         frame <- frame + 1L
[17:38:14.854]                         envir <- sys.frame(frame)
[17:38:14.854]                       }
[17:38:14.854]                     }
[17:38:14.854]                     sendCondition <<- function(cond) NULL
[17:38:14.854]                   }
[17:38:14.854]                 })
[17:38:14.854]                 withCallingHandlers({
[17:38:14.854]                   {
[17:38:14.854]                     do.call(function(...) {
[17:38:14.854]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.854]                       if (!identical(...future.globals.maxSize.org, 
[17:38:14.854]                         ...future.globals.maxSize)) {
[17:38:14.854]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.854]                         on.exit(options(oopts), add = TRUE)
[17:38:14.854]                       }
[17:38:14.854]                       {
[17:38:14.854]                         lapply(seq_along(...future.elements_ii), 
[17:38:14.854]                           FUN = function(jj) {
[17:38:14.854]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.854]                             ...future.FUN(...future.X_jj, ...)
[17:38:14.854]                           })
[17:38:14.854]                       }
[17:38:14.854]                     }, args = future.call.arguments)
[17:38:14.854]                   }
[17:38:14.854]                 }, immediateCondition = function(cond) {
[17:38:14.854]                   sendCondition <- ...future.makeSendCondition()
[17:38:14.854]                   sendCondition(cond)
[17:38:14.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.854]                   {
[17:38:14.854]                     inherits <- base::inherits
[17:38:14.854]                     invokeRestart <- base::invokeRestart
[17:38:14.854]                     is.null <- base::is.null
[17:38:14.854]                     muffled <- FALSE
[17:38:14.854]                     if (inherits(cond, "message")) {
[17:38:14.854]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:14.854]                       if (muffled) 
[17:38:14.854]                         invokeRestart("muffleMessage")
[17:38:14.854]                     }
[17:38:14.854]                     else if (inherits(cond, "warning")) {
[17:38:14.854]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:14.854]                       if (muffled) 
[17:38:14.854]                         invokeRestart("muffleWarning")
[17:38:14.854]                     }
[17:38:14.854]                     else if (inherits(cond, "condition")) {
[17:38:14.854]                       if (!is.null(pattern)) {
[17:38:14.854]                         computeRestarts <- base::computeRestarts
[17:38:14.854]                         grepl <- base::grepl
[17:38:14.854]                         restarts <- computeRestarts(cond)
[17:38:14.854]                         for (restart in restarts) {
[17:38:14.854]                           name <- restart$name
[17:38:14.854]                           if (is.null(name)) 
[17:38:14.854]                             next
[17:38:14.854]                           if (!grepl(pattern, name)) 
[17:38:14.854]                             next
[17:38:14.854]                           invokeRestart(restart)
[17:38:14.854]                           muffled <- TRUE
[17:38:14.854]                           break
[17:38:14.854]                         }
[17:38:14.854]                       }
[17:38:14.854]                     }
[17:38:14.854]                     invisible(muffled)
[17:38:14.854]                   }
[17:38:14.854]                   muffleCondition(cond)
[17:38:14.854]                 })
[17:38:14.854]             }))
[17:38:14.854]             future::FutureResult(value = ...future.value$value, 
[17:38:14.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:14.854]                   ...future.rng), globalenv = if (FALSE) 
[17:38:14.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:14.854]                     ...future.globalenv.names))
[17:38:14.854]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:14.854]         }, condition = base::local({
[17:38:14.854]             c <- base::c
[17:38:14.854]             inherits <- base::inherits
[17:38:14.854]             invokeRestart <- base::invokeRestart
[17:38:14.854]             length <- base::length
[17:38:14.854]             list <- base::list
[17:38:14.854]             seq.int <- base::seq.int
[17:38:14.854]             signalCondition <- base::signalCondition
[17:38:14.854]             sys.calls <- base::sys.calls
[17:38:14.854]             `[[` <- base::`[[`
[17:38:14.854]             `+` <- base::`+`
[17:38:14.854]             `<<-` <- base::`<<-`
[17:38:14.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:14.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:14.854]                   3L)]
[17:38:14.854]             }
[17:38:14.854]             function(cond) {
[17:38:14.854]                 is_error <- inherits(cond, "error")
[17:38:14.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:14.854]                   NULL)
[17:38:14.854]                 if (is_error) {
[17:38:14.854]                   sessionInformation <- function() {
[17:38:14.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:14.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:14.854]                       search = base::search(), system = base::Sys.info())
[17:38:14.854]                   }
[17:38:14.854]                   ...future.conditions[[length(...future.conditions) + 
[17:38:14.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:14.854]                     cond$call), session = sessionInformation(), 
[17:38:14.854]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:14.854]                   signalCondition(cond)
[17:38:14.854]                 }
[17:38:14.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:14.854]                 "immediateCondition"))) {
[17:38:14.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:14.854]                   ...future.conditions[[length(...future.conditions) + 
[17:38:14.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:14.854]                   if (TRUE && !signal) {
[17:38:14.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.854]                     {
[17:38:14.854]                       inherits <- base::inherits
[17:38:14.854]                       invokeRestart <- base::invokeRestart
[17:38:14.854]                       is.null <- base::is.null
[17:38:14.854]                       muffled <- FALSE
[17:38:14.854]                       if (inherits(cond, "message")) {
[17:38:14.854]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:14.854]                         if (muffled) 
[17:38:14.854]                           invokeRestart("muffleMessage")
[17:38:14.854]                       }
[17:38:14.854]                       else if (inherits(cond, "warning")) {
[17:38:14.854]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:14.854]                         if (muffled) 
[17:38:14.854]                           invokeRestart("muffleWarning")
[17:38:14.854]                       }
[17:38:14.854]                       else if (inherits(cond, "condition")) {
[17:38:14.854]                         if (!is.null(pattern)) {
[17:38:14.854]                           computeRestarts <- base::computeRestarts
[17:38:14.854]                           grepl <- base::grepl
[17:38:14.854]                           restarts <- computeRestarts(cond)
[17:38:14.854]                           for (restart in restarts) {
[17:38:14.854]                             name <- restart$name
[17:38:14.854]                             if (is.null(name)) 
[17:38:14.854]                               next
[17:38:14.854]                             if (!grepl(pattern, name)) 
[17:38:14.854]                               next
[17:38:14.854]                             invokeRestart(restart)
[17:38:14.854]                             muffled <- TRUE
[17:38:14.854]                             break
[17:38:14.854]                           }
[17:38:14.854]                         }
[17:38:14.854]                       }
[17:38:14.854]                       invisible(muffled)
[17:38:14.854]                     }
[17:38:14.854]                     muffleCondition(cond, pattern = "^muffle")
[17:38:14.854]                   }
[17:38:14.854]                 }
[17:38:14.854]                 else {
[17:38:14.854]                   if (TRUE) {
[17:38:14.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:14.854]                     {
[17:38:14.854]                       inherits <- base::inherits
[17:38:14.854]                       invokeRestart <- base::invokeRestart
[17:38:14.854]                       is.null <- base::is.null
[17:38:14.854]                       muffled <- FALSE
[17:38:14.854]                       if (inherits(cond, "message")) {
[17:38:14.854]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:14.854]                         if (muffled) 
[17:38:14.854]                           invokeRestart("muffleMessage")
[17:38:14.854]                       }
[17:38:14.854]                       else if (inherits(cond, "warning")) {
[17:38:14.854]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:14.854]                         if (muffled) 
[17:38:14.854]                           invokeRestart("muffleWarning")
[17:38:14.854]                       }
[17:38:14.854]                       else if (inherits(cond, "condition")) {
[17:38:14.854]                         if (!is.null(pattern)) {
[17:38:14.854]                           computeRestarts <- base::computeRestarts
[17:38:14.854]                           grepl <- base::grepl
[17:38:14.854]                           restarts <- computeRestarts(cond)
[17:38:14.854]                           for (restart in restarts) {
[17:38:14.854]                             name <- restart$name
[17:38:14.854]                             if (is.null(name)) 
[17:38:14.854]                               next
[17:38:14.854]                             if (!grepl(pattern, name)) 
[17:38:14.854]                               next
[17:38:14.854]                             invokeRestart(restart)
[17:38:14.854]                             muffled <- TRUE
[17:38:14.854]                             break
[17:38:14.854]                           }
[17:38:14.854]                         }
[17:38:14.854]                       }
[17:38:14.854]                       invisible(muffled)
[17:38:14.854]                     }
[17:38:14.854]                     muffleCondition(cond, pattern = "^muffle")
[17:38:14.854]                   }
[17:38:14.854]                 }
[17:38:14.854]             }
[17:38:14.854]         }))
[17:38:14.854]     }, error = function(ex) {
[17:38:14.854]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:14.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:14.854]                 ...future.rng), started = ...future.startTime, 
[17:38:14.854]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:14.854]             version = "1.8"), class = "FutureResult")
[17:38:14.854]     }, finally = {
[17:38:14.854]         if (!identical(...future.workdir, getwd())) 
[17:38:14.854]             setwd(...future.workdir)
[17:38:14.854]         {
[17:38:14.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:14.854]                 ...future.oldOptions$nwarnings <- NULL
[17:38:14.854]             }
[17:38:14.854]             base::options(...future.oldOptions)
[17:38:14.854]             if (.Platform$OS.type == "windows") {
[17:38:14.854]                 old_names <- names(...future.oldEnvVars)
[17:38:14.854]                 envs <- base::Sys.getenv()
[17:38:14.854]                 names <- names(envs)
[17:38:14.854]                 common <- intersect(names, old_names)
[17:38:14.854]                 added <- setdiff(names, old_names)
[17:38:14.854]                 removed <- setdiff(old_names, names)
[17:38:14.854]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:14.854]                   envs[common]]
[17:38:14.854]                 NAMES <- toupper(changed)
[17:38:14.854]                 args <- list()
[17:38:14.854]                 for (kk in seq_along(NAMES)) {
[17:38:14.854]                   name <- changed[[kk]]
[17:38:14.854]                   NAME <- NAMES[[kk]]
[17:38:14.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.854]                     next
[17:38:14.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:14.854]                 }
[17:38:14.854]                 NAMES <- toupper(added)
[17:38:14.854]                 for (kk in seq_along(NAMES)) {
[17:38:14.854]                   name <- added[[kk]]
[17:38:14.854]                   NAME <- NAMES[[kk]]
[17:38:14.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.854]                     next
[17:38:14.854]                   args[[name]] <- ""
[17:38:14.854]                 }
[17:38:14.854]                 NAMES <- toupper(removed)
[17:38:14.854]                 for (kk in seq_along(NAMES)) {
[17:38:14.854]                   name <- removed[[kk]]
[17:38:14.854]                   NAME <- NAMES[[kk]]
[17:38:14.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:14.854]                     next
[17:38:14.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:14.854]                 }
[17:38:14.854]                 if (length(args) > 0) 
[17:38:14.854]                   base::do.call(base::Sys.setenv, args = args)
[17:38:14.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:14.854]             }
[17:38:14.854]             else {
[17:38:14.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:14.854]             }
[17:38:14.854]             {
[17:38:14.854]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:14.854]                   0L) {
[17:38:14.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:14.854]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:14.854]                   base::options(opts)
[17:38:14.854]                 }
[17:38:14.854]                 {
[17:38:14.854]                   {
[17:38:14.854]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:14.854]                     NULL
[17:38:14.854]                   }
[17:38:14.854]                   options(future.plan = NULL)
[17:38:14.854]                   if (is.na(NA_character_)) 
[17:38:14.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:14.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:14.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:14.854]                     .init = FALSE)
[17:38:14.854]                 }
[17:38:14.854]             }
[17:38:14.854]         }
[17:38:14.854]     })
[17:38:14.854]     if (TRUE) {
[17:38:14.854]         base::sink(type = "output", split = FALSE)
[17:38:14.854]         if (TRUE) {
[17:38:14.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:14.854]         }
[17:38:14.854]         else {
[17:38:14.854]             ...future.result["stdout"] <- base::list(NULL)
[17:38:14.854]         }
[17:38:14.854]         base::close(...future.stdout)
[17:38:14.854]         ...future.stdout <- NULL
[17:38:14.854]     }
[17:38:14.854]     ...future.result$conditions <- ...future.conditions
[17:38:14.854]     ...future.result$finished <- base::Sys.time()
[17:38:14.854]     ...future.result
[17:38:14.854] }
[17:38:14.857] Exporting 11 global objects (96.29 KiB) to cluster node #2 ...
[17:38:14.857] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:38:14.901] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:38:14.901] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ...
[17:38:14.901] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ... DONE
[17:38:14.901] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:38:14.902] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:38:14.902] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:38:14.945] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:38:14.945] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:38:14.989] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:38:14.989] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[17:38:14.989] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[17:38:14.989] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:38:14.990] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:38:14.990] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[17:38:14.990] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[17:38:14.991] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:38:14.991] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:38:14.991] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:14.991] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:14.992] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:14.992] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:14.992] Exporting 11 global objects (96.29 KiB) to cluster node #2 ... DONE
[17:38:14.993] MultisessionFuture started
[17:38:14.993] - Launch lazy future ... done
[17:38:14.993] run() for ‘MultisessionFuture’ ... done
[17:38:14.993] Created future:
[17:38:14.994] receiveMessageFromWorker() for ClusterFuture ...
[17:38:14.995] - Validating connection of MultisessionFuture
[17:38:14.995] - received message: FutureResult
[17:38:14.995] - Received FutureResult
[17:38:14.995] - Erased future from FutureRegistry
[17:38:14.995] result() for ClusterFuture ...
[17:38:14.995] - result already collected: FutureResult
[17:38:14.995] result() for ClusterFuture ... done
[17:38:14.995] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:14.993] MultisessionFuture:
[17:38:14.993] Label: ‘future_vapply-2’
[17:38:14.993] Expression:
[17:38:14.993] {
[17:38:14.993]     do.call(function(...) {
[17:38:14.993]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:14.993]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:14.993]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:14.993]             on.exit(options(oopts), add = TRUE)
[17:38:14.993]         }
[17:38:14.993]         {
[17:38:14.993]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:14.993]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:14.993]                 ...future.FUN(...future.X_jj, ...)
[17:38:14.993]             })
[17:38:14.993]         }
[17:38:14.993]     }, args = future.call.arguments)
[17:38:14.993] }
[17:38:14.993] Lazy evaluation: FALSE
[17:38:14.993] Asynchronous evaluation: TRUE
[17:38:14.993] Local evaluation: TRUE
[17:38:14.993] Environment: R_GlobalEnv
[17:38:14.993] Capture standard output: TRUE
[17:38:14.993] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:14.993] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:14.993] Packages: 1 packages (‘future.apply’)
[17:38:14.993] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:14.993] Resolved: TRUE
[17:38:14.993] Value: <not collected>
[17:38:14.993] Conditions captured: <none>
[17:38:14.993] Early signaling: FALSE
[17:38:14.993] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:14.993] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:14.996] Chunk #2 of 2 ... DONE
[17:38:14.996] Launching 2 futures (chunks) ... DONE
[17:38:14.996] Resolving 2 futures (chunks) ...
[17:38:14.996] resolve() on list ...
[17:38:14.996]  recursive: 0
[17:38:14.996]  length: 2
[17:38:14.996] 
[17:38:14.997] receiveMessageFromWorker() for ClusterFuture ...
[17:38:14.997] - Validating connection of MultisessionFuture
[17:38:14.997] - received message: FutureResult
[17:38:14.997] - Received FutureResult
[17:38:14.997] - Erased future from FutureRegistry
[17:38:14.997] result() for ClusterFuture ...
[17:38:14.997] - result already collected: FutureResult
[17:38:14.997] result() for ClusterFuture ... done
[17:38:14.998] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:14.998] Future #1
[17:38:14.998] result() for ClusterFuture ...
[17:38:14.998] - result already collected: FutureResult
[17:38:14.998] result() for ClusterFuture ... done
[17:38:14.998] result() for ClusterFuture ...
[17:38:14.998] - result already collected: FutureResult
[17:38:14.998] result() for ClusterFuture ... done
[17:38:14.998] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:14.998] - nx: 2
[17:38:14.998] - relay: TRUE
[17:38:14.999] - stdout: TRUE
[17:38:14.999] - signal: TRUE
[17:38:14.999] - resignal: FALSE
[17:38:14.999] - force: TRUE
[17:38:14.999] - relayed: [n=2] FALSE, FALSE
[17:38:14.999] - queued futures: [n=2] FALSE, FALSE
[17:38:14.999]  - until=1
[17:38:14.999]  - relaying element #1
[17:38:14.999] result() for ClusterFuture ...
[17:38:14.999] - result already collected: FutureResult
[17:38:14.999] result() for ClusterFuture ... done
[17:38:15.000] result() for ClusterFuture ...
[17:38:15.000] - result already collected: FutureResult
[17:38:15.000] result() for ClusterFuture ... done
[17:38:15.000] result() for ClusterFuture ...
[17:38:15.000] - result already collected: FutureResult
[17:38:15.000] result() for ClusterFuture ... done
[17:38:15.000] result() for ClusterFuture ...
[17:38:15.000] - result already collected: FutureResult
[17:38:15.000] result() for ClusterFuture ... done
[17:38:15.000] - relayed: [n=2] TRUE, FALSE
[17:38:15.000] - queued futures: [n=2] TRUE, FALSE
[17:38:15.001] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:15.001]  length: 1 (resolved future 1)
[17:38:15.001] Future #2
[17:38:15.001] result() for ClusterFuture ...
[17:38:15.001] - result already collected: FutureResult
[17:38:15.001] result() for ClusterFuture ... done
[17:38:15.001] result() for ClusterFuture ...
[17:38:15.001] - result already collected: FutureResult
[17:38:15.001] result() for ClusterFuture ... done
[17:38:15.001] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:15.001] - nx: 2
[17:38:15.002] - relay: TRUE
[17:38:15.002] - stdout: TRUE
[17:38:15.002] - signal: TRUE
[17:38:15.002] - resignal: FALSE
[17:38:15.002] - force: TRUE
[17:38:15.002] - relayed: [n=2] TRUE, FALSE
[17:38:15.002] - queued futures: [n=2] TRUE, FALSE
[17:38:15.002]  - until=2
[17:38:15.002]  - relaying element #2
[17:38:15.002] result() for ClusterFuture ...
[17:38:15.002] - result already collected: FutureResult
[17:38:15.002] result() for ClusterFuture ... done
[17:38:15.003] result() for ClusterFuture ...
[17:38:15.003] - result already collected: FutureResult
[17:38:15.003] result() for ClusterFuture ... done
[17:38:15.003] result() for ClusterFuture ...
[17:38:15.003] - result already collected: FutureResult
[17:38:15.003] result() for ClusterFuture ... done
[17:38:15.003] result() for ClusterFuture ...
[17:38:15.003] - result already collected: FutureResult
[17:38:15.003] result() for ClusterFuture ... done
[17:38:15.003] - relayed: [n=2] TRUE, TRUE
[17:38:15.003] - queued futures: [n=2] TRUE, TRUE
[17:38:15.004] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:15.004]  length: 0 (resolved future 2)
[17:38:15.004] Relaying remaining futures
[17:38:15.004] signalConditionsASAP(NULL, pos=0) ...
[17:38:15.004] - nx: 2
[17:38:15.004] - relay: TRUE
[17:38:15.004] - stdout: TRUE
[17:38:15.004] - signal: TRUE
[17:38:15.004] - resignal: FALSE
[17:38:15.004] - force: TRUE
[17:38:15.004] - relayed: [n=2] TRUE, TRUE
[17:38:15.005] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:15.005] - relayed: [n=2] TRUE, TRUE
[17:38:15.005] - queued futures: [n=2] TRUE, TRUE
[17:38:15.005] signalConditionsASAP(NULL, pos=0) ... done
[17:38:15.005] resolve() on list ... DONE
[17:38:15.005] result() for ClusterFuture ...
[17:38:15.005] - result already collected: FutureResult
[17:38:15.005] result() for ClusterFuture ... done
[17:38:15.005] result() for ClusterFuture ...
[17:38:15.005] - result already collected: FutureResult
[17:38:15.005] result() for ClusterFuture ... done
[17:38:15.006] result() for ClusterFuture ...
[17:38:15.006] - result already collected: FutureResult
[17:38:15.006] result() for ClusterFuture ... done
[17:38:15.006] result() for ClusterFuture ...
[17:38:15.006] - result already collected: FutureResult
[17:38:15.006] result() for ClusterFuture ... done
[17:38:15.006]  - Number of value chunks collected: 2
[17:38:15.006] Resolving 2 futures (chunks) ... DONE
[17:38:15.006] Reducing values from 2 chunks ...
[17:38:15.006]  - Number of values collected after concatenation: 4
[17:38:15.006]  - Number of values expected: 4
[17:38:15.007] Reducing values from 2 chunks ... DONE
[17:38:15.007] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[17:38:15.009] future_lapply() ...
[17:38:15.014] Number of chunks: 2
[17:38:15.014] getGlobalsAndPackagesXApply() ...
[17:38:15.014]  - future.globals: TRUE
[17:38:15.014] getGlobalsAndPackages() ...
[17:38:15.015] Searching for globals...
[17:38:15.018] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:15.018] Searching for globals ... DONE
[17:38:15.018] Resolving globals: FALSE
[17:38:15.019] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[17:38:15.019] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:15.019] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:15.019] - packages: [1] ‘future.apply’
[17:38:15.019] getGlobalsAndPackages() ... DONE
[17:38:15.020]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:15.020]  - needed namespaces: [n=1] ‘future.apply’
[17:38:15.020] Finding globals ... DONE
[17:38:15.020]  - use_args: TRUE
[17:38:15.020]  - Getting '...' globals ...
[17:38:15.020] resolve() on list ...
[17:38:15.020]  recursive: 0
[17:38:15.021]  length: 1
[17:38:15.021]  elements: ‘...’
[17:38:15.021]  length: 0 (resolved future 1)
[17:38:15.021] resolve() on list ... DONE
[17:38:15.021]    - '...' content: [n=0] 
[17:38:15.021] List of 1
[17:38:15.021]  $ ...: list()
[17:38:15.021]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:15.021]  - attr(*, "where")=List of 1
[17:38:15.021]   ..$ ...:<environment: 0x56080406ef18> 
[17:38:15.021]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:15.021]  - attr(*, "resolved")= logi TRUE
[17:38:15.021]  - attr(*, "total_size")= num NA
[17:38:15.024]  - Getting '...' globals ... DONE
[17:38:15.024] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:15.024] List of 8
[17:38:15.024]  $ ...future.FUN:function (x, ...)  
[17:38:15.024]  $ x_FUN        :function (x)  
[17:38:15.024]  $ times        : int 1
[17:38:15.024]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:15.024]  $ stop_if_not  :function (...)  
[17:38:15.024]  $ dim          : NULL
[17:38:15.024]  $ valid_types  : chr "logical"
[17:38:15.024]  $ ...          : list()
[17:38:15.024]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:15.024]  - attr(*, "where")=List of 8
[17:38:15.024]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:15.024]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:15.024]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:15.024]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:15.024]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:15.024]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:15.024]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:15.024]   ..$ ...          :<environment: 0x56080406ef18> 
[17:38:15.024]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:15.024]  - attr(*, "resolved")= logi FALSE
[17:38:15.024]  - attr(*, "total_size")= num 94200
[17:38:15.029] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:15.029] getGlobalsAndPackagesXApply() ... DONE
[17:38:15.030] Number of futures (= number of chunks): 2
[17:38:15.030] Launching 2 futures (chunks) ...
[17:38:15.030] Chunk #1 of 2 ...
[17:38:15.030]  - Finding globals in 'X' for chunk #1 ...
[17:38:15.030] getGlobalsAndPackages() ...
[17:38:15.030] Searching for globals...
[17:38:15.030] 
[17:38:15.031] Searching for globals ... DONE
[17:38:15.031] - globals: [0] <none>
[17:38:15.031] getGlobalsAndPackages() ... DONE
[17:38:15.031]    + additional globals found: [n=0] 
[17:38:15.031]    + additional namespaces needed: [n=0] 
[17:38:15.031]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:15.031]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:15.031]  - seeds: <none>
[17:38:15.031]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.031] getGlobalsAndPackages() ...
[17:38:15.031] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.032] Resolving globals: FALSE
[17:38:15.032] Tweak future expression to call with '...' arguments ...
[17:38:15.032] {
[17:38:15.032]     do.call(function(...) {
[17:38:15.032]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.032]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:15.032]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.032]             on.exit(options(oopts), add = TRUE)
[17:38:15.032]         }
[17:38:15.032]         {
[17:38:15.032]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:15.032]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.032]                 ...future.FUN(...future.X_jj, ...)
[17:38:15.032]             })
[17:38:15.032]         }
[17:38:15.032]     }, args = future.call.arguments)
[17:38:15.032] }
[17:38:15.032] Tweak future expression to call with '...' arguments ... DONE
[17:38:15.033] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.033] - packages: [1] ‘future.apply’
[17:38:15.033] getGlobalsAndPackages() ... DONE
[17:38:15.033] run() for ‘Future’ ...
[17:38:15.033] - state: ‘created’
[17:38:15.034] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:15.048] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:15.048] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:15.048]   - Field: ‘node’
[17:38:15.048]   - Field: ‘label’
[17:38:15.048]   - Field: ‘local’
[17:38:15.048]   - Field: ‘owner’
[17:38:15.048]   - Field: ‘envir’
[17:38:15.048]   - Field: ‘workers’
[17:38:15.048]   - Field: ‘packages’
[17:38:15.048]   - Field: ‘gc’
[17:38:15.049]   - Field: ‘conditions’
[17:38:15.049]   - Field: ‘persistent’
[17:38:15.049]   - Field: ‘expr’
[17:38:15.049]   - Field: ‘uuid’
[17:38:15.049]   - Field: ‘seed’
[17:38:15.049]   - Field: ‘version’
[17:38:15.049]   - Field: ‘result’
[17:38:15.049]   - Field: ‘asynchronous’
[17:38:15.049]   - Field: ‘calls’
[17:38:15.049]   - Field: ‘globals’
[17:38:15.049]   - Field: ‘stdout’
[17:38:15.050]   - Field: ‘earlySignal’
[17:38:15.050]   - Field: ‘lazy’
[17:38:15.050]   - Field: ‘state’
[17:38:15.050] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:15.050] - Launch lazy future ...
[17:38:15.050] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:15.050] Packages needed by future strategies (n = 0): <none>
[17:38:15.051] {
[17:38:15.051]     {
[17:38:15.051]         {
[17:38:15.051]             ...future.startTime <- base::Sys.time()
[17:38:15.051]             {
[17:38:15.051]                 {
[17:38:15.051]                   {
[17:38:15.051]                     {
[17:38:15.051]                       {
[17:38:15.051]                         base::local({
[17:38:15.051]                           has_future <- base::requireNamespace("future", 
[17:38:15.051]                             quietly = TRUE)
[17:38:15.051]                           if (has_future) {
[17:38:15.051]                             ns <- base::getNamespace("future")
[17:38:15.051]                             version <- ns[[".package"]][["version"]]
[17:38:15.051]                             if (is.null(version)) 
[17:38:15.051]                               version <- utils::packageVersion("future")
[17:38:15.051]                           }
[17:38:15.051]                           else {
[17:38:15.051]                             version <- NULL
[17:38:15.051]                           }
[17:38:15.051]                           if (!has_future || version < "1.8.0") {
[17:38:15.051]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:15.051]                               "", base::R.version$version.string), 
[17:38:15.051]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:15.051]                                 base::R.version$platform, 8 * 
[17:38:15.051]                                   base::.Machine$sizeof.pointer), 
[17:38:15.051]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:15.051]                                 "release", "version")], collapse = " "), 
[17:38:15.051]                               hostname = base::Sys.info()[["nodename"]])
[17:38:15.051]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:15.051]                               info)
[17:38:15.051]                             info <- base::paste(info, collapse = "; ")
[17:38:15.051]                             if (!has_future) {
[17:38:15.051]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:15.051]                                 info)
[17:38:15.051]                             }
[17:38:15.051]                             else {
[17:38:15.051]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:15.051]                                 info, version)
[17:38:15.051]                             }
[17:38:15.051]                             base::stop(msg)
[17:38:15.051]                           }
[17:38:15.051]                         })
[17:38:15.051]                       }
[17:38:15.051]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:15.051]                       base::options(mc.cores = 1L)
[17:38:15.051]                     }
[17:38:15.051]                     base::local({
[17:38:15.051]                       for (pkg in "future.apply") {
[17:38:15.051]                         base::loadNamespace(pkg)
[17:38:15.051]                         base::library(pkg, character.only = TRUE)
[17:38:15.051]                       }
[17:38:15.051]                     })
[17:38:15.051]                   }
[17:38:15.051]                   ...future.strategy.old <- future::plan("list")
[17:38:15.051]                   options(future.plan = NULL)
[17:38:15.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:15.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:15.051]                 }
[17:38:15.051]                 ...future.workdir <- getwd()
[17:38:15.051]             }
[17:38:15.051]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:15.051]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:15.051]         }
[17:38:15.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:15.051]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:15.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:15.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:15.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:15.051]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:15.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:15.051]             base::names(...future.oldOptions))
[17:38:15.051]     }
[17:38:15.051]     if (FALSE) {
[17:38:15.051]     }
[17:38:15.051]     else {
[17:38:15.051]         if (TRUE) {
[17:38:15.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:15.051]                 open = "w")
[17:38:15.051]         }
[17:38:15.051]         else {
[17:38:15.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:15.051]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:15.051]         }
[17:38:15.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:15.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:15.051]             base::sink(type = "output", split = FALSE)
[17:38:15.051]             base::close(...future.stdout)
[17:38:15.051]         }, add = TRUE)
[17:38:15.051]     }
[17:38:15.051]     ...future.frame <- base::sys.nframe()
[17:38:15.051]     ...future.conditions <- base::list()
[17:38:15.051]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:15.051]     if (FALSE) {
[17:38:15.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:15.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:15.051]     }
[17:38:15.051]     ...future.result <- base::tryCatch({
[17:38:15.051]         base::withCallingHandlers({
[17:38:15.051]             ...future.value <- base::withVisible(base::local({
[17:38:15.051]                 ...future.makeSendCondition <- base::local({
[17:38:15.051]                   sendCondition <- NULL
[17:38:15.051]                   function(frame = 1L) {
[17:38:15.051]                     if (is.function(sendCondition)) 
[17:38:15.051]                       return(sendCondition)
[17:38:15.051]                     ns <- getNamespace("parallel")
[17:38:15.051]                     if (exists("sendData", mode = "function", 
[17:38:15.051]                       envir = ns)) {
[17:38:15.051]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:15.051]                         envir = ns)
[17:38:15.051]                       envir <- sys.frame(frame)
[17:38:15.051]                       master <- NULL
[17:38:15.051]                       while (!identical(envir, .GlobalEnv) && 
[17:38:15.051]                         !identical(envir, emptyenv())) {
[17:38:15.051]                         if (exists("master", mode = "list", envir = envir, 
[17:38:15.051]                           inherits = FALSE)) {
[17:38:15.051]                           master <- get("master", mode = "list", 
[17:38:15.051]                             envir = envir, inherits = FALSE)
[17:38:15.051]                           if (inherits(master, c("SOCKnode", 
[17:38:15.051]                             "SOCK0node"))) {
[17:38:15.051]                             sendCondition <<- function(cond) {
[17:38:15.051]                               data <- list(type = "VALUE", value = cond, 
[17:38:15.051]                                 success = TRUE)
[17:38:15.051]                               parallel_sendData(master, data)
[17:38:15.051]                             }
[17:38:15.051]                             return(sendCondition)
[17:38:15.051]                           }
[17:38:15.051]                         }
[17:38:15.051]                         frame <- frame + 1L
[17:38:15.051]                         envir <- sys.frame(frame)
[17:38:15.051]                       }
[17:38:15.051]                     }
[17:38:15.051]                     sendCondition <<- function(cond) NULL
[17:38:15.051]                   }
[17:38:15.051]                 })
[17:38:15.051]                 withCallingHandlers({
[17:38:15.051]                   {
[17:38:15.051]                     do.call(function(...) {
[17:38:15.051]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.051]                       if (!identical(...future.globals.maxSize.org, 
[17:38:15.051]                         ...future.globals.maxSize)) {
[17:38:15.051]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.051]                         on.exit(options(oopts), add = TRUE)
[17:38:15.051]                       }
[17:38:15.051]                       {
[17:38:15.051]                         lapply(seq_along(...future.elements_ii), 
[17:38:15.051]                           FUN = function(jj) {
[17:38:15.051]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.051]                             ...future.FUN(...future.X_jj, ...)
[17:38:15.051]                           })
[17:38:15.051]                       }
[17:38:15.051]                     }, args = future.call.arguments)
[17:38:15.051]                   }
[17:38:15.051]                 }, immediateCondition = function(cond) {
[17:38:15.051]                   sendCondition <- ...future.makeSendCondition()
[17:38:15.051]                   sendCondition(cond)
[17:38:15.051]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.051]                   {
[17:38:15.051]                     inherits <- base::inherits
[17:38:15.051]                     invokeRestart <- base::invokeRestart
[17:38:15.051]                     is.null <- base::is.null
[17:38:15.051]                     muffled <- FALSE
[17:38:15.051]                     if (inherits(cond, "message")) {
[17:38:15.051]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:15.051]                       if (muffled) 
[17:38:15.051]                         invokeRestart("muffleMessage")
[17:38:15.051]                     }
[17:38:15.051]                     else if (inherits(cond, "warning")) {
[17:38:15.051]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:15.051]                       if (muffled) 
[17:38:15.051]                         invokeRestart("muffleWarning")
[17:38:15.051]                     }
[17:38:15.051]                     else if (inherits(cond, "condition")) {
[17:38:15.051]                       if (!is.null(pattern)) {
[17:38:15.051]                         computeRestarts <- base::computeRestarts
[17:38:15.051]                         grepl <- base::grepl
[17:38:15.051]                         restarts <- computeRestarts(cond)
[17:38:15.051]                         for (restart in restarts) {
[17:38:15.051]                           name <- restart$name
[17:38:15.051]                           if (is.null(name)) 
[17:38:15.051]                             next
[17:38:15.051]                           if (!grepl(pattern, name)) 
[17:38:15.051]                             next
[17:38:15.051]                           invokeRestart(restart)
[17:38:15.051]                           muffled <- TRUE
[17:38:15.051]                           break
[17:38:15.051]                         }
[17:38:15.051]                       }
[17:38:15.051]                     }
[17:38:15.051]                     invisible(muffled)
[17:38:15.051]                   }
[17:38:15.051]                   muffleCondition(cond)
[17:38:15.051]                 })
[17:38:15.051]             }))
[17:38:15.051]             future::FutureResult(value = ...future.value$value, 
[17:38:15.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:15.051]                   ...future.rng), globalenv = if (FALSE) 
[17:38:15.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:15.051]                     ...future.globalenv.names))
[17:38:15.051]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:15.051]         }, condition = base::local({
[17:38:15.051]             c <- base::c
[17:38:15.051]             inherits <- base::inherits
[17:38:15.051]             invokeRestart <- base::invokeRestart
[17:38:15.051]             length <- base::length
[17:38:15.051]             list <- base::list
[17:38:15.051]             seq.int <- base::seq.int
[17:38:15.051]             signalCondition <- base::signalCondition
[17:38:15.051]             sys.calls <- base::sys.calls
[17:38:15.051]             `[[` <- base::`[[`
[17:38:15.051]             `+` <- base::`+`
[17:38:15.051]             `<<-` <- base::`<<-`
[17:38:15.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:15.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:15.051]                   3L)]
[17:38:15.051]             }
[17:38:15.051]             function(cond) {
[17:38:15.051]                 is_error <- inherits(cond, "error")
[17:38:15.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:15.051]                   NULL)
[17:38:15.051]                 if (is_error) {
[17:38:15.051]                   sessionInformation <- function() {
[17:38:15.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:15.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:15.051]                       search = base::search(), system = base::Sys.info())
[17:38:15.051]                   }
[17:38:15.051]                   ...future.conditions[[length(...future.conditions) + 
[17:38:15.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:15.051]                     cond$call), session = sessionInformation(), 
[17:38:15.051]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:15.051]                   signalCondition(cond)
[17:38:15.051]                 }
[17:38:15.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:15.051]                 "immediateCondition"))) {
[17:38:15.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:15.051]                   ...future.conditions[[length(...future.conditions) + 
[17:38:15.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:15.051]                   if (TRUE && !signal) {
[17:38:15.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.051]                     {
[17:38:15.051]                       inherits <- base::inherits
[17:38:15.051]                       invokeRestart <- base::invokeRestart
[17:38:15.051]                       is.null <- base::is.null
[17:38:15.051]                       muffled <- FALSE
[17:38:15.051]                       if (inherits(cond, "message")) {
[17:38:15.051]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:15.051]                         if (muffled) 
[17:38:15.051]                           invokeRestart("muffleMessage")
[17:38:15.051]                       }
[17:38:15.051]                       else if (inherits(cond, "warning")) {
[17:38:15.051]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:15.051]                         if (muffled) 
[17:38:15.051]                           invokeRestart("muffleWarning")
[17:38:15.051]                       }
[17:38:15.051]                       else if (inherits(cond, "condition")) {
[17:38:15.051]                         if (!is.null(pattern)) {
[17:38:15.051]                           computeRestarts <- base::computeRestarts
[17:38:15.051]                           grepl <- base::grepl
[17:38:15.051]                           restarts <- computeRestarts(cond)
[17:38:15.051]                           for (restart in restarts) {
[17:38:15.051]                             name <- restart$name
[17:38:15.051]                             if (is.null(name)) 
[17:38:15.051]                               next
[17:38:15.051]                             if (!grepl(pattern, name)) 
[17:38:15.051]                               next
[17:38:15.051]                             invokeRestart(restart)
[17:38:15.051]                             muffled <- TRUE
[17:38:15.051]                             break
[17:38:15.051]                           }
[17:38:15.051]                         }
[17:38:15.051]                       }
[17:38:15.051]                       invisible(muffled)
[17:38:15.051]                     }
[17:38:15.051]                     muffleCondition(cond, pattern = "^muffle")
[17:38:15.051]                   }
[17:38:15.051]                 }
[17:38:15.051]                 else {
[17:38:15.051]                   if (TRUE) {
[17:38:15.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.051]                     {
[17:38:15.051]                       inherits <- base::inherits
[17:38:15.051]                       invokeRestart <- base::invokeRestart
[17:38:15.051]                       is.null <- base::is.null
[17:38:15.051]                       muffled <- FALSE
[17:38:15.051]                       if (inherits(cond, "message")) {
[17:38:15.051]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:15.051]                         if (muffled) 
[17:38:15.051]                           invokeRestart("muffleMessage")
[17:38:15.051]                       }
[17:38:15.051]                       else if (inherits(cond, "warning")) {
[17:38:15.051]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:15.051]                         if (muffled) 
[17:38:15.051]                           invokeRestart("muffleWarning")
[17:38:15.051]                       }
[17:38:15.051]                       else if (inherits(cond, "condition")) {
[17:38:15.051]                         if (!is.null(pattern)) {
[17:38:15.051]                           computeRestarts <- base::computeRestarts
[17:38:15.051]                           grepl <- base::grepl
[17:38:15.051]                           restarts <- computeRestarts(cond)
[17:38:15.051]                           for (restart in restarts) {
[17:38:15.051]                             name <- restart$name
[17:38:15.051]                             if (is.null(name)) 
[17:38:15.051]                               next
[17:38:15.051]                             if (!grepl(pattern, name)) 
[17:38:15.051]                               next
[17:38:15.051]                             invokeRestart(restart)
[17:38:15.051]                             muffled <- TRUE
[17:38:15.051]                             break
[17:38:15.051]                           }
[17:38:15.051]                         }
[17:38:15.051]                       }
[17:38:15.051]                       invisible(muffled)
[17:38:15.051]                     }
[17:38:15.051]                     muffleCondition(cond, pattern = "^muffle")
[17:38:15.051]                   }
[17:38:15.051]                 }
[17:38:15.051]             }
[17:38:15.051]         }))
[17:38:15.051]     }, error = function(ex) {
[17:38:15.051]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:15.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:15.051]                 ...future.rng), started = ...future.startTime, 
[17:38:15.051]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:15.051]             version = "1.8"), class = "FutureResult")
[17:38:15.051]     }, finally = {
[17:38:15.051]         if (!identical(...future.workdir, getwd())) 
[17:38:15.051]             setwd(...future.workdir)
[17:38:15.051]         {
[17:38:15.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:15.051]                 ...future.oldOptions$nwarnings <- NULL
[17:38:15.051]             }
[17:38:15.051]             base::options(...future.oldOptions)
[17:38:15.051]             if (.Platform$OS.type == "windows") {
[17:38:15.051]                 old_names <- names(...future.oldEnvVars)
[17:38:15.051]                 envs <- base::Sys.getenv()
[17:38:15.051]                 names <- names(envs)
[17:38:15.051]                 common <- intersect(names, old_names)
[17:38:15.051]                 added <- setdiff(names, old_names)
[17:38:15.051]                 removed <- setdiff(old_names, names)
[17:38:15.051]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:15.051]                   envs[common]]
[17:38:15.051]                 NAMES <- toupper(changed)
[17:38:15.051]                 args <- list()
[17:38:15.051]                 for (kk in seq_along(NAMES)) {
[17:38:15.051]                   name <- changed[[kk]]
[17:38:15.051]                   NAME <- NAMES[[kk]]
[17:38:15.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.051]                     next
[17:38:15.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:15.051]                 }
[17:38:15.051]                 NAMES <- toupper(added)
[17:38:15.051]                 for (kk in seq_along(NAMES)) {
[17:38:15.051]                   name <- added[[kk]]
[17:38:15.051]                   NAME <- NAMES[[kk]]
[17:38:15.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.051]                     next
[17:38:15.051]                   args[[name]] <- ""
[17:38:15.051]                 }
[17:38:15.051]                 NAMES <- toupper(removed)
[17:38:15.051]                 for (kk in seq_along(NAMES)) {
[17:38:15.051]                   name <- removed[[kk]]
[17:38:15.051]                   NAME <- NAMES[[kk]]
[17:38:15.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.051]                     next
[17:38:15.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:15.051]                 }
[17:38:15.051]                 if (length(args) > 0) 
[17:38:15.051]                   base::do.call(base::Sys.setenv, args = args)
[17:38:15.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:15.051]             }
[17:38:15.051]             else {
[17:38:15.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:15.051]             }
[17:38:15.051]             {
[17:38:15.051]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:15.051]                   0L) {
[17:38:15.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:15.051]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:15.051]                   base::options(opts)
[17:38:15.051]                 }
[17:38:15.051]                 {
[17:38:15.051]                   {
[17:38:15.051]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:15.051]                     NULL
[17:38:15.051]                   }
[17:38:15.051]                   options(future.plan = NULL)
[17:38:15.051]                   if (is.na(NA_character_)) 
[17:38:15.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:15.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:15.051]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:15.051]                     .init = FALSE)
[17:38:15.051]                 }
[17:38:15.051]             }
[17:38:15.051]         }
[17:38:15.051]     })
[17:38:15.051]     if (TRUE) {
[17:38:15.051]         base::sink(type = "output", split = FALSE)
[17:38:15.051]         if (TRUE) {
[17:38:15.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:15.051]         }
[17:38:15.051]         else {
[17:38:15.051]             ...future.result["stdout"] <- base::list(NULL)
[17:38:15.051]         }
[17:38:15.051]         base::close(...future.stdout)
[17:38:15.051]         ...future.stdout <- NULL
[17:38:15.051]     }
[17:38:15.051]     ...future.result$conditions <- ...future.conditions
[17:38:15.051]     ...future.result$finished <- base::Sys.time()
[17:38:15.051]     ...future.result
[17:38:15.051] }
[17:38:15.054] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[17:38:15.054] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:38:15.097] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:38:15.097] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:38:15.097] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:38:15.097] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:38:15.098] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:38:15.098] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:38:15.140] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:38:15.141] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:38:15.185] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:38:15.185] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:38:15.185] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:38:15.186] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[17:38:15.186] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[17:38:15.186] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:15.187] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:15.187] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ...
[17:38:15.187] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ... DONE
[17:38:15.187] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:15.187] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:15.188] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:15.188] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:15.188] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[17:38:15.189] MultisessionFuture started
[17:38:15.189] - Launch lazy future ... done
[17:38:15.189] run() for ‘MultisessionFuture’ ... done
[17:38:15.189] Created future:
[17:38:15.189] MultisessionFuture:
[17:38:15.189] Label: ‘future_vapply-1’
[17:38:15.189] Expression:
[17:38:15.189] {
[17:38:15.189]     do.call(function(...) {
[17:38:15.189]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.189]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:15.189]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.189]             on.exit(options(oopts), add = TRUE)
[17:38:15.189]         }
[17:38:15.189]         {
[17:38:15.189]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:15.189]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.189]                 ...future.FUN(...future.X_jj, ...)
[17:38:15.189]             })
[17:38:15.189]         }
[17:38:15.189]     }, args = future.call.arguments)
[17:38:15.189] }
[17:38:15.189] Lazy evaluation: FALSE
[17:38:15.189] Asynchronous evaluation: TRUE
[17:38:15.189] Local evaluation: TRUE
[17:38:15.189] Environment: R_GlobalEnv
[17:38:15.189] Capture standard output: TRUE
[17:38:15.189] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:15.189] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:15.189] Packages: 1 packages (‘future.apply’)
[17:38:15.189] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:15.189] Resolved: FALSE
[17:38:15.189] Value: <not collected>
[17:38:15.189] Conditions captured: <none>
[17:38:15.189] Early signaling: FALSE
[17:38:15.189] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:15.189] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:15.201] Chunk #1 of 2 ... DONE
[17:38:15.201] Chunk #2 of 2 ...
[17:38:15.204]  - Finding globals in 'X' for chunk #2 ...
[17:38:15.204] getGlobalsAndPackages() ...
[17:38:15.204] Searching for globals...
[17:38:15.205] 
[17:38:15.205] Searching for globals ... DONE
[17:38:15.205] - globals: [0] <none>
[17:38:15.205] getGlobalsAndPackages() ... DONE
[17:38:15.205]    + additional globals found: [n=0] 
[17:38:15.205]    + additional namespaces needed: [n=0] 
[17:38:15.205]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:15.206]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:15.206]  - seeds: <none>
[17:38:15.206]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.206] getGlobalsAndPackages() ...
[17:38:15.206] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.206] Resolving globals: FALSE
[17:38:15.206] Tweak future expression to call with '...' arguments ...
[17:38:15.206] {
[17:38:15.206]     do.call(function(...) {
[17:38:15.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:15.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.206]             on.exit(options(oopts), add = TRUE)
[17:38:15.206]         }
[17:38:15.206]         {
[17:38:15.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:15.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.206]                 ...future.FUN(...future.X_jj, ...)
[17:38:15.206]             })
[17:38:15.206]         }
[17:38:15.206]     }, args = future.call.arguments)
[17:38:15.206] }
[17:38:15.207] Tweak future expression to call with '...' arguments ... DONE
[17:38:15.207] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.208] - packages: [1] ‘future.apply’
[17:38:15.208] getGlobalsAndPackages() ... DONE
[17:38:15.208] run() for ‘Future’ ...
[17:38:15.208] - state: ‘created’
[17:38:15.209] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:15.224] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:15.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:15.224]   - Field: ‘node’
[17:38:15.224]   - Field: ‘label’
[17:38:15.224]   - Field: ‘local’
[17:38:15.224]   - Field: ‘owner’
[17:38:15.225]   - Field: ‘envir’
[17:38:15.225]   - Field: ‘workers’
[17:38:15.225]   - Field: ‘packages’
[17:38:15.225]   - Field: ‘gc’
[17:38:15.225]   - Field: ‘conditions’
[17:38:15.225]   - Field: ‘persistent’
[17:38:15.225]   - Field: ‘expr’
[17:38:15.225]   - Field: ‘uuid’
[17:38:15.225]   - Field: ‘seed’
[17:38:15.225]   - Field: ‘version’
[17:38:15.225]   - Field: ‘result’
[17:38:15.226]   - Field: ‘asynchronous’
[17:38:15.226]   - Field: ‘calls’
[17:38:15.226]   - Field: ‘globals’
[17:38:15.226]   - Field: ‘stdout’
[17:38:15.226]   - Field: ‘earlySignal’
[17:38:15.226]   - Field: ‘lazy’
[17:38:15.226]   - Field: ‘state’
[17:38:15.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:15.226] - Launch lazy future ...
[17:38:15.227] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:15.227] Packages needed by future strategies (n = 0): <none>
[17:38:15.227] {
[17:38:15.227]     {
[17:38:15.227]         {
[17:38:15.227]             ...future.startTime <- base::Sys.time()
[17:38:15.227]             {
[17:38:15.227]                 {
[17:38:15.227]                   {
[17:38:15.227]                     {
[17:38:15.227]                       {
[17:38:15.227]                         base::local({
[17:38:15.227]                           has_future <- base::requireNamespace("future", 
[17:38:15.227]                             quietly = TRUE)
[17:38:15.227]                           if (has_future) {
[17:38:15.227]                             ns <- base::getNamespace("future")
[17:38:15.227]                             version <- ns[[".package"]][["version"]]
[17:38:15.227]                             if (is.null(version)) 
[17:38:15.227]                               version <- utils::packageVersion("future")
[17:38:15.227]                           }
[17:38:15.227]                           else {
[17:38:15.227]                             version <- NULL
[17:38:15.227]                           }
[17:38:15.227]                           if (!has_future || version < "1.8.0") {
[17:38:15.227]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:15.227]                               "", base::R.version$version.string), 
[17:38:15.227]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:15.227]                                 base::R.version$platform, 8 * 
[17:38:15.227]                                   base::.Machine$sizeof.pointer), 
[17:38:15.227]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:15.227]                                 "release", "version")], collapse = " "), 
[17:38:15.227]                               hostname = base::Sys.info()[["nodename"]])
[17:38:15.227]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:15.227]                               info)
[17:38:15.227]                             info <- base::paste(info, collapse = "; ")
[17:38:15.227]                             if (!has_future) {
[17:38:15.227]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:15.227]                                 info)
[17:38:15.227]                             }
[17:38:15.227]                             else {
[17:38:15.227]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:15.227]                                 info, version)
[17:38:15.227]                             }
[17:38:15.227]                             base::stop(msg)
[17:38:15.227]                           }
[17:38:15.227]                         })
[17:38:15.227]                       }
[17:38:15.227]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:15.227]                       base::options(mc.cores = 1L)
[17:38:15.227]                     }
[17:38:15.227]                     base::local({
[17:38:15.227]                       for (pkg in "future.apply") {
[17:38:15.227]                         base::loadNamespace(pkg)
[17:38:15.227]                         base::library(pkg, character.only = TRUE)
[17:38:15.227]                       }
[17:38:15.227]                     })
[17:38:15.227]                   }
[17:38:15.227]                   ...future.strategy.old <- future::plan("list")
[17:38:15.227]                   options(future.plan = NULL)
[17:38:15.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:15.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:15.227]                 }
[17:38:15.227]                 ...future.workdir <- getwd()
[17:38:15.227]             }
[17:38:15.227]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:15.227]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:15.227]         }
[17:38:15.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:15.227]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:15.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:15.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:15.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:15.227]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:15.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:15.227]             base::names(...future.oldOptions))
[17:38:15.227]     }
[17:38:15.227]     if (FALSE) {
[17:38:15.227]     }
[17:38:15.227]     else {
[17:38:15.227]         if (TRUE) {
[17:38:15.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:15.227]                 open = "w")
[17:38:15.227]         }
[17:38:15.227]         else {
[17:38:15.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:15.227]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:15.227]         }
[17:38:15.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:15.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:15.227]             base::sink(type = "output", split = FALSE)
[17:38:15.227]             base::close(...future.stdout)
[17:38:15.227]         }, add = TRUE)
[17:38:15.227]     }
[17:38:15.227]     ...future.frame <- base::sys.nframe()
[17:38:15.227]     ...future.conditions <- base::list()
[17:38:15.227]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:15.227]     if (FALSE) {
[17:38:15.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:15.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:15.227]     }
[17:38:15.227]     ...future.result <- base::tryCatch({
[17:38:15.227]         base::withCallingHandlers({
[17:38:15.227]             ...future.value <- base::withVisible(base::local({
[17:38:15.227]                 ...future.makeSendCondition <- base::local({
[17:38:15.227]                   sendCondition <- NULL
[17:38:15.227]                   function(frame = 1L) {
[17:38:15.227]                     if (is.function(sendCondition)) 
[17:38:15.227]                       return(sendCondition)
[17:38:15.227]                     ns <- getNamespace("parallel")
[17:38:15.227]                     if (exists("sendData", mode = "function", 
[17:38:15.227]                       envir = ns)) {
[17:38:15.227]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:15.227]                         envir = ns)
[17:38:15.227]                       envir <- sys.frame(frame)
[17:38:15.227]                       master <- NULL
[17:38:15.227]                       while (!identical(envir, .GlobalEnv) && 
[17:38:15.227]                         !identical(envir, emptyenv())) {
[17:38:15.227]                         if (exists("master", mode = "list", envir = envir, 
[17:38:15.227]                           inherits = FALSE)) {
[17:38:15.227]                           master <- get("master", mode = "list", 
[17:38:15.227]                             envir = envir, inherits = FALSE)
[17:38:15.227]                           if (inherits(master, c("SOCKnode", 
[17:38:15.227]                             "SOCK0node"))) {
[17:38:15.227]                             sendCondition <<- function(cond) {
[17:38:15.227]                               data <- list(type = "VALUE", value = cond, 
[17:38:15.227]                                 success = TRUE)
[17:38:15.227]                               parallel_sendData(master, data)
[17:38:15.227]                             }
[17:38:15.227]                             return(sendCondition)
[17:38:15.227]                           }
[17:38:15.227]                         }
[17:38:15.227]                         frame <- frame + 1L
[17:38:15.227]                         envir <- sys.frame(frame)
[17:38:15.227]                       }
[17:38:15.227]                     }
[17:38:15.227]                     sendCondition <<- function(cond) NULL
[17:38:15.227]                   }
[17:38:15.227]                 })
[17:38:15.227]                 withCallingHandlers({
[17:38:15.227]                   {
[17:38:15.227]                     do.call(function(...) {
[17:38:15.227]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.227]                       if (!identical(...future.globals.maxSize.org, 
[17:38:15.227]                         ...future.globals.maxSize)) {
[17:38:15.227]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.227]                         on.exit(options(oopts), add = TRUE)
[17:38:15.227]                       }
[17:38:15.227]                       {
[17:38:15.227]                         lapply(seq_along(...future.elements_ii), 
[17:38:15.227]                           FUN = function(jj) {
[17:38:15.227]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.227]                             ...future.FUN(...future.X_jj, ...)
[17:38:15.227]                           })
[17:38:15.227]                       }
[17:38:15.227]                     }, args = future.call.arguments)
[17:38:15.227]                   }
[17:38:15.227]                 }, immediateCondition = function(cond) {
[17:38:15.227]                   sendCondition <- ...future.makeSendCondition()
[17:38:15.227]                   sendCondition(cond)
[17:38:15.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.227]                   {
[17:38:15.227]                     inherits <- base::inherits
[17:38:15.227]                     invokeRestart <- base::invokeRestart
[17:38:15.227]                     is.null <- base::is.null
[17:38:15.227]                     muffled <- FALSE
[17:38:15.227]                     if (inherits(cond, "message")) {
[17:38:15.227]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:15.227]                       if (muffled) 
[17:38:15.227]                         invokeRestart("muffleMessage")
[17:38:15.227]                     }
[17:38:15.227]                     else if (inherits(cond, "warning")) {
[17:38:15.227]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:15.227]                       if (muffled) 
[17:38:15.227]                         invokeRestart("muffleWarning")
[17:38:15.227]                     }
[17:38:15.227]                     else if (inherits(cond, "condition")) {
[17:38:15.227]                       if (!is.null(pattern)) {
[17:38:15.227]                         computeRestarts <- base::computeRestarts
[17:38:15.227]                         grepl <- base::grepl
[17:38:15.227]                         restarts <- computeRestarts(cond)
[17:38:15.227]                         for (restart in restarts) {
[17:38:15.227]                           name <- restart$name
[17:38:15.227]                           if (is.null(name)) 
[17:38:15.227]                             next
[17:38:15.227]                           if (!grepl(pattern, name)) 
[17:38:15.227]                             next
[17:38:15.227]                           invokeRestart(restart)
[17:38:15.227]                           muffled <- TRUE
[17:38:15.227]                           break
[17:38:15.227]                         }
[17:38:15.227]                       }
[17:38:15.227]                     }
[17:38:15.227]                     invisible(muffled)
[17:38:15.227]                   }
[17:38:15.227]                   muffleCondition(cond)
[17:38:15.227]                 })
[17:38:15.227]             }))
[17:38:15.227]             future::FutureResult(value = ...future.value$value, 
[17:38:15.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:15.227]                   ...future.rng), globalenv = if (FALSE) 
[17:38:15.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:15.227]                     ...future.globalenv.names))
[17:38:15.227]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:15.227]         }, condition = base::local({
[17:38:15.227]             c <- base::c
[17:38:15.227]             inherits <- base::inherits
[17:38:15.227]             invokeRestart <- base::invokeRestart
[17:38:15.227]             length <- base::length
[17:38:15.227]             list <- base::list
[17:38:15.227]             seq.int <- base::seq.int
[17:38:15.227]             signalCondition <- base::signalCondition
[17:38:15.227]             sys.calls <- base::sys.calls
[17:38:15.227]             `[[` <- base::`[[`
[17:38:15.227]             `+` <- base::`+`
[17:38:15.227]             `<<-` <- base::`<<-`
[17:38:15.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:15.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:15.227]                   3L)]
[17:38:15.227]             }
[17:38:15.227]             function(cond) {
[17:38:15.227]                 is_error <- inherits(cond, "error")
[17:38:15.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:15.227]                   NULL)
[17:38:15.227]                 if (is_error) {
[17:38:15.227]                   sessionInformation <- function() {
[17:38:15.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:15.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:15.227]                       search = base::search(), system = base::Sys.info())
[17:38:15.227]                   }
[17:38:15.227]                   ...future.conditions[[length(...future.conditions) + 
[17:38:15.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:15.227]                     cond$call), session = sessionInformation(), 
[17:38:15.227]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:15.227]                   signalCondition(cond)
[17:38:15.227]                 }
[17:38:15.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:15.227]                 "immediateCondition"))) {
[17:38:15.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:15.227]                   ...future.conditions[[length(...future.conditions) + 
[17:38:15.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:15.227]                   if (TRUE && !signal) {
[17:38:15.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.227]                     {
[17:38:15.227]                       inherits <- base::inherits
[17:38:15.227]                       invokeRestart <- base::invokeRestart
[17:38:15.227]                       is.null <- base::is.null
[17:38:15.227]                       muffled <- FALSE
[17:38:15.227]                       if (inherits(cond, "message")) {
[17:38:15.227]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:15.227]                         if (muffled) 
[17:38:15.227]                           invokeRestart("muffleMessage")
[17:38:15.227]                       }
[17:38:15.227]                       else if (inherits(cond, "warning")) {
[17:38:15.227]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:15.227]                         if (muffled) 
[17:38:15.227]                           invokeRestart("muffleWarning")
[17:38:15.227]                       }
[17:38:15.227]                       else if (inherits(cond, "condition")) {
[17:38:15.227]                         if (!is.null(pattern)) {
[17:38:15.227]                           computeRestarts <- base::computeRestarts
[17:38:15.227]                           grepl <- base::grepl
[17:38:15.227]                           restarts <- computeRestarts(cond)
[17:38:15.227]                           for (restart in restarts) {
[17:38:15.227]                             name <- restart$name
[17:38:15.227]                             if (is.null(name)) 
[17:38:15.227]                               next
[17:38:15.227]                             if (!grepl(pattern, name)) 
[17:38:15.227]                               next
[17:38:15.227]                             invokeRestart(restart)
[17:38:15.227]                             muffled <- TRUE
[17:38:15.227]                             break
[17:38:15.227]                           }
[17:38:15.227]                         }
[17:38:15.227]                       }
[17:38:15.227]                       invisible(muffled)
[17:38:15.227]                     }
[17:38:15.227]                     muffleCondition(cond, pattern = "^muffle")
[17:38:15.227]                   }
[17:38:15.227]                 }
[17:38:15.227]                 else {
[17:38:15.227]                   if (TRUE) {
[17:38:15.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.227]                     {
[17:38:15.227]                       inherits <- base::inherits
[17:38:15.227]                       invokeRestart <- base::invokeRestart
[17:38:15.227]                       is.null <- base::is.null
[17:38:15.227]                       muffled <- FALSE
[17:38:15.227]                       if (inherits(cond, "message")) {
[17:38:15.227]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:15.227]                         if (muffled) 
[17:38:15.227]                           invokeRestart("muffleMessage")
[17:38:15.227]                       }
[17:38:15.227]                       else if (inherits(cond, "warning")) {
[17:38:15.227]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:15.227]                         if (muffled) 
[17:38:15.227]                           invokeRestart("muffleWarning")
[17:38:15.227]                       }
[17:38:15.227]                       else if (inherits(cond, "condition")) {
[17:38:15.227]                         if (!is.null(pattern)) {
[17:38:15.227]                           computeRestarts <- base::computeRestarts
[17:38:15.227]                           grepl <- base::grepl
[17:38:15.227]                           restarts <- computeRestarts(cond)
[17:38:15.227]                           for (restart in restarts) {
[17:38:15.227]                             name <- restart$name
[17:38:15.227]                             if (is.null(name)) 
[17:38:15.227]                               next
[17:38:15.227]                             if (!grepl(pattern, name)) 
[17:38:15.227]                               next
[17:38:15.227]                             invokeRestart(restart)
[17:38:15.227]                             muffled <- TRUE
[17:38:15.227]                             break
[17:38:15.227]                           }
[17:38:15.227]                         }
[17:38:15.227]                       }
[17:38:15.227]                       invisible(muffled)
[17:38:15.227]                     }
[17:38:15.227]                     muffleCondition(cond, pattern = "^muffle")
[17:38:15.227]                   }
[17:38:15.227]                 }
[17:38:15.227]             }
[17:38:15.227]         }))
[17:38:15.227]     }, error = function(ex) {
[17:38:15.227]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:15.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:15.227]                 ...future.rng), started = ...future.startTime, 
[17:38:15.227]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:15.227]             version = "1.8"), class = "FutureResult")
[17:38:15.227]     }, finally = {
[17:38:15.227]         if (!identical(...future.workdir, getwd())) 
[17:38:15.227]             setwd(...future.workdir)
[17:38:15.227]         {
[17:38:15.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:15.227]                 ...future.oldOptions$nwarnings <- NULL
[17:38:15.227]             }
[17:38:15.227]             base::options(...future.oldOptions)
[17:38:15.227]             if (.Platform$OS.type == "windows") {
[17:38:15.227]                 old_names <- names(...future.oldEnvVars)
[17:38:15.227]                 envs <- base::Sys.getenv()
[17:38:15.227]                 names <- names(envs)
[17:38:15.227]                 common <- intersect(names, old_names)
[17:38:15.227]                 added <- setdiff(names, old_names)
[17:38:15.227]                 removed <- setdiff(old_names, names)
[17:38:15.227]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:15.227]                   envs[common]]
[17:38:15.227]                 NAMES <- toupper(changed)
[17:38:15.227]                 args <- list()
[17:38:15.227]                 for (kk in seq_along(NAMES)) {
[17:38:15.227]                   name <- changed[[kk]]
[17:38:15.227]                   NAME <- NAMES[[kk]]
[17:38:15.227]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.227]                     next
[17:38:15.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:15.227]                 }
[17:38:15.227]                 NAMES <- toupper(added)
[17:38:15.227]                 for (kk in seq_along(NAMES)) {
[17:38:15.227]                   name <- added[[kk]]
[17:38:15.227]                   NAME <- NAMES[[kk]]
[17:38:15.227]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.227]                     next
[17:38:15.227]                   args[[name]] <- ""
[17:38:15.227]                 }
[17:38:15.227]                 NAMES <- toupper(removed)
[17:38:15.227]                 for (kk in seq_along(NAMES)) {
[17:38:15.227]                   name <- removed[[kk]]
[17:38:15.227]                   NAME <- NAMES[[kk]]
[17:38:15.227]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.227]                     next
[17:38:15.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:15.227]                 }
[17:38:15.227]                 if (length(args) > 0) 
[17:38:15.227]                   base::do.call(base::Sys.setenv, args = args)
[17:38:15.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:15.227]             }
[17:38:15.227]             else {
[17:38:15.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:15.227]             }
[17:38:15.227]             {
[17:38:15.227]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:15.227]                   0L) {
[17:38:15.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:15.227]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:15.227]                   base::options(opts)
[17:38:15.227]                 }
[17:38:15.227]                 {
[17:38:15.227]                   {
[17:38:15.227]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:15.227]                     NULL
[17:38:15.227]                   }
[17:38:15.227]                   options(future.plan = NULL)
[17:38:15.227]                   if (is.na(NA_character_)) 
[17:38:15.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:15.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:15.227]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:15.227]                     .init = FALSE)
[17:38:15.227]                 }
[17:38:15.227]             }
[17:38:15.227]         }
[17:38:15.227]     })
[17:38:15.227]     if (TRUE) {
[17:38:15.227]         base::sink(type = "output", split = FALSE)
[17:38:15.227]         if (TRUE) {
[17:38:15.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:15.227]         }
[17:38:15.227]         else {
[17:38:15.227]             ...future.result["stdout"] <- base::list(NULL)
[17:38:15.227]         }
[17:38:15.227]         base::close(...future.stdout)
[17:38:15.227]         ...future.stdout <- NULL
[17:38:15.227]     }
[17:38:15.227]     ...future.result$conditions <- ...future.conditions
[17:38:15.227]     ...future.result$finished <- base::Sys.time()
[17:38:15.227]     ...future.result
[17:38:15.227] }
[17:38:15.230] Exporting 11 global objects (91.99 KiB) to cluster node #2 ...
[17:38:15.230] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:38:15.273] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:38:15.273] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[17:38:15.273] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[17:38:15.274] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:38:15.274] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:38:15.274] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:38:15.317] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:38:15.317] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:38:15.361] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:38:15.361] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:38:15.361] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:38:15.361] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ...
[17:38:15.362] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ... DONE
[17:38:15.362] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:15.362] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:15.363] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ...
[17:38:15.363] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ... DONE
[17:38:15.363] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:15.363] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:15.364] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:15.364] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:15.364] Exporting 11 global objects (91.99 KiB) to cluster node #2 ... DONE
[17:38:15.365] MultisessionFuture started
[17:38:15.365] - Launch lazy future ... done
[17:38:15.365] run() for ‘MultisessionFuture’ ... done
[17:38:15.365] Created future:
[17:38:15.366] receiveMessageFromWorker() for ClusterFuture ...
[17:38:15.367] - Validating connection of MultisessionFuture
[17:38:15.367] - received message: FutureResult
[17:38:15.367] - Received FutureResult
[17:38:15.367] - Erased future from FutureRegistry
[17:38:15.367] result() for ClusterFuture ...
[17:38:15.367] - result already collected: FutureResult
[17:38:15.367] result() for ClusterFuture ... done
[17:38:15.367] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:15.365] MultisessionFuture:
[17:38:15.365] Label: ‘future_vapply-2’
[17:38:15.365] Expression:
[17:38:15.365] {
[17:38:15.365]     do.call(function(...) {
[17:38:15.365]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.365]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:15.365]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.365]             on.exit(options(oopts), add = TRUE)
[17:38:15.365]         }
[17:38:15.365]         {
[17:38:15.365]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:15.365]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.365]                 ...future.FUN(...future.X_jj, ...)
[17:38:15.365]             })
[17:38:15.365]         }
[17:38:15.365]     }, args = future.call.arguments)
[17:38:15.365] }
[17:38:15.365] Lazy evaluation: FALSE
[17:38:15.365] Asynchronous evaluation: TRUE
[17:38:15.365] Local evaluation: TRUE
[17:38:15.365] Environment: R_GlobalEnv
[17:38:15.365] Capture standard output: TRUE
[17:38:15.365] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:15.365] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:15.365] Packages: 1 packages (‘future.apply’)
[17:38:15.365] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:15.365] Resolved: TRUE
[17:38:15.365] Value: <not collected>
[17:38:15.365] Conditions captured: <none>
[17:38:15.365] Early signaling: FALSE
[17:38:15.365] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:15.365] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:15.368] Chunk #2 of 2 ... DONE
[17:38:15.368] Launching 2 futures (chunks) ... DONE
[17:38:15.368] Resolving 2 futures (chunks) ...
[17:38:15.368] resolve() on list ...
[17:38:15.368]  recursive: 0
[17:38:15.368]  length: 2
[17:38:15.368] 
[17:38:15.369] receiveMessageFromWorker() for ClusterFuture ...
[17:38:15.369] - Validating connection of MultisessionFuture
[17:38:15.369] - received message: FutureResult
[17:38:15.369] - Received FutureResult
[17:38:15.369] - Erased future from FutureRegistry
[17:38:15.369] result() for ClusterFuture ...
[17:38:15.370] - result already collected: FutureResult
[17:38:15.370] result() for ClusterFuture ... done
[17:38:15.370] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:15.370] Future #1
[17:38:15.370] result() for ClusterFuture ...
[17:38:15.370] - result already collected: FutureResult
[17:38:15.370] result() for ClusterFuture ... done
[17:38:15.370] result() for ClusterFuture ...
[17:38:15.370] - result already collected: FutureResult
[17:38:15.370] result() for ClusterFuture ... done
[17:38:15.370] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:15.371] - nx: 2
[17:38:15.371] - relay: TRUE
[17:38:15.371] - stdout: TRUE
[17:38:15.371] - signal: TRUE
[17:38:15.371] - resignal: FALSE
[17:38:15.371] - force: TRUE
[17:38:15.371] - relayed: [n=2] FALSE, FALSE
[17:38:15.371] - queued futures: [n=2] FALSE, FALSE
[17:38:15.371]  - until=1
[17:38:15.371]  - relaying element #1
[17:38:15.371] result() for ClusterFuture ...
[17:38:15.372] - result already collected: FutureResult
[17:38:15.372] result() for ClusterFuture ... done
[17:38:15.372] result() for ClusterFuture ...
[17:38:15.372] - result already collected: FutureResult
[17:38:15.372] result() for ClusterFuture ... done
[17:38:15.372] result() for ClusterFuture ...
[17:38:15.372] - result already collected: FutureResult
[17:38:15.372] result() for ClusterFuture ... done
[17:38:15.372] result() for ClusterFuture ...
[17:38:15.372] - result already collected: FutureResult
[17:38:15.372] result() for ClusterFuture ... done
[17:38:15.373] - relayed: [n=2] TRUE, FALSE
[17:38:15.373] - queued futures: [n=2] TRUE, FALSE
[17:38:15.373] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:15.373]  length: 1 (resolved future 1)
[17:38:15.373] Future #2
[17:38:15.373] result() for ClusterFuture ...
[17:38:15.373] - result already collected: FutureResult
[17:38:15.373] result() for ClusterFuture ... done
[17:38:15.373] result() for ClusterFuture ...
[17:38:15.373] - result already collected: FutureResult
[17:38:15.374] result() for ClusterFuture ... done
[17:38:15.374] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:15.374] - nx: 2
[17:38:15.374] - relay: TRUE
[17:38:15.374] - stdout: TRUE
[17:38:15.374] - signal: TRUE
[17:38:15.374] - resignal: FALSE
[17:38:15.374] - force: TRUE
[17:38:15.374] - relayed: [n=2] TRUE, FALSE
[17:38:15.374] - queued futures: [n=2] TRUE, FALSE
[17:38:15.374]  - until=2
[17:38:15.374]  - relaying element #2
[17:38:15.375] result() for ClusterFuture ...
[17:38:15.375] - result already collected: FutureResult
[17:38:15.375] result() for ClusterFuture ... done
[17:38:15.375] result() for ClusterFuture ...
[17:38:15.375] - result already collected: FutureResult
[17:38:15.375] result() for ClusterFuture ... done
[17:38:15.375] result() for ClusterFuture ...
[17:38:15.375] - result already collected: FutureResult
[17:38:15.375] result() for ClusterFuture ... done
[17:38:15.375] result() for ClusterFuture ...
[17:38:15.375] - result already collected: FutureResult
[17:38:15.376] result() for ClusterFuture ... done
[17:38:15.376] - relayed: [n=2] TRUE, TRUE
[17:38:15.376] - queued futures: [n=2] TRUE, TRUE
[17:38:15.376] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:15.376]  length: 0 (resolved future 2)
[17:38:15.376] Relaying remaining futures
[17:38:15.376] signalConditionsASAP(NULL, pos=0) ...
[17:38:15.376] - nx: 2
[17:38:15.376] - relay: TRUE
[17:38:15.376] - stdout: TRUE
[17:38:15.376] - signal: TRUE
[17:38:15.376] - resignal: FALSE
[17:38:15.377] - force: TRUE
[17:38:15.377] - relayed: [n=2] TRUE, TRUE
[17:38:15.377] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:15.377] - relayed: [n=2] TRUE, TRUE
[17:38:15.377] - queued futures: [n=2] TRUE, TRUE
[17:38:15.377] signalConditionsASAP(NULL, pos=0) ... done
[17:38:15.377] resolve() on list ... DONE
[17:38:15.377] result() for ClusterFuture ...
[17:38:15.377] - result already collected: FutureResult
[17:38:15.377] result() for ClusterFuture ... done
[17:38:15.377] result() for ClusterFuture ...
[17:38:15.378] - result already collected: FutureResult
[17:38:15.378] result() for ClusterFuture ... done
[17:38:15.378] result() for ClusterFuture ...
[17:38:15.378] - result already collected: FutureResult
[17:38:15.378] result() for ClusterFuture ... done
[17:38:15.378] result() for ClusterFuture ...
[17:38:15.378] - result already collected: FutureResult
[17:38:15.378] result() for ClusterFuture ... done
[17:38:15.378]  - Number of value chunks collected: 2
[17:38:15.378] Resolving 2 futures (chunks) ... DONE
[17:38:15.378] Reducing values from 2 chunks ...
[17:38:15.379]  - Number of values collected after concatenation: 11
[17:38:15.379]  - Number of values expected: 11
[17:38:15.379] Reducing values from 2 chunks ... DONE
[17:38:15.379] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[17:38:15.380] future_lapply() ...
[17:38:15.385] Number of chunks: 2
[17:38:15.385] getGlobalsAndPackagesXApply() ...
[17:38:15.385]  - future.globals: TRUE
[17:38:15.386] getGlobalsAndPackages() ...
[17:38:15.386] Searching for globals...
[17:38:15.389] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:15.389] Searching for globals ... DONE
[17:38:15.389] Resolving globals: FALSE
[17:38:15.390] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[17:38:15.390] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:15.390] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:15.390] - packages: [1] ‘future.apply’
[17:38:15.391] getGlobalsAndPackages() ... DONE
[17:38:15.391]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:15.391]  - needed namespaces: [n=1] ‘future.apply’
[17:38:15.391] Finding globals ... DONE
[17:38:15.391]  - use_args: TRUE
[17:38:15.391]  - Getting '...' globals ...
[17:38:15.391] resolve() on list ...
[17:38:15.391]  recursive: 0
[17:38:15.392]  length: 1
[17:38:15.392]  elements: ‘...’
[17:38:15.392]  length: 0 (resolved future 1)
[17:38:15.392] resolve() on list ... DONE
[17:38:15.392]    - '...' content: [n=0] 
[17:38:15.392] List of 1
[17:38:15.392]  $ ...: list()
[17:38:15.392]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:15.392]  - attr(*, "where")=List of 1
[17:38:15.392]   ..$ ...:<environment: 0x56080302bf48> 
[17:38:15.392]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:15.392]  - attr(*, "resolved")= logi TRUE
[17:38:15.392]  - attr(*, "total_size")= num NA
[17:38:15.395]  - Getting '...' globals ... DONE
[17:38:15.395] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:15.395] List of 8
[17:38:15.395]  $ ...future.FUN:function (x, ...)  
[17:38:15.395]  $ x_FUN        :function (x)  
[17:38:15.395]  $ times        : int 1
[17:38:15.395]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:15.395]  $ stop_if_not  :function (...)  
[17:38:15.395]  $ dim          : NULL
[17:38:15.395]  $ valid_types  : chr [1:2] "logical" "integer"
[17:38:15.395]  $ ...          : list()
[17:38:15.395]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:15.395]  - attr(*, "where")=List of 8
[17:38:15.395]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:15.395]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:15.395]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:15.395]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:15.395]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:15.395]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:15.395]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:15.395]   ..$ ...          :<environment: 0x56080302bf48> 
[17:38:15.395]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:15.395]  - attr(*, "resolved")= logi FALSE
[17:38:15.395]  - attr(*, "total_size")= num 94264
[17:38:15.400] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:15.400] getGlobalsAndPackagesXApply() ... DONE
[17:38:15.400] Number of futures (= number of chunks): 2
[17:38:15.401] Launching 2 futures (chunks) ...
[17:38:15.401] Chunk #1 of 2 ...
[17:38:15.401]  - Finding globals in 'X' for chunk #1 ...
[17:38:15.401] getGlobalsAndPackages() ...
[17:38:15.401] Searching for globals...
[17:38:15.401] 
[17:38:15.401] Searching for globals ... DONE
[17:38:15.401] - globals: [0] <none>
[17:38:15.401] getGlobalsAndPackages() ... DONE
[17:38:15.402]    + additional globals found: [n=0] 
[17:38:15.402]    + additional namespaces needed: [n=0] 
[17:38:15.402]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:15.402]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:15.402]  - seeds: <none>
[17:38:15.402]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.402] getGlobalsAndPackages() ...
[17:38:15.402] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.402] Resolving globals: FALSE
[17:38:15.402] Tweak future expression to call with '...' arguments ...
[17:38:15.403] {
[17:38:15.403]     do.call(function(...) {
[17:38:15.403]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.403]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:15.403]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.403]             on.exit(options(oopts), add = TRUE)
[17:38:15.403]         }
[17:38:15.403]         {
[17:38:15.403]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:15.403]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.403]                 ...future.FUN(...future.X_jj, ...)
[17:38:15.403]             })
[17:38:15.403]         }
[17:38:15.403]     }, args = future.call.arguments)
[17:38:15.403] }
[17:38:15.403] Tweak future expression to call with '...' arguments ... DONE
[17:38:15.403] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.403] - packages: [1] ‘future.apply’
[17:38:15.404] getGlobalsAndPackages() ... DONE
[17:38:15.404] run() for ‘Future’ ...
[17:38:15.404] - state: ‘created’
[17:38:15.404] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:15.418] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:15.418] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:15.419]   - Field: ‘node’
[17:38:15.419]   - Field: ‘label’
[17:38:15.419]   - Field: ‘local’
[17:38:15.419]   - Field: ‘owner’
[17:38:15.419]   - Field: ‘envir’
[17:38:15.419]   - Field: ‘workers’
[17:38:15.419]   - Field: ‘packages’
[17:38:15.419]   - Field: ‘gc’
[17:38:15.419]   - Field: ‘conditions’
[17:38:15.419]   - Field: ‘persistent’
[17:38:15.419]   - Field: ‘expr’
[17:38:15.420]   - Field: ‘uuid’
[17:38:15.420]   - Field: ‘seed’
[17:38:15.420]   - Field: ‘version’
[17:38:15.420]   - Field: ‘result’
[17:38:15.420]   - Field: ‘asynchronous’
[17:38:15.420]   - Field: ‘calls’
[17:38:15.420]   - Field: ‘globals’
[17:38:15.420]   - Field: ‘stdout’
[17:38:15.420]   - Field: ‘earlySignal’
[17:38:15.420]   - Field: ‘lazy’
[17:38:15.420]   - Field: ‘state’
[17:38:15.421] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:15.421] - Launch lazy future ...
[17:38:15.421] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:15.421] Packages needed by future strategies (n = 0): <none>
[17:38:15.422] {
[17:38:15.422]     {
[17:38:15.422]         {
[17:38:15.422]             ...future.startTime <- base::Sys.time()
[17:38:15.422]             {
[17:38:15.422]                 {
[17:38:15.422]                   {
[17:38:15.422]                     {
[17:38:15.422]                       {
[17:38:15.422]                         base::local({
[17:38:15.422]                           has_future <- base::requireNamespace("future", 
[17:38:15.422]                             quietly = TRUE)
[17:38:15.422]                           if (has_future) {
[17:38:15.422]                             ns <- base::getNamespace("future")
[17:38:15.422]                             version <- ns[[".package"]][["version"]]
[17:38:15.422]                             if (is.null(version)) 
[17:38:15.422]                               version <- utils::packageVersion("future")
[17:38:15.422]                           }
[17:38:15.422]                           else {
[17:38:15.422]                             version <- NULL
[17:38:15.422]                           }
[17:38:15.422]                           if (!has_future || version < "1.8.0") {
[17:38:15.422]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:15.422]                               "", base::R.version$version.string), 
[17:38:15.422]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:15.422]                                 base::R.version$platform, 8 * 
[17:38:15.422]                                   base::.Machine$sizeof.pointer), 
[17:38:15.422]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:15.422]                                 "release", "version")], collapse = " "), 
[17:38:15.422]                               hostname = base::Sys.info()[["nodename"]])
[17:38:15.422]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:15.422]                               info)
[17:38:15.422]                             info <- base::paste(info, collapse = "; ")
[17:38:15.422]                             if (!has_future) {
[17:38:15.422]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:15.422]                                 info)
[17:38:15.422]                             }
[17:38:15.422]                             else {
[17:38:15.422]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:15.422]                                 info, version)
[17:38:15.422]                             }
[17:38:15.422]                             base::stop(msg)
[17:38:15.422]                           }
[17:38:15.422]                         })
[17:38:15.422]                       }
[17:38:15.422]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:15.422]                       base::options(mc.cores = 1L)
[17:38:15.422]                     }
[17:38:15.422]                     base::local({
[17:38:15.422]                       for (pkg in "future.apply") {
[17:38:15.422]                         base::loadNamespace(pkg)
[17:38:15.422]                         base::library(pkg, character.only = TRUE)
[17:38:15.422]                       }
[17:38:15.422]                     })
[17:38:15.422]                   }
[17:38:15.422]                   ...future.strategy.old <- future::plan("list")
[17:38:15.422]                   options(future.plan = NULL)
[17:38:15.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:15.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:15.422]                 }
[17:38:15.422]                 ...future.workdir <- getwd()
[17:38:15.422]             }
[17:38:15.422]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:15.422]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:15.422]         }
[17:38:15.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:15.422]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:15.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:15.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:15.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:15.422]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:15.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:15.422]             base::names(...future.oldOptions))
[17:38:15.422]     }
[17:38:15.422]     if (FALSE) {
[17:38:15.422]     }
[17:38:15.422]     else {
[17:38:15.422]         if (TRUE) {
[17:38:15.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:15.422]                 open = "w")
[17:38:15.422]         }
[17:38:15.422]         else {
[17:38:15.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:15.422]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:15.422]         }
[17:38:15.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:15.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:15.422]             base::sink(type = "output", split = FALSE)
[17:38:15.422]             base::close(...future.stdout)
[17:38:15.422]         }, add = TRUE)
[17:38:15.422]     }
[17:38:15.422]     ...future.frame <- base::sys.nframe()
[17:38:15.422]     ...future.conditions <- base::list()
[17:38:15.422]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:15.422]     if (FALSE) {
[17:38:15.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:15.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:15.422]     }
[17:38:15.422]     ...future.result <- base::tryCatch({
[17:38:15.422]         base::withCallingHandlers({
[17:38:15.422]             ...future.value <- base::withVisible(base::local({
[17:38:15.422]                 ...future.makeSendCondition <- base::local({
[17:38:15.422]                   sendCondition <- NULL
[17:38:15.422]                   function(frame = 1L) {
[17:38:15.422]                     if (is.function(sendCondition)) 
[17:38:15.422]                       return(sendCondition)
[17:38:15.422]                     ns <- getNamespace("parallel")
[17:38:15.422]                     if (exists("sendData", mode = "function", 
[17:38:15.422]                       envir = ns)) {
[17:38:15.422]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:15.422]                         envir = ns)
[17:38:15.422]                       envir <- sys.frame(frame)
[17:38:15.422]                       master <- NULL
[17:38:15.422]                       while (!identical(envir, .GlobalEnv) && 
[17:38:15.422]                         !identical(envir, emptyenv())) {
[17:38:15.422]                         if (exists("master", mode = "list", envir = envir, 
[17:38:15.422]                           inherits = FALSE)) {
[17:38:15.422]                           master <- get("master", mode = "list", 
[17:38:15.422]                             envir = envir, inherits = FALSE)
[17:38:15.422]                           if (inherits(master, c("SOCKnode", 
[17:38:15.422]                             "SOCK0node"))) {
[17:38:15.422]                             sendCondition <<- function(cond) {
[17:38:15.422]                               data <- list(type = "VALUE", value = cond, 
[17:38:15.422]                                 success = TRUE)
[17:38:15.422]                               parallel_sendData(master, data)
[17:38:15.422]                             }
[17:38:15.422]                             return(sendCondition)
[17:38:15.422]                           }
[17:38:15.422]                         }
[17:38:15.422]                         frame <- frame + 1L
[17:38:15.422]                         envir <- sys.frame(frame)
[17:38:15.422]                       }
[17:38:15.422]                     }
[17:38:15.422]                     sendCondition <<- function(cond) NULL
[17:38:15.422]                   }
[17:38:15.422]                 })
[17:38:15.422]                 withCallingHandlers({
[17:38:15.422]                   {
[17:38:15.422]                     do.call(function(...) {
[17:38:15.422]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.422]                       if (!identical(...future.globals.maxSize.org, 
[17:38:15.422]                         ...future.globals.maxSize)) {
[17:38:15.422]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.422]                         on.exit(options(oopts), add = TRUE)
[17:38:15.422]                       }
[17:38:15.422]                       {
[17:38:15.422]                         lapply(seq_along(...future.elements_ii), 
[17:38:15.422]                           FUN = function(jj) {
[17:38:15.422]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.422]                             ...future.FUN(...future.X_jj, ...)
[17:38:15.422]                           })
[17:38:15.422]                       }
[17:38:15.422]                     }, args = future.call.arguments)
[17:38:15.422]                   }
[17:38:15.422]                 }, immediateCondition = function(cond) {
[17:38:15.422]                   sendCondition <- ...future.makeSendCondition()
[17:38:15.422]                   sendCondition(cond)
[17:38:15.422]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.422]                   {
[17:38:15.422]                     inherits <- base::inherits
[17:38:15.422]                     invokeRestart <- base::invokeRestart
[17:38:15.422]                     is.null <- base::is.null
[17:38:15.422]                     muffled <- FALSE
[17:38:15.422]                     if (inherits(cond, "message")) {
[17:38:15.422]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:15.422]                       if (muffled) 
[17:38:15.422]                         invokeRestart("muffleMessage")
[17:38:15.422]                     }
[17:38:15.422]                     else if (inherits(cond, "warning")) {
[17:38:15.422]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:15.422]                       if (muffled) 
[17:38:15.422]                         invokeRestart("muffleWarning")
[17:38:15.422]                     }
[17:38:15.422]                     else if (inherits(cond, "condition")) {
[17:38:15.422]                       if (!is.null(pattern)) {
[17:38:15.422]                         computeRestarts <- base::computeRestarts
[17:38:15.422]                         grepl <- base::grepl
[17:38:15.422]                         restarts <- computeRestarts(cond)
[17:38:15.422]                         for (restart in restarts) {
[17:38:15.422]                           name <- restart$name
[17:38:15.422]                           if (is.null(name)) 
[17:38:15.422]                             next
[17:38:15.422]                           if (!grepl(pattern, name)) 
[17:38:15.422]                             next
[17:38:15.422]                           invokeRestart(restart)
[17:38:15.422]                           muffled <- TRUE
[17:38:15.422]                           break
[17:38:15.422]                         }
[17:38:15.422]                       }
[17:38:15.422]                     }
[17:38:15.422]                     invisible(muffled)
[17:38:15.422]                   }
[17:38:15.422]                   muffleCondition(cond)
[17:38:15.422]                 })
[17:38:15.422]             }))
[17:38:15.422]             future::FutureResult(value = ...future.value$value, 
[17:38:15.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:15.422]                   ...future.rng), globalenv = if (FALSE) 
[17:38:15.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:15.422]                     ...future.globalenv.names))
[17:38:15.422]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:15.422]         }, condition = base::local({
[17:38:15.422]             c <- base::c
[17:38:15.422]             inherits <- base::inherits
[17:38:15.422]             invokeRestart <- base::invokeRestart
[17:38:15.422]             length <- base::length
[17:38:15.422]             list <- base::list
[17:38:15.422]             seq.int <- base::seq.int
[17:38:15.422]             signalCondition <- base::signalCondition
[17:38:15.422]             sys.calls <- base::sys.calls
[17:38:15.422]             `[[` <- base::`[[`
[17:38:15.422]             `+` <- base::`+`
[17:38:15.422]             `<<-` <- base::`<<-`
[17:38:15.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:15.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:15.422]                   3L)]
[17:38:15.422]             }
[17:38:15.422]             function(cond) {
[17:38:15.422]                 is_error <- inherits(cond, "error")
[17:38:15.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:15.422]                   NULL)
[17:38:15.422]                 if (is_error) {
[17:38:15.422]                   sessionInformation <- function() {
[17:38:15.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:15.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:15.422]                       search = base::search(), system = base::Sys.info())
[17:38:15.422]                   }
[17:38:15.422]                   ...future.conditions[[length(...future.conditions) + 
[17:38:15.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:15.422]                     cond$call), session = sessionInformation(), 
[17:38:15.422]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:15.422]                   signalCondition(cond)
[17:38:15.422]                 }
[17:38:15.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:15.422]                 "immediateCondition"))) {
[17:38:15.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:15.422]                   ...future.conditions[[length(...future.conditions) + 
[17:38:15.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:15.422]                   if (TRUE && !signal) {
[17:38:15.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.422]                     {
[17:38:15.422]                       inherits <- base::inherits
[17:38:15.422]                       invokeRestart <- base::invokeRestart
[17:38:15.422]                       is.null <- base::is.null
[17:38:15.422]                       muffled <- FALSE
[17:38:15.422]                       if (inherits(cond, "message")) {
[17:38:15.422]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:15.422]                         if (muffled) 
[17:38:15.422]                           invokeRestart("muffleMessage")
[17:38:15.422]                       }
[17:38:15.422]                       else if (inherits(cond, "warning")) {
[17:38:15.422]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:15.422]                         if (muffled) 
[17:38:15.422]                           invokeRestart("muffleWarning")
[17:38:15.422]                       }
[17:38:15.422]                       else if (inherits(cond, "condition")) {
[17:38:15.422]                         if (!is.null(pattern)) {
[17:38:15.422]                           computeRestarts <- base::computeRestarts
[17:38:15.422]                           grepl <- base::grepl
[17:38:15.422]                           restarts <- computeRestarts(cond)
[17:38:15.422]                           for (restart in restarts) {
[17:38:15.422]                             name <- restart$name
[17:38:15.422]                             if (is.null(name)) 
[17:38:15.422]                               next
[17:38:15.422]                             if (!grepl(pattern, name)) 
[17:38:15.422]                               next
[17:38:15.422]                             invokeRestart(restart)
[17:38:15.422]                             muffled <- TRUE
[17:38:15.422]                             break
[17:38:15.422]                           }
[17:38:15.422]                         }
[17:38:15.422]                       }
[17:38:15.422]                       invisible(muffled)
[17:38:15.422]                     }
[17:38:15.422]                     muffleCondition(cond, pattern = "^muffle")
[17:38:15.422]                   }
[17:38:15.422]                 }
[17:38:15.422]                 else {
[17:38:15.422]                   if (TRUE) {
[17:38:15.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.422]                     {
[17:38:15.422]                       inherits <- base::inherits
[17:38:15.422]                       invokeRestart <- base::invokeRestart
[17:38:15.422]                       is.null <- base::is.null
[17:38:15.422]                       muffled <- FALSE
[17:38:15.422]                       if (inherits(cond, "message")) {
[17:38:15.422]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:15.422]                         if (muffled) 
[17:38:15.422]                           invokeRestart("muffleMessage")
[17:38:15.422]                       }
[17:38:15.422]                       else if (inherits(cond, "warning")) {
[17:38:15.422]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:15.422]                         if (muffled) 
[17:38:15.422]                           invokeRestart("muffleWarning")
[17:38:15.422]                       }
[17:38:15.422]                       else if (inherits(cond, "condition")) {
[17:38:15.422]                         if (!is.null(pattern)) {
[17:38:15.422]                           computeRestarts <- base::computeRestarts
[17:38:15.422]                           grepl <- base::grepl
[17:38:15.422]                           restarts <- computeRestarts(cond)
[17:38:15.422]                           for (restart in restarts) {
[17:38:15.422]                             name <- restart$name
[17:38:15.422]                             if (is.null(name)) 
[17:38:15.422]                               next
[17:38:15.422]                             if (!grepl(pattern, name)) 
[17:38:15.422]                               next
[17:38:15.422]                             invokeRestart(restart)
[17:38:15.422]                             muffled <- TRUE
[17:38:15.422]                             break
[17:38:15.422]                           }
[17:38:15.422]                         }
[17:38:15.422]                       }
[17:38:15.422]                       invisible(muffled)
[17:38:15.422]                     }
[17:38:15.422]                     muffleCondition(cond, pattern = "^muffle")
[17:38:15.422]                   }
[17:38:15.422]                 }
[17:38:15.422]             }
[17:38:15.422]         }))
[17:38:15.422]     }, error = function(ex) {
[17:38:15.422]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:15.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:15.422]                 ...future.rng), started = ...future.startTime, 
[17:38:15.422]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:15.422]             version = "1.8"), class = "FutureResult")
[17:38:15.422]     }, finally = {
[17:38:15.422]         if (!identical(...future.workdir, getwd())) 
[17:38:15.422]             setwd(...future.workdir)
[17:38:15.422]         {
[17:38:15.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:15.422]                 ...future.oldOptions$nwarnings <- NULL
[17:38:15.422]             }
[17:38:15.422]             base::options(...future.oldOptions)
[17:38:15.422]             if (.Platform$OS.type == "windows") {
[17:38:15.422]                 old_names <- names(...future.oldEnvVars)
[17:38:15.422]                 envs <- base::Sys.getenv()
[17:38:15.422]                 names <- names(envs)
[17:38:15.422]                 common <- intersect(names, old_names)
[17:38:15.422]                 added <- setdiff(names, old_names)
[17:38:15.422]                 removed <- setdiff(old_names, names)
[17:38:15.422]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:15.422]                   envs[common]]
[17:38:15.422]                 NAMES <- toupper(changed)
[17:38:15.422]                 args <- list()
[17:38:15.422]                 for (kk in seq_along(NAMES)) {
[17:38:15.422]                   name <- changed[[kk]]
[17:38:15.422]                   NAME <- NAMES[[kk]]
[17:38:15.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.422]                     next
[17:38:15.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:15.422]                 }
[17:38:15.422]                 NAMES <- toupper(added)
[17:38:15.422]                 for (kk in seq_along(NAMES)) {
[17:38:15.422]                   name <- added[[kk]]
[17:38:15.422]                   NAME <- NAMES[[kk]]
[17:38:15.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.422]                     next
[17:38:15.422]                   args[[name]] <- ""
[17:38:15.422]                 }
[17:38:15.422]                 NAMES <- toupper(removed)
[17:38:15.422]                 for (kk in seq_along(NAMES)) {
[17:38:15.422]                   name <- removed[[kk]]
[17:38:15.422]                   NAME <- NAMES[[kk]]
[17:38:15.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.422]                     next
[17:38:15.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:15.422]                 }
[17:38:15.422]                 if (length(args) > 0) 
[17:38:15.422]                   base::do.call(base::Sys.setenv, args = args)
[17:38:15.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:15.422]             }
[17:38:15.422]             else {
[17:38:15.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:15.422]             }
[17:38:15.422]             {
[17:38:15.422]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:15.422]                   0L) {
[17:38:15.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:15.422]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:15.422]                   base::options(opts)
[17:38:15.422]                 }
[17:38:15.422]                 {
[17:38:15.422]                   {
[17:38:15.422]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:15.422]                     NULL
[17:38:15.422]                   }
[17:38:15.422]                   options(future.plan = NULL)
[17:38:15.422]                   if (is.na(NA_character_)) 
[17:38:15.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:15.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:15.422]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:15.422]                     .init = FALSE)
[17:38:15.422]                 }
[17:38:15.422]             }
[17:38:15.422]         }
[17:38:15.422]     })
[17:38:15.422]     if (TRUE) {
[17:38:15.422]         base::sink(type = "output", split = FALSE)
[17:38:15.422]         if (TRUE) {
[17:38:15.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:15.422]         }
[17:38:15.422]         else {
[17:38:15.422]             ...future.result["stdout"] <- base::list(NULL)
[17:38:15.422]         }
[17:38:15.422]         base::close(...future.stdout)
[17:38:15.422]         ...future.stdout <- NULL
[17:38:15.422]     }
[17:38:15.422]     ...future.result$conditions <- ...future.conditions
[17:38:15.422]     ...future.result$finished <- base::Sys.time()
[17:38:15.422]     ...future.result
[17:38:15.422] }
[17:38:15.424] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[17:38:15.425] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:38:15.469] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:38:15.469] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:38:15.470] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:38:15.470] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:38:15.470] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:38:15.470] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:38:15.513] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:38:15.513] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:38:15.557] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:38:15.557] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:38:15.557] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:38:15.558] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[17:38:15.558] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[17:38:15.558] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:15.559] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:15.559] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:38:15.559] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:38:15.559] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:15.560] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:15.560] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:15.562] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:15.563] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[17:38:15.563] MultisessionFuture started
[17:38:15.563] - Launch lazy future ... done
[17:38:15.564] run() for ‘MultisessionFuture’ ... done
[17:38:15.564] Created future:
[17:38:15.564] MultisessionFuture:
[17:38:15.564] Label: ‘future_vapply-1’
[17:38:15.564] Expression:
[17:38:15.564] {
[17:38:15.564]     do.call(function(...) {
[17:38:15.564]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.564]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:15.564]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.564]             on.exit(options(oopts), add = TRUE)
[17:38:15.564]         }
[17:38:15.564]         {
[17:38:15.564]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:15.564]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.564]                 ...future.FUN(...future.X_jj, ...)
[17:38:15.564]             })
[17:38:15.564]         }
[17:38:15.564]     }, args = future.call.arguments)
[17:38:15.564] }
[17:38:15.564] Lazy evaluation: FALSE
[17:38:15.564] Asynchronous evaluation: TRUE
[17:38:15.564] Local evaluation: TRUE
[17:38:15.564] Environment: R_GlobalEnv
[17:38:15.564] Capture standard output: TRUE
[17:38:15.564] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:15.564] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:15.564] Packages: 1 packages (‘future.apply’)
[17:38:15.564] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:15.564] Resolved: FALSE
[17:38:15.564] Value: <not collected>
[17:38:15.564] Conditions captured: <none>
[17:38:15.564] Early signaling: FALSE
[17:38:15.564] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:15.564] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:15.576] Chunk #1 of 2 ... DONE
[17:38:15.576] Chunk #2 of 2 ...
[17:38:15.576]  - Finding globals in 'X' for chunk #2 ...
[17:38:15.576] getGlobalsAndPackages() ...
[17:38:15.576] Searching for globals...
[17:38:15.577] 
[17:38:15.577] Searching for globals ... DONE
[17:38:15.577] - globals: [0] <none>
[17:38:15.577] getGlobalsAndPackages() ... DONE
[17:38:15.577]    + additional globals found: [n=0] 
[17:38:15.577]    + additional namespaces needed: [n=0] 
[17:38:15.577]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:15.577]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:15.577]  - seeds: <none>
[17:38:15.577]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.578] getGlobalsAndPackages() ...
[17:38:15.578] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.578] Resolving globals: FALSE
[17:38:15.578] Tweak future expression to call with '...' arguments ...
[17:38:15.578] {
[17:38:15.578]     do.call(function(...) {
[17:38:15.578]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.578]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:15.578]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.578]             on.exit(options(oopts), add = TRUE)
[17:38:15.578]         }
[17:38:15.578]         {
[17:38:15.578]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:15.578]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.578]                 ...future.FUN(...future.X_jj, ...)
[17:38:15.578]             })
[17:38:15.578]         }
[17:38:15.578]     }, args = future.call.arguments)
[17:38:15.578] }
[17:38:15.578] Tweak future expression to call with '...' arguments ... DONE
[17:38:15.579] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.579] - packages: [1] ‘future.apply’
[17:38:15.579] getGlobalsAndPackages() ... DONE
[17:38:15.579] run() for ‘Future’ ...
[17:38:15.579] - state: ‘created’
[17:38:15.580] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:15.594] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:15.594] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:15.594]   - Field: ‘node’
[17:38:15.594]   - Field: ‘label’
[17:38:15.595]   - Field: ‘local’
[17:38:15.595]   - Field: ‘owner’
[17:38:15.595]   - Field: ‘envir’
[17:38:15.595]   - Field: ‘workers’
[17:38:15.595]   - Field: ‘packages’
[17:38:15.595]   - Field: ‘gc’
[17:38:15.595]   - Field: ‘conditions’
[17:38:15.595]   - Field: ‘persistent’
[17:38:15.595]   - Field: ‘expr’
[17:38:15.595]   - Field: ‘uuid’
[17:38:15.596]   - Field: ‘seed’
[17:38:15.596]   - Field: ‘version’
[17:38:15.596]   - Field: ‘result’
[17:38:15.596]   - Field: ‘asynchronous’
[17:38:15.596]   - Field: ‘calls’
[17:38:15.596]   - Field: ‘globals’
[17:38:15.596]   - Field: ‘stdout’
[17:38:15.596]   - Field: ‘earlySignal’
[17:38:15.596]   - Field: ‘lazy’
[17:38:15.596]   - Field: ‘state’
[17:38:15.596] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:15.597] - Launch lazy future ...
[17:38:15.597] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:15.597] Packages needed by future strategies (n = 0): <none>
[17:38:15.598] {
[17:38:15.598]     {
[17:38:15.598]         {
[17:38:15.598]             ...future.startTime <- base::Sys.time()
[17:38:15.598]             {
[17:38:15.598]                 {
[17:38:15.598]                   {
[17:38:15.598]                     {
[17:38:15.598]                       {
[17:38:15.598]                         base::local({
[17:38:15.598]                           has_future <- base::requireNamespace("future", 
[17:38:15.598]                             quietly = TRUE)
[17:38:15.598]                           if (has_future) {
[17:38:15.598]                             ns <- base::getNamespace("future")
[17:38:15.598]                             version <- ns[[".package"]][["version"]]
[17:38:15.598]                             if (is.null(version)) 
[17:38:15.598]                               version <- utils::packageVersion("future")
[17:38:15.598]                           }
[17:38:15.598]                           else {
[17:38:15.598]                             version <- NULL
[17:38:15.598]                           }
[17:38:15.598]                           if (!has_future || version < "1.8.0") {
[17:38:15.598]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:15.598]                               "", base::R.version$version.string), 
[17:38:15.598]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:15.598]                                 base::R.version$platform, 8 * 
[17:38:15.598]                                   base::.Machine$sizeof.pointer), 
[17:38:15.598]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:15.598]                                 "release", "version")], collapse = " "), 
[17:38:15.598]                               hostname = base::Sys.info()[["nodename"]])
[17:38:15.598]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:15.598]                               info)
[17:38:15.598]                             info <- base::paste(info, collapse = "; ")
[17:38:15.598]                             if (!has_future) {
[17:38:15.598]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:15.598]                                 info)
[17:38:15.598]                             }
[17:38:15.598]                             else {
[17:38:15.598]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:15.598]                                 info, version)
[17:38:15.598]                             }
[17:38:15.598]                             base::stop(msg)
[17:38:15.598]                           }
[17:38:15.598]                         })
[17:38:15.598]                       }
[17:38:15.598]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:15.598]                       base::options(mc.cores = 1L)
[17:38:15.598]                     }
[17:38:15.598]                     base::local({
[17:38:15.598]                       for (pkg in "future.apply") {
[17:38:15.598]                         base::loadNamespace(pkg)
[17:38:15.598]                         base::library(pkg, character.only = TRUE)
[17:38:15.598]                       }
[17:38:15.598]                     })
[17:38:15.598]                   }
[17:38:15.598]                   ...future.strategy.old <- future::plan("list")
[17:38:15.598]                   options(future.plan = NULL)
[17:38:15.598]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:15.598]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:15.598]                 }
[17:38:15.598]                 ...future.workdir <- getwd()
[17:38:15.598]             }
[17:38:15.598]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:15.598]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:15.598]         }
[17:38:15.598]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:15.598]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:15.598]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:15.598]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:15.598]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:15.598]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:15.598]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:15.598]             base::names(...future.oldOptions))
[17:38:15.598]     }
[17:38:15.598]     if (FALSE) {
[17:38:15.598]     }
[17:38:15.598]     else {
[17:38:15.598]         if (TRUE) {
[17:38:15.598]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:15.598]                 open = "w")
[17:38:15.598]         }
[17:38:15.598]         else {
[17:38:15.598]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:15.598]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:15.598]         }
[17:38:15.598]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:15.598]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:15.598]             base::sink(type = "output", split = FALSE)
[17:38:15.598]             base::close(...future.stdout)
[17:38:15.598]         }, add = TRUE)
[17:38:15.598]     }
[17:38:15.598]     ...future.frame <- base::sys.nframe()
[17:38:15.598]     ...future.conditions <- base::list()
[17:38:15.598]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:15.598]     if (FALSE) {
[17:38:15.598]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:15.598]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:15.598]     }
[17:38:15.598]     ...future.result <- base::tryCatch({
[17:38:15.598]         base::withCallingHandlers({
[17:38:15.598]             ...future.value <- base::withVisible(base::local({
[17:38:15.598]                 ...future.makeSendCondition <- base::local({
[17:38:15.598]                   sendCondition <- NULL
[17:38:15.598]                   function(frame = 1L) {
[17:38:15.598]                     if (is.function(sendCondition)) 
[17:38:15.598]                       return(sendCondition)
[17:38:15.598]                     ns <- getNamespace("parallel")
[17:38:15.598]                     if (exists("sendData", mode = "function", 
[17:38:15.598]                       envir = ns)) {
[17:38:15.598]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:15.598]                         envir = ns)
[17:38:15.598]                       envir <- sys.frame(frame)
[17:38:15.598]                       master <- NULL
[17:38:15.598]                       while (!identical(envir, .GlobalEnv) && 
[17:38:15.598]                         !identical(envir, emptyenv())) {
[17:38:15.598]                         if (exists("master", mode = "list", envir = envir, 
[17:38:15.598]                           inherits = FALSE)) {
[17:38:15.598]                           master <- get("master", mode = "list", 
[17:38:15.598]                             envir = envir, inherits = FALSE)
[17:38:15.598]                           if (inherits(master, c("SOCKnode", 
[17:38:15.598]                             "SOCK0node"))) {
[17:38:15.598]                             sendCondition <<- function(cond) {
[17:38:15.598]                               data <- list(type = "VALUE", value = cond, 
[17:38:15.598]                                 success = TRUE)
[17:38:15.598]                               parallel_sendData(master, data)
[17:38:15.598]                             }
[17:38:15.598]                             return(sendCondition)
[17:38:15.598]                           }
[17:38:15.598]                         }
[17:38:15.598]                         frame <- frame + 1L
[17:38:15.598]                         envir <- sys.frame(frame)
[17:38:15.598]                       }
[17:38:15.598]                     }
[17:38:15.598]                     sendCondition <<- function(cond) NULL
[17:38:15.598]                   }
[17:38:15.598]                 })
[17:38:15.598]                 withCallingHandlers({
[17:38:15.598]                   {
[17:38:15.598]                     do.call(function(...) {
[17:38:15.598]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.598]                       if (!identical(...future.globals.maxSize.org, 
[17:38:15.598]                         ...future.globals.maxSize)) {
[17:38:15.598]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.598]                         on.exit(options(oopts), add = TRUE)
[17:38:15.598]                       }
[17:38:15.598]                       {
[17:38:15.598]                         lapply(seq_along(...future.elements_ii), 
[17:38:15.598]                           FUN = function(jj) {
[17:38:15.598]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.598]                             ...future.FUN(...future.X_jj, ...)
[17:38:15.598]                           })
[17:38:15.598]                       }
[17:38:15.598]                     }, args = future.call.arguments)
[17:38:15.598]                   }
[17:38:15.598]                 }, immediateCondition = function(cond) {
[17:38:15.598]                   sendCondition <- ...future.makeSendCondition()
[17:38:15.598]                   sendCondition(cond)
[17:38:15.598]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.598]                   {
[17:38:15.598]                     inherits <- base::inherits
[17:38:15.598]                     invokeRestart <- base::invokeRestart
[17:38:15.598]                     is.null <- base::is.null
[17:38:15.598]                     muffled <- FALSE
[17:38:15.598]                     if (inherits(cond, "message")) {
[17:38:15.598]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:15.598]                       if (muffled) 
[17:38:15.598]                         invokeRestart("muffleMessage")
[17:38:15.598]                     }
[17:38:15.598]                     else if (inherits(cond, "warning")) {
[17:38:15.598]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:15.598]                       if (muffled) 
[17:38:15.598]                         invokeRestart("muffleWarning")
[17:38:15.598]                     }
[17:38:15.598]                     else if (inherits(cond, "condition")) {
[17:38:15.598]                       if (!is.null(pattern)) {
[17:38:15.598]                         computeRestarts <- base::computeRestarts
[17:38:15.598]                         grepl <- base::grepl
[17:38:15.598]                         restarts <- computeRestarts(cond)
[17:38:15.598]                         for (restart in restarts) {
[17:38:15.598]                           name <- restart$name
[17:38:15.598]                           if (is.null(name)) 
[17:38:15.598]                             next
[17:38:15.598]                           if (!grepl(pattern, name)) 
[17:38:15.598]                             next
[17:38:15.598]                           invokeRestart(restart)
[17:38:15.598]                           muffled <- TRUE
[17:38:15.598]                           break
[17:38:15.598]                         }
[17:38:15.598]                       }
[17:38:15.598]                     }
[17:38:15.598]                     invisible(muffled)
[17:38:15.598]                   }
[17:38:15.598]                   muffleCondition(cond)
[17:38:15.598]                 })
[17:38:15.598]             }))
[17:38:15.598]             future::FutureResult(value = ...future.value$value, 
[17:38:15.598]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:15.598]                   ...future.rng), globalenv = if (FALSE) 
[17:38:15.598]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:15.598]                     ...future.globalenv.names))
[17:38:15.598]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:15.598]         }, condition = base::local({
[17:38:15.598]             c <- base::c
[17:38:15.598]             inherits <- base::inherits
[17:38:15.598]             invokeRestart <- base::invokeRestart
[17:38:15.598]             length <- base::length
[17:38:15.598]             list <- base::list
[17:38:15.598]             seq.int <- base::seq.int
[17:38:15.598]             signalCondition <- base::signalCondition
[17:38:15.598]             sys.calls <- base::sys.calls
[17:38:15.598]             `[[` <- base::`[[`
[17:38:15.598]             `+` <- base::`+`
[17:38:15.598]             `<<-` <- base::`<<-`
[17:38:15.598]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:15.598]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:15.598]                   3L)]
[17:38:15.598]             }
[17:38:15.598]             function(cond) {
[17:38:15.598]                 is_error <- inherits(cond, "error")
[17:38:15.598]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:15.598]                   NULL)
[17:38:15.598]                 if (is_error) {
[17:38:15.598]                   sessionInformation <- function() {
[17:38:15.598]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:15.598]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:15.598]                       search = base::search(), system = base::Sys.info())
[17:38:15.598]                   }
[17:38:15.598]                   ...future.conditions[[length(...future.conditions) + 
[17:38:15.598]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:15.598]                     cond$call), session = sessionInformation(), 
[17:38:15.598]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:15.598]                   signalCondition(cond)
[17:38:15.598]                 }
[17:38:15.598]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:15.598]                 "immediateCondition"))) {
[17:38:15.598]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:15.598]                   ...future.conditions[[length(...future.conditions) + 
[17:38:15.598]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:15.598]                   if (TRUE && !signal) {
[17:38:15.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.598]                     {
[17:38:15.598]                       inherits <- base::inherits
[17:38:15.598]                       invokeRestart <- base::invokeRestart
[17:38:15.598]                       is.null <- base::is.null
[17:38:15.598]                       muffled <- FALSE
[17:38:15.598]                       if (inherits(cond, "message")) {
[17:38:15.598]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:15.598]                         if (muffled) 
[17:38:15.598]                           invokeRestart("muffleMessage")
[17:38:15.598]                       }
[17:38:15.598]                       else if (inherits(cond, "warning")) {
[17:38:15.598]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:15.598]                         if (muffled) 
[17:38:15.598]                           invokeRestart("muffleWarning")
[17:38:15.598]                       }
[17:38:15.598]                       else if (inherits(cond, "condition")) {
[17:38:15.598]                         if (!is.null(pattern)) {
[17:38:15.598]                           computeRestarts <- base::computeRestarts
[17:38:15.598]                           grepl <- base::grepl
[17:38:15.598]                           restarts <- computeRestarts(cond)
[17:38:15.598]                           for (restart in restarts) {
[17:38:15.598]                             name <- restart$name
[17:38:15.598]                             if (is.null(name)) 
[17:38:15.598]                               next
[17:38:15.598]                             if (!grepl(pattern, name)) 
[17:38:15.598]                               next
[17:38:15.598]                             invokeRestart(restart)
[17:38:15.598]                             muffled <- TRUE
[17:38:15.598]                             break
[17:38:15.598]                           }
[17:38:15.598]                         }
[17:38:15.598]                       }
[17:38:15.598]                       invisible(muffled)
[17:38:15.598]                     }
[17:38:15.598]                     muffleCondition(cond, pattern = "^muffle")
[17:38:15.598]                   }
[17:38:15.598]                 }
[17:38:15.598]                 else {
[17:38:15.598]                   if (TRUE) {
[17:38:15.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.598]                     {
[17:38:15.598]                       inherits <- base::inherits
[17:38:15.598]                       invokeRestart <- base::invokeRestart
[17:38:15.598]                       is.null <- base::is.null
[17:38:15.598]                       muffled <- FALSE
[17:38:15.598]                       if (inherits(cond, "message")) {
[17:38:15.598]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:15.598]                         if (muffled) 
[17:38:15.598]                           invokeRestart("muffleMessage")
[17:38:15.598]                       }
[17:38:15.598]                       else if (inherits(cond, "warning")) {
[17:38:15.598]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:15.598]                         if (muffled) 
[17:38:15.598]                           invokeRestart("muffleWarning")
[17:38:15.598]                       }
[17:38:15.598]                       else if (inherits(cond, "condition")) {
[17:38:15.598]                         if (!is.null(pattern)) {
[17:38:15.598]                           computeRestarts <- base::computeRestarts
[17:38:15.598]                           grepl <- base::grepl
[17:38:15.598]                           restarts <- computeRestarts(cond)
[17:38:15.598]                           for (restart in restarts) {
[17:38:15.598]                             name <- restart$name
[17:38:15.598]                             if (is.null(name)) 
[17:38:15.598]                               next
[17:38:15.598]                             if (!grepl(pattern, name)) 
[17:38:15.598]                               next
[17:38:15.598]                             invokeRestart(restart)
[17:38:15.598]                             muffled <- TRUE
[17:38:15.598]                             break
[17:38:15.598]                           }
[17:38:15.598]                         }
[17:38:15.598]                       }
[17:38:15.598]                       invisible(muffled)
[17:38:15.598]                     }
[17:38:15.598]                     muffleCondition(cond, pattern = "^muffle")
[17:38:15.598]                   }
[17:38:15.598]                 }
[17:38:15.598]             }
[17:38:15.598]         }))
[17:38:15.598]     }, error = function(ex) {
[17:38:15.598]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:15.598]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:15.598]                 ...future.rng), started = ...future.startTime, 
[17:38:15.598]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:15.598]             version = "1.8"), class = "FutureResult")
[17:38:15.598]     }, finally = {
[17:38:15.598]         if (!identical(...future.workdir, getwd())) 
[17:38:15.598]             setwd(...future.workdir)
[17:38:15.598]         {
[17:38:15.598]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:15.598]                 ...future.oldOptions$nwarnings <- NULL
[17:38:15.598]             }
[17:38:15.598]             base::options(...future.oldOptions)
[17:38:15.598]             if (.Platform$OS.type == "windows") {
[17:38:15.598]                 old_names <- names(...future.oldEnvVars)
[17:38:15.598]                 envs <- base::Sys.getenv()
[17:38:15.598]                 names <- names(envs)
[17:38:15.598]                 common <- intersect(names, old_names)
[17:38:15.598]                 added <- setdiff(names, old_names)
[17:38:15.598]                 removed <- setdiff(old_names, names)
[17:38:15.598]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:15.598]                   envs[common]]
[17:38:15.598]                 NAMES <- toupper(changed)
[17:38:15.598]                 args <- list()
[17:38:15.598]                 for (kk in seq_along(NAMES)) {
[17:38:15.598]                   name <- changed[[kk]]
[17:38:15.598]                   NAME <- NAMES[[kk]]
[17:38:15.598]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.598]                     next
[17:38:15.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:15.598]                 }
[17:38:15.598]                 NAMES <- toupper(added)
[17:38:15.598]                 for (kk in seq_along(NAMES)) {
[17:38:15.598]                   name <- added[[kk]]
[17:38:15.598]                   NAME <- NAMES[[kk]]
[17:38:15.598]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.598]                     next
[17:38:15.598]                   args[[name]] <- ""
[17:38:15.598]                 }
[17:38:15.598]                 NAMES <- toupper(removed)
[17:38:15.598]                 for (kk in seq_along(NAMES)) {
[17:38:15.598]                   name <- removed[[kk]]
[17:38:15.598]                   NAME <- NAMES[[kk]]
[17:38:15.598]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.598]                     next
[17:38:15.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:15.598]                 }
[17:38:15.598]                 if (length(args) > 0) 
[17:38:15.598]                   base::do.call(base::Sys.setenv, args = args)
[17:38:15.598]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:15.598]             }
[17:38:15.598]             else {
[17:38:15.598]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:15.598]             }
[17:38:15.598]             {
[17:38:15.598]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:15.598]                   0L) {
[17:38:15.598]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:15.598]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:15.598]                   base::options(opts)
[17:38:15.598]                 }
[17:38:15.598]                 {
[17:38:15.598]                   {
[17:38:15.598]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:15.598]                     NULL
[17:38:15.598]                   }
[17:38:15.598]                   options(future.plan = NULL)
[17:38:15.598]                   if (is.na(NA_character_)) 
[17:38:15.598]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:15.598]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:15.598]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:15.598]                     .init = FALSE)
[17:38:15.598]                 }
[17:38:15.598]             }
[17:38:15.598]         }
[17:38:15.598]     })
[17:38:15.598]     if (TRUE) {
[17:38:15.598]         base::sink(type = "output", split = FALSE)
[17:38:15.598]         if (TRUE) {
[17:38:15.598]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:15.598]         }
[17:38:15.598]         else {
[17:38:15.598]             ...future.result["stdout"] <- base::list(NULL)
[17:38:15.598]         }
[17:38:15.598]         base::close(...future.stdout)
[17:38:15.598]         ...future.stdout <- NULL
[17:38:15.598]     }
[17:38:15.598]     ...future.result$conditions <- ...future.conditions
[17:38:15.598]     ...future.result$finished <- base::Sys.time()
[17:38:15.598]     ...future.result
[17:38:15.598] }
[17:38:15.600] Exporting 11 global objects (92.05 KiB) to cluster node #2 ...
[17:38:15.601] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:38:15.645] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:38:15.645] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[17:38:15.645] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[17:38:15.646] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:38:15.646] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:38:15.646] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:38:15.689] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:38:15.689] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:38:15.733] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:38:15.733] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:38:15.734] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:38:15.734] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[17:38:15.734] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[17:38:15.734] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:15.735] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:15.735] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:38:15.735] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:38:15.736] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:15.736] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:15.736] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:15.736] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:15.737] Exporting 11 global objects (92.05 KiB) to cluster node #2 ... DONE
[17:38:15.737] MultisessionFuture started
[17:38:15.737] - Launch lazy future ... done
[17:38:15.737] run() for ‘MultisessionFuture’ ... done
[17:38:15.737] Created future:
[17:38:15.741] receiveMessageFromWorker() for ClusterFuture ...
[17:38:15.741] - Validating connection of MultisessionFuture
[17:38:15.741] - received message: FutureResult
[17:38:15.741] - Received FutureResult
[17:38:15.741] - Erased future from FutureRegistry
[17:38:15.742] result() for ClusterFuture ...
[17:38:15.742] - result already collected: FutureResult
[17:38:15.742] result() for ClusterFuture ... done
[17:38:15.742] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:15.738] MultisessionFuture:
[17:38:15.738] Label: ‘future_vapply-2’
[17:38:15.738] Expression:
[17:38:15.738] {
[17:38:15.738]     do.call(function(...) {
[17:38:15.738]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.738]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:15.738]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.738]             on.exit(options(oopts), add = TRUE)
[17:38:15.738]         }
[17:38:15.738]         {
[17:38:15.738]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:15.738]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.738]                 ...future.FUN(...future.X_jj, ...)
[17:38:15.738]             })
[17:38:15.738]         }
[17:38:15.738]     }, args = future.call.arguments)
[17:38:15.738] }
[17:38:15.738] Lazy evaluation: FALSE
[17:38:15.738] Asynchronous evaluation: TRUE
[17:38:15.738] Local evaluation: TRUE
[17:38:15.738] Environment: R_GlobalEnv
[17:38:15.738] Capture standard output: TRUE
[17:38:15.738] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:15.738] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:15.738] Packages: 1 packages (‘future.apply’)
[17:38:15.738] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:15.738] Resolved: TRUE
[17:38:15.738] Value: <not collected>
[17:38:15.738] Conditions captured: <none>
[17:38:15.738] Early signaling: FALSE
[17:38:15.738] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:15.738] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:15.742] Chunk #2 of 2 ... DONE
[17:38:15.742] Launching 2 futures (chunks) ... DONE
[17:38:15.742] Resolving 2 futures (chunks) ...
[17:38:15.742] resolve() on list ...
[17:38:15.743]  recursive: 0
[17:38:15.743]  length: 2
[17:38:15.743] 
[17:38:15.743] receiveMessageFromWorker() for ClusterFuture ...
[17:38:15.743] - Validating connection of MultisessionFuture
[17:38:15.744] - received message: FutureResult
[17:38:15.744] - Received FutureResult
[17:38:15.744] - Erased future from FutureRegistry
[17:38:15.744] result() for ClusterFuture ...
[17:38:15.744] - result already collected: FutureResult
[17:38:15.744] result() for ClusterFuture ... done
[17:38:15.747] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:15.747] Future #1
[17:38:15.747] result() for ClusterFuture ...
[17:38:15.748] - result already collected: FutureResult
[17:38:15.748] result() for ClusterFuture ... done
[17:38:15.748] result() for ClusterFuture ...
[17:38:15.748] - result already collected: FutureResult
[17:38:15.748] result() for ClusterFuture ... done
[17:38:15.748] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:15.748] - nx: 2
[17:38:15.748] - relay: TRUE
[17:38:15.748] - stdout: TRUE
[17:38:15.749] - signal: TRUE
[17:38:15.749] - resignal: FALSE
[17:38:15.749] - force: TRUE
[17:38:15.749] - relayed: [n=2] FALSE, FALSE
[17:38:15.749] - queued futures: [n=2] FALSE, FALSE
[17:38:15.749]  - until=1
[17:38:15.749]  - relaying element #1
[17:38:15.749] result() for ClusterFuture ...
[17:38:15.749] - result already collected: FutureResult
[17:38:15.749] result() for ClusterFuture ... done
[17:38:15.750] result() for ClusterFuture ...
[17:38:15.750] - result already collected: FutureResult
[17:38:15.750] result() for ClusterFuture ... done
[17:38:15.750] result() for ClusterFuture ...
[17:38:15.750] - result already collected: FutureResult
[17:38:15.750] result() for ClusterFuture ... done
[17:38:15.750] result() for ClusterFuture ...
[17:38:15.750] - result already collected: FutureResult
[17:38:15.750] result() for ClusterFuture ... done
[17:38:15.751] - relayed: [n=2] TRUE, FALSE
[17:38:15.751] - queued futures: [n=2] TRUE, FALSE
[17:38:15.751] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:15.751]  length: 1 (resolved future 1)
[17:38:15.751] Future #2
[17:38:15.751] result() for ClusterFuture ...
[17:38:15.751] - result already collected: FutureResult
[17:38:15.751] result() for ClusterFuture ... done
[17:38:15.751] result() for ClusterFuture ...
[17:38:15.752] - result already collected: FutureResult
[17:38:15.752] result() for ClusterFuture ... done
[17:38:15.752] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:38:15.752] - nx: 2
[17:38:15.752] - relay: TRUE
[17:38:15.752] - stdout: TRUE
[17:38:15.752] - signal: TRUE
[17:38:15.752] - resignal: FALSE
[17:38:15.752] - force: TRUE
[17:38:15.752] - relayed: [n=2] TRUE, FALSE
[17:38:15.753] - queued futures: [n=2] TRUE, FALSE
[17:38:15.753]  - until=2
[17:38:15.753]  - relaying element #2
[17:38:15.753] result() for ClusterFuture ...
[17:38:15.753] - result already collected: FutureResult
[17:38:15.753] result() for ClusterFuture ... done
[17:38:15.753] result() for ClusterFuture ...
[17:38:15.753] - result already collected: FutureResult
[17:38:15.753] result() for ClusterFuture ... done
[17:38:15.753] result() for ClusterFuture ...
[17:38:15.753] - result already collected: FutureResult
[17:38:15.754] result() for ClusterFuture ... done
[17:38:15.754] result() for ClusterFuture ...
[17:38:15.754] - result already collected: FutureResult
[17:38:15.754] result() for ClusterFuture ... done
[17:38:15.754] - relayed: [n=2] TRUE, TRUE
[17:38:15.754] - queued futures: [n=2] TRUE, TRUE
[17:38:15.754] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:38:15.754]  length: 0 (resolved future 2)
[17:38:15.754] Relaying remaining futures
[17:38:15.754] signalConditionsASAP(NULL, pos=0) ...
[17:38:15.754] - nx: 2
[17:38:15.755] - relay: TRUE
[17:38:15.755] - stdout: TRUE
[17:38:15.755] - signal: TRUE
[17:38:15.755] - resignal: FALSE
[17:38:15.755] - force: TRUE
[17:38:15.755] - relayed: [n=2] TRUE, TRUE
[17:38:15.755] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:38:15.755] - relayed: [n=2] TRUE, TRUE
[17:38:15.755] - queued futures: [n=2] TRUE, TRUE
[17:38:15.755] signalConditionsASAP(NULL, pos=0) ... done
[17:38:15.755] resolve() on list ... DONE
[17:38:15.756] result() for ClusterFuture ...
[17:38:15.756] - result already collected: FutureResult
[17:38:15.756] result() for ClusterFuture ... done
[17:38:15.756] result() for ClusterFuture ...
[17:38:15.756] - result already collected: FutureResult
[17:38:15.756] result() for ClusterFuture ... done
[17:38:15.756] result() for ClusterFuture ...
[17:38:15.756] - result already collected: FutureResult
[17:38:15.756] result() for ClusterFuture ... done
[17:38:15.756] result() for ClusterFuture ...
[17:38:15.757] - result already collected: FutureResult
[17:38:15.757] result() for ClusterFuture ... done
[17:38:15.757]  - Number of value chunks collected: 2
[17:38:15.757] Resolving 2 futures (chunks) ... DONE
[17:38:15.757] Reducing values from 2 chunks ...
[17:38:15.757]  - Number of values collected after concatenation: 3
[17:38:15.757]  - Number of values expected: 3
[17:38:15.757] Reducing values from 2 chunks ... DONE
[17:38:15.757] future_lapply() ... DONE
- exceptions ...
[17:38:15.758] future_lapply() ...
[17:38:15.763] Number of chunks: 2
[17:38:15.764] getGlobalsAndPackagesXApply() ...
[17:38:15.764]  - future.globals: TRUE
[17:38:15.764] getGlobalsAndPackages() ...
[17:38:15.764] Searching for globals...
[17:38:15.768] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:38:15.768] Searching for globals ... DONE
[17:38:15.768] Resolving globals: FALSE
[17:38:15.769] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[17:38:15.769] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:38:15.769] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:15.769] - packages: [1] ‘future.apply’
[17:38:15.770] getGlobalsAndPackages() ... DONE
[17:38:15.770]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:38:15.770]  - needed namespaces: [n=1] ‘future.apply’
[17:38:15.770] Finding globals ... DONE
[17:38:15.770]  - use_args: TRUE
[17:38:15.770]  - Getting '...' globals ...
[17:38:15.770] resolve() on list ...
[17:38:15.771]  recursive: 0
[17:38:15.771]  length: 1
[17:38:15.771]  elements: ‘...’
[17:38:15.771]  length: 0 (resolved future 1)
[17:38:15.771] resolve() on list ... DONE
[17:38:15.771]    - '...' content: [n=0] 
[17:38:15.771] List of 1
[17:38:15.771]  $ ...: list()
[17:38:15.771]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:15.771]  - attr(*, "where")=List of 1
[17:38:15.771]   ..$ ...:<environment: 0x560801968c78> 
[17:38:15.771]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:15.771]  - attr(*, "resolved")= logi TRUE
[17:38:15.771]  - attr(*, "total_size")= num NA
[17:38:15.774]  - Getting '...' globals ... DONE
[17:38:15.774] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:38:15.774] List of 8
[17:38:15.774]  $ ...future.FUN:function (x, ...)  
[17:38:15.774]  $ x_FUN        :function (x)  
[17:38:15.774]  $ times        : int 2
[17:38:15.774]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:38:15.774]  $ stop_if_not  :function (...)  
[17:38:15.774]  $ dim          : NULL
[17:38:15.774]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:38:15.774]  $ ...          : list()
[17:38:15.774]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:38:15.774]  - attr(*, "where")=List of 8
[17:38:15.774]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:38:15.774]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:38:15.774]   ..$ times        :<environment: R_EmptyEnv> 
[17:38:15.774]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:38:15.774]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:38:15.774]   ..$ dim          :<environment: R_EmptyEnv> 
[17:38:15.774]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:38:15.774]   ..$ ...          :<environment: 0x560801968c78> 
[17:38:15.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:38:15.774]  - attr(*, "resolved")= logi FALSE
[17:38:15.774]  - attr(*, "total_size")= num 95128
[17:38:15.780] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:38:15.780] getGlobalsAndPackagesXApply() ... DONE
[17:38:15.780] Number of futures (= number of chunks): 2
[17:38:15.780] Launching 2 futures (chunks) ...
[17:38:15.781] Chunk #1 of 2 ...
[17:38:15.781]  - Finding globals in 'X' for chunk #1 ...
[17:38:15.781] getGlobalsAndPackages() ...
[17:38:15.781] Searching for globals...
[17:38:15.781] 
[17:38:15.781] Searching for globals ... DONE
[17:38:15.781] - globals: [0] <none>
[17:38:15.781] getGlobalsAndPackages() ... DONE
[17:38:15.781]    + additional globals found: [n=0] 
[17:38:15.782]    + additional namespaces needed: [n=0] 
[17:38:15.782]  - Finding globals in 'X' for chunk #1 ... DONE
[17:38:15.782]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:15.782]  - seeds: <none>
[17:38:15.782]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.782] getGlobalsAndPackages() ...
[17:38:15.782] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.782] Resolving globals: FALSE
[17:38:15.782] Tweak future expression to call with '...' arguments ...
[17:38:15.782] {
[17:38:15.782]     do.call(function(...) {
[17:38:15.782]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.782]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:15.782]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.782]             on.exit(options(oopts), add = TRUE)
[17:38:15.782]         }
[17:38:15.782]         {
[17:38:15.782]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:15.782]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.782]                 ...future.FUN(...future.X_jj, ...)
[17:38:15.782]             })
[17:38:15.782]         }
[17:38:15.782]     }, args = future.call.arguments)
[17:38:15.782] }
[17:38:15.783] Tweak future expression to call with '...' arguments ... DONE
[17:38:15.783] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.783] - packages: [1] ‘future.apply’
[17:38:15.784] getGlobalsAndPackages() ... DONE
[17:38:15.784] run() for ‘Future’ ...
[17:38:15.784] - state: ‘created’
[17:38:15.784] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:15.798] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:15.799] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:15.799]   - Field: ‘node’
[17:38:15.799]   - Field: ‘label’
[17:38:15.799]   - Field: ‘local’
[17:38:15.799]   - Field: ‘owner’
[17:38:15.799]   - Field: ‘envir’
[17:38:15.799]   - Field: ‘workers’
[17:38:15.799]   - Field: ‘packages’
[17:38:15.799]   - Field: ‘gc’
[17:38:15.799]   - Field: ‘conditions’
[17:38:15.800]   - Field: ‘persistent’
[17:38:15.800]   - Field: ‘expr’
[17:38:15.800]   - Field: ‘uuid’
[17:38:15.800]   - Field: ‘seed’
[17:38:15.800]   - Field: ‘version’
[17:38:15.800]   - Field: ‘result’
[17:38:15.800]   - Field: ‘asynchronous’
[17:38:15.800]   - Field: ‘calls’
[17:38:15.800]   - Field: ‘globals’
[17:38:15.800]   - Field: ‘stdout’
[17:38:15.800]   - Field: ‘earlySignal’
[17:38:15.801]   - Field: ‘lazy’
[17:38:15.801]   - Field: ‘state’
[17:38:15.801] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:15.801] - Launch lazy future ...
[17:38:15.801] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:15.801] Packages needed by future strategies (n = 0): <none>
[17:38:15.802] {
[17:38:15.802]     {
[17:38:15.802]         {
[17:38:15.802]             ...future.startTime <- base::Sys.time()
[17:38:15.802]             {
[17:38:15.802]                 {
[17:38:15.802]                   {
[17:38:15.802]                     {
[17:38:15.802]                       {
[17:38:15.802]                         base::local({
[17:38:15.802]                           has_future <- base::requireNamespace("future", 
[17:38:15.802]                             quietly = TRUE)
[17:38:15.802]                           if (has_future) {
[17:38:15.802]                             ns <- base::getNamespace("future")
[17:38:15.802]                             version <- ns[[".package"]][["version"]]
[17:38:15.802]                             if (is.null(version)) 
[17:38:15.802]                               version <- utils::packageVersion("future")
[17:38:15.802]                           }
[17:38:15.802]                           else {
[17:38:15.802]                             version <- NULL
[17:38:15.802]                           }
[17:38:15.802]                           if (!has_future || version < "1.8.0") {
[17:38:15.802]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:15.802]                               "", base::R.version$version.string), 
[17:38:15.802]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:15.802]                                 base::R.version$platform, 8 * 
[17:38:15.802]                                   base::.Machine$sizeof.pointer), 
[17:38:15.802]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:15.802]                                 "release", "version")], collapse = " "), 
[17:38:15.802]                               hostname = base::Sys.info()[["nodename"]])
[17:38:15.802]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:15.802]                               info)
[17:38:15.802]                             info <- base::paste(info, collapse = "; ")
[17:38:15.802]                             if (!has_future) {
[17:38:15.802]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:15.802]                                 info)
[17:38:15.802]                             }
[17:38:15.802]                             else {
[17:38:15.802]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:15.802]                                 info, version)
[17:38:15.802]                             }
[17:38:15.802]                             base::stop(msg)
[17:38:15.802]                           }
[17:38:15.802]                         })
[17:38:15.802]                       }
[17:38:15.802]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:15.802]                       base::options(mc.cores = 1L)
[17:38:15.802]                     }
[17:38:15.802]                     base::local({
[17:38:15.802]                       for (pkg in "future.apply") {
[17:38:15.802]                         base::loadNamespace(pkg)
[17:38:15.802]                         base::library(pkg, character.only = TRUE)
[17:38:15.802]                       }
[17:38:15.802]                     })
[17:38:15.802]                   }
[17:38:15.802]                   ...future.strategy.old <- future::plan("list")
[17:38:15.802]                   options(future.plan = NULL)
[17:38:15.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:15.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:15.802]                 }
[17:38:15.802]                 ...future.workdir <- getwd()
[17:38:15.802]             }
[17:38:15.802]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:15.802]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:15.802]         }
[17:38:15.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:15.802]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:15.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:15.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:15.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:15.802]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:15.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:15.802]             base::names(...future.oldOptions))
[17:38:15.802]     }
[17:38:15.802]     if (FALSE) {
[17:38:15.802]     }
[17:38:15.802]     else {
[17:38:15.802]         if (TRUE) {
[17:38:15.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:15.802]                 open = "w")
[17:38:15.802]         }
[17:38:15.802]         else {
[17:38:15.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:15.802]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:15.802]         }
[17:38:15.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:15.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:15.802]             base::sink(type = "output", split = FALSE)
[17:38:15.802]             base::close(...future.stdout)
[17:38:15.802]         }, add = TRUE)
[17:38:15.802]     }
[17:38:15.802]     ...future.frame <- base::sys.nframe()
[17:38:15.802]     ...future.conditions <- base::list()
[17:38:15.802]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:15.802]     if (FALSE) {
[17:38:15.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:15.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:15.802]     }
[17:38:15.802]     ...future.result <- base::tryCatch({
[17:38:15.802]         base::withCallingHandlers({
[17:38:15.802]             ...future.value <- base::withVisible(base::local({
[17:38:15.802]                 ...future.makeSendCondition <- base::local({
[17:38:15.802]                   sendCondition <- NULL
[17:38:15.802]                   function(frame = 1L) {
[17:38:15.802]                     if (is.function(sendCondition)) 
[17:38:15.802]                       return(sendCondition)
[17:38:15.802]                     ns <- getNamespace("parallel")
[17:38:15.802]                     if (exists("sendData", mode = "function", 
[17:38:15.802]                       envir = ns)) {
[17:38:15.802]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:15.802]                         envir = ns)
[17:38:15.802]                       envir <- sys.frame(frame)
[17:38:15.802]                       master <- NULL
[17:38:15.802]                       while (!identical(envir, .GlobalEnv) && 
[17:38:15.802]                         !identical(envir, emptyenv())) {
[17:38:15.802]                         if (exists("master", mode = "list", envir = envir, 
[17:38:15.802]                           inherits = FALSE)) {
[17:38:15.802]                           master <- get("master", mode = "list", 
[17:38:15.802]                             envir = envir, inherits = FALSE)
[17:38:15.802]                           if (inherits(master, c("SOCKnode", 
[17:38:15.802]                             "SOCK0node"))) {
[17:38:15.802]                             sendCondition <<- function(cond) {
[17:38:15.802]                               data <- list(type = "VALUE", value = cond, 
[17:38:15.802]                                 success = TRUE)
[17:38:15.802]                               parallel_sendData(master, data)
[17:38:15.802]                             }
[17:38:15.802]                             return(sendCondition)
[17:38:15.802]                           }
[17:38:15.802]                         }
[17:38:15.802]                         frame <- frame + 1L
[17:38:15.802]                         envir <- sys.frame(frame)
[17:38:15.802]                       }
[17:38:15.802]                     }
[17:38:15.802]                     sendCondition <<- function(cond) NULL
[17:38:15.802]                   }
[17:38:15.802]                 })
[17:38:15.802]                 withCallingHandlers({
[17:38:15.802]                   {
[17:38:15.802]                     do.call(function(...) {
[17:38:15.802]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.802]                       if (!identical(...future.globals.maxSize.org, 
[17:38:15.802]                         ...future.globals.maxSize)) {
[17:38:15.802]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.802]                         on.exit(options(oopts), add = TRUE)
[17:38:15.802]                       }
[17:38:15.802]                       {
[17:38:15.802]                         lapply(seq_along(...future.elements_ii), 
[17:38:15.802]                           FUN = function(jj) {
[17:38:15.802]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.802]                             ...future.FUN(...future.X_jj, ...)
[17:38:15.802]                           })
[17:38:15.802]                       }
[17:38:15.802]                     }, args = future.call.arguments)
[17:38:15.802]                   }
[17:38:15.802]                 }, immediateCondition = function(cond) {
[17:38:15.802]                   sendCondition <- ...future.makeSendCondition()
[17:38:15.802]                   sendCondition(cond)
[17:38:15.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.802]                   {
[17:38:15.802]                     inherits <- base::inherits
[17:38:15.802]                     invokeRestart <- base::invokeRestart
[17:38:15.802]                     is.null <- base::is.null
[17:38:15.802]                     muffled <- FALSE
[17:38:15.802]                     if (inherits(cond, "message")) {
[17:38:15.802]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:15.802]                       if (muffled) 
[17:38:15.802]                         invokeRestart("muffleMessage")
[17:38:15.802]                     }
[17:38:15.802]                     else if (inherits(cond, "warning")) {
[17:38:15.802]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:15.802]                       if (muffled) 
[17:38:15.802]                         invokeRestart("muffleWarning")
[17:38:15.802]                     }
[17:38:15.802]                     else if (inherits(cond, "condition")) {
[17:38:15.802]                       if (!is.null(pattern)) {
[17:38:15.802]                         computeRestarts <- base::computeRestarts
[17:38:15.802]                         grepl <- base::grepl
[17:38:15.802]                         restarts <- computeRestarts(cond)
[17:38:15.802]                         for (restart in restarts) {
[17:38:15.802]                           name <- restart$name
[17:38:15.802]                           if (is.null(name)) 
[17:38:15.802]                             next
[17:38:15.802]                           if (!grepl(pattern, name)) 
[17:38:15.802]                             next
[17:38:15.802]                           invokeRestart(restart)
[17:38:15.802]                           muffled <- TRUE
[17:38:15.802]                           break
[17:38:15.802]                         }
[17:38:15.802]                       }
[17:38:15.802]                     }
[17:38:15.802]                     invisible(muffled)
[17:38:15.802]                   }
[17:38:15.802]                   muffleCondition(cond)
[17:38:15.802]                 })
[17:38:15.802]             }))
[17:38:15.802]             future::FutureResult(value = ...future.value$value, 
[17:38:15.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:15.802]                   ...future.rng), globalenv = if (FALSE) 
[17:38:15.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:15.802]                     ...future.globalenv.names))
[17:38:15.802]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:15.802]         }, condition = base::local({
[17:38:15.802]             c <- base::c
[17:38:15.802]             inherits <- base::inherits
[17:38:15.802]             invokeRestart <- base::invokeRestart
[17:38:15.802]             length <- base::length
[17:38:15.802]             list <- base::list
[17:38:15.802]             seq.int <- base::seq.int
[17:38:15.802]             signalCondition <- base::signalCondition
[17:38:15.802]             sys.calls <- base::sys.calls
[17:38:15.802]             `[[` <- base::`[[`
[17:38:15.802]             `+` <- base::`+`
[17:38:15.802]             `<<-` <- base::`<<-`
[17:38:15.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:15.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:15.802]                   3L)]
[17:38:15.802]             }
[17:38:15.802]             function(cond) {
[17:38:15.802]                 is_error <- inherits(cond, "error")
[17:38:15.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:15.802]                   NULL)
[17:38:15.802]                 if (is_error) {
[17:38:15.802]                   sessionInformation <- function() {
[17:38:15.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:15.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:15.802]                       search = base::search(), system = base::Sys.info())
[17:38:15.802]                   }
[17:38:15.802]                   ...future.conditions[[length(...future.conditions) + 
[17:38:15.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:15.802]                     cond$call), session = sessionInformation(), 
[17:38:15.802]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:15.802]                   signalCondition(cond)
[17:38:15.802]                 }
[17:38:15.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:15.802]                 "immediateCondition"))) {
[17:38:15.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:15.802]                   ...future.conditions[[length(...future.conditions) + 
[17:38:15.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:15.802]                   if (TRUE && !signal) {
[17:38:15.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.802]                     {
[17:38:15.802]                       inherits <- base::inherits
[17:38:15.802]                       invokeRestart <- base::invokeRestart
[17:38:15.802]                       is.null <- base::is.null
[17:38:15.802]                       muffled <- FALSE
[17:38:15.802]                       if (inherits(cond, "message")) {
[17:38:15.802]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:15.802]                         if (muffled) 
[17:38:15.802]                           invokeRestart("muffleMessage")
[17:38:15.802]                       }
[17:38:15.802]                       else if (inherits(cond, "warning")) {
[17:38:15.802]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:15.802]                         if (muffled) 
[17:38:15.802]                           invokeRestart("muffleWarning")
[17:38:15.802]                       }
[17:38:15.802]                       else if (inherits(cond, "condition")) {
[17:38:15.802]                         if (!is.null(pattern)) {
[17:38:15.802]                           computeRestarts <- base::computeRestarts
[17:38:15.802]                           grepl <- base::grepl
[17:38:15.802]                           restarts <- computeRestarts(cond)
[17:38:15.802]                           for (restart in restarts) {
[17:38:15.802]                             name <- restart$name
[17:38:15.802]                             if (is.null(name)) 
[17:38:15.802]                               next
[17:38:15.802]                             if (!grepl(pattern, name)) 
[17:38:15.802]                               next
[17:38:15.802]                             invokeRestart(restart)
[17:38:15.802]                             muffled <- TRUE
[17:38:15.802]                             break
[17:38:15.802]                           }
[17:38:15.802]                         }
[17:38:15.802]                       }
[17:38:15.802]                       invisible(muffled)
[17:38:15.802]                     }
[17:38:15.802]                     muffleCondition(cond, pattern = "^muffle")
[17:38:15.802]                   }
[17:38:15.802]                 }
[17:38:15.802]                 else {
[17:38:15.802]                   if (TRUE) {
[17:38:15.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.802]                     {
[17:38:15.802]                       inherits <- base::inherits
[17:38:15.802]                       invokeRestart <- base::invokeRestart
[17:38:15.802]                       is.null <- base::is.null
[17:38:15.802]                       muffled <- FALSE
[17:38:15.802]                       if (inherits(cond, "message")) {
[17:38:15.802]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:15.802]                         if (muffled) 
[17:38:15.802]                           invokeRestart("muffleMessage")
[17:38:15.802]                       }
[17:38:15.802]                       else if (inherits(cond, "warning")) {
[17:38:15.802]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:15.802]                         if (muffled) 
[17:38:15.802]                           invokeRestart("muffleWarning")
[17:38:15.802]                       }
[17:38:15.802]                       else if (inherits(cond, "condition")) {
[17:38:15.802]                         if (!is.null(pattern)) {
[17:38:15.802]                           computeRestarts <- base::computeRestarts
[17:38:15.802]                           grepl <- base::grepl
[17:38:15.802]                           restarts <- computeRestarts(cond)
[17:38:15.802]                           for (restart in restarts) {
[17:38:15.802]                             name <- restart$name
[17:38:15.802]                             if (is.null(name)) 
[17:38:15.802]                               next
[17:38:15.802]                             if (!grepl(pattern, name)) 
[17:38:15.802]                               next
[17:38:15.802]                             invokeRestart(restart)
[17:38:15.802]                             muffled <- TRUE
[17:38:15.802]                             break
[17:38:15.802]                           }
[17:38:15.802]                         }
[17:38:15.802]                       }
[17:38:15.802]                       invisible(muffled)
[17:38:15.802]                     }
[17:38:15.802]                     muffleCondition(cond, pattern = "^muffle")
[17:38:15.802]                   }
[17:38:15.802]                 }
[17:38:15.802]             }
[17:38:15.802]         }))
[17:38:15.802]     }, error = function(ex) {
[17:38:15.802]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:15.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:15.802]                 ...future.rng), started = ...future.startTime, 
[17:38:15.802]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:15.802]             version = "1.8"), class = "FutureResult")
[17:38:15.802]     }, finally = {
[17:38:15.802]         if (!identical(...future.workdir, getwd())) 
[17:38:15.802]             setwd(...future.workdir)
[17:38:15.802]         {
[17:38:15.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:15.802]                 ...future.oldOptions$nwarnings <- NULL
[17:38:15.802]             }
[17:38:15.802]             base::options(...future.oldOptions)
[17:38:15.802]             if (.Platform$OS.type == "windows") {
[17:38:15.802]                 old_names <- names(...future.oldEnvVars)
[17:38:15.802]                 envs <- base::Sys.getenv()
[17:38:15.802]                 names <- names(envs)
[17:38:15.802]                 common <- intersect(names, old_names)
[17:38:15.802]                 added <- setdiff(names, old_names)
[17:38:15.802]                 removed <- setdiff(old_names, names)
[17:38:15.802]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:15.802]                   envs[common]]
[17:38:15.802]                 NAMES <- toupper(changed)
[17:38:15.802]                 args <- list()
[17:38:15.802]                 for (kk in seq_along(NAMES)) {
[17:38:15.802]                   name <- changed[[kk]]
[17:38:15.802]                   NAME <- NAMES[[kk]]
[17:38:15.802]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.802]                     next
[17:38:15.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:15.802]                 }
[17:38:15.802]                 NAMES <- toupper(added)
[17:38:15.802]                 for (kk in seq_along(NAMES)) {
[17:38:15.802]                   name <- added[[kk]]
[17:38:15.802]                   NAME <- NAMES[[kk]]
[17:38:15.802]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.802]                     next
[17:38:15.802]                   args[[name]] <- ""
[17:38:15.802]                 }
[17:38:15.802]                 NAMES <- toupper(removed)
[17:38:15.802]                 for (kk in seq_along(NAMES)) {
[17:38:15.802]                   name <- removed[[kk]]
[17:38:15.802]                   NAME <- NAMES[[kk]]
[17:38:15.802]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.802]                     next
[17:38:15.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:15.802]                 }
[17:38:15.802]                 if (length(args) > 0) 
[17:38:15.802]                   base::do.call(base::Sys.setenv, args = args)
[17:38:15.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:15.802]             }
[17:38:15.802]             else {
[17:38:15.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:15.802]             }
[17:38:15.802]             {
[17:38:15.802]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:15.802]                   0L) {
[17:38:15.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:15.802]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:15.802]                   base::options(opts)
[17:38:15.802]                 }
[17:38:15.802]                 {
[17:38:15.802]                   {
[17:38:15.802]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:15.802]                     NULL
[17:38:15.802]                   }
[17:38:15.802]                   options(future.plan = NULL)
[17:38:15.802]                   if (is.na(NA_character_)) 
[17:38:15.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:15.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:15.802]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:15.802]                     .init = FALSE)
[17:38:15.802]                 }
[17:38:15.802]             }
[17:38:15.802]         }
[17:38:15.802]     })
[17:38:15.802]     if (TRUE) {
[17:38:15.802]         base::sink(type = "output", split = FALSE)
[17:38:15.802]         if (TRUE) {
[17:38:15.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:15.802]         }
[17:38:15.802]         else {
[17:38:15.802]             ...future.result["stdout"] <- base::list(NULL)
[17:38:15.802]         }
[17:38:15.802]         base::close(...future.stdout)
[17:38:15.802]         ...future.stdout <- NULL
[17:38:15.802]     }
[17:38:15.802]     ...future.result$conditions <- ...future.conditions
[17:38:15.802]     ...future.result$finished <- base::Sys.time()
[17:38:15.802]     ...future.result
[17:38:15.802] }
[17:38:15.805] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[17:38:15.805] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:38:15.849] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:38:15.849] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[17:38:15.849] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[17:38:15.850] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:38:15.850] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:38:15.850] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:38:15.893] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:38:15.893] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:38:15.937] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:38:15.937] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:38:15.937] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:38:15.938] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:38:15.938] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:38:15.938] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:38:15.939] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:38:15.939] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:38:15.939] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:38:15.939] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:38:15.940] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:38:15.940] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:38:15.940] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:38:15.940] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[17:38:15.941] MultisessionFuture started
[17:38:15.941] - Launch lazy future ... done
[17:38:15.941] run() for ‘MultisessionFuture’ ... done
[17:38:15.941] Created future:
[17:38:15.941] MultisessionFuture:
[17:38:15.941] Label: ‘future_vapply-1’
[17:38:15.941] Expression:
[17:38:15.941] {
[17:38:15.941]     do.call(function(...) {
[17:38:15.941]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.941]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:15.941]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.941]             on.exit(options(oopts), add = TRUE)
[17:38:15.941]         }
[17:38:15.941]         {
[17:38:15.941]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:15.941]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.941]                 ...future.FUN(...future.X_jj, ...)
[17:38:15.941]             })
[17:38:15.941]         }
[17:38:15.941]     }, args = future.call.arguments)
[17:38:15.941] }
[17:38:15.941] Lazy evaluation: FALSE
[17:38:15.941] Asynchronous evaluation: TRUE
[17:38:15.941] Local evaluation: TRUE
[17:38:15.941] Environment: R_GlobalEnv
[17:38:15.941] Capture standard output: TRUE
[17:38:15.941] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:15.941] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:15.941] Packages: 1 packages (‘future.apply’)
[17:38:15.941] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:15.941] Resolved: FALSE
[17:38:15.941] Value: <not collected>
[17:38:15.941] Conditions captured: <none>
[17:38:15.941] Early signaling: FALSE
[17:38:15.941] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:15.941] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:15.953] Chunk #1 of 2 ... DONE
[17:38:15.953] Chunk #2 of 2 ...
[17:38:15.954]  - Finding globals in 'X' for chunk #2 ...
[17:38:15.954] getGlobalsAndPackages() ...
[17:38:15.954] Searching for globals...
[17:38:15.954] 
[17:38:15.954] Searching for globals ... DONE
[17:38:15.954] - globals: [0] <none>
[17:38:15.954] getGlobalsAndPackages() ... DONE
[17:38:15.954]    + additional globals found: [n=0] 
[17:38:15.954]    + additional namespaces needed: [n=0] 
[17:38:15.955]  - Finding globals in 'X' for chunk #2 ... DONE
[17:38:15.955]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:38:15.955]  - seeds: <none>
[17:38:15.955]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.955] getGlobalsAndPackages() ...
[17:38:15.955] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.955] Resolving globals: FALSE
[17:38:15.955] Tweak future expression to call with '...' arguments ...
[17:38:15.955] {
[17:38:15.955]     do.call(function(...) {
[17:38:15.955]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.955]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:15.955]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.955]             on.exit(options(oopts), add = TRUE)
[17:38:15.955]         }
[17:38:15.955]         {
[17:38:15.955]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:15.955]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.955]                 ...future.FUN(...future.X_jj, ...)
[17:38:15.955]             })
[17:38:15.955]         }
[17:38:15.955]     }, args = future.call.arguments)
[17:38:15.955] }
[17:38:15.956] Tweak future expression to call with '...' arguments ... DONE
[17:38:15.956] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:38:15.956] - packages: [1] ‘future.apply’
[17:38:15.956] getGlobalsAndPackages() ... DONE
[17:38:15.957] run() for ‘Future’ ...
[17:38:15.957] - state: ‘created’
[17:38:15.957] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:38:15.971] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:15.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:38:15.972]   - Field: ‘node’
[17:38:15.972]   - Field: ‘label’
[17:38:15.972]   - Field: ‘local’
[17:38:15.972]   - Field: ‘owner’
[17:38:15.972]   - Field: ‘envir’
[17:38:15.972]   - Field: ‘workers’
[17:38:15.972]   - Field: ‘packages’
[17:38:15.972]   - Field: ‘gc’
[17:38:15.973]   - Field: ‘conditions’
[17:38:15.973]   - Field: ‘persistent’
[17:38:15.973]   - Field: ‘expr’
[17:38:15.973]   - Field: ‘uuid’
[17:38:15.973]   - Field: ‘seed’
[17:38:15.973]   - Field: ‘version’
[17:38:15.973]   - Field: ‘result’
[17:38:15.973]   - Field: ‘asynchronous’
[17:38:15.973]   - Field: ‘calls’
[17:38:15.973]   - Field: ‘globals’
[17:38:15.973]   - Field: ‘stdout’
[17:38:15.974]   - Field: ‘earlySignal’
[17:38:15.974]   - Field: ‘lazy’
[17:38:15.974]   - Field: ‘state’
[17:38:15.974] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:38:15.974] - Launch lazy future ...
[17:38:15.974] Packages needed by the future expression (n = 1): ‘future.apply’
[17:38:15.974] Packages needed by future strategies (n = 0): <none>
[17:38:15.975] {
[17:38:15.975]     {
[17:38:15.975]         {
[17:38:15.975]             ...future.startTime <- base::Sys.time()
[17:38:15.975]             {
[17:38:15.975]                 {
[17:38:15.975]                   {
[17:38:15.975]                     {
[17:38:15.975]                       {
[17:38:15.975]                         base::local({
[17:38:15.975]                           has_future <- base::requireNamespace("future", 
[17:38:15.975]                             quietly = TRUE)
[17:38:15.975]                           if (has_future) {
[17:38:15.975]                             ns <- base::getNamespace("future")
[17:38:15.975]                             version <- ns[[".package"]][["version"]]
[17:38:15.975]                             if (is.null(version)) 
[17:38:15.975]                               version <- utils::packageVersion("future")
[17:38:15.975]                           }
[17:38:15.975]                           else {
[17:38:15.975]                             version <- NULL
[17:38:15.975]                           }
[17:38:15.975]                           if (!has_future || version < "1.8.0") {
[17:38:15.975]                             info <- base::c(r_version = base::gsub("R version ", 
[17:38:15.975]                               "", base::R.version$version.string), 
[17:38:15.975]                               platform = base::sprintf("%s (%s-bit)", 
[17:38:15.975]                                 base::R.version$platform, 8 * 
[17:38:15.975]                                   base::.Machine$sizeof.pointer), 
[17:38:15.975]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:38:15.975]                                 "release", "version")], collapse = " "), 
[17:38:15.975]                               hostname = base::Sys.info()[["nodename"]])
[17:38:15.975]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:38:15.975]                               info)
[17:38:15.975]                             info <- base::paste(info, collapse = "; ")
[17:38:15.975]                             if (!has_future) {
[17:38:15.975]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:38:15.975]                                 info)
[17:38:15.975]                             }
[17:38:15.975]                             else {
[17:38:15.975]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:38:15.975]                                 info, version)
[17:38:15.975]                             }
[17:38:15.975]                             base::stop(msg)
[17:38:15.975]                           }
[17:38:15.975]                         })
[17:38:15.975]                       }
[17:38:15.975]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:38:15.975]                       base::options(mc.cores = 1L)
[17:38:15.975]                     }
[17:38:15.975]                     base::local({
[17:38:15.975]                       for (pkg in "future.apply") {
[17:38:15.975]                         base::loadNamespace(pkg)
[17:38:15.975]                         base::library(pkg, character.only = TRUE)
[17:38:15.975]                       }
[17:38:15.975]                     })
[17:38:15.975]                   }
[17:38:15.975]                   ...future.strategy.old <- future::plan("list")
[17:38:15.975]                   options(future.plan = NULL)
[17:38:15.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:38:15.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:38:15.975]                 }
[17:38:15.975]                 ...future.workdir <- getwd()
[17:38:15.975]             }
[17:38:15.975]             ...future.oldOptions <- base::as.list(base::.Options)
[17:38:15.975]             ...future.oldEnvVars <- base::Sys.getenv()
[17:38:15.975]         }
[17:38:15.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:38:15.975]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:38:15.975]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:38:15.975]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:38:15.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:38:15.975]             future.stdout.windows.reencode = NULL, width = 80L)
[17:38:15.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:38:15.975]             base::names(...future.oldOptions))
[17:38:15.975]     }
[17:38:15.975]     if (FALSE) {
[17:38:15.975]     }
[17:38:15.975]     else {
[17:38:15.975]         if (TRUE) {
[17:38:15.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:38:15.975]                 open = "w")
[17:38:15.975]         }
[17:38:15.975]         else {
[17:38:15.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:38:15.975]                 windows = "NUL", "/dev/null"), open = "w")
[17:38:15.975]         }
[17:38:15.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:38:15.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:38:15.975]             base::sink(type = "output", split = FALSE)
[17:38:15.975]             base::close(...future.stdout)
[17:38:15.975]         }, add = TRUE)
[17:38:15.975]     }
[17:38:15.975]     ...future.frame <- base::sys.nframe()
[17:38:15.975]     ...future.conditions <- base::list()
[17:38:15.975]     ...future.rng <- base::globalenv()$.Random.seed
[17:38:15.975]     if (FALSE) {
[17:38:15.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:38:15.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:38:15.975]     }
[17:38:15.975]     ...future.result <- base::tryCatch({
[17:38:15.975]         base::withCallingHandlers({
[17:38:15.975]             ...future.value <- base::withVisible(base::local({
[17:38:15.975]                 ...future.makeSendCondition <- base::local({
[17:38:15.975]                   sendCondition <- NULL
[17:38:15.975]                   function(frame = 1L) {
[17:38:15.975]                     if (is.function(sendCondition)) 
[17:38:15.975]                       return(sendCondition)
[17:38:15.975]                     ns <- getNamespace("parallel")
[17:38:15.975]                     if (exists("sendData", mode = "function", 
[17:38:15.975]                       envir = ns)) {
[17:38:15.975]                       parallel_sendData <- get("sendData", mode = "function", 
[17:38:15.975]                         envir = ns)
[17:38:15.975]                       envir <- sys.frame(frame)
[17:38:15.975]                       master <- NULL
[17:38:15.975]                       while (!identical(envir, .GlobalEnv) && 
[17:38:15.975]                         !identical(envir, emptyenv())) {
[17:38:15.975]                         if (exists("master", mode = "list", envir = envir, 
[17:38:15.975]                           inherits = FALSE)) {
[17:38:15.975]                           master <- get("master", mode = "list", 
[17:38:15.975]                             envir = envir, inherits = FALSE)
[17:38:15.975]                           if (inherits(master, c("SOCKnode", 
[17:38:15.975]                             "SOCK0node"))) {
[17:38:15.975]                             sendCondition <<- function(cond) {
[17:38:15.975]                               data <- list(type = "VALUE", value = cond, 
[17:38:15.975]                                 success = TRUE)
[17:38:15.975]                               parallel_sendData(master, data)
[17:38:15.975]                             }
[17:38:15.975]                             return(sendCondition)
[17:38:15.975]                           }
[17:38:15.975]                         }
[17:38:15.975]                         frame <- frame + 1L
[17:38:15.975]                         envir <- sys.frame(frame)
[17:38:15.975]                       }
[17:38:15.975]                     }
[17:38:15.975]                     sendCondition <<- function(cond) NULL
[17:38:15.975]                   }
[17:38:15.975]                 })
[17:38:15.975]                 withCallingHandlers({
[17:38:15.975]                   {
[17:38:15.975]                     do.call(function(...) {
[17:38:15.975]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:15.975]                       if (!identical(...future.globals.maxSize.org, 
[17:38:15.975]                         ...future.globals.maxSize)) {
[17:38:15.975]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:15.975]                         on.exit(options(oopts), add = TRUE)
[17:38:15.975]                       }
[17:38:15.975]                       {
[17:38:15.975]                         lapply(seq_along(...future.elements_ii), 
[17:38:15.975]                           FUN = function(jj) {
[17:38:15.975]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:15.975]                             ...future.FUN(...future.X_jj, ...)
[17:38:15.975]                           })
[17:38:15.975]                       }
[17:38:15.975]                     }, args = future.call.arguments)
[17:38:15.975]                   }
[17:38:15.975]                 }, immediateCondition = function(cond) {
[17:38:15.975]                   sendCondition <- ...future.makeSendCondition()
[17:38:15.975]                   sendCondition(cond)
[17:38:15.975]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.975]                   {
[17:38:15.975]                     inherits <- base::inherits
[17:38:15.975]                     invokeRestart <- base::invokeRestart
[17:38:15.975]                     is.null <- base::is.null
[17:38:15.975]                     muffled <- FALSE
[17:38:15.975]                     if (inherits(cond, "message")) {
[17:38:15.975]                       muffled <- grepl(pattern, "muffleMessage")
[17:38:15.975]                       if (muffled) 
[17:38:15.975]                         invokeRestart("muffleMessage")
[17:38:15.975]                     }
[17:38:15.975]                     else if (inherits(cond, "warning")) {
[17:38:15.975]                       muffled <- grepl(pattern, "muffleWarning")
[17:38:15.975]                       if (muffled) 
[17:38:15.975]                         invokeRestart("muffleWarning")
[17:38:15.975]                     }
[17:38:15.975]                     else if (inherits(cond, "condition")) {
[17:38:15.975]                       if (!is.null(pattern)) {
[17:38:15.975]                         computeRestarts <- base::computeRestarts
[17:38:15.975]                         grepl <- base::grepl
[17:38:15.975]                         restarts <- computeRestarts(cond)
[17:38:15.975]                         for (restart in restarts) {
[17:38:15.975]                           name <- restart$name
[17:38:15.975]                           if (is.null(name)) 
[17:38:15.975]                             next
[17:38:15.975]                           if (!grepl(pattern, name)) 
[17:38:15.975]                             next
[17:38:15.975]                           invokeRestart(restart)
[17:38:15.975]                           muffled <- TRUE
[17:38:15.975]                           break
[17:38:15.975]                         }
[17:38:15.975]                       }
[17:38:15.975]                     }
[17:38:15.975]                     invisible(muffled)
[17:38:15.975]                   }
[17:38:15.975]                   muffleCondition(cond)
[17:38:15.975]                 })
[17:38:15.975]             }))
[17:38:15.975]             future::FutureResult(value = ...future.value$value, 
[17:38:15.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:15.975]                   ...future.rng), globalenv = if (FALSE) 
[17:38:15.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:38:15.975]                     ...future.globalenv.names))
[17:38:15.975]                 else NULL, started = ...future.startTime, version = "1.8")
[17:38:15.975]         }, condition = base::local({
[17:38:15.975]             c <- base::c
[17:38:15.975]             inherits <- base::inherits
[17:38:15.975]             invokeRestart <- base::invokeRestart
[17:38:15.975]             length <- base::length
[17:38:15.975]             list <- base::list
[17:38:15.975]             seq.int <- base::seq.int
[17:38:15.975]             signalCondition <- base::signalCondition
[17:38:15.975]             sys.calls <- base::sys.calls
[17:38:15.975]             `[[` <- base::`[[`
[17:38:15.975]             `+` <- base::`+`
[17:38:15.975]             `<<-` <- base::`<<-`
[17:38:15.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:38:15.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:38:15.975]                   3L)]
[17:38:15.975]             }
[17:38:15.975]             function(cond) {
[17:38:15.975]                 is_error <- inherits(cond, "error")
[17:38:15.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:38:15.975]                   NULL)
[17:38:15.975]                 if (is_error) {
[17:38:15.975]                   sessionInformation <- function() {
[17:38:15.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:38:15.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:38:15.975]                       search = base::search(), system = base::Sys.info())
[17:38:15.975]                   }
[17:38:15.975]                   ...future.conditions[[length(...future.conditions) + 
[17:38:15.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:38:15.975]                     cond$call), session = sessionInformation(), 
[17:38:15.975]                     timestamp = base::Sys.time(), signaled = 0L)
[17:38:15.975]                   signalCondition(cond)
[17:38:15.975]                 }
[17:38:15.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:38:15.975]                 "immediateCondition"))) {
[17:38:15.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:38:15.975]                   ...future.conditions[[length(...future.conditions) + 
[17:38:15.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:38:15.975]                   if (TRUE && !signal) {
[17:38:15.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.975]                     {
[17:38:15.975]                       inherits <- base::inherits
[17:38:15.975]                       invokeRestart <- base::invokeRestart
[17:38:15.975]                       is.null <- base::is.null
[17:38:15.975]                       muffled <- FALSE
[17:38:15.975]                       if (inherits(cond, "message")) {
[17:38:15.975]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:15.975]                         if (muffled) 
[17:38:15.975]                           invokeRestart("muffleMessage")
[17:38:15.975]                       }
[17:38:15.975]                       else if (inherits(cond, "warning")) {
[17:38:15.975]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:15.975]                         if (muffled) 
[17:38:15.975]                           invokeRestart("muffleWarning")
[17:38:15.975]                       }
[17:38:15.975]                       else if (inherits(cond, "condition")) {
[17:38:15.975]                         if (!is.null(pattern)) {
[17:38:15.975]                           computeRestarts <- base::computeRestarts
[17:38:15.975]                           grepl <- base::grepl
[17:38:15.975]                           restarts <- computeRestarts(cond)
[17:38:15.975]                           for (restart in restarts) {
[17:38:15.975]                             name <- restart$name
[17:38:15.975]                             if (is.null(name)) 
[17:38:15.975]                               next
[17:38:15.975]                             if (!grepl(pattern, name)) 
[17:38:15.975]                               next
[17:38:15.975]                             invokeRestart(restart)
[17:38:15.975]                             muffled <- TRUE
[17:38:15.975]                             break
[17:38:15.975]                           }
[17:38:15.975]                         }
[17:38:15.975]                       }
[17:38:15.975]                       invisible(muffled)
[17:38:15.975]                     }
[17:38:15.975]                     muffleCondition(cond, pattern = "^muffle")
[17:38:15.975]                   }
[17:38:15.975]                 }
[17:38:15.975]                 else {
[17:38:15.975]                   if (TRUE) {
[17:38:15.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:38:15.975]                     {
[17:38:15.975]                       inherits <- base::inherits
[17:38:15.975]                       invokeRestart <- base::invokeRestart
[17:38:15.975]                       is.null <- base::is.null
[17:38:15.975]                       muffled <- FALSE
[17:38:15.975]                       if (inherits(cond, "message")) {
[17:38:15.975]                         muffled <- grepl(pattern, "muffleMessage")
[17:38:15.975]                         if (muffled) 
[17:38:15.975]                           invokeRestart("muffleMessage")
[17:38:15.975]                       }
[17:38:15.975]                       else if (inherits(cond, "warning")) {
[17:38:15.975]                         muffled <- grepl(pattern, "muffleWarning")
[17:38:15.975]                         if (muffled) 
[17:38:15.975]                           invokeRestart("muffleWarning")
[17:38:15.975]                       }
[17:38:15.975]                       else if (inherits(cond, "condition")) {
[17:38:15.975]                         if (!is.null(pattern)) {
[17:38:15.975]                           computeRestarts <- base::computeRestarts
[17:38:15.975]                           grepl <- base::grepl
[17:38:15.975]                           restarts <- computeRestarts(cond)
[17:38:15.975]                           for (restart in restarts) {
[17:38:15.975]                             name <- restart$name
[17:38:15.975]                             if (is.null(name)) 
[17:38:15.975]                               next
[17:38:15.975]                             if (!grepl(pattern, name)) 
[17:38:15.975]                               next
[17:38:15.975]                             invokeRestart(restart)
[17:38:15.975]                             muffled <- TRUE
[17:38:15.975]                             break
[17:38:15.975]                           }
[17:38:15.975]                         }
[17:38:15.975]                       }
[17:38:15.975]                       invisible(muffled)
[17:38:15.975]                     }
[17:38:15.975]                     muffleCondition(cond, pattern = "^muffle")
[17:38:15.975]                   }
[17:38:15.975]                 }
[17:38:15.975]             }
[17:38:15.975]         }))
[17:38:15.975]     }, error = function(ex) {
[17:38:15.975]         base::structure(base::list(value = NULL, visible = NULL, 
[17:38:15.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:38:15.975]                 ...future.rng), started = ...future.startTime, 
[17:38:15.975]             finished = Sys.time(), session_uuid = NA_character_, 
[17:38:15.975]             version = "1.8"), class = "FutureResult")
[17:38:15.975]     }, finally = {
[17:38:15.975]         if (!identical(...future.workdir, getwd())) 
[17:38:15.975]             setwd(...future.workdir)
[17:38:15.975]         {
[17:38:15.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:38:15.975]                 ...future.oldOptions$nwarnings <- NULL
[17:38:15.975]             }
[17:38:15.975]             base::options(...future.oldOptions)
[17:38:15.975]             if (.Platform$OS.type == "windows") {
[17:38:15.975]                 old_names <- names(...future.oldEnvVars)
[17:38:15.975]                 envs <- base::Sys.getenv()
[17:38:15.975]                 names <- names(envs)
[17:38:15.975]                 common <- intersect(names, old_names)
[17:38:15.975]                 added <- setdiff(names, old_names)
[17:38:15.975]                 removed <- setdiff(old_names, names)
[17:38:15.975]                 changed <- common[...future.oldEnvVars[common] != 
[17:38:15.975]                   envs[common]]
[17:38:15.975]                 NAMES <- toupper(changed)
[17:38:15.975]                 args <- list()
[17:38:15.975]                 for (kk in seq_along(NAMES)) {
[17:38:15.975]                   name <- changed[[kk]]
[17:38:15.975]                   NAME <- NAMES[[kk]]
[17:38:15.975]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.975]                     next
[17:38:15.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:15.975]                 }
[17:38:15.975]                 NAMES <- toupper(added)
[17:38:15.975]                 for (kk in seq_along(NAMES)) {
[17:38:15.975]                   name <- added[[kk]]
[17:38:15.975]                   NAME <- NAMES[[kk]]
[17:38:15.975]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.975]                     next
[17:38:15.975]                   args[[name]] <- ""
[17:38:15.975]                 }
[17:38:15.975]                 NAMES <- toupper(removed)
[17:38:15.975]                 for (kk in seq_along(NAMES)) {
[17:38:15.975]                   name <- removed[[kk]]
[17:38:15.975]                   NAME <- NAMES[[kk]]
[17:38:15.975]                   if (name != NAME && is.element(NAME, old_names)) 
[17:38:15.975]                     next
[17:38:15.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:38:15.975]                 }
[17:38:15.975]                 if (length(args) > 0) 
[17:38:15.975]                   base::do.call(base::Sys.setenv, args = args)
[17:38:15.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:38:15.975]             }
[17:38:15.975]             else {
[17:38:15.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:38:15.975]             }
[17:38:15.975]             {
[17:38:15.975]                 if (base::length(...future.futureOptionsAdded) > 
[17:38:15.975]                   0L) {
[17:38:15.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:38:15.975]                   base::names(opts) <- ...future.futureOptionsAdded
[17:38:15.975]                   base::options(opts)
[17:38:15.975]                 }
[17:38:15.975]                 {
[17:38:15.975]                   {
[17:38:15.975]                     base::options(mc.cores = ...future.mc.cores.old)
[17:38:15.975]                     NULL
[17:38:15.975]                   }
[17:38:15.975]                   options(future.plan = NULL)
[17:38:15.975]                   if (is.na(NA_character_)) 
[17:38:15.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:38:15.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:38:15.975]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:38:15.975]                     .init = FALSE)
[17:38:15.975]                 }
[17:38:15.975]             }
[17:38:15.975]         }
[17:38:15.975]     })
[17:38:15.975]     if (TRUE) {
[17:38:15.975]         base::sink(type = "output", split = FALSE)
[17:38:15.975]         if (TRUE) {
[17:38:15.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:38:15.975]         }
[17:38:15.975]         else {
[17:38:15.975]             ...future.result["stdout"] <- base::list(NULL)
[17:38:15.975]         }
[17:38:15.975]         base::close(...future.stdout)
[17:38:15.975]         ...future.stdout <- NULL
[17:38:15.975]     }
[17:38:15.975]     ...future.result$conditions <- ...future.conditions
[17:38:15.975]     ...future.result$finished <- base::Sys.time()
[17:38:15.975]     ...future.result
[17:38:15.975] }
[17:38:15.978] Exporting 11 global objects (92.90 KiB) to cluster node #2 ...
[17:38:15.978] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:38:16.021] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:38:16.021] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ...
[17:38:16.021] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ... DONE
[17:38:16.022] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:38:16.022] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:38:16.022] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:38:16.065] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:38:16.065] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:38:16.109] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:38:16.109] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:38:16.109] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:38:16.109] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:38:16.110] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:38:16.110] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:38:16.110] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:38:16.111] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:38:16.111] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:38:16.111] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:38:16.111] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:38:16.112] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:38:16.112] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:38:16.112] Exporting 11 global objects (92.90 KiB) to cluster node #2 ... DONE
[17:38:16.113] MultisessionFuture started
[17:38:16.113] - Launch lazy future ... done
[17:38:16.113] run() for ‘MultisessionFuture’ ... done
[17:38:16.113] Created future:
[17:38:16.115] receiveMessageFromWorker() for ClusterFuture ...
[17:38:16.115] - Validating connection of MultisessionFuture
[17:38:16.116] - received message: FutureResult
[17:38:16.116] - Received FutureResult
[17:38:16.116] - Erased future from FutureRegistry
[17:38:16.116] result() for ClusterFuture ...
[17:38:16.116] - result already collected: FutureResult
[17:38:16.116] result() for ClusterFuture ... done
[17:38:16.116] signalConditions() ...
[17:38:16.116]  - include = ‘immediateCondition’
[17:38:16.116]  - exclude = 
[17:38:16.117]  - resignal = FALSE
[17:38:16.117]  - Number of conditions: 1
[17:38:16.117] signalConditions() ... done
[17:38:16.117] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:16.113] MultisessionFuture:
[17:38:16.113] Label: ‘future_vapply-2’
[17:38:16.113] Expression:
[17:38:16.113] {
[17:38:16.113]     do.call(function(...) {
[17:38:16.113]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:38:16.113]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:38:16.113]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:38:16.113]             on.exit(options(oopts), add = TRUE)
[17:38:16.113]         }
[17:38:16.113]         {
[17:38:16.113]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:38:16.113]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:38:16.113]                 ...future.FUN(...future.X_jj, ...)
[17:38:16.113]             })
[17:38:16.113]         }
[17:38:16.113]     }, args = future.call.arguments)
[17:38:16.113] }
[17:38:16.113] Lazy evaluation: FALSE
[17:38:16.113] Asynchronous evaluation: TRUE
[17:38:16.113] Local evaluation: TRUE
[17:38:16.113] Environment: R_GlobalEnv
[17:38:16.113] Capture standard output: TRUE
[17:38:16.113] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:38:16.113] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:38:16.113] Packages: 1 packages (‘future.apply’)
[17:38:16.113] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:38:16.113] Resolved: TRUE
[17:38:16.113] Value: <not collected>
[17:38:16.113] Conditions captured: <none>
[17:38:16.113] Early signaling: FALSE
[17:38:16.113] Owner process: 7b2e57a6-29ff-249c-d564-e8274aa59173
[17:38:16.113] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:38:16.117] Chunk #2 of 2 ... DONE
[17:38:16.117] Launching 2 futures (chunks) ... DONE
[17:38:16.117] Resolving 2 futures (chunks) ...
[17:38:16.117] resolve() on list ...
[17:38:16.117]  recursive: 0
[17:38:16.118]  length: 2
[17:38:16.118] 
[17:38:16.118] receiveMessageFromWorker() for ClusterFuture ...
[17:38:16.118] - Validating connection of MultisessionFuture
[17:38:16.119] - received message: FutureResult
[17:38:16.119] - Received FutureResult
[17:38:16.119] - Erased future from FutureRegistry
[17:38:16.119] result() for ClusterFuture ...
[17:38:16.119] - result already collected: FutureResult
[17:38:16.119] result() for ClusterFuture ... done
[17:38:16.119] signalConditions() ...
[17:38:16.119]  - include = ‘immediateCondition’
[17:38:16.119]  - exclude = 
[17:38:16.119]  - resignal = FALSE
[17:38:16.120]  - Number of conditions: 1
[17:38:16.120] signalConditions() ... done
[17:38:16.120] receiveMessageFromWorker() for ClusterFuture ... done
[17:38:16.120] Future #1
[17:38:16.120] result() for ClusterFuture ...
[17:38:16.120] - result already collected: FutureResult
[17:38:16.120] result() for ClusterFuture ... done
[17:38:16.120] result() for ClusterFuture ...
[17:38:16.120] - result already collected: FutureResult
[17:38:16.120] result() for ClusterFuture ... done
[17:38:16.121] signalConditions() ...
[17:38:16.121]  - include = ‘immediateCondition’
[17:38:16.121]  - exclude = 
[17:38:16.121]  - resignal = FALSE
[17:38:16.121]  - Number of conditions: 1
[17:38:16.121] signalConditions() ... done
[17:38:16.121] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:38:16.121] - nx: 2
[17:38:16.121] - relay: TRUE
[17:38:16.121] - stdout: TRUE
[17:38:16.121] - signal: TRUE
[17:38:16.121] - resignal: FALSE
[17:38:16.122] - force: TRUE
[17:38:16.122] - relayed: [n=2] FALSE, FALSE
[17:38:16.122] - queued futures: [n=2] FALSE, FALSE
[17:38:16.122]  - until=1
[17:38:16.122]  - relaying element #1
[17:38:16.122] result() for ClusterFuture ...
[17:38:16.122] - result already collected: FutureResult
[17:38:16.122] result() for ClusterFuture ... done
[17:38:16.122] result() for ClusterFuture ...
[17:38:16.122] - result already collected: FutureResult
[17:38:16.122] result() for ClusterFuture ... done
[17:38:16.123] signalConditions() ...
[17:38:16.123]  - include = ‘immediateCondition’
[17:38:16.123]  - exclude = 
[17:38:16.123]  - resignal = FALSE
[17:38:16.123]  - Number of conditions: 1
[17:38:16.123] signalConditions() ... done
[17:38:16.123] result() for ClusterFuture ...
[17:38:16.123] - result already collected: FutureResult
[17:38:16.123] result() for ClusterFuture ... done
[17:38:16.123] signalConditions() ...
[17:38:16.123]  - include = ‘immediateCondition’
[17:38:16.124]  - exclude = 
[17:38:16.124]  - resignal = FALSE
[17:38:16.124]  - Number of conditions: 1
[17:38:16.124] signalConditions() ... done
[17:38:16.124] result() for ClusterFuture ...
[17:38:16.124] - result already collected: FutureResult
[17:38:16.124] result() for ClusterFuture ... done
[17:38:16.124] signalConditions() ...
[17:38:16.124]  - include = ‘condition’
[17:38:16.124]  - exclude = ‘immediateCondition’
[17:38:16.124]  - resignal = TRUE
[17:38:16.125]  - Number of conditions: 1
[17:38:16.125]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:38:16.125] signalConditions() ... done
[17:38:16.125] - relayed: [n=2] FALSE, FALSE
[17:38:16.125] - queued futures: [n=2] TRUE, FALSE
[17:38:16.125] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:38:16.125] plan(): Setting new future strategy stack:
[17:38:16.125] List of future strategies:
[17:38:16.125] 1. sequential:
[17:38:16.125]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:16.125]    - tweaked: FALSE
[17:38:16.125]    - call: plan(sequential)
[17:38:16.126] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[17:38:16.127] plan(): Setting new future strategy stack:
[17:38:16.127] List of future strategies:
[17:38:16.127] 1. FutureStrategy:
[17:38:16.127]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:38:16.127]    - tweaked: FALSE
[17:38:16.127]    - call: future::plan(oplan)
[17:38:16.128] plan(): nbrOfWorkers() = 1
> 
