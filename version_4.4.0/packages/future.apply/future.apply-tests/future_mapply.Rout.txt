
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[09:29:14.010] plan(): Setting new future strategy stack:
[09:29:14.010] List of future strategies:
[09:29:14.010] 1. sequential:
[09:29:14.010]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.010]    - tweaked: FALSE
[09:29:14.010]    - call: future::plan("sequential")
[09:29:14.024] plan(): nbrOfWorkers() = 1
> 
> message("*** future_mapply() ...")
*** future_mapply() ...
> 
> message("- Parallel RNG truth (for later)...")
- Parallel RNG truth (for later)...
> plan(sequential)
[09:29:14.032] plan(): Setting new future strategy stack:
[09:29:14.032] List of future strategies:
[09:29:14.032] 1. sequential:
[09:29:14.032]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.032]    - tweaked: FALSE
[09:29:14.032]    - call: plan(sequential)
[09:29:14.042] plan(): nbrOfWorkers() = 1
> y_rng_0 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                          MoreArgs = list(min = 1), future.seed = 0xBEEF)
[09:29:14.043] future_mapply() ...
[09:29:14.043] Generating random seeds ...
[09:29:14.044] Generating random seed streams for 4 elements ...
[09:29:14.044] Generating random seed streams for 4 elements ... DONE
[09:29:14.044] Generating random seeds ... DONE
[09:29:14.044] Will set RNG state on exit: 10407, -2127033937, 556831574, 1526525595, -300945518, -983255142, 56797152
[09:29:14.044] Number of chunks: 1
[09:29:14.045] getGlobalsAndPackagesXApply() ...
[09:29:14.045]  - future.globals: TRUE
[09:29:14.045] getGlobalsAndPackages() ...
[09:29:14.045] Searching for globals...
[09:29:14.050] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[09:29:14.050] Searching for globals ... DONE
[09:29:14.051] Resolving globals: FALSE
[09:29:14.052] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[09:29:14.052] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[09:29:14.052] - globals: [1] ‘FUN’
[09:29:14.052] - packages: [1] ‘stats’
[09:29:14.052] getGlobalsAndPackages() ... DONE
[09:29:14.053]  - globals found/used: [n=1] ‘FUN’
[09:29:14.053]  - needed namespaces: [n=1] ‘stats’
[09:29:14.053] Finding globals ... DONE
[09:29:14.053] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.053] List of 2
[09:29:14.053]  $ ...future.FUN:function (n, min = 0, max = 1)  
[09:29:14.053]  $ MoreArgs     :List of 1
[09:29:14.053]   ..$ min: num 1
[09:29:14.053]  - attr(*, "where")=List of 2
[09:29:14.053]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.053]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.053]  - attr(*, "resolved")= logi FALSE
[09:29:14.053]  - attr(*, "total_size")= num NA
[09:29:14.058] Packages to be attached in all futures: [n=1] ‘stats’
[09:29:14.058] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.058] Number of futures (= number of chunks): 1
[09:29:14.058] Launching 1 futures (chunks) ...
[09:29:14.060] Chunk #1 of 1 ...
[09:29:14.061]  - Finding globals in '...' for chunk #1 ...
[09:29:14.061] getGlobalsAndPackages() ...
[09:29:14.061] Searching for globals...
[09:29:14.061] 
[09:29:14.061] Searching for globals ... DONE
[09:29:14.061] - globals: [0] <none>
[09:29:14.062] getGlobalsAndPackages() ... DONE
[09:29:14.062]    + additional globals found: [n=0] 
[09:29:14.062]    + additional namespaces needed: [n=0] 
[09:29:14.062]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.062]  - seeds: [4] <seeds>
[09:29:14.062]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.062] getGlobalsAndPackages() ...
[09:29:14.062] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.062] Resolving globals: FALSE
[09:29:14.063] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[09:29:14.063] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[09:29:14.064] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.064] - packages: [1] ‘stats’
[09:29:14.064] getGlobalsAndPackages() ... DONE
[09:29:14.064] run() for ‘Future’ ...
[09:29:14.065] - state: ‘created’
[09:29:14.065] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.065] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.065] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.065]   - Field: ‘label’
[09:29:14.065]   - Field: ‘local’
[09:29:14.065]   - Field: ‘owner’
[09:29:14.066]   - Field: ‘envir’
[09:29:14.066]   - Field: ‘packages’
[09:29:14.066]   - Field: ‘gc’
[09:29:14.066]   - Field: ‘conditions’
[09:29:14.066]   - Field: ‘expr’
[09:29:14.066]   - Field: ‘uuid’
[09:29:14.066]   - Field: ‘seed’
[09:29:14.066]   - Field: ‘version’
[09:29:14.066]   - Field: ‘result’
[09:29:14.066]   - Field: ‘asynchronous’
[09:29:14.066]   - Field: ‘calls’
[09:29:14.066]   - Field: ‘globals’
[09:29:14.067]   - Field: ‘stdout’
[09:29:14.067]   - Field: ‘earlySignal’
[09:29:14.067]   - Field: ‘lazy’
[09:29:14.067]   - Field: ‘state’
[09:29:14.067] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.067] - Launch lazy future ...
[09:29:14.068] Packages needed by the future expression (n = 1): ‘stats’
[09:29:14.068] Packages needed by future strategies (n = 0): <none>
[09:29:14.068] {
[09:29:14.068]     {
[09:29:14.068]         {
[09:29:14.068]             ...future.startTime <- base::Sys.time()
[09:29:14.068]             {
[09:29:14.068]                 {
[09:29:14.068]                   {
[09:29:14.068]                     {
[09:29:14.068]                       base::local({
[09:29:14.068]                         has_future <- base::requireNamespace("future", 
[09:29:14.068]                           quietly = TRUE)
[09:29:14.068]                         if (has_future) {
[09:29:14.068]                           ns <- base::getNamespace("future")
[09:29:14.068]                           version <- ns[[".package"]][["version"]]
[09:29:14.068]                           if (is.null(version)) 
[09:29:14.068]                             version <- utils::packageVersion("future")
[09:29:14.068]                         }
[09:29:14.068]                         else {
[09:29:14.068]                           version <- NULL
[09:29:14.068]                         }
[09:29:14.068]                         if (!has_future || version < "1.8.0") {
[09:29:14.068]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.068]                             "", base::R.version$version.string), 
[09:29:14.068]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:14.068]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.068]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.068]                               "release", "version")], collapse = " "), 
[09:29:14.068]                             hostname = base::Sys.info()[["nodename"]])
[09:29:14.068]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.068]                             info)
[09:29:14.068]                           info <- base::paste(info, collapse = "; ")
[09:29:14.068]                           if (!has_future) {
[09:29:14.068]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.068]                               info)
[09:29:14.068]                           }
[09:29:14.068]                           else {
[09:29:14.068]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.068]                               info, version)
[09:29:14.068]                           }
[09:29:14.068]                           base::stop(msg)
[09:29:14.068]                         }
[09:29:14.068]                       })
[09:29:14.068]                     }
[09:29:14.068]                     base::local({
[09:29:14.068]                       for (pkg in "stats") {
[09:29:14.068]                         base::loadNamespace(pkg)
[09:29:14.068]                         base::library(pkg, character.only = TRUE)
[09:29:14.068]                       }
[09:29:14.068]                     })
[09:29:14.068]                   }
[09:29:14.068]                   ...future.strategy.old <- future::plan("list")
[09:29:14.068]                   options(future.plan = NULL)
[09:29:14.068]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.068]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.068]                 }
[09:29:14.068]                 ...future.workdir <- getwd()
[09:29:14.068]             }
[09:29:14.068]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.068]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.068]         }
[09:29:14.068]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.068]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.068]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.068]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.068]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.068]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.068]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.068]             base::names(...future.oldOptions))
[09:29:14.068]     }
[09:29:14.068]     if (FALSE) {
[09:29:14.068]     }
[09:29:14.068]     else {
[09:29:14.068]         if (TRUE) {
[09:29:14.068]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.068]                 open = "w")
[09:29:14.068]         }
[09:29:14.068]         else {
[09:29:14.068]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.068]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.068]         }
[09:29:14.068]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.068]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.068]             base::sink(type = "output", split = FALSE)
[09:29:14.068]             base::close(...future.stdout)
[09:29:14.068]         }, add = TRUE)
[09:29:14.068]     }
[09:29:14.068]     ...future.frame <- base::sys.nframe()
[09:29:14.068]     ...future.conditions <- base::list()
[09:29:14.068]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.068]     if (FALSE) {
[09:29:14.068]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.068]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.068]     }
[09:29:14.068]     ...future.result <- base::tryCatch({
[09:29:14.068]         base::withCallingHandlers({
[09:29:14.068]             ...future.value <- base::withVisible(base::local({
[09:29:14.068]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.068]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.068]                   ...future.globals.maxSize)) {
[09:29:14.068]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.068]                   on.exit(options(oopts), add = TRUE)
[09:29:14.068]                 }
[09:29:14.068]                 {
[09:29:14.068]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:14.068]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[09:29:14.068]                       envir = globalenv(), inherits = FALSE)
[09:29:14.068]                     ...future.FUN(...)
[09:29:14.068]                   }
[09:29:14.068]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:14.068]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:14.068]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.068]                     USE.NAMES = FALSE)
[09:29:14.068]                   do.call(mapply, args = args)
[09:29:14.068]                 }
[09:29:14.068]             }))
[09:29:14.068]             future::FutureResult(value = ...future.value$value, 
[09:29:14.068]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.068]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.068]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.068]                     ...future.globalenv.names))
[09:29:14.068]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.068]         }, condition = base::local({
[09:29:14.068]             c <- base::c
[09:29:14.068]             inherits <- base::inherits
[09:29:14.068]             invokeRestart <- base::invokeRestart
[09:29:14.068]             length <- base::length
[09:29:14.068]             list <- base::list
[09:29:14.068]             seq.int <- base::seq.int
[09:29:14.068]             signalCondition <- base::signalCondition
[09:29:14.068]             sys.calls <- base::sys.calls
[09:29:14.068]             `[[` <- base::`[[`
[09:29:14.068]             `+` <- base::`+`
[09:29:14.068]             `<<-` <- base::`<<-`
[09:29:14.068]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.068]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.068]                   3L)]
[09:29:14.068]             }
[09:29:14.068]             function(cond) {
[09:29:14.068]                 is_error <- inherits(cond, "error")
[09:29:14.068]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.068]                   NULL)
[09:29:14.068]                 if (is_error) {
[09:29:14.068]                   sessionInformation <- function() {
[09:29:14.068]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.068]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.068]                       search = base::search(), system = base::Sys.info())
[09:29:14.068]                   }
[09:29:14.068]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.068]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.068]                     cond$call), session = sessionInformation(), 
[09:29:14.068]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.068]                   signalCondition(cond)
[09:29:14.068]                 }
[09:29:14.068]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.068]                 "immediateCondition"))) {
[09:29:14.068]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.068]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.068]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.068]                   if (TRUE && !signal) {
[09:29:14.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.068]                     {
[09:29:14.068]                       inherits <- base::inherits
[09:29:14.068]                       invokeRestart <- base::invokeRestart
[09:29:14.068]                       is.null <- base::is.null
[09:29:14.068]                       muffled <- FALSE
[09:29:14.068]                       if (inherits(cond, "message")) {
[09:29:14.068]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.068]                         if (muffled) 
[09:29:14.068]                           invokeRestart("muffleMessage")
[09:29:14.068]                       }
[09:29:14.068]                       else if (inherits(cond, "warning")) {
[09:29:14.068]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.068]                         if (muffled) 
[09:29:14.068]                           invokeRestart("muffleWarning")
[09:29:14.068]                       }
[09:29:14.068]                       else if (inherits(cond, "condition")) {
[09:29:14.068]                         if (!is.null(pattern)) {
[09:29:14.068]                           computeRestarts <- base::computeRestarts
[09:29:14.068]                           grepl <- base::grepl
[09:29:14.068]                           restarts <- computeRestarts(cond)
[09:29:14.068]                           for (restart in restarts) {
[09:29:14.068]                             name <- restart$name
[09:29:14.068]                             if (is.null(name)) 
[09:29:14.068]                               next
[09:29:14.068]                             if (!grepl(pattern, name)) 
[09:29:14.068]                               next
[09:29:14.068]                             invokeRestart(restart)
[09:29:14.068]                             muffled <- TRUE
[09:29:14.068]                             break
[09:29:14.068]                           }
[09:29:14.068]                         }
[09:29:14.068]                       }
[09:29:14.068]                       invisible(muffled)
[09:29:14.068]                     }
[09:29:14.068]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.068]                   }
[09:29:14.068]                 }
[09:29:14.068]                 else {
[09:29:14.068]                   if (TRUE) {
[09:29:14.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.068]                     {
[09:29:14.068]                       inherits <- base::inherits
[09:29:14.068]                       invokeRestart <- base::invokeRestart
[09:29:14.068]                       is.null <- base::is.null
[09:29:14.068]                       muffled <- FALSE
[09:29:14.068]                       if (inherits(cond, "message")) {
[09:29:14.068]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.068]                         if (muffled) 
[09:29:14.068]                           invokeRestart("muffleMessage")
[09:29:14.068]                       }
[09:29:14.068]                       else if (inherits(cond, "warning")) {
[09:29:14.068]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.068]                         if (muffled) 
[09:29:14.068]                           invokeRestart("muffleWarning")
[09:29:14.068]                       }
[09:29:14.068]                       else if (inherits(cond, "condition")) {
[09:29:14.068]                         if (!is.null(pattern)) {
[09:29:14.068]                           computeRestarts <- base::computeRestarts
[09:29:14.068]                           grepl <- base::grepl
[09:29:14.068]                           restarts <- computeRestarts(cond)
[09:29:14.068]                           for (restart in restarts) {
[09:29:14.068]                             name <- restart$name
[09:29:14.068]                             if (is.null(name)) 
[09:29:14.068]                               next
[09:29:14.068]                             if (!grepl(pattern, name)) 
[09:29:14.068]                               next
[09:29:14.068]                             invokeRestart(restart)
[09:29:14.068]                             muffled <- TRUE
[09:29:14.068]                             break
[09:29:14.068]                           }
[09:29:14.068]                         }
[09:29:14.068]                       }
[09:29:14.068]                       invisible(muffled)
[09:29:14.068]                     }
[09:29:14.068]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.068]                   }
[09:29:14.068]                 }
[09:29:14.068]             }
[09:29:14.068]         }))
[09:29:14.068]     }, error = function(ex) {
[09:29:14.068]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.068]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.068]                 ...future.rng), started = ...future.startTime, 
[09:29:14.068]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.068]             version = "1.8"), class = "FutureResult")
[09:29:14.068]     }, finally = {
[09:29:14.068]         if (!identical(...future.workdir, getwd())) 
[09:29:14.068]             setwd(...future.workdir)
[09:29:14.068]         {
[09:29:14.068]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.068]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.068]             }
[09:29:14.068]             base::options(...future.oldOptions)
[09:29:14.068]             if (.Platform$OS.type == "windows") {
[09:29:14.068]                 old_names <- names(...future.oldEnvVars)
[09:29:14.068]                 envs <- base::Sys.getenv()
[09:29:14.068]                 names <- names(envs)
[09:29:14.068]                 common <- intersect(names, old_names)
[09:29:14.068]                 added <- setdiff(names, old_names)
[09:29:14.068]                 removed <- setdiff(old_names, names)
[09:29:14.068]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.068]                   envs[common]]
[09:29:14.068]                 NAMES <- toupper(changed)
[09:29:14.068]                 args <- list()
[09:29:14.068]                 for (kk in seq_along(NAMES)) {
[09:29:14.068]                   name <- changed[[kk]]
[09:29:14.068]                   NAME <- NAMES[[kk]]
[09:29:14.068]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.068]                     next
[09:29:14.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.068]                 }
[09:29:14.068]                 NAMES <- toupper(added)
[09:29:14.068]                 for (kk in seq_along(NAMES)) {
[09:29:14.068]                   name <- added[[kk]]
[09:29:14.068]                   NAME <- NAMES[[kk]]
[09:29:14.068]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.068]                     next
[09:29:14.068]                   args[[name]] <- ""
[09:29:14.068]                 }
[09:29:14.068]                 NAMES <- toupper(removed)
[09:29:14.068]                 for (kk in seq_along(NAMES)) {
[09:29:14.068]                   name <- removed[[kk]]
[09:29:14.068]                   NAME <- NAMES[[kk]]
[09:29:14.068]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.068]                     next
[09:29:14.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.068]                 }
[09:29:14.068]                 if (length(args) > 0) 
[09:29:14.068]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.068]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.068]             }
[09:29:14.068]             else {
[09:29:14.068]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.068]             }
[09:29:14.068]             {
[09:29:14.068]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.068]                   0L) {
[09:29:14.068]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.068]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.068]                   base::options(opts)
[09:29:14.068]                 }
[09:29:14.068]                 {
[09:29:14.068]                   {
[09:29:14.068]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.068]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.068]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.068]                     NULL
[09:29:14.068]                   }
[09:29:14.068]                   options(future.plan = NULL)
[09:29:14.068]                   if (is.na(NA_character_)) 
[09:29:14.068]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.068]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.068]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.068]                     .init = FALSE)
[09:29:14.068]                 }
[09:29:14.068]             }
[09:29:14.068]         }
[09:29:14.068]     })
[09:29:14.068]     if (TRUE) {
[09:29:14.068]         base::sink(type = "output", split = FALSE)
[09:29:14.068]         if (TRUE) {
[09:29:14.068]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.068]         }
[09:29:14.068]         else {
[09:29:14.068]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.068]         }
[09:29:14.068]         base::close(...future.stdout)
[09:29:14.068]         ...future.stdout <- NULL
[09:29:14.068]     }
[09:29:14.068]     ...future.result$conditions <- ...future.conditions
[09:29:14.068]     ...future.result$finished <- base::Sys.time()
[09:29:14.068]     ...future.result
[09:29:14.068] }
[09:29:14.070] assign_globals() ...
[09:29:14.070] List of 5
[09:29:14.070]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[09:29:14.070]  $ MoreArgs                 :List of 1
[09:29:14.070]   ..$ min: num 1
[09:29:14.070]  $ ...future.elements_ii    :List of 2
[09:29:14.070]   ..$ n  :List of 4
[09:29:14.070]   .. ..$ : int 1
[09:29:14.070]   .. ..$ : int 2
[09:29:14.070]   .. ..$ : int 3
[09:29:14.070]   .. ..$ : int 4
[09:29:14.070]   ..$ max:List of 4
[09:29:14.070]   .. ..$ : int 2
[09:29:14.070]   .. ..$ : int 3
[09:29:14.070]   .. ..$ : int 4
[09:29:14.070]   .. ..$ : int 5
[09:29:14.070]  $ ...future.seeds_ii       :List of 4
[09:29:14.070]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[09:29:14.070]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[09:29:14.070]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[09:29:14.070]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[09:29:14.070]  $ ...future.globals.maxSize: NULL
[09:29:14.070]  - attr(*, "where")=List of 5
[09:29:14.070]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.070]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.070]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.070]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.070]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.070]  - attr(*, "resolved")= logi FALSE
[09:29:14.070]  - attr(*, "total_size")= num 2912
[09:29:14.070]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.070]  - attr(*, "already-done")= logi TRUE
[09:29:14.078] - copied ‘...future.FUN’ to environment
[09:29:14.078] - copied ‘MoreArgs’ to environment
[09:29:14.078] - copied ‘...future.elements_ii’ to environment
[09:29:14.079] - copied ‘...future.seeds_ii’ to environment
[09:29:14.079] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.079] assign_globals() ... done
[09:29:14.079] plan(): Setting new future strategy stack:
[09:29:14.079] List of future strategies:
[09:29:14.079] 1. sequential:
[09:29:14.079]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.079]    - tweaked: FALSE
[09:29:14.079]    - call: NULL
[09:29:14.080] plan(): nbrOfWorkers() = 1
[09:29:14.081] plan(): Setting new future strategy stack:
[09:29:14.081] List of future strategies:
[09:29:14.081] 1. sequential:
[09:29:14.081]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.081]    - tweaked: FALSE
[09:29:14.081]    - call: plan(sequential)
[09:29:14.081] plan(): nbrOfWorkers() = 1
[09:29:14.081] SequentialFuture started (and completed)
[09:29:14.082] - Launch lazy future ... done
[09:29:14.082] run() for ‘SequentialFuture’ ... done
[09:29:14.082] Created future:
[09:29:14.082] SequentialFuture:
[09:29:14.082] Label: ‘future_mapply-1’
[09:29:14.082] Expression:
[09:29:14.082] {
[09:29:14.082]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.082]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.082]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.082]         on.exit(options(oopts), add = TRUE)
[09:29:14.082]     }
[09:29:14.082]     {
[09:29:14.082]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:14.082]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[09:29:14.082]                 inherits = FALSE)
[09:29:14.082]             ...future.FUN(...)
[09:29:14.082]         }
[09:29:14.082]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:14.082]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:14.082]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.082]         do.call(mapply, args = args)
[09:29:14.082]     }
[09:29:14.082] }
[09:29:14.082] Lazy evaluation: FALSE
[09:29:14.082] Asynchronous evaluation: FALSE
[09:29:14.082] Local evaluation: TRUE
[09:29:14.082] Environment: R_GlobalEnv
[09:29:14.082] Capture standard output: TRUE
[09:29:14.082] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.082] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.082] Packages: 1 packages (‘stats’)
[09:29:14.082] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:29:14.082] Resolved: TRUE
[09:29:14.082] Value: 280 bytes of class ‘list’
[09:29:14.082] Early signaling: FALSE
[09:29:14.082] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.082] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.084] Chunk #1 of 1 ... DONE
[09:29:14.084] Launching 1 futures (chunks) ... DONE
[09:29:14.084] Resolving 1 futures (chunks) ...
[09:29:14.084] resolve() on list ...
[09:29:14.084]  recursive: 0
[09:29:14.084]  length: 1
[09:29:14.085] 
[09:29:14.085] resolved() for ‘SequentialFuture’ ...
[09:29:14.085] - state: ‘finished’
[09:29:14.085] - run: TRUE
[09:29:14.085] - result: ‘FutureResult’
[09:29:14.085] resolved() for ‘SequentialFuture’ ... done
[09:29:14.085] Future #1
[09:29:14.086] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.086] - nx: 1
[09:29:14.086] - relay: TRUE
[09:29:14.086] - stdout: TRUE
[09:29:14.086] - signal: TRUE
[09:29:14.086] - resignal: FALSE
[09:29:14.086] - force: TRUE
[09:29:14.086] - relayed: [n=1] FALSE
[09:29:14.086] - queued futures: [n=1] FALSE
[09:29:14.086]  - until=1
[09:29:14.086]  - relaying element #1
[09:29:14.087] - relayed: [n=1] TRUE
[09:29:14.087] - queued futures: [n=1] TRUE
[09:29:14.087] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.087]  length: 0 (resolved future 1)
[09:29:14.087] Relaying remaining futures
[09:29:14.087] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.087] - nx: 1
[09:29:14.087] - relay: TRUE
[09:29:14.087] - stdout: TRUE
[09:29:14.087] - signal: TRUE
[09:29:14.087] - resignal: FALSE
[09:29:14.088] - force: TRUE
[09:29:14.088] - relayed: [n=1] TRUE
[09:29:14.088] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.088] - relayed: [n=1] TRUE
[09:29:14.088] - queued futures: [n=1] TRUE
[09:29:14.088] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.088] resolve() on list ... DONE
[09:29:14.088]  - Number of value chunks collected: 1
[09:29:14.088] Resolving 1 futures (chunks) ... DONE
[09:29:14.088] Reducing values from 1 chunks ...
[09:29:14.089]  - Number of values collected after concatenation: 4
[09:29:14.089]  - Number of values expected: 4
[09:29:14.089] Reducing values from 1 chunks ... DONE
[09:29:14.089] future_mapply() ... DONE
> print(y_rng_0)
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(mapply) ...")
+   y0 <- mapply(rep, 1:4, 4:1)
+   y1 <- future_mapply(rep, 1:4, 4:1)
+   stopifnot(identical(y1, y0))
+   y2 <- future_mapply("rep", 1:4, 4:1)
+   stopifnot(identical(y2, y0))
+   
+   y0 <- mapply(rep, times = 1:4, x = 4:1)
+   y1 <- future_mapply(rep, times = 1:4, x = 4:1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   y1 <- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(function(x, y) seq_len(x) + y,
+                c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y1 <- future_mapply(function(x, y) seq_len(x) + y,
+                       c(a =  1, b = 2, c = 3),  # names from first
+                       c(A = 10, B = 0, C = -10))
+   stopifnot(identical(y1, y0))
+ 
+   message("- future_.mapply()")
+   dots <- list(c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y2 <- .mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   names(y0) <- NULL  ## .mapply() don't set names
+   stopifnot(all.equal(y2, y0))
+   y3 <- future_.mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   stopifnot(all.equal(y3, y2))
+ 
+   word <- function(C, k) paste(rep.int(C, k), collapse = "")
+   for (chunk.size in list(1L, structure(2L, ordering = "random"), structure(3L, ordering = 5:1))) {
+     y0 <- mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE)
+     y1 <- future_mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE, future.chunk.size = chunk.size)
+     stopifnot(identical(y1, y0))
+ 
+     dots <- list(LETTERS[1:5], 5:1)
+     MoreArgs <- list()
+     y2 <- .mapply(word, dots = dots, MoreArgs = list())
+     names(y0) <- NULL  ## .mapply() don't set names
+     stopifnot(all.equal(y2, y0))
+     y3 <- future_.mapply(word, dots = dots, MoreArgs = list())
+     stopifnot(all.equal(y3, y2))
+   }
+ 
+   message("- Subsetting (Issue #17) ...")
+   X <- as.Date("2018-06-01")
+   y0 <- mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   y1 <- future_mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   stopifnot(identical(y1, y0))
+ 
+   dots <- list(X)
+   y2 <- .mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y2, y0))
+   y3 <- future_.mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y3, y2))
+ 
+   message("- Non-recycling of MoreArgs (Issue #51) ...")
+   y0 <- base::mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4)
+   )
+   y1 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = FALSE
+   )
+   stopifnot(identical(y1, y0))
+   y2 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = TRUE
+   )
+   stopifnot(identical(y2, y0))
+ 
+   dots <- list(x = 1:2)
+   MoreArgs <- list(y = 3:4)
+   y3 <- .mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   y4 <- future_.mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y4, y3))
+ 
+   message("- Recycle arguments to same length ...")
+   y0 <- mapply(rep, 1:4, 2:1)
+   y1 <- future_mapply(rep, 1:4, 2:1)
+   stopifnot(identical(y1, y0))
+ 
+   
+   message("- Parallel RNG ...")
+   y_rng_1 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                            MoreArgs = list(min = 1), future.seed = 0xBEEF)
+   print(y_rng_1)
+   stopifnot(all.equal(y_rng_1, y_rng_0))
+ 
+   message("- future_Map() ...")
+   xs <- replicate(5, stats::runif(10), simplify = FALSE)
+   ws <- replicate(5, stats::rpois(10, 5) + 1, simplify = FALSE)
+   y0 <- Map(weighted.mean, xs, ws)
+   y1 <- future_Map(stats::weighted.mean, xs, ws)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_mapply() - 'max-or-0-if' recycling rule ...")
+   ## R (>= 4.2.0): mapply() & Map() follow usual "max-or-0-if" recycling rule
+   ## and keeps returning a named list in the "empty" case.
+   
+   truth <- list()
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(`+`, 1:3, NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(`+`, 1:3, NULL)
+   stopifnot(identical(y, truth))
+   
+   truth <- setNames(list(), character())
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character())
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character()) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character()) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+ 
+   ## Gives an error in R-devel (2021-11-26 r81252)
+   if (getRversion() >= "4.2.0" && FALSE) {
+     y0 <- mapply(paste, c(a = "A"), character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, c(a = "A"), character())
+   stopifnot(identical(y, truth))
+ 
+   ## R (>= 4.2.0): Map() now recycles similar to basic Ops:
+   truth <- as.list(1 + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, 1, 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, 1, 1:3)
+   stopifnot(identical(y, truth))
+   
+   truth <- as.list(numeric() + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, numeric(), 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, numeric(), 1:3)
+   stopifnot(identical(y, truth))
+ 
+   message("- future_mapply(x, ...) where x[[i]] subsets via S3 method ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   `[[.Foo` <- function(x, ...) 0
+   y0 <- mapply(x, FUN = identity)
+   stopifnot(identical(y0, c(a = 0, b = 0)))
+   y1 <- future_mapply(x, FUN = identity)
+   if (getOption("future.apply.chunkWith", "[[") == "[") {
+     stopifnot(identical(y1, unlist(x)))
+   } else {
+     stopifnot(identical(y1, y0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[09:29:14.238] plan(): Setting new future strategy stack:
[09:29:14.238] List of future strategies:
[09:29:14.238] 1. sequential:
[09:29:14.238]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.238]    - tweaked: FALSE
[09:29:14.238]    - call: plan(strategy)
[09:29:14.238] plan(): nbrOfWorkers() = 1
- From example(mapply) ...
[09:29:14.239] future_mapply() ...
[09:29:14.239] Number of chunks: 1
[09:29:14.239] getGlobalsAndPackagesXApply() ...
[09:29:14.239]  - future.globals: TRUE
[09:29:14.239] getGlobalsAndPackages() ...
[09:29:14.239] Searching for globals...
[09:29:14.240] - globals found: [1] ‘FUN’
[09:29:14.240] Searching for globals ... DONE
[09:29:14.240] Resolving globals: FALSE
[09:29:14.240] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:14.240] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:14.241] - globals: [1] ‘FUN’
[09:29:14.241] 
[09:29:14.241] getGlobalsAndPackages() ... DONE
[09:29:14.241]  - globals found/used: [n=1] ‘FUN’
[09:29:14.241]  - needed namespaces: [n=0] 
[09:29:14.241] Finding globals ... DONE
[09:29:14.241] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.241] List of 2
[09:29:14.241]  $ ...future.FUN:function (x, ...)  
[09:29:14.241]  $ MoreArgs     : NULL
[09:29:14.241]  - attr(*, "where")=List of 2
[09:29:14.241]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.241]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.241]  - attr(*, "resolved")= logi FALSE
[09:29:14.241]  - attr(*, "total_size")= num NA
[09:29:14.244] Packages to be attached in all futures: [n=0] 
[09:29:14.244] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.244] Number of futures (= number of chunks): 1
[09:29:14.244] Launching 1 futures (chunks) ...
[09:29:14.244] Chunk #1 of 1 ...
[09:29:14.244]  - Finding globals in '...' for chunk #1 ...
[09:29:14.244] getGlobalsAndPackages() ...
[09:29:14.244] Searching for globals...
[09:29:14.245] 
[09:29:14.245] Searching for globals ... DONE
[09:29:14.245] - globals: [0] <none>
[09:29:14.245] getGlobalsAndPackages() ... DONE
[09:29:14.245]    + additional globals found: [n=0] 
[09:29:14.245]    + additional namespaces needed: [n=0] 
[09:29:14.245]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.245]  - seeds: <none>
[09:29:14.245]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.246] getGlobalsAndPackages() ...
[09:29:14.246] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.246] Resolving globals: FALSE
[09:29:14.246] The total size of the 5 globals is 504 bytes (504 bytes)
[09:29:14.247] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.247] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.247] 
[09:29:14.247] getGlobalsAndPackages() ... DONE
[09:29:14.247] run() for ‘Future’ ...
[09:29:14.247] - state: ‘created’
[09:29:14.247] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.248] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.248] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.248]   - Field: ‘label’
[09:29:14.248]   - Field: ‘local’
[09:29:14.248]   - Field: ‘owner’
[09:29:14.248]   - Field: ‘envir’
[09:29:14.248]   - Field: ‘packages’
[09:29:14.248]   - Field: ‘gc’
[09:29:14.248]   - Field: ‘conditions’
[09:29:14.249]   - Field: ‘expr’
[09:29:14.249]   - Field: ‘uuid’
[09:29:14.249]   - Field: ‘seed’
[09:29:14.249]   - Field: ‘version’
[09:29:14.249]   - Field: ‘result’
[09:29:14.249]   - Field: ‘asynchronous’
[09:29:14.249]   - Field: ‘calls’
[09:29:14.249]   - Field: ‘globals’
[09:29:14.249]   - Field: ‘stdout’
[09:29:14.249]   - Field: ‘earlySignal’
[09:29:14.249]   - Field: ‘lazy’
[09:29:14.250]   - Field: ‘state’
[09:29:14.250] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.250] - Launch lazy future ...
[09:29:14.250] Packages needed by the future expression (n = 0): <none>
[09:29:14.250] Packages needed by future strategies (n = 0): <none>
[09:29:14.251] {
[09:29:14.251]     {
[09:29:14.251]         {
[09:29:14.251]             ...future.startTime <- base::Sys.time()
[09:29:14.251]             {
[09:29:14.251]                 {
[09:29:14.251]                   {
[09:29:14.251]                     base::local({
[09:29:14.251]                       has_future <- base::requireNamespace("future", 
[09:29:14.251]                         quietly = TRUE)
[09:29:14.251]                       if (has_future) {
[09:29:14.251]                         ns <- base::getNamespace("future")
[09:29:14.251]                         version <- ns[[".package"]][["version"]]
[09:29:14.251]                         if (is.null(version)) 
[09:29:14.251]                           version <- utils::packageVersion("future")
[09:29:14.251]                       }
[09:29:14.251]                       else {
[09:29:14.251]                         version <- NULL
[09:29:14.251]                       }
[09:29:14.251]                       if (!has_future || version < "1.8.0") {
[09:29:14.251]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.251]                           "", base::R.version$version.string), 
[09:29:14.251]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.251]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.251]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.251]                             "release", "version")], collapse = " "), 
[09:29:14.251]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.251]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.251]                           info)
[09:29:14.251]                         info <- base::paste(info, collapse = "; ")
[09:29:14.251]                         if (!has_future) {
[09:29:14.251]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.251]                             info)
[09:29:14.251]                         }
[09:29:14.251]                         else {
[09:29:14.251]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.251]                             info, version)
[09:29:14.251]                         }
[09:29:14.251]                         base::stop(msg)
[09:29:14.251]                       }
[09:29:14.251]                     })
[09:29:14.251]                   }
[09:29:14.251]                   ...future.strategy.old <- future::plan("list")
[09:29:14.251]                   options(future.plan = NULL)
[09:29:14.251]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.251]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.251]                 }
[09:29:14.251]                 ...future.workdir <- getwd()
[09:29:14.251]             }
[09:29:14.251]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.251]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.251]         }
[09:29:14.251]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.251]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.251]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.251]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.251]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.251]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.251]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.251]             base::names(...future.oldOptions))
[09:29:14.251]     }
[09:29:14.251]     if (FALSE) {
[09:29:14.251]     }
[09:29:14.251]     else {
[09:29:14.251]         if (TRUE) {
[09:29:14.251]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.251]                 open = "w")
[09:29:14.251]         }
[09:29:14.251]         else {
[09:29:14.251]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.251]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.251]         }
[09:29:14.251]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.251]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.251]             base::sink(type = "output", split = FALSE)
[09:29:14.251]             base::close(...future.stdout)
[09:29:14.251]         }, add = TRUE)
[09:29:14.251]     }
[09:29:14.251]     ...future.frame <- base::sys.nframe()
[09:29:14.251]     ...future.conditions <- base::list()
[09:29:14.251]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.251]     if (FALSE) {
[09:29:14.251]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.251]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.251]     }
[09:29:14.251]     ...future.result <- base::tryCatch({
[09:29:14.251]         base::withCallingHandlers({
[09:29:14.251]             ...future.value <- base::withVisible(base::local({
[09:29:14.251]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.251]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.251]                   ...future.globals.maxSize)) {
[09:29:14.251]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.251]                   on.exit(options(oopts), add = TRUE)
[09:29:14.251]                 }
[09:29:14.251]                 {
[09:29:14.251]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.251]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.251]                     USE.NAMES = FALSE)
[09:29:14.251]                   do.call(mapply, args = args)
[09:29:14.251]                 }
[09:29:14.251]             }))
[09:29:14.251]             future::FutureResult(value = ...future.value$value, 
[09:29:14.251]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.251]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.251]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.251]                     ...future.globalenv.names))
[09:29:14.251]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.251]         }, condition = base::local({
[09:29:14.251]             c <- base::c
[09:29:14.251]             inherits <- base::inherits
[09:29:14.251]             invokeRestart <- base::invokeRestart
[09:29:14.251]             length <- base::length
[09:29:14.251]             list <- base::list
[09:29:14.251]             seq.int <- base::seq.int
[09:29:14.251]             signalCondition <- base::signalCondition
[09:29:14.251]             sys.calls <- base::sys.calls
[09:29:14.251]             `[[` <- base::`[[`
[09:29:14.251]             `+` <- base::`+`
[09:29:14.251]             `<<-` <- base::`<<-`
[09:29:14.251]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.251]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.251]                   3L)]
[09:29:14.251]             }
[09:29:14.251]             function(cond) {
[09:29:14.251]                 is_error <- inherits(cond, "error")
[09:29:14.251]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.251]                   NULL)
[09:29:14.251]                 if (is_error) {
[09:29:14.251]                   sessionInformation <- function() {
[09:29:14.251]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.251]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.251]                       search = base::search(), system = base::Sys.info())
[09:29:14.251]                   }
[09:29:14.251]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.251]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.251]                     cond$call), session = sessionInformation(), 
[09:29:14.251]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.251]                   signalCondition(cond)
[09:29:14.251]                 }
[09:29:14.251]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.251]                 "immediateCondition"))) {
[09:29:14.251]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.251]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.251]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.251]                   if (TRUE && !signal) {
[09:29:14.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.251]                     {
[09:29:14.251]                       inherits <- base::inherits
[09:29:14.251]                       invokeRestart <- base::invokeRestart
[09:29:14.251]                       is.null <- base::is.null
[09:29:14.251]                       muffled <- FALSE
[09:29:14.251]                       if (inherits(cond, "message")) {
[09:29:14.251]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.251]                         if (muffled) 
[09:29:14.251]                           invokeRestart("muffleMessage")
[09:29:14.251]                       }
[09:29:14.251]                       else if (inherits(cond, "warning")) {
[09:29:14.251]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.251]                         if (muffled) 
[09:29:14.251]                           invokeRestart("muffleWarning")
[09:29:14.251]                       }
[09:29:14.251]                       else if (inherits(cond, "condition")) {
[09:29:14.251]                         if (!is.null(pattern)) {
[09:29:14.251]                           computeRestarts <- base::computeRestarts
[09:29:14.251]                           grepl <- base::grepl
[09:29:14.251]                           restarts <- computeRestarts(cond)
[09:29:14.251]                           for (restart in restarts) {
[09:29:14.251]                             name <- restart$name
[09:29:14.251]                             if (is.null(name)) 
[09:29:14.251]                               next
[09:29:14.251]                             if (!grepl(pattern, name)) 
[09:29:14.251]                               next
[09:29:14.251]                             invokeRestart(restart)
[09:29:14.251]                             muffled <- TRUE
[09:29:14.251]                             break
[09:29:14.251]                           }
[09:29:14.251]                         }
[09:29:14.251]                       }
[09:29:14.251]                       invisible(muffled)
[09:29:14.251]                     }
[09:29:14.251]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.251]                   }
[09:29:14.251]                 }
[09:29:14.251]                 else {
[09:29:14.251]                   if (TRUE) {
[09:29:14.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.251]                     {
[09:29:14.251]                       inherits <- base::inherits
[09:29:14.251]                       invokeRestart <- base::invokeRestart
[09:29:14.251]                       is.null <- base::is.null
[09:29:14.251]                       muffled <- FALSE
[09:29:14.251]                       if (inherits(cond, "message")) {
[09:29:14.251]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.251]                         if (muffled) 
[09:29:14.251]                           invokeRestart("muffleMessage")
[09:29:14.251]                       }
[09:29:14.251]                       else if (inherits(cond, "warning")) {
[09:29:14.251]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.251]                         if (muffled) 
[09:29:14.251]                           invokeRestart("muffleWarning")
[09:29:14.251]                       }
[09:29:14.251]                       else if (inherits(cond, "condition")) {
[09:29:14.251]                         if (!is.null(pattern)) {
[09:29:14.251]                           computeRestarts <- base::computeRestarts
[09:29:14.251]                           grepl <- base::grepl
[09:29:14.251]                           restarts <- computeRestarts(cond)
[09:29:14.251]                           for (restart in restarts) {
[09:29:14.251]                             name <- restart$name
[09:29:14.251]                             if (is.null(name)) 
[09:29:14.251]                               next
[09:29:14.251]                             if (!grepl(pattern, name)) 
[09:29:14.251]                               next
[09:29:14.251]                             invokeRestart(restart)
[09:29:14.251]                             muffled <- TRUE
[09:29:14.251]                             break
[09:29:14.251]                           }
[09:29:14.251]                         }
[09:29:14.251]                       }
[09:29:14.251]                       invisible(muffled)
[09:29:14.251]                     }
[09:29:14.251]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.251]                   }
[09:29:14.251]                 }
[09:29:14.251]             }
[09:29:14.251]         }))
[09:29:14.251]     }, error = function(ex) {
[09:29:14.251]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.251]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.251]                 ...future.rng), started = ...future.startTime, 
[09:29:14.251]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.251]             version = "1.8"), class = "FutureResult")
[09:29:14.251]     }, finally = {
[09:29:14.251]         if (!identical(...future.workdir, getwd())) 
[09:29:14.251]             setwd(...future.workdir)
[09:29:14.251]         {
[09:29:14.251]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.251]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.251]             }
[09:29:14.251]             base::options(...future.oldOptions)
[09:29:14.251]             if (.Platform$OS.type == "windows") {
[09:29:14.251]                 old_names <- names(...future.oldEnvVars)
[09:29:14.251]                 envs <- base::Sys.getenv()
[09:29:14.251]                 names <- names(envs)
[09:29:14.251]                 common <- intersect(names, old_names)
[09:29:14.251]                 added <- setdiff(names, old_names)
[09:29:14.251]                 removed <- setdiff(old_names, names)
[09:29:14.251]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.251]                   envs[common]]
[09:29:14.251]                 NAMES <- toupper(changed)
[09:29:14.251]                 args <- list()
[09:29:14.251]                 for (kk in seq_along(NAMES)) {
[09:29:14.251]                   name <- changed[[kk]]
[09:29:14.251]                   NAME <- NAMES[[kk]]
[09:29:14.251]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.251]                     next
[09:29:14.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.251]                 }
[09:29:14.251]                 NAMES <- toupper(added)
[09:29:14.251]                 for (kk in seq_along(NAMES)) {
[09:29:14.251]                   name <- added[[kk]]
[09:29:14.251]                   NAME <- NAMES[[kk]]
[09:29:14.251]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.251]                     next
[09:29:14.251]                   args[[name]] <- ""
[09:29:14.251]                 }
[09:29:14.251]                 NAMES <- toupper(removed)
[09:29:14.251]                 for (kk in seq_along(NAMES)) {
[09:29:14.251]                   name <- removed[[kk]]
[09:29:14.251]                   NAME <- NAMES[[kk]]
[09:29:14.251]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.251]                     next
[09:29:14.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.251]                 }
[09:29:14.251]                 if (length(args) > 0) 
[09:29:14.251]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.251]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.251]             }
[09:29:14.251]             else {
[09:29:14.251]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.251]             }
[09:29:14.251]             {
[09:29:14.251]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.251]                   0L) {
[09:29:14.251]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.251]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.251]                   base::options(opts)
[09:29:14.251]                 }
[09:29:14.251]                 {
[09:29:14.251]                   {
[09:29:14.251]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.251]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.251]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.251]                     NULL
[09:29:14.251]                   }
[09:29:14.251]                   options(future.plan = NULL)
[09:29:14.251]                   if (is.na(NA_character_)) 
[09:29:14.251]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.251]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.251]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.251]                     .init = FALSE)
[09:29:14.251]                 }
[09:29:14.251]             }
[09:29:14.251]         }
[09:29:14.251]     })
[09:29:14.251]     if (TRUE) {
[09:29:14.251]         base::sink(type = "output", split = FALSE)
[09:29:14.251]         if (TRUE) {
[09:29:14.251]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.251]         }
[09:29:14.251]         else {
[09:29:14.251]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.251]         }
[09:29:14.251]         base::close(...future.stdout)
[09:29:14.251]         ...future.stdout <- NULL
[09:29:14.251]     }
[09:29:14.251]     ...future.result$conditions <- ...future.conditions
[09:29:14.251]     ...future.result$finished <- base::Sys.time()
[09:29:14.251]     ...future.result
[09:29:14.251] }
[09:29:14.253] assign_globals() ...
[09:29:14.253] List of 5
[09:29:14.253]  $ ...future.FUN            :function (x, ...)  
[09:29:14.253]  $ MoreArgs                 : NULL
[09:29:14.253]  $ ...future.elements_ii    :List of 2
[09:29:14.253]   ..$ :List of 4
[09:29:14.253]   .. ..$ : int 1
[09:29:14.253]   .. ..$ : int 2
[09:29:14.253]   .. ..$ : int 3
[09:29:14.253]   .. ..$ : int 4
[09:29:14.253]   ..$ :List of 4
[09:29:14.253]   .. ..$ : int 4
[09:29:14.253]   .. ..$ : int 3
[09:29:14.253]   .. ..$ : int 2
[09:29:14.253]   .. ..$ : int 1
[09:29:14.253]  $ ...future.seeds_ii       : NULL
[09:29:14.253]  $ ...future.globals.maxSize: NULL
[09:29:14.253]  - attr(*, "where")=List of 5
[09:29:14.253]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.253]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.253]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.253]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.253]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.253]  - attr(*, "resolved")= logi FALSE
[09:29:14.253]  - attr(*, "total_size")= num 504
[09:29:14.253]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.253]  - attr(*, "already-done")= logi TRUE
[09:29:14.259] - copied ‘...future.FUN’ to environment
[09:29:14.259] - copied ‘MoreArgs’ to environment
[09:29:14.259] - copied ‘...future.elements_ii’ to environment
[09:29:14.260] - copied ‘...future.seeds_ii’ to environment
[09:29:14.260] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.260] assign_globals() ... done
[09:29:14.260] plan(): Setting new future strategy stack:
[09:29:14.260] List of future strategies:
[09:29:14.260] 1. sequential:
[09:29:14.260]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.260]    - tweaked: FALSE
[09:29:14.260]    - call: NULL
[09:29:14.260] plan(): nbrOfWorkers() = 1
[09:29:14.261] plan(): Setting new future strategy stack:
[09:29:14.261] List of future strategies:
[09:29:14.261] 1. sequential:
[09:29:14.261]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.261]    - tweaked: FALSE
[09:29:14.261]    - call: plan(strategy)
[09:29:14.262] plan(): nbrOfWorkers() = 1
[09:29:14.262] SequentialFuture started (and completed)
[09:29:14.262] - Launch lazy future ... done
[09:29:14.262] run() for ‘SequentialFuture’ ... done
[09:29:14.262] Created future:
[09:29:14.262] SequentialFuture:
[09:29:14.262] Label: ‘future_mapply-1’
[09:29:14.262] Expression:
[09:29:14.262] {
[09:29:14.262]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.262]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.262]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.262]         on.exit(options(oopts), add = TRUE)
[09:29:14.262]     }
[09:29:14.262]     {
[09:29:14.262]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.262]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.262]         do.call(mapply, args = args)
[09:29:14.262]     }
[09:29:14.262] }
[09:29:14.262] Lazy evaluation: FALSE
[09:29:14.262] Asynchronous evaluation: FALSE
[09:29:14.262] Local evaluation: TRUE
[09:29:14.262] Environment: R_GlobalEnv
[09:29:14.262] Capture standard output: TRUE
[09:29:14.262] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.262] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.262] Packages: <none>
[09:29:14.262] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.262] Resolved: TRUE
[09:29:14.262] Value: 240 bytes of class ‘list’
[09:29:14.262] Early signaling: FALSE
[09:29:14.262] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.262] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.263] Chunk #1 of 1 ... DONE
[09:29:14.263] Launching 1 futures (chunks) ... DONE
[09:29:14.263] Resolving 1 futures (chunks) ...
[09:29:14.263] resolve() on list ...
[09:29:14.263]  recursive: 0
[09:29:14.263]  length: 1
[09:29:14.264] 
[09:29:14.264] resolved() for ‘SequentialFuture’ ...
[09:29:14.264] - state: ‘finished’
[09:29:14.264] - run: TRUE
[09:29:14.264] - result: ‘FutureResult’
[09:29:14.264] resolved() for ‘SequentialFuture’ ... done
[09:29:14.264] Future #1
[09:29:14.264] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.264] - nx: 1
[09:29:14.264] - relay: TRUE
[09:29:14.264] - stdout: TRUE
[09:29:14.265] - signal: TRUE
[09:29:14.265] - resignal: FALSE
[09:29:14.265] - force: TRUE
[09:29:14.265] - relayed: [n=1] FALSE
[09:29:14.265] - queued futures: [n=1] FALSE
[09:29:14.265]  - until=1
[09:29:14.265]  - relaying element #1
[09:29:14.265] - relayed: [n=1] TRUE
[09:29:14.265] - queued futures: [n=1] TRUE
[09:29:14.265] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.265]  length: 0 (resolved future 1)
[09:29:14.266] Relaying remaining futures
[09:29:14.266] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.266] - nx: 1
[09:29:14.266] - relay: TRUE
[09:29:14.266] - stdout: TRUE
[09:29:14.266] - signal: TRUE
[09:29:14.266] - resignal: FALSE
[09:29:14.266] - force: TRUE
[09:29:14.266] - relayed: [n=1] TRUE
[09:29:14.266] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.266] - relayed: [n=1] TRUE
[09:29:14.266] - queued futures: [n=1] TRUE
[09:29:14.267] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.267] resolve() on list ... DONE
[09:29:14.267]  - Number of value chunks collected: 1
[09:29:14.267] Resolving 1 futures (chunks) ... DONE
[09:29:14.267] Reducing values from 1 chunks ...
[09:29:14.267]  - Number of values collected after concatenation: 4
[09:29:14.267]  - Number of values expected: 4
[09:29:14.267] Reducing values from 1 chunks ... DONE
[09:29:14.267] future_mapply() ... DONE
[09:29:14.267] future_mapply() ...
[09:29:14.268] Number of chunks: 1
[09:29:14.268] getGlobalsAndPackagesXApply() ...
[09:29:14.268]  - future.globals: TRUE
[09:29:14.268] getGlobalsAndPackages() ...
[09:29:14.268] Searching for globals...
[09:29:14.268] - globals found: [1] ‘FUN’
[09:29:14.269] Searching for globals ... DONE
[09:29:14.269] Resolving globals: FALSE
[09:29:14.269] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:14.269] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:14.269] - globals: [1] ‘FUN’
[09:29:14.269] 
[09:29:14.269] getGlobalsAndPackages() ... DONE
[09:29:14.270]  - globals found/used: [n=1] ‘FUN’
[09:29:14.270]  - needed namespaces: [n=0] 
[09:29:14.270] Finding globals ... DONE
[09:29:14.270] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.270] List of 2
[09:29:14.270]  $ ...future.FUN:function (x, ...)  
[09:29:14.270]  $ MoreArgs     : NULL
[09:29:14.270]  - attr(*, "where")=List of 2
[09:29:14.270]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.270]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.270]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.270]  - attr(*, "resolved")= logi FALSE
[09:29:14.270]  - attr(*, "total_size")= num NA
[09:29:14.272] Packages to be attached in all futures: [n=0] 
[09:29:14.272] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.273] Number of futures (= number of chunks): 1
[09:29:14.273] Launching 1 futures (chunks) ...
[09:29:14.273] Chunk #1 of 1 ...
[09:29:14.273]  - Finding globals in '...' for chunk #1 ...
[09:29:14.273] getGlobalsAndPackages() ...
[09:29:14.273] Searching for globals...
[09:29:14.273] 
[09:29:14.273] Searching for globals ... DONE
[09:29:14.273] - globals: [0] <none>
[09:29:14.274] getGlobalsAndPackages() ... DONE
[09:29:14.274]    + additional globals found: [n=0] 
[09:29:14.274]    + additional namespaces needed: [n=0] 
[09:29:14.274]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.274]  - seeds: <none>
[09:29:14.274]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.274] getGlobalsAndPackages() ...
[09:29:14.274] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.274] Resolving globals: FALSE
[09:29:14.276] The total size of the 5 globals is 504 bytes (504 bytes)
[09:29:14.276] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.276] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.276] 
[09:29:14.276] getGlobalsAndPackages() ... DONE
[09:29:14.277] run() for ‘Future’ ...
[09:29:14.277] - state: ‘created’
[09:29:14.277] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.277] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.277] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.277]   - Field: ‘label’
[09:29:14.277]   - Field: ‘local’
[09:29:14.278]   - Field: ‘owner’
[09:29:14.278]   - Field: ‘envir’
[09:29:14.278]   - Field: ‘packages’
[09:29:14.278]   - Field: ‘gc’
[09:29:14.278]   - Field: ‘conditions’
[09:29:14.278]   - Field: ‘expr’
[09:29:14.278]   - Field: ‘uuid’
[09:29:14.278]   - Field: ‘seed’
[09:29:14.278]   - Field: ‘version’
[09:29:14.278]   - Field: ‘result’
[09:29:14.278]   - Field: ‘asynchronous’
[09:29:14.278]   - Field: ‘calls’
[09:29:14.279]   - Field: ‘globals’
[09:29:14.279]   - Field: ‘stdout’
[09:29:14.279]   - Field: ‘earlySignal’
[09:29:14.279]   - Field: ‘lazy’
[09:29:14.279]   - Field: ‘state’
[09:29:14.279] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.279] - Launch lazy future ...
[09:29:14.279] Packages needed by the future expression (n = 0): <none>
[09:29:14.279] Packages needed by future strategies (n = 0): <none>
[09:29:14.280] {
[09:29:14.280]     {
[09:29:14.280]         {
[09:29:14.280]             ...future.startTime <- base::Sys.time()
[09:29:14.280]             {
[09:29:14.280]                 {
[09:29:14.280]                   {
[09:29:14.280]                     base::local({
[09:29:14.280]                       has_future <- base::requireNamespace("future", 
[09:29:14.280]                         quietly = TRUE)
[09:29:14.280]                       if (has_future) {
[09:29:14.280]                         ns <- base::getNamespace("future")
[09:29:14.280]                         version <- ns[[".package"]][["version"]]
[09:29:14.280]                         if (is.null(version)) 
[09:29:14.280]                           version <- utils::packageVersion("future")
[09:29:14.280]                       }
[09:29:14.280]                       else {
[09:29:14.280]                         version <- NULL
[09:29:14.280]                       }
[09:29:14.280]                       if (!has_future || version < "1.8.0") {
[09:29:14.280]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.280]                           "", base::R.version$version.string), 
[09:29:14.280]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.280]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.280]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.280]                             "release", "version")], collapse = " "), 
[09:29:14.280]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.280]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.280]                           info)
[09:29:14.280]                         info <- base::paste(info, collapse = "; ")
[09:29:14.280]                         if (!has_future) {
[09:29:14.280]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.280]                             info)
[09:29:14.280]                         }
[09:29:14.280]                         else {
[09:29:14.280]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.280]                             info, version)
[09:29:14.280]                         }
[09:29:14.280]                         base::stop(msg)
[09:29:14.280]                       }
[09:29:14.280]                     })
[09:29:14.280]                   }
[09:29:14.280]                   ...future.strategy.old <- future::plan("list")
[09:29:14.280]                   options(future.plan = NULL)
[09:29:14.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.280]                 }
[09:29:14.280]                 ...future.workdir <- getwd()
[09:29:14.280]             }
[09:29:14.280]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.280]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.280]         }
[09:29:14.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.280]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.280]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.280]             base::names(...future.oldOptions))
[09:29:14.280]     }
[09:29:14.280]     if (FALSE) {
[09:29:14.280]     }
[09:29:14.280]     else {
[09:29:14.280]         if (TRUE) {
[09:29:14.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.280]                 open = "w")
[09:29:14.280]         }
[09:29:14.280]         else {
[09:29:14.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.280]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.280]         }
[09:29:14.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.280]             base::sink(type = "output", split = FALSE)
[09:29:14.280]             base::close(...future.stdout)
[09:29:14.280]         }, add = TRUE)
[09:29:14.280]     }
[09:29:14.280]     ...future.frame <- base::sys.nframe()
[09:29:14.280]     ...future.conditions <- base::list()
[09:29:14.280]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.280]     if (FALSE) {
[09:29:14.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.280]     }
[09:29:14.280]     ...future.result <- base::tryCatch({
[09:29:14.280]         base::withCallingHandlers({
[09:29:14.280]             ...future.value <- base::withVisible(base::local({
[09:29:14.280]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.280]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.280]                   ...future.globals.maxSize)) {
[09:29:14.280]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.280]                   on.exit(options(oopts), add = TRUE)
[09:29:14.280]                 }
[09:29:14.280]                 {
[09:29:14.280]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.280]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.280]                     USE.NAMES = FALSE)
[09:29:14.280]                   do.call(mapply, args = args)
[09:29:14.280]                 }
[09:29:14.280]             }))
[09:29:14.280]             future::FutureResult(value = ...future.value$value, 
[09:29:14.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.280]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.280]                     ...future.globalenv.names))
[09:29:14.280]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.280]         }, condition = base::local({
[09:29:14.280]             c <- base::c
[09:29:14.280]             inherits <- base::inherits
[09:29:14.280]             invokeRestart <- base::invokeRestart
[09:29:14.280]             length <- base::length
[09:29:14.280]             list <- base::list
[09:29:14.280]             seq.int <- base::seq.int
[09:29:14.280]             signalCondition <- base::signalCondition
[09:29:14.280]             sys.calls <- base::sys.calls
[09:29:14.280]             `[[` <- base::`[[`
[09:29:14.280]             `+` <- base::`+`
[09:29:14.280]             `<<-` <- base::`<<-`
[09:29:14.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.280]                   3L)]
[09:29:14.280]             }
[09:29:14.280]             function(cond) {
[09:29:14.280]                 is_error <- inherits(cond, "error")
[09:29:14.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.280]                   NULL)
[09:29:14.280]                 if (is_error) {
[09:29:14.280]                   sessionInformation <- function() {
[09:29:14.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.280]                       search = base::search(), system = base::Sys.info())
[09:29:14.280]                   }
[09:29:14.280]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.280]                     cond$call), session = sessionInformation(), 
[09:29:14.280]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.280]                   signalCondition(cond)
[09:29:14.280]                 }
[09:29:14.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.280]                 "immediateCondition"))) {
[09:29:14.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.280]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.280]                   if (TRUE && !signal) {
[09:29:14.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.280]                     {
[09:29:14.280]                       inherits <- base::inherits
[09:29:14.280]                       invokeRestart <- base::invokeRestart
[09:29:14.280]                       is.null <- base::is.null
[09:29:14.280]                       muffled <- FALSE
[09:29:14.280]                       if (inherits(cond, "message")) {
[09:29:14.280]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.280]                         if (muffled) 
[09:29:14.280]                           invokeRestart("muffleMessage")
[09:29:14.280]                       }
[09:29:14.280]                       else if (inherits(cond, "warning")) {
[09:29:14.280]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.280]                         if (muffled) 
[09:29:14.280]                           invokeRestart("muffleWarning")
[09:29:14.280]                       }
[09:29:14.280]                       else if (inherits(cond, "condition")) {
[09:29:14.280]                         if (!is.null(pattern)) {
[09:29:14.280]                           computeRestarts <- base::computeRestarts
[09:29:14.280]                           grepl <- base::grepl
[09:29:14.280]                           restarts <- computeRestarts(cond)
[09:29:14.280]                           for (restart in restarts) {
[09:29:14.280]                             name <- restart$name
[09:29:14.280]                             if (is.null(name)) 
[09:29:14.280]                               next
[09:29:14.280]                             if (!grepl(pattern, name)) 
[09:29:14.280]                               next
[09:29:14.280]                             invokeRestart(restart)
[09:29:14.280]                             muffled <- TRUE
[09:29:14.280]                             break
[09:29:14.280]                           }
[09:29:14.280]                         }
[09:29:14.280]                       }
[09:29:14.280]                       invisible(muffled)
[09:29:14.280]                     }
[09:29:14.280]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.280]                   }
[09:29:14.280]                 }
[09:29:14.280]                 else {
[09:29:14.280]                   if (TRUE) {
[09:29:14.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.280]                     {
[09:29:14.280]                       inherits <- base::inherits
[09:29:14.280]                       invokeRestart <- base::invokeRestart
[09:29:14.280]                       is.null <- base::is.null
[09:29:14.280]                       muffled <- FALSE
[09:29:14.280]                       if (inherits(cond, "message")) {
[09:29:14.280]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.280]                         if (muffled) 
[09:29:14.280]                           invokeRestart("muffleMessage")
[09:29:14.280]                       }
[09:29:14.280]                       else if (inherits(cond, "warning")) {
[09:29:14.280]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.280]                         if (muffled) 
[09:29:14.280]                           invokeRestart("muffleWarning")
[09:29:14.280]                       }
[09:29:14.280]                       else if (inherits(cond, "condition")) {
[09:29:14.280]                         if (!is.null(pattern)) {
[09:29:14.280]                           computeRestarts <- base::computeRestarts
[09:29:14.280]                           grepl <- base::grepl
[09:29:14.280]                           restarts <- computeRestarts(cond)
[09:29:14.280]                           for (restart in restarts) {
[09:29:14.280]                             name <- restart$name
[09:29:14.280]                             if (is.null(name)) 
[09:29:14.280]                               next
[09:29:14.280]                             if (!grepl(pattern, name)) 
[09:29:14.280]                               next
[09:29:14.280]                             invokeRestart(restart)
[09:29:14.280]                             muffled <- TRUE
[09:29:14.280]                             break
[09:29:14.280]                           }
[09:29:14.280]                         }
[09:29:14.280]                       }
[09:29:14.280]                       invisible(muffled)
[09:29:14.280]                     }
[09:29:14.280]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.280]                   }
[09:29:14.280]                 }
[09:29:14.280]             }
[09:29:14.280]         }))
[09:29:14.280]     }, error = function(ex) {
[09:29:14.280]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.280]                 ...future.rng), started = ...future.startTime, 
[09:29:14.280]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.280]             version = "1.8"), class = "FutureResult")
[09:29:14.280]     }, finally = {
[09:29:14.280]         if (!identical(...future.workdir, getwd())) 
[09:29:14.280]             setwd(...future.workdir)
[09:29:14.280]         {
[09:29:14.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.280]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.280]             }
[09:29:14.280]             base::options(...future.oldOptions)
[09:29:14.280]             if (.Platform$OS.type == "windows") {
[09:29:14.280]                 old_names <- names(...future.oldEnvVars)
[09:29:14.280]                 envs <- base::Sys.getenv()
[09:29:14.280]                 names <- names(envs)
[09:29:14.280]                 common <- intersect(names, old_names)
[09:29:14.280]                 added <- setdiff(names, old_names)
[09:29:14.280]                 removed <- setdiff(old_names, names)
[09:29:14.280]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.280]                   envs[common]]
[09:29:14.280]                 NAMES <- toupper(changed)
[09:29:14.280]                 args <- list()
[09:29:14.280]                 for (kk in seq_along(NAMES)) {
[09:29:14.280]                   name <- changed[[kk]]
[09:29:14.280]                   NAME <- NAMES[[kk]]
[09:29:14.280]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.280]                     next
[09:29:14.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.280]                 }
[09:29:14.280]                 NAMES <- toupper(added)
[09:29:14.280]                 for (kk in seq_along(NAMES)) {
[09:29:14.280]                   name <- added[[kk]]
[09:29:14.280]                   NAME <- NAMES[[kk]]
[09:29:14.280]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.280]                     next
[09:29:14.280]                   args[[name]] <- ""
[09:29:14.280]                 }
[09:29:14.280]                 NAMES <- toupper(removed)
[09:29:14.280]                 for (kk in seq_along(NAMES)) {
[09:29:14.280]                   name <- removed[[kk]]
[09:29:14.280]                   NAME <- NAMES[[kk]]
[09:29:14.280]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.280]                     next
[09:29:14.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.280]                 }
[09:29:14.280]                 if (length(args) > 0) 
[09:29:14.280]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.280]             }
[09:29:14.280]             else {
[09:29:14.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.280]             }
[09:29:14.280]             {
[09:29:14.280]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.280]                   0L) {
[09:29:14.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.280]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.280]                   base::options(opts)
[09:29:14.280]                 }
[09:29:14.280]                 {
[09:29:14.280]                   {
[09:29:14.280]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.280]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.280]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.280]                     NULL
[09:29:14.280]                   }
[09:29:14.280]                   options(future.plan = NULL)
[09:29:14.280]                   if (is.na(NA_character_)) 
[09:29:14.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.280]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.280]                     .init = FALSE)
[09:29:14.280]                 }
[09:29:14.280]             }
[09:29:14.280]         }
[09:29:14.280]     })
[09:29:14.280]     if (TRUE) {
[09:29:14.280]         base::sink(type = "output", split = FALSE)
[09:29:14.280]         if (TRUE) {
[09:29:14.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.280]         }
[09:29:14.280]         else {
[09:29:14.280]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.280]         }
[09:29:14.280]         base::close(...future.stdout)
[09:29:14.280]         ...future.stdout <- NULL
[09:29:14.280]     }
[09:29:14.280]     ...future.result$conditions <- ...future.conditions
[09:29:14.280]     ...future.result$finished <- base::Sys.time()
[09:29:14.280]     ...future.result
[09:29:14.280] }
[09:29:14.281] assign_globals() ...
[09:29:14.281] List of 5
[09:29:14.281]  $ ...future.FUN            :function (x, ...)  
[09:29:14.281]  $ MoreArgs                 : NULL
[09:29:14.281]  $ ...future.elements_ii    :List of 2
[09:29:14.281]   ..$ :List of 4
[09:29:14.281]   .. ..$ : int 1
[09:29:14.281]   .. ..$ : int 2
[09:29:14.281]   .. ..$ : int 3
[09:29:14.281]   .. ..$ : int 4
[09:29:14.281]   ..$ :List of 4
[09:29:14.281]   .. ..$ : int 4
[09:29:14.281]   .. ..$ : int 3
[09:29:14.281]   .. ..$ : int 2
[09:29:14.281]   .. ..$ : int 1
[09:29:14.281]  $ ...future.seeds_ii       : NULL
[09:29:14.281]  $ ...future.globals.maxSize: NULL
[09:29:14.281]  - attr(*, "where")=List of 5
[09:29:14.281]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.281]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.281]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.281]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.281]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.281]  - attr(*, "resolved")= logi FALSE
[09:29:14.281]  - attr(*, "total_size")= num 504
[09:29:14.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.281]  - attr(*, "already-done")= logi TRUE
[09:29:14.287] - copied ‘...future.FUN’ to environment
[09:29:14.288] - copied ‘MoreArgs’ to environment
[09:29:14.288] - copied ‘...future.elements_ii’ to environment
[09:29:14.288] - copied ‘...future.seeds_ii’ to environment
[09:29:14.288] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.288] assign_globals() ... done
[09:29:14.288] plan(): Setting new future strategy stack:
[09:29:14.288] List of future strategies:
[09:29:14.288] 1. sequential:
[09:29:14.288]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.288]    - tweaked: FALSE
[09:29:14.288]    - call: NULL
[09:29:14.289] plan(): nbrOfWorkers() = 1
[09:29:14.289] plan(): Setting new future strategy stack:
[09:29:14.289] List of future strategies:
[09:29:14.289] 1. sequential:
[09:29:14.289]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.289]    - tweaked: FALSE
[09:29:14.289]    - call: plan(strategy)
[09:29:14.290] plan(): nbrOfWorkers() = 1
[09:29:14.290] SequentialFuture started (and completed)
[09:29:14.290] - Launch lazy future ... done
[09:29:14.290] run() for ‘SequentialFuture’ ... done
[09:29:14.290] Created future:
[09:29:14.290] SequentialFuture:
[09:29:14.290] Label: ‘future_mapply-1’
[09:29:14.290] Expression:
[09:29:14.290] {
[09:29:14.290]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.290]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.290]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.290]         on.exit(options(oopts), add = TRUE)
[09:29:14.290]     }
[09:29:14.290]     {
[09:29:14.290]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.290]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.290]         do.call(mapply, args = args)
[09:29:14.290]     }
[09:29:14.290] }
[09:29:14.290] Lazy evaluation: FALSE
[09:29:14.290] Asynchronous evaluation: FALSE
[09:29:14.290] Local evaluation: TRUE
[09:29:14.290] Environment: R_GlobalEnv
[09:29:14.290] Capture standard output: TRUE
[09:29:14.290] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.290] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.290] Packages: <none>
[09:29:14.290] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.290] Resolved: TRUE
[09:29:14.290] Value: 240 bytes of class ‘list’
[09:29:14.290] Early signaling: FALSE
[09:29:14.290] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.290] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.291] Chunk #1 of 1 ... DONE
[09:29:14.291] Launching 1 futures (chunks) ... DONE
[09:29:14.291] Resolving 1 futures (chunks) ...
[09:29:14.292] resolve() on list ...
[09:29:14.292]  recursive: 0
[09:29:14.292]  length: 1
[09:29:14.292] 
[09:29:14.292] resolved() for ‘SequentialFuture’ ...
[09:29:14.292] - state: ‘finished’
[09:29:14.292] - run: TRUE
[09:29:14.292] - result: ‘FutureResult’
[09:29:14.292] resolved() for ‘SequentialFuture’ ... done
[09:29:14.292] Future #1
[09:29:14.292] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.293] - nx: 1
[09:29:14.293] - relay: TRUE
[09:29:14.293] - stdout: TRUE
[09:29:14.293] - signal: TRUE
[09:29:14.293] - resignal: FALSE
[09:29:14.293] - force: TRUE
[09:29:14.293] - relayed: [n=1] FALSE
[09:29:14.293] - queued futures: [n=1] FALSE
[09:29:14.293]  - until=1
[09:29:14.293]  - relaying element #1
[09:29:14.293] - relayed: [n=1] TRUE
[09:29:14.294] - queued futures: [n=1] TRUE
[09:29:14.294] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.294]  length: 0 (resolved future 1)
[09:29:14.294] Relaying remaining futures
[09:29:14.294] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.294] - nx: 1
[09:29:14.294] - relay: TRUE
[09:29:14.294] - stdout: TRUE
[09:29:14.294] - signal: TRUE
[09:29:14.294] - resignal: FALSE
[09:29:14.294] - force: TRUE
[09:29:14.294] - relayed: [n=1] TRUE
[09:29:14.294] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.295] - relayed: [n=1] TRUE
[09:29:14.295] - queued futures: [n=1] TRUE
[09:29:14.295] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.295] resolve() on list ... DONE
[09:29:14.295]  - Number of value chunks collected: 1
[09:29:14.295] Resolving 1 futures (chunks) ... DONE
[09:29:14.295] Reducing values from 1 chunks ...
[09:29:14.295]  - Number of values collected after concatenation: 4
[09:29:14.295]  - Number of values expected: 4
[09:29:14.295] Reducing values from 1 chunks ... DONE
[09:29:14.296] future_mapply() ... DONE
[09:29:14.296] future_mapply() ...
[09:29:14.296] Number of chunks: 1
[09:29:14.296] getGlobalsAndPackagesXApply() ...
[09:29:14.296]  - future.globals: TRUE
[09:29:14.296] getGlobalsAndPackages() ...
[09:29:14.296] Searching for globals...
[09:29:14.297] - globals found: [1] ‘FUN’
[09:29:14.297] Searching for globals ... DONE
[09:29:14.297] Resolving globals: FALSE
[09:29:14.297] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:14.297] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:14.297] - globals: [1] ‘FUN’
[09:29:14.298] 
[09:29:14.298] getGlobalsAndPackages() ... DONE
[09:29:14.298]  - globals found/used: [n=1] ‘FUN’
[09:29:14.298]  - needed namespaces: [n=0] 
[09:29:14.298] Finding globals ... DONE
[09:29:14.298] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.298] List of 2
[09:29:14.298]  $ ...future.FUN:function (x, ...)  
[09:29:14.298]  $ MoreArgs     : NULL
[09:29:14.298]  - attr(*, "where")=List of 2
[09:29:14.298]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.298]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.298]  - attr(*, "resolved")= logi FALSE
[09:29:14.298]  - attr(*, "total_size")= num NA
[09:29:14.301] Packages to be attached in all futures: [n=0] 
[09:29:14.301] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.302] Number of futures (= number of chunks): 1
[09:29:14.302] Launching 1 futures (chunks) ...
[09:29:14.302] Chunk #1 of 1 ...
[09:29:14.302]  - Finding globals in '...' for chunk #1 ...
[09:29:14.302] getGlobalsAndPackages() ...
[09:29:14.302] Searching for globals...
[09:29:14.302] 
[09:29:14.303] Searching for globals ... DONE
[09:29:14.303] - globals: [0] <none>
[09:29:14.303] getGlobalsAndPackages() ... DONE
[09:29:14.303]    + additional globals found: [n=0] 
[09:29:14.303]    + additional namespaces needed: [n=0] 
[09:29:14.303]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.303]  - seeds: <none>
[09:29:14.303]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.303] getGlobalsAndPackages() ...
[09:29:14.303] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.303] Resolving globals: FALSE
[09:29:14.304] The total size of the 5 globals is 504 bytes (504 bytes)
[09:29:14.304] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.304] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.304] 
[09:29:14.305] getGlobalsAndPackages() ... DONE
[09:29:14.305] run() for ‘Future’ ...
[09:29:14.305] - state: ‘created’
[09:29:14.305] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.305] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.305] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.305]   - Field: ‘label’
[09:29:14.306]   - Field: ‘local’
[09:29:14.306]   - Field: ‘owner’
[09:29:14.306]   - Field: ‘envir’
[09:29:14.306]   - Field: ‘packages’
[09:29:14.306]   - Field: ‘gc’
[09:29:14.306]   - Field: ‘conditions’
[09:29:14.306]   - Field: ‘expr’
[09:29:14.306]   - Field: ‘uuid’
[09:29:14.306]   - Field: ‘seed’
[09:29:14.306]   - Field: ‘version’
[09:29:14.306]   - Field: ‘result’
[09:29:14.306]   - Field: ‘asynchronous’
[09:29:14.307]   - Field: ‘calls’
[09:29:14.307]   - Field: ‘globals’
[09:29:14.307]   - Field: ‘stdout’
[09:29:14.307]   - Field: ‘earlySignal’
[09:29:14.307]   - Field: ‘lazy’
[09:29:14.307]   - Field: ‘state’
[09:29:14.307] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.307] - Launch lazy future ...
[09:29:14.307] Packages needed by the future expression (n = 0): <none>
[09:29:14.307] Packages needed by future strategies (n = 0): <none>
[09:29:14.308] {
[09:29:14.308]     {
[09:29:14.308]         {
[09:29:14.308]             ...future.startTime <- base::Sys.time()
[09:29:14.308]             {
[09:29:14.308]                 {
[09:29:14.308]                   {
[09:29:14.308]                     base::local({
[09:29:14.308]                       has_future <- base::requireNamespace("future", 
[09:29:14.308]                         quietly = TRUE)
[09:29:14.308]                       if (has_future) {
[09:29:14.308]                         ns <- base::getNamespace("future")
[09:29:14.308]                         version <- ns[[".package"]][["version"]]
[09:29:14.308]                         if (is.null(version)) 
[09:29:14.308]                           version <- utils::packageVersion("future")
[09:29:14.308]                       }
[09:29:14.308]                       else {
[09:29:14.308]                         version <- NULL
[09:29:14.308]                       }
[09:29:14.308]                       if (!has_future || version < "1.8.0") {
[09:29:14.308]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.308]                           "", base::R.version$version.string), 
[09:29:14.308]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.308]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.308]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.308]                             "release", "version")], collapse = " "), 
[09:29:14.308]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.308]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.308]                           info)
[09:29:14.308]                         info <- base::paste(info, collapse = "; ")
[09:29:14.308]                         if (!has_future) {
[09:29:14.308]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.308]                             info)
[09:29:14.308]                         }
[09:29:14.308]                         else {
[09:29:14.308]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.308]                             info, version)
[09:29:14.308]                         }
[09:29:14.308]                         base::stop(msg)
[09:29:14.308]                       }
[09:29:14.308]                     })
[09:29:14.308]                   }
[09:29:14.308]                   ...future.strategy.old <- future::plan("list")
[09:29:14.308]                   options(future.plan = NULL)
[09:29:14.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.308]                 }
[09:29:14.308]                 ...future.workdir <- getwd()
[09:29:14.308]             }
[09:29:14.308]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.308]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.308]         }
[09:29:14.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.308]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.308]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.308]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.308]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.308]             base::names(...future.oldOptions))
[09:29:14.308]     }
[09:29:14.308]     if (FALSE) {
[09:29:14.308]     }
[09:29:14.308]     else {
[09:29:14.308]         if (TRUE) {
[09:29:14.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.308]                 open = "w")
[09:29:14.308]         }
[09:29:14.308]         else {
[09:29:14.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.308]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.308]         }
[09:29:14.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.308]             base::sink(type = "output", split = FALSE)
[09:29:14.308]             base::close(...future.stdout)
[09:29:14.308]         }, add = TRUE)
[09:29:14.308]     }
[09:29:14.308]     ...future.frame <- base::sys.nframe()
[09:29:14.308]     ...future.conditions <- base::list()
[09:29:14.308]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.308]     if (FALSE) {
[09:29:14.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.308]     }
[09:29:14.308]     ...future.result <- base::tryCatch({
[09:29:14.308]         base::withCallingHandlers({
[09:29:14.308]             ...future.value <- base::withVisible(base::local({
[09:29:14.308]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.308]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.308]                   ...future.globals.maxSize)) {
[09:29:14.308]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.308]                   on.exit(options(oopts), add = TRUE)
[09:29:14.308]                 }
[09:29:14.308]                 {
[09:29:14.308]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.308]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.308]                     USE.NAMES = FALSE)
[09:29:14.308]                   do.call(mapply, args = args)
[09:29:14.308]                 }
[09:29:14.308]             }))
[09:29:14.308]             future::FutureResult(value = ...future.value$value, 
[09:29:14.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.308]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.308]                     ...future.globalenv.names))
[09:29:14.308]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.308]         }, condition = base::local({
[09:29:14.308]             c <- base::c
[09:29:14.308]             inherits <- base::inherits
[09:29:14.308]             invokeRestart <- base::invokeRestart
[09:29:14.308]             length <- base::length
[09:29:14.308]             list <- base::list
[09:29:14.308]             seq.int <- base::seq.int
[09:29:14.308]             signalCondition <- base::signalCondition
[09:29:14.308]             sys.calls <- base::sys.calls
[09:29:14.308]             `[[` <- base::`[[`
[09:29:14.308]             `+` <- base::`+`
[09:29:14.308]             `<<-` <- base::`<<-`
[09:29:14.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.308]                   3L)]
[09:29:14.308]             }
[09:29:14.308]             function(cond) {
[09:29:14.308]                 is_error <- inherits(cond, "error")
[09:29:14.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.308]                   NULL)
[09:29:14.308]                 if (is_error) {
[09:29:14.308]                   sessionInformation <- function() {
[09:29:14.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.308]                       search = base::search(), system = base::Sys.info())
[09:29:14.308]                   }
[09:29:14.308]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.308]                     cond$call), session = sessionInformation(), 
[09:29:14.308]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.308]                   signalCondition(cond)
[09:29:14.308]                 }
[09:29:14.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.308]                 "immediateCondition"))) {
[09:29:14.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.308]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.308]                   if (TRUE && !signal) {
[09:29:14.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.308]                     {
[09:29:14.308]                       inherits <- base::inherits
[09:29:14.308]                       invokeRestart <- base::invokeRestart
[09:29:14.308]                       is.null <- base::is.null
[09:29:14.308]                       muffled <- FALSE
[09:29:14.308]                       if (inherits(cond, "message")) {
[09:29:14.308]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.308]                         if (muffled) 
[09:29:14.308]                           invokeRestart("muffleMessage")
[09:29:14.308]                       }
[09:29:14.308]                       else if (inherits(cond, "warning")) {
[09:29:14.308]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.308]                         if (muffled) 
[09:29:14.308]                           invokeRestart("muffleWarning")
[09:29:14.308]                       }
[09:29:14.308]                       else if (inherits(cond, "condition")) {
[09:29:14.308]                         if (!is.null(pattern)) {
[09:29:14.308]                           computeRestarts <- base::computeRestarts
[09:29:14.308]                           grepl <- base::grepl
[09:29:14.308]                           restarts <- computeRestarts(cond)
[09:29:14.308]                           for (restart in restarts) {
[09:29:14.308]                             name <- restart$name
[09:29:14.308]                             if (is.null(name)) 
[09:29:14.308]                               next
[09:29:14.308]                             if (!grepl(pattern, name)) 
[09:29:14.308]                               next
[09:29:14.308]                             invokeRestart(restart)
[09:29:14.308]                             muffled <- TRUE
[09:29:14.308]                             break
[09:29:14.308]                           }
[09:29:14.308]                         }
[09:29:14.308]                       }
[09:29:14.308]                       invisible(muffled)
[09:29:14.308]                     }
[09:29:14.308]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.308]                   }
[09:29:14.308]                 }
[09:29:14.308]                 else {
[09:29:14.308]                   if (TRUE) {
[09:29:14.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.308]                     {
[09:29:14.308]                       inherits <- base::inherits
[09:29:14.308]                       invokeRestart <- base::invokeRestart
[09:29:14.308]                       is.null <- base::is.null
[09:29:14.308]                       muffled <- FALSE
[09:29:14.308]                       if (inherits(cond, "message")) {
[09:29:14.308]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.308]                         if (muffled) 
[09:29:14.308]                           invokeRestart("muffleMessage")
[09:29:14.308]                       }
[09:29:14.308]                       else if (inherits(cond, "warning")) {
[09:29:14.308]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.308]                         if (muffled) 
[09:29:14.308]                           invokeRestart("muffleWarning")
[09:29:14.308]                       }
[09:29:14.308]                       else if (inherits(cond, "condition")) {
[09:29:14.308]                         if (!is.null(pattern)) {
[09:29:14.308]                           computeRestarts <- base::computeRestarts
[09:29:14.308]                           grepl <- base::grepl
[09:29:14.308]                           restarts <- computeRestarts(cond)
[09:29:14.308]                           for (restart in restarts) {
[09:29:14.308]                             name <- restart$name
[09:29:14.308]                             if (is.null(name)) 
[09:29:14.308]                               next
[09:29:14.308]                             if (!grepl(pattern, name)) 
[09:29:14.308]                               next
[09:29:14.308]                             invokeRestart(restart)
[09:29:14.308]                             muffled <- TRUE
[09:29:14.308]                             break
[09:29:14.308]                           }
[09:29:14.308]                         }
[09:29:14.308]                       }
[09:29:14.308]                       invisible(muffled)
[09:29:14.308]                     }
[09:29:14.308]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.308]                   }
[09:29:14.308]                 }
[09:29:14.308]             }
[09:29:14.308]         }))
[09:29:14.308]     }, error = function(ex) {
[09:29:14.308]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.308]                 ...future.rng), started = ...future.startTime, 
[09:29:14.308]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.308]             version = "1.8"), class = "FutureResult")
[09:29:14.308]     }, finally = {
[09:29:14.308]         if (!identical(...future.workdir, getwd())) 
[09:29:14.308]             setwd(...future.workdir)
[09:29:14.308]         {
[09:29:14.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.308]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.308]             }
[09:29:14.308]             base::options(...future.oldOptions)
[09:29:14.308]             if (.Platform$OS.type == "windows") {
[09:29:14.308]                 old_names <- names(...future.oldEnvVars)
[09:29:14.308]                 envs <- base::Sys.getenv()
[09:29:14.308]                 names <- names(envs)
[09:29:14.308]                 common <- intersect(names, old_names)
[09:29:14.308]                 added <- setdiff(names, old_names)
[09:29:14.308]                 removed <- setdiff(old_names, names)
[09:29:14.308]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.308]                   envs[common]]
[09:29:14.308]                 NAMES <- toupper(changed)
[09:29:14.308]                 args <- list()
[09:29:14.308]                 for (kk in seq_along(NAMES)) {
[09:29:14.308]                   name <- changed[[kk]]
[09:29:14.308]                   NAME <- NAMES[[kk]]
[09:29:14.308]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.308]                     next
[09:29:14.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.308]                 }
[09:29:14.308]                 NAMES <- toupper(added)
[09:29:14.308]                 for (kk in seq_along(NAMES)) {
[09:29:14.308]                   name <- added[[kk]]
[09:29:14.308]                   NAME <- NAMES[[kk]]
[09:29:14.308]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.308]                     next
[09:29:14.308]                   args[[name]] <- ""
[09:29:14.308]                 }
[09:29:14.308]                 NAMES <- toupper(removed)
[09:29:14.308]                 for (kk in seq_along(NAMES)) {
[09:29:14.308]                   name <- removed[[kk]]
[09:29:14.308]                   NAME <- NAMES[[kk]]
[09:29:14.308]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.308]                     next
[09:29:14.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.308]                 }
[09:29:14.308]                 if (length(args) > 0) 
[09:29:14.308]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.308]             }
[09:29:14.308]             else {
[09:29:14.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.308]             }
[09:29:14.308]             {
[09:29:14.308]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.308]                   0L) {
[09:29:14.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.308]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.308]                   base::options(opts)
[09:29:14.308]                 }
[09:29:14.308]                 {
[09:29:14.308]                   {
[09:29:14.308]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.308]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.308]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.308]                     NULL
[09:29:14.308]                   }
[09:29:14.308]                   options(future.plan = NULL)
[09:29:14.308]                   if (is.na(NA_character_)) 
[09:29:14.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.308]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.308]                     .init = FALSE)
[09:29:14.308]                 }
[09:29:14.308]             }
[09:29:14.308]         }
[09:29:14.308]     })
[09:29:14.308]     if (TRUE) {
[09:29:14.308]         base::sink(type = "output", split = FALSE)
[09:29:14.308]         if (TRUE) {
[09:29:14.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.308]         }
[09:29:14.308]         else {
[09:29:14.308]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.308]         }
[09:29:14.308]         base::close(...future.stdout)
[09:29:14.308]         ...future.stdout <- NULL
[09:29:14.308]     }
[09:29:14.308]     ...future.result$conditions <- ...future.conditions
[09:29:14.308]     ...future.result$finished <- base::Sys.time()
[09:29:14.308]     ...future.result
[09:29:14.308] }
[09:29:14.309] assign_globals() ...
[09:29:14.309] List of 5
[09:29:14.309]  $ ...future.FUN            :function (x, ...)  
[09:29:14.309]  $ MoreArgs                 : NULL
[09:29:14.309]  $ ...future.elements_ii    :List of 2
[09:29:14.309]   ..$ times:List of 4
[09:29:14.309]   .. ..$ : int 1
[09:29:14.309]   .. ..$ : int 2
[09:29:14.309]   .. ..$ : int 3
[09:29:14.309]   .. ..$ : int 4
[09:29:14.309]   ..$ x    :List of 4
[09:29:14.309]   .. ..$ : int 4
[09:29:14.309]   .. ..$ : int 3
[09:29:14.309]   .. ..$ : int 2
[09:29:14.309]   .. ..$ : int 1
[09:29:14.309]  $ ...future.seeds_ii       : NULL
[09:29:14.309]  $ ...future.globals.maxSize: NULL
[09:29:14.309]  - attr(*, "where")=List of 5
[09:29:14.309]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.309]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.309]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.309]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.309]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.309]  - attr(*, "resolved")= logi FALSE
[09:29:14.309]  - attr(*, "total_size")= num 504
[09:29:14.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.309]  - attr(*, "already-done")= logi TRUE
[09:29:14.316] - copied ‘...future.FUN’ to environment
[09:29:14.316] - copied ‘MoreArgs’ to environment
[09:29:14.316] - copied ‘...future.elements_ii’ to environment
[09:29:14.316] - copied ‘...future.seeds_ii’ to environment
[09:29:14.316] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.316] assign_globals() ... done
[09:29:14.316] plan(): Setting new future strategy stack:
[09:29:14.316] List of future strategies:
[09:29:14.316] 1. sequential:
[09:29:14.316]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.316]    - tweaked: FALSE
[09:29:14.316]    - call: NULL
[09:29:14.317] plan(): nbrOfWorkers() = 1
[09:29:14.317] plan(): Setting new future strategy stack:
[09:29:14.318] List of future strategies:
[09:29:14.318] 1. sequential:
[09:29:14.318]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.318]    - tweaked: FALSE
[09:29:14.318]    - call: plan(strategy)
[09:29:14.318] plan(): nbrOfWorkers() = 1
[09:29:14.318] SequentialFuture started (and completed)
[09:29:14.318] - Launch lazy future ... done
[09:29:14.318] run() for ‘SequentialFuture’ ... done
[09:29:14.318] Created future:
[09:29:14.318] SequentialFuture:
[09:29:14.318] Label: ‘future_mapply-1’
[09:29:14.318] Expression:
[09:29:14.318] {
[09:29:14.318]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.318]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.318]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.318]         on.exit(options(oopts), add = TRUE)
[09:29:14.318]     }
[09:29:14.318]     {
[09:29:14.318]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.318]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.318]         do.call(mapply, args = args)
[09:29:14.318]     }
[09:29:14.318] }
[09:29:14.318] Lazy evaluation: FALSE
[09:29:14.318] Asynchronous evaluation: FALSE
[09:29:14.318] Local evaluation: TRUE
[09:29:14.318] Environment: R_GlobalEnv
[09:29:14.318] Capture standard output: TRUE
[09:29:14.318] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.318] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.318] Packages: <none>
[09:29:14.318] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.318] Resolved: TRUE
[09:29:14.318] Value: 240 bytes of class ‘list’
[09:29:14.318] Early signaling: FALSE
[09:29:14.318] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.318] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.319] Chunk #1 of 1 ... DONE
[09:29:14.319] Launching 1 futures (chunks) ... DONE
[09:29:14.319] Resolving 1 futures (chunks) ...
[09:29:14.320] resolve() on list ...
[09:29:14.320]  recursive: 0
[09:29:14.320]  length: 1
[09:29:14.320] 
[09:29:14.320] resolved() for ‘SequentialFuture’ ...
[09:29:14.320] - state: ‘finished’
[09:29:14.320] - run: TRUE
[09:29:14.320] - result: ‘FutureResult’
[09:29:14.320] resolved() for ‘SequentialFuture’ ... done
[09:29:14.320] Future #1
[09:29:14.320] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.321] - nx: 1
[09:29:14.321] - relay: TRUE
[09:29:14.321] - stdout: TRUE
[09:29:14.321] - signal: TRUE
[09:29:14.321] - resignal: FALSE
[09:29:14.321] - force: TRUE
[09:29:14.321] - relayed: [n=1] FALSE
[09:29:14.321] - queued futures: [n=1] FALSE
[09:29:14.321]  - until=1
[09:29:14.321]  - relaying element #1
[09:29:14.321] - relayed: [n=1] TRUE
[09:29:14.322] - queued futures: [n=1] TRUE
[09:29:14.322] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.322]  length: 0 (resolved future 1)
[09:29:14.322] Relaying remaining futures
[09:29:14.322] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.322] - nx: 1
[09:29:14.322] - relay: TRUE
[09:29:14.322] - stdout: TRUE
[09:29:14.322] - signal: TRUE
[09:29:14.322] - resignal: FALSE
[09:29:14.322] - force: TRUE
[09:29:14.322] - relayed: [n=1] TRUE
[09:29:14.322] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.323] - relayed: [n=1] TRUE
[09:29:14.323] - queued futures: [n=1] TRUE
[09:29:14.323] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.323] resolve() on list ... DONE
[09:29:14.324]  - Number of value chunks collected: 1
[09:29:14.324] Resolving 1 futures (chunks) ... DONE
[09:29:14.324] Reducing values from 1 chunks ...
[09:29:14.324]  - Number of values collected after concatenation: 4
[09:29:14.324]  - Number of values expected: 4
[09:29:14.324] Reducing values from 1 chunks ... DONE
[09:29:14.324] future_mapply() ... DONE
[09:29:14.325] future_mapply() ...
[09:29:14.325] Number of chunks: 1
[09:29:14.325] getGlobalsAndPackagesXApply() ...
[09:29:14.325]  - future.globals: TRUE
[09:29:14.325] getGlobalsAndPackages() ...
[09:29:14.325] Searching for globals...
[09:29:14.326] - globals found: [1] ‘FUN’
[09:29:14.326] Searching for globals ... DONE
[09:29:14.326] Resolving globals: FALSE
[09:29:14.326] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:14.326] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:14.326] - globals: [1] ‘FUN’
[09:29:14.327] 
[09:29:14.327] getGlobalsAndPackages() ... DONE
[09:29:14.327]  - globals found/used: [n=1] ‘FUN’
[09:29:14.327]  - needed namespaces: [n=0] 
[09:29:14.327] Finding globals ... DONE
[09:29:14.327] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.327] List of 2
[09:29:14.327]  $ ...future.FUN:function (x, ...)  
[09:29:14.327]  $ MoreArgs     :List of 1
[09:29:14.327]   ..$ x: num 42
[09:29:14.327]  - attr(*, "where")=List of 2
[09:29:14.327]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.327]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.327]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.327]  - attr(*, "resolved")= logi FALSE
[09:29:14.327]  - attr(*, "total_size")= num NA
[09:29:14.330] Packages to be attached in all futures: [n=0] 
[09:29:14.330] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.330] Number of futures (= number of chunks): 1
[09:29:14.330] Launching 1 futures (chunks) ...
[09:29:14.330] Chunk #1 of 1 ...
[09:29:14.330]  - Finding globals in '...' for chunk #1 ...
[09:29:14.330] getGlobalsAndPackages() ...
[09:29:14.330] Searching for globals...
[09:29:14.331] 
[09:29:14.331] Searching for globals ... DONE
[09:29:14.331] - globals: [0] <none>
[09:29:14.331] getGlobalsAndPackages() ... DONE
[09:29:14.331]    + additional globals found: [n=0] 
[09:29:14.331]    + additional namespaces needed: [n=0] 
[09:29:14.331]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.331]  - seeds: <none>
[09:29:14.331]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.332] getGlobalsAndPackages() ...
[09:29:14.332] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.332] Resolving globals: FALSE
[09:29:14.332] The total size of the 5 globals is 336 bytes (336 bytes)
[09:29:14.333] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 336 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[09:29:14.333] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.333] 
[09:29:14.333] getGlobalsAndPackages() ... DONE
[09:29:14.333] run() for ‘Future’ ...
[09:29:14.333] - state: ‘created’
[09:29:14.333] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.334] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.334] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.334]   - Field: ‘label’
[09:29:14.334]   - Field: ‘local’
[09:29:14.334]   - Field: ‘owner’
[09:29:14.334]   - Field: ‘envir’
[09:29:14.334]   - Field: ‘packages’
[09:29:14.334]   - Field: ‘gc’
[09:29:14.334]   - Field: ‘conditions’
[09:29:14.334]   - Field: ‘expr’
[09:29:14.334]   - Field: ‘uuid’
[09:29:14.335]   - Field: ‘seed’
[09:29:14.335]   - Field: ‘version’
[09:29:14.335]   - Field: ‘result’
[09:29:14.335]   - Field: ‘asynchronous’
[09:29:14.335]   - Field: ‘calls’
[09:29:14.335]   - Field: ‘globals’
[09:29:14.335]   - Field: ‘stdout’
[09:29:14.335]   - Field: ‘earlySignal’
[09:29:14.335]   - Field: ‘lazy’
[09:29:14.335]   - Field: ‘state’
[09:29:14.335] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.335] - Launch lazy future ...
[09:29:14.336] Packages needed by the future expression (n = 0): <none>
[09:29:14.336] Packages needed by future strategies (n = 0): <none>
[09:29:14.336] {
[09:29:14.336]     {
[09:29:14.336]         {
[09:29:14.336]             ...future.startTime <- base::Sys.time()
[09:29:14.336]             {
[09:29:14.336]                 {
[09:29:14.336]                   {
[09:29:14.336]                     base::local({
[09:29:14.336]                       has_future <- base::requireNamespace("future", 
[09:29:14.336]                         quietly = TRUE)
[09:29:14.336]                       if (has_future) {
[09:29:14.336]                         ns <- base::getNamespace("future")
[09:29:14.336]                         version <- ns[[".package"]][["version"]]
[09:29:14.336]                         if (is.null(version)) 
[09:29:14.336]                           version <- utils::packageVersion("future")
[09:29:14.336]                       }
[09:29:14.336]                       else {
[09:29:14.336]                         version <- NULL
[09:29:14.336]                       }
[09:29:14.336]                       if (!has_future || version < "1.8.0") {
[09:29:14.336]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.336]                           "", base::R.version$version.string), 
[09:29:14.336]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.336]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.336]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.336]                             "release", "version")], collapse = " "), 
[09:29:14.336]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.336]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.336]                           info)
[09:29:14.336]                         info <- base::paste(info, collapse = "; ")
[09:29:14.336]                         if (!has_future) {
[09:29:14.336]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.336]                             info)
[09:29:14.336]                         }
[09:29:14.336]                         else {
[09:29:14.336]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.336]                             info, version)
[09:29:14.336]                         }
[09:29:14.336]                         base::stop(msg)
[09:29:14.336]                       }
[09:29:14.336]                     })
[09:29:14.336]                   }
[09:29:14.336]                   ...future.strategy.old <- future::plan("list")
[09:29:14.336]                   options(future.plan = NULL)
[09:29:14.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.336]                 }
[09:29:14.336]                 ...future.workdir <- getwd()
[09:29:14.336]             }
[09:29:14.336]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.336]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.336]         }
[09:29:14.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.336]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.336]             base::names(...future.oldOptions))
[09:29:14.336]     }
[09:29:14.336]     if (FALSE) {
[09:29:14.336]     }
[09:29:14.336]     else {
[09:29:14.336]         if (TRUE) {
[09:29:14.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.336]                 open = "w")
[09:29:14.336]         }
[09:29:14.336]         else {
[09:29:14.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.336]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.336]         }
[09:29:14.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.336]             base::sink(type = "output", split = FALSE)
[09:29:14.336]             base::close(...future.stdout)
[09:29:14.336]         }, add = TRUE)
[09:29:14.336]     }
[09:29:14.336]     ...future.frame <- base::sys.nframe()
[09:29:14.336]     ...future.conditions <- base::list()
[09:29:14.336]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.336]     if (FALSE) {
[09:29:14.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.336]     }
[09:29:14.336]     ...future.result <- base::tryCatch({
[09:29:14.336]         base::withCallingHandlers({
[09:29:14.336]             ...future.value <- base::withVisible(base::local({
[09:29:14.336]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.336]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.336]                   ...future.globals.maxSize)) {
[09:29:14.336]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.336]                   on.exit(options(oopts), add = TRUE)
[09:29:14.336]                 }
[09:29:14.336]                 {
[09:29:14.336]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.336]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.336]                     USE.NAMES = FALSE)
[09:29:14.336]                   do.call(mapply, args = args)
[09:29:14.336]                 }
[09:29:14.336]             }))
[09:29:14.336]             future::FutureResult(value = ...future.value$value, 
[09:29:14.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.336]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.336]                     ...future.globalenv.names))
[09:29:14.336]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.336]         }, condition = base::local({
[09:29:14.336]             c <- base::c
[09:29:14.336]             inherits <- base::inherits
[09:29:14.336]             invokeRestart <- base::invokeRestart
[09:29:14.336]             length <- base::length
[09:29:14.336]             list <- base::list
[09:29:14.336]             seq.int <- base::seq.int
[09:29:14.336]             signalCondition <- base::signalCondition
[09:29:14.336]             sys.calls <- base::sys.calls
[09:29:14.336]             `[[` <- base::`[[`
[09:29:14.336]             `+` <- base::`+`
[09:29:14.336]             `<<-` <- base::`<<-`
[09:29:14.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.336]                   3L)]
[09:29:14.336]             }
[09:29:14.336]             function(cond) {
[09:29:14.336]                 is_error <- inherits(cond, "error")
[09:29:14.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.336]                   NULL)
[09:29:14.336]                 if (is_error) {
[09:29:14.336]                   sessionInformation <- function() {
[09:29:14.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.336]                       search = base::search(), system = base::Sys.info())
[09:29:14.336]                   }
[09:29:14.336]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.336]                     cond$call), session = sessionInformation(), 
[09:29:14.336]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.336]                   signalCondition(cond)
[09:29:14.336]                 }
[09:29:14.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.336]                 "immediateCondition"))) {
[09:29:14.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.336]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.336]                   if (TRUE && !signal) {
[09:29:14.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.336]                     {
[09:29:14.336]                       inherits <- base::inherits
[09:29:14.336]                       invokeRestart <- base::invokeRestart
[09:29:14.336]                       is.null <- base::is.null
[09:29:14.336]                       muffled <- FALSE
[09:29:14.336]                       if (inherits(cond, "message")) {
[09:29:14.336]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.336]                         if (muffled) 
[09:29:14.336]                           invokeRestart("muffleMessage")
[09:29:14.336]                       }
[09:29:14.336]                       else if (inherits(cond, "warning")) {
[09:29:14.336]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.336]                         if (muffled) 
[09:29:14.336]                           invokeRestart("muffleWarning")
[09:29:14.336]                       }
[09:29:14.336]                       else if (inherits(cond, "condition")) {
[09:29:14.336]                         if (!is.null(pattern)) {
[09:29:14.336]                           computeRestarts <- base::computeRestarts
[09:29:14.336]                           grepl <- base::grepl
[09:29:14.336]                           restarts <- computeRestarts(cond)
[09:29:14.336]                           for (restart in restarts) {
[09:29:14.336]                             name <- restart$name
[09:29:14.336]                             if (is.null(name)) 
[09:29:14.336]                               next
[09:29:14.336]                             if (!grepl(pattern, name)) 
[09:29:14.336]                               next
[09:29:14.336]                             invokeRestart(restart)
[09:29:14.336]                             muffled <- TRUE
[09:29:14.336]                             break
[09:29:14.336]                           }
[09:29:14.336]                         }
[09:29:14.336]                       }
[09:29:14.336]                       invisible(muffled)
[09:29:14.336]                     }
[09:29:14.336]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.336]                   }
[09:29:14.336]                 }
[09:29:14.336]                 else {
[09:29:14.336]                   if (TRUE) {
[09:29:14.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.336]                     {
[09:29:14.336]                       inherits <- base::inherits
[09:29:14.336]                       invokeRestart <- base::invokeRestart
[09:29:14.336]                       is.null <- base::is.null
[09:29:14.336]                       muffled <- FALSE
[09:29:14.336]                       if (inherits(cond, "message")) {
[09:29:14.336]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.336]                         if (muffled) 
[09:29:14.336]                           invokeRestart("muffleMessage")
[09:29:14.336]                       }
[09:29:14.336]                       else if (inherits(cond, "warning")) {
[09:29:14.336]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.336]                         if (muffled) 
[09:29:14.336]                           invokeRestart("muffleWarning")
[09:29:14.336]                       }
[09:29:14.336]                       else if (inherits(cond, "condition")) {
[09:29:14.336]                         if (!is.null(pattern)) {
[09:29:14.336]                           computeRestarts <- base::computeRestarts
[09:29:14.336]                           grepl <- base::grepl
[09:29:14.336]                           restarts <- computeRestarts(cond)
[09:29:14.336]                           for (restart in restarts) {
[09:29:14.336]                             name <- restart$name
[09:29:14.336]                             if (is.null(name)) 
[09:29:14.336]                               next
[09:29:14.336]                             if (!grepl(pattern, name)) 
[09:29:14.336]                               next
[09:29:14.336]                             invokeRestart(restart)
[09:29:14.336]                             muffled <- TRUE
[09:29:14.336]                             break
[09:29:14.336]                           }
[09:29:14.336]                         }
[09:29:14.336]                       }
[09:29:14.336]                       invisible(muffled)
[09:29:14.336]                     }
[09:29:14.336]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.336]                   }
[09:29:14.336]                 }
[09:29:14.336]             }
[09:29:14.336]         }))
[09:29:14.336]     }, error = function(ex) {
[09:29:14.336]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.336]                 ...future.rng), started = ...future.startTime, 
[09:29:14.336]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.336]             version = "1.8"), class = "FutureResult")
[09:29:14.336]     }, finally = {
[09:29:14.336]         if (!identical(...future.workdir, getwd())) 
[09:29:14.336]             setwd(...future.workdir)
[09:29:14.336]         {
[09:29:14.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.336]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.336]             }
[09:29:14.336]             base::options(...future.oldOptions)
[09:29:14.336]             if (.Platform$OS.type == "windows") {
[09:29:14.336]                 old_names <- names(...future.oldEnvVars)
[09:29:14.336]                 envs <- base::Sys.getenv()
[09:29:14.336]                 names <- names(envs)
[09:29:14.336]                 common <- intersect(names, old_names)
[09:29:14.336]                 added <- setdiff(names, old_names)
[09:29:14.336]                 removed <- setdiff(old_names, names)
[09:29:14.336]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.336]                   envs[common]]
[09:29:14.336]                 NAMES <- toupper(changed)
[09:29:14.336]                 args <- list()
[09:29:14.336]                 for (kk in seq_along(NAMES)) {
[09:29:14.336]                   name <- changed[[kk]]
[09:29:14.336]                   NAME <- NAMES[[kk]]
[09:29:14.336]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.336]                     next
[09:29:14.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.336]                 }
[09:29:14.336]                 NAMES <- toupper(added)
[09:29:14.336]                 for (kk in seq_along(NAMES)) {
[09:29:14.336]                   name <- added[[kk]]
[09:29:14.336]                   NAME <- NAMES[[kk]]
[09:29:14.336]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.336]                     next
[09:29:14.336]                   args[[name]] <- ""
[09:29:14.336]                 }
[09:29:14.336]                 NAMES <- toupper(removed)
[09:29:14.336]                 for (kk in seq_along(NAMES)) {
[09:29:14.336]                   name <- removed[[kk]]
[09:29:14.336]                   NAME <- NAMES[[kk]]
[09:29:14.336]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.336]                     next
[09:29:14.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.336]                 }
[09:29:14.336]                 if (length(args) > 0) 
[09:29:14.336]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.336]             }
[09:29:14.336]             else {
[09:29:14.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.336]             }
[09:29:14.336]             {
[09:29:14.336]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.336]                   0L) {
[09:29:14.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.336]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.336]                   base::options(opts)
[09:29:14.336]                 }
[09:29:14.336]                 {
[09:29:14.336]                   {
[09:29:14.336]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.336]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.336]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.336]                     NULL
[09:29:14.336]                   }
[09:29:14.336]                   options(future.plan = NULL)
[09:29:14.336]                   if (is.na(NA_character_)) 
[09:29:14.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.336]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.336]                     .init = FALSE)
[09:29:14.336]                 }
[09:29:14.336]             }
[09:29:14.336]         }
[09:29:14.336]     })
[09:29:14.336]     if (TRUE) {
[09:29:14.336]         base::sink(type = "output", split = FALSE)
[09:29:14.336]         if (TRUE) {
[09:29:14.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.336]         }
[09:29:14.336]         else {
[09:29:14.336]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.336]         }
[09:29:14.336]         base::close(...future.stdout)
[09:29:14.336]         ...future.stdout <- NULL
[09:29:14.336]     }
[09:29:14.336]     ...future.result$conditions <- ...future.conditions
[09:29:14.336]     ...future.result$finished <- base::Sys.time()
[09:29:14.336]     ...future.result
[09:29:14.336] }
[09:29:14.338] assign_globals() ...
[09:29:14.338] List of 5
[09:29:14.338]  $ ...future.FUN            :function (x, ...)  
[09:29:14.338]  $ MoreArgs                 :List of 1
[09:29:14.338]   ..$ x: num 42
[09:29:14.338]  $ ...future.elements_ii    :List of 1
[09:29:14.338]   ..$ times:List of 4
[09:29:14.338]   .. ..$ : int 1
[09:29:14.338]   .. ..$ : int 2
[09:29:14.338]   .. ..$ : int 3
[09:29:14.338]   .. ..$ : int 4
[09:29:14.338]  $ ...future.seeds_ii       : NULL
[09:29:14.338]  $ ...future.globals.maxSize: NULL
[09:29:14.338]  - attr(*, "where")=List of 5
[09:29:14.338]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.338]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.338]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.338]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.338]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.338]  - attr(*, "resolved")= logi FALSE
[09:29:14.338]  - attr(*, "total_size")= num 336
[09:29:14.338]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.338]  - attr(*, "already-done")= logi TRUE
[09:29:14.343] - copied ‘...future.FUN’ to environment
[09:29:14.343] - copied ‘MoreArgs’ to environment
[09:29:14.343] - copied ‘...future.elements_ii’ to environment
[09:29:14.343] - copied ‘...future.seeds_ii’ to environment
[09:29:14.343] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.343] assign_globals() ... done
[09:29:14.344] plan(): Setting new future strategy stack:
[09:29:14.344] List of future strategies:
[09:29:14.344] 1. sequential:
[09:29:14.344]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.344]    - tweaked: FALSE
[09:29:14.344]    - call: NULL
[09:29:14.344] plan(): nbrOfWorkers() = 1
[09:29:14.345] plan(): Setting new future strategy stack:
[09:29:14.345] List of future strategies:
[09:29:14.345] 1. sequential:
[09:29:14.345]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.345]    - tweaked: FALSE
[09:29:14.345]    - call: plan(strategy)
[09:29:14.345] plan(): nbrOfWorkers() = 1
[09:29:14.345] SequentialFuture started (and completed)
[09:29:14.346] - Launch lazy future ... done
[09:29:14.346] run() for ‘SequentialFuture’ ... done
[09:29:14.346] Created future:
[09:29:14.346] SequentialFuture:
[09:29:14.346] Label: ‘future_mapply-1’
[09:29:14.346] Expression:
[09:29:14.346] {
[09:29:14.346]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.346]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.346]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.346]         on.exit(options(oopts), add = TRUE)
[09:29:14.346]     }
[09:29:14.346]     {
[09:29:14.346]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.346]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.346]         do.call(mapply, args = args)
[09:29:14.346]     }
[09:29:14.346] }
[09:29:14.346] Lazy evaluation: FALSE
[09:29:14.346] Asynchronous evaluation: FALSE
[09:29:14.346] Local evaluation: TRUE
[09:29:14.346] Environment: R_GlobalEnv
[09:29:14.346] Capture standard output: TRUE
[09:29:14.346] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.346] Globals: 5 objects totaling 336 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.346] Packages: <none>
[09:29:14.346] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.346] Resolved: TRUE
[09:29:14.346] Value: 280 bytes of class ‘list’
[09:29:14.346] Early signaling: FALSE
[09:29:14.346] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.346] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.347] Chunk #1 of 1 ... DONE
[09:29:14.347] Launching 1 futures (chunks) ... DONE
[09:29:14.347] Resolving 1 futures (chunks) ...
[09:29:14.347] resolve() on list ...
[09:29:14.347]  recursive: 0
[09:29:14.348]  length: 1
[09:29:14.348] 
[09:29:14.348] resolved() for ‘SequentialFuture’ ...
[09:29:14.348] - state: ‘finished’
[09:29:14.348] - run: TRUE
[09:29:14.348] - result: ‘FutureResult’
[09:29:14.348] resolved() for ‘SequentialFuture’ ... done
[09:29:14.349] Future #1
[09:29:14.349] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.349] - nx: 1
[09:29:14.349] - relay: TRUE
[09:29:14.349] - stdout: TRUE
[09:29:14.349] - signal: TRUE
[09:29:14.349] - resignal: FALSE
[09:29:14.349] - force: TRUE
[09:29:14.349] - relayed: [n=1] FALSE
[09:29:14.349] - queued futures: [n=1] FALSE
[09:29:14.349]  - until=1
[09:29:14.350]  - relaying element #1
[09:29:14.350] - relayed: [n=1] TRUE
[09:29:14.350] - queued futures: [n=1] TRUE
[09:29:14.350] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.350]  length: 0 (resolved future 1)
[09:29:14.350] Relaying remaining futures
[09:29:14.350] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.350] - nx: 1
[09:29:14.350] - relay: TRUE
[09:29:14.350] - stdout: TRUE
[09:29:14.350] - signal: TRUE
[09:29:14.351] - resignal: FALSE
[09:29:14.351] - force: TRUE
[09:29:14.351] - relayed: [n=1] TRUE
[09:29:14.351] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.351] - relayed: [n=1] TRUE
[09:29:14.351] - queued futures: [n=1] TRUE
[09:29:14.351] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.351] resolve() on list ... DONE
[09:29:14.351]  - Number of value chunks collected: 1
[09:29:14.351] Resolving 1 futures (chunks) ... DONE
[09:29:14.351] Reducing values from 1 chunks ...
[09:29:14.351]  - Number of values collected after concatenation: 4
[09:29:14.352]  - Number of values expected: 4
[09:29:14.352] Reducing values from 1 chunks ... DONE
[09:29:14.352] future_mapply() ... DONE
[09:29:14.352] future_mapply() ...
[09:29:14.352] Number of chunks: 1
[09:29:14.352] getGlobalsAndPackagesXApply() ...
[09:29:14.352]  - future.globals: TRUE
[09:29:14.352] getGlobalsAndPackages() ...
[09:29:14.352] Searching for globals...
[09:29:14.353] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[09:29:14.354] Searching for globals ... DONE
[09:29:14.354] Resolving globals: FALSE
[09:29:14.354] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[09:29:14.354] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[09:29:14.354] - globals: [1] ‘FUN’
[09:29:14.355] 
[09:29:14.355] getGlobalsAndPackages() ... DONE
[09:29:14.355]  - globals found/used: [n=1] ‘FUN’
[09:29:14.355]  - needed namespaces: [n=0] 
[09:29:14.355] Finding globals ... DONE
[09:29:14.355] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.355] List of 2
[09:29:14.355]  $ ...future.FUN:function (x, y)  
[09:29:14.355]  $ MoreArgs     : NULL
[09:29:14.355]  - attr(*, "where")=List of 2
[09:29:14.355]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.355]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.355]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.355]  - attr(*, "resolved")= logi FALSE
[09:29:14.355]  - attr(*, "total_size")= num NA
[09:29:14.357] Packages to be attached in all futures: [n=0] 
[09:29:14.357] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.358] Number of futures (= number of chunks): 1
[09:29:14.358] Launching 1 futures (chunks) ...
[09:29:14.358] Chunk #1 of 1 ...
[09:29:14.358]  - Finding globals in '...' for chunk #1 ...
[09:29:14.358] getGlobalsAndPackages() ...
[09:29:14.358] Searching for globals...
[09:29:14.358] 
[09:29:14.358] Searching for globals ... DONE
[09:29:14.358] - globals: [0] <none>
[09:29:14.359] getGlobalsAndPackages() ... DONE
[09:29:14.359]    + additional globals found: [n=0] 
[09:29:14.359]    + additional namespaces needed: [n=0] 
[09:29:14.359]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.359]  - seeds: <none>
[09:29:14.359]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.359] getGlobalsAndPackages() ...
[09:29:14.359] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.359] Resolving globals: FALSE
[09:29:14.360] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[09:29:14.360] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.360] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.360] 
[09:29:14.360] getGlobalsAndPackages() ... DONE
[09:29:14.361] run() for ‘Future’ ...
[09:29:14.361] - state: ‘created’
[09:29:14.361] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.361] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.361] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.361]   - Field: ‘label’
[09:29:14.361]   - Field: ‘local’
[09:29:14.361]   - Field: ‘owner’
[09:29:14.362]   - Field: ‘envir’
[09:29:14.362]   - Field: ‘packages’
[09:29:14.362]   - Field: ‘gc’
[09:29:14.362]   - Field: ‘conditions’
[09:29:14.362]   - Field: ‘expr’
[09:29:14.362]   - Field: ‘uuid’
[09:29:14.362]   - Field: ‘seed’
[09:29:14.362]   - Field: ‘version’
[09:29:14.362]   - Field: ‘result’
[09:29:14.362]   - Field: ‘asynchronous’
[09:29:14.362]   - Field: ‘calls’
[09:29:14.362]   - Field: ‘globals’
[09:29:14.363]   - Field: ‘stdout’
[09:29:14.363]   - Field: ‘earlySignal’
[09:29:14.363]   - Field: ‘lazy’
[09:29:14.363]   - Field: ‘state’
[09:29:14.363] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.363] - Launch lazy future ...
[09:29:14.363] Packages needed by the future expression (n = 0): <none>
[09:29:14.363] Packages needed by future strategies (n = 0): <none>
[09:29:14.364] {
[09:29:14.364]     {
[09:29:14.364]         {
[09:29:14.364]             ...future.startTime <- base::Sys.time()
[09:29:14.364]             {
[09:29:14.364]                 {
[09:29:14.364]                   {
[09:29:14.364]                     base::local({
[09:29:14.364]                       has_future <- base::requireNamespace("future", 
[09:29:14.364]                         quietly = TRUE)
[09:29:14.364]                       if (has_future) {
[09:29:14.364]                         ns <- base::getNamespace("future")
[09:29:14.364]                         version <- ns[[".package"]][["version"]]
[09:29:14.364]                         if (is.null(version)) 
[09:29:14.364]                           version <- utils::packageVersion("future")
[09:29:14.364]                       }
[09:29:14.364]                       else {
[09:29:14.364]                         version <- NULL
[09:29:14.364]                       }
[09:29:14.364]                       if (!has_future || version < "1.8.0") {
[09:29:14.364]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.364]                           "", base::R.version$version.string), 
[09:29:14.364]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.364]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.364]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.364]                             "release", "version")], collapse = " "), 
[09:29:14.364]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.364]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.364]                           info)
[09:29:14.364]                         info <- base::paste(info, collapse = "; ")
[09:29:14.364]                         if (!has_future) {
[09:29:14.364]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.364]                             info)
[09:29:14.364]                         }
[09:29:14.364]                         else {
[09:29:14.364]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.364]                             info, version)
[09:29:14.364]                         }
[09:29:14.364]                         base::stop(msg)
[09:29:14.364]                       }
[09:29:14.364]                     })
[09:29:14.364]                   }
[09:29:14.364]                   ...future.strategy.old <- future::plan("list")
[09:29:14.364]                   options(future.plan = NULL)
[09:29:14.364]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.364]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.364]                 }
[09:29:14.364]                 ...future.workdir <- getwd()
[09:29:14.364]             }
[09:29:14.364]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.364]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.364]         }
[09:29:14.364]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.364]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.364]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.364]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.364]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.364]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.364]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.364]             base::names(...future.oldOptions))
[09:29:14.364]     }
[09:29:14.364]     if (FALSE) {
[09:29:14.364]     }
[09:29:14.364]     else {
[09:29:14.364]         if (TRUE) {
[09:29:14.364]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.364]                 open = "w")
[09:29:14.364]         }
[09:29:14.364]         else {
[09:29:14.364]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.364]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.364]         }
[09:29:14.364]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.364]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.364]             base::sink(type = "output", split = FALSE)
[09:29:14.364]             base::close(...future.stdout)
[09:29:14.364]         }, add = TRUE)
[09:29:14.364]     }
[09:29:14.364]     ...future.frame <- base::sys.nframe()
[09:29:14.364]     ...future.conditions <- base::list()
[09:29:14.364]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.364]     if (FALSE) {
[09:29:14.364]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.364]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.364]     }
[09:29:14.364]     ...future.result <- base::tryCatch({
[09:29:14.364]         base::withCallingHandlers({
[09:29:14.364]             ...future.value <- base::withVisible(base::local({
[09:29:14.364]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.364]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.364]                   ...future.globals.maxSize)) {
[09:29:14.364]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.364]                   on.exit(options(oopts), add = TRUE)
[09:29:14.364]                 }
[09:29:14.364]                 {
[09:29:14.364]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.364]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.364]                     USE.NAMES = FALSE)
[09:29:14.364]                   do.call(mapply, args = args)
[09:29:14.364]                 }
[09:29:14.364]             }))
[09:29:14.364]             future::FutureResult(value = ...future.value$value, 
[09:29:14.364]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.364]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.364]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.364]                     ...future.globalenv.names))
[09:29:14.364]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.364]         }, condition = base::local({
[09:29:14.364]             c <- base::c
[09:29:14.364]             inherits <- base::inherits
[09:29:14.364]             invokeRestart <- base::invokeRestart
[09:29:14.364]             length <- base::length
[09:29:14.364]             list <- base::list
[09:29:14.364]             seq.int <- base::seq.int
[09:29:14.364]             signalCondition <- base::signalCondition
[09:29:14.364]             sys.calls <- base::sys.calls
[09:29:14.364]             `[[` <- base::`[[`
[09:29:14.364]             `+` <- base::`+`
[09:29:14.364]             `<<-` <- base::`<<-`
[09:29:14.364]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.364]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.364]                   3L)]
[09:29:14.364]             }
[09:29:14.364]             function(cond) {
[09:29:14.364]                 is_error <- inherits(cond, "error")
[09:29:14.364]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.364]                   NULL)
[09:29:14.364]                 if (is_error) {
[09:29:14.364]                   sessionInformation <- function() {
[09:29:14.364]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.364]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.364]                       search = base::search(), system = base::Sys.info())
[09:29:14.364]                   }
[09:29:14.364]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.364]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.364]                     cond$call), session = sessionInformation(), 
[09:29:14.364]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.364]                   signalCondition(cond)
[09:29:14.364]                 }
[09:29:14.364]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.364]                 "immediateCondition"))) {
[09:29:14.364]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.364]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.364]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.364]                   if (TRUE && !signal) {
[09:29:14.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.364]                     {
[09:29:14.364]                       inherits <- base::inherits
[09:29:14.364]                       invokeRestart <- base::invokeRestart
[09:29:14.364]                       is.null <- base::is.null
[09:29:14.364]                       muffled <- FALSE
[09:29:14.364]                       if (inherits(cond, "message")) {
[09:29:14.364]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.364]                         if (muffled) 
[09:29:14.364]                           invokeRestart("muffleMessage")
[09:29:14.364]                       }
[09:29:14.364]                       else if (inherits(cond, "warning")) {
[09:29:14.364]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.364]                         if (muffled) 
[09:29:14.364]                           invokeRestart("muffleWarning")
[09:29:14.364]                       }
[09:29:14.364]                       else if (inherits(cond, "condition")) {
[09:29:14.364]                         if (!is.null(pattern)) {
[09:29:14.364]                           computeRestarts <- base::computeRestarts
[09:29:14.364]                           grepl <- base::grepl
[09:29:14.364]                           restarts <- computeRestarts(cond)
[09:29:14.364]                           for (restart in restarts) {
[09:29:14.364]                             name <- restart$name
[09:29:14.364]                             if (is.null(name)) 
[09:29:14.364]                               next
[09:29:14.364]                             if (!grepl(pattern, name)) 
[09:29:14.364]                               next
[09:29:14.364]                             invokeRestart(restart)
[09:29:14.364]                             muffled <- TRUE
[09:29:14.364]                             break
[09:29:14.364]                           }
[09:29:14.364]                         }
[09:29:14.364]                       }
[09:29:14.364]                       invisible(muffled)
[09:29:14.364]                     }
[09:29:14.364]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.364]                   }
[09:29:14.364]                 }
[09:29:14.364]                 else {
[09:29:14.364]                   if (TRUE) {
[09:29:14.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.364]                     {
[09:29:14.364]                       inherits <- base::inherits
[09:29:14.364]                       invokeRestart <- base::invokeRestart
[09:29:14.364]                       is.null <- base::is.null
[09:29:14.364]                       muffled <- FALSE
[09:29:14.364]                       if (inherits(cond, "message")) {
[09:29:14.364]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.364]                         if (muffled) 
[09:29:14.364]                           invokeRestart("muffleMessage")
[09:29:14.364]                       }
[09:29:14.364]                       else if (inherits(cond, "warning")) {
[09:29:14.364]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.364]                         if (muffled) 
[09:29:14.364]                           invokeRestart("muffleWarning")
[09:29:14.364]                       }
[09:29:14.364]                       else if (inherits(cond, "condition")) {
[09:29:14.364]                         if (!is.null(pattern)) {
[09:29:14.364]                           computeRestarts <- base::computeRestarts
[09:29:14.364]                           grepl <- base::grepl
[09:29:14.364]                           restarts <- computeRestarts(cond)
[09:29:14.364]                           for (restart in restarts) {
[09:29:14.364]                             name <- restart$name
[09:29:14.364]                             if (is.null(name)) 
[09:29:14.364]                               next
[09:29:14.364]                             if (!grepl(pattern, name)) 
[09:29:14.364]                               next
[09:29:14.364]                             invokeRestart(restart)
[09:29:14.364]                             muffled <- TRUE
[09:29:14.364]                             break
[09:29:14.364]                           }
[09:29:14.364]                         }
[09:29:14.364]                       }
[09:29:14.364]                       invisible(muffled)
[09:29:14.364]                     }
[09:29:14.364]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.364]                   }
[09:29:14.364]                 }
[09:29:14.364]             }
[09:29:14.364]         }))
[09:29:14.364]     }, error = function(ex) {
[09:29:14.364]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.364]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.364]                 ...future.rng), started = ...future.startTime, 
[09:29:14.364]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.364]             version = "1.8"), class = "FutureResult")
[09:29:14.364]     }, finally = {
[09:29:14.364]         if (!identical(...future.workdir, getwd())) 
[09:29:14.364]             setwd(...future.workdir)
[09:29:14.364]         {
[09:29:14.364]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.364]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.364]             }
[09:29:14.364]             base::options(...future.oldOptions)
[09:29:14.364]             if (.Platform$OS.type == "windows") {
[09:29:14.364]                 old_names <- names(...future.oldEnvVars)
[09:29:14.364]                 envs <- base::Sys.getenv()
[09:29:14.364]                 names <- names(envs)
[09:29:14.364]                 common <- intersect(names, old_names)
[09:29:14.364]                 added <- setdiff(names, old_names)
[09:29:14.364]                 removed <- setdiff(old_names, names)
[09:29:14.364]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.364]                   envs[common]]
[09:29:14.364]                 NAMES <- toupper(changed)
[09:29:14.364]                 args <- list()
[09:29:14.364]                 for (kk in seq_along(NAMES)) {
[09:29:14.364]                   name <- changed[[kk]]
[09:29:14.364]                   NAME <- NAMES[[kk]]
[09:29:14.364]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.364]                     next
[09:29:14.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.364]                 }
[09:29:14.364]                 NAMES <- toupper(added)
[09:29:14.364]                 for (kk in seq_along(NAMES)) {
[09:29:14.364]                   name <- added[[kk]]
[09:29:14.364]                   NAME <- NAMES[[kk]]
[09:29:14.364]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.364]                     next
[09:29:14.364]                   args[[name]] <- ""
[09:29:14.364]                 }
[09:29:14.364]                 NAMES <- toupper(removed)
[09:29:14.364]                 for (kk in seq_along(NAMES)) {
[09:29:14.364]                   name <- removed[[kk]]
[09:29:14.364]                   NAME <- NAMES[[kk]]
[09:29:14.364]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.364]                     next
[09:29:14.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.364]                 }
[09:29:14.364]                 if (length(args) > 0) 
[09:29:14.364]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.364]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.364]             }
[09:29:14.364]             else {
[09:29:14.364]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.364]             }
[09:29:14.364]             {
[09:29:14.364]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.364]                   0L) {
[09:29:14.364]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.364]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.364]                   base::options(opts)
[09:29:14.364]                 }
[09:29:14.364]                 {
[09:29:14.364]                   {
[09:29:14.364]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.364]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.364]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.364]                     NULL
[09:29:14.364]                   }
[09:29:14.364]                   options(future.plan = NULL)
[09:29:14.364]                   if (is.na(NA_character_)) 
[09:29:14.364]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.364]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.364]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.364]                     .init = FALSE)
[09:29:14.364]                 }
[09:29:14.364]             }
[09:29:14.364]         }
[09:29:14.364]     })
[09:29:14.364]     if (TRUE) {
[09:29:14.364]         base::sink(type = "output", split = FALSE)
[09:29:14.364]         if (TRUE) {
[09:29:14.364]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.364]         }
[09:29:14.364]         else {
[09:29:14.364]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.364]         }
[09:29:14.364]         base::close(...future.stdout)
[09:29:14.364]         ...future.stdout <- NULL
[09:29:14.364]     }
[09:29:14.364]     ...future.result$conditions <- ...future.conditions
[09:29:14.364]     ...future.result$finished <- base::Sys.time()
[09:29:14.364]     ...future.result
[09:29:14.364] }
[09:29:14.365] assign_globals() ...
[09:29:14.365] List of 5
[09:29:14.365]  $ ...future.FUN            :function (x, y)  
[09:29:14.365]  $ MoreArgs                 : NULL
[09:29:14.365]  $ ...future.elements_ii    :List of 2
[09:29:14.365]   ..$ :List of 3
[09:29:14.365]   .. ..$ a: num 1
[09:29:14.365]   .. ..$ b: num 2
[09:29:14.365]   .. ..$ c: num 3
[09:29:14.365]   ..$ :List of 3
[09:29:14.365]   .. ..$ A: num 10
[09:29:14.365]   .. ..$ B: num 0
[09:29:14.365]   .. ..$ C: num -10
[09:29:14.365]  $ ...future.seeds_ii       : NULL
[09:29:14.365]  $ ...future.globals.maxSize: NULL
[09:29:14.365]  - attr(*, "where")=List of 5
[09:29:14.365]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.365]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.365]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.365]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.365]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.365]  - attr(*, "resolved")= logi FALSE
[09:29:14.365]  - attr(*, "total_size")= num 2312
[09:29:14.365]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.365]  - attr(*, "already-done")= logi TRUE
[09:29:14.372] - reassign environment for ‘...future.FUN’
[09:29:14.372] - copied ‘...future.FUN’ to environment
[09:29:14.372] - copied ‘MoreArgs’ to environment
[09:29:14.372] - copied ‘...future.elements_ii’ to environment
[09:29:14.372] - copied ‘...future.seeds_ii’ to environment
[09:29:14.372] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.373] assign_globals() ... done
[09:29:14.373] plan(): Setting new future strategy stack:
[09:29:14.373] List of future strategies:
[09:29:14.373] 1. sequential:
[09:29:14.373]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.373]    - tweaked: FALSE
[09:29:14.373]    - call: NULL
[09:29:14.373] plan(): nbrOfWorkers() = 1
[09:29:14.374] plan(): Setting new future strategy stack:
[09:29:14.374] List of future strategies:
[09:29:14.374] 1. sequential:
[09:29:14.374]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.374]    - tweaked: FALSE
[09:29:14.374]    - call: plan(strategy)
[09:29:14.374] plan(): nbrOfWorkers() = 1
[09:29:14.375] SequentialFuture started (and completed)
[09:29:14.375] - Launch lazy future ... done
[09:29:14.375] run() for ‘SequentialFuture’ ... done
[09:29:14.375] Created future:
[09:29:14.375] SequentialFuture:
[09:29:14.375] Label: ‘future_mapply-1’
[09:29:14.375] Expression:
[09:29:14.375] {
[09:29:14.375]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.375]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.375]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.375]         on.exit(options(oopts), add = TRUE)
[09:29:14.375]     }
[09:29:14.375]     {
[09:29:14.375]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.375]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.375]         do.call(mapply, args = args)
[09:29:14.375]     }
[09:29:14.375] }
[09:29:14.375] Lazy evaluation: FALSE
[09:29:14.375] Asynchronous evaluation: FALSE
[09:29:14.375] Local evaluation: TRUE
[09:29:14.375] Environment: R_GlobalEnv
[09:29:14.375] Capture standard output: TRUE
[09:29:14.375] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.375] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.375] Packages: <none>
[09:29:14.375] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.375] Resolved: TRUE
[09:29:14.375] Value: 200 bytes of class ‘list’
[09:29:14.375] Early signaling: FALSE
[09:29:14.375] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.375] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.376] Chunk #1 of 1 ... DONE
[09:29:14.376] Launching 1 futures (chunks) ... DONE
[09:29:14.376] Resolving 1 futures (chunks) ...
[09:29:14.376] resolve() on list ...
[09:29:14.376]  recursive: 0
[09:29:14.376]  length: 1
[09:29:14.376] 
[09:29:14.376] resolved() for ‘SequentialFuture’ ...
[09:29:14.376] - state: ‘finished’
[09:29:14.377] - run: TRUE
[09:29:14.377] - result: ‘FutureResult’
[09:29:14.377] resolved() for ‘SequentialFuture’ ... done
[09:29:14.377] Future #1
[09:29:14.377] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.377] - nx: 1
[09:29:14.377] - relay: TRUE
[09:29:14.377] - stdout: TRUE
[09:29:14.377] - signal: TRUE
[09:29:14.377] - resignal: FALSE
[09:29:14.377] - force: TRUE
[09:29:14.377] - relayed: [n=1] FALSE
[09:29:14.378] - queued futures: [n=1] FALSE
[09:29:14.378]  - until=1
[09:29:14.378]  - relaying element #1
[09:29:14.378] - relayed: [n=1] TRUE
[09:29:14.378] - queued futures: [n=1] TRUE
[09:29:14.378] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.378]  length: 0 (resolved future 1)
[09:29:14.378] Relaying remaining futures
[09:29:14.378] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.378] - nx: 1
[09:29:14.378] - relay: TRUE
[09:29:14.379] - stdout: TRUE
[09:29:14.379] - signal: TRUE
[09:29:14.379] - resignal: FALSE
[09:29:14.379] - force: TRUE
[09:29:14.379] - relayed: [n=1] TRUE
[09:29:14.379] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.379] - relayed: [n=1] TRUE
[09:29:14.379] - queued futures: [n=1] TRUE
[09:29:14.379] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.379] resolve() on list ... DONE
[09:29:14.379]  - Number of value chunks collected: 1
[09:29:14.379] Resolving 1 futures (chunks) ... DONE
[09:29:14.380] Reducing values from 1 chunks ...
[09:29:14.380]  - Number of values collected after concatenation: 3
[09:29:14.380]  - Number of values expected: 3
[09:29:14.380] Reducing values from 1 chunks ... DONE
[09:29:14.380] future_mapply() ... DONE
- future_.mapply()
[09:29:14.381] future_mapply() ...
[09:29:14.381] Number of chunks: 1
[09:29:14.381] getGlobalsAndPackagesXApply() ...
[09:29:14.381]  - future.globals: TRUE
[09:29:14.381] getGlobalsAndPackages() ...
[09:29:14.381] Searching for globals...
[09:29:14.382] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[09:29:14.382] Searching for globals ... DONE
[09:29:14.382] Resolving globals: FALSE
[09:29:14.383] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[09:29:14.383] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[09:29:14.383] - globals: [1] ‘FUN’
[09:29:14.383] 
[09:29:14.383] getGlobalsAndPackages() ... DONE
[09:29:14.383]  - globals found/used: [n=1] ‘FUN’
[09:29:14.383]  - needed namespaces: [n=0] 
[09:29:14.384] Finding globals ... DONE
[09:29:14.384] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.384] List of 2
[09:29:14.384]  $ ...future.FUN:function (x, y)  
[09:29:14.384]  $ MoreArgs     : list()
[09:29:14.384]  - attr(*, "where")=List of 2
[09:29:14.384]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.384]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.384]  - attr(*, "resolved")= logi FALSE
[09:29:14.384]  - attr(*, "total_size")= num NA
[09:29:14.386] Packages to be attached in all futures: [n=0] 
[09:29:14.386] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.386] Number of futures (= number of chunks): 1
[09:29:14.386] Launching 1 futures (chunks) ...
[09:29:14.386] Chunk #1 of 1 ...
[09:29:14.387]  - Finding globals in '...' for chunk #1 ...
[09:29:14.387] getGlobalsAndPackages() ...
[09:29:14.387] Searching for globals...
[09:29:14.387] 
[09:29:14.387] Searching for globals ... DONE
[09:29:14.387] - globals: [0] <none>
[09:29:14.387] getGlobalsAndPackages() ... DONE
[09:29:14.387]    + additional globals found: [n=0] 
[09:29:14.387]    + additional namespaces needed: [n=0] 
[09:29:14.388]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.388]  - seeds: <none>
[09:29:14.388]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.388] getGlobalsAndPackages() ...
[09:29:14.388] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.388] Resolving globals: FALSE
[09:29:14.388] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[09:29:14.389] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:14.389] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.389] 
[09:29:14.389] getGlobalsAndPackages() ... DONE
[09:29:14.389] run() for ‘Future’ ...
[09:29:14.389] - state: ‘created’
[09:29:14.390] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.390] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.390] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.390]   - Field: ‘label’
[09:29:14.390]   - Field: ‘local’
[09:29:14.390]   - Field: ‘owner’
[09:29:14.390]   - Field: ‘envir’
[09:29:14.390]   - Field: ‘packages’
[09:29:14.390]   - Field: ‘gc’
[09:29:14.391]   - Field: ‘conditions’
[09:29:14.391]   - Field: ‘expr’
[09:29:14.391]   - Field: ‘uuid’
[09:29:14.391]   - Field: ‘seed’
[09:29:14.391]   - Field: ‘version’
[09:29:14.391]   - Field: ‘result’
[09:29:14.391]   - Field: ‘asynchronous’
[09:29:14.391]   - Field: ‘calls’
[09:29:14.391]   - Field: ‘globals’
[09:29:14.391]   - Field: ‘stdout’
[09:29:14.391]   - Field: ‘earlySignal’
[09:29:14.391]   - Field: ‘lazy’
[09:29:14.392]   - Field: ‘state’
[09:29:14.392] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.392] - Launch lazy future ...
[09:29:14.392] Packages needed by the future expression (n = 0): <none>
[09:29:14.392] Packages needed by future strategies (n = 0): <none>
[09:29:14.392] {
[09:29:14.392]     {
[09:29:14.392]         {
[09:29:14.392]             ...future.startTime <- base::Sys.time()
[09:29:14.392]             {
[09:29:14.392]                 {
[09:29:14.392]                   {
[09:29:14.392]                     base::local({
[09:29:14.392]                       has_future <- base::requireNamespace("future", 
[09:29:14.392]                         quietly = TRUE)
[09:29:14.392]                       if (has_future) {
[09:29:14.392]                         ns <- base::getNamespace("future")
[09:29:14.392]                         version <- ns[[".package"]][["version"]]
[09:29:14.392]                         if (is.null(version)) 
[09:29:14.392]                           version <- utils::packageVersion("future")
[09:29:14.392]                       }
[09:29:14.392]                       else {
[09:29:14.392]                         version <- NULL
[09:29:14.392]                       }
[09:29:14.392]                       if (!has_future || version < "1.8.0") {
[09:29:14.392]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.392]                           "", base::R.version$version.string), 
[09:29:14.392]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.392]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.392]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.392]                             "release", "version")], collapse = " "), 
[09:29:14.392]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.392]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.392]                           info)
[09:29:14.392]                         info <- base::paste(info, collapse = "; ")
[09:29:14.392]                         if (!has_future) {
[09:29:14.392]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.392]                             info)
[09:29:14.392]                         }
[09:29:14.392]                         else {
[09:29:14.392]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.392]                             info, version)
[09:29:14.392]                         }
[09:29:14.392]                         base::stop(msg)
[09:29:14.392]                       }
[09:29:14.392]                     })
[09:29:14.392]                   }
[09:29:14.392]                   ...future.strategy.old <- future::plan("list")
[09:29:14.392]                   options(future.plan = NULL)
[09:29:14.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.392]                 }
[09:29:14.392]                 ...future.workdir <- getwd()
[09:29:14.392]             }
[09:29:14.392]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.392]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.392]         }
[09:29:14.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.392]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.392]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.392]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.392]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.392]             base::names(...future.oldOptions))
[09:29:14.392]     }
[09:29:14.392]     if (FALSE) {
[09:29:14.392]     }
[09:29:14.392]     else {
[09:29:14.392]         if (TRUE) {
[09:29:14.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.392]                 open = "w")
[09:29:14.392]         }
[09:29:14.392]         else {
[09:29:14.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.392]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.392]         }
[09:29:14.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.392]             base::sink(type = "output", split = FALSE)
[09:29:14.392]             base::close(...future.stdout)
[09:29:14.392]         }, add = TRUE)
[09:29:14.392]     }
[09:29:14.392]     ...future.frame <- base::sys.nframe()
[09:29:14.392]     ...future.conditions <- base::list()
[09:29:14.392]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.392]     if (FALSE) {
[09:29:14.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.392]     }
[09:29:14.392]     ...future.result <- base::tryCatch({
[09:29:14.392]         base::withCallingHandlers({
[09:29:14.392]             ...future.value <- base::withVisible(base::local({
[09:29:14.392]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.392]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.392]                   ...future.globals.maxSize)) {
[09:29:14.392]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.392]                   on.exit(options(oopts), add = TRUE)
[09:29:14.392]                 }
[09:29:14.392]                 {
[09:29:14.392]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.392]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.392]                     USE.NAMES = FALSE)
[09:29:14.392]                   do.call(mapply, args = args)
[09:29:14.392]                 }
[09:29:14.392]             }))
[09:29:14.392]             future::FutureResult(value = ...future.value$value, 
[09:29:14.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.392]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.392]                     ...future.globalenv.names))
[09:29:14.392]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.392]         }, condition = base::local({
[09:29:14.392]             c <- base::c
[09:29:14.392]             inherits <- base::inherits
[09:29:14.392]             invokeRestart <- base::invokeRestart
[09:29:14.392]             length <- base::length
[09:29:14.392]             list <- base::list
[09:29:14.392]             seq.int <- base::seq.int
[09:29:14.392]             signalCondition <- base::signalCondition
[09:29:14.392]             sys.calls <- base::sys.calls
[09:29:14.392]             `[[` <- base::`[[`
[09:29:14.392]             `+` <- base::`+`
[09:29:14.392]             `<<-` <- base::`<<-`
[09:29:14.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.392]                   3L)]
[09:29:14.392]             }
[09:29:14.392]             function(cond) {
[09:29:14.392]                 is_error <- inherits(cond, "error")
[09:29:14.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.392]                   NULL)
[09:29:14.392]                 if (is_error) {
[09:29:14.392]                   sessionInformation <- function() {
[09:29:14.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.392]                       search = base::search(), system = base::Sys.info())
[09:29:14.392]                   }
[09:29:14.392]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.392]                     cond$call), session = sessionInformation(), 
[09:29:14.392]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.392]                   signalCondition(cond)
[09:29:14.392]                 }
[09:29:14.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.392]                 "immediateCondition"))) {
[09:29:14.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.392]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.392]                   if (TRUE && !signal) {
[09:29:14.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.392]                     {
[09:29:14.392]                       inherits <- base::inherits
[09:29:14.392]                       invokeRestart <- base::invokeRestart
[09:29:14.392]                       is.null <- base::is.null
[09:29:14.392]                       muffled <- FALSE
[09:29:14.392]                       if (inherits(cond, "message")) {
[09:29:14.392]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.392]                         if (muffled) 
[09:29:14.392]                           invokeRestart("muffleMessage")
[09:29:14.392]                       }
[09:29:14.392]                       else if (inherits(cond, "warning")) {
[09:29:14.392]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.392]                         if (muffled) 
[09:29:14.392]                           invokeRestart("muffleWarning")
[09:29:14.392]                       }
[09:29:14.392]                       else if (inherits(cond, "condition")) {
[09:29:14.392]                         if (!is.null(pattern)) {
[09:29:14.392]                           computeRestarts <- base::computeRestarts
[09:29:14.392]                           grepl <- base::grepl
[09:29:14.392]                           restarts <- computeRestarts(cond)
[09:29:14.392]                           for (restart in restarts) {
[09:29:14.392]                             name <- restart$name
[09:29:14.392]                             if (is.null(name)) 
[09:29:14.392]                               next
[09:29:14.392]                             if (!grepl(pattern, name)) 
[09:29:14.392]                               next
[09:29:14.392]                             invokeRestart(restart)
[09:29:14.392]                             muffled <- TRUE
[09:29:14.392]                             break
[09:29:14.392]                           }
[09:29:14.392]                         }
[09:29:14.392]                       }
[09:29:14.392]                       invisible(muffled)
[09:29:14.392]                     }
[09:29:14.392]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.392]                   }
[09:29:14.392]                 }
[09:29:14.392]                 else {
[09:29:14.392]                   if (TRUE) {
[09:29:14.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.392]                     {
[09:29:14.392]                       inherits <- base::inherits
[09:29:14.392]                       invokeRestart <- base::invokeRestart
[09:29:14.392]                       is.null <- base::is.null
[09:29:14.392]                       muffled <- FALSE
[09:29:14.392]                       if (inherits(cond, "message")) {
[09:29:14.392]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.392]                         if (muffled) 
[09:29:14.392]                           invokeRestart("muffleMessage")
[09:29:14.392]                       }
[09:29:14.392]                       else if (inherits(cond, "warning")) {
[09:29:14.392]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.392]                         if (muffled) 
[09:29:14.392]                           invokeRestart("muffleWarning")
[09:29:14.392]                       }
[09:29:14.392]                       else if (inherits(cond, "condition")) {
[09:29:14.392]                         if (!is.null(pattern)) {
[09:29:14.392]                           computeRestarts <- base::computeRestarts
[09:29:14.392]                           grepl <- base::grepl
[09:29:14.392]                           restarts <- computeRestarts(cond)
[09:29:14.392]                           for (restart in restarts) {
[09:29:14.392]                             name <- restart$name
[09:29:14.392]                             if (is.null(name)) 
[09:29:14.392]                               next
[09:29:14.392]                             if (!grepl(pattern, name)) 
[09:29:14.392]                               next
[09:29:14.392]                             invokeRestart(restart)
[09:29:14.392]                             muffled <- TRUE
[09:29:14.392]                             break
[09:29:14.392]                           }
[09:29:14.392]                         }
[09:29:14.392]                       }
[09:29:14.392]                       invisible(muffled)
[09:29:14.392]                     }
[09:29:14.392]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.392]                   }
[09:29:14.392]                 }
[09:29:14.392]             }
[09:29:14.392]         }))
[09:29:14.392]     }, error = function(ex) {
[09:29:14.392]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.392]                 ...future.rng), started = ...future.startTime, 
[09:29:14.392]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.392]             version = "1.8"), class = "FutureResult")
[09:29:14.392]     }, finally = {
[09:29:14.392]         if (!identical(...future.workdir, getwd())) 
[09:29:14.392]             setwd(...future.workdir)
[09:29:14.392]         {
[09:29:14.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.392]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.392]             }
[09:29:14.392]             base::options(...future.oldOptions)
[09:29:14.392]             if (.Platform$OS.type == "windows") {
[09:29:14.392]                 old_names <- names(...future.oldEnvVars)
[09:29:14.392]                 envs <- base::Sys.getenv()
[09:29:14.392]                 names <- names(envs)
[09:29:14.392]                 common <- intersect(names, old_names)
[09:29:14.392]                 added <- setdiff(names, old_names)
[09:29:14.392]                 removed <- setdiff(old_names, names)
[09:29:14.392]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.392]                   envs[common]]
[09:29:14.392]                 NAMES <- toupper(changed)
[09:29:14.392]                 args <- list()
[09:29:14.392]                 for (kk in seq_along(NAMES)) {
[09:29:14.392]                   name <- changed[[kk]]
[09:29:14.392]                   NAME <- NAMES[[kk]]
[09:29:14.392]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.392]                     next
[09:29:14.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.392]                 }
[09:29:14.392]                 NAMES <- toupper(added)
[09:29:14.392]                 for (kk in seq_along(NAMES)) {
[09:29:14.392]                   name <- added[[kk]]
[09:29:14.392]                   NAME <- NAMES[[kk]]
[09:29:14.392]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.392]                     next
[09:29:14.392]                   args[[name]] <- ""
[09:29:14.392]                 }
[09:29:14.392]                 NAMES <- toupper(removed)
[09:29:14.392]                 for (kk in seq_along(NAMES)) {
[09:29:14.392]                   name <- removed[[kk]]
[09:29:14.392]                   NAME <- NAMES[[kk]]
[09:29:14.392]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.392]                     next
[09:29:14.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.392]                 }
[09:29:14.392]                 if (length(args) > 0) 
[09:29:14.392]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.392]             }
[09:29:14.392]             else {
[09:29:14.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.392]             }
[09:29:14.392]             {
[09:29:14.392]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.392]                   0L) {
[09:29:14.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.392]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.392]                   base::options(opts)
[09:29:14.392]                 }
[09:29:14.392]                 {
[09:29:14.392]                   {
[09:29:14.392]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.392]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.392]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.392]                     NULL
[09:29:14.392]                   }
[09:29:14.392]                   options(future.plan = NULL)
[09:29:14.392]                   if (is.na(NA_character_)) 
[09:29:14.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.392]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.392]                     .init = FALSE)
[09:29:14.392]                 }
[09:29:14.392]             }
[09:29:14.392]         }
[09:29:14.392]     })
[09:29:14.392]     if (TRUE) {
[09:29:14.392]         base::sink(type = "output", split = FALSE)
[09:29:14.392]         if (TRUE) {
[09:29:14.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.392]         }
[09:29:14.392]         else {
[09:29:14.392]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.392]         }
[09:29:14.392]         base::close(...future.stdout)
[09:29:14.392]         ...future.stdout <- NULL
[09:29:14.392]     }
[09:29:14.392]     ...future.result$conditions <- ...future.conditions
[09:29:14.392]     ...future.result$finished <- base::Sys.time()
[09:29:14.392]     ...future.result
[09:29:14.392] }
[09:29:14.394] assign_globals() ...
[09:29:14.394] List of 5
[09:29:14.394]  $ ...future.FUN            :function (x, y)  
[09:29:14.394]  $ MoreArgs                 : list()
[09:29:14.394]  $ ...future.elements_ii    :List of 2
[09:29:14.394]   ..$ :List of 3
[09:29:14.394]   .. ..$ a: num 1
[09:29:14.394]   .. ..$ b: num 2
[09:29:14.394]   .. ..$ c: num 3
[09:29:14.394]   ..$ :List of 3
[09:29:14.394]   .. ..$ A: num 10
[09:29:14.394]   .. ..$ B: num 0
[09:29:14.394]   .. ..$ C: num -10
[09:29:14.394]  $ ...future.seeds_ii       : NULL
[09:29:14.394]  $ ...future.globals.maxSize: NULL
[09:29:14.394]  - attr(*, "where")=List of 5
[09:29:14.394]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.394]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.394]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.394]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.394]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.394]  - attr(*, "resolved")= logi FALSE
[09:29:14.394]  - attr(*, "total_size")= num 2312
[09:29:14.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.394]  - attr(*, "already-done")= logi TRUE
[09:29:14.401] - reassign environment for ‘...future.FUN’
[09:29:14.401] - copied ‘...future.FUN’ to environment
[09:29:14.401] - copied ‘MoreArgs’ to environment
[09:29:14.401] - copied ‘...future.elements_ii’ to environment
[09:29:14.401] - copied ‘...future.seeds_ii’ to environment
[09:29:14.401] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.401] assign_globals() ... done
[09:29:14.402] plan(): Setting new future strategy stack:
[09:29:14.402] List of future strategies:
[09:29:14.402] 1. sequential:
[09:29:14.402]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.402]    - tweaked: FALSE
[09:29:14.402]    - call: NULL
[09:29:14.402] plan(): nbrOfWorkers() = 1
[09:29:14.403] plan(): Setting new future strategy stack:
[09:29:14.403] List of future strategies:
[09:29:14.403] 1. sequential:
[09:29:14.403]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.403]    - tweaked: FALSE
[09:29:14.403]    - call: plan(strategy)
[09:29:14.403] plan(): nbrOfWorkers() = 1
[09:29:14.403] SequentialFuture started (and completed)
[09:29:14.404] - Launch lazy future ... done
[09:29:14.404] run() for ‘SequentialFuture’ ... done
[09:29:14.404] Created future:
[09:29:14.404] SequentialFuture:
[09:29:14.404] Label: ‘future_.mapply-1’
[09:29:14.404] Expression:
[09:29:14.404] {
[09:29:14.404]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.404]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.404]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.404]         on.exit(options(oopts), add = TRUE)
[09:29:14.404]     }
[09:29:14.404]     {
[09:29:14.404]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.404]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.404]         do.call(mapply, args = args)
[09:29:14.404]     }
[09:29:14.404] }
[09:29:14.404] Lazy evaluation: FALSE
[09:29:14.404] Asynchronous evaluation: FALSE
[09:29:14.404] Local evaluation: TRUE
[09:29:14.404] Environment: R_GlobalEnv
[09:29:14.404] Capture standard output: TRUE
[09:29:14.404] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.404] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.404] Packages: <none>
[09:29:14.404] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.404] Resolved: TRUE
[09:29:14.404] Value: 200 bytes of class ‘list’
[09:29:14.404] Early signaling: FALSE
[09:29:14.404] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.404] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.405] Chunk #1 of 1 ... DONE
[09:29:14.405] Launching 1 futures (chunks) ... DONE
[09:29:14.405] Resolving 1 futures (chunks) ...
[09:29:14.405] resolve() on list ...
[09:29:14.405]  recursive: 0
[09:29:14.405]  length: 1
[09:29:14.405] 
[09:29:14.405] resolved() for ‘SequentialFuture’ ...
[09:29:14.405] - state: ‘finished’
[09:29:14.405] - run: TRUE
[09:29:14.406] - result: ‘FutureResult’
[09:29:14.406] resolved() for ‘SequentialFuture’ ... done
[09:29:14.406] Future #1
[09:29:14.406] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.406] - nx: 1
[09:29:14.406] - relay: TRUE
[09:29:14.406] - stdout: TRUE
[09:29:14.406] - signal: TRUE
[09:29:14.406] - resignal: FALSE
[09:29:14.406] - force: TRUE
[09:29:14.406] - relayed: [n=1] FALSE
[09:29:14.406] - queued futures: [n=1] FALSE
[09:29:14.407]  - until=1
[09:29:14.407]  - relaying element #1
[09:29:14.407] - relayed: [n=1] TRUE
[09:29:14.407] - queued futures: [n=1] TRUE
[09:29:14.407] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.407]  length: 0 (resolved future 1)
[09:29:14.407] Relaying remaining futures
[09:29:14.407] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.407] - nx: 1
[09:29:14.407] - relay: TRUE
[09:29:14.407] - stdout: TRUE
[09:29:14.408] - signal: TRUE
[09:29:14.408] - resignal: FALSE
[09:29:14.408] - force: TRUE
[09:29:14.408] - relayed: [n=1] TRUE
[09:29:14.408] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.408] - relayed: [n=1] TRUE
[09:29:14.408] - queued futures: [n=1] TRUE
[09:29:14.408] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.408] resolve() on list ... DONE
[09:29:14.408]  - Number of value chunks collected: 1
[09:29:14.408] Resolving 1 futures (chunks) ... DONE
[09:29:14.409] Reducing values from 1 chunks ...
[09:29:14.409]  - Number of values collected after concatenation: 3
[09:29:14.409]  - Number of values expected: 3
[09:29:14.409] Reducing values from 1 chunks ... DONE
[09:29:14.409] future_mapply() ... DONE
[09:29:14.409] future_mapply() ...
[09:29:14.411] Number of chunks: 5
[09:29:14.411] getGlobalsAndPackagesXApply() ...
[09:29:14.411]  - future.globals: TRUE
[09:29:14.411] getGlobalsAndPackages() ...
[09:29:14.411] Searching for globals...
[09:29:14.412] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:14.413] Searching for globals ... DONE
[09:29:14.413] Resolving globals: FALSE
[09:29:14.413] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:14.413] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:14.413] - globals: [1] ‘FUN’
[09:29:14.413] 
[09:29:14.414] getGlobalsAndPackages() ... DONE
[09:29:14.414]  - globals found/used: [n=1] ‘FUN’
[09:29:14.414]  - needed namespaces: [n=0] 
[09:29:14.414] Finding globals ... DONE
[09:29:14.414] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.414] List of 2
[09:29:14.414]  $ ...future.FUN:function (C, k)  
[09:29:14.414]  $ MoreArgs     : NULL
[09:29:14.414]  - attr(*, "where")=List of 2
[09:29:14.414]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.414]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.414]  - attr(*, "resolved")= logi FALSE
[09:29:14.414]  - attr(*, "total_size")= num NA
[09:29:14.416] Packages to be attached in all futures: [n=0] 
[09:29:14.416] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.417] Number of futures (= number of chunks): 5
[09:29:14.417] Launching 5 futures (chunks) ...
[09:29:14.417] Chunk #1 of 5 ...
[09:29:14.417]  - Finding globals in '...' for chunk #1 ...
[09:29:14.417] getGlobalsAndPackages() ...
[09:29:14.417] Searching for globals...
[09:29:14.418] 
[09:29:14.419] Searching for globals ... DONE
[09:29:14.419] - globals: [0] <none>
[09:29:14.419] getGlobalsAndPackages() ... DONE
[09:29:14.419]    + additional globals found: [n=0] 
[09:29:14.419]    + additional namespaces needed: [n=0] 
[09:29:14.419]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.419]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:14.419]  - seeds: <none>
[09:29:14.419]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.419] getGlobalsAndPackages() ...
[09:29:14.419] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.419] Resolving globals: FALSE
[09:29:14.420] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:14.420] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.420] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.421] 
[09:29:14.421] getGlobalsAndPackages() ... DONE
[09:29:14.421] run() for ‘Future’ ...
[09:29:14.421] - state: ‘created’
[09:29:14.421] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.421] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.421] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.422]   - Field: ‘label’
[09:29:14.422]   - Field: ‘local’
[09:29:14.422]   - Field: ‘owner’
[09:29:14.422]   - Field: ‘envir’
[09:29:14.422]   - Field: ‘packages’
[09:29:14.422]   - Field: ‘gc’
[09:29:14.422]   - Field: ‘conditions’
[09:29:14.422]   - Field: ‘expr’
[09:29:14.422]   - Field: ‘uuid’
[09:29:14.422]   - Field: ‘seed’
[09:29:14.422]   - Field: ‘version’
[09:29:14.422]   - Field: ‘result’
[09:29:14.423]   - Field: ‘asynchronous’
[09:29:14.423]   - Field: ‘calls’
[09:29:14.423]   - Field: ‘globals’
[09:29:14.423]   - Field: ‘stdout’
[09:29:14.423]   - Field: ‘earlySignal’
[09:29:14.423]   - Field: ‘lazy’
[09:29:14.423]   - Field: ‘state’
[09:29:14.423] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.423] - Launch lazy future ...
[09:29:14.423] Packages needed by the future expression (n = 0): <none>
[09:29:14.423] Packages needed by future strategies (n = 0): <none>
[09:29:14.424] {
[09:29:14.424]     {
[09:29:14.424]         {
[09:29:14.424]             ...future.startTime <- base::Sys.time()
[09:29:14.424]             {
[09:29:14.424]                 {
[09:29:14.424]                   {
[09:29:14.424]                     base::local({
[09:29:14.424]                       has_future <- base::requireNamespace("future", 
[09:29:14.424]                         quietly = TRUE)
[09:29:14.424]                       if (has_future) {
[09:29:14.424]                         ns <- base::getNamespace("future")
[09:29:14.424]                         version <- ns[[".package"]][["version"]]
[09:29:14.424]                         if (is.null(version)) 
[09:29:14.424]                           version <- utils::packageVersion("future")
[09:29:14.424]                       }
[09:29:14.424]                       else {
[09:29:14.424]                         version <- NULL
[09:29:14.424]                       }
[09:29:14.424]                       if (!has_future || version < "1.8.0") {
[09:29:14.424]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.424]                           "", base::R.version$version.string), 
[09:29:14.424]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.424]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.424]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.424]                             "release", "version")], collapse = " "), 
[09:29:14.424]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.424]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.424]                           info)
[09:29:14.424]                         info <- base::paste(info, collapse = "; ")
[09:29:14.424]                         if (!has_future) {
[09:29:14.424]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.424]                             info)
[09:29:14.424]                         }
[09:29:14.424]                         else {
[09:29:14.424]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.424]                             info, version)
[09:29:14.424]                         }
[09:29:14.424]                         base::stop(msg)
[09:29:14.424]                       }
[09:29:14.424]                     })
[09:29:14.424]                   }
[09:29:14.424]                   ...future.strategy.old <- future::plan("list")
[09:29:14.424]                   options(future.plan = NULL)
[09:29:14.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.424]                 }
[09:29:14.424]                 ...future.workdir <- getwd()
[09:29:14.424]             }
[09:29:14.424]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.424]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.424]         }
[09:29:14.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.424]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:14.424]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.424]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.424]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.424]             base::names(...future.oldOptions))
[09:29:14.424]     }
[09:29:14.424]     if (FALSE) {
[09:29:14.424]     }
[09:29:14.424]     else {
[09:29:14.424]         if (TRUE) {
[09:29:14.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.424]                 open = "w")
[09:29:14.424]         }
[09:29:14.424]         else {
[09:29:14.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.424]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.424]         }
[09:29:14.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.424]             base::sink(type = "output", split = FALSE)
[09:29:14.424]             base::close(...future.stdout)
[09:29:14.424]         }, add = TRUE)
[09:29:14.424]     }
[09:29:14.424]     ...future.frame <- base::sys.nframe()
[09:29:14.424]     ...future.conditions <- base::list()
[09:29:14.424]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.424]     if (FALSE) {
[09:29:14.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.424]     }
[09:29:14.424]     ...future.result <- base::tryCatch({
[09:29:14.424]         base::withCallingHandlers({
[09:29:14.424]             ...future.value <- base::withVisible(base::local({
[09:29:14.424]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.424]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.424]                   ...future.globals.maxSize)) {
[09:29:14.424]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.424]                   on.exit(options(oopts), add = TRUE)
[09:29:14.424]                 }
[09:29:14.424]                 {
[09:29:14.424]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.424]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.424]                     USE.NAMES = FALSE)
[09:29:14.424]                   do.call(mapply, args = args)
[09:29:14.424]                 }
[09:29:14.424]             }))
[09:29:14.424]             future::FutureResult(value = ...future.value$value, 
[09:29:14.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.424]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.424]                     ...future.globalenv.names))
[09:29:14.424]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.424]         }, condition = base::local({
[09:29:14.424]             c <- base::c
[09:29:14.424]             inherits <- base::inherits
[09:29:14.424]             invokeRestart <- base::invokeRestart
[09:29:14.424]             length <- base::length
[09:29:14.424]             list <- base::list
[09:29:14.424]             seq.int <- base::seq.int
[09:29:14.424]             signalCondition <- base::signalCondition
[09:29:14.424]             sys.calls <- base::sys.calls
[09:29:14.424]             `[[` <- base::`[[`
[09:29:14.424]             `+` <- base::`+`
[09:29:14.424]             `<<-` <- base::`<<-`
[09:29:14.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.424]                   3L)]
[09:29:14.424]             }
[09:29:14.424]             function(cond) {
[09:29:14.424]                 is_error <- inherits(cond, "error")
[09:29:14.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.424]                   NULL)
[09:29:14.424]                 if (is_error) {
[09:29:14.424]                   sessionInformation <- function() {
[09:29:14.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.424]                       search = base::search(), system = base::Sys.info())
[09:29:14.424]                   }
[09:29:14.424]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.424]                     cond$call), session = sessionInformation(), 
[09:29:14.424]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.424]                   signalCondition(cond)
[09:29:14.424]                 }
[09:29:14.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.424]                 "immediateCondition"))) {
[09:29:14.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.424]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.424]                   if (TRUE && !signal) {
[09:29:14.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.424]                     {
[09:29:14.424]                       inherits <- base::inherits
[09:29:14.424]                       invokeRestart <- base::invokeRestart
[09:29:14.424]                       is.null <- base::is.null
[09:29:14.424]                       muffled <- FALSE
[09:29:14.424]                       if (inherits(cond, "message")) {
[09:29:14.424]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.424]                         if (muffled) 
[09:29:14.424]                           invokeRestart("muffleMessage")
[09:29:14.424]                       }
[09:29:14.424]                       else if (inherits(cond, "warning")) {
[09:29:14.424]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.424]                         if (muffled) 
[09:29:14.424]                           invokeRestart("muffleWarning")
[09:29:14.424]                       }
[09:29:14.424]                       else if (inherits(cond, "condition")) {
[09:29:14.424]                         if (!is.null(pattern)) {
[09:29:14.424]                           computeRestarts <- base::computeRestarts
[09:29:14.424]                           grepl <- base::grepl
[09:29:14.424]                           restarts <- computeRestarts(cond)
[09:29:14.424]                           for (restart in restarts) {
[09:29:14.424]                             name <- restart$name
[09:29:14.424]                             if (is.null(name)) 
[09:29:14.424]                               next
[09:29:14.424]                             if (!grepl(pattern, name)) 
[09:29:14.424]                               next
[09:29:14.424]                             invokeRestart(restart)
[09:29:14.424]                             muffled <- TRUE
[09:29:14.424]                             break
[09:29:14.424]                           }
[09:29:14.424]                         }
[09:29:14.424]                       }
[09:29:14.424]                       invisible(muffled)
[09:29:14.424]                     }
[09:29:14.424]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.424]                   }
[09:29:14.424]                 }
[09:29:14.424]                 else {
[09:29:14.424]                   if (TRUE) {
[09:29:14.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.424]                     {
[09:29:14.424]                       inherits <- base::inherits
[09:29:14.424]                       invokeRestart <- base::invokeRestart
[09:29:14.424]                       is.null <- base::is.null
[09:29:14.424]                       muffled <- FALSE
[09:29:14.424]                       if (inherits(cond, "message")) {
[09:29:14.424]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.424]                         if (muffled) 
[09:29:14.424]                           invokeRestart("muffleMessage")
[09:29:14.424]                       }
[09:29:14.424]                       else if (inherits(cond, "warning")) {
[09:29:14.424]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.424]                         if (muffled) 
[09:29:14.424]                           invokeRestart("muffleWarning")
[09:29:14.424]                       }
[09:29:14.424]                       else if (inherits(cond, "condition")) {
[09:29:14.424]                         if (!is.null(pattern)) {
[09:29:14.424]                           computeRestarts <- base::computeRestarts
[09:29:14.424]                           grepl <- base::grepl
[09:29:14.424]                           restarts <- computeRestarts(cond)
[09:29:14.424]                           for (restart in restarts) {
[09:29:14.424]                             name <- restart$name
[09:29:14.424]                             if (is.null(name)) 
[09:29:14.424]                               next
[09:29:14.424]                             if (!grepl(pattern, name)) 
[09:29:14.424]                               next
[09:29:14.424]                             invokeRestart(restart)
[09:29:14.424]                             muffled <- TRUE
[09:29:14.424]                             break
[09:29:14.424]                           }
[09:29:14.424]                         }
[09:29:14.424]                       }
[09:29:14.424]                       invisible(muffled)
[09:29:14.424]                     }
[09:29:14.424]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.424]                   }
[09:29:14.424]                 }
[09:29:14.424]             }
[09:29:14.424]         }))
[09:29:14.424]     }, error = function(ex) {
[09:29:14.424]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.424]                 ...future.rng), started = ...future.startTime, 
[09:29:14.424]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.424]             version = "1.8"), class = "FutureResult")
[09:29:14.424]     }, finally = {
[09:29:14.424]         if (!identical(...future.workdir, getwd())) 
[09:29:14.424]             setwd(...future.workdir)
[09:29:14.424]         {
[09:29:14.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.424]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.424]             }
[09:29:14.424]             base::options(...future.oldOptions)
[09:29:14.424]             if (.Platform$OS.type == "windows") {
[09:29:14.424]                 old_names <- names(...future.oldEnvVars)
[09:29:14.424]                 envs <- base::Sys.getenv()
[09:29:14.424]                 names <- names(envs)
[09:29:14.424]                 common <- intersect(names, old_names)
[09:29:14.424]                 added <- setdiff(names, old_names)
[09:29:14.424]                 removed <- setdiff(old_names, names)
[09:29:14.424]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.424]                   envs[common]]
[09:29:14.424]                 NAMES <- toupper(changed)
[09:29:14.424]                 args <- list()
[09:29:14.424]                 for (kk in seq_along(NAMES)) {
[09:29:14.424]                   name <- changed[[kk]]
[09:29:14.424]                   NAME <- NAMES[[kk]]
[09:29:14.424]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.424]                     next
[09:29:14.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.424]                 }
[09:29:14.424]                 NAMES <- toupper(added)
[09:29:14.424]                 for (kk in seq_along(NAMES)) {
[09:29:14.424]                   name <- added[[kk]]
[09:29:14.424]                   NAME <- NAMES[[kk]]
[09:29:14.424]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.424]                     next
[09:29:14.424]                   args[[name]] <- ""
[09:29:14.424]                 }
[09:29:14.424]                 NAMES <- toupper(removed)
[09:29:14.424]                 for (kk in seq_along(NAMES)) {
[09:29:14.424]                   name <- removed[[kk]]
[09:29:14.424]                   NAME <- NAMES[[kk]]
[09:29:14.424]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.424]                     next
[09:29:14.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.424]                 }
[09:29:14.424]                 if (length(args) > 0) 
[09:29:14.424]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.424]             }
[09:29:14.424]             else {
[09:29:14.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.424]             }
[09:29:14.424]             {
[09:29:14.424]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.424]                   0L) {
[09:29:14.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.424]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.424]                   base::options(opts)
[09:29:14.424]                 }
[09:29:14.424]                 {
[09:29:14.424]                   {
[09:29:14.424]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.424]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.424]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.424]                     NULL
[09:29:14.424]                   }
[09:29:14.424]                   options(future.plan = NULL)
[09:29:14.424]                   if (is.na(NA_character_)) 
[09:29:14.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.424]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.424]                     .init = FALSE)
[09:29:14.424]                 }
[09:29:14.424]             }
[09:29:14.424]         }
[09:29:14.424]     })
[09:29:14.424]     if (TRUE) {
[09:29:14.424]         base::sink(type = "output", split = FALSE)
[09:29:14.424]         if (TRUE) {
[09:29:14.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.424]         }
[09:29:14.424]         else {
[09:29:14.424]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.424]         }
[09:29:14.424]         base::close(...future.stdout)
[09:29:14.424]         ...future.stdout <- NULL
[09:29:14.424]     }
[09:29:14.424]     ...future.result$conditions <- ...future.conditions
[09:29:14.424]     ...future.result$finished <- base::Sys.time()
[09:29:14.424]     ...future.result
[09:29:14.424] }
[09:29:14.425] assign_globals() ...
[09:29:14.426] List of 5
[09:29:14.426]  $ ...future.FUN            :function (C, k)  
[09:29:14.426]  $ MoreArgs                 : NULL
[09:29:14.426]  $ ...future.elements_ii    :List of 2
[09:29:14.426]   ..$ :List of 1
[09:29:14.426]   .. ..$ : chr "A"
[09:29:14.426]   ..$ :List of 1
[09:29:14.426]   .. ..$ : int 5
[09:29:14.426]  $ ...future.seeds_ii       : NULL
[09:29:14.426]  $ ...future.globals.maxSize: NULL
[09:29:14.426]  - attr(*, "where")=List of 5
[09:29:14.426]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.426]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.426]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.426]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.426]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.426]  - attr(*, "resolved")= logi FALSE
[09:29:14.426]  - attr(*, "total_size")= num 3488
[09:29:14.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.426]  - attr(*, "already-done")= logi TRUE
[09:29:14.430] - reassign environment for ‘...future.FUN’
[09:29:14.430] - copied ‘...future.FUN’ to environment
[09:29:14.430] - copied ‘MoreArgs’ to environment
[09:29:14.430] - copied ‘...future.elements_ii’ to environment
[09:29:14.430] - copied ‘...future.seeds_ii’ to environment
[09:29:14.431] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.431] assign_globals() ... done
[09:29:14.431] plan(): Setting new future strategy stack:
[09:29:14.431] List of future strategies:
[09:29:14.431] 1. sequential:
[09:29:14.431]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.431]    - tweaked: FALSE
[09:29:14.431]    - call: NULL
[09:29:14.431] plan(): nbrOfWorkers() = 1
[09:29:14.432] plan(): Setting new future strategy stack:
[09:29:14.432] List of future strategies:
[09:29:14.432] 1. sequential:
[09:29:14.432]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.432]    - tweaked: FALSE
[09:29:14.432]    - call: plan(strategy)
[09:29:14.433] plan(): nbrOfWorkers() = 1
[09:29:14.433] SequentialFuture started (and completed)
[09:29:14.433] - Launch lazy future ... done
[09:29:14.433] run() for ‘SequentialFuture’ ... done
[09:29:14.433] Created future:
[09:29:14.433] SequentialFuture:
[09:29:14.433] Label: ‘future_mapply-1’
[09:29:14.433] Expression:
[09:29:14.433] {
[09:29:14.433]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.433]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.433]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.433]         on.exit(options(oopts), add = TRUE)
[09:29:14.433]     }
[09:29:14.433]     {
[09:29:14.433]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.433]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.433]         do.call(mapply, args = args)
[09:29:14.433]     }
[09:29:14.433] }
[09:29:14.433] Lazy evaluation: FALSE
[09:29:14.433] Asynchronous evaluation: FALSE
[09:29:14.433] Local evaluation: TRUE
[09:29:14.433] Environment: R_GlobalEnv
[09:29:14.433] Capture standard output: TRUE
[09:29:14.433] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.433] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.433] Packages: <none>
[09:29:14.433] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.433] Resolved: TRUE
[09:29:14.433] Value: 112 bytes of class ‘list’
[09:29:14.433] Early signaling: FALSE
[09:29:14.433] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.433] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.434] Chunk #1 of 5 ... DONE
[09:29:14.434] Chunk #2 of 5 ...
[09:29:14.434]  - Finding globals in '...' for chunk #2 ...
[09:29:14.434] getGlobalsAndPackages() ...
[09:29:14.434] Searching for globals...
[09:29:14.435] 
[09:29:14.435] Searching for globals ... DONE
[09:29:14.435] - globals: [0] <none>
[09:29:14.435] getGlobalsAndPackages() ... DONE
[09:29:14.435]    + additional globals found: [n=0] 
[09:29:14.435]    + additional namespaces needed: [n=0] 
[09:29:14.435]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:14.435]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:14.435]  - seeds: <none>
[09:29:14.435]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.435] getGlobalsAndPackages() ...
[09:29:14.435] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.436] Resolving globals: FALSE
[09:29:14.436] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:14.436] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.437] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.437] 
[09:29:14.437] getGlobalsAndPackages() ... DONE
[09:29:14.437] run() for ‘Future’ ...
[09:29:14.437] - state: ‘created’
[09:29:14.437] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.437] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.437] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.438]   - Field: ‘label’
[09:29:14.438]   - Field: ‘local’
[09:29:14.438]   - Field: ‘owner’
[09:29:14.438]   - Field: ‘envir’
[09:29:14.438]   - Field: ‘packages’
[09:29:14.438]   - Field: ‘gc’
[09:29:14.438]   - Field: ‘conditions’
[09:29:14.438]   - Field: ‘expr’
[09:29:14.438]   - Field: ‘uuid’
[09:29:14.438]   - Field: ‘seed’
[09:29:14.438]   - Field: ‘version’
[09:29:14.439]   - Field: ‘result’
[09:29:14.439]   - Field: ‘asynchronous’
[09:29:14.439]   - Field: ‘calls’
[09:29:14.439]   - Field: ‘globals’
[09:29:14.439]   - Field: ‘stdout’
[09:29:14.439]   - Field: ‘earlySignal’
[09:29:14.439]   - Field: ‘lazy’
[09:29:14.439]   - Field: ‘state’
[09:29:14.439] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.439] - Launch lazy future ...
[09:29:14.439] Packages needed by the future expression (n = 0): <none>
[09:29:14.440] Packages needed by future strategies (n = 0): <none>
[09:29:14.440] {
[09:29:14.440]     {
[09:29:14.440]         {
[09:29:14.440]             ...future.startTime <- base::Sys.time()
[09:29:14.440]             {
[09:29:14.440]                 {
[09:29:14.440]                   {
[09:29:14.440]                     base::local({
[09:29:14.440]                       has_future <- base::requireNamespace("future", 
[09:29:14.440]                         quietly = TRUE)
[09:29:14.440]                       if (has_future) {
[09:29:14.440]                         ns <- base::getNamespace("future")
[09:29:14.440]                         version <- ns[[".package"]][["version"]]
[09:29:14.440]                         if (is.null(version)) 
[09:29:14.440]                           version <- utils::packageVersion("future")
[09:29:14.440]                       }
[09:29:14.440]                       else {
[09:29:14.440]                         version <- NULL
[09:29:14.440]                       }
[09:29:14.440]                       if (!has_future || version < "1.8.0") {
[09:29:14.440]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.440]                           "", base::R.version$version.string), 
[09:29:14.440]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.440]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.440]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.440]                             "release", "version")], collapse = " "), 
[09:29:14.440]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.440]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.440]                           info)
[09:29:14.440]                         info <- base::paste(info, collapse = "; ")
[09:29:14.440]                         if (!has_future) {
[09:29:14.440]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.440]                             info)
[09:29:14.440]                         }
[09:29:14.440]                         else {
[09:29:14.440]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.440]                             info, version)
[09:29:14.440]                         }
[09:29:14.440]                         base::stop(msg)
[09:29:14.440]                       }
[09:29:14.440]                     })
[09:29:14.440]                   }
[09:29:14.440]                   ...future.strategy.old <- future::plan("list")
[09:29:14.440]                   options(future.plan = NULL)
[09:29:14.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.440]                 }
[09:29:14.440]                 ...future.workdir <- getwd()
[09:29:14.440]             }
[09:29:14.440]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.440]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.440]         }
[09:29:14.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.440]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:14.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.440]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.440]             base::names(...future.oldOptions))
[09:29:14.440]     }
[09:29:14.440]     if (FALSE) {
[09:29:14.440]     }
[09:29:14.440]     else {
[09:29:14.440]         if (TRUE) {
[09:29:14.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.440]                 open = "w")
[09:29:14.440]         }
[09:29:14.440]         else {
[09:29:14.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.440]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.440]         }
[09:29:14.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.440]             base::sink(type = "output", split = FALSE)
[09:29:14.440]             base::close(...future.stdout)
[09:29:14.440]         }, add = TRUE)
[09:29:14.440]     }
[09:29:14.440]     ...future.frame <- base::sys.nframe()
[09:29:14.440]     ...future.conditions <- base::list()
[09:29:14.440]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.440]     if (FALSE) {
[09:29:14.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.440]     }
[09:29:14.440]     ...future.result <- base::tryCatch({
[09:29:14.440]         base::withCallingHandlers({
[09:29:14.440]             ...future.value <- base::withVisible(base::local({
[09:29:14.440]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.440]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.440]                   ...future.globals.maxSize)) {
[09:29:14.440]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.440]                   on.exit(options(oopts), add = TRUE)
[09:29:14.440]                 }
[09:29:14.440]                 {
[09:29:14.440]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.440]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.440]                     USE.NAMES = FALSE)
[09:29:14.440]                   do.call(mapply, args = args)
[09:29:14.440]                 }
[09:29:14.440]             }))
[09:29:14.440]             future::FutureResult(value = ...future.value$value, 
[09:29:14.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.440]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.440]                     ...future.globalenv.names))
[09:29:14.440]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.440]         }, condition = base::local({
[09:29:14.440]             c <- base::c
[09:29:14.440]             inherits <- base::inherits
[09:29:14.440]             invokeRestart <- base::invokeRestart
[09:29:14.440]             length <- base::length
[09:29:14.440]             list <- base::list
[09:29:14.440]             seq.int <- base::seq.int
[09:29:14.440]             signalCondition <- base::signalCondition
[09:29:14.440]             sys.calls <- base::sys.calls
[09:29:14.440]             `[[` <- base::`[[`
[09:29:14.440]             `+` <- base::`+`
[09:29:14.440]             `<<-` <- base::`<<-`
[09:29:14.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.440]                   3L)]
[09:29:14.440]             }
[09:29:14.440]             function(cond) {
[09:29:14.440]                 is_error <- inherits(cond, "error")
[09:29:14.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.440]                   NULL)
[09:29:14.440]                 if (is_error) {
[09:29:14.440]                   sessionInformation <- function() {
[09:29:14.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.440]                       search = base::search(), system = base::Sys.info())
[09:29:14.440]                   }
[09:29:14.440]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.440]                     cond$call), session = sessionInformation(), 
[09:29:14.440]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.440]                   signalCondition(cond)
[09:29:14.440]                 }
[09:29:14.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.440]                 "immediateCondition"))) {
[09:29:14.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.440]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.440]                   if (TRUE && !signal) {
[09:29:14.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.440]                     {
[09:29:14.440]                       inherits <- base::inherits
[09:29:14.440]                       invokeRestart <- base::invokeRestart
[09:29:14.440]                       is.null <- base::is.null
[09:29:14.440]                       muffled <- FALSE
[09:29:14.440]                       if (inherits(cond, "message")) {
[09:29:14.440]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.440]                         if (muffled) 
[09:29:14.440]                           invokeRestart("muffleMessage")
[09:29:14.440]                       }
[09:29:14.440]                       else if (inherits(cond, "warning")) {
[09:29:14.440]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.440]                         if (muffled) 
[09:29:14.440]                           invokeRestart("muffleWarning")
[09:29:14.440]                       }
[09:29:14.440]                       else if (inherits(cond, "condition")) {
[09:29:14.440]                         if (!is.null(pattern)) {
[09:29:14.440]                           computeRestarts <- base::computeRestarts
[09:29:14.440]                           grepl <- base::grepl
[09:29:14.440]                           restarts <- computeRestarts(cond)
[09:29:14.440]                           for (restart in restarts) {
[09:29:14.440]                             name <- restart$name
[09:29:14.440]                             if (is.null(name)) 
[09:29:14.440]                               next
[09:29:14.440]                             if (!grepl(pattern, name)) 
[09:29:14.440]                               next
[09:29:14.440]                             invokeRestart(restart)
[09:29:14.440]                             muffled <- TRUE
[09:29:14.440]                             break
[09:29:14.440]                           }
[09:29:14.440]                         }
[09:29:14.440]                       }
[09:29:14.440]                       invisible(muffled)
[09:29:14.440]                     }
[09:29:14.440]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.440]                   }
[09:29:14.440]                 }
[09:29:14.440]                 else {
[09:29:14.440]                   if (TRUE) {
[09:29:14.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.440]                     {
[09:29:14.440]                       inherits <- base::inherits
[09:29:14.440]                       invokeRestart <- base::invokeRestart
[09:29:14.440]                       is.null <- base::is.null
[09:29:14.440]                       muffled <- FALSE
[09:29:14.440]                       if (inherits(cond, "message")) {
[09:29:14.440]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.440]                         if (muffled) 
[09:29:14.440]                           invokeRestart("muffleMessage")
[09:29:14.440]                       }
[09:29:14.440]                       else if (inherits(cond, "warning")) {
[09:29:14.440]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.440]                         if (muffled) 
[09:29:14.440]                           invokeRestart("muffleWarning")
[09:29:14.440]                       }
[09:29:14.440]                       else if (inherits(cond, "condition")) {
[09:29:14.440]                         if (!is.null(pattern)) {
[09:29:14.440]                           computeRestarts <- base::computeRestarts
[09:29:14.440]                           grepl <- base::grepl
[09:29:14.440]                           restarts <- computeRestarts(cond)
[09:29:14.440]                           for (restart in restarts) {
[09:29:14.440]                             name <- restart$name
[09:29:14.440]                             if (is.null(name)) 
[09:29:14.440]                               next
[09:29:14.440]                             if (!grepl(pattern, name)) 
[09:29:14.440]                               next
[09:29:14.440]                             invokeRestart(restart)
[09:29:14.440]                             muffled <- TRUE
[09:29:14.440]                             break
[09:29:14.440]                           }
[09:29:14.440]                         }
[09:29:14.440]                       }
[09:29:14.440]                       invisible(muffled)
[09:29:14.440]                     }
[09:29:14.440]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.440]                   }
[09:29:14.440]                 }
[09:29:14.440]             }
[09:29:14.440]         }))
[09:29:14.440]     }, error = function(ex) {
[09:29:14.440]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.440]                 ...future.rng), started = ...future.startTime, 
[09:29:14.440]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.440]             version = "1.8"), class = "FutureResult")
[09:29:14.440]     }, finally = {
[09:29:14.440]         if (!identical(...future.workdir, getwd())) 
[09:29:14.440]             setwd(...future.workdir)
[09:29:14.440]         {
[09:29:14.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.440]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.440]             }
[09:29:14.440]             base::options(...future.oldOptions)
[09:29:14.440]             if (.Platform$OS.type == "windows") {
[09:29:14.440]                 old_names <- names(...future.oldEnvVars)
[09:29:14.440]                 envs <- base::Sys.getenv()
[09:29:14.440]                 names <- names(envs)
[09:29:14.440]                 common <- intersect(names, old_names)
[09:29:14.440]                 added <- setdiff(names, old_names)
[09:29:14.440]                 removed <- setdiff(old_names, names)
[09:29:14.440]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.440]                   envs[common]]
[09:29:14.440]                 NAMES <- toupper(changed)
[09:29:14.440]                 args <- list()
[09:29:14.440]                 for (kk in seq_along(NAMES)) {
[09:29:14.440]                   name <- changed[[kk]]
[09:29:14.440]                   NAME <- NAMES[[kk]]
[09:29:14.440]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.440]                     next
[09:29:14.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.440]                 }
[09:29:14.440]                 NAMES <- toupper(added)
[09:29:14.440]                 for (kk in seq_along(NAMES)) {
[09:29:14.440]                   name <- added[[kk]]
[09:29:14.440]                   NAME <- NAMES[[kk]]
[09:29:14.440]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.440]                     next
[09:29:14.440]                   args[[name]] <- ""
[09:29:14.440]                 }
[09:29:14.440]                 NAMES <- toupper(removed)
[09:29:14.440]                 for (kk in seq_along(NAMES)) {
[09:29:14.440]                   name <- removed[[kk]]
[09:29:14.440]                   NAME <- NAMES[[kk]]
[09:29:14.440]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.440]                     next
[09:29:14.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.440]                 }
[09:29:14.440]                 if (length(args) > 0) 
[09:29:14.440]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.440]             }
[09:29:14.440]             else {
[09:29:14.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.440]             }
[09:29:14.440]             {
[09:29:14.440]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.440]                   0L) {
[09:29:14.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.440]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.440]                   base::options(opts)
[09:29:14.440]                 }
[09:29:14.440]                 {
[09:29:14.440]                   {
[09:29:14.440]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.440]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.440]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.440]                     NULL
[09:29:14.440]                   }
[09:29:14.440]                   options(future.plan = NULL)
[09:29:14.440]                   if (is.na(NA_character_)) 
[09:29:14.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.440]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.440]                     .init = FALSE)
[09:29:14.440]                 }
[09:29:14.440]             }
[09:29:14.440]         }
[09:29:14.440]     })
[09:29:14.440]     if (TRUE) {
[09:29:14.440]         base::sink(type = "output", split = FALSE)
[09:29:14.440]         if (TRUE) {
[09:29:14.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.440]         }
[09:29:14.440]         else {
[09:29:14.440]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.440]         }
[09:29:14.440]         base::close(...future.stdout)
[09:29:14.440]         ...future.stdout <- NULL
[09:29:14.440]     }
[09:29:14.440]     ...future.result$conditions <- ...future.conditions
[09:29:14.440]     ...future.result$finished <- base::Sys.time()
[09:29:14.440]     ...future.result
[09:29:14.440] }
[09:29:14.443] assign_globals() ...
[09:29:14.443] List of 5
[09:29:14.443]  $ ...future.FUN            :function (C, k)  
[09:29:14.443]  $ MoreArgs                 : NULL
[09:29:14.443]  $ ...future.elements_ii    :List of 2
[09:29:14.443]   ..$ :List of 1
[09:29:14.443]   .. ..$ : chr "B"
[09:29:14.443]   ..$ :List of 1
[09:29:14.443]   .. ..$ : int 4
[09:29:14.443]  $ ...future.seeds_ii       : NULL
[09:29:14.443]  $ ...future.globals.maxSize: NULL
[09:29:14.443]  - attr(*, "where")=List of 5
[09:29:14.443]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.443]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.443]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.443]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.443]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.443]  - attr(*, "resolved")= logi FALSE
[09:29:14.443]  - attr(*, "total_size")= num 3488
[09:29:14.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.443]  - attr(*, "already-done")= logi TRUE
[09:29:14.447] - reassign environment for ‘...future.FUN’
[09:29:14.447] - copied ‘...future.FUN’ to environment
[09:29:14.447] - copied ‘MoreArgs’ to environment
[09:29:14.447] - copied ‘...future.elements_ii’ to environment
[09:29:14.448] - copied ‘...future.seeds_ii’ to environment
[09:29:14.448] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.448] assign_globals() ... done
[09:29:14.448] plan(): Setting new future strategy stack:
[09:29:14.448] List of future strategies:
[09:29:14.448] 1. sequential:
[09:29:14.448]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.448]    - tweaked: FALSE
[09:29:14.448]    - call: NULL
[09:29:14.448] plan(): nbrOfWorkers() = 1
[09:29:14.449] plan(): Setting new future strategy stack:
[09:29:14.449] List of future strategies:
[09:29:14.449] 1. sequential:
[09:29:14.449]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.449]    - tweaked: FALSE
[09:29:14.449]    - call: plan(strategy)
[09:29:14.450] plan(): nbrOfWorkers() = 1
[09:29:14.450] SequentialFuture started (and completed)
[09:29:14.450] - Launch lazy future ... done
[09:29:14.450] run() for ‘SequentialFuture’ ... done
[09:29:14.450] Created future:
[09:29:14.450] SequentialFuture:
[09:29:14.450] Label: ‘future_mapply-2’
[09:29:14.450] Expression:
[09:29:14.450] {
[09:29:14.450]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.450]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.450]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.450]         on.exit(options(oopts), add = TRUE)
[09:29:14.450]     }
[09:29:14.450]     {
[09:29:14.450]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.450]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.450]         do.call(mapply, args = args)
[09:29:14.450]     }
[09:29:14.450] }
[09:29:14.450] Lazy evaluation: FALSE
[09:29:14.450] Asynchronous evaluation: FALSE
[09:29:14.450] Local evaluation: TRUE
[09:29:14.450] Environment: R_GlobalEnv
[09:29:14.450] Capture standard output: TRUE
[09:29:14.450] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.450] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.450] Packages: <none>
[09:29:14.450] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.450] Resolved: TRUE
[09:29:14.450] Value: 112 bytes of class ‘list’
[09:29:14.450] Early signaling: FALSE
[09:29:14.450] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.450] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.451] Chunk #2 of 5 ... DONE
[09:29:14.451] Chunk #3 of 5 ...
[09:29:14.451]  - Finding globals in '...' for chunk #3 ...
[09:29:14.451] getGlobalsAndPackages() ...
[09:29:14.451] Searching for globals...
[09:29:14.452] 
[09:29:14.452] Searching for globals ... DONE
[09:29:14.452] - globals: [0] <none>
[09:29:14.452] getGlobalsAndPackages() ... DONE
[09:29:14.452]    + additional globals found: [n=0] 
[09:29:14.452]    + additional namespaces needed: [n=0] 
[09:29:14.452]  - Finding globals in '...' for chunk #3 ... DONE
[09:29:14.452]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:14.452]  - seeds: <none>
[09:29:14.452]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.453] getGlobalsAndPackages() ...
[09:29:14.453] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.453] Resolving globals: FALSE
[09:29:14.453] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:14.454] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.454] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.454] 
[09:29:14.454] getGlobalsAndPackages() ... DONE
[09:29:14.454] run() for ‘Future’ ...
[09:29:14.454] - state: ‘created’
[09:29:14.454] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.454] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.455] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.455]   - Field: ‘label’
[09:29:14.455]   - Field: ‘local’
[09:29:14.455]   - Field: ‘owner’
[09:29:14.455]   - Field: ‘envir’
[09:29:14.455]   - Field: ‘packages’
[09:29:14.455]   - Field: ‘gc’
[09:29:14.455]   - Field: ‘conditions’
[09:29:14.455]   - Field: ‘expr’
[09:29:14.455]   - Field: ‘uuid’
[09:29:14.455]   - Field: ‘seed’
[09:29:14.456]   - Field: ‘version’
[09:29:14.456]   - Field: ‘result’
[09:29:14.456]   - Field: ‘asynchronous’
[09:29:14.456]   - Field: ‘calls’
[09:29:14.456]   - Field: ‘globals’
[09:29:14.456]   - Field: ‘stdout’
[09:29:14.456]   - Field: ‘earlySignal’
[09:29:14.456]   - Field: ‘lazy’
[09:29:14.456]   - Field: ‘state’
[09:29:14.456] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.456] - Launch lazy future ...
[09:29:14.457] Packages needed by the future expression (n = 0): <none>
[09:29:14.457] Packages needed by future strategies (n = 0): <none>
[09:29:14.457] {
[09:29:14.457]     {
[09:29:14.457]         {
[09:29:14.457]             ...future.startTime <- base::Sys.time()
[09:29:14.457]             {
[09:29:14.457]                 {
[09:29:14.457]                   {
[09:29:14.457]                     base::local({
[09:29:14.457]                       has_future <- base::requireNamespace("future", 
[09:29:14.457]                         quietly = TRUE)
[09:29:14.457]                       if (has_future) {
[09:29:14.457]                         ns <- base::getNamespace("future")
[09:29:14.457]                         version <- ns[[".package"]][["version"]]
[09:29:14.457]                         if (is.null(version)) 
[09:29:14.457]                           version <- utils::packageVersion("future")
[09:29:14.457]                       }
[09:29:14.457]                       else {
[09:29:14.457]                         version <- NULL
[09:29:14.457]                       }
[09:29:14.457]                       if (!has_future || version < "1.8.0") {
[09:29:14.457]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.457]                           "", base::R.version$version.string), 
[09:29:14.457]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.457]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.457]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.457]                             "release", "version")], collapse = " "), 
[09:29:14.457]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.457]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.457]                           info)
[09:29:14.457]                         info <- base::paste(info, collapse = "; ")
[09:29:14.457]                         if (!has_future) {
[09:29:14.457]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.457]                             info)
[09:29:14.457]                         }
[09:29:14.457]                         else {
[09:29:14.457]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.457]                             info, version)
[09:29:14.457]                         }
[09:29:14.457]                         base::stop(msg)
[09:29:14.457]                       }
[09:29:14.457]                     })
[09:29:14.457]                   }
[09:29:14.457]                   ...future.strategy.old <- future::plan("list")
[09:29:14.457]                   options(future.plan = NULL)
[09:29:14.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.457]                 }
[09:29:14.457]                 ...future.workdir <- getwd()
[09:29:14.457]             }
[09:29:14.457]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.457]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.457]         }
[09:29:14.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.457]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:14.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.457]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.457]             base::names(...future.oldOptions))
[09:29:14.457]     }
[09:29:14.457]     if (FALSE) {
[09:29:14.457]     }
[09:29:14.457]     else {
[09:29:14.457]         if (TRUE) {
[09:29:14.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.457]                 open = "w")
[09:29:14.457]         }
[09:29:14.457]         else {
[09:29:14.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.457]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.457]         }
[09:29:14.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.457]             base::sink(type = "output", split = FALSE)
[09:29:14.457]             base::close(...future.stdout)
[09:29:14.457]         }, add = TRUE)
[09:29:14.457]     }
[09:29:14.457]     ...future.frame <- base::sys.nframe()
[09:29:14.457]     ...future.conditions <- base::list()
[09:29:14.457]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.457]     if (FALSE) {
[09:29:14.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.457]     }
[09:29:14.457]     ...future.result <- base::tryCatch({
[09:29:14.457]         base::withCallingHandlers({
[09:29:14.457]             ...future.value <- base::withVisible(base::local({
[09:29:14.457]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.457]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.457]                   ...future.globals.maxSize)) {
[09:29:14.457]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.457]                   on.exit(options(oopts), add = TRUE)
[09:29:14.457]                 }
[09:29:14.457]                 {
[09:29:14.457]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.457]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.457]                     USE.NAMES = FALSE)
[09:29:14.457]                   do.call(mapply, args = args)
[09:29:14.457]                 }
[09:29:14.457]             }))
[09:29:14.457]             future::FutureResult(value = ...future.value$value, 
[09:29:14.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.457]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.457]                     ...future.globalenv.names))
[09:29:14.457]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.457]         }, condition = base::local({
[09:29:14.457]             c <- base::c
[09:29:14.457]             inherits <- base::inherits
[09:29:14.457]             invokeRestart <- base::invokeRestart
[09:29:14.457]             length <- base::length
[09:29:14.457]             list <- base::list
[09:29:14.457]             seq.int <- base::seq.int
[09:29:14.457]             signalCondition <- base::signalCondition
[09:29:14.457]             sys.calls <- base::sys.calls
[09:29:14.457]             `[[` <- base::`[[`
[09:29:14.457]             `+` <- base::`+`
[09:29:14.457]             `<<-` <- base::`<<-`
[09:29:14.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.457]                   3L)]
[09:29:14.457]             }
[09:29:14.457]             function(cond) {
[09:29:14.457]                 is_error <- inherits(cond, "error")
[09:29:14.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.457]                   NULL)
[09:29:14.457]                 if (is_error) {
[09:29:14.457]                   sessionInformation <- function() {
[09:29:14.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.457]                       search = base::search(), system = base::Sys.info())
[09:29:14.457]                   }
[09:29:14.457]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.457]                     cond$call), session = sessionInformation(), 
[09:29:14.457]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.457]                   signalCondition(cond)
[09:29:14.457]                 }
[09:29:14.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.457]                 "immediateCondition"))) {
[09:29:14.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.457]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.457]                   if (TRUE && !signal) {
[09:29:14.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.457]                     {
[09:29:14.457]                       inherits <- base::inherits
[09:29:14.457]                       invokeRestart <- base::invokeRestart
[09:29:14.457]                       is.null <- base::is.null
[09:29:14.457]                       muffled <- FALSE
[09:29:14.457]                       if (inherits(cond, "message")) {
[09:29:14.457]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.457]                         if (muffled) 
[09:29:14.457]                           invokeRestart("muffleMessage")
[09:29:14.457]                       }
[09:29:14.457]                       else if (inherits(cond, "warning")) {
[09:29:14.457]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.457]                         if (muffled) 
[09:29:14.457]                           invokeRestart("muffleWarning")
[09:29:14.457]                       }
[09:29:14.457]                       else if (inherits(cond, "condition")) {
[09:29:14.457]                         if (!is.null(pattern)) {
[09:29:14.457]                           computeRestarts <- base::computeRestarts
[09:29:14.457]                           grepl <- base::grepl
[09:29:14.457]                           restarts <- computeRestarts(cond)
[09:29:14.457]                           for (restart in restarts) {
[09:29:14.457]                             name <- restart$name
[09:29:14.457]                             if (is.null(name)) 
[09:29:14.457]                               next
[09:29:14.457]                             if (!grepl(pattern, name)) 
[09:29:14.457]                               next
[09:29:14.457]                             invokeRestart(restart)
[09:29:14.457]                             muffled <- TRUE
[09:29:14.457]                             break
[09:29:14.457]                           }
[09:29:14.457]                         }
[09:29:14.457]                       }
[09:29:14.457]                       invisible(muffled)
[09:29:14.457]                     }
[09:29:14.457]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.457]                   }
[09:29:14.457]                 }
[09:29:14.457]                 else {
[09:29:14.457]                   if (TRUE) {
[09:29:14.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.457]                     {
[09:29:14.457]                       inherits <- base::inherits
[09:29:14.457]                       invokeRestart <- base::invokeRestart
[09:29:14.457]                       is.null <- base::is.null
[09:29:14.457]                       muffled <- FALSE
[09:29:14.457]                       if (inherits(cond, "message")) {
[09:29:14.457]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.457]                         if (muffled) 
[09:29:14.457]                           invokeRestart("muffleMessage")
[09:29:14.457]                       }
[09:29:14.457]                       else if (inherits(cond, "warning")) {
[09:29:14.457]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.457]                         if (muffled) 
[09:29:14.457]                           invokeRestart("muffleWarning")
[09:29:14.457]                       }
[09:29:14.457]                       else if (inherits(cond, "condition")) {
[09:29:14.457]                         if (!is.null(pattern)) {
[09:29:14.457]                           computeRestarts <- base::computeRestarts
[09:29:14.457]                           grepl <- base::grepl
[09:29:14.457]                           restarts <- computeRestarts(cond)
[09:29:14.457]                           for (restart in restarts) {
[09:29:14.457]                             name <- restart$name
[09:29:14.457]                             if (is.null(name)) 
[09:29:14.457]                               next
[09:29:14.457]                             if (!grepl(pattern, name)) 
[09:29:14.457]                               next
[09:29:14.457]                             invokeRestart(restart)
[09:29:14.457]                             muffled <- TRUE
[09:29:14.457]                             break
[09:29:14.457]                           }
[09:29:14.457]                         }
[09:29:14.457]                       }
[09:29:14.457]                       invisible(muffled)
[09:29:14.457]                     }
[09:29:14.457]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.457]                   }
[09:29:14.457]                 }
[09:29:14.457]             }
[09:29:14.457]         }))
[09:29:14.457]     }, error = function(ex) {
[09:29:14.457]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.457]                 ...future.rng), started = ...future.startTime, 
[09:29:14.457]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.457]             version = "1.8"), class = "FutureResult")
[09:29:14.457]     }, finally = {
[09:29:14.457]         if (!identical(...future.workdir, getwd())) 
[09:29:14.457]             setwd(...future.workdir)
[09:29:14.457]         {
[09:29:14.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.457]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.457]             }
[09:29:14.457]             base::options(...future.oldOptions)
[09:29:14.457]             if (.Platform$OS.type == "windows") {
[09:29:14.457]                 old_names <- names(...future.oldEnvVars)
[09:29:14.457]                 envs <- base::Sys.getenv()
[09:29:14.457]                 names <- names(envs)
[09:29:14.457]                 common <- intersect(names, old_names)
[09:29:14.457]                 added <- setdiff(names, old_names)
[09:29:14.457]                 removed <- setdiff(old_names, names)
[09:29:14.457]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.457]                   envs[common]]
[09:29:14.457]                 NAMES <- toupper(changed)
[09:29:14.457]                 args <- list()
[09:29:14.457]                 for (kk in seq_along(NAMES)) {
[09:29:14.457]                   name <- changed[[kk]]
[09:29:14.457]                   NAME <- NAMES[[kk]]
[09:29:14.457]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.457]                     next
[09:29:14.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.457]                 }
[09:29:14.457]                 NAMES <- toupper(added)
[09:29:14.457]                 for (kk in seq_along(NAMES)) {
[09:29:14.457]                   name <- added[[kk]]
[09:29:14.457]                   NAME <- NAMES[[kk]]
[09:29:14.457]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.457]                     next
[09:29:14.457]                   args[[name]] <- ""
[09:29:14.457]                 }
[09:29:14.457]                 NAMES <- toupper(removed)
[09:29:14.457]                 for (kk in seq_along(NAMES)) {
[09:29:14.457]                   name <- removed[[kk]]
[09:29:14.457]                   NAME <- NAMES[[kk]]
[09:29:14.457]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.457]                     next
[09:29:14.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.457]                 }
[09:29:14.457]                 if (length(args) > 0) 
[09:29:14.457]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.457]             }
[09:29:14.457]             else {
[09:29:14.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.457]             }
[09:29:14.457]             {
[09:29:14.457]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.457]                   0L) {
[09:29:14.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.457]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.457]                   base::options(opts)
[09:29:14.457]                 }
[09:29:14.457]                 {
[09:29:14.457]                   {
[09:29:14.457]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.457]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.457]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.457]                     NULL
[09:29:14.457]                   }
[09:29:14.457]                   options(future.plan = NULL)
[09:29:14.457]                   if (is.na(NA_character_)) 
[09:29:14.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.457]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.457]                     .init = FALSE)
[09:29:14.457]                 }
[09:29:14.457]             }
[09:29:14.457]         }
[09:29:14.457]     })
[09:29:14.457]     if (TRUE) {
[09:29:14.457]         base::sink(type = "output", split = FALSE)
[09:29:14.457]         if (TRUE) {
[09:29:14.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.457]         }
[09:29:14.457]         else {
[09:29:14.457]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.457]         }
[09:29:14.457]         base::close(...future.stdout)
[09:29:14.457]         ...future.stdout <- NULL
[09:29:14.457]     }
[09:29:14.457]     ...future.result$conditions <- ...future.conditions
[09:29:14.457]     ...future.result$finished <- base::Sys.time()
[09:29:14.457]     ...future.result
[09:29:14.457] }
[09:29:14.459] assign_globals() ...
[09:29:14.459] List of 5
[09:29:14.459]  $ ...future.FUN            :function (C, k)  
[09:29:14.459]  $ MoreArgs                 : NULL
[09:29:14.459]  $ ...future.elements_ii    :List of 2
[09:29:14.459]   ..$ :List of 1
[09:29:14.459]   .. ..$ : chr "C"
[09:29:14.459]   ..$ :List of 1
[09:29:14.459]   .. ..$ : int 3
[09:29:14.459]  $ ...future.seeds_ii       : NULL
[09:29:14.459]  $ ...future.globals.maxSize: NULL
[09:29:14.459]  - attr(*, "where")=List of 5
[09:29:14.459]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.459]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.459]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.459]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.459]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.459]  - attr(*, "resolved")= logi FALSE
[09:29:14.459]  - attr(*, "total_size")= num 3488
[09:29:14.459]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.459]  - attr(*, "already-done")= logi TRUE
[09:29:14.463] - reassign environment for ‘...future.FUN’
[09:29:14.463] - copied ‘...future.FUN’ to environment
[09:29:14.463] - copied ‘MoreArgs’ to environment
[09:29:14.464] - copied ‘...future.elements_ii’ to environment
[09:29:14.464] - copied ‘...future.seeds_ii’ to environment
[09:29:14.465] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.466] assign_globals() ... done
[09:29:14.466] plan(): Setting new future strategy stack:
[09:29:14.466] List of future strategies:
[09:29:14.466] 1. sequential:
[09:29:14.466]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.466]    - tweaked: FALSE
[09:29:14.466]    - call: NULL
[09:29:14.466] plan(): nbrOfWorkers() = 1
[09:29:14.467] plan(): Setting new future strategy stack:
[09:29:14.467] List of future strategies:
[09:29:14.467] 1. sequential:
[09:29:14.467]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.467]    - tweaked: FALSE
[09:29:14.467]    - call: plan(strategy)
[09:29:14.468] plan(): nbrOfWorkers() = 1
[09:29:14.468] SequentialFuture started (and completed)
[09:29:14.468] - Launch lazy future ... done
[09:29:14.468] run() for ‘SequentialFuture’ ... done
[09:29:14.468] Created future:
[09:29:14.468] SequentialFuture:
[09:29:14.468] Label: ‘future_mapply-3’
[09:29:14.468] Expression:
[09:29:14.468] {
[09:29:14.468]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.468]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.468]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.468]         on.exit(options(oopts), add = TRUE)
[09:29:14.468]     }
[09:29:14.468]     {
[09:29:14.468]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.468]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.468]         do.call(mapply, args = args)
[09:29:14.468]     }
[09:29:14.468] }
[09:29:14.468] Lazy evaluation: FALSE
[09:29:14.468] Asynchronous evaluation: FALSE
[09:29:14.468] Local evaluation: TRUE
[09:29:14.468] Environment: R_GlobalEnv
[09:29:14.468] Capture standard output: TRUE
[09:29:14.468] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.468] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.468] Packages: <none>
[09:29:14.468] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.468] Resolved: TRUE
[09:29:14.468] Value: 112 bytes of class ‘list’
[09:29:14.468] Early signaling: FALSE
[09:29:14.468] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.468] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.469] Chunk #3 of 5 ... DONE
[09:29:14.469] Chunk #4 of 5 ...
[09:29:14.469]  - Finding globals in '...' for chunk #4 ...
[09:29:14.469] getGlobalsAndPackages() ...
[09:29:14.469] Searching for globals...
[09:29:14.470] 
[09:29:14.470] Searching for globals ... DONE
[09:29:14.470] - globals: [0] <none>
[09:29:14.470] getGlobalsAndPackages() ... DONE
[09:29:14.470]    + additional globals found: [n=0] 
[09:29:14.470]    + additional namespaces needed: [n=0] 
[09:29:14.470]  - Finding globals in '...' for chunk #4 ... DONE
[09:29:14.470]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:14.470]  - seeds: <none>
[09:29:14.471]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.471] getGlobalsAndPackages() ...
[09:29:14.471] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.471] Resolving globals: FALSE
[09:29:14.471] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:14.472] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.472] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.472] 
[09:29:14.472] getGlobalsAndPackages() ... DONE
[09:29:14.472] run() for ‘Future’ ...
[09:29:14.472] - state: ‘created’
[09:29:14.473] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.473] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.473] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.473]   - Field: ‘label’
[09:29:14.473]   - Field: ‘local’
[09:29:14.473]   - Field: ‘owner’
[09:29:14.473]   - Field: ‘envir’
[09:29:14.473]   - Field: ‘packages’
[09:29:14.474]   - Field: ‘gc’
[09:29:14.474]   - Field: ‘conditions’
[09:29:14.474]   - Field: ‘expr’
[09:29:14.474]   - Field: ‘uuid’
[09:29:14.474]   - Field: ‘seed’
[09:29:14.474]   - Field: ‘version’
[09:29:14.474]   - Field: ‘result’
[09:29:14.474]   - Field: ‘asynchronous’
[09:29:14.474]   - Field: ‘calls’
[09:29:14.474]   - Field: ‘globals’
[09:29:14.474]   - Field: ‘stdout’
[09:29:14.474]   - Field: ‘earlySignal’
[09:29:14.475]   - Field: ‘lazy’
[09:29:14.475]   - Field: ‘state’
[09:29:14.475] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.475] - Launch lazy future ...
[09:29:14.475] Packages needed by the future expression (n = 0): <none>
[09:29:14.475] Packages needed by future strategies (n = 0): <none>
[09:29:14.476] {
[09:29:14.476]     {
[09:29:14.476]         {
[09:29:14.476]             ...future.startTime <- base::Sys.time()
[09:29:14.476]             {
[09:29:14.476]                 {
[09:29:14.476]                   {
[09:29:14.476]                     base::local({
[09:29:14.476]                       has_future <- base::requireNamespace("future", 
[09:29:14.476]                         quietly = TRUE)
[09:29:14.476]                       if (has_future) {
[09:29:14.476]                         ns <- base::getNamespace("future")
[09:29:14.476]                         version <- ns[[".package"]][["version"]]
[09:29:14.476]                         if (is.null(version)) 
[09:29:14.476]                           version <- utils::packageVersion("future")
[09:29:14.476]                       }
[09:29:14.476]                       else {
[09:29:14.476]                         version <- NULL
[09:29:14.476]                       }
[09:29:14.476]                       if (!has_future || version < "1.8.0") {
[09:29:14.476]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.476]                           "", base::R.version$version.string), 
[09:29:14.476]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.476]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.476]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.476]                             "release", "version")], collapse = " "), 
[09:29:14.476]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.476]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.476]                           info)
[09:29:14.476]                         info <- base::paste(info, collapse = "; ")
[09:29:14.476]                         if (!has_future) {
[09:29:14.476]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.476]                             info)
[09:29:14.476]                         }
[09:29:14.476]                         else {
[09:29:14.476]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.476]                             info, version)
[09:29:14.476]                         }
[09:29:14.476]                         base::stop(msg)
[09:29:14.476]                       }
[09:29:14.476]                     })
[09:29:14.476]                   }
[09:29:14.476]                   ...future.strategy.old <- future::plan("list")
[09:29:14.476]                   options(future.plan = NULL)
[09:29:14.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.476]                 }
[09:29:14.476]                 ...future.workdir <- getwd()
[09:29:14.476]             }
[09:29:14.476]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.476]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.476]         }
[09:29:14.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.476]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:14.476]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.476]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.476]             base::names(...future.oldOptions))
[09:29:14.476]     }
[09:29:14.476]     if (FALSE) {
[09:29:14.476]     }
[09:29:14.476]     else {
[09:29:14.476]         if (TRUE) {
[09:29:14.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.476]                 open = "w")
[09:29:14.476]         }
[09:29:14.476]         else {
[09:29:14.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.476]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.476]         }
[09:29:14.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.476]             base::sink(type = "output", split = FALSE)
[09:29:14.476]             base::close(...future.stdout)
[09:29:14.476]         }, add = TRUE)
[09:29:14.476]     }
[09:29:14.476]     ...future.frame <- base::sys.nframe()
[09:29:14.476]     ...future.conditions <- base::list()
[09:29:14.476]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.476]     if (FALSE) {
[09:29:14.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.476]     }
[09:29:14.476]     ...future.result <- base::tryCatch({
[09:29:14.476]         base::withCallingHandlers({
[09:29:14.476]             ...future.value <- base::withVisible(base::local({
[09:29:14.476]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.476]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.476]                   ...future.globals.maxSize)) {
[09:29:14.476]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.476]                   on.exit(options(oopts), add = TRUE)
[09:29:14.476]                 }
[09:29:14.476]                 {
[09:29:14.476]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.476]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.476]                     USE.NAMES = FALSE)
[09:29:14.476]                   do.call(mapply, args = args)
[09:29:14.476]                 }
[09:29:14.476]             }))
[09:29:14.476]             future::FutureResult(value = ...future.value$value, 
[09:29:14.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.476]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.476]                     ...future.globalenv.names))
[09:29:14.476]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.476]         }, condition = base::local({
[09:29:14.476]             c <- base::c
[09:29:14.476]             inherits <- base::inherits
[09:29:14.476]             invokeRestart <- base::invokeRestart
[09:29:14.476]             length <- base::length
[09:29:14.476]             list <- base::list
[09:29:14.476]             seq.int <- base::seq.int
[09:29:14.476]             signalCondition <- base::signalCondition
[09:29:14.476]             sys.calls <- base::sys.calls
[09:29:14.476]             `[[` <- base::`[[`
[09:29:14.476]             `+` <- base::`+`
[09:29:14.476]             `<<-` <- base::`<<-`
[09:29:14.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.476]                   3L)]
[09:29:14.476]             }
[09:29:14.476]             function(cond) {
[09:29:14.476]                 is_error <- inherits(cond, "error")
[09:29:14.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.476]                   NULL)
[09:29:14.476]                 if (is_error) {
[09:29:14.476]                   sessionInformation <- function() {
[09:29:14.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.476]                       search = base::search(), system = base::Sys.info())
[09:29:14.476]                   }
[09:29:14.476]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.476]                     cond$call), session = sessionInformation(), 
[09:29:14.476]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.476]                   signalCondition(cond)
[09:29:14.476]                 }
[09:29:14.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.476]                 "immediateCondition"))) {
[09:29:14.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.476]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.476]                   if (TRUE && !signal) {
[09:29:14.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.476]                     {
[09:29:14.476]                       inherits <- base::inherits
[09:29:14.476]                       invokeRestart <- base::invokeRestart
[09:29:14.476]                       is.null <- base::is.null
[09:29:14.476]                       muffled <- FALSE
[09:29:14.476]                       if (inherits(cond, "message")) {
[09:29:14.476]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.476]                         if (muffled) 
[09:29:14.476]                           invokeRestart("muffleMessage")
[09:29:14.476]                       }
[09:29:14.476]                       else if (inherits(cond, "warning")) {
[09:29:14.476]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.476]                         if (muffled) 
[09:29:14.476]                           invokeRestart("muffleWarning")
[09:29:14.476]                       }
[09:29:14.476]                       else if (inherits(cond, "condition")) {
[09:29:14.476]                         if (!is.null(pattern)) {
[09:29:14.476]                           computeRestarts <- base::computeRestarts
[09:29:14.476]                           grepl <- base::grepl
[09:29:14.476]                           restarts <- computeRestarts(cond)
[09:29:14.476]                           for (restart in restarts) {
[09:29:14.476]                             name <- restart$name
[09:29:14.476]                             if (is.null(name)) 
[09:29:14.476]                               next
[09:29:14.476]                             if (!grepl(pattern, name)) 
[09:29:14.476]                               next
[09:29:14.476]                             invokeRestart(restart)
[09:29:14.476]                             muffled <- TRUE
[09:29:14.476]                             break
[09:29:14.476]                           }
[09:29:14.476]                         }
[09:29:14.476]                       }
[09:29:14.476]                       invisible(muffled)
[09:29:14.476]                     }
[09:29:14.476]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.476]                   }
[09:29:14.476]                 }
[09:29:14.476]                 else {
[09:29:14.476]                   if (TRUE) {
[09:29:14.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.476]                     {
[09:29:14.476]                       inherits <- base::inherits
[09:29:14.476]                       invokeRestart <- base::invokeRestart
[09:29:14.476]                       is.null <- base::is.null
[09:29:14.476]                       muffled <- FALSE
[09:29:14.476]                       if (inherits(cond, "message")) {
[09:29:14.476]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.476]                         if (muffled) 
[09:29:14.476]                           invokeRestart("muffleMessage")
[09:29:14.476]                       }
[09:29:14.476]                       else if (inherits(cond, "warning")) {
[09:29:14.476]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.476]                         if (muffled) 
[09:29:14.476]                           invokeRestart("muffleWarning")
[09:29:14.476]                       }
[09:29:14.476]                       else if (inherits(cond, "condition")) {
[09:29:14.476]                         if (!is.null(pattern)) {
[09:29:14.476]                           computeRestarts <- base::computeRestarts
[09:29:14.476]                           grepl <- base::grepl
[09:29:14.476]                           restarts <- computeRestarts(cond)
[09:29:14.476]                           for (restart in restarts) {
[09:29:14.476]                             name <- restart$name
[09:29:14.476]                             if (is.null(name)) 
[09:29:14.476]                               next
[09:29:14.476]                             if (!grepl(pattern, name)) 
[09:29:14.476]                               next
[09:29:14.476]                             invokeRestart(restart)
[09:29:14.476]                             muffled <- TRUE
[09:29:14.476]                             break
[09:29:14.476]                           }
[09:29:14.476]                         }
[09:29:14.476]                       }
[09:29:14.476]                       invisible(muffled)
[09:29:14.476]                     }
[09:29:14.476]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.476]                   }
[09:29:14.476]                 }
[09:29:14.476]             }
[09:29:14.476]         }))
[09:29:14.476]     }, error = function(ex) {
[09:29:14.476]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.476]                 ...future.rng), started = ...future.startTime, 
[09:29:14.476]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.476]             version = "1.8"), class = "FutureResult")
[09:29:14.476]     }, finally = {
[09:29:14.476]         if (!identical(...future.workdir, getwd())) 
[09:29:14.476]             setwd(...future.workdir)
[09:29:14.476]         {
[09:29:14.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.476]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.476]             }
[09:29:14.476]             base::options(...future.oldOptions)
[09:29:14.476]             if (.Platform$OS.type == "windows") {
[09:29:14.476]                 old_names <- names(...future.oldEnvVars)
[09:29:14.476]                 envs <- base::Sys.getenv()
[09:29:14.476]                 names <- names(envs)
[09:29:14.476]                 common <- intersect(names, old_names)
[09:29:14.476]                 added <- setdiff(names, old_names)
[09:29:14.476]                 removed <- setdiff(old_names, names)
[09:29:14.476]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.476]                   envs[common]]
[09:29:14.476]                 NAMES <- toupper(changed)
[09:29:14.476]                 args <- list()
[09:29:14.476]                 for (kk in seq_along(NAMES)) {
[09:29:14.476]                   name <- changed[[kk]]
[09:29:14.476]                   NAME <- NAMES[[kk]]
[09:29:14.476]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.476]                     next
[09:29:14.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.476]                 }
[09:29:14.476]                 NAMES <- toupper(added)
[09:29:14.476]                 for (kk in seq_along(NAMES)) {
[09:29:14.476]                   name <- added[[kk]]
[09:29:14.476]                   NAME <- NAMES[[kk]]
[09:29:14.476]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.476]                     next
[09:29:14.476]                   args[[name]] <- ""
[09:29:14.476]                 }
[09:29:14.476]                 NAMES <- toupper(removed)
[09:29:14.476]                 for (kk in seq_along(NAMES)) {
[09:29:14.476]                   name <- removed[[kk]]
[09:29:14.476]                   NAME <- NAMES[[kk]]
[09:29:14.476]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.476]                     next
[09:29:14.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.476]                 }
[09:29:14.476]                 if (length(args) > 0) 
[09:29:14.476]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.476]             }
[09:29:14.476]             else {
[09:29:14.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.476]             }
[09:29:14.476]             {
[09:29:14.476]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.476]                   0L) {
[09:29:14.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.476]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.476]                   base::options(opts)
[09:29:14.476]                 }
[09:29:14.476]                 {
[09:29:14.476]                   {
[09:29:14.476]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.476]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.476]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.476]                     NULL
[09:29:14.476]                   }
[09:29:14.476]                   options(future.plan = NULL)
[09:29:14.476]                   if (is.na(NA_character_)) 
[09:29:14.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.476]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.476]                     .init = FALSE)
[09:29:14.476]                 }
[09:29:14.476]             }
[09:29:14.476]         }
[09:29:14.476]     })
[09:29:14.476]     if (TRUE) {
[09:29:14.476]         base::sink(type = "output", split = FALSE)
[09:29:14.476]         if (TRUE) {
[09:29:14.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.476]         }
[09:29:14.476]         else {
[09:29:14.476]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.476]         }
[09:29:14.476]         base::close(...future.stdout)
[09:29:14.476]         ...future.stdout <- NULL
[09:29:14.476]     }
[09:29:14.476]     ...future.result$conditions <- ...future.conditions
[09:29:14.476]     ...future.result$finished <- base::Sys.time()
[09:29:14.476]     ...future.result
[09:29:14.476] }
[09:29:14.477] assign_globals() ...
[09:29:14.477] List of 5
[09:29:14.477]  $ ...future.FUN            :function (C, k)  
[09:29:14.477]  $ MoreArgs                 : NULL
[09:29:14.477]  $ ...future.elements_ii    :List of 2
[09:29:14.477]   ..$ :List of 1
[09:29:14.477]   .. ..$ : chr "D"
[09:29:14.477]   ..$ :List of 1
[09:29:14.477]   .. ..$ : int 2
[09:29:14.477]  $ ...future.seeds_ii       : NULL
[09:29:14.477]  $ ...future.globals.maxSize: NULL
[09:29:14.477]  - attr(*, "where")=List of 5
[09:29:14.477]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.477]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.477]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.477]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.477]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.477]  - attr(*, "resolved")= logi FALSE
[09:29:14.477]  - attr(*, "total_size")= num 3488
[09:29:14.477]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.477]  - attr(*, "already-done")= logi TRUE
[09:29:14.482] - reassign environment for ‘...future.FUN’
[09:29:14.482] - copied ‘...future.FUN’ to environment
[09:29:14.482] - copied ‘MoreArgs’ to environment
[09:29:14.482] - copied ‘...future.elements_ii’ to environment
[09:29:14.483] - copied ‘...future.seeds_ii’ to environment
[09:29:14.483] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.483] assign_globals() ... done
[09:29:14.483] plan(): Setting new future strategy stack:
[09:29:14.483] List of future strategies:
[09:29:14.483] 1. sequential:
[09:29:14.483]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.483]    - tweaked: FALSE
[09:29:14.483]    - call: NULL
[09:29:14.483] plan(): nbrOfWorkers() = 1
[09:29:14.484] plan(): Setting new future strategy stack:
[09:29:14.484] List of future strategies:
[09:29:14.484] 1. sequential:
[09:29:14.484]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.484]    - tweaked: FALSE
[09:29:14.484]    - call: plan(strategy)
[09:29:14.485] plan(): nbrOfWorkers() = 1
[09:29:14.485] SequentialFuture started (and completed)
[09:29:14.485] - Launch lazy future ... done
[09:29:14.485] run() for ‘SequentialFuture’ ... done
[09:29:14.485] Created future:
[09:29:14.485] SequentialFuture:
[09:29:14.485] Label: ‘future_mapply-4’
[09:29:14.485] Expression:
[09:29:14.485] {
[09:29:14.485]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.485]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.485]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.485]         on.exit(options(oopts), add = TRUE)
[09:29:14.485]     }
[09:29:14.485]     {
[09:29:14.485]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.485]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.485]         do.call(mapply, args = args)
[09:29:14.485]     }
[09:29:14.485] }
[09:29:14.485] Lazy evaluation: FALSE
[09:29:14.485] Asynchronous evaluation: FALSE
[09:29:14.485] Local evaluation: TRUE
[09:29:14.485] Environment: R_GlobalEnv
[09:29:14.485] Capture standard output: TRUE
[09:29:14.485] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.485] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.485] Packages: <none>
[09:29:14.485] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.485] Resolved: TRUE
[09:29:14.485] Value: 112 bytes of class ‘list’
[09:29:14.485] Early signaling: FALSE
[09:29:14.485] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.485] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.486] Chunk #4 of 5 ... DONE
[09:29:14.486] Chunk #5 of 5 ...
[09:29:14.486]  - Finding globals in '...' for chunk #5 ...
[09:29:14.487] getGlobalsAndPackages() ...
[09:29:14.487] Searching for globals...
[09:29:14.487] 
[09:29:14.487] Searching for globals ... DONE
[09:29:14.487] - globals: [0] <none>
[09:29:14.487] getGlobalsAndPackages() ... DONE
[09:29:14.487]    + additional globals found: [n=0] 
[09:29:14.487]    + additional namespaces needed: [n=0] 
[09:29:14.487]  - Finding globals in '...' for chunk #5 ... DONE
[09:29:14.488]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:14.488]  - seeds: <none>
[09:29:14.488]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.488] getGlobalsAndPackages() ...
[09:29:14.488] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.488] Resolving globals: FALSE
[09:29:14.489] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:14.489] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.516] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.516] 
[09:29:14.517] getGlobalsAndPackages() ... DONE
[09:29:14.517] run() for ‘Future’ ...
[09:29:14.517] - state: ‘created’
[09:29:14.517] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.517] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.518] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.518]   - Field: ‘label’
[09:29:14.518]   - Field: ‘local’
[09:29:14.518]   - Field: ‘owner’
[09:29:14.518]   - Field: ‘envir’
[09:29:14.518]   - Field: ‘packages’
[09:29:14.518]   - Field: ‘gc’
[09:29:14.518]   - Field: ‘conditions’
[09:29:14.518]   - Field: ‘expr’
[09:29:14.519]   - Field: ‘uuid’
[09:29:14.519]   - Field: ‘seed’
[09:29:14.519]   - Field: ‘version’
[09:29:14.519]   - Field: ‘result’
[09:29:14.519]   - Field: ‘asynchronous’
[09:29:14.519]   - Field: ‘calls’
[09:29:14.519]   - Field: ‘globals’
[09:29:14.519]   - Field: ‘stdout’
[09:29:14.519]   - Field: ‘earlySignal’
[09:29:14.519]   - Field: ‘lazy’
[09:29:14.519]   - Field: ‘state’
[09:29:14.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.520] - Launch lazy future ...
[09:29:14.520] Packages needed by the future expression (n = 0): <none>
[09:29:14.520] Packages needed by future strategies (n = 0): <none>
[09:29:14.520] {
[09:29:14.520]     {
[09:29:14.520]         {
[09:29:14.520]             ...future.startTime <- base::Sys.time()
[09:29:14.520]             {
[09:29:14.520]                 {
[09:29:14.520]                   {
[09:29:14.520]                     base::local({
[09:29:14.520]                       has_future <- base::requireNamespace("future", 
[09:29:14.520]                         quietly = TRUE)
[09:29:14.520]                       if (has_future) {
[09:29:14.520]                         ns <- base::getNamespace("future")
[09:29:14.520]                         version <- ns[[".package"]][["version"]]
[09:29:14.520]                         if (is.null(version)) 
[09:29:14.520]                           version <- utils::packageVersion("future")
[09:29:14.520]                       }
[09:29:14.520]                       else {
[09:29:14.520]                         version <- NULL
[09:29:14.520]                       }
[09:29:14.520]                       if (!has_future || version < "1.8.0") {
[09:29:14.520]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.520]                           "", base::R.version$version.string), 
[09:29:14.520]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.520]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.520]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.520]                             "release", "version")], collapse = " "), 
[09:29:14.520]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.520]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.520]                           info)
[09:29:14.520]                         info <- base::paste(info, collapse = "; ")
[09:29:14.520]                         if (!has_future) {
[09:29:14.520]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.520]                             info)
[09:29:14.520]                         }
[09:29:14.520]                         else {
[09:29:14.520]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.520]                             info, version)
[09:29:14.520]                         }
[09:29:14.520]                         base::stop(msg)
[09:29:14.520]                       }
[09:29:14.520]                     })
[09:29:14.520]                   }
[09:29:14.520]                   ...future.strategy.old <- future::plan("list")
[09:29:14.520]                   options(future.plan = NULL)
[09:29:14.520]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.520]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.520]                 }
[09:29:14.520]                 ...future.workdir <- getwd()
[09:29:14.520]             }
[09:29:14.520]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.520]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.520]         }
[09:29:14.520]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.520]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:14.520]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.520]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.520]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.520]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.520]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.520]             base::names(...future.oldOptions))
[09:29:14.520]     }
[09:29:14.520]     if (FALSE) {
[09:29:14.520]     }
[09:29:14.520]     else {
[09:29:14.520]         if (TRUE) {
[09:29:14.520]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.520]                 open = "w")
[09:29:14.520]         }
[09:29:14.520]         else {
[09:29:14.520]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.520]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.520]         }
[09:29:14.520]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.520]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.520]             base::sink(type = "output", split = FALSE)
[09:29:14.520]             base::close(...future.stdout)
[09:29:14.520]         }, add = TRUE)
[09:29:14.520]     }
[09:29:14.520]     ...future.frame <- base::sys.nframe()
[09:29:14.520]     ...future.conditions <- base::list()
[09:29:14.520]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.520]     if (FALSE) {
[09:29:14.520]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.520]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.520]     }
[09:29:14.520]     ...future.result <- base::tryCatch({
[09:29:14.520]         base::withCallingHandlers({
[09:29:14.520]             ...future.value <- base::withVisible(base::local({
[09:29:14.520]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.520]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.520]                   ...future.globals.maxSize)) {
[09:29:14.520]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.520]                   on.exit(options(oopts), add = TRUE)
[09:29:14.520]                 }
[09:29:14.520]                 {
[09:29:14.520]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.520]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.520]                     USE.NAMES = FALSE)
[09:29:14.520]                   do.call(mapply, args = args)
[09:29:14.520]                 }
[09:29:14.520]             }))
[09:29:14.520]             future::FutureResult(value = ...future.value$value, 
[09:29:14.520]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.520]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.520]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.520]                     ...future.globalenv.names))
[09:29:14.520]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.520]         }, condition = base::local({
[09:29:14.520]             c <- base::c
[09:29:14.520]             inherits <- base::inherits
[09:29:14.520]             invokeRestart <- base::invokeRestart
[09:29:14.520]             length <- base::length
[09:29:14.520]             list <- base::list
[09:29:14.520]             seq.int <- base::seq.int
[09:29:14.520]             signalCondition <- base::signalCondition
[09:29:14.520]             sys.calls <- base::sys.calls
[09:29:14.520]             `[[` <- base::`[[`
[09:29:14.520]             `+` <- base::`+`
[09:29:14.520]             `<<-` <- base::`<<-`
[09:29:14.520]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.520]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.520]                   3L)]
[09:29:14.520]             }
[09:29:14.520]             function(cond) {
[09:29:14.520]                 is_error <- inherits(cond, "error")
[09:29:14.520]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.520]                   NULL)
[09:29:14.520]                 if (is_error) {
[09:29:14.520]                   sessionInformation <- function() {
[09:29:14.520]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.520]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.520]                       search = base::search(), system = base::Sys.info())
[09:29:14.520]                   }
[09:29:14.520]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.520]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.520]                     cond$call), session = sessionInformation(), 
[09:29:14.520]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.520]                   signalCondition(cond)
[09:29:14.520]                 }
[09:29:14.520]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.520]                 "immediateCondition"))) {
[09:29:14.520]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.520]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.520]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.520]                   if (TRUE && !signal) {
[09:29:14.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.520]                     {
[09:29:14.520]                       inherits <- base::inherits
[09:29:14.520]                       invokeRestart <- base::invokeRestart
[09:29:14.520]                       is.null <- base::is.null
[09:29:14.520]                       muffled <- FALSE
[09:29:14.520]                       if (inherits(cond, "message")) {
[09:29:14.520]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.520]                         if (muffled) 
[09:29:14.520]                           invokeRestart("muffleMessage")
[09:29:14.520]                       }
[09:29:14.520]                       else if (inherits(cond, "warning")) {
[09:29:14.520]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.520]                         if (muffled) 
[09:29:14.520]                           invokeRestart("muffleWarning")
[09:29:14.520]                       }
[09:29:14.520]                       else if (inherits(cond, "condition")) {
[09:29:14.520]                         if (!is.null(pattern)) {
[09:29:14.520]                           computeRestarts <- base::computeRestarts
[09:29:14.520]                           grepl <- base::grepl
[09:29:14.520]                           restarts <- computeRestarts(cond)
[09:29:14.520]                           for (restart in restarts) {
[09:29:14.520]                             name <- restart$name
[09:29:14.520]                             if (is.null(name)) 
[09:29:14.520]                               next
[09:29:14.520]                             if (!grepl(pattern, name)) 
[09:29:14.520]                               next
[09:29:14.520]                             invokeRestart(restart)
[09:29:14.520]                             muffled <- TRUE
[09:29:14.520]                             break
[09:29:14.520]                           }
[09:29:14.520]                         }
[09:29:14.520]                       }
[09:29:14.520]                       invisible(muffled)
[09:29:14.520]                     }
[09:29:14.520]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.520]                   }
[09:29:14.520]                 }
[09:29:14.520]                 else {
[09:29:14.520]                   if (TRUE) {
[09:29:14.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.520]                     {
[09:29:14.520]                       inherits <- base::inherits
[09:29:14.520]                       invokeRestart <- base::invokeRestart
[09:29:14.520]                       is.null <- base::is.null
[09:29:14.520]                       muffled <- FALSE
[09:29:14.520]                       if (inherits(cond, "message")) {
[09:29:14.520]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.520]                         if (muffled) 
[09:29:14.520]                           invokeRestart("muffleMessage")
[09:29:14.520]                       }
[09:29:14.520]                       else if (inherits(cond, "warning")) {
[09:29:14.520]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.520]                         if (muffled) 
[09:29:14.520]                           invokeRestart("muffleWarning")
[09:29:14.520]                       }
[09:29:14.520]                       else if (inherits(cond, "condition")) {
[09:29:14.520]                         if (!is.null(pattern)) {
[09:29:14.520]                           computeRestarts <- base::computeRestarts
[09:29:14.520]                           grepl <- base::grepl
[09:29:14.520]                           restarts <- computeRestarts(cond)
[09:29:14.520]                           for (restart in restarts) {
[09:29:14.520]                             name <- restart$name
[09:29:14.520]                             if (is.null(name)) 
[09:29:14.520]                               next
[09:29:14.520]                             if (!grepl(pattern, name)) 
[09:29:14.520]                               next
[09:29:14.520]                             invokeRestart(restart)
[09:29:14.520]                             muffled <- TRUE
[09:29:14.520]                             break
[09:29:14.520]                           }
[09:29:14.520]                         }
[09:29:14.520]                       }
[09:29:14.520]                       invisible(muffled)
[09:29:14.520]                     }
[09:29:14.520]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.520]                   }
[09:29:14.520]                 }
[09:29:14.520]             }
[09:29:14.520]         }))
[09:29:14.520]     }, error = function(ex) {
[09:29:14.520]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.520]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.520]                 ...future.rng), started = ...future.startTime, 
[09:29:14.520]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.520]             version = "1.8"), class = "FutureResult")
[09:29:14.520]     }, finally = {
[09:29:14.520]         if (!identical(...future.workdir, getwd())) 
[09:29:14.520]             setwd(...future.workdir)
[09:29:14.520]         {
[09:29:14.520]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.520]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.520]             }
[09:29:14.520]             base::options(...future.oldOptions)
[09:29:14.520]             if (.Platform$OS.type == "windows") {
[09:29:14.520]                 old_names <- names(...future.oldEnvVars)
[09:29:14.520]                 envs <- base::Sys.getenv()
[09:29:14.520]                 names <- names(envs)
[09:29:14.520]                 common <- intersect(names, old_names)
[09:29:14.520]                 added <- setdiff(names, old_names)
[09:29:14.520]                 removed <- setdiff(old_names, names)
[09:29:14.520]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.520]                   envs[common]]
[09:29:14.520]                 NAMES <- toupper(changed)
[09:29:14.520]                 args <- list()
[09:29:14.520]                 for (kk in seq_along(NAMES)) {
[09:29:14.520]                   name <- changed[[kk]]
[09:29:14.520]                   NAME <- NAMES[[kk]]
[09:29:14.520]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.520]                     next
[09:29:14.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.520]                 }
[09:29:14.520]                 NAMES <- toupper(added)
[09:29:14.520]                 for (kk in seq_along(NAMES)) {
[09:29:14.520]                   name <- added[[kk]]
[09:29:14.520]                   NAME <- NAMES[[kk]]
[09:29:14.520]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.520]                     next
[09:29:14.520]                   args[[name]] <- ""
[09:29:14.520]                 }
[09:29:14.520]                 NAMES <- toupper(removed)
[09:29:14.520]                 for (kk in seq_along(NAMES)) {
[09:29:14.520]                   name <- removed[[kk]]
[09:29:14.520]                   NAME <- NAMES[[kk]]
[09:29:14.520]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.520]                     next
[09:29:14.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.520]                 }
[09:29:14.520]                 if (length(args) > 0) 
[09:29:14.520]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.520]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.520]             }
[09:29:14.520]             else {
[09:29:14.520]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.520]             }
[09:29:14.520]             {
[09:29:14.520]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.520]                   0L) {
[09:29:14.520]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.520]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.520]                   base::options(opts)
[09:29:14.520]                 }
[09:29:14.520]                 {
[09:29:14.520]                   {
[09:29:14.520]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.520]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.520]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.520]                     NULL
[09:29:14.520]                   }
[09:29:14.520]                   options(future.plan = NULL)
[09:29:14.520]                   if (is.na(NA_character_)) 
[09:29:14.520]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.520]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.520]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.520]                     .init = FALSE)
[09:29:14.520]                 }
[09:29:14.520]             }
[09:29:14.520]         }
[09:29:14.520]     })
[09:29:14.520]     if (TRUE) {
[09:29:14.520]         base::sink(type = "output", split = FALSE)
[09:29:14.520]         if (TRUE) {
[09:29:14.520]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.520]         }
[09:29:14.520]         else {
[09:29:14.520]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.520]         }
[09:29:14.520]         base::close(...future.stdout)
[09:29:14.520]         ...future.stdout <- NULL
[09:29:14.520]     }
[09:29:14.520]     ...future.result$conditions <- ...future.conditions
[09:29:14.520]     ...future.result$finished <- base::Sys.time()
[09:29:14.520]     ...future.result
[09:29:14.520] }
[09:29:14.522] assign_globals() ...
[09:29:14.522] List of 5
[09:29:14.522]  $ ...future.FUN            :function (C, k)  
[09:29:14.522]  $ MoreArgs                 : NULL
[09:29:14.522]  $ ...future.elements_ii    :List of 2
[09:29:14.522]   ..$ :List of 1
[09:29:14.522]   .. ..$ : chr "E"
[09:29:14.522]   ..$ :List of 1
[09:29:14.522]   .. ..$ : int 1
[09:29:14.522]  $ ...future.seeds_ii       : NULL
[09:29:14.522]  $ ...future.globals.maxSize: NULL
[09:29:14.522]  - attr(*, "where")=List of 5
[09:29:14.522]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.522]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.522]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.522]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.522]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.522]  - attr(*, "resolved")= logi FALSE
[09:29:14.522]  - attr(*, "total_size")= num 3488
[09:29:14.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.522]  - attr(*, "already-done")= logi TRUE
[09:29:14.527] - reassign environment for ‘...future.FUN’
[09:29:14.527] - copied ‘...future.FUN’ to environment
[09:29:14.527] - copied ‘MoreArgs’ to environment
[09:29:14.527] - copied ‘...future.elements_ii’ to environment
[09:29:14.527] - copied ‘...future.seeds_ii’ to environment
[09:29:14.528] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.528] assign_globals() ... done
[09:29:14.528] plan(): Setting new future strategy stack:
[09:29:14.528] List of future strategies:
[09:29:14.528] 1. sequential:
[09:29:14.528]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.528]    - tweaked: FALSE
[09:29:14.528]    - call: NULL
[09:29:14.528] plan(): nbrOfWorkers() = 1
[09:29:14.529] plan(): Setting new future strategy stack:
[09:29:14.529] List of future strategies:
[09:29:14.529] 1. sequential:
[09:29:14.529]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.529]    - tweaked: FALSE
[09:29:14.529]    - call: plan(strategy)
[09:29:14.530] plan(): nbrOfWorkers() = 1
[09:29:14.530] SequentialFuture started (and completed)
[09:29:14.530] - Launch lazy future ... done
[09:29:14.530] run() for ‘SequentialFuture’ ... done
[09:29:14.530] Created future:
[09:29:14.530] SequentialFuture:
[09:29:14.530] Label: ‘future_mapply-5’
[09:29:14.530] Expression:
[09:29:14.530] {
[09:29:14.530]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.530]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.530]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.530]         on.exit(options(oopts), add = TRUE)
[09:29:14.530]     }
[09:29:14.530]     {
[09:29:14.530]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.530]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.530]         do.call(mapply, args = args)
[09:29:14.530]     }
[09:29:14.530] }
[09:29:14.530] Lazy evaluation: FALSE
[09:29:14.530] Asynchronous evaluation: FALSE
[09:29:14.530] Local evaluation: TRUE
[09:29:14.530] Environment: R_GlobalEnv
[09:29:14.530] Capture standard output: TRUE
[09:29:14.530] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.530] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.530] Packages: <none>
[09:29:14.530] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.530] Resolved: TRUE
[09:29:14.530] Value: 112 bytes of class ‘list’
[09:29:14.530] Early signaling: FALSE
[09:29:14.530] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.530] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.531] Chunk #5 of 5 ... DONE
[09:29:14.531] Launching 5 futures (chunks) ... DONE
[09:29:14.531] Resolving 5 futures (chunks) ...
[09:29:14.531] resolve() on list ...
[09:29:14.532]  recursive: 0
[09:29:14.532]  length: 5
[09:29:14.532] 
[09:29:14.532] resolved() for ‘SequentialFuture’ ...
[09:29:14.532] - state: ‘finished’
[09:29:14.532] - run: TRUE
[09:29:14.532] - result: ‘FutureResult’
[09:29:14.532] resolved() for ‘SequentialFuture’ ... done
[09:29:14.532] Future #1
[09:29:14.532] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.533] - nx: 5
[09:29:14.533] - relay: TRUE
[09:29:14.533] - stdout: TRUE
[09:29:14.533] - signal: TRUE
[09:29:14.533] - resignal: FALSE
[09:29:14.533] - force: TRUE
[09:29:14.533] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[09:29:14.533] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[09:29:14.533]  - until=1
[09:29:14.533]  - relaying element #1
[09:29:14.534] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[09:29:14.534] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[09:29:14.534] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.534]  length: 4 (resolved future 1)
[09:29:14.534] resolved() for ‘SequentialFuture’ ...
[09:29:14.534] - state: ‘finished’
[09:29:14.534] - run: TRUE
[09:29:14.534] - result: ‘FutureResult’
[09:29:14.534] resolved() for ‘SequentialFuture’ ... done
[09:29:14.534] Future #2
[09:29:14.535] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:29:14.535] - nx: 5
[09:29:14.535] - relay: TRUE
[09:29:14.535] - stdout: TRUE
[09:29:14.535] - signal: TRUE
[09:29:14.535] - resignal: FALSE
[09:29:14.535] - force: TRUE
[09:29:14.535] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[09:29:14.535] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[09:29:14.535]  - until=2
[09:29:14.535]  - relaying element #2
[09:29:14.536] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[09:29:14.536] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[09:29:14.536] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:29:14.536]  length: 3 (resolved future 2)
[09:29:14.536] resolved() for ‘SequentialFuture’ ...
[09:29:14.536] - state: ‘finished’
[09:29:14.536] - run: TRUE
[09:29:14.536] - result: ‘FutureResult’
[09:29:14.536] resolved() for ‘SequentialFuture’ ... done
[09:29:14.536] Future #3
[09:29:14.537] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:29:14.537] - nx: 5
[09:29:14.537] - relay: TRUE
[09:29:14.537] - stdout: TRUE
[09:29:14.537] - signal: TRUE
[09:29:14.537] - resignal: FALSE
[09:29:14.537] - force: TRUE
[09:29:14.537] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[09:29:14.537] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[09:29:14.537]  - until=3
[09:29:14.537]  - relaying element #3
[09:29:14.538] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[09:29:14.538] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[09:29:14.538] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:29:14.538]  length: 2 (resolved future 3)
[09:29:14.538] resolved() for ‘SequentialFuture’ ...
[09:29:14.538] - state: ‘finished’
[09:29:14.538] - run: TRUE
[09:29:14.538] - result: ‘FutureResult’
[09:29:14.538] resolved() for ‘SequentialFuture’ ... done
[09:29:14.538] Future #4
[09:29:14.539] signalConditionsASAP(SequentialFuture, pos=4) ...
[09:29:14.539] - nx: 5
[09:29:14.539] - relay: TRUE
[09:29:14.539] - stdout: TRUE
[09:29:14.539] - signal: TRUE
[09:29:14.539] - resignal: FALSE
[09:29:14.539] - force: TRUE
[09:29:14.539] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[09:29:14.539] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[09:29:14.539]  - until=4
[09:29:14.539]  - relaying element #4
[09:29:14.540] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[09:29:14.540] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[09:29:14.540] signalConditionsASAP(SequentialFuture, pos=4) ... done
[09:29:14.540]  length: 1 (resolved future 4)
[09:29:14.540] resolved() for ‘SequentialFuture’ ...
[09:29:14.540] - state: ‘finished’
[09:29:14.540] - run: TRUE
[09:29:14.540] - result: ‘FutureResult’
[09:29:14.540] resolved() for ‘SequentialFuture’ ... done
[09:29:14.540] Future #5
[09:29:14.541] signalConditionsASAP(SequentialFuture, pos=5) ...
[09:29:14.541] - nx: 5
[09:29:14.541] - relay: TRUE
[09:29:14.541] - stdout: TRUE
[09:29:14.541] - signal: TRUE
[09:29:14.541] - resignal: FALSE
[09:29:14.541] - force: TRUE
[09:29:14.541] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[09:29:14.541] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[09:29:14.541]  - until=5
[09:29:14.541]  - relaying element #5
[09:29:14.542] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:14.542] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:14.543] signalConditionsASAP(SequentialFuture, pos=5) ... done
[09:29:14.543]  length: 0 (resolved future 5)
[09:29:14.543] Relaying remaining futures
[09:29:14.544] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.544] - nx: 5
[09:29:14.544] - relay: TRUE
[09:29:14.544] - stdout: TRUE
[09:29:14.544] - signal: TRUE
[09:29:14.544] - resignal: FALSE
[09:29:14.544] - force: TRUE
[09:29:14.544] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:14.544] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[09:29:14.545] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:14.545] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:14.545] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.545] resolve() on list ... DONE
[09:29:14.545]  - Number of value chunks collected: 5
[09:29:14.545] Resolving 5 futures (chunks) ... DONE
[09:29:14.545] Reducing values from 5 chunks ...
[09:29:14.545]  - Number of values collected after concatenation: 5
[09:29:14.546]  - Number of values expected: 5
[09:29:14.546] Reducing values from 5 chunks ... DONE
[09:29:14.546] future_mapply() ... DONE
[09:29:14.546] future_mapply() ...
[09:29:14.546] Number of chunks: 1
[09:29:14.546] getGlobalsAndPackagesXApply() ...
[09:29:14.546]  - future.globals: TRUE
[09:29:14.547] getGlobalsAndPackages() ...
[09:29:14.547] Searching for globals...
[09:29:14.548] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:14.548] Searching for globals ... DONE
[09:29:14.548] Resolving globals: FALSE
[09:29:14.548] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:14.549] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:14.549] - globals: [1] ‘FUN’
[09:29:14.549] 
[09:29:14.549] getGlobalsAndPackages() ... DONE
[09:29:14.549]  - globals found/used: [n=1] ‘FUN’
[09:29:14.549]  - needed namespaces: [n=0] 
[09:29:14.549] Finding globals ... DONE
[09:29:14.550] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.550] List of 2
[09:29:14.550]  $ ...future.FUN:function (C, k)  
[09:29:14.550]  $ MoreArgs     : list()
[09:29:14.550]  - attr(*, "where")=List of 2
[09:29:14.550]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.550]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.550]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.550]  - attr(*, "resolved")= logi FALSE
[09:29:14.550]  - attr(*, "total_size")= num NA
[09:29:14.552] Packages to be attached in all futures: [n=0] 
[09:29:14.552] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.553] Number of futures (= number of chunks): 1
[09:29:14.553] Launching 1 futures (chunks) ...
[09:29:14.553] Chunk #1 of 1 ...
[09:29:14.553]  - Finding globals in '...' for chunk #1 ...
[09:29:14.553] getGlobalsAndPackages() ...
[09:29:14.553] Searching for globals...
[09:29:14.553] 
[09:29:14.553] Searching for globals ... DONE
[09:29:14.554] - globals: [0] <none>
[09:29:14.554] getGlobalsAndPackages() ... DONE
[09:29:14.554]    + additional globals found: [n=0] 
[09:29:14.554]    + additional namespaces needed: [n=0] 
[09:29:14.554]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.554]  - seeds: <none>
[09:29:14.554]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.554] getGlobalsAndPackages() ...
[09:29:14.554] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.554] Resolving globals: FALSE
[09:29:14.555] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[09:29:14.555] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:14.555] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.556] 
[09:29:14.556] getGlobalsAndPackages() ... DONE
[09:29:14.556] run() for ‘Future’ ...
[09:29:14.556] - state: ‘created’
[09:29:14.556] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.556] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.557] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.557]   - Field: ‘label’
[09:29:14.557]   - Field: ‘local’
[09:29:14.557]   - Field: ‘owner’
[09:29:14.557]   - Field: ‘envir’
[09:29:14.557]   - Field: ‘packages’
[09:29:14.557]   - Field: ‘gc’
[09:29:14.557]   - Field: ‘conditions’
[09:29:14.557]   - Field: ‘expr’
[09:29:14.557]   - Field: ‘uuid’
[09:29:14.557]   - Field: ‘seed’
[09:29:14.558]   - Field: ‘version’
[09:29:14.558]   - Field: ‘result’
[09:29:14.558]   - Field: ‘asynchronous’
[09:29:14.558]   - Field: ‘calls’
[09:29:14.558]   - Field: ‘globals’
[09:29:14.558]   - Field: ‘stdout’
[09:29:14.558]   - Field: ‘earlySignal’
[09:29:14.558]   - Field: ‘lazy’
[09:29:14.558]   - Field: ‘state’
[09:29:14.558] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.558] - Launch lazy future ...
[09:29:14.559] Packages needed by the future expression (n = 0): <none>
[09:29:14.559] Packages needed by future strategies (n = 0): <none>
[09:29:14.559] {
[09:29:14.559]     {
[09:29:14.559]         {
[09:29:14.559]             ...future.startTime <- base::Sys.time()
[09:29:14.559]             {
[09:29:14.559]                 {
[09:29:14.559]                   {
[09:29:14.559]                     base::local({
[09:29:14.559]                       has_future <- base::requireNamespace("future", 
[09:29:14.559]                         quietly = TRUE)
[09:29:14.559]                       if (has_future) {
[09:29:14.559]                         ns <- base::getNamespace("future")
[09:29:14.559]                         version <- ns[[".package"]][["version"]]
[09:29:14.559]                         if (is.null(version)) 
[09:29:14.559]                           version <- utils::packageVersion("future")
[09:29:14.559]                       }
[09:29:14.559]                       else {
[09:29:14.559]                         version <- NULL
[09:29:14.559]                       }
[09:29:14.559]                       if (!has_future || version < "1.8.0") {
[09:29:14.559]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.559]                           "", base::R.version$version.string), 
[09:29:14.559]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.559]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.559]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.559]                             "release", "version")], collapse = " "), 
[09:29:14.559]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.559]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.559]                           info)
[09:29:14.559]                         info <- base::paste(info, collapse = "; ")
[09:29:14.559]                         if (!has_future) {
[09:29:14.559]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.559]                             info)
[09:29:14.559]                         }
[09:29:14.559]                         else {
[09:29:14.559]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.559]                             info, version)
[09:29:14.559]                         }
[09:29:14.559]                         base::stop(msg)
[09:29:14.559]                       }
[09:29:14.559]                     })
[09:29:14.559]                   }
[09:29:14.559]                   ...future.strategy.old <- future::plan("list")
[09:29:14.559]                   options(future.plan = NULL)
[09:29:14.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.559]                 }
[09:29:14.559]                 ...future.workdir <- getwd()
[09:29:14.559]             }
[09:29:14.559]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.559]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.559]         }
[09:29:14.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.559]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.559]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.559]             base::names(...future.oldOptions))
[09:29:14.559]     }
[09:29:14.559]     if (FALSE) {
[09:29:14.559]     }
[09:29:14.559]     else {
[09:29:14.559]         if (TRUE) {
[09:29:14.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.559]                 open = "w")
[09:29:14.559]         }
[09:29:14.559]         else {
[09:29:14.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.559]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.559]         }
[09:29:14.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.559]             base::sink(type = "output", split = FALSE)
[09:29:14.559]             base::close(...future.stdout)
[09:29:14.559]         }, add = TRUE)
[09:29:14.559]     }
[09:29:14.559]     ...future.frame <- base::sys.nframe()
[09:29:14.559]     ...future.conditions <- base::list()
[09:29:14.559]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.559]     if (FALSE) {
[09:29:14.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.559]     }
[09:29:14.559]     ...future.result <- base::tryCatch({
[09:29:14.559]         base::withCallingHandlers({
[09:29:14.559]             ...future.value <- base::withVisible(base::local({
[09:29:14.559]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.559]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.559]                   ...future.globals.maxSize)) {
[09:29:14.559]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.559]                   on.exit(options(oopts), add = TRUE)
[09:29:14.559]                 }
[09:29:14.559]                 {
[09:29:14.559]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.559]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.559]                     USE.NAMES = FALSE)
[09:29:14.559]                   do.call(mapply, args = args)
[09:29:14.559]                 }
[09:29:14.559]             }))
[09:29:14.559]             future::FutureResult(value = ...future.value$value, 
[09:29:14.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.559]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.559]                     ...future.globalenv.names))
[09:29:14.559]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.559]         }, condition = base::local({
[09:29:14.559]             c <- base::c
[09:29:14.559]             inherits <- base::inherits
[09:29:14.559]             invokeRestart <- base::invokeRestart
[09:29:14.559]             length <- base::length
[09:29:14.559]             list <- base::list
[09:29:14.559]             seq.int <- base::seq.int
[09:29:14.559]             signalCondition <- base::signalCondition
[09:29:14.559]             sys.calls <- base::sys.calls
[09:29:14.559]             `[[` <- base::`[[`
[09:29:14.559]             `+` <- base::`+`
[09:29:14.559]             `<<-` <- base::`<<-`
[09:29:14.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.559]                   3L)]
[09:29:14.559]             }
[09:29:14.559]             function(cond) {
[09:29:14.559]                 is_error <- inherits(cond, "error")
[09:29:14.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.559]                   NULL)
[09:29:14.559]                 if (is_error) {
[09:29:14.559]                   sessionInformation <- function() {
[09:29:14.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.559]                       search = base::search(), system = base::Sys.info())
[09:29:14.559]                   }
[09:29:14.559]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.559]                     cond$call), session = sessionInformation(), 
[09:29:14.559]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.559]                   signalCondition(cond)
[09:29:14.559]                 }
[09:29:14.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.559]                 "immediateCondition"))) {
[09:29:14.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.559]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.559]                   if (TRUE && !signal) {
[09:29:14.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.559]                     {
[09:29:14.559]                       inherits <- base::inherits
[09:29:14.559]                       invokeRestart <- base::invokeRestart
[09:29:14.559]                       is.null <- base::is.null
[09:29:14.559]                       muffled <- FALSE
[09:29:14.559]                       if (inherits(cond, "message")) {
[09:29:14.559]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.559]                         if (muffled) 
[09:29:14.559]                           invokeRestart("muffleMessage")
[09:29:14.559]                       }
[09:29:14.559]                       else if (inherits(cond, "warning")) {
[09:29:14.559]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.559]                         if (muffled) 
[09:29:14.559]                           invokeRestart("muffleWarning")
[09:29:14.559]                       }
[09:29:14.559]                       else if (inherits(cond, "condition")) {
[09:29:14.559]                         if (!is.null(pattern)) {
[09:29:14.559]                           computeRestarts <- base::computeRestarts
[09:29:14.559]                           grepl <- base::grepl
[09:29:14.559]                           restarts <- computeRestarts(cond)
[09:29:14.559]                           for (restart in restarts) {
[09:29:14.559]                             name <- restart$name
[09:29:14.559]                             if (is.null(name)) 
[09:29:14.559]                               next
[09:29:14.559]                             if (!grepl(pattern, name)) 
[09:29:14.559]                               next
[09:29:14.559]                             invokeRestart(restart)
[09:29:14.559]                             muffled <- TRUE
[09:29:14.559]                             break
[09:29:14.559]                           }
[09:29:14.559]                         }
[09:29:14.559]                       }
[09:29:14.559]                       invisible(muffled)
[09:29:14.559]                     }
[09:29:14.559]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.559]                   }
[09:29:14.559]                 }
[09:29:14.559]                 else {
[09:29:14.559]                   if (TRUE) {
[09:29:14.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.559]                     {
[09:29:14.559]                       inherits <- base::inherits
[09:29:14.559]                       invokeRestart <- base::invokeRestart
[09:29:14.559]                       is.null <- base::is.null
[09:29:14.559]                       muffled <- FALSE
[09:29:14.559]                       if (inherits(cond, "message")) {
[09:29:14.559]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.559]                         if (muffled) 
[09:29:14.559]                           invokeRestart("muffleMessage")
[09:29:14.559]                       }
[09:29:14.559]                       else if (inherits(cond, "warning")) {
[09:29:14.559]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.559]                         if (muffled) 
[09:29:14.559]                           invokeRestart("muffleWarning")
[09:29:14.559]                       }
[09:29:14.559]                       else if (inherits(cond, "condition")) {
[09:29:14.559]                         if (!is.null(pattern)) {
[09:29:14.559]                           computeRestarts <- base::computeRestarts
[09:29:14.559]                           grepl <- base::grepl
[09:29:14.559]                           restarts <- computeRestarts(cond)
[09:29:14.559]                           for (restart in restarts) {
[09:29:14.559]                             name <- restart$name
[09:29:14.559]                             if (is.null(name)) 
[09:29:14.559]                               next
[09:29:14.559]                             if (!grepl(pattern, name)) 
[09:29:14.559]                               next
[09:29:14.559]                             invokeRestart(restart)
[09:29:14.559]                             muffled <- TRUE
[09:29:14.559]                             break
[09:29:14.559]                           }
[09:29:14.559]                         }
[09:29:14.559]                       }
[09:29:14.559]                       invisible(muffled)
[09:29:14.559]                     }
[09:29:14.559]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.559]                   }
[09:29:14.559]                 }
[09:29:14.559]             }
[09:29:14.559]         }))
[09:29:14.559]     }, error = function(ex) {
[09:29:14.559]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.559]                 ...future.rng), started = ...future.startTime, 
[09:29:14.559]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.559]             version = "1.8"), class = "FutureResult")
[09:29:14.559]     }, finally = {
[09:29:14.559]         if (!identical(...future.workdir, getwd())) 
[09:29:14.559]             setwd(...future.workdir)
[09:29:14.559]         {
[09:29:14.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.559]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.559]             }
[09:29:14.559]             base::options(...future.oldOptions)
[09:29:14.559]             if (.Platform$OS.type == "windows") {
[09:29:14.559]                 old_names <- names(...future.oldEnvVars)
[09:29:14.559]                 envs <- base::Sys.getenv()
[09:29:14.559]                 names <- names(envs)
[09:29:14.559]                 common <- intersect(names, old_names)
[09:29:14.559]                 added <- setdiff(names, old_names)
[09:29:14.559]                 removed <- setdiff(old_names, names)
[09:29:14.559]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.559]                   envs[common]]
[09:29:14.559]                 NAMES <- toupper(changed)
[09:29:14.559]                 args <- list()
[09:29:14.559]                 for (kk in seq_along(NAMES)) {
[09:29:14.559]                   name <- changed[[kk]]
[09:29:14.559]                   NAME <- NAMES[[kk]]
[09:29:14.559]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.559]                     next
[09:29:14.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.559]                 }
[09:29:14.559]                 NAMES <- toupper(added)
[09:29:14.559]                 for (kk in seq_along(NAMES)) {
[09:29:14.559]                   name <- added[[kk]]
[09:29:14.559]                   NAME <- NAMES[[kk]]
[09:29:14.559]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.559]                     next
[09:29:14.559]                   args[[name]] <- ""
[09:29:14.559]                 }
[09:29:14.559]                 NAMES <- toupper(removed)
[09:29:14.559]                 for (kk in seq_along(NAMES)) {
[09:29:14.559]                   name <- removed[[kk]]
[09:29:14.559]                   NAME <- NAMES[[kk]]
[09:29:14.559]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.559]                     next
[09:29:14.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.559]                 }
[09:29:14.559]                 if (length(args) > 0) 
[09:29:14.559]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.559]             }
[09:29:14.559]             else {
[09:29:14.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.559]             }
[09:29:14.559]             {
[09:29:14.559]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.559]                   0L) {
[09:29:14.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.559]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.559]                   base::options(opts)
[09:29:14.559]                 }
[09:29:14.559]                 {
[09:29:14.559]                   {
[09:29:14.559]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.559]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.559]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.559]                     NULL
[09:29:14.559]                   }
[09:29:14.559]                   options(future.plan = NULL)
[09:29:14.559]                   if (is.na(NA_character_)) 
[09:29:14.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.559]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.559]                     .init = FALSE)
[09:29:14.559]                 }
[09:29:14.559]             }
[09:29:14.559]         }
[09:29:14.559]     })
[09:29:14.559]     if (TRUE) {
[09:29:14.559]         base::sink(type = "output", split = FALSE)
[09:29:14.559]         if (TRUE) {
[09:29:14.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.559]         }
[09:29:14.559]         else {
[09:29:14.559]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.559]         }
[09:29:14.559]         base::close(...future.stdout)
[09:29:14.559]         ...future.stdout <- NULL
[09:29:14.559]     }
[09:29:14.559]     ...future.result$conditions <- ...future.conditions
[09:29:14.559]     ...future.result$finished <- base::Sys.time()
[09:29:14.559]     ...future.result
[09:29:14.559] }
[09:29:14.561] assign_globals() ...
[09:29:14.561] List of 5
[09:29:14.561]  $ ...future.FUN            :function (C, k)  
[09:29:14.561]  $ MoreArgs                 : list()
[09:29:14.561]  $ ...future.elements_ii    :List of 2
[09:29:14.561]   ..$ :List of 5
[09:29:14.561]   .. ..$ : chr "A"
[09:29:14.561]   .. ..$ : chr "B"
[09:29:14.561]   .. ..$ : chr "C"
[09:29:14.561]   .. ..$ : chr "D"
[09:29:14.561]   .. ..$ : chr "E"
[09:29:14.561]   ..$ :List of 5
[09:29:14.561]   .. ..$ : int 5
[09:29:14.561]   .. ..$ : int 4
[09:29:14.561]   .. ..$ : int 3
[09:29:14.561]   .. ..$ : int 2
[09:29:14.561]   .. ..$ : int 1
[09:29:14.561]  $ ...future.seeds_ii       : NULL
[09:29:14.561]  $ ...future.globals.maxSize: NULL
[09:29:14.561]  - attr(*, "where")=List of 5
[09:29:14.561]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.561]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.561]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.561]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.561]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.561]  - attr(*, "resolved")= logi FALSE
[09:29:14.561]  - attr(*, "total_size")= num 4160
[09:29:14.561]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.561]  - attr(*, "already-done")= logi TRUE
[09:29:14.568] - reassign environment for ‘...future.FUN’
[09:29:14.568] - copied ‘...future.FUN’ to environment
[09:29:14.568] - copied ‘MoreArgs’ to environment
[09:29:14.568] - copied ‘...future.elements_ii’ to environment
[09:29:14.569] - copied ‘...future.seeds_ii’ to environment
[09:29:14.570] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.570] assign_globals() ... done
[09:29:14.570] plan(): Setting new future strategy stack:
[09:29:14.570] List of future strategies:
[09:29:14.570] 1. sequential:
[09:29:14.570]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.570]    - tweaked: FALSE
[09:29:14.570]    - call: NULL
[09:29:14.571] plan(): nbrOfWorkers() = 1
[09:29:14.571] plan(): Setting new future strategy stack:
[09:29:14.571] List of future strategies:
[09:29:14.571] 1. sequential:
[09:29:14.571]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.571]    - tweaked: FALSE
[09:29:14.571]    - call: plan(strategy)
[09:29:14.572] plan(): nbrOfWorkers() = 1
[09:29:14.572] SequentialFuture started (and completed)
[09:29:14.572] - Launch lazy future ... done
[09:29:14.572] run() for ‘SequentialFuture’ ... done
[09:29:14.572] Created future:
[09:29:14.573] SequentialFuture:
[09:29:14.573] Label: ‘future_.mapply-1’
[09:29:14.573] Expression:
[09:29:14.573] {
[09:29:14.573]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.573]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.573]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.573]         on.exit(options(oopts), add = TRUE)
[09:29:14.573]     }
[09:29:14.573]     {
[09:29:14.573]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.573]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.573]         do.call(mapply, args = args)
[09:29:14.573]     }
[09:29:14.573] }
[09:29:14.573] Lazy evaluation: FALSE
[09:29:14.573] Asynchronous evaluation: FALSE
[09:29:14.573] Local evaluation: TRUE
[09:29:14.573] Environment: R_GlobalEnv
[09:29:14.573] Capture standard output: TRUE
[09:29:14.573] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.573] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.573] Packages: <none>
[09:29:14.573] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.573] Resolved: TRUE
[09:29:14.573] Value: 560 bytes of class ‘list’
[09:29:14.573] Early signaling: FALSE
[09:29:14.573] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.573] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.573] Chunk #1 of 1 ... DONE
[09:29:14.574] Launching 1 futures (chunks) ... DONE
[09:29:14.574] Resolving 1 futures (chunks) ...
[09:29:14.574] resolve() on list ...
[09:29:14.574]  recursive: 0
[09:29:14.574]  length: 1
[09:29:14.574] 
[09:29:14.574] resolved() for ‘SequentialFuture’ ...
[09:29:14.574] - state: ‘finished’
[09:29:14.574] - run: TRUE
[09:29:14.574] - result: ‘FutureResult’
[09:29:14.575] resolved() for ‘SequentialFuture’ ... done
[09:29:14.575] Future #1
[09:29:14.575] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.575] - nx: 1
[09:29:14.575] - relay: TRUE
[09:29:14.575] - stdout: TRUE
[09:29:14.575] - signal: TRUE
[09:29:14.575] - resignal: FALSE
[09:29:14.575] - force: TRUE
[09:29:14.575] - relayed: [n=1] FALSE
[09:29:14.576] - queued futures: [n=1] FALSE
[09:29:14.576]  - until=1
[09:29:14.576]  - relaying element #1
[09:29:14.576] - relayed: [n=1] TRUE
[09:29:14.576] - queued futures: [n=1] TRUE
[09:29:14.576] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.576]  length: 0 (resolved future 1)
[09:29:14.576] Relaying remaining futures
[09:29:14.576] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.577] - nx: 1
[09:29:14.577] - relay: TRUE
[09:29:14.577] - stdout: TRUE
[09:29:14.577] - signal: TRUE
[09:29:14.577] - resignal: FALSE
[09:29:14.577] - force: TRUE
[09:29:14.577] - relayed: [n=1] TRUE
[09:29:14.577] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.577] - relayed: [n=1] TRUE
[09:29:14.577] - queued futures: [n=1] TRUE
[09:29:14.577] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.577] resolve() on list ... DONE
[09:29:14.578]  - Number of value chunks collected: 1
[09:29:14.578] Resolving 1 futures (chunks) ... DONE
[09:29:14.578] Reducing values from 1 chunks ...
[09:29:14.578]  - Number of values collected after concatenation: 5
[09:29:14.578]  - Number of values expected: 5
[09:29:14.578] Reducing values from 1 chunks ... DONE
[09:29:14.578] future_mapply() ... DONE
[09:29:14.578] future_mapply() ...
[09:29:14.579] Number of chunks: 3
[09:29:14.579] Index remapping (attribute 'ordering'): [n = 5] 3, 5, 1, 4, 2
[09:29:14.579] getGlobalsAndPackagesXApply() ...
[09:29:14.579]  - future.globals: TRUE
[09:29:14.579] getGlobalsAndPackages() ...
[09:29:14.579] Searching for globals...
[09:29:14.581] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:14.581] Searching for globals ... DONE
[09:29:14.581] Resolving globals: FALSE
[09:29:14.581] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:14.581] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:14.582] - globals: [1] ‘FUN’
[09:29:14.582] 
[09:29:14.582] getGlobalsAndPackages() ... DONE
[09:29:14.582]  - globals found/used: [n=1] ‘FUN’
[09:29:14.582]  - needed namespaces: [n=0] 
[09:29:14.582] Finding globals ... DONE
[09:29:14.582] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.582] List of 2
[09:29:14.582]  $ ...future.FUN:function (C, k)  
[09:29:14.582]  $ MoreArgs     : NULL
[09:29:14.582]  - attr(*, "where")=List of 2
[09:29:14.582]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.582]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.582]  - attr(*, "resolved")= logi FALSE
[09:29:14.582]  - attr(*, "total_size")= num NA
[09:29:14.585] Packages to be attached in all futures: [n=0] 
[09:29:14.585] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.585] Number of futures (= number of chunks): 3
[09:29:14.585] Launching 3 futures (chunks) ...
[09:29:14.585] Chunk #1 of 3 ...
[09:29:14.585]  - Finding globals in '...' for chunk #1 ...
[09:29:14.586] getGlobalsAndPackages() ...
[09:29:14.586] Searching for globals...
[09:29:14.586] 
[09:29:14.586] Searching for globals ... DONE
[09:29:14.586] - globals: [0] <none>
[09:29:14.586] getGlobalsAndPackages() ... DONE
[09:29:14.586]    + additional globals found: [n=0] 
[09:29:14.586]    + additional namespaces needed: [n=0] 
[09:29:14.586]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.587]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[09:29:14.587]  - seeds: <none>
[09:29:14.587]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.587] getGlobalsAndPackages() ...
[09:29:14.587] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.587] Resolving globals: FALSE
[09:29:14.588] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:14.588] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.588] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.588] 
[09:29:14.588] getGlobalsAndPackages() ... DONE
[09:29:14.589] run() for ‘Future’ ...
[09:29:14.589] - state: ‘created’
[09:29:14.589] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.589] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.589] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.589]   - Field: ‘label’
[09:29:14.589]   - Field: ‘local’
[09:29:14.590]   - Field: ‘owner’
[09:29:14.590]   - Field: ‘envir’
[09:29:14.590]   - Field: ‘packages’
[09:29:14.590]   - Field: ‘gc’
[09:29:14.590]   - Field: ‘conditions’
[09:29:14.590]   - Field: ‘expr’
[09:29:14.590]   - Field: ‘uuid’
[09:29:14.590]   - Field: ‘seed’
[09:29:14.590]   - Field: ‘version’
[09:29:14.590]   - Field: ‘result’
[09:29:14.590]   - Field: ‘asynchronous’
[09:29:14.591]   - Field: ‘calls’
[09:29:14.591]   - Field: ‘globals’
[09:29:14.591]   - Field: ‘stdout’
[09:29:14.591]   - Field: ‘earlySignal’
[09:29:14.591]   - Field: ‘lazy’
[09:29:14.591]   - Field: ‘state’
[09:29:14.591] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.591] - Launch lazy future ...
[09:29:14.591] Packages needed by the future expression (n = 0): <none>
[09:29:14.591] Packages needed by future strategies (n = 0): <none>
[09:29:14.592] {
[09:29:14.592]     {
[09:29:14.592]         {
[09:29:14.592]             ...future.startTime <- base::Sys.time()
[09:29:14.592]             {
[09:29:14.592]                 {
[09:29:14.592]                   {
[09:29:14.592]                     base::local({
[09:29:14.592]                       has_future <- base::requireNamespace("future", 
[09:29:14.592]                         quietly = TRUE)
[09:29:14.592]                       if (has_future) {
[09:29:14.592]                         ns <- base::getNamespace("future")
[09:29:14.592]                         version <- ns[[".package"]][["version"]]
[09:29:14.592]                         if (is.null(version)) 
[09:29:14.592]                           version <- utils::packageVersion("future")
[09:29:14.592]                       }
[09:29:14.592]                       else {
[09:29:14.592]                         version <- NULL
[09:29:14.592]                       }
[09:29:14.592]                       if (!has_future || version < "1.8.0") {
[09:29:14.592]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.592]                           "", base::R.version$version.string), 
[09:29:14.592]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.592]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.592]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.592]                             "release", "version")], collapse = " "), 
[09:29:14.592]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.592]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.592]                           info)
[09:29:14.592]                         info <- base::paste(info, collapse = "; ")
[09:29:14.592]                         if (!has_future) {
[09:29:14.592]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.592]                             info)
[09:29:14.592]                         }
[09:29:14.592]                         else {
[09:29:14.592]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.592]                             info, version)
[09:29:14.592]                         }
[09:29:14.592]                         base::stop(msg)
[09:29:14.592]                       }
[09:29:14.592]                     })
[09:29:14.592]                   }
[09:29:14.592]                   ...future.strategy.old <- future::plan("list")
[09:29:14.592]                   options(future.plan = NULL)
[09:29:14.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.592]                 }
[09:29:14.592]                 ...future.workdir <- getwd()
[09:29:14.592]             }
[09:29:14.592]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.592]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.592]         }
[09:29:14.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.592]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[09:29:14.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.592]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.592]             base::names(...future.oldOptions))
[09:29:14.592]     }
[09:29:14.592]     if (FALSE) {
[09:29:14.592]     }
[09:29:14.592]     else {
[09:29:14.592]         if (TRUE) {
[09:29:14.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.592]                 open = "w")
[09:29:14.592]         }
[09:29:14.592]         else {
[09:29:14.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.592]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.592]         }
[09:29:14.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.592]             base::sink(type = "output", split = FALSE)
[09:29:14.592]             base::close(...future.stdout)
[09:29:14.592]         }, add = TRUE)
[09:29:14.592]     }
[09:29:14.592]     ...future.frame <- base::sys.nframe()
[09:29:14.592]     ...future.conditions <- base::list()
[09:29:14.592]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.592]     if (FALSE) {
[09:29:14.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.592]     }
[09:29:14.592]     ...future.result <- base::tryCatch({
[09:29:14.592]         base::withCallingHandlers({
[09:29:14.592]             ...future.value <- base::withVisible(base::local({
[09:29:14.592]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.592]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.592]                   ...future.globals.maxSize)) {
[09:29:14.592]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.592]                   on.exit(options(oopts), add = TRUE)
[09:29:14.592]                 }
[09:29:14.592]                 {
[09:29:14.592]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.592]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.592]                     USE.NAMES = FALSE)
[09:29:14.592]                   do.call(mapply, args = args)
[09:29:14.592]                 }
[09:29:14.592]             }))
[09:29:14.592]             future::FutureResult(value = ...future.value$value, 
[09:29:14.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.592]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.592]                     ...future.globalenv.names))
[09:29:14.592]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.592]         }, condition = base::local({
[09:29:14.592]             c <- base::c
[09:29:14.592]             inherits <- base::inherits
[09:29:14.592]             invokeRestart <- base::invokeRestart
[09:29:14.592]             length <- base::length
[09:29:14.592]             list <- base::list
[09:29:14.592]             seq.int <- base::seq.int
[09:29:14.592]             signalCondition <- base::signalCondition
[09:29:14.592]             sys.calls <- base::sys.calls
[09:29:14.592]             `[[` <- base::`[[`
[09:29:14.592]             `+` <- base::`+`
[09:29:14.592]             `<<-` <- base::`<<-`
[09:29:14.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.592]                   3L)]
[09:29:14.592]             }
[09:29:14.592]             function(cond) {
[09:29:14.592]                 is_error <- inherits(cond, "error")
[09:29:14.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.592]                   NULL)
[09:29:14.592]                 if (is_error) {
[09:29:14.592]                   sessionInformation <- function() {
[09:29:14.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.592]                       search = base::search(), system = base::Sys.info())
[09:29:14.592]                   }
[09:29:14.592]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.592]                     cond$call), session = sessionInformation(), 
[09:29:14.592]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.592]                   signalCondition(cond)
[09:29:14.592]                 }
[09:29:14.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.592]                 "immediateCondition"))) {
[09:29:14.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.592]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.592]                   if (TRUE && !signal) {
[09:29:14.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.592]                     {
[09:29:14.592]                       inherits <- base::inherits
[09:29:14.592]                       invokeRestart <- base::invokeRestart
[09:29:14.592]                       is.null <- base::is.null
[09:29:14.592]                       muffled <- FALSE
[09:29:14.592]                       if (inherits(cond, "message")) {
[09:29:14.592]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.592]                         if (muffled) 
[09:29:14.592]                           invokeRestart("muffleMessage")
[09:29:14.592]                       }
[09:29:14.592]                       else if (inherits(cond, "warning")) {
[09:29:14.592]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.592]                         if (muffled) 
[09:29:14.592]                           invokeRestart("muffleWarning")
[09:29:14.592]                       }
[09:29:14.592]                       else if (inherits(cond, "condition")) {
[09:29:14.592]                         if (!is.null(pattern)) {
[09:29:14.592]                           computeRestarts <- base::computeRestarts
[09:29:14.592]                           grepl <- base::grepl
[09:29:14.592]                           restarts <- computeRestarts(cond)
[09:29:14.592]                           for (restart in restarts) {
[09:29:14.592]                             name <- restart$name
[09:29:14.592]                             if (is.null(name)) 
[09:29:14.592]                               next
[09:29:14.592]                             if (!grepl(pattern, name)) 
[09:29:14.592]                               next
[09:29:14.592]                             invokeRestart(restart)
[09:29:14.592]                             muffled <- TRUE
[09:29:14.592]                             break
[09:29:14.592]                           }
[09:29:14.592]                         }
[09:29:14.592]                       }
[09:29:14.592]                       invisible(muffled)
[09:29:14.592]                     }
[09:29:14.592]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.592]                   }
[09:29:14.592]                 }
[09:29:14.592]                 else {
[09:29:14.592]                   if (TRUE) {
[09:29:14.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.592]                     {
[09:29:14.592]                       inherits <- base::inherits
[09:29:14.592]                       invokeRestart <- base::invokeRestart
[09:29:14.592]                       is.null <- base::is.null
[09:29:14.592]                       muffled <- FALSE
[09:29:14.592]                       if (inherits(cond, "message")) {
[09:29:14.592]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.592]                         if (muffled) 
[09:29:14.592]                           invokeRestart("muffleMessage")
[09:29:14.592]                       }
[09:29:14.592]                       else if (inherits(cond, "warning")) {
[09:29:14.592]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.592]                         if (muffled) 
[09:29:14.592]                           invokeRestart("muffleWarning")
[09:29:14.592]                       }
[09:29:14.592]                       else if (inherits(cond, "condition")) {
[09:29:14.592]                         if (!is.null(pattern)) {
[09:29:14.592]                           computeRestarts <- base::computeRestarts
[09:29:14.592]                           grepl <- base::grepl
[09:29:14.592]                           restarts <- computeRestarts(cond)
[09:29:14.592]                           for (restart in restarts) {
[09:29:14.592]                             name <- restart$name
[09:29:14.592]                             if (is.null(name)) 
[09:29:14.592]                               next
[09:29:14.592]                             if (!grepl(pattern, name)) 
[09:29:14.592]                               next
[09:29:14.592]                             invokeRestart(restart)
[09:29:14.592]                             muffled <- TRUE
[09:29:14.592]                             break
[09:29:14.592]                           }
[09:29:14.592]                         }
[09:29:14.592]                       }
[09:29:14.592]                       invisible(muffled)
[09:29:14.592]                     }
[09:29:14.592]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.592]                   }
[09:29:14.592]                 }
[09:29:14.592]             }
[09:29:14.592]         }))
[09:29:14.592]     }, error = function(ex) {
[09:29:14.592]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.592]                 ...future.rng), started = ...future.startTime, 
[09:29:14.592]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.592]             version = "1.8"), class = "FutureResult")
[09:29:14.592]     }, finally = {
[09:29:14.592]         if (!identical(...future.workdir, getwd())) 
[09:29:14.592]             setwd(...future.workdir)
[09:29:14.592]         {
[09:29:14.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.592]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.592]             }
[09:29:14.592]             base::options(...future.oldOptions)
[09:29:14.592]             if (.Platform$OS.type == "windows") {
[09:29:14.592]                 old_names <- names(...future.oldEnvVars)
[09:29:14.592]                 envs <- base::Sys.getenv()
[09:29:14.592]                 names <- names(envs)
[09:29:14.592]                 common <- intersect(names, old_names)
[09:29:14.592]                 added <- setdiff(names, old_names)
[09:29:14.592]                 removed <- setdiff(old_names, names)
[09:29:14.592]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.592]                   envs[common]]
[09:29:14.592]                 NAMES <- toupper(changed)
[09:29:14.592]                 args <- list()
[09:29:14.592]                 for (kk in seq_along(NAMES)) {
[09:29:14.592]                   name <- changed[[kk]]
[09:29:14.592]                   NAME <- NAMES[[kk]]
[09:29:14.592]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.592]                     next
[09:29:14.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.592]                 }
[09:29:14.592]                 NAMES <- toupper(added)
[09:29:14.592]                 for (kk in seq_along(NAMES)) {
[09:29:14.592]                   name <- added[[kk]]
[09:29:14.592]                   NAME <- NAMES[[kk]]
[09:29:14.592]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.592]                     next
[09:29:14.592]                   args[[name]] <- ""
[09:29:14.592]                 }
[09:29:14.592]                 NAMES <- toupper(removed)
[09:29:14.592]                 for (kk in seq_along(NAMES)) {
[09:29:14.592]                   name <- removed[[kk]]
[09:29:14.592]                   NAME <- NAMES[[kk]]
[09:29:14.592]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.592]                     next
[09:29:14.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.592]                 }
[09:29:14.592]                 if (length(args) > 0) 
[09:29:14.592]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.592]             }
[09:29:14.592]             else {
[09:29:14.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.592]             }
[09:29:14.592]             {
[09:29:14.592]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.592]                   0L) {
[09:29:14.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.592]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.592]                   base::options(opts)
[09:29:14.592]                 }
[09:29:14.592]                 {
[09:29:14.592]                   {
[09:29:14.592]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.592]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.592]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.592]                     NULL
[09:29:14.592]                   }
[09:29:14.592]                   options(future.plan = NULL)
[09:29:14.592]                   if (is.na(NA_character_)) 
[09:29:14.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.592]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.592]                     .init = FALSE)
[09:29:14.592]                 }
[09:29:14.592]             }
[09:29:14.592]         }
[09:29:14.592]     })
[09:29:14.592]     if (TRUE) {
[09:29:14.592]         base::sink(type = "output", split = FALSE)
[09:29:14.592]         if (TRUE) {
[09:29:14.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.592]         }
[09:29:14.592]         else {
[09:29:14.592]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.592]         }
[09:29:14.592]         base::close(...future.stdout)
[09:29:14.592]         ...future.stdout <- NULL
[09:29:14.592]     }
[09:29:14.592]     ...future.result$conditions <- ...future.conditions
[09:29:14.592]     ...future.result$finished <- base::Sys.time()
[09:29:14.592]     ...future.result
[09:29:14.592] }
[09:29:14.594] assign_globals() ...
[09:29:14.594] List of 5
[09:29:14.594]  $ ...future.FUN            :function (C, k)  
[09:29:14.594]  $ MoreArgs                 : NULL
[09:29:14.594]  $ ...future.elements_ii    :List of 2
[09:29:14.594]   ..$ :List of 2
[09:29:14.594]   .. ..$ : chr "C"
[09:29:14.594]   .. ..$ : chr "E"
[09:29:14.594]   ..$ :List of 2
[09:29:14.594]   .. ..$ : int 3
[09:29:14.594]   .. ..$ : int 1
[09:29:14.594]  $ ...future.seeds_ii       : NULL
[09:29:14.594]  $ ...future.globals.maxSize: NULL
[09:29:14.594]  - attr(*, "where")=List of 5
[09:29:14.594]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.594]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.594]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.594]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.594]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.594]  - attr(*, "resolved")= logi FALSE
[09:29:14.594]  - attr(*, "total_size")= num 3656
[09:29:14.594]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.594]  - attr(*, "already-done")= logi TRUE
[09:29:14.601] - reassign environment for ‘...future.FUN’
[09:29:14.601] - copied ‘...future.FUN’ to environment
[09:29:14.601] - copied ‘MoreArgs’ to environment
[09:29:14.601] - copied ‘...future.elements_ii’ to environment
[09:29:14.601] - copied ‘...future.seeds_ii’ to environment
[09:29:14.601] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.601] assign_globals() ... done
[09:29:14.602] plan(): Setting new future strategy stack:
[09:29:14.602] List of future strategies:
[09:29:14.602] 1. sequential:
[09:29:14.602]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.602]    - tweaked: FALSE
[09:29:14.602]    - call: NULL
[09:29:14.602] plan(): nbrOfWorkers() = 1
[09:29:14.603] plan(): Setting new future strategy stack:
[09:29:14.603] List of future strategies:
[09:29:14.603] 1. sequential:
[09:29:14.603]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.603]    - tweaked: FALSE
[09:29:14.603]    - call: plan(strategy)
[09:29:14.603] plan(): nbrOfWorkers() = 1
[09:29:14.604] SequentialFuture started (and completed)
[09:29:14.604] - Launch lazy future ... done
[09:29:14.604] run() for ‘SequentialFuture’ ... done
[09:29:14.604] Created future:
[09:29:14.604] SequentialFuture:
[09:29:14.604] Label: ‘future_mapply-1’
[09:29:14.604] Expression:
[09:29:14.604] {
[09:29:14.604]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.604]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.604]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.604]         on.exit(options(oopts), add = TRUE)
[09:29:14.604]     }
[09:29:14.604]     {
[09:29:14.604]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.604]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.604]         do.call(mapply, args = args)
[09:29:14.604]     }
[09:29:14.604] }
[09:29:14.604] Lazy evaluation: FALSE
[09:29:14.604] Asynchronous evaluation: FALSE
[09:29:14.604] Local evaluation: TRUE
[09:29:14.604] Environment: R_GlobalEnv
[09:29:14.604] Capture standard output: TRUE
[09:29:14.604] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.604] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.604] Packages: <none>
[09:29:14.604] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.604] Resolved: TRUE
[09:29:14.604] Value: 224 bytes of class ‘list’
[09:29:14.604] Early signaling: FALSE
[09:29:14.604] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.604] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.605] Chunk #1 of 3 ... DONE
[09:29:14.605] Chunk #2 of 3 ...
[09:29:14.605]  - Finding globals in '...' for chunk #2 ...
[09:29:14.605] getGlobalsAndPackages() ...
[09:29:14.605] Searching for globals...
[09:29:14.606] 
[09:29:14.606] Searching for globals ... DONE
[09:29:14.606] - globals: [0] <none>
[09:29:14.606] getGlobalsAndPackages() ... DONE
[09:29:14.606]    + additional globals found: [n=0] 
[09:29:14.606]    + additional namespaces needed: [n=0] 
[09:29:14.606]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:14.606]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[09:29:14.606]  - seeds: <none>
[09:29:14.606]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.606] getGlobalsAndPackages() ...
[09:29:14.607] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.607] Resolving globals: FALSE
[09:29:14.607] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:14.607] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.608] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.608] 
[09:29:14.608] getGlobalsAndPackages() ... DONE
[09:29:14.608] run() for ‘Future’ ...
[09:29:14.608] - state: ‘created’
[09:29:14.608] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.609] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.609] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.609]   - Field: ‘label’
[09:29:14.609]   - Field: ‘local’
[09:29:14.609]   - Field: ‘owner’
[09:29:14.609]   - Field: ‘envir’
[09:29:14.609]   - Field: ‘packages’
[09:29:14.609]   - Field: ‘gc’
[09:29:14.609]   - Field: ‘conditions’
[09:29:14.609]   - Field: ‘expr’
[09:29:14.610]   - Field: ‘uuid’
[09:29:14.610]   - Field: ‘seed’
[09:29:14.610]   - Field: ‘version’
[09:29:14.610]   - Field: ‘result’
[09:29:14.610]   - Field: ‘asynchronous’
[09:29:14.610]   - Field: ‘calls’
[09:29:14.610]   - Field: ‘globals’
[09:29:14.610]   - Field: ‘stdout’
[09:29:14.610]   - Field: ‘earlySignal’
[09:29:14.610]   - Field: ‘lazy’
[09:29:14.610]   - Field: ‘state’
[09:29:14.611] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.611] - Launch lazy future ...
[09:29:14.611] Packages needed by the future expression (n = 0): <none>
[09:29:14.611] Packages needed by future strategies (n = 0): <none>
[09:29:14.611] {
[09:29:14.611]     {
[09:29:14.611]         {
[09:29:14.611]             ...future.startTime <- base::Sys.time()
[09:29:14.611]             {
[09:29:14.611]                 {
[09:29:14.611]                   {
[09:29:14.611]                     base::local({
[09:29:14.611]                       has_future <- base::requireNamespace("future", 
[09:29:14.611]                         quietly = TRUE)
[09:29:14.611]                       if (has_future) {
[09:29:14.611]                         ns <- base::getNamespace("future")
[09:29:14.611]                         version <- ns[[".package"]][["version"]]
[09:29:14.611]                         if (is.null(version)) 
[09:29:14.611]                           version <- utils::packageVersion("future")
[09:29:14.611]                       }
[09:29:14.611]                       else {
[09:29:14.611]                         version <- NULL
[09:29:14.611]                       }
[09:29:14.611]                       if (!has_future || version < "1.8.0") {
[09:29:14.611]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.611]                           "", base::R.version$version.string), 
[09:29:14.611]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.611]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.611]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.611]                             "release", "version")], collapse = " "), 
[09:29:14.611]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.611]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.611]                           info)
[09:29:14.611]                         info <- base::paste(info, collapse = "; ")
[09:29:14.611]                         if (!has_future) {
[09:29:14.611]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.611]                             info)
[09:29:14.611]                         }
[09:29:14.611]                         else {
[09:29:14.611]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.611]                             info, version)
[09:29:14.611]                         }
[09:29:14.611]                         base::stop(msg)
[09:29:14.611]                       }
[09:29:14.611]                     })
[09:29:14.611]                   }
[09:29:14.611]                   ...future.strategy.old <- future::plan("list")
[09:29:14.611]                   options(future.plan = NULL)
[09:29:14.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.611]                 }
[09:29:14.611]                 ...future.workdir <- getwd()
[09:29:14.611]             }
[09:29:14.611]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.611]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.611]         }
[09:29:14.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.611]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[09:29:14.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.611]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.611]             base::names(...future.oldOptions))
[09:29:14.611]     }
[09:29:14.611]     if (FALSE) {
[09:29:14.611]     }
[09:29:14.611]     else {
[09:29:14.611]         if (TRUE) {
[09:29:14.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.611]                 open = "w")
[09:29:14.611]         }
[09:29:14.611]         else {
[09:29:14.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.611]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.611]         }
[09:29:14.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.611]             base::sink(type = "output", split = FALSE)
[09:29:14.611]             base::close(...future.stdout)
[09:29:14.611]         }, add = TRUE)
[09:29:14.611]     }
[09:29:14.611]     ...future.frame <- base::sys.nframe()
[09:29:14.611]     ...future.conditions <- base::list()
[09:29:14.611]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.611]     if (FALSE) {
[09:29:14.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.611]     }
[09:29:14.611]     ...future.result <- base::tryCatch({
[09:29:14.611]         base::withCallingHandlers({
[09:29:14.611]             ...future.value <- base::withVisible(base::local({
[09:29:14.611]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.611]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.611]                   ...future.globals.maxSize)) {
[09:29:14.611]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.611]                   on.exit(options(oopts), add = TRUE)
[09:29:14.611]                 }
[09:29:14.611]                 {
[09:29:14.611]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.611]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.611]                     USE.NAMES = FALSE)
[09:29:14.611]                   do.call(mapply, args = args)
[09:29:14.611]                 }
[09:29:14.611]             }))
[09:29:14.611]             future::FutureResult(value = ...future.value$value, 
[09:29:14.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.611]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.611]                     ...future.globalenv.names))
[09:29:14.611]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.611]         }, condition = base::local({
[09:29:14.611]             c <- base::c
[09:29:14.611]             inherits <- base::inherits
[09:29:14.611]             invokeRestart <- base::invokeRestart
[09:29:14.611]             length <- base::length
[09:29:14.611]             list <- base::list
[09:29:14.611]             seq.int <- base::seq.int
[09:29:14.611]             signalCondition <- base::signalCondition
[09:29:14.611]             sys.calls <- base::sys.calls
[09:29:14.611]             `[[` <- base::`[[`
[09:29:14.611]             `+` <- base::`+`
[09:29:14.611]             `<<-` <- base::`<<-`
[09:29:14.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.611]                   3L)]
[09:29:14.611]             }
[09:29:14.611]             function(cond) {
[09:29:14.611]                 is_error <- inherits(cond, "error")
[09:29:14.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.611]                   NULL)
[09:29:14.611]                 if (is_error) {
[09:29:14.611]                   sessionInformation <- function() {
[09:29:14.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.611]                       search = base::search(), system = base::Sys.info())
[09:29:14.611]                   }
[09:29:14.611]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.611]                     cond$call), session = sessionInformation(), 
[09:29:14.611]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.611]                   signalCondition(cond)
[09:29:14.611]                 }
[09:29:14.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.611]                 "immediateCondition"))) {
[09:29:14.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.611]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.611]                   if (TRUE && !signal) {
[09:29:14.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.611]                     {
[09:29:14.611]                       inherits <- base::inherits
[09:29:14.611]                       invokeRestart <- base::invokeRestart
[09:29:14.611]                       is.null <- base::is.null
[09:29:14.611]                       muffled <- FALSE
[09:29:14.611]                       if (inherits(cond, "message")) {
[09:29:14.611]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.611]                         if (muffled) 
[09:29:14.611]                           invokeRestart("muffleMessage")
[09:29:14.611]                       }
[09:29:14.611]                       else if (inherits(cond, "warning")) {
[09:29:14.611]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.611]                         if (muffled) 
[09:29:14.611]                           invokeRestart("muffleWarning")
[09:29:14.611]                       }
[09:29:14.611]                       else if (inherits(cond, "condition")) {
[09:29:14.611]                         if (!is.null(pattern)) {
[09:29:14.611]                           computeRestarts <- base::computeRestarts
[09:29:14.611]                           grepl <- base::grepl
[09:29:14.611]                           restarts <- computeRestarts(cond)
[09:29:14.611]                           for (restart in restarts) {
[09:29:14.611]                             name <- restart$name
[09:29:14.611]                             if (is.null(name)) 
[09:29:14.611]                               next
[09:29:14.611]                             if (!grepl(pattern, name)) 
[09:29:14.611]                               next
[09:29:14.611]                             invokeRestart(restart)
[09:29:14.611]                             muffled <- TRUE
[09:29:14.611]                             break
[09:29:14.611]                           }
[09:29:14.611]                         }
[09:29:14.611]                       }
[09:29:14.611]                       invisible(muffled)
[09:29:14.611]                     }
[09:29:14.611]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.611]                   }
[09:29:14.611]                 }
[09:29:14.611]                 else {
[09:29:14.611]                   if (TRUE) {
[09:29:14.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.611]                     {
[09:29:14.611]                       inherits <- base::inherits
[09:29:14.611]                       invokeRestart <- base::invokeRestart
[09:29:14.611]                       is.null <- base::is.null
[09:29:14.611]                       muffled <- FALSE
[09:29:14.611]                       if (inherits(cond, "message")) {
[09:29:14.611]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.611]                         if (muffled) 
[09:29:14.611]                           invokeRestart("muffleMessage")
[09:29:14.611]                       }
[09:29:14.611]                       else if (inherits(cond, "warning")) {
[09:29:14.611]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.611]                         if (muffled) 
[09:29:14.611]                           invokeRestart("muffleWarning")
[09:29:14.611]                       }
[09:29:14.611]                       else if (inherits(cond, "condition")) {
[09:29:14.611]                         if (!is.null(pattern)) {
[09:29:14.611]                           computeRestarts <- base::computeRestarts
[09:29:14.611]                           grepl <- base::grepl
[09:29:14.611]                           restarts <- computeRestarts(cond)
[09:29:14.611]                           for (restart in restarts) {
[09:29:14.611]                             name <- restart$name
[09:29:14.611]                             if (is.null(name)) 
[09:29:14.611]                               next
[09:29:14.611]                             if (!grepl(pattern, name)) 
[09:29:14.611]                               next
[09:29:14.611]                             invokeRestart(restart)
[09:29:14.611]                             muffled <- TRUE
[09:29:14.611]                             break
[09:29:14.611]                           }
[09:29:14.611]                         }
[09:29:14.611]                       }
[09:29:14.611]                       invisible(muffled)
[09:29:14.611]                     }
[09:29:14.611]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.611]                   }
[09:29:14.611]                 }
[09:29:14.611]             }
[09:29:14.611]         }))
[09:29:14.611]     }, error = function(ex) {
[09:29:14.611]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.611]                 ...future.rng), started = ...future.startTime, 
[09:29:14.611]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.611]             version = "1.8"), class = "FutureResult")
[09:29:14.611]     }, finally = {
[09:29:14.611]         if (!identical(...future.workdir, getwd())) 
[09:29:14.611]             setwd(...future.workdir)
[09:29:14.611]         {
[09:29:14.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.611]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.611]             }
[09:29:14.611]             base::options(...future.oldOptions)
[09:29:14.611]             if (.Platform$OS.type == "windows") {
[09:29:14.611]                 old_names <- names(...future.oldEnvVars)
[09:29:14.611]                 envs <- base::Sys.getenv()
[09:29:14.611]                 names <- names(envs)
[09:29:14.611]                 common <- intersect(names, old_names)
[09:29:14.611]                 added <- setdiff(names, old_names)
[09:29:14.611]                 removed <- setdiff(old_names, names)
[09:29:14.611]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.611]                   envs[common]]
[09:29:14.611]                 NAMES <- toupper(changed)
[09:29:14.611]                 args <- list()
[09:29:14.611]                 for (kk in seq_along(NAMES)) {
[09:29:14.611]                   name <- changed[[kk]]
[09:29:14.611]                   NAME <- NAMES[[kk]]
[09:29:14.611]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.611]                     next
[09:29:14.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.611]                 }
[09:29:14.611]                 NAMES <- toupper(added)
[09:29:14.611]                 for (kk in seq_along(NAMES)) {
[09:29:14.611]                   name <- added[[kk]]
[09:29:14.611]                   NAME <- NAMES[[kk]]
[09:29:14.611]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.611]                     next
[09:29:14.611]                   args[[name]] <- ""
[09:29:14.611]                 }
[09:29:14.611]                 NAMES <- toupper(removed)
[09:29:14.611]                 for (kk in seq_along(NAMES)) {
[09:29:14.611]                   name <- removed[[kk]]
[09:29:14.611]                   NAME <- NAMES[[kk]]
[09:29:14.611]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.611]                     next
[09:29:14.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.611]                 }
[09:29:14.611]                 if (length(args) > 0) 
[09:29:14.611]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.611]             }
[09:29:14.611]             else {
[09:29:14.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.611]             }
[09:29:14.611]             {
[09:29:14.611]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.611]                   0L) {
[09:29:14.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.611]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.611]                   base::options(opts)
[09:29:14.611]                 }
[09:29:14.611]                 {
[09:29:14.611]                   {
[09:29:14.611]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.611]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.611]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.611]                     NULL
[09:29:14.611]                   }
[09:29:14.611]                   options(future.plan = NULL)
[09:29:14.611]                   if (is.na(NA_character_)) 
[09:29:14.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.611]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.611]                     .init = FALSE)
[09:29:14.611]                 }
[09:29:14.611]             }
[09:29:14.611]         }
[09:29:14.611]     })
[09:29:14.611]     if (TRUE) {
[09:29:14.611]         base::sink(type = "output", split = FALSE)
[09:29:14.611]         if (TRUE) {
[09:29:14.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.611]         }
[09:29:14.611]         else {
[09:29:14.611]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.611]         }
[09:29:14.611]         base::close(...future.stdout)
[09:29:14.611]         ...future.stdout <- NULL
[09:29:14.611]     }
[09:29:14.611]     ...future.result$conditions <- ...future.conditions
[09:29:14.611]     ...future.result$finished <- base::Sys.time()
[09:29:14.611]     ...future.result
[09:29:14.611] }
[09:29:14.613] assign_globals() ...
[09:29:14.613] List of 5
[09:29:14.613]  $ ...future.FUN            :function (C, k)  
[09:29:14.613]  $ MoreArgs                 : NULL
[09:29:14.613]  $ ...future.elements_ii    :List of 2
[09:29:14.613]   ..$ :List of 1
[09:29:14.613]   .. ..$ : chr "A"
[09:29:14.613]   ..$ :List of 1
[09:29:14.613]   .. ..$ : int 5
[09:29:14.613]  $ ...future.seeds_ii       : NULL
[09:29:14.613]  $ ...future.globals.maxSize: NULL
[09:29:14.613]  - attr(*, "where")=List of 5
[09:29:14.613]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.613]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.613]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.613]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.613]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.613]  - attr(*, "resolved")= logi FALSE
[09:29:14.613]  - attr(*, "total_size")= num 3488
[09:29:14.613]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.613]  - attr(*, "already-done")= logi TRUE
[09:29:14.618] - reassign environment for ‘...future.FUN’
[09:29:14.618] - copied ‘...future.FUN’ to environment
[09:29:14.618] - copied ‘MoreArgs’ to environment
[09:29:14.618] - copied ‘...future.elements_ii’ to environment
[09:29:14.618] - copied ‘...future.seeds_ii’ to environment
[09:29:14.619] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.619] assign_globals() ... done
[09:29:14.619] plan(): Setting new future strategy stack:
[09:29:14.619] List of future strategies:
[09:29:14.619] 1. sequential:
[09:29:14.619]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.619]    - tweaked: FALSE
[09:29:14.619]    - call: NULL
[09:29:14.619] plan(): nbrOfWorkers() = 1
[09:29:14.620] plan(): Setting new future strategy stack:
[09:29:14.620] List of future strategies:
[09:29:14.620] 1. sequential:
[09:29:14.620]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.620]    - tweaked: FALSE
[09:29:14.620]    - call: plan(strategy)
[09:29:14.621] plan(): nbrOfWorkers() = 1
[09:29:14.621] SequentialFuture started (and completed)
[09:29:14.621] - Launch lazy future ... done
[09:29:14.621] run() for ‘SequentialFuture’ ... done
[09:29:14.621] Created future:
[09:29:14.621] SequentialFuture:
[09:29:14.621] Label: ‘future_mapply-2’
[09:29:14.621] Expression:
[09:29:14.621] {
[09:29:14.621]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.621]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.621]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.621]         on.exit(options(oopts), add = TRUE)
[09:29:14.621]     }
[09:29:14.621]     {
[09:29:14.621]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.621]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.621]         do.call(mapply, args = args)
[09:29:14.621]     }
[09:29:14.621] }
[09:29:14.621] Lazy evaluation: FALSE
[09:29:14.621] Asynchronous evaluation: FALSE
[09:29:14.621] Local evaluation: TRUE
[09:29:14.621] Environment: R_GlobalEnv
[09:29:14.621] Capture standard output: TRUE
[09:29:14.621] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.621] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.621] Packages: <none>
[09:29:14.621] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.621] Resolved: TRUE
[09:29:14.621] Value: 112 bytes of class ‘list’
[09:29:14.621] Early signaling: FALSE
[09:29:14.621] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.621] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.622] Chunk #2 of 3 ... DONE
[09:29:14.622] Chunk #3 of 3 ...
[09:29:14.624]  - Finding globals in '...' for chunk #3 ...
[09:29:14.624] getGlobalsAndPackages() ...
[09:29:14.624] Searching for globals...
[09:29:14.624] 
[09:29:14.624] Searching for globals ... DONE
[09:29:14.624] - globals: [0] <none>
[09:29:14.624] getGlobalsAndPackages() ... DONE
[09:29:14.625]    + additional globals found: [n=0] 
[09:29:14.625]    + additional namespaces needed: [n=0] 
[09:29:14.625]  - Finding globals in '...' for chunk #3 ... DONE
[09:29:14.625]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[09:29:14.625]  - seeds: <none>
[09:29:14.625]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.625] getGlobalsAndPackages() ...
[09:29:14.625] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.625] Resolving globals: FALSE
[09:29:14.626] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:14.626] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.626] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.627] 
[09:29:14.627] getGlobalsAndPackages() ... DONE
[09:29:14.627] run() for ‘Future’ ...
[09:29:14.627] - state: ‘created’
[09:29:14.627] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.627] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.627] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.628]   - Field: ‘label’
[09:29:14.628]   - Field: ‘local’
[09:29:14.628]   - Field: ‘owner’
[09:29:14.628]   - Field: ‘envir’
[09:29:14.628]   - Field: ‘packages’
[09:29:14.628]   - Field: ‘gc’
[09:29:14.628]   - Field: ‘conditions’
[09:29:14.628]   - Field: ‘expr’
[09:29:14.628]   - Field: ‘uuid’
[09:29:14.628]   - Field: ‘seed’
[09:29:14.628]   - Field: ‘version’
[09:29:14.629]   - Field: ‘result’
[09:29:14.629]   - Field: ‘asynchronous’
[09:29:14.629]   - Field: ‘calls’
[09:29:14.629]   - Field: ‘globals’
[09:29:14.629]   - Field: ‘stdout’
[09:29:14.629]   - Field: ‘earlySignal’
[09:29:14.629]   - Field: ‘lazy’
[09:29:14.629]   - Field: ‘state’
[09:29:14.629] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.629] - Launch lazy future ...
[09:29:14.630] Packages needed by the future expression (n = 0): <none>
[09:29:14.630] Packages needed by future strategies (n = 0): <none>
[09:29:14.630] {
[09:29:14.630]     {
[09:29:14.630]         {
[09:29:14.630]             ...future.startTime <- base::Sys.time()
[09:29:14.630]             {
[09:29:14.630]                 {
[09:29:14.630]                   {
[09:29:14.630]                     base::local({
[09:29:14.630]                       has_future <- base::requireNamespace("future", 
[09:29:14.630]                         quietly = TRUE)
[09:29:14.630]                       if (has_future) {
[09:29:14.630]                         ns <- base::getNamespace("future")
[09:29:14.630]                         version <- ns[[".package"]][["version"]]
[09:29:14.630]                         if (is.null(version)) 
[09:29:14.630]                           version <- utils::packageVersion("future")
[09:29:14.630]                       }
[09:29:14.630]                       else {
[09:29:14.630]                         version <- NULL
[09:29:14.630]                       }
[09:29:14.630]                       if (!has_future || version < "1.8.0") {
[09:29:14.630]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.630]                           "", base::R.version$version.string), 
[09:29:14.630]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.630]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.630]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.630]                             "release", "version")], collapse = " "), 
[09:29:14.630]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.630]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.630]                           info)
[09:29:14.630]                         info <- base::paste(info, collapse = "; ")
[09:29:14.630]                         if (!has_future) {
[09:29:14.630]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.630]                             info)
[09:29:14.630]                         }
[09:29:14.630]                         else {
[09:29:14.630]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.630]                             info, version)
[09:29:14.630]                         }
[09:29:14.630]                         base::stop(msg)
[09:29:14.630]                       }
[09:29:14.630]                     })
[09:29:14.630]                   }
[09:29:14.630]                   ...future.strategy.old <- future::plan("list")
[09:29:14.630]                   options(future.plan = NULL)
[09:29:14.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.630]                 }
[09:29:14.630]                 ...future.workdir <- getwd()
[09:29:14.630]             }
[09:29:14.630]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.630]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.630]         }
[09:29:14.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.630]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[09:29:14.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.630]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.630]             base::names(...future.oldOptions))
[09:29:14.630]     }
[09:29:14.630]     if (FALSE) {
[09:29:14.630]     }
[09:29:14.630]     else {
[09:29:14.630]         if (TRUE) {
[09:29:14.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.630]                 open = "w")
[09:29:14.630]         }
[09:29:14.630]         else {
[09:29:14.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.630]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.630]         }
[09:29:14.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.630]             base::sink(type = "output", split = FALSE)
[09:29:14.630]             base::close(...future.stdout)
[09:29:14.630]         }, add = TRUE)
[09:29:14.630]     }
[09:29:14.630]     ...future.frame <- base::sys.nframe()
[09:29:14.630]     ...future.conditions <- base::list()
[09:29:14.630]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.630]     if (FALSE) {
[09:29:14.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.630]     }
[09:29:14.630]     ...future.result <- base::tryCatch({
[09:29:14.630]         base::withCallingHandlers({
[09:29:14.630]             ...future.value <- base::withVisible(base::local({
[09:29:14.630]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.630]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.630]                   ...future.globals.maxSize)) {
[09:29:14.630]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.630]                   on.exit(options(oopts), add = TRUE)
[09:29:14.630]                 }
[09:29:14.630]                 {
[09:29:14.630]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.630]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.630]                     USE.NAMES = FALSE)
[09:29:14.630]                   do.call(mapply, args = args)
[09:29:14.630]                 }
[09:29:14.630]             }))
[09:29:14.630]             future::FutureResult(value = ...future.value$value, 
[09:29:14.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.630]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.630]                     ...future.globalenv.names))
[09:29:14.630]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.630]         }, condition = base::local({
[09:29:14.630]             c <- base::c
[09:29:14.630]             inherits <- base::inherits
[09:29:14.630]             invokeRestart <- base::invokeRestart
[09:29:14.630]             length <- base::length
[09:29:14.630]             list <- base::list
[09:29:14.630]             seq.int <- base::seq.int
[09:29:14.630]             signalCondition <- base::signalCondition
[09:29:14.630]             sys.calls <- base::sys.calls
[09:29:14.630]             `[[` <- base::`[[`
[09:29:14.630]             `+` <- base::`+`
[09:29:14.630]             `<<-` <- base::`<<-`
[09:29:14.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.630]                   3L)]
[09:29:14.630]             }
[09:29:14.630]             function(cond) {
[09:29:14.630]                 is_error <- inherits(cond, "error")
[09:29:14.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.630]                   NULL)
[09:29:14.630]                 if (is_error) {
[09:29:14.630]                   sessionInformation <- function() {
[09:29:14.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.630]                       search = base::search(), system = base::Sys.info())
[09:29:14.630]                   }
[09:29:14.630]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.630]                     cond$call), session = sessionInformation(), 
[09:29:14.630]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.630]                   signalCondition(cond)
[09:29:14.630]                 }
[09:29:14.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.630]                 "immediateCondition"))) {
[09:29:14.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.630]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.630]                   if (TRUE && !signal) {
[09:29:14.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.630]                     {
[09:29:14.630]                       inherits <- base::inherits
[09:29:14.630]                       invokeRestart <- base::invokeRestart
[09:29:14.630]                       is.null <- base::is.null
[09:29:14.630]                       muffled <- FALSE
[09:29:14.630]                       if (inherits(cond, "message")) {
[09:29:14.630]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.630]                         if (muffled) 
[09:29:14.630]                           invokeRestart("muffleMessage")
[09:29:14.630]                       }
[09:29:14.630]                       else if (inherits(cond, "warning")) {
[09:29:14.630]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.630]                         if (muffled) 
[09:29:14.630]                           invokeRestart("muffleWarning")
[09:29:14.630]                       }
[09:29:14.630]                       else if (inherits(cond, "condition")) {
[09:29:14.630]                         if (!is.null(pattern)) {
[09:29:14.630]                           computeRestarts <- base::computeRestarts
[09:29:14.630]                           grepl <- base::grepl
[09:29:14.630]                           restarts <- computeRestarts(cond)
[09:29:14.630]                           for (restart in restarts) {
[09:29:14.630]                             name <- restart$name
[09:29:14.630]                             if (is.null(name)) 
[09:29:14.630]                               next
[09:29:14.630]                             if (!grepl(pattern, name)) 
[09:29:14.630]                               next
[09:29:14.630]                             invokeRestart(restart)
[09:29:14.630]                             muffled <- TRUE
[09:29:14.630]                             break
[09:29:14.630]                           }
[09:29:14.630]                         }
[09:29:14.630]                       }
[09:29:14.630]                       invisible(muffled)
[09:29:14.630]                     }
[09:29:14.630]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.630]                   }
[09:29:14.630]                 }
[09:29:14.630]                 else {
[09:29:14.630]                   if (TRUE) {
[09:29:14.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.630]                     {
[09:29:14.630]                       inherits <- base::inherits
[09:29:14.630]                       invokeRestart <- base::invokeRestart
[09:29:14.630]                       is.null <- base::is.null
[09:29:14.630]                       muffled <- FALSE
[09:29:14.630]                       if (inherits(cond, "message")) {
[09:29:14.630]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.630]                         if (muffled) 
[09:29:14.630]                           invokeRestart("muffleMessage")
[09:29:14.630]                       }
[09:29:14.630]                       else if (inherits(cond, "warning")) {
[09:29:14.630]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.630]                         if (muffled) 
[09:29:14.630]                           invokeRestart("muffleWarning")
[09:29:14.630]                       }
[09:29:14.630]                       else if (inherits(cond, "condition")) {
[09:29:14.630]                         if (!is.null(pattern)) {
[09:29:14.630]                           computeRestarts <- base::computeRestarts
[09:29:14.630]                           grepl <- base::grepl
[09:29:14.630]                           restarts <- computeRestarts(cond)
[09:29:14.630]                           for (restart in restarts) {
[09:29:14.630]                             name <- restart$name
[09:29:14.630]                             if (is.null(name)) 
[09:29:14.630]                               next
[09:29:14.630]                             if (!grepl(pattern, name)) 
[09:29:14.630]                               next
[09:29:14.630]                             invokeRestart(restart)
[09:29:14.630]                             muffled <- TRUE
[09:29:14.630]                             break
[09:29:14.630]                           }
[09:29:14.630]                         }
[09:29:14.630]                       }
[09:29:14.630]                       invisible(muffled)
[09:29:14.630]                     }
[09:29:14.630]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.630]                   }
[09:29:14.630]                 }
[09:29:14.630]             }
[09:29:14.630]         }))
[09:29:14.630]     }, error = function(ex) {
[09:29:14.630]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.630]                 ...future.rng), started = ...future.startTime, 
[09:29:14.630]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.630]             version = "1.8"), class = "FutureResult")
[09:29:14.630]     }, finally = {
[09:29:14.630]         if (!identical(...future.workdir, getwd())) 
[09:29:14.630]             setwd(...future.workdir)
[09:29:14.630]         {
[09:29:14.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.630]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.630]             }
[09:29:14.630]             base::options(...future.oldOptions)
[09:29:14.630]             if (.Platform$OS.type == "windows") {
[09:29:14.630]                 old_names <- names(...future.oldEnvVars)
[09:29:14.630]                 envs <- base::Sys.getenv()
[09:29:14.630]                 names <- names(envs)
[09:29:14.630]                 common <- intersect(names, old_names)
[09:29:14.630]                 added <- setdiff(names, old_names)
[09:29:14.630]                 removed <- setdiff(old_names, names)
[09:29:14.630]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.630]                   envs[common]]
[09:29:14.630]                 NAMES <- toupper(changed)
[09:29:14.630]                 args <- list()
[09:29:14.630]                 for (kk in seq_along(NAMES)) {
[09:29:14.630]                   name <- changed[[kk]]
[09:29:14.630]                   NAME <- NAMES[[kk]]
[09:29:14.630]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.630]                     next
[09:29:14.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.630]                 }
[09:29:14.630]                 NAMES <- toupper(added)
[09:29:14.630]                 for (kk in seq_along(NAMES)) {
[09:29:14.630]                   name <- added[[kk]]
[09:29:14.630]                   NAME <- NAMES[[kk]]
[09:29:14.630]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.630]                     next
[09:29:14.630]                   args[[name]] <- ""
[09:29:14.630]                 }
[09:29:14.630]                 NAMES <- toupper(removed)
[09:29:14.630]                 for (kk in seq_along(NAMES)) {
[09:29:14.630]                   name <- removed[[kk]]
[09:29:14.630]                   NAME <- NAMES[[kk]]
[09:29:14.630]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.630]                     next
[09:29:14.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.630]                 }
[09:29:14.630]                 if (length(args) > 0) 
[09:29:14.630]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.630]             }
[09:29:14.630]             else {
[09:29:14.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.630]             }
[09:29:14.630]             {
[09:29:14.630]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.630]                   0L) {
[09:29:14.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.630]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.630]                   base::options(opts)
[09:29:14.630]                 }
[09:29:14.630]                 {
[09:29:14.630]                   {
[09:29:14.630]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.630]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.630]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.630]                     NULL
[09:29:14.630]                   }
[09:29:14.630]                   options(future.plan = NULL)
[09:29:14.630]                   if (is.na(NA_character_)) 
[09:29:14.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.630]                     .init = FALSE)
[09:29:14.630]                 }
[09:29:14.630]             }
[09:29:14.630]         }
[09:29:14.630]     })
[09:29:14.630]     if (TRUE) {
[09:29:14.630]         base::sink(type = "output", split = FALSE)
[09:29:14.630]         if (TRUE) {
[09:29:14.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.630]         }
[09:29:14.630]         else {
[09:29:14.630]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.630]         }
[09:29:14.630]         base::close(...future.stdout)
[09:29:14.630]         ...future.stdout <- NULL
[09:29:14.630]     }
[09:29:14.630]     ...future.result$conditions <- ...future.conditions
[09:29:14.630]     ...future.result$finished <- base::Sys.time()
[09:29:14.630]     ...future.result
[09:29:14.630] }
[09:29:14.632] assign_globals() ...
[09:29:14.632] List of 5
[09:29:14.632]  $ ...future.FUN            :function (C, k)  
[09:29:14.632]  $ MoreArgs                 : NULL
[09:29:14.632]  $ ...future.elements_ii    :List of 2
[09:29:14.632]   ..$ :List of 2
[09:29:14.632]   .. ..$ : chr "D"
[09:29:14.632]   .. ..$ : chr "B"
[09:29:14.632]   ..$ :List of 2
[09:29:14.632]   .. ..$ : int 2
[09:29:14.632]   .. ..$ : int 4
[09:29:14.632]  $ ...future.seeds_ii       : NULL
[09:29:14.632]  $ ...future.globals.maxSize: NULL
[09:29:14.632]  - attr(*, "where")=List of 5
[09:29:14.632]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.632]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.632]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.632]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.632]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.632]  - attr(*, "resolved")= logi FALSE
[09:29:14.632]  - attr(*, "total_size")= num 3656
[09:29:14.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.632]  - attr(*, "already-done")= logi TRUE
[09:29:14.637] - reassign environment for ‘...future.FUN’
[09:29:14.637] - copied ‘...future.FUN’ to environment
[09:29:14.637] - copied ‘MoreArgs’ to environment
[09:29:14.637] - copied ‘...future.elements_ii’ to environment
[09:29:14.637] - copied ‘...future.seeds_ii’ to environment
[09:29:14.637] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.637] assign_globals() ... done
[09:29:14.638] plan(): Setting new future strategy stack:
[09:29:14.638] List of future strategies:
[09:29:14.638] 1. sequential:
[09:29:14.638]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.638]    - tweaked: FALSE
[09:29:14.638]    - call: NULL
[09:29:14.638] plan(): nbrOfWorkers() = 1
[09:29:14.639] plan(): Setting new future strategy stack:
[09:29:14.639] List of future strategies:
[09:29:14.639] 1. sequential:
[09:29:14.639]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.639]    - tweaked: FALSE
[09:29:14.639]    - call: plan(strategy)
[09:29:14.640] plan(): nbrOfWorkers() = 1
[09:29:14.640] SequentialFuture started (and completed)
[09:29:14.640] - Launch lazy future ... done
[09:29:14.640] run() for ‘SequentialFuture’ ... done
[09:29:14.640] Created future:
[09:29:14.640] SequentialFuture:
[09:29:14.640] Label: ‘future_mapply-3’
[09:29:14.640] Expression:
[09:29:14.640] {
[09:29:14.640]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.640]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.640]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.640]         on.exit(options(oopts), add = TRUE)
[09:29:14.640]     }
[09:29:14.640]     {
[09:29:14.640]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.640]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.640]         do.call(mapply, args = args)
[09:29:14.640]     }
[09:29:14.640] }
[09:29:14.640] Lazy evaluation: FALSE
[09:29:14.640] Asynchronous evaluation: FALSE
[09:29:14.640] Local evaluation: TRUE
[09:29:14.640] Environment: R_GlobalEnv
[09:29:14.640] Capture standard output: TRUE
[09:29:14.640] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.640] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.640] Packages: <none>
[09:29:14.640] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.640] Resolved: TRUE
[09:29:14.640] Value: 224 bytes of class ‘list’
[09:29:14.640] Early signaling: FALSE
[09:29:14.640] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.640] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.641] Chunk #3 of 3 ... DONE
[09:29:14.641] Launching 3 futures (chunks) ... DONE
[09:29:14.641] Resolving 3 futures (chunks) ...
[09:29:14.641] resolve() on list ...
[09:29:14.641]  recursive: 0
[09:29:14.641]  length: 3
[09:29:14.642] 
[09:29:14.642] resolved() for ‘SequentialFuture’ ...
[09:29:14.642] - state: ‘finished’
[09:29:14.642] - run: TRUE
[09:29:14.642] - result: ‘FutureResult’
[09:29:14.642] resolved() for ‘SequentialFuture’ ... done
[09:29:14.642] Future #1
[09:29:14.642] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.642] - nx: 3
[09:29:14.642] - relay: TRUE
[09:29:14.643] - stdout: TRUE
[09:29:14.643] - signal: TRUE
[09:29:14.643] - resignal: FALSE
[09:29:14.643] - force: TRUE
[09:29:14.643] - relayed: [n=3] FALSE, FALSE, FALSE
[09:29:14.643] - queued futures: [n=3] FALSE, FALSE, FALSE
[09:29:14.643]  - until=1
[09:29:14.643]  - relaying element #1
[09:29:14.643] - relayed: [n=3] TRUE, FALSE, FALSE
[09:29:14.643] - queued futures: [n=3] TRUE, FALSE, FALSE
[09:29:14.643] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.644]  length: 2 (resolved future 1)
[09:29:14.644] resolved() for ‘SequentialFuture’ ...
[09:29:14.644] - state: ‘finished’
[09:29:14.644] - run: TRUE
[09:29:14.644] - result: ‘FutureResult’
[09:29:14.644] resolved() for ‘SequentialFuture’ ... done
[09:29:14.644] Future #2
[09:29:14.644] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:29:14.644] - nx: 3
[09:29:14.645] - relay: TRUE
[09:29:14.645] - stdout: TRUE
[09:29:14.645] - signal: TRUE
[09:29:14.645] - resignal: FALSE
[09:29:14.645] - force: TRUE
[09:29:14.645] - relayed: [n=3] TRUE, FALSE, FALSE
[09:29:14.645] - queued futures: [n=3] TRUE, FALSE, FALSE
[09:29:14.645]  - until=2
[09:29:14.645]  - relaying element #2
[09:29:14.645] - relayed: [n=3] TRUE, TRUE, FALSE
[09:29:14.645] - queued futures: [n=3] TRUE, TRUE, FALSE
[09:29:14.646] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:29:14.646]  length: 1 (resolved future 2)
[09:29:14.646] resolved() for ‘SequentialFuture’ ...
[09:29:14.646] - state: ‘finished’
[09:29:14.646] - run: TRUE
[09:29:14.646] - result: ‘FutureResult’
[09:29:14.646] resolved() for ‘SequentialFuture’ ... done
[09:29:14.646] Future #3
[09:29:14.646] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:29:14.646] - nx: 3
[09:29:14.646] - relay: TRUE
[09:29:14.647] - stdout: TRUE
[09:29:14.647] - signal: TRUE
[09:29:14.647] - resignal: FALSE
[09:29:14.647] - force: TRUE
[09:29:14.647] - relayed: [n=3] TRUE, TRUE, FALSE
[09:29:14.647] - queued futures: [n=3] TRUE, TRUE, FALSE
[09:29:14.647]  - until=3
[09:29:14.647]  - relaying element #3
[09:29:14.647] - relayed: [n=3] TRUE, TRUE, TRUE
[09:29:14.647] - queued futures: [n=3] TRUE, TRUE, TRUE
[09:29:14.647] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:29:14.648]  length: 0 (resolved future 3)
[09:29:14.648] Relaying remaining futures
[09:29:14.649] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.649] - nx: 3
[09:29:14.649] - relay: TRUE
[09:29:14.649] - stdout: TRUE
[09:29:14.649] - signal: TRUE
[09:29:14.649] - resignal: FALSE
[09:29:14.650] - force: TRUE
[09:29:14.650] - relayed: [n=3] TRUE, TRUE, TRUE
[09:29:14.650] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[09:29:14.650] - relayed: [n=3] TRUE, TRUE, TRUE
[09:29:14.650] - queued futures: [n=3] TRUE, TRUE, TRUE
[09:29:14.650] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.650] resolve() on list ... DONE
[09:29:14.650]  - Number of value chunks collected: 3
[09:29:14.650] Resolving 3 futures (chunks) ... DONE
[09:29:14.651] Reducing values from 3 chunks ...
[09:29:14.651]  - Number of values collected after concatenation: 5
[09:29:14.651]  - Number of values expected: 5
[09:29:14.651] Reverse index remapping (attribute 'ordering'): [n = 5] 3, 5, 1, 4, 2
[09:29:14.651] Reducing values from 3 chunks ... DONE
[09:29:14.651] future_mapply() ... DONE
[09:29:14.651] future_mapply() ...
[09:29:14.651] Number of chunks: 1
[09:29:14.652] getGlobalsAndPackagesXApply() ...
[09:29:14.652]  - future.globals: TRUE
[09:29:14.652] getGlobalsAndPackages() ...
[09:29:14.652] Searching for globals...
[09:29:14.653] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:14.653] Searching for globals ... DONE
[09:29:14.653] Resolving globals: FALSE
[09:29:14.654] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:14.654] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:14.654] - globals: [1] ‘FUN’
[09:29:14.654] 
[09:29:14.654] getGlobalsAndPackages() ... DONE
[09:29:14.654]  - globals found/used: [n=1] ‘FUN’
[09:29:14.654]  - needed namespaces: [n=0] 
[09:29:14.654] Finding globals ... DONE
[09:29:14.655] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.655] List of 2
[09:29:14.655]  $ ...future.FUN:function (C, k)  
[09:29:14.655]  $ MoreArgs     : list()
[09:29:14.655]  - attr(*, "where")=List of 2
[09:29:14.655]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.655]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.655]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.655]  - attr(*, "resolved")= logi FALSE
[09:29:14.655]  - attr(*, "total_size")= num NA
[09:29:14.657] Packages to be attached in all futures: [n=0] 
[09:29:14.657] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.657] Number of futures (= number of chunks): 1
[09:29:14.657] Launching 1 futures (chunks) ...
[09:29:14.658] Chunk #1 of 1 ...
[09:29:14.658]  - Finding globals in '...' for chunk #1 ...
[09:29:14.658] getGlobalsAndPackages() ...
[09:29:14.658] Searching for globals...
[09:29:14.658] 
[09:29:14.658] Searching for globals ... DONE
[09:29:14.658] - globals: [0] <none>
[09:29:14.658] getGlobalsAndPackages() ... DONE
[09:29:14.658]    + additional globals found: [n=0] 
[09:29:14.659]    + additional namespaces needed: [n=0] 
[09:29:14.659]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.659]  - seeds: <none>
[09:29:14.659]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.659] getGlobalsAndPackages() ...
[09:29:14.659] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.659] Resolving globals: FALSE
[09:29:14.660] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[09:29:14.660] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:14.660] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.660] 
[09:29:14.660] getGlobalsAndPackages() ... DONE
[09:29:14.661] run() for ‘Future’ ...
[09:29:14.661] - state: ‘created’
[09:29:14.661] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.661] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.661] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.661]   - Field: ‘label’
[09:29:14.661]   - Field: ‘local’
[09:29:14.661]   - Field: ‘owner’
[09:29:14.662]   - Field: ‘envir’
[09:29:14.662]   - Field: ‘packages’
[09:29:14.662]   - Field: ‘gc’
[09:29:14.662]   - Field: ‘conditions’
[09:29:14.662]   - Field: ‘expr’
[09:29:14.662]   - Field: ‘uuid’
[09:29:14.662]   - Field: ‘seed’
[09:29:14.662]   - Field: ‘version’
[09:29:14.662]   - Field: ‘result’
[09:29:14.662]   - Field: ‘asynchronous’
[09:29:14.662]   - Field: ‘calls’
[09:29:14.663]   - Field: ‘globals’
[09:29:14.663]   - Field: ‘stdout’
[09:29:14.663]   - Field: ‘earlySignal’
[09:29:14.663]   - Field: ‘lazy’
[09:29:14.663]   - Field: ‘state’
[09:29:14.663] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.663] - Launch lazy future ...
[09:29:14.663] Packages needed by the future expression (n = 0): <none>
[09:29:14.663] Packages needed by future strategies (n = 0): <none>
[09:29:14.664] {
[09:29:14.664]     {
[09:29:14.664]         {
[09:29:14.664]             ...future.startTime <- base::Sys.time()
[09:29:14.664]             {
[09:29:14.664]                 {
[09:29:14.664]                   {
[09:29:14.664]                     base::local({
[09:29:14.664]                       has_future <- base::requireNamespace("future", 
[09:29:14.664]                         quietly = TRUE)
[09:29:14.664]                       if (has_future) {
[09:29:14.664]                         ns <- base::getNamespace("future")
[09:29:14.664]                         version <- ns[[".package"]][["version"]]
[09:29:14.664]                         if (is.null(version)) 
[09:29:14.664]                           version <- utils::packageVersion("future")
[09:29:14.664]                       }
[09:29:14.664]                       else {
[09:29:14.664]                         version <- NULL
[09:29:14.664]                       }
[09:29:14.664]                       if (!has_future || version < "1.8.0") {
[09:29:14.664]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.664]                           "", base::R.version$version.string), 
[09:29:14.664]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.664]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.664]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.664]                             "release", "version")], collapse = " "), 
[09:29:14.664]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.664]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.664]                           info)
[09:29:14.664]                         info <- base::paste(info, collapse = "; ")
[09:29:14.664]                         if (!has_future) {
[09:29:14.664]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.664]                             info)
[09:29:14.664]                         }
[09:29:14.664]                         else {
[09:29:14.664]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.664]                             info, version)
[09:29:14.664]                         }
[09:29:14.664]                         base::stop(msg)
[09:29:14.664]                       }
[09:29:14.664]                     })
[09:29:14.664]                   }
[09:29:14.664]                   ...future.strategy.old <- future::plan("list")
[09:29:14.664]                   options(future.plan = NULL)
[09:29:14.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.664]                 }
[09:29:14.664]                 ...future.workdir <- getwd()
[09:29:14.664]             }
[09:29:14.664]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.664]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.664]         }
[09:29:14.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.664]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.664]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.664]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.664]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.664]             base::names(...future.oldOptions))
[09:29:14.664]     }
[09:29:14.664]     if (FALSE) {
[09:29:14.664]     }
[09:29:14.664]     else {
[09:29:14.664]         if (TRUE) {
[09:29:14.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.664]                 open = "w")
[09:29:14.664]         }
[09:29:14.664]         else {
[09:29:14.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.664]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.664]         }
[09:29:14.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.664]             base::sink(type = "output", split = FALSE)
[09:29:14.664]             base::close(...future.stdout)
[09:29:14.664]         }, add = TRUE)
[09:29:14.664]     }
[09:29:14.664]     ...future.frame <- base::sys.nframe()
[09:29:14.664]     ...future.conditions <- base::list()
[09:29:14.664]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.664]     if (FALSE) {
[09:29:14.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.664]     }
[09:29:14.664]     ...future.result <- base::tryCatch({
[09:29:14.664]         base::withCallingHandlers({
[09:29:14.664]             ...future.value <- base::withVisible(base::local({
[09:29:14.664]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.664]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.664]                   ...future.globals.maxSize)) {
[09:29:14.664]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.664]                   on.exit(options(oopts), add = TRUE)
[09:29:14.664]                 }
[09:29:14.664]                 {
[09:29:14.664]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.664]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.664]                     USE.NAMES = FALSE)
[09:29:14.664]                   do.call(mapply, args = args)
[09:29:14.664]                 }
[09:29:14.664]             }))
[09:29:14.664]             future::FutureResult(value = ...future.value$value, 
[09:29:14.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.664]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.664]                     ...future.globalenv.names))
[09:29:14.664]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.664]         }, condition = base::local({
[09:29:14.664]             c <- base::c
[09:29:14.664]             inherits <- base::inherits
[09:29:14.664]             invokeRestart <- base::invokeRestart
[09:29:14.664]             length <- base::length
[09:29:14.664]             list <- base::list
[09:29:14.664]             seq.int <- base::seq.int
[09:29:14.664]             signalCondition <- base::signalCondition
[09:29:14.664]             sys.calls <- base::sys.calls
[09:29:14.664]             `[[` <- base::`[[`
[09:29:14.664]             `+` <- base::`+`
[09:29:14.664]             `<<-` <- base::`<<-`
[09:29:14.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.664]                   3L)]
[09:29:14.664]             }
[09:29:14.664]             function(cond) {
[09:29:14.664]                 is_error <- inherits(cond, "error")
[09:29:14.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.664]                   NULL)
[09:29:14.664]                 if (is_error) {
[09:29:14.664]                   sessionInformation <- function() {
[09:29:14.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.664]                       search = base::search(), system = base::Sys.info())
[09:29:14.664]                   }
[09:29:14.664]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.664]                     cond$call), session = sessionInformation(), 
[09:29:14.664]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.664]                   signalCondition(cond)
[09:29:14.664]                 }
[09:29:14.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.664]                 "immediateCondition"))) {
[09:29:14.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.664]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.664]                   if (TRUE && !signal) {
[09:29:14.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.664]                     {
[09:29:14.664]                       inherits <- base::inherits
[09:29:14.664]                       invokeRestart <- base::invokeRestart
[09:29:14.664]                       is.null <- base::is.null
[09:29:14.664]                       muffled <- FALSE
[09:29:14.664]                       if (inherits(cond, "message")) {
[09:29:14.664]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.664]                         if (muffled) 
[09:29:14.664]                           invokeRestart("muffleMessage")
[09:29:14.664]                       }
[09:29:14.664]                       else if (inherits(cond, "warning")) {
[09:29:14.664]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.664]                         if (muffled) 
[09:29:14.664]                           invokeRestart("muffleWarning")
[09:29:14.664]                       }
[09:29:14.664]                       else if (inherits(cond, "condition")) {
[09:29:14.664]                         if (!is.null(pattern)) {
[09:29:14.664]                           computeRestarts <- base::computeRestarts
[09:29:14.664]                           grepl <- base::grepl
[09:29:14.664]                           restarts <- computeRestarts(cond)
[09:29:14.664]                           for (restart in restarts) {
[09:29:14.664]                             name <- restart$name
[09:29:14.664]                             if (is.null(name)) 
[09:29:14.664]                               next
[09:29:14.664]                             if (!grepl(pattern, name)) 
[09:29:14.664]                               next
[09:29:14.664]                             invokeRestart(restart)
[09:29:14.664]                             muffled <- TRUE
[09:29:14.664]                             break
[09:29:14.664]                           }
[09:29:14.664]                         }
[09:29:14.664]                       }
[09:29:14.664]                       invisible(muffled)
[09:29:14.664]                     }
[09:29:14.664]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.664]                   }
[09:29:14.664]                 }
[09:29:14.664]                 else {
[09:29:14.664]                   if (TRUE) {
[09:29:14.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.664]                     {
[09:29:14.664]                       inherits <- base::inherits
[09:29:14.664]                       invokeRestart <- base::invokeRestart
[09:29:14.664]                       is.null <- base::is.null
[09:29:14.664]                       muffled <- FALSE
[09:29:14.664]                       if (inherits(cond, "message")) {
[09:29:14.664]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.664]                         if (muffled) 
[09:29:14.664]                           invokeRestart("muffleMessage")
[09:29:14.664]                       }
[09:29:14.664]                       else if (inherits(cond, "warning")) {
[09:29:14.664]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.664]                         if (muffled) 
[09:29:14.664]                           invokeRestart("muffleWarning")
[09:29:14.664]                       }
[09:29:14.664]                       else if (inherits(cond, "condition")) {
[09:29:14.664]                         if (!is.null(pattern)) {
[09:29:14.664]                           computeRestarts <- base::computeRestarts
[09:29:14.664]                           grepl <- base::grepl
[09:29:14.664]                           restarts <- computeRestarts(cond)
[09:29:14.664]                           for (restart in restarts) {
[09:29:14.664]                             name <- restart$name
[09:29:14.664]                             if (is.null(name)) 
[09:29:14.664]                               next
[09:29:14.664]                             if (!grepl(pattern, name)) 
[09:29:14.664]                               next
[09:29:14.664]                             invokeRestart(restart)
[09:29:14.664]                             muffled <- TRUE
[09:29:14.664]                             break
[09:29:14.664]                           }
[09:29:14.664]                         }
[09:29:14.664]                       }
[09:29:14.664]                       invisible(muffled)
[09:29:14.664]                     }
[09:29:14.664]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.664]                   }
[09:29:14.664]                 }
[09:29:14.664]             }
[09:29:14.664]         }))
[09:29:14.664]     }, error = function(ex) {
[09:29:14.664]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.664]                 ...future.rng), started = ...future.startTime, 
[09:29:14.664]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.664]             version = "1.8"), class = "FutureResult")
[09:29:14.664]     }, finally = {
[09:29:14.664]         if (!identical(...future.workdir, getwd())) 
[09:29:14.664]             setwd(...future.workdir)
[09:29:14.664]         {
[09:29:14.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.664]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.664]             }
[09:29:14.664]             base::options(...future.oldOptions)
[09:29:14.664]             if (.Platform$OS.type == "windows") {
[09:29:14.664]                 old_names <- names(...future.oldEnvVars)
[09:29:14.664]                 envs <- base::Sys.getenv()
[09:29:14.664]                 names <- names(envs)
[09:29:14.664]                 common <- intersect(names, old_names)
[09:29:14.664]                 added <- setdiff(names, old_names)
[09:29:14.664]                 removed <- setdiff(old_names, names)
[09:29:14.664]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.664]                   envs[common]]
[09:29:14.664]                 NAMES <- toupper(changed)
[09:29:14.664]                 args <- list()
[09:29:14.664]                 for (kk in seq_along(NAMES)) {
[09:29:14.664]                   name <- changed[[kk]]
[09:29:14.664]                   NAME <- NAMES[[kk]]
[09:29:14.664]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.664]                     next
[09:29:14.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.664]                 }
[09:29:14.664]                 NAMES <- toupper(added)
[09:29:14.664]                 for (kk in seq_along(NAMES)) {
[09:29:14.664]                   name <- added[[kk]]
[09:29:14.664]                   NAME <- NAMES[[kk]]
[09:29:14.664]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.664]                     next
[09:29:14.664]                   args[[name]] <- ""
[09:29:14.664]                 }
[09:29:14.664]                 NAMES <- toupper(removed)
[09:29:14.664]                 for (kk in seq_along(NAMES)) {
[09:29:14.664]                   name <- removed[[kk]]
[09:29:14.664]                   NAME <- NAMES[[kk]]
[09:29:14.664]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.664]                     next
[09:29:14.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.664]                 }
[09:29:14.664]                 if (length(args) > 0) 
[09:29:14.664]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.664]             }
[09:29:14.664]             else {
[09:29:14.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.664]             }
[09:29:14.664]             {
[09:29:14.664]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.664]                   0L) {
[09:29:14.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.664]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.664]                   base::options(opts)
[09:29:14.664]                 }
[09:29:14.664]                 {
[09:29:14.664]                   {
[09:29:14.664]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.664]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.664]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.664]                     NULL
[09:29:14.664]                   }
[09:29:14.664]                   options(future.plan = NULL)
[09:29:14.664]                   if (is.na(NA_character_)) 
[09:29:14.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.664]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.664]                     .init = FALSE)
[09:29:14.664]                 }
[09:29:14.664]             }
[09:29:14.664]         }
[09:29:14.664]     })
[09:29:14.664]     if (TRUE) {
[09:29:14.664]         base::sink(type = "output", split = FALSE)
[09:29:14.664]         if (TRUE) {
[09:29:14.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.664]         }
[09:29:14.664]         else {
[09:29:14.664]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.664]         }
[09:29:14.664]         base::close(...future.stdout)
[09:29:14.664]         ...future.stdout <- NULL
[09:29:14.664]     }
[09:29:14.664]     ...future.result$conditions <- ...future.conditions
[09:29:14.664]     ...future.result$finished <- base::Sys.time()
[09:29:14.664]     ...future.result
[09:29:14.664] }
[09:29:14.665] assign_globals() ...
[09:29:14.665] List of 5
[09:29:14.665]  $ ...future.FUN            :function (C, k)  
[09:29:14.665]  $ MoreArgs                 : list()
[09:29:14.665]  $ ...future.elements_ii    :List of 2
[09:29:14.665]   ..$ :List of 5
[09:29:14.665]   .. ..$ : chr "A"
[09:29:14.665]   .. ..$ : chr "B"
[09:29:14.665]   .. ..$ : chr "C"
[09:29:14.665]   .. ..$ : chr "D"
[09:29:14.665]   .. ..$ : chr "E"
[09:29:14.665]   ..$ :List of 5
[09:29:14.665]   .. ..$ : int 5
[09:29:14.665]   .. ..$ : int 4
[09:29:14.665]   .. ..$ : int 3
[09:29:14.665]   .. ..$ : int 2
[09:29:14.665]   .. ..$ : int 1
[09:29:14.665]  $ ...future.seeds_ii       : NULL
[09:29:14.665]  $ ...future.globals.maxSize: NULL
[09:29:14.665]  - attr(*, "where")=List of 5
[09:29:14.665]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.665]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.665]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.665]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.665]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.665]  - attr(*, "resolved")= logi FALSE
[09:29:14.665]  - attr(*, "total_size")= num 4160
[09:29:14.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.665]  - attr(*, "already-done")= logi TRUE
[09:29:14.673] - reassign environment for ‘...future.FUN’
[09:29:14.673] - copied ‘...future.FUN’ to environment
[09:29:14.673] - copied ‘MoreArgs’ to environment
[09:29:14.673] - copied ‘...future.elements_ii’ to environment
[09:29:14.674] - copied ‘...future.seeds_ii’ to environment
[09:29:14.674] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.674] assign_globals() ... done
[09:29:14.674] plan(): Setting new future strategy stack:
[09:29:14.674] List of future strategies:
[09:29:14.674] 1. sequential:
[09:29:14.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.674]    - tweaked: FALSE
[09:29:14.674]    - call: NULL
[09:29:14.675] plan(): nbrOfWorkers() = 1
[09:29:14.675] plan(): Setting new future strategy stack:
[09:29:14.675] List of future strategies:
[09:29:14.675] 1. sequential:
[09:29:14.675]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.675]    - tweaked: FALSE
[09:29:14.675]    - call: plan(strategy)
[09:29:14.676] plan(): nbrOfWorkers() = 1
[09:29:14.676] SequentialFuture started (and completed)
[09:29:14.676] - Launch lazy future ... done
[09:29:14.676] run() for ‘SequentialFuture’ ... done
[09:29:14.676] Created future:
[09:29:14.676] SequentialFuture:
[09:29:14.676] Label: ‘future_.mapply-1’
[09:29:14.676] Expression:
[09:29:14.676] {
[09:29:14.676]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.676]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.676]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.676]         on.exit(options(oopts), add = TRUE)
[09:29:14.676]     }
[09:29:14.676]     {
[09:29:14.676]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.676]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.676]         do.call(mapply, args = args)
[09:29:14.676]     }
[09:29:14.676] }
[09:29:14.676] Lazy evaluation: FALSE
[09:29:14.676] Asynchronous evaluation: FALSE
[09:29:14.676] Local evaluation: TRUE
[09:29:14.676] Environment: R_GlobalEnv
[09:29:14.676] Capture standard output: TRUE
[09:29:14.676] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.676] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.676] Packages: <none>
[09:29:14.676] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.676] Resolved: TRUE
[09:29:14.676] Value: 560 bytes of class ‘list’
[09:29:14.676] Early signaling: FALSE
[09:29:14.676] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.676] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.677] Chunk #1 of 1 ... DONE
[09:29:14.677] Launching 1 futures (chunks) ... DONE
[09:29:14.677] Resolving 1 futures (chunks) ...
[09:29:14.678] resolve() on list ...
[09:29:14.678]  recursive: 0
[09:29:14.678]  length: 1
[09:29:14.678] 
[09:29:14.678] resolved() for ‘SequentialFuture’ ...
[09:29:14.678] - state: ‘finished’
[09:29:14.678] - run: TRUE
[09:29:14.678] - result: ‘FutureResult’
[09:29:14.678] resolved() for ‘SequentialFuture’ ... done
[09:29:14.678] Future #1
[09:29:14.678] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.679] - nx: 1
[09:29:14.679] - relay: TRUE
[09:29:14.679] - stdout: TRUE
[09:29:14.679] - signal: TRUE
[09:29:14.679] - resignal: FALSE
[09:29:14.679] - force: TRUE
[09:29:14.679] - relayed: [n=1] FALSE
[09:29:14.679] - queued futures: [n=1] FALSE
[09:29:14.679]  - until=1
[09:29:14.679]  - relaying element #1
[09:29:14.680] - relayed: [n=1] TRUE
[09:29:14.680] - queued futures: [n=1] TRUE
[09:29:14.680] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.680]  length: 0 (resolved future 1)
[09:29:14.680] Relaying remaining futures
[09:29:14.680] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.680] - nx: 1
[09:29:14.680] - relay: TRUE
[09:29:14.680] - stdout: TRUE
[09:29:14.680] - signal: TRUE
[09:29:14.680] - resignal: FALSE
[09:29:14.680] - force: TRUE
[09:29:14.681] - relayed: [n=1] TRUE
[09:29:14.681] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.681] - relayed: [n=1] TRUE
[09:29:14.681] - queued futures: [n=1] TRUE
[09:29:14.681] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.681] resolve() on list ... DONE
[09:29:14.681]  - Number of value chunks collected: 1
[09:29:14.681] Resolving 1 futures (chunks) ... DONE
[09:29:14.681] Reducing values from 1 chunks ...
[09:29:14.681]  - Number of values collected after concatenation: 5
[09:29:14.682]  - Number of values expected: 5
[09:29:14.682] Reducing values from 1 chunks ... DONE
[09:29:14.682] future_mapply() ... DONE
[09:29:14.682] future_mapply() ...
[09:29:14.682] Number of chunks: 2
[09:29:14.682] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[09:29:14.682] getGlobalsAndPackagesXApply() ...
[09:29:14.683]  - future.globals: TRUE
[09:29:14.683] getGlobalsAndPackages() ...
[09:29:14.683] Searching for globals...
[09:29:14.684] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:14.684] Searching for globals ... DONE
[09:29:14.684] Resolving globals: FALSE
[09:29:14.684] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:14.685] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:14.685] - globals: [1] ‘FUN’
[09:29:14.685] 
[09:29:14.685] getGlobalsAndPackages() ... DONE
[09:29:14.685]  - globals found/used: [n=1] ‘FUN’
[09:29:14.685]  - needed namespaces: [n=0] 
[09:29:14.685] Finding globals ... DONE
[09:29:14.685] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.686] List of 2
[09:29:14.686]  $ ...future.FUN:function (C, k)  
[09:29:14.686]  $ MoreArgs     : NULL
[09:29:14.686]  - attr(*, "where")=List of 2
[09:29:14.686]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.686]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.686]  - attr(*, "resolved")= logi FALSE
[09:29:14.686]  - attr(*, "total_size")= num NA
[09:29:14.688] Packages to be attached in all futures: [n=0] 
[09:29:14.688] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.688] Number of futures (= number of chunks): 2
[09:29:14.688] Launching 2 futures (chunks) ...
[09:29:14.688] Chunk #1 of 2 ...
[09:29:14.688]  - Finding globals in '...' for chunk #1 ...
[09:29:14.688] getGlobalsAndPackages() ...
[09:29:14.689] Searching for globals...
[09:29:14.689] 
[09:29:14.689] Searching for globals ... DONE
[09:29:14.689] - globals: [0] <none>
[09:29:14.689] getGlobalsAndPackages() ... DONE
[09:29:14.689]    + additional globals found: [n=0] 
[09:29:14.689]    + additional namespaces needed: [n=0] 
[09:29:14.689]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.689]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:14.690]  - seeds: <none>
[09:29:14.690]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.690] getGlobalsAndPackages() ...
[09:29:14.690] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.690] Resolving globals: FALSE
[09:29:14.690] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:14.691] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.691] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.691] 
[09:29:14.691] getGlobalsAndPackages() ... DONE
[09:29:14.691] run() for ‘Future’ ...
[09:29:14.691] - state: ‘created’
[09:29:14.692] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.692] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.692] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.692]   - Field: ‘label’
[09:29:14.692]   - Field: ‘local’
[09:29:14.692]   - Field: ‘owner’
[09:29:14.692]   - Field: ‘envir’
[09:29:14.692]   - Field: ‘packages’
[09:29:14.692]   - Field: ‘gc’
[09:29:14.693]   - Field: ‘conditions’
[09:29:14.693]   - Field: ‘expr’
[09:29:14.693]   - Field: ‘uuid’
[09:29:14.693]   - Field: ‘seed’
[09:29:14.693]   - Field: ‘version’
[09:29:14.693]   - Field: ‘result’
[09:29:14.693]   - Field: ‘asynchronous’
[09:29:14.693]   - Field: ‘calls’
[09:29:14.693]   - Field: ‘globals’
[09:29:14.693]   - Field: ‘stdout’
[09:29:14.693]   - Field: ‘earlySignal’
[09:29:14.693]   - Field: ‘lazy’
[09:29:14.694]   - Field: ‘state’
[09:29:14.694] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.694] - Launch lazy future ...
[09:29:14.694] Packages needed by the future expression (n = 0): <none>
[09:29:14.694] Packages needed by future strategies (n = 0): <none>
[09:29:14.694] {
[09:29:14.694]     {
[09:29:14.694]         {
[09:29:14.694]             ...future.startTime <- base::Sys.time()
[09:29:14.694]             {
[09:29:14.694]                 {
[09:29:14.694]                   {
[09:29:14.694]                     base::local({
[09:29:14.694]                       has_future <- base::requireNamespace("future", 
[09:29:14.694]                         quietly = TRUE)
[09:29:14.694]                       if (has_future) {
[09:29:14.694]                         ns <- base::getNamespace("future")
[09:29:14.694]                         version <- ns[[".package"]][["version"]]
[09:29:14.694]                         if (is.null(version)) 
[09:29:14.694]                           version <- utils::packageVersion("future")
[09:29:14.694]                       }
[09:29:14.694]                       else {
[09:29:14.694]                         version <- NULL
[09:29:14.694]                       }
[09:29:14.694]                       if (!has_future || version < "1.8.0") {
[09:29:14.694]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.694]                           "", base::R.version$version.string), 
[09:29:14.694]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.694]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.694]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.694]                             "release", "version")], collapse = " "), 
[09:29:14.694]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.694]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.694]                           info)
[09:29:14.694]                         info <- base::paste(info, collapse = "; ")
[09:29:14.694]                         if (!has_future) {
[09:29:14.694]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.694]                             info)
[09:29:14.694]                         }
[09:29:14.694]                         else {
[09:29:14.694]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.694]                             info, version)
[09:29:14.694]                         }
[09:29:14.694]                         base::stop(msg)
[09:29:14.694]                       }
[09:29:14.694]                     })
[09:29:14.694]                   }
[09:29:14.694]                   ...future.strategy.old <- future::plan("list")
[09:29:14.694]                   options(future.plan = NULL)
[09:29:14.694]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.694]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.694]                 }
[09:29:14.694]                 ...future.workdir <- getwd()
[09:29:14.694]             }
[09:29:14.694]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.694]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.694]         }
[09:29:14.694]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.694]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:14.694]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.694]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.694]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.694]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.694]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.694]             base::names(...future.oldOptions))
[09:29:14.694]     }
[09:29:14.694]     if (FALSE) {
[09:29:14.694]     }
[09:29:14.694]     else {
[09:29:14.694]         if (TRUE) {
[09:29:14.694]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.694]                 open = "w")
[09:29:14.694]         }
[09:29:14.694]         else {
[09:29:14.694]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.694]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.694]         }
[09:29:14.694]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.694]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.694]             base::sink(type = "output", split = FALSE)
[09:29:14.694]             base::close(...future.stdout)
[09:29:14.694]         }, add = TRUE)
[09:29:14.694]     }
[09:29:14.694]     ...future.frame <- base::sys.nframe()
[09:29:14.694]     ...future.conditions <- base::list()
[09:29:14.694]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.694]     if (FALSE) {
[09:29:14.694]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.694]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.694]     }
[09:29:14.694]     ...future.result <- base::tryCatch({
[09:29:14.694]         base::withCallingHandlers({
[09:29:14.694]             ...future.value <- base::withVisible(base::local({
[09:29:14.694]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.694]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.694]                   ...future.globals.maxSize)) {
[09:29:14.694]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.694]                   on.exit(options(oopts), add = TRUE)
[09:29:14.694]                 }
[09:29:14.694]                 {
[09:29:14.694]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.694]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.694]                     USE.NAMES = FALSE)
[09:29:14.694]                   do.call(mapply, args = args)
[09:29:14.694]                 }
[09:29:14.694]             }))
[09:29:14.694]             future::FutureResult(value = ...future.value$value, 
[09:29:14.694]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.694]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.694]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.694]                     ...future.globalenv.names))
[09:29:14.694]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.694]         }, condition = base::local({
[09:29:14.694]             c <- base::c
[09:29:14.694]             inherits <- base::inherits
[09:29:14.694]             invokeRestart <- base::invokeRestart
[09:29:14.694]             length <- base::length
[09:29:14.694]             list <- base::list
[09:29:14.694]             seq.int <- base::seq.int
[09:29:14.694]             signalCondition <- base::signalCondition
[09:29:14.694]             sys.calls <- base::sys.calls
[09:29:14.694]             `[[` <- base::`[[`
[09:29:14.694]             `+` <- base::`+`
[09:29:14.694]             `<<-` <- base::`<<-`
[09:29:14.694]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.694]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.694]                   3L)]
[09:29:14.694]             }
[09:29:14.694]             function(cond) {
[09:29:14.694]                 is_error <- inherits(cond, "error")
[09:29:14.694]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.694]                   NULL)
[09:29:14.694]                 if (is_error) {
[09:29:14.694]                   sessionInformation <- function() {
[09:29:14.694]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.694]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.694]                       search = base::search(), system = base::Sys.info())
[09:29:14.694]                   }
[09:29:14.694]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.694]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.694]                     cond$call), session = sessionInformation(), 
[09:29:14.694]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.694]                   signalCondition(cond)
[09:29:14.694]                 }
[09:29:14.694]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.694]                 "immediateCondition"))) {
[09:29:14.694]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.694]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.694]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.694]                   if (TRUE && !signal) {
[09:29:14.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.694]                     {
[09:29:14.694]                       inherits <- base::inherits
[09:29:14.694]                       invokeRestart <- base::invokeRestart
[09:29:14.694]                       is.null <- base::is.null
[09:29:14.694]                       muffled <- FALSE
[09:29:14.694]                       if (inherits(cond, "message")) {
[09:29:14.694]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.694]                         if (muffled) 
[09:29:14.694]                           invokeRestart("muffleMessage")
[09:29:14.694]                       }
[09:29:14.694]                       else if (inherits(cond, "warning")) {
[09:29:14.694]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.694]                         if (muffled) 
[09:29:14.694]                           invokeRestart("muffleWarning")
[09:29:14.694]                       }
[09:29:14.694]                       else if (inherits(cond, "condition")) {
[09:29:14.694]                         if (!is.null(pattern)) {
[09:29:14.694]                           computeRestarts <- base::computeRestarts
[09:29:14.694]                           grepl <- base::grepl
[09:29:14.694]                           restarts <- computeRestarts(cond)
[09:29:14.694]                           for (restart in restarts) {
[09:29:14.694]                             name <- restart$name
[09:29:14.694]                             if (is.null(name)) 
[09:29:14.694]                               next
[09:29:14.694]                             if (!grepl(pattern, name)) 
[09:29:14.694]                               next
[09:29:14.694]                             invokeRestart(restart)
[09:29:14.694]                             muffled <- TRUE
[09:29:14.694]                             break
[09:29:14.694]                           }
[09:29:14.694]                         }
[09:29:14.694]                       }
[09:29:14.694]                       invisible(muffled)
[09:29:14.694]                     }
[09:29:14.694]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.694]                   }
[09:29:14.694]                 }
[09:29:14.694]                 else {
[09:29:14.694]                   if (TRUE) {
[09:29:14.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.694]                     {
[09:29:14.694]                       inherits <- base::inherits
[09:29:14.694]                       invokeRestart <- base::invokeRestart
[09:29:14.694]                       is.null <- base::is.null
[09:29:14.694]                       muffled <- FALSE
[09:29:14.694]                       if (inherits(cond, "message")) {
[09:29:14.694]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.694]                         if (muffled) 
[09:29:14.694]                           invokeRestart("muffleMessage")
[09:29:14.694]                       }
[09:29:14.694]                       else if (inherits(cond, "warning")) {
[09:29:14.694]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.694]                         if (muffled) 
[09:29:14.694]                           invokeRestart("muffleWarning")
[09:29:14.694]                       }
[09:29:14.694]                       else if (inherits(cond, "condition")) {
[09:29:14.694]                         if (!is.null(pattern)) {
[09:29:14.694]                           computeRestarts <- base::computeRestarts
[09:29:14.694]                           grepl <- base::grepl
[09:29:14.694]                           restarts <- computeRestarts(cond)
[09:29:14.694]                           for (restart in restarts) {
[09:29:14.694]                             name <- restart$name
[09:29:14.694]                             if (is.null(name)) 
[09:29:14.694]                               next
[09:29:14.694]                             if (!grepl(pattern, name)) 
[09:29:14.694]                               next
[09:29:14.694]                             invokeRestart(restart)
[09:29:14.694]                             muffled <- TRUE
[09:29:14.694]                             break
[09:29:14.694]                           }
[09:29:14.694]                         }
[09:29:14.694]                       }
[09:29:14.694]                       invisible(muffled)
[09:29:14.694]                     }
[09:29:14.694]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.694]                   }
[09:29:14.694]                 }
[09:29:14.694]             }
[09:29:14.694]         }))
[09:29:14.694]     }, error = function(ex) {
[09:29:14.694]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.694]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.694]                 ...future.rng), started = ...future.startTime, 
[09:29:14.694]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.694]             version = "1.8"), class = "FutureResult")
[09:29:14.694]     }, finally = {
[09:29:14.694]         if (!identical(...future.workdir, getwd())) 
[09:29:14.694]             setwd(...future.workdir)
[09:29:14.694]         {
[09:29:14.694]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.694]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.694]             }
[09:29:14.694]             base::options(...future.oldOptions)
[09:29:14.694]             if (.Platform$OS.type == "windows") {
[09:29:14.694]                 old_names <- names(...future.oldEnvVars)
[09:29:14.694]                 envs <- base::Sys.getenv()
[09:29:14.694]                 names <- names(envs)
[09:29:14.694]                 common <- intersect(names, old_names)
[09:29:14.694]                 added <- setdiff(names, old_names)
[09:29:14.694]                 removed <- setdiff(old_names, names)
[09:29:14.694]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.694]                   envs[common]]
[09:29:14.694]                 NAMES <- toupper(changed)
[09:29:14.694]                 args <- list()
[09:29:14.694]                 for (kk in seq_along(NAMES)) {
[09:29:14.694]                   name <- changed[[kk]]
[09:29:14.694]                   NAME <- NAMES[[kk]]
[09:29:14.694]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.694]                     next
[09:29:14.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.694]                 }
[09:29:14.694]                 NAMES <- toupper(added)
[09:29:14.694]                 for (kk in seq_along(NAMES)) {
[09:29:14.694]                   name <- added[[kk]]
[09:29:14.694]                   NAME <- NAMES[[kk]]
[09:29:14.694]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.694]                     next
[09:29:14.694]                   args[[name]] <- ""
[09:29:14.694]                 }
[09:29:14.694]                 NAMES <- toupper(removed)
[09:29:14.694]                 for (kk in seq_along(NAMES)) {
[09:29:14.694]                   name <- removed[[kk]]
[09:29:14.694]                   NAME <- NAMES[[kk]]
[09:29:14.694]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.694]                     next
[09:29:14.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.694]                 }
[09:29:14.694]                 if (length(args) > 0) 
[09:29:14.694]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.694]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.694]             }
[09:29:14.694]             else {
[09:29:14.694]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.694]             }
[09:29:14.694]             {
[09:29:14.694]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.694]                   0L) {
[09:29:14.694]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.694]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.694]                   base::options(opts)
[09:29:14.694]                 }
[09:29:14.694]                 {
[09:29:14.694]                   {
[09:29:14.694]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.694]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.694]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.694]                     NULL
[09:29:14.694]                   }
[09:29:14.694]                   options(future.plan = NULL)
[09:29:14.694]                   if (is.na(NA_character_)) 
[09:29:14.694]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.694]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.694]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.694]                     .init = FALSE)
[09:29:14.694]                 }
[09:29:14.694]             }
[09:29:14.694]         }
[09:29:14.694]     })
[09:29:14.694]     if (TRUE) {
[09:29:14.694]         base::sink(type = "output", split = FALSE)
[09:29:14.694]         if (TRUE) {
[09:29:14.694]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.694]         }
[09:29:14.694]         else {
[09:29:14.694]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.694]         }
[09:29:14.694]         base::close(...future.stdout)
[09:29:14.694]         ...future.stdout <- NULL
[09:29:14.694]     }
[09:29:14.694]     ...future.result$conditions <- ...future.conditions
[09:29:14.694]     ...future.result$finished <- base::Sys.time()
[09:29:14.694]     ...future.result
[09:29:14.694] }
[09:29:14.696] assign_globals() ...
[09:29:14.696] List of 5
[09:29:14.696]  $ ...future.FUN            :function (C, k)  
[09:29:14.696]  $ MoreArgs                 : NULL
[09:29:14.696]  $ ...future.elements_ii    :List of 2
[09:29:14.696]   ..$ :List of 2
[09:29:14.696]   .. ..$ : chr "E"
[09:29:14.696]   .. ..$ : chr "D"
[09:29:14.696]   ..$ :List of 2
[09:29:14.696]   .. ..$ : int 1
[09:29:14.696]   .. ..$ : int 2
[09:29:14.696]  $ ...future.seeds_ii       : NULL
[09:29:14.696]  $ ...future.globals.maxSize: NULL
[09:29:14.696]  - attr(*, "where")=List of 5
[09:29:14.696]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.696]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.696]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.696]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.696]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.696]  - attr(*, "resolved")= logi FALSE
[09:29:14.696]  - attr(*, "total_size")= num 3656
[09:29:14.696]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.696]  - attr(*, "already-done")= logi TRUE
[09:29:14.703] - reassign environment for ‘...future.FUN’
[09:29:14.703] - copied ‘...future.FUN’ to environment
[09:29:14.703] - copied ‘MoreArgs’ to environment
[09:29:14.703] - copied ‘...future.elements_ii’ to environment
[09:29:14.703] - copied ‘...future.seeds_ii’ to environment
[09:29:14.703] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.703] assign_globals() ... done
[09:29:14.703] plan(): Setting new future strategy stack:
[09:29:14.703] List of future strategies:
[09:29:14.703] 1. sequential:
[09:29:14.703]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.703]    - tweaked: FALSE
[09:29:14.703]    - call: NULL
[09:29:14.704] plan(): nbrOfWorkers() = 1
[09:29:14.705] plan(): Setting new future strategy stack:
[09:29:14.705] List of future strategies:
[09:29:14.705] 1. sequential:
[09:29:14.705]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.705]    - tweaked: FALSE
[09:29:14.705]    - call: plan(strategy)
[09:29:14.705] plan(): nbrOfWorkers() = 1
[09:29:14.705] SequentialFuture started (and completed)
[09:29:14.705] - Launch lazy future ... done
[09:29:14.705] run() for ‘SequentialFuture’ ... done
[09:29:14.706] Created future:
[09:29:14.706] SequentialFuture:
[09:29:14.706] Label: ‘future_mapply-1’
[09:29:14.706] Expression:
[09:29:14.706] {
[09:29:14.706]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.706]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.706]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.706]         on.exit(options(oopts), add = TRUE)
[09:29:14.706]     }
[09:29:14.706]     {
[09:29:14.706]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.706]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.706]         do.call(mapply, args = args)
[09:29:14.706]     }
[09:29:14.706] }
[09:29:14.706] Lazy evaluation: FALSE
[09:29:14.706] Asynchronous evaluation: FALSE
[09:29:14.706] Local evaluation: TRUE
[09:29:14.706] Environment: R_GlobalEnv
[09:29:14.706] Capture standard output: TRUE
[09:29:14.706] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.706] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.706] Packages: <none>
[09:29:14.706] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.706] Resolved: TRUE
[09:29:14.706] Value: 224 bytes of class ‘list’
[09:29:14.706] Early signaling: FALSE
[09:29:14.706] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.706] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.706] Chunk #1 of 2 ... DONE
[09:29:14.706] Chunk #2 of 2 ...
[09:29:14.707]  - Finding globals in '...' for chunk #2 ...
[09:29:14.707] getGlobalsAndPackages() ...
[09:29:14.707] Searching for globals...
[09:29:14.707] 
[09:29:14.707] Searching for globals ... DONE
[09:29:14.707] - globals: [0] <none>
[09:29:14.707] getGlobalsAndPackages() ... DONE
[09:29:14.707]    + additional globals found: [n=0] 
[09:29:14.708]    + additional namespaces needed: [n=0] 
[09:29:14.708]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:14.708]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:14.708]  - seeds: <none>
[09:29:14.708]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.708] getGlobalsAndPackages() ...
[09:29:14.708] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.708] Resolving globals: FALSE
[09:29:14.709] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[09:29:14.709] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.709] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.709] 
[09:29:14.709] getGlobalsAndPackages() ... DONE
[09:29:14.710] run() for ‘Future’ ...
[09:29:14.710] - state: ‘created’
[09:29:14.710] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.710] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.710] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.710]   - Field: ‘label’
[09:29:14.710]   - Field: ‘local’
[09:29:14.710]   - Field: ‘owner’
[09:29:14.710]   - Field: ‘envir’
[09:29:14.711]   - Field: ‘packages’
[09:29:14.711]   - Field: ‘gc’
[09:29:14.711]   - Field: ‘conditions’
[09:29:14.711]   - Field: ‘expr’
[09:29:14.711]   - Field: ‘uuid’
[09:29:14.711]   - Field: ‘seed’
[09:29:14.711]   - Field: ‘version’
[09:29:14.711]   - Field: ‘result’
[09:29:14.711]   - Field: ‘asynchronous’
[09:29:14.711]   - Field: ‘calls’
[09:29:14.711]   - Field: ‘globals’
[09:29:14.712]   - Field: ‘stdout’
[09:29:14.712]   - Field: ‘earlySignal’
[09:29:14.712]   - Field: ‘lazy’
[09:29:14.712]   - Field: ‘state’
[09:29:14.712] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.712] - Launch lazy future ...
[09:29:14.712] Packages needed by the future expression (n = 0): <none>
[09:29:14.712] Packages needed by future strategies (n = 0): <none>
[09:29:14.713] {
[09:29:14.713]     {
[09:29:14.713]         {
[09:29:14.713]             ...future.startTime <- base::Sys.time()
[09:29:14.713]             {
[09:29:14.713]                 {
[09:29:14.713]                   {
[09:29:14.713]                     base::local({
[09:29:14.713]                       has_future <- base::requireNamespace("future", 
[09:29:14.713]                         quietly = TRUE)
[09:29:14.713]                       if (has_future) {
[09:29:14.713]                         ns <- base::getNamespace("future")
[09:29:14.713]                         version <- ns[[".package"]][["version"]]
[09:29:14.713]                         if (is.null(version)) 
[09:29:14.713]                           version <- utils::packageVersion("future")
[09:29:14.713]                       }
[09:29:14.713]                       else {
[09:29:14.713]                         version <- NULL
[09:29:14.713]                       }
[09:29:14.713]                       if (!has_future || version < "1.8.0") {
[09:29:14.713]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.713]                           "", base::R.version$version.string), 
[09:29:14.713]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.713]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.713]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.713]                             "release", "version")], collapse = " "), 
[09:29:14.713]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.713]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.713]                           info)
[09:29:14.713]                         info <- base::paste(info, collapse = "; ")
[09:29:14.713]                         if (!has_future) {
[09:29:14.713]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.713]                             info)
[09:29:14.713]                         }
[09:29:14.713]                         else {
[09:29:14.713]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.713]                             info, version)
[09:29:14.713]                         }
[09:29:14.713]                         base::stop(msg)
[09:29:14.713]                       }
[09:29:14.713]                     })
[09:29:14.713]                   }
[09:29:14.713]                   ...future.strategy.old <- future::plan("list")
[09:29:14.713]                   options(future.plan = NULL)
[09:29:14.713]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.713]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.713]                 }
[09:29:14.713]                 ...future.workdir <- getwd()
[09:29:14.713]             }
[09:29:14.713]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.713]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.713]         }
[09:29:14.713]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.713]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:14.713]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.713]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.713]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.713]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.713]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.713]             base::names(...future.oldOptions))
[09:29:14.713]     }
[09:29:14.713]     if (FALSE) {
[09:29:14.713]     }
[09:29:14.713]     else {
[09:29:14.713]         if (TRUE) {
[09:29:14.713]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.713]                 open = "w")
[09:29:14.713]         }
[09:29:14.713]         else {
[09:29:14.713]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.713]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.713]         }
[09:29:14.713]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.713]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.713]             base::sink(type = "output", split = FALSE)
[09:29:14.713]             base::close(...future.stdout)
[09:29:14.713]         }, add = TRUE)
[09:29:14.713]     }
[09:29:14.713]     ...future.frame <- base::sys.nframe()
[09:29:14.713]     ...future.conditions <- base::list()
[09:29:14.713]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.713]     if (FALSE) {
[09:29:14.713]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.713]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.713]     }
[09:29:14.713]     ...future.result <- base::tryCatch({
[09:29:14.713]         base::withCallingHandlers({
[09:29:14.713]             ...future.value <- base::withVisible(base::local({
[09:29:14.713]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.713]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.713]                   ...future.globals.maxSize)) {
[09:29:14.713]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.713]                   on.exit(options(oopts), add = TRUE)
[09:29:14.713]                 }
[09:29:14.713]                 {
[09:29:14.713]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.713]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.713]                     USE.NAMES = FALSE)
[09:29:14.713]                   do.call(mapply, args = args)
[09:29:14.713]                 }
[09:29:14.713]             }))
[09:29:14.713]             future::FutureResult(value = ...future.value$value, 
[09:29:14.713]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.713]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.713]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.713]                     ...future.globalenv.names))
[09:29:14.713]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.713]         }, condition = base::local({
[09:29:14.713]             c <- base::c
[09:29:14.713]             inherits <- base::inherits
[09:29:14.713]             invokeRestart <- base::invokeRestart
[09:29:14.713]             length <- base::length
[09:29:14.713]             list <- base::list
[09:29:14.713]             seq.int <- base::seq.int
[09:29:14.713]             signalCondition <- base::signalCondition
[09:29:14.713]             sys.calls <- base::sys.calls
[09:29:14.713]             `[[` <- base::`[[`
[09:29:14.713]             `+` <- base::`+`
[09:29:14.713]             `<<-` <- base::`<<-`
[09:29:14.713]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.713]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.713]                   3L)]
[09:29:14.713]             }
[09:29:14.713]             function(cond) {
[09:29:14.713]                 is_error <- inherits(cond, "error")
[09:29:14.713]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.713]                   NULL)
[09:29:14.713]                 if (is_error) {
[09:29:14.713]                   sessionInformation <- function() {
[09:29:14.713]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.713]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.713]                       search = base::search(), system = base::Sys.info())
[09:29:14.713]                   }
[09:29:14.713]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.713]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.713]                     cond$call), session = sessionInformation(), 
[09:29:14.713]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.713]                   signalCondition(cond)
[09:29:14.713]                 }
[09:29:14.713]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.713]                 "immediateCondition"))) {
[09:29:14.713]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.713]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.713]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.713]                   if (TRUE && !signal) {
[09:29:14.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.713]                     {
[09:29:14.713]                       inherits <- base::inherits
[09:29:14.713]                       invokeRestart <- base::invokeRestart
[09:29:14.713]                       is.null <- base::is.null
[09:29:14.713]                       muffled <- FALSE
[09:29:14.713]                       if (inherits(cond, "message")) {
[09:29:14.713]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.713]                         if (muffled) 
[09:29:14.713]                           invokeRestart("muffleMessage")
[09:29:14.713]                       }
[09:29:14.713]                       else if (inherits(cond, "warning")) {
[09:29:14.713]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.713]                         if (muffled) 
[09:29:14.713]                           invokeRestart("muffleWarning")
[09:29:14.713]                       }
[09:29:14.713]                       else if (inherits(cond, "condition")) {
[09:29:14.713]                         if (!is.null(pattern)) {
[09:29:14.713]                           computeRestarts <- base::computeRestarts
[09:29:14.713]                           grepl <- base::grepl
[09:29:14.713]                           restarts <- computeRestarts(cond)
[09:29:14.713]                           for (restart in restarts) {
[09:29:14.713]                             name <- restart$name
[09:29:14.713]                             if (is.null(name)) 
[09:29:14.713]                               next
[09:29:14.713]                             if (!grepl(pattern, name)) 
[09:29:14.713]                               next
[09:29:14.713]                             invokeRestart(restart)
[09:29:14.713]                             muffled <- TRUE
[09:29:14.713]                             break
[09:29:14.713]                           }
[09:29:14.713]                         }
[09:29:14.713]                       }
[09:29:14.713]                       invisible(muffled)
[09:29:14.713]                     }
[09:29:14.713]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.713]                   }
[09:29:14.713]                 }
[09:29:14.713]                 else {
[09:29:14.713]                   if (TRUE) {
[09:29:14.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.713]                     {
[09:29:14.713]                       inherits <- base::inherits
[09:29:14.713]                       invokeRestart <- base::invokeRestart
[09:29:14.713]                       is.null <- base::is.null
[09:29:14.713]                       muffled <- FALSE
[09:29:14.713]                       if (inherits(cond, "message")) {
[09:29:14.713]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.713]                         if (muffled) 
[09:29:14.713]                           invokeRestart("muffleMessage")
[09:29:14.713]                       }
[09:29:14.713]                       else if (inherits(cond, "warning")) {
[09:29:14.713]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.713]                         if (muffled) 
[09:29:14.713]                           invokeRestart("muffleWarning")
[09:29:14.713]                       }
[09:29:14.713]                       else if (inherits(cond, "condition")) {
[09:29:14.713]                         if (!is.null(pattern)) {
[09:29:14.713]                           computeRestarts <- base::computeRestarts
[09:29:14.713]                           grepl <- base::grepl
[09:29:14.713]                           restarts <- computeRestarts(cond)
[09:29:14.713]                           for (restart in restarts) {
[09:29:14.713]                             name <- restart$name
[09:29:14.713]                             if (is.null(name)) 
[09:29:14.713]                               next
[09:29:14.713]                             if (!grepl(pattern, name)) 
[09:29:14.713]                               next
[09:29:14.713]                             invokeRestart(restart)
[09:29:14.713]                             muffled <- TRUE
[09:29:14.713]                             break
[09:29:14.713]                           }
[09:29:14.713]                         }
[09:29:14.713]                       }
[09:29:14.713]                       invisible(muffled)
[09:29:14.713]                     }
[09:29:14.713]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.713]                   }
[09:29:14.713]                 }
[09:29:14.713]             }
[09:29:14.713]         }))
[09:29:14.713]     }, error = function(ex) {
[09:29:14.713]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.713]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.713]                 ...future.rng), started = ...future.startTime, 
[09:29:14.713]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.713]             version = "1.8"), class = "FutureResult")
[09:29:14.713]     }, finally = {
[09:29:14.713]         if (!identical(...future.workdir, getwd())) 
[09:29:14.713]             setwd(...future.workdir)
[09:29:14.713]         {
[09:29:14.713]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.713]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.713]             }
[09:29:14.713]             base::options(...future.oldOptions)
[09:29:14.713]             if (.Platform$OS.type == "windows") {
[09:29:14.713]                 old_names <- names(...future.oldEnvVars)
[09:29:14.713]                 envs <- base::Sys.getenv()
[09:29:14.713]                 names <- names(envs)
[09:29:14.713]                 common <- intersect(names, old_names)
[09:29:14.713]                 added <- setdiff(names, old_names)
[09:29:14.713]                 removed <- setdiff(old_names, names)
[09:29:14.713]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.713]                   envs[common]]
[09:29:14.713]                 NAMES <- toupper(changed)
[09:29:14.713]                 args <- list()
[09:29:14.713]                 for (kk in seq_along(NAMES)) {
[09:29:14.713]                   name <- changed[[kk]]
[09:29:14.713]                   NAME <- NAMES[[kk]]
[09:29:14.713]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.713]                     next
[09:29:14.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.713]                 }
[09:29:14.713]                 NAMES <- toupper(added)
[09:29:14.713]                 for (kk in seq_along(NAMES)) {
[09:29:14.713]                   name <- added[[kk]]
[09:29:14.713]                   NAME <- NAMES[[kk]]
[09:29:14.713]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.713]                     next
[09:29:14.713]                   args[[name]] <- ""
[09:29:14.713]                 }
[09:29:14.713]                 NAMES <- toupper(removed)
[09:29:14.713]                 for (kk in seq_along(NAMES)) {
[09:29:14.713]                   name <- removed[[kk]]
[09:29:14.713]                   NAME <- NAMES[[kk]]
[09:29:14.713]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.713]                     next
[09:29:14.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.713]                 }
[09:29:14.713]                 if (length(args) > 0) 
[09:29:14.713]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.713]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.713]             }
[09:29:14.713]             else {
[09:29:14.713]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.713]             }
[09:29:14.713]             {
[09:29:14.713]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.713]                   0L) {
[09:29:14.713]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.713]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.713]                   base::options(opts)
[09:29:14.713]                 }
[09:29:14.713]                 {
[09:29:14.713]                   {
[09:29:14.713]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.713]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.713]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.713]                     NULL
[09:29:14.713]                   }
[09:29:14.713]                   options(future.plan = NULL)
[09:29:14.713]                   if (is.na(NA_character_)) 
[09:29:14.713]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.713]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.713]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.713]                     .init = FALSE)
[09:29:14.713]                 }
[09:29:14.713]             }
[09:29:14.713]         }
[09:29:14.713]     })
[09:29:14.713]     if (TRUE) {
[09:29:14.713]         base::sink(type = "output", split = FALSE)
[09:29:14.713]         if (TRUE) {
[09:29:14.713]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.713]         }
[09:29:14.713]         else {
[09:29:14.713]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.713]         }
[09:29:14.713]         base::close(...future.stdout)
[09:29:14.713]         ...future.stdout <- NULL
[09:29:14.713]     }
[09:29:14.713]     ...future.result$conditions <- ...future.conditions
[09:29:14.713]     ...future.result$finished <- base::Sys.time()
[09:29:14.713]     ...future.result
[09:29:14.713] }
[09:29:14.714] assign_globals() ...
[09:29:14.714] List of 5
[09:29:14.714]  $ ...future.FUN            :function (C, k)  
[09:29:14.714]  $ MoreArgs                 : NULL
[09:29:14.714]  $ ...future.elements_ii    :List of 2
[09:29:14.714]   ..$ :List of 3
[09:29:14.714]   .. ..$ : chr "C"
[09:29:14.714]   .. ..$ : chr "B"
[09:29:14.714]   .. ..$ : chr "A"
[09:29:14.714]   ..$ :List of 3
[09:29:14.714]   .. ..$ : int 3
[09:29:14.714]   .. ..$ : int 4
[09:29:14.714]   .. ..$ : int 5
[09:29:14.714]  $ ...future.seeds_ii       : NULL
[09:29:14.714]  $ ...future.globals.maxSize: NULL
[09:29:14.714]  - attr(*, "where")=List of 5
[09:29:14.714]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.714]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.714]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.714]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.714]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.714]  - attr(*, "resolved")= logi FALSE
[09:29:14.714]  - attr(*, "total_size")= num 3824
[09:29:14.714]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.714]  - attr(*, "already-done")= logi TRUE
[09:29:14.720] - reassign environment for ‘...future.FUN’
[09:29:14.720] - copied ‘...future.FUN’ to environment
[09:29:14.720] - copied ‘MoreArgs’ to environment
[09:29:14.720] - copied ‘...future.elements_ii’ to environment
[09:29:14.720] - copied ‘...future.seeds_ii’ to environment
[09:29:14.720] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.720] assign_globals() ... done
[09:29:14.721] plan(): Setting new future strategy stack:
[09:29:14.722] List of future strategies:
[09:29:14.722] 1. sequential:
[09:29:14.722]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.722]    - tweaked: FALSE
[09:29:14.722]    - call: NULL
[09:29:14.722] plan(): nbrOfWorkers() = 1
[09:29:14.723] plan(): Setting new future strategy stack:
[09:29:14.723] List of future strategies:
[09:29:14.723] 1. sequential:
[09:29:14.723]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.723]    - tweaked: FALSE
[09:29:14.723]    - call: plan(strategy)
[09:29:14.724] plan(): nbrOfWorkers() = 1
[09:29:14.724] SequentialFuture started (and completed)
[09:29:14.724] - Launch lazy future ... done
[09:29:14.724] run() for ‘SequentialFuture’ ... done
[09:29:14.724] Created future:
[09:29:14.724] SequentialFuture:
[09:29:14.724] Label: ‘future_mapply-2’
[09:29:14.724] Expression:
[09:29:14.724] {
[09:29:14.724]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.724]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.724]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.724]         on.exit(options(oopts), add = TRUE)
[09:29:14.724]     }
[09:29:14.724]     {
[09:29:14.724]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.724]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.724]         do.call(mapply, args = args)
[09:29:14.724]     }
[09:29:14.724] }
[09:29:14.724] Lazy evaluation: FALSE
[09:29:14.724] Asynchronous evaluation: FALSE
[09:29:14.724] Local evaluation: TRUE
[09:29:14.724] Environment: R_GlobalEnv
[09:29:14.724] Capture standard output: TRUE
[09:29:14.724] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.724] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.724] Packages: <none>
[09:29:14.724] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.724] Resolved: TRUE
[09:29:14.724] Value: 336 bytes of class ‘list’
[09:29:14.724] Early signaling: FALSE
[09:29:14.724] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.724] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.725] Chunk #2 of 2 ... DONE
[09:29:14.725] Launching 2 futures (chunks) ... DONE
[09:29:14.725] Resolving 2 futures (chunks) ...
[09:29:14.725] resolve() on list ...
[09:29:14.725]  recursive: 0
[09:29:14.725]  length: 2
[09:29:14.725] 
[09:29:14.726] resolved() for ‘SequentialFuture’ ...
[09:29:14.726] - state: ‘finished’
[09:29:14.726] - run: TRUE
[09:29:14.726] - result: ‘FutureResult’
[09:29:14.726] resolved() for ‘SequentialFuture’ ... done
[09:29:14.726] Future #1
[09:29:14.726] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.726] - nx: 2
[09:29:14.726] - relay: TRUE
[09:29:14.726] - stdout: TRUE
[09:29:14.726] - signal: TRUE
[09:29:14.727] - resignal: FALSE
[09:29:14.727] - force: TRUE
[09:29:14.727] - relayed: [n=2] FALSE, FALSE
[09:29:14.727] - queued futures: [n=2] FALSE, FALSE
[09:29:14.727]  - until=1
[09:29:14.727]  - relaying element #1
[09:29:14.727] - relayed: [n=2] TRUE, FALSE
[09:29:14.727] - queued futures: [n=2] TRUE, FALSE
[09:29:14.727] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.727]  length: 1 (resolved future 1)
[09:29:14.728] resolved() for ‘SequentialFuture’ ...
[09:29:14.728] - state: ‘finished’
[09:29:14.728] - run: TRUE
[09:29:14.728] - result: ‘FutureResult’
[09:29:14.728] resolved() for ‘SequentialFuture’ ... done
[09:29:14.728] Future #2
[09:29:14.728] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:29:14.728] - nx: 2
[09:29:14.728] - relay: TRUE
[09:29:14.728] - stdout: TRUE
[09:29:14.728] - signal: TRUE
[09:29:14.729] - resignal: FALSE
[09:29:14.729] - force: TRUE
[09:29:14.729] - relayed: [n=2] TRUE, FALSE
[09:29:14.729] - queued futures: [n=2] TRUE, FALSE
[09:29:14.729]  - until=2
[09:29:14.729]  - relaying element #2
[09:29:14.729] - relayed: [n=2] TRUE, TRUE
[09:29:14.729] - queued futures: [n=2] TRUE, TRUE
[09:29:14.729] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:29:14.729]  length: 0 (resolved future 2)
[09:29:14.730] Relaying remaining futures
[09:29:14.730] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.730] - nx: 2
[09:29:14.730] - relay: TRUE
[09:29:14.730] - stdout: TRUE
[09:29:14.730] - signal: TRUE
[09:29:14.730] - resignal: FALSE
[09:29:14.730] - force: TRUE
[09:29:14.730] - relayed: [n=2] TRUE, TRUE
[09:29:14.730] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:14.730] - relayed: [n=2] TRUE, TRUE
[09:29:14.730] - queued futures: [n=2] TRUE, TRUE
[09:29:14.731] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.731] resolve() on list ... DONE
[09:29:14.731]  - Number of value chunks collected: 2
[09:29:14.731] Resolving 2 futures (chunks) ... DONE
[09:29:14.731] Reducing values from 2 chunks ...
[09:29:14.731]  - Number of values collected after concatenation: 5
[09:29:14.731]  - Number of values expected: 5
[09:29:14.731] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[09:29:14.731] Reducing values from 2 chunks ... DONE
[09:29:14.731] future_mapply() ... DONE
[09:29:14.732] future_mapply() ...
[09:29:14.732] Number of chunks: 1
[09:29:14.732] getGlobalsAndPackagesXApply() ...
[09:29:14.732]  - future.globals: TRUE
[09:29:14.732] getGlobalsAndPackages() ...
[09:29:14.732] Searching for globals...
[09:29:14.733] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:14.733] Searching for globals ... DONE
[09:29:14.734] Resolving globals: FALSE
[09:29:14.734] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:14.734] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:14.734] - globals: [1] ‘FUN’
[09:29:14.734] 
[09:29:14.734] getGlobalsAndPackages() ... DONE
[09:29:14.735]  - globals found/used: [n=1] ‘FUN’
[09:29:14.735]  - needed namespaces: [n=0] 
[09:29:14.735] Finding globals ... DONE
[09:29:14.735] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.735] List of 2
[09:29:14.735]  $ ...future.FUN:function (C, k)  
[09:29:14.735]  $ MoreArgs     : list()
[09:29:14.735]  - attr(*, "where")=List of 2
[09:29:14.735]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.735]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.735]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.735]  - attr(*, "resolved")= logi FALSE
[09:29:14.735]  - attr(*, "total_size")= num NA
[09:29:14.737] Packages to be attached in all futures: [n=0] 
[09:29:14.737] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.737] Number of futures (= number of chunks): 1
[09:29:14.738] Launching 1 futures (chunks) ...
[09:29:14.738] Chunk #1 of 1 ...
[09:29:14.738]  - Finding globals in '...' for chunk #1 ...
[09:29:14.738] getGlobalsAndPackages() ...
[09:29:14.738] Searching for globals...
[09:29:14.738] 
[09:29:14.738] Searching for globals ... DONE
[09:29:14.738] - globals: [0] <none>
[09:29:14.739] getGlobalsAndPackages() ... DONE
[09:29:14.739]    + additional globals found: [n=0] 
[09:29:14.739]    + additional namespaces needed: [n=0] 
[09:29:14.739]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.739]  - seeds: <none>
[09:29:14.739]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.739] getGlobalsAndPackages() ...
[09:29:14.739] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.739] Resolving globals: FALSE
[09:29:14.740] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[09:29:14.740] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:14.740] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.740] 
[09:29:14.740] getGlobalsAndPackages() ... DONE
[09:29:14.741] run() for ‘Future’ ...
[09:29:14.741] - state: ‘created’
[09:29:14.741] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.741] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.741] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.741]   - Field: ‘label’
[09:29:14.741]   - Field: ‘local’
[09:29:14.742]   - Field: ‘owner’
[09:29:14.742]   - Field: ‘envir’
[09:29:14.742]   - Field: ‘packages’
[09:29:14.742]   - Field: ‘gc’
[09:29:14.742]   - Field: ‘conditions’
[09:29:14.742]   - Field: ‘expr’
[09:29:14.742]   - Field: ‘uuid’
[09:29:14.742]   - Field: ‘seed’
[09:29:14.742]   - Field: ‘version’
[09:29:14.742]   - Field: ‘result’
[09:29:14.742]   - Field: ‘asynchronous’
[09:29:14.742]   - Field: ‘calls’
[09:29:14.743]   - Field: ‘globals’
[09:29:14.743]   - Field: ‘stdout’
[09:29:14.743]   - Field: ‘earlySignal’
[09:29:14.743]   - Field: ‘lazy’
[09:29:14.743]   - Field: ‘state’
[09:29:14.743] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.743] - Launch lazy future ...
[09:29:14.743] Packages needed by the future expression (n = 0): <none>
[09:29:14.743] Packages needed by future strategies (n = 0): <none>
[09:29:14.745] {
[09:29:14.745]     {
[09:29:14.745]         {
[09:29:14.745]             ...future.startTime <- base::Sys.time()
[09:29:14.745]             {
[09:29:14.745]                 {
[09:29:14.745]                   {
[09:29:14.745]                     base::local({
[09:29:14.745]                       has_future <- base::requireNamespace("future", 
[09:29:14.745]                         quietly = TRUE)
[09:29:14.745]                       if (has_future) {
[09:29:14.745]                         ns <- base::getNamespace("future")
[09:29:14.745]                         version <- ns[[".package"]][["version"]]
[09:29:14.745]                         if (is.null(version)) 
[09:29:14.745]                           version <- utils::packageVersion("future")
[09:29:14.745]                       }
[09:29:14.745]                       else {
[09:29:14.745]                         version <- NULL
[09:29:14.745]                       }
[09:29:14.745]                       if (!has_future || version < "1.8.0") {
[09:29:14.745]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.745]                           "", base::R.version$version.string), 
[09:29:14.745]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.745]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.745]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.745]                             "release", "version")], collapse = " "), 
[09:29:14.745]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.745]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.745]                           info)
[09:29:14.745]                         info <- base::paste(info, collapse = "; ")
[09:29:14.745]                         if (!has_future) {
[09:29:14.745]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.745]                             info)
[09:29:14.745]                         }
[09:29:14.745]                         else {
[09:29:14.745]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.745]                             info, version)
[09:29:14.745]                         }
[09:29:14.745]                         base::stop(msg)
[09:29:14.745]                       }
[09:29:14.745]                     })
[09:29:14.745]                   }
[09:29:14.745]                   ...future.strategy.old <- future::plan("list")
[09:29:14.745]                   options(future.plan = NULL)
[09:29:14.745]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.745]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.745]                 }
[09:29:14.745]                 ...future.workdir <- getwd()
[09:29:14.745]             }
[09:29:14.745]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.745]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.745]         }
[09:29:14.745]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.745]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.745]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.745]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.745]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.745]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.745]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.745]             base::names(...future.oldOptions))
[09:29:14.745]     }
[09:29:14.745]     if (FALSE) {
[09:29:14.745]     }
[09:29:14.745]     else {
[09:29:14.745]         if (TRUE) {
[09:29:14.745]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.745]                 open = "w")
[09:29:14.745]         }
[09:29:14.745]         else {
[09:29:14.745]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.745]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.745]         }
[09:29:14.745]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.745]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.745]             base::sink(type = "output", split = FALSE)
[09:29:14.745]             base::close(...future.stdout)
[09:29:14.745]         }, add = TRUE)
[09:29:14.745]     }
[09:29:14.745]     ...future.frame <- base::sys.nframe()
[09:29:14.745]     ...future.conditions <- base::list()
[09:29:14.745]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.745]     if (FALSE) {
[09:29:14.745]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.745]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.745]     }
[09:29:14.745]     ...future.result <- base::tryCatch({
[09:29:14.745]         base::withCallingHandlers({
[09:29:14.745]             ...future.value <- base::withVisible(base::local({
[09:29:14.745]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.745]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.745]                   ...future.globals.maxSize)) {
[09:29:14.745]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.745]                   on.exit(options(oopts), add = TRUE)
[09:29:14.745]                 }
[09:29:14.745]                 {
[09:29:14.745]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.745]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.745]                     USE.NAMES = FALSE)
[09:29:14.745]                   do.call(mapply, args = args)
[09:29:14.745]                 }
[09:29:14.745]             }))
[09:29:14.745]             future::FutureResult(value = ...future.value$value, 
[09:29:14.745]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.745]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.745]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.745]                     ...future.globalenv.names))
[09:29:14.745]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.745]         }, condition = base::local({
[09:29:14.745]             c <- base::c
[09:29:14.745]             inherits <- base::inherits
[09:29:14.745]             invokeRestart <- base::invokeRestart
[09:29:14.745]             length <- base::length
[09:29:14.745]             list <- base::list
[09:29:14.745]             seq.int <- base::seq.int
[09:29:14.745]             signalCondition <- base::signalCondition
[09:29:14.745]             sys.calls <- base::sys.calls
[09:29:14.745]             `[[` <- base::`[[`
[09:29:14.745]             `+` <- base::`+`
[09:29:14.745]             `<<-` <- base::`<<-`
[09:29:14.745]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.745]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.745]                   3L)]
[09:29:14.745]             }
[09:29:14.745]             function(cond) {
[09:29:14.745]                 is_error <- inherits(cond, "error")
[09:29:14.745]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.745]                   NULL)
[09:29:14.745]                 if (is_error) {
[09:29:14.745]                   sessionInformation <- function() {
[09:29:14.745]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.745]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.745]                       search = base::search(), system = base::Sys.info())
[09:29:14.745]                   }
[09:29:14.745]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.745]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.745]                     cond$call), session = sessionInformation(), 
[09:29:14.745]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.745]                   signalCondition(cond)
[09:29:14.745]                 }
[09:29:14.745]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.745]                 "immediateCondition"))) {
[09:29:14.745]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.745]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.745]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.745]                   if (TRUE && !signal) {
[09:29:14.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.745]                     {
[09:29:14.745]                       inherits <- base::inherits
[09:29:14.745]                       invokeRestart <- base::invokeRestart
[09:29:14.745]                       is.null <- base::is.null
[09:29:14.745]                       muffled <- FALSE
[09:29:14.745]                       if (inherits(cond, "message")) {
[09:29:14.745]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.745]                         if (muffled) 
[09:29:14.745]                           invokeRestart("muffleMessage")
[09:29:14.745]                       }
[09:29:14.745]                       else if (inherits(cond, "warning")) {
[09:29:14.745]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.745]                         if (muffled) 
[09:29:14.745]                           invokeRestart("muffleWarning")
[09:29:14.745]                       }
[09:29:14.745]                       else if (inherits(cond, "condition")) {
[09:29:14.745]                         if (!is.null(pattern)) {
[09:29:14.745]                           computeRestarts <- base::computeRestarts
[09:29:14.745]                           grepl <- base::grepl
[09:29:14.745]                           restarts <- computeRestarts(cond)
[09:29:14.745]                           for (restart in restarts) {
[09:29:14.745]                             name <- restart$name
[09:29:14.745]                             if (is.null(name)) 
[09:29:14.745]                               next
[09:29:14.745]                             if (!grepl(pattern, name)) 
[09:29:14.745]                               next
[09:29:14.745]                             invokeRestart(restart)
[09:29:14.745]                             muffled <- TRUE
[09:29:14.745]                             break
[09:29:14.745]                           }
[09:29:14.745]                         }
[09:29:14.745]                       }
[09:29:14.745]                       invisible(muffled)
[09:29:14.745]                     }
[09:29:14.745]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.745]                   }
[09:29:14.745]                 }
[09:29:14.745]                 else {
[09:29:14.745]                   if (TRUE) {
[09:29:14.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.745]                     {
[09:29:14.745]                       inherits <- base::inherits
[09:29:14.745]                       invokeRestart <- base::invokeRestart
[09:29:14.745]                       is.null <- base::is.null
[09:29:14.745]                       muffled <- FALSE
[09:29:14.745]                       if (inherits(cond, "message")) {
[09:29:14.745]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.745]                         if (muffled) 
[09:29:14.745]                           invokeRestart("muffleMessage")
[09:29:14.745]                       }
[09:29:14.745]                       else if (inherits(cond, "warning")) {
[09:29:14.745]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.745]                         if (muffled) 
[09:29:14.745]                           invokeRestart("muffleWarning")
[09:29:14.745]                       }
[09:29:14.745]                       else if (inherits(cond, "condition")) {
[09:29:14.745]                         if (!is.null(pattern)) {
[09:29:14.745]                           computeRestarts <- base::computeRestarts
[09:29:14.745]                           grepl <- base::grepl
[09:29:14.745]                           restarts <- computeRestarts(cond)
[09:29:14.745]                           for (restart in restarts) {
[09:29:14.745]                             name <- restart$name
[09:29:14.745]                             if (is.null(name)) 
[09:29:14.745]                               next
[09:29:14.745]                             if (!grepl(pattern, name)) 
[09:29:14.745]                               next
[09:29:14.745]                             invokeRestart(restart)
[09:29:14.745]                             muffled <- TRUE
[09:29:14.745]                             break
[09:29:14.745]                           }
[09:29:14.745]                         }
[09:29:14.745]                       }
[09:29:14.745]                       invisible(muffled)
[09:29:14.745]                     }
[09:29:14.745]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.745]                   }
[09:29:14.745]                 }
[09:29:14.745]             }
[09:29:14.745]         }))
[09:29:14.745]     }, error = function(ex) {
[09:29:14.745]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.745]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.745]                 ...future.rng), started = ...future.startTime, 
[09:29:14.745]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.745]             version = "1.8"), class = "FutureResult")
[09:29:14.745]     }, finally = {
[09:29:14.745]         if (!identical(...future.workdir, getwd())) 
[09:29:14.745]             setwd(...future.workdir)
[09:29:14.745]         {
[09:29:14.745]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.745]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.745]             }
[09:29:14.745]             base::options(...future.oldOptions)
[09:29:14.745]             if (.Platform$OS.type == "windows") {
[09:29:14.745]                 old_names <- names(...future.oldEnvVars)
[09:29:14.745]                 envs <- base::Sys.getenv()
[09:29:14.745]                 names <- names(envs)
[09:29:14.745]                 common <- intersect(names, old_names)
[09:29:14.745]                 added <- setdiff(names, old_names)
[09:29:14.745]                 removed <- setdiff(old_names, names)
[09:29:14.745]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.745]                   envs[common]]
[09:29:14.745]                 NAMES <- toupper(changed)
[09:29:14.745]                 args <- list()
[09:29:14.745]                 for (kk in seq_along(NAMES)) {
[09:29:14.745]                   name <- changed[[kk]]
[09:29:14.745]                   NAME <- NAMES[[kk]]
[09:29:14.745]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.745]                     next
[09:29:14.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.745]                 }
[09:29:14.745]                 NAMES <- toupper(added)
[09:29:14.745]                 for (kk in seq_along(NAMES)) {
[09:29:14.745]                   name <- added[[kk]]
[09:29:14.745]                   NAME <- NAMES[[kk]]
[09:29:14.745]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.745]                     next
[09:29:14.745]                   args[[name]] <- ""
[09:29:14.745]                 }
[09:29:14.745]                 NAMES <- toupper(removed)
[09:29:14.745]                 for (kk in seq_along(NAMES)) {
[09:29:14.745]                   name <- removed[[kk]]
[09:29:14.745]                   NAME <- NAMES[[kk]]
[09:29:14.745]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.745]                     next
[09:29:14.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.745]                 }
[09:29:14.745]                 if (length(args) > 0) 
[09:29:14.745]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.745]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.745]             }
[09:29:14.745]             else {
[09:29:14.745]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.745]             }
[09:29:14.745]             {
[09:29:14.745]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.745]                   0L) {
[09:29:14.745]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.745]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.745]                   base::options(opts)
[09:29:14.745]                 }
[09:29:14.745]                 {
[09:29:14.745]                   {
[09:29:14.745]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.745]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.745]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.745]                     NULL
[09:29:14.745]                   }
[09:29:14.745]                   options(future.plan = NULL)
[09:29:14.745]                   if (is.na(NA_character_)) 
[09:29:14.745]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.745]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.745]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.745]                     .init = FALSE)
[09:29:14.745]                 }
[09:29:14.745]             }
[09:29:14.745]         }
[09:29:14.745]     })
[09:29:14.745]     if (TRUE) {
[09:29:14.745]         base::sink(type = "output", split = FALSE)
[09:29:14.745]         if (TRUE) {
[09:29:14.745]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.745]         }
[09:29:14.745]         else {
[09:29:14.745]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.745]         }
[09:29:14.745]         base::close(...future.stdout)
[09:29:14.745]         ...future.stdout <- NULL
[09:29:14.745]     }
[09:29:14.745]     ...future.result$conditions <- ...future.conditions
[09:29:14.745]     ...future.result$finished <- base::Sys.time()
[09:29:14.745]     ...future.result
[09:29:14.745] }
[09:29:14.748] assign_globals() ...
[09:29:14.748] List of 5
[09:29:14.748]  $ ...future.FUN            :function (C, k)  
[09:29:14.748]  $ MoreArgs                 : list()
[09:29:14.748]  $ ...future.elements_ii    :List of 2
[09:29:14.748]   ..$ :List of 5
[09:29:14.748]   .. ..$ : chr "A"
[09:29:14.748]   .. ..$ : chr "B"
[09:29:14.748]   .. ..$ : chr "C"
[09:29:14.748]   .. ..$ : chr "D"
[09:29:14.748]   .. ..$ : chr "E"
[09:29:14.748]   ..$ :List of 5
[09:29:14.748]   .. ..$ : int 5
[09:29:14.748]   .. ..$ : int 4
[09:29:14.748]   .. ..$ : int 3
[09:29:14.748]   .. ..$ : int 2
[09:29:14.748]   .. ..$ : int 1
[09:29:14.748]  $ ...future.seeds_ii       : NULL
[09:29:14.748]  $ ...future.globals.maxSize: NULL
[09:29:14.748]  - attr(*, "where")=List of 5
[09:29:14.748]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.748]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.748]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.748]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.748]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.748]  - attr(*, "resolved")= logi FALSE
[09:29:14.748]  - attr(*, "total_size")= num 4160
[09:29:14.748]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.748]  - attr(*, "already-done")= logi TRUE
[09:29:14.755] - reassign environment for ‘...future.FUN’
[09:29:14.755] - copied ‘...future.FUN’ to environment
[09:29:14.755] - copied ‘MoreArgs’ to environment
[09:29:14.755] - copied ‘...future.elements_ii’ to environment
[09:29:14.756] - copied ‘...future.seeds_ii’ to environment
[09:29:14.756] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.756] assign_globals() ... done
[09:29:14.756] plan(): Setting new future strategy stack:
[09:29:14.756] List of future strategies:
[09:29:14.756] 1. sequential:
[09:29:14.756]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.756]    - tweaked: FALSE
[09:29:14.756]    - call: NULL
[09:29:14.756] plan(): nbrOfWorkers() = 1
[09:29:14.757] plan(): Setting new future strategy stack:
[09:29:14.757] List of future strategies:
[09:29:14.757] 1. sequential:
[09:29:14.757]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.757]    - tweaked: FALSE
[09:29:14.757]    - call: plan(strategy)
[09:29:14.758] plan(): nbrOfWorkers() = 1
[09:29:14.758] SequentialFuture started (and completed)
[09:29:14.758] - Launch lazy future ... done
[09:29:14.758] run() for ‘SequentialFuture’ ... done
[09:29:14.758] Created future:
[09:29:14.758] SequentialFuture:
[09:29:14.758] Label: ‘future_.mapply-1’
[09:29:14.758] Expression:
[09:29:14.758] {
[09:29:14.758]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.758]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.758]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.758]         on.exit(options(oopts), add = TRUE)
[09:29:14.758]     }
[09:29:14.758]     {
[09:29:14.758]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.758]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.758]         do.call(mapply, args = args)
[09:29:14.758]     }
[09:29:14.758] }
[09:29:14.758] Lazy evaluation: FALSE
[09:29:14.758] Asynchronous evaluation: FALSE
[09:29:14.758] Local evaluation: TRUE
[09:29:14.758] Environment: R_GlobalEnv
[09:29:14.758] Capture standard output: TRUE
[09:29:14.758] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.758] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.758] Packages: <none>
[09:29:14.758] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.758] Resolved: TRUE
[09:29:14.758] Value: 560 bytes of class ‘list’
[09:29:14.758] Early signaling: FALSE
[09:29:14.758] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.758] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.759] Chunk #1 of 1 ... DONE
[09:29:14.759] Launching 1 futures (chunks) ... DONE
[09:29:14.759] Resolving 1 futures (chunks) ...
[09:29:14.759] resolve() on list ...
[09:29:14.759]  recursive: 0
[09:29:14.759]  length: 1
[09:29:14.760] 
[09:29:14.760] resolved() for ‘SequentialFuture’ ...
[09:29:14.760] - state: ‘finished’
[09:29:14.760] - run: TRUE
[09:29:14.760] - result: ‘FutureResult’
[09:29:14.760] resolved() for ‘SequentialFuture’ ... done
[09:29:14.760] Future #1
[09:29:14.760] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.760] - nx: 1
[09:29:14.760] - relay: TRUE
[09:29:14.760] - stdout: TRUE
[09:29:14.761] - signal: TRUE
[09:29:14.761] - resignal: FALSE
[09:29:14.761] - force: TRUE
[09:29:14.761] - relayed: [n=1] FALSE
[09:29:14.761] - queued futures: [n=1] FALSE
[09:29:14.761]  - until=1
[09:29:14.761]  - relaying element #1
[09:29:14.761] - relayed: [n=1] TRUE
[09:29:14.761] - queued futures: [n=1] TRUE
[09:29:14.761] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.761]  length: 0 (resolved future 1)
[09:29:14.762] Relaying remaining futures
[09:29:14.762] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.762] - nx: 1
[09:29:14.762] - relay: TRUE
[09:29:14.762] - stdout: TRUE
[09:29:14.762] - signal: TRUE
[09:29:14.762] - resignal: FALSE
[09:29:14.762] - force: TRUE
[09:29:14.762] - relayed: [n=1] TRUE
[09:29:14.762] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.762] - relayed: [n=1] TRUE
[09:29:14.763] - queued futures: [n=1] TRUE
[09:29:14.763] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.763] resolve() on list ... DONE
[09:29:14.763]  - Number of value chunks collected: 1
[09:29:14.763] Resolving 1 futures (chunks) ... DONE
[09:29:14.763] Reducing values from 1 chunks ...
[09:29:14.763]  - Number of values collected after concatenation: 5
[09:29:14.763]  - Number of values expected: 5
[09:29:14.763] Reducing values from 1 chunks ... DONE
[09:29:14.763] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[09:29:14.764] future_mapply() ...
[09:29:14.764] Number of chunks: 1
[09:29:14.764] getGlobalsAndPackagesXApply() ...
[09:29:14.764]  - future.globals: TRUE
[09:29:14.764] getGlobalsAndPackages() ...
[09:29:14.764] Searching for globals...
[09:29:14.765] - globals found: [1] ‘FUN’
[09:29:14.765] Searching for globals ... DONE
[09:29:14.765] Resolving globals: FALSE
[09:29:14.766] The total size of the 1 globals is 848 bytes (848 bytes)
[09:29:14.766] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:29:14.766] - globals: [1] ‘FUN’
[09:29:14.766] 
[09:29:14.766] getGlobalsAndPackages() ... DONE
[09:29:14.766]  - globals found/used: [n=1] ‘FUN’
[09:29:14.766]  - needed namespaces: [n=0] 
[09:29:14.767] Finding globals ... DONE
[09:29:14.767] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.767] List of 2
[09:29:14.767]  $ ...future.FUN:function (x)  
[09:29:14.767]  $ MoreArgs     : NULL
[09:29:14.767]  - attr(*, "where")=List of 2
[09:29:14.767]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.767]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.767]  - attr(*, "resolved")= logi FALSE
[09:29:14.767]  - attr(*, "total_size")= num NA
[09:29:14.770] Packages to be attached in all futures: [n=0] 
[09:29:14.770] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.770] Number of futures (= number of chunks): 1
[09:29:14.770] Launching 1 futures (chunks) ...
[09:29:14.771] Chunk #1 of 1 ...
[09:29:14.771]  - Finding globals in '...' for chunk #1 ...
[09:29:14.771] getGlobalsAndPackages() ...
[09:29:14.771] Searching for globals...
[09:29:14.771] 
[09:29:14.771] Searching for globals ... DONE
[09:29:14.771] - globals: [0] <none>
[09:29:14.771] getGlobalsAndPackages() ... DONE
[09:29:14.772]    + additional globals found: [n=0] 
[09:29:14.772]    + additional namespaces needed: [n=0] 
[09:29:14.772]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.772]  - seeds: <none>
[09:29:14.772]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.772] getGlobalsAndPackages() ...
[09:29:14.772] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.772] Resolving globals: FALSE
[09:29:14.773] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[09:29:14.773] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.773] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.773] 
[09:29:14.773] getGlobalsAndPackages() ... DONE
[09:29:14.774] run() for ‘Future’ ...
[09:29:14.774] - state: ‘created’
[09:29:14.774] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.774] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.774] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.774]   - Field: ‘label’
[09:29:14.774]   - Field: ‘local’
[09:29:14.774]   - Field: ‘owner’
[09:29:14.775]   - Field: ‘envir’
[09:29:14.775]   - Field: ‘packages’
[09:29:14.775]   - Field: ‘gc’
[09:29:14.775]   - Field: ‘conditions’
[09:29:14.775]   - Field: ‘expr’
[09:29:14.775]   - Field: ‘uuid’
[09:29:14.775]   - Field: ‘seed’
[09:29:14.775]   - Field: ‘version’
[09:29:14.775]   - Field: ‘result’
[09:29:14.775]   - Field: ‘asynchronous’
[09:29:14.775]   - Field: ‘calls’
[09:29:14.775]   - Field: ‘globals’
[09:29:14.776]   - Field: ‘stdout’
[09:29:14.776]   - Field: ‘earlySignal’
[09:29:14.776]   - Field: ‘lazy’
[09:29:14.776]   - Field: ‘state’
[09:29:14.776] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.776] - Launch lazy future ...
[09:29:14.776] Packages needed by the future expression (n = 0): <none>
[09:29:14.776] Packages needed by future strategies (n = 0): <none>
[09:29:14.777] {
[09:29:14.777]     {
[09:29:14.777]         {
[09:29:14.777]             ...future.startTime <- base::Sys.time()
[09:29:14.777]             {
[09:29:14.777]                 {
[09:29:14.777]                   {
[09:29:14.777]                     base::local({
[09:29:14.777]                       has_future <- base::requireNamespace("future", 
[09:29:14.777]                         quietly = TRUE)
[09:29:14.777]                       if (has_future) {
[09:29:14.777]                         ns <- base::getNamespace("future")
[09:29:14.777]                         version <- ns[[".package"]][["version"]]
[09:29:14.777]                         if (is.null(version)) 
[09:29:14.777]                           version <- utils::packageVersion("future")
[09:29:14.777]                       }
[09:29:14.777]                       else {
[09:29:14.777]                         version <- NULL
[09:29:14.777]                       }
[09:29:14.777]                       if (!has_future || version < "1.8.0") {
[09:29:14.777]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.777]                           "", base::R.version$version.string), 
[09:29:14.777]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.777]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.777]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.777]                             "release", "version")], collapse = " "), 
[09:29:14.777]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.777]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.777]                           info)
[09:29:14.777]                         info <- base::paste(info, collapse = "; ")
[09:29:14.777]                         if (!has_future) {
[09:29:14.777]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.777]                             info)
[09:29:14.777]                         }
[09:29:14.777]                         else {
[09:29:14.777]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.777]                             info, version)
[09:29:14.777]                         }
[09:29:14.777]                         base::stop(msg)
[09:29:14.777]                       }
[09:29:14.777]                     })
[09:29:14.777]                   }
[09:29:14.777]                   ...future.strategy.old <- future::plan("list")
[09:29:14.777]                   options(future.plan = NULL)
[09:29:14.777]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.777]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.777]                 }
[09:29:14.777]                 ...future.workdir <- getwd()
[09:29:14.777]             }
[09:29:14.777]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.777]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.777]         }
[09:29:14.777]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.777]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.777]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.777]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.777]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.777]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.777]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.777]             base::names(...future.oldOptions))
[09:29:14.777]     }
[09:29:14.777]     if (FALSE) {
[09:29:14.777]     }
[09:29:14.777]     else {
[09:29:14.777]         if (TRUE) {
[09:29:14.777]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.777]                 open = "w")
[09:29:14.777]         }
[09:29:14.777]         else {
[09:29:14.777]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.777]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.777]         }
[09:29:14.777]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.777]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.777]             base::sink(type = "output", split = FALSE)
[09:29:14.777]             base::close(...future.stdout)
[09:29:14.777]         }, add = TRUE)
[09:29:14.777]     }
[09:29:14.777]     ...future.frame <- base::sys.nframe()
[09:29:14.777]     ...future.conditions <- base::list()
[09:29:14.777]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.777]     if (FALSE) {
[09:29:14.777]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.777]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.777]     }
[09:29:14.777]     ...future.result <- base::tryCatch({
[09:29:14.777]         base::withCallingHandlers({
[09:29:14.777]             ...future.value <- base::withVisible(base::local({
[09:29:14.777]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.777]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.777]                   ...future.globals.maxSize)) {
[09:29:14.777]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.777]                   on.exit(options(oopts), add = TRUE)
[09:29:14.777]                 }
[09:29:14.777]                 {
[09:29:14.777]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.777]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.777]                     USE.NAMES = FALSE)
[09:29:14.777]                   do.call(mapply, args = args)
[09:29:14.777]                 }
[09:29:14.777]             }))
[09:29:14.777]             future::FutureResult(value = ...future.value$value, 
[09:29:14.777]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.777]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.777]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.777]                     ...future.globalenv.names))
[09:29:14.777]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.777]         }, condition = base::local({
[09:29:14.777]             c <- base::c
[09:29:14.777]             inherits <- base::inherits
[09:29:14.777]             invokeRestart <- base::invokeRestart
[09:29:14.777]             length <- base::length
[09:29:14.777]             list <- base::list
[09:29:14.777]             seq.int <- base::seq.int
[09:29:14.777]             signalCondition <- base::signalCondition
[09:29:14.777]             sys.calls <- base::sys.calls
[09:29:14.777]             `[[` <- base::`[[`
[09:29:14.777]             `+` <- base::`+`
[09:29:14.777]             `<<-` <- base::`<<-`
[09:29:14.777]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.777]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.777]                   3L)]
[09:29:14.777]             }
[09:29:14.777]             function(cond) {
[09:29:14.777]                 is_error <- inherits(cond, "error")
[09:29:14.777]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.777]                   NULL)
[09:29:14.777]                 if (is_error) {
[09:29:14.777]                   sessionInformation <- function() {
[09:29:14.777]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.777]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.777]                       search = base::search(), system = base::Sys.info())
[09:29:14.777]                   }
[09:29:14.777]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.777]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.777]                     cond$call), session = sessionInformation(), 
[09:29:14.777]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.777]                   signalCondition(cond)
[09:29:14.777]                 }
[09:29:14.777]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.777]                 "immediateCondition"))) {
[09:29:14.777]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.777]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.777]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.777]                   if (TRUE && !signal) {
[09:29:14.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.777]                     {
[09:29:14.777]                       inherits <- base::inherits
[09:29:14.777]                       invokeRestart <- base::invokeRestart
[09:29:14.777]                       is.null <- base::is.null
[09:29:14.777]                       muffled <- FALSE
[09:29:14.777]                       if (inherits(cond, "message")) {
[09:29:14.777]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.777]                         if (muffled) 
[09:29:14.777]                           invokeRestart("muffleMessage")
[09:29:14.777]                       }
[09:29:14.777]                       else if (inherits(cond, "warning")) {
[09:29:14.777]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.777]                         if (muffled) 
[09:29:14.777]                           invokeRestart("muffleWarning")
[09:29:14.777]                       }
[09:29:14.777]                       else if (inherits(cond, "condition")) {
[09:29:14.777]                         if (!is.null(pattern)) {
[09:29:14.777]                           computeRestarts <- base::computeRestarts
[09:29:14.777]                           grepl <- base::grepl
[09:29:14.777]                           restarts <- computeRestarts(cond)
[09:29:14.777]                           for (restart in restarts) {
[09:29:14.777]                             name <- restart$name
[09:29:14.777]                             if (is.null(name)) 
[09:29:14.777]                               next
[09:29:14.777]                             if (!grepl(pattern, name)) 
[09:29:14.777]                               next
[09:29:14.777]                             invokeRestart(restart)
[09:29:14.777]                             muffled <- TRUE
[09:29:14.777]                             break
[09:29:14.777]                           }
[09:29:14.777]                         }
[09:29:14.777]                       }
[09:29:14.777]                       invisible(muffled)
[09:29:14.777]                     }
[09:29:14.777]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.777]                   }
[09:29:14.777]                 }
[09:29:14.777]                 else {
[09:29:14.777]                   if (TRUE) {
[09:29:14.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.777]                     {
[09:29:14.777]                       inherits <- base::inherits
[09:29:14.777]                       invokeRestart <- base::invokeRestart
[09:29:14.777]                       is.null <- base::is.null
[09:29:14.777]                       muffled <- FALSE
[09:29:14.777]                       if (inherits(cond, "message")) {
[09:29:14.777]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.777]                         if (muffled) 
[09:29:14.777]                           invokeRestart("muffleMessage")
[09:29:14.777]                       }
[09:29:14.777]                       else if (inherits(cond, "warning")) {
[09:29:14.777]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.777]                         if (muffled) 
[09:29:14.777]                           invokeRestart("muffleWarning")
[09:29:14.777]                       }
[09:29:14.777]                       else if (inherits(cond, "condition")) {
[09:29:14.777]                         if (!is.null(pattern)) {
[09:29:14.777]                           computeRestarts <- base::computeRestarts
[09:29:14.777]                           grepl <- base::grepl
[09:29:14.777]                           restarts <- computeRestarts(cond)
[09:29:14.777]                           for (restart in restarts) {
[09:29:14.777]                             name <- restart$name
[09:29:14.777]                             if (is.null(name)) 
[09:29:14.777]                               next
[09:29:14.777]                             if (!grepl(pattern, name)) 
[09:29:14.777]                               next
[09:29:14.777]                             invokeRestart(restart)
[09:29:14.777]                             muffled <- TRUE
[09:29:14.777]                             break
[09:29:14.777]                           }
[09:29:14.777]                         }
[09:29:14.777]                       }
[09:29:14.777]                       invisible(muffled)
[09:29:14.777]                     }
[09:29:14.777]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.777]                   }
[09:29:14.777]                 }
[09:29:14.777]             }
[09:29:14.777]         }))
[09:29:14.777]     }, error = function(ex) {
[09:29:14.777]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.777]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.777]                 ...future.rng), started = ...future.startTime, 
[09:29:14.777]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.777]             version = "1.8"), class = "FutureResult")
[09:29:14.777]     }, finally = {
[09:29:14.777]         if (!identical(...future.workdir, getwd())) 
[09:29:14.777]             setwd(...future.workdir)
[09:29:14.777]         {
[09:29:14.777]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.777]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.777]             }
[09:29:14.777]             base::options(...future.oldOptions)
[09:29:14.777]             if (.Platform$OS.type == "windows") {
[09:29:14.777]                 old_names <- names(...future.oldEnvVars)
[09:29:14.777]                 envs <- base::Sys.getenv()
[09:29:14.777]                 names <- names(envs)
[09:29:14.777]                 common <- intersect(names, old_names)
[09:29:14.777]                 added <- setdiff(names, old_names)
[09:29:14.777]                 removed <- setdiff(old_names, names)
[09:29:14.777]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.777]                   envs[common]]
[09:29:14.777]                 NAMES <- toupper(changed)
[09:29:14.777]                 args <- list()
[09:29:14.777]                 for (kk in seq_along(NAMES)) {
[09:29:14.777]                   name <- changed[[kk]]
[09:29:14.777]                   NAME <- NAMES[[kk]]
[09:29:14.777]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.777]                     next
[09:29:14.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.777]                 }
[09:29:14.777]                 NAMES <- toupper(added)
[09:29:14.777]                 for (kk in seq_along(NAMES)) {
[09:29:14.777]                   name <- added[[kk]]
[09:29:14.777]                   NAME <- NAMES[[kk]]
[09:29:14.777]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.777]                     next
[09:29:14.777]                   args[[name]] <- ""
[09:29:14.777]                 }
[09:29:14.777]                 NAMES <- toupper(removed)
[09:29:14.777]                 for (kk in seq_along(NAMES)) {
[09:29:14.777]                   name <- removed[[kk]]
[09:29:14.777]                   NAME <- NAMES[[kk]]
[09:29:14.777]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.777]                     next
[09:29:14.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.777]                 }
[09:29:14.777]                 if (length(args) > 0) 
[09:29:14.777]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.777]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.777]             }
[09:29:14.777]             else {
[09:29:14.777]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.777]             }
[09:29:14.777]             {
[09:29:14.777]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.777]                   0L) {
[09:29:14.777]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.777]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.777]                   base::options(opts)
[09:29:14.777]                 }
[09:29:14.777]                 {
[09:29:14.777]                   {
[09:29:14.777]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.777]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.777]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.777]                     NULL
[09:29:14.777]                   }
[09:29:14.777]                   options(future.plan = NULL)
[09:29:14.777]                   if (is.na(NA_character_)) 
[09:29:14.777]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.777]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.777]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.777]                     .init = FALSE)
[09:29:14.777]                 }
[09:29:14.777]             }
[09:29:14.777]         }
[09:29:14.777]     })
[09:29:14.777]     if (TRUE) {
[09:29:14.777]         base::sink(type = "output", split = FALSE)
[09:29:14.777]         if (TRUE) {
[09:29:14.777]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.777]         }
[09:29:14.777]         else {
[09:29:14.777]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.777]         }
[09:29:14.777]         base::close(...future.stdout)
[09:29:14.777]         ...future.stdout <- NULL
[09:29:14.777]     }
[09:29:14.777]     ...future.result$conditions <- ...future.conditions
[09:29:14.777]     ...future.result$finished <- base::Sys.time()
[09:29:14.777]     ...future.result
[09:29:14.777] }
[09:29:14.778] assign_globals() ...
[09:29:14.778] List of 5
[09:29:14.778]  $ ...future.FUN            :function (x)  
[09:29:14.778]  $ MoreArgs                 : NULL
[09:29:14.778]  $ ...future.elements_ii    :List of 1
[09:29:14.778]   ..$ :List of 1
[09:29:14.778]   .. ..$ : Date[1:1], format: "2018-06-01"
[09:29:14.778]  $ ...future.seeds_ii       : NULL
[09:29:14.778]  $ ...future.globals.maxSize: NULL
[09:29:14.778]  - attr(*, "where")=List of 5
[09:29:14.778]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.778]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.778]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.778]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.778]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.778]  - attr(*, "resolved")= logi FALSE
[09:29:14.778]  - attr(*, "total_size")= num 1128
[09:29:14.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.778]  - attr(*, "already-done")= logi TRUE
[09:29:14.783] - copied ‘...future.FUN’ to environment
[09:29:14.783] - copied ‘MoreArgs’ to environment
[09:29:14.783] - copied ‘...future.elements_ii’ to environment
[09:29:14.783] - copied ‘...future.seeds_ii’ to environment
[09:29:14.783] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.783] assign_globals() ... done
[09:29:14.784] plan(): Setting new future strategy stack:
[09:29:14.784] List of future strategies:
[09:29:14.784] 1. sequential:
[09:29:14.784]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.784]    - tweaked: FALSE
[09:29:14.784]    - call: NULL
[09:29:14.784] plan(): nbrOfWorkers() = 1
[09:29:14.785] plan(): Setting new future strategy stack:
[09:29:14.785] List of future strategies:
[09:29:14.785] 1. sequential:
[09:29:14.785]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.785]    - tweaked: FALSE
[09:29:14.785]    - call: plan(strategy)
[09:29:14.785] plan(): nbrOfWorkers() = 1
[09:29:14.785] SequentialFuture started (and completed)
[09:29:14.786] - Launch lazy future ... done
[09:29:14.786] run() for ‘SequentialFuture’ ... done
[09:29:14.786] Created future:
[09:29:14.786] SequentialFuture:
[09:29:14.786] Label: ‘future_mapply-1’
[09:29:14.786] Expression:
[09:29:14.786] {
[09:29:14.786]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.786]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.786]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.786]         on.exit(options(oopts), add = TRUE)
[09:29:14.786]     }
[09:29:14.786]     {
[09:29:14.786]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.786]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.786]         do.call(mapply, args = args)
[09:29:14.786]     }
[09:29:14.786] }
[09:29:14.786] Lazy evaluation: FALSE
[09:29:14.786] Asynchronous evaluation: FALSE
[09:29:14.786] Local evaluation: TRUE
[09:29:14.786] Environment: R_GlobalEnv
[09:29:14.786] Capture standard output: TRUE
[09:29:14.786] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.786] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.786] Packages: <none>
[09:29:14.786] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.786] Resolved: TRUE
[09:29:14.786] Value: 280 bytes of class ‘list’
[09:29:14.786] Early signaling: FALSE
[09:29:14.786] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.786] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.787] Chunk #1 of 1 ... DONE
[09:29:14.787] Launching 1 futures (chunks) ... DONE
[09:29:14.787] Resolving 1 futures (chunks) ...
[09:29:14.787] resolve() on list ...
[09:29:14.787]  recursive: 0
[09:29:14.787]  length: 1
[09:29:14.787] 
[09:29:14.787] resolved() for ‘SequentialFuture’ ...
[09:29:14.787] - state: ‘finished’
[09:29:14.787] - run: TRUE
[09:29:14.788] - result: ‘FutureResult’
[09:29:14.788] resolved() for ‘SequentialFuture’ ... done
[09:29:14.788] Future #1
[09:29:14.788] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.788] - nx: 1
[09:29:14.788] - relay: TRUE
[09:29:14.788] - stdout: TRUE
[09:29:14.788] - signal: TRUE
[09:29:14.788] - resignal: FALSE
[09:29:14.788] - force: TRUE
[09:29:14.788] - relayed: [n=1] FALSE
[09:29:14.788] - queued futures: [n=1] FALSE
[09:29:14.789]  - until=1
[09:29:14.789]  - relaying element #1
[09:29:14.789] - relayed: [n=1] TRUE
[09:29:14.789] - queued futures: [n=1] TRUE
[09:29:14.789] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.789]  length: 0 (resolved future 1)
[09:29:14.789] Relaying remaining futures
[09:29:14.789] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.789] - nx: 1
[09:29:14.790] - relay: TRUE
[09:29:14.790] - stdout: TRUE
[09:29:14.790] - signal: TRUE
[09:29:14.790] - resignal: FALSE
[09:29:14.790] - force: TRUE
[09:29:14.790] - relayed: [n=1] TRUE
[09:29:14.790] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.790] - relayed: [n=1] TRUE
[09:29:14.790] - queued futures: [n=1] TRUE
[09:29:14.790] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.790] resolve() on list ... DONE
[09:29:14.791]  - Number of value chunks collected: 1
[09:29:14.791] Resolving 1 futures (chunks) ... DONE
[09:29:14.791] Reducing values from 1 chunks ...
[09:29:14.791]  - Number of values collected after concatenation: 1
[09:29:14.791]  - Number of values expected: 1
[09:29:14.791] Reducing values from 1 chunks ... DONE
[09:29:14.791] future_mapply() ... DONE
[09:29:14.791] future_mapply() ...
[09:29:14.791] Number of chunks: 1
[09:29:14.791] getGlobalsAndPackagesXApply() ...
[09:29:14.792]  - future.globals: TRUE
[09:29:14.792] getGlobalsAndPackages() ...
[09:29:14.792] Searching for globals...
[09:29:14.793] - globals found: [1] ‘FUN’
[09:29:14.793] Searching for globals ... DONE
[09:29:14.793] Resolving globals: FALSE
[09:29:14.794] The total size of the 1 globals is 848 bytes (848 bytes)
[09:29:14.795] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:29:14.795] - globals: [1] ‘FUN’
[09:29:14.795] 
[09:29:14.795] getGlobalsAndPackages() ... DONE
[09:29:14.795]  - globals found/used: [n=1] ‘FUN’
[09:29:14.795]  - needed namespaces: [n=0] 
[09:29:14.795] Finding globals ... DONE
[09:29:14.795] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.796] List of 2
[09:29:14.796]  $ ...future.FUN:function (x)  
[09:29:14.796]  $ MoreArgs     : list()
[09:29:14.796]  - attr(*, "where")=List of 2
[09:29:14.796]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.796]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.796]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.796]  - attr(*, "resolved")= logi FALSE
[09:29:14.796]  - attr(*, "total_size")= num NA
[09:29:14.798] Packages to be attached in all futures: [n=0] 
[09:29:14.798] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.798] Number of futures (= number of chunks): 1
[09:29:14.798] Launching 1 futures (chunks) ...
[09:29:14.798] Chunk #1 of 1 ...
[09:29:14.798]  - Finding globals in '...' for chunk #1 ...
[09:29:14.799] getGlobalsAndPackages() ...
[09:29:14.799] Searching for globals...
[09:29:14.799] 
[09:29:14.799] Searching for globals ... DONE
[09:29:14.799] - globals: [0] <none>
[09:29:14.799] getGlobalsAndPackages() ... DONE
[09:29:14.799]    + additional globals found: [n=0] 
[09:29:14.799]    + additional namespaces needed: [n=0] 
[09:29:14.799]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.800]  - seeds: <none>
[09:29:14.800]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.800] getGlobalsAndPackages() ...
[09:29:14.800] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.800] Resolving globals: FALSE
[09:29:14.800] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[09:29:14.801] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:14.801] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.801] 
[09:29:14.801] getGlobalsAndPackages() ... DONE
[09:29:14.801] run() for ‘Future’ ...
[09:29:14.801] - state: ‘created’
[09:29:14.802] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.802] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.802] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.802]   - Field: ‘label’
[09:29:14.802]   - Field: ‘local’
[09:29:14.802]   - Field: ‘owner’
[09:29:14.802]   - Field: ‘envir’
[09:29:14.802]   - Field: ‘packages’
[09:29:14.802]   - Field: ‘gc’
[09:29:14.802]   - Field: ‘conditions’
[09:29:14.803]   - Field: ‘expr’
[09:29:14.803]   - Field: ‘uuid’
[09:29:14.803]   - Field: ‘seed’
[09:29:14.803]   - Field: ‘version’
[09:29:14.803]   - Field: ‘result’
[09:29:14.803]   - Field: ‘asynchronous’
[09:29:14.803]   - Field: ‘calls’
[09:29:14.803]   - Field: ‘globals’
[09:29:14.803]   - Field: ‘stdout’
[09:29:14.803]   - Field: ‘earlySignal’
[09:29:14.803]   - Field: ‘lazy’
[09:29:14.803]   - Field: ‘state’
[09:29:14.804] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.804] - Launch lazy future ...
[09:29:14.804] Packages needed by the future expression (n = 0): <none>
[09:29:14.804] Packages needed by future strategies (n = 0): <none>
[09:29:14.804] {
[09:29:14.804]     {
[09:29:14.804]         {
[09:29:14.804]             ...future.startTime <- base::Sys.time()
[09:29:14.804]             {
[09:29:14.804]                 {
[09:29:14.804]                   {
[09:29:14.804]                     base::local({
[09:29:14.804]                       has_future <- base::requireNamespace("future", 
[09:29:14.804]                         quietly = TRUE)
[09:29:14.804]                       if (has_future) {
[09:29:14.804]                         ns <- base::getNamespace("future")
[09:29:14.804]                         version <- ns[[".package"]][["version"]]
[09:29:14.804]                         if (is.null(version)) 
[09:29:14.804]                           version <- utils::packageVersion("future")
[09:29:14.804]                       }
[09:29:14.804]                       else {
[09:29:14.804]                         version <- NULL
[09:29:14.804]                       }
[09:29:14.804]                       if (!has_future || version < "1.8.0") {
[09:29:14.804]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.804]                           "", base::R.version$version.string), 
[09:29:14.804]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.804]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.804]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.804]                             "release", "version")], collapse = " "), 
[09:29:14.804]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.804]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.804]                           info)
[09:29:14.804]                         info <- base::paste(info, collapse = "; ")
[09:29:14.804]                         if (!has_future) {
[09:29:14.804]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.804]                             info)
[09:29:14.804]                         }
[09:29:14.804]                         else {
[09:29:14.804]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.804]                             info, version)
[09:29:14.804]                         }
[09:29:14.804]                         base::stop(msg)
[09:29:14.804]                       }
[09:29:14.804]                     })
[09:29:14.804]                   }
[09:29:14.804]                   ...future.strategy.old <- future::plan("list")
[09:29:14.804]                   options(future.plan = NULL)
[09:29:14.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.804]                 }
[09:29:14.804]                 ...future.workdir <- getwd()
[09:29:14.804]             }
[09:29:14.804]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.804]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.804]         }
[09:29:14.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.804]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.804]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.804]             base::names(...future.oldOptions))
[09:29:14.804]     }
[09:29:14.804]     if (FALSE) {
[09:29:14.804]     }
[09:29:14.804]     else {
[09:29:14.804]         if (TRUE) {
[09:29:14.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.804]                 open = "w")
[09:29:14.804]         }
[09:29:14.804]         else {
[09:29:14.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.804]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.804]         }
[09:29:14.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.804]             base::sink(type = "output", split = FALSE)
[09:29:14.804]             base::close(...future.stdout)
[09:29:14.804]         }, add = TRUE)
[09:29:14.804]     }
[09:29:14.804]     ...future.frame <- base::sys.nframe()
[09:29:14.804]     ...future.conditions <- base::list()
[09:29:14.804]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.804]     if (FALSE) {
[09:29:14.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.804]     }
[09:29:14.804]     ...future.result <- base::tryCatch({
[09:29:14.804]         base::withCallingHandlers({
[09:29:14.804]             ...future.value <- base::withVisible(base::local({
[09:29:14.804]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.804]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.804]                   ...future.globals.maxSize)) {
[09:29:14.804]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.804]                   on.exit(options(oopts), add = TRUE)
[09:29:14.804]                 }
[09:29:14.804]                 {
[09:29:14.804]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.804]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.804]                     USE.NAMES = FALSE)
[09:29:14.804]                   do.call(mapply, args = args)
[09:29:14.804]                 }
[09:29:14.804]             }))
[09:29:14.804]             future::FutureResult(value = ...future.value$value, 
[09:29:14.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.804]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.804]                     ...future.globalenv.names))
[09:29:14.804]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.804]         }, condition = base::local({
[09:29:14.804]             c <- base::c
[09:29:14.804]             inherits <- base::inherits
[09:29:14.804]             invokeRestart <- base::invokeRestart
[09:29:14.804]             length <- base::length
[09:29:14.804]             list <- base::list
[09:29:14.804]             seq.int <- base::seq.int
[09:29:14.804]             signalCondition <- base::signalCondition
[09:29:14.804]             sys.calls <- base::sys.calls
[09:29:14.804]             `[[` <- base::`[[`
[09:29:14.804]             `+` <- base::`+`
[09:29:14.804]             `<<-` <- base::`<<-`
[09:29:14.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.804]                   3L)]
[09:29:14.804]             }
[09:29:14.804]             function(cond) {
[09:29:14.804]                 is_error <- inherits(cond, "error")
[09:29:14.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.804]                   NULL)
[09:29:14.804]                 if (is_error) {
[09:29:14.804]                   sessionInformation <- function() {
[09:29:14.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.804]                       search = base::search(), system = base::Sys.info())
[09:29:14.804]                   }
[09:29:14.804]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.804]                     cond$call), session = sessionInformation(), 
[09:29:14.804]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.804]                   signalCondition(cond)
[09:29:14.804]                 }
[09:29:14.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.804]                 "immediateCondition"))) {
[09:29:14.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.804]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.804]                   if (TRUE && !signal) {
[09:29:14.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.804]                     {
[09:29:14.804]                       inherits <- base::inherits
[09:29:14.804]                       invokeRestart <- base::invokeRestart
[09:29:14.804]                       is.null <- base::is.null
[09:29:14.804]                       muffled <- FALSE
[09:29:14.804]                       if (inherits(cond, "message")) {
[09:29:14.804]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.804]                         if (muffled) 
[09:29:14.804]                           invokeRestart("muffleMessage")
[09:29:14.804]                       }
[09:29:14.804]                       else if (inherits(cond, "warning")) {
[09:29:14.804]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.804]                         if (muffled) 
[09:29:14.804]                           invokeRestart("muffleWarning")
[09:29:14.804]                       }
[09:29:14.804]                       else if (inherits(cond, "condition")) {
[09:29:14.804]                         if (!is.null(pattern)) {
[09:29:14.804]                           computeRestarts <- base::computeRestarts
[09:29:14.804]                           grepl <- base::grepl
[09:29:14.804]                           restarts <- computeRestarts(cond)
[09:29:14.804]                           for (restart in restarts) {
[09:29:14.804]                             name <- restart$name
[09:29:14.804]                             if (is.null(name)) 
[09:29:14.804]                               next
[09:29:14.804]                             if (!grepl(pattern, name)) 
[09:29:14.804]                               next
[09:29:14.804]                             invokeRestart(restart)
[09:29:14.804]                             muffled <- TRUE
[09:29:14.804]                             break
[09:29:14.804]                           }
[09:29:14.804]                         }
[09:29:14.804]                       }
[09:29:14.804]                       invisible(muffled)
[09:29:14.804]                     }
[09:29:14.804]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.804]                   }
[09:29:14.804]                 }
[09:29:14.804]                 else {
[09:29:14.804]                   if (TRUE) {
[09:29:14.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.804]                     {
[09:29:14.804]                       inherits <- base::inherits
[09:29:14.804]                       invokeRestart <- base::invokeRestart
[09:29:14.804]                       is.null <- base::is.null
[09:29:14.804]                       muffled <- FALSE
[09:29:14.804]                       if (inherits(cond, "message")) {
[09:29:14.804]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.804]                         if (muffled) 
[09:29:14.804]                           invokeRestart("muffleMessage")
[09:29:14.804]                       }
[09:29:14.804]                       else if (inherits(cond, "warning")) {
[09:29:14.804]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.804]                         if (muffled) 
[09:29:14.804]                           invokeRestart("muffleWarning")
[09:29:14.804]                       }
[09:29:14.804]                       else if (inherits(cond, "condition")) {
[09:29:14.804]                         if (!is.null(pattern)) {
[09:29:14.804]                           computeRestarts <- base::computeRestarts
[09:29:14.804]                           grepl <- base::grepl
[09:29:14.804]                           restarts <- computeRestarts(cond)
[09:29:14.804]                           for (restart in restarts) {
[09:29:14.804]                             name <- restart$name
[09:29:14.804]                             if (is.null(name)) 
[09:29:14.804]                               next
[09:29:14.804]                             if (!grepl(pattern, name)) 
[09:29:14.804]                               next
[09:29:14.804]                             invokeRestart(restart)
[09:29:14.804]                             muffled <- TRUE
[09:29:14.804]                             break
[09:29:14.804]                           }
[09:29:14.804]                         }
[09:29:14.804]                       }
[09:29:14.804]                       invisible(muffled)
[09:29:14.804]                     }
[09:29:14.804]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.804]                   }
[09:29:14.804]                 }
[09:29:14.804]             }
[09:29:14.804]         }))
[09:29:14.804]     }, error = function(ex) {
[09:29:14.804]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.804]                 ...future.rng), started = ...future.startTime, 
[09:29:14.804]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.804]             version = "1.8"), class = "FutureResult")
[09:29:14.804]     }, finally = {
[09:29:14.804]         if (!identical(...future.workdir, getwd())) 
[09:29:14.804]             setwd(...future.workdir)
[09:29:14.804]         {
[09:29:14.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.804]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.804]             }
[09:29:14.804]             base::options(...future.oldOptions)
[09:29:14.804]             if (.Platform$OS.type == "windows") {
[09:29:14.804]                 old_names <- names(...future.oldEnvVars)
[09:29:14.804]                 envs <- base::Sys.getenv()
[09:29:14.804]                 names <- names(envs)
[09:29:14.804]                 common <- intersect(names, old_names)
[09:29:14.804]                 added <- setdiff(names, old_names)
[09:29:14.804]                 removed <- setdiff(old_names, names)
[09:29:14.804]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.804]                   envs[common]]
[09:29:14.804]                 NAMES <- toupper(changed)
[09:29:14.804]                 args <- list()
[09:29:14.804]                 for (kk in seq_along(NAMES)) {
[09:29:14.804]                   name <- changed[[kk]]
[09:29:14.804]                   NAME <- NAMES[[kk]]
[09:29:14.804]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.804]                     next
[09:29:14.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.804]                 }
[09:29:14.804]                 NAMES <- toupper(added)
[09:29:14.804]                 for (kk in seq_along(NAMES)) {
[09:29:14.804]                   name <- added[[kk]]
[09:29:14.804]                   NAME <- NAMES[[kk]]
[09:29:14.804]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.804]                     next
[09:29:14.804]                   args[[name]] <- ""
[09:29:14.804]                 }
[09:29:14.804]                 NAMES <- toupper(removed)
[09:29:14.804]                 for (kk in seq_along(NAMES)) {
[09:29:14.804]                   name <- removed[[kk]]
[09:29:14.804]                   NAME <- NAMES[[kk]]
[09:29:14.804]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.804]                     next
[09:29:14.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.804]                 }
[09:29:14.804]                 if (length(args) > 0) 
[09:29:14.804]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.804]             }
[09:29:14.804]             else {
[09:29:14.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.804]             }
[09:29:14.804]             {
[09:29:14.804]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.804]                   0L) {
[09:29:14.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.804]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.804]                   base::options(opts)
[09:29:14.804]                 }
[09:29:14.804]                 {
[09:29:14.804]                   {
[09:29:14.804]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.804]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.804]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.804]                     NULL
[09:29:14.804]                   }
[09:29:14.804]                   options(future.plan = NULL)
[09:29:14.804]                   if (is.na(NA_character_)) 
[09:29:14.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.804]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.804]                     .init = FALSE)
[09:29:14.804]                 }
[09:29:14.804]             }
[09:29:14.804]         }
[09:29:14.804]     })
[09:29:14.804]     if (TRUE) {
[09:29:14.804]         base::sink(type = "output", split = FALSE)
[09:29:14.804]         if (TRUE) {
[09:29:14.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.804]         }
[09:29:14.804]         else {
[09:29:14.804]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.804]         }
[09:29:14.804]         base::close(...future.stdout)
[09:29:14.804]         ...future.stdout <- NULL
[09:29:14.804]     }
[09:29:14.804]     ...future.result$conditions <- ...future.conditions
[09:29:14.804]     ...future.result$finished <- base::Sys.time()
[09:29:14.804]     ...future.result
[09:29:14.804] }
[09:29:14.806] assign_globals() ...
[09:29:14.806] List of 5
[09:29:14.806]  $ ...future.FUN            :function (x)  
[09:29:14.806]  $ MoreArgs                 : list()
[09:29:14.806]  $ ...future.elements_ii    :List of 1
[09:29:14.806]   ..$ :List of 1
[09:29:14.806]   .. ..$ : Date[1:1], format: "2018-06-01"
[09:29:14.806]  $ ...future.seeds_ii       : NULL
[09:29:14.806]  $ ...future.globals.maxSize: NULL
[09:29:14.806]  - attr(*, "where")=List of 5
[09:29:14.806]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.806]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.806]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.806]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.806]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.806]  - attr(*, "resolved")= logi FALSE
[09:29:14.806]  - attr(*, "total_size")= num 1128
[09:29:14.806]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.806]  - attr(*, "already-done")= logi TRUE
[09:29:14.810] - copied ‘...future.FUN’ to environment
[09:29:14.810] - copied ‘MoreArgs’ to environment
[09:29:14.810] - copied ‘...future.elements_ii’ to environment
[09:29:14.811] - copied ‘...future.seeds_ii’ to environment
[09:29:14.811] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.811] assign_globals() ... done
[09:29:14.811] plan(): Setting new future strategy stack:
[09:29:14.811] List of future strategies:
[09:29:14.811] 1. sequential:
[09:29:14.811]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.811]    - tweaked: FALSE
[09:29:14.811]    - call: NULL
[09:29:14.812] plan(): nbrOfWorkers() = 1
[09:29:14.812] plan(): Setting new future strategy stack:
[09:29:14.812] List of future strategies:
[09:29:14.812] 1. sequential:
[09:29:14.812]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.812]    - tweaked: FALSE
[09:29:14.812]    - call: plan(strategy)
[09:29:14.813] plan(): nbrOfWorkers() = 1
[09:29:14.813] SequentialFuture started (and completed)
[09:29:14.813] - Launch lazy future ... done
[09:29:14.813] run() for ‘SequentialFuture’ ... done
[09:29:14.813] Created future:
[09:29:14.813] SequentialFuture:
[09:29:14.813] Label: ‘future_.mapply-1’
[09:29:14.813] Expression:
[09:29:14.813] {
[09:29:14.813]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.813]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.813]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.813]         on.exit(options(oopts), add = TRUE)
[09:29:14.813]     }
[09:29:14.813]     {
[09:29:14.813]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.813]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.813]         do.call(mapply, args = args)
[09:29:14.813]     }
[09:29:14.813] }
[09:29:14.813] Lazy evaluation: FALSE
[09:29:14.813] Asynchronous evaluation: FALSE
[09:29:14.813] Local evaluation: TRUE
[09:29:14.813] Environment: R_GlobalEnv
[09:29:14.813] Capture standard output: TRUE
[09:29:14.813] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.813] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.813] Packages: <none>
[09:29:14.813] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.813] Resolved: TRUE
[09:29:14.813] Value: 280 bytes of class ‘list’
[09:29:14.813] Early signaling: FALSE
[09:29:14.813] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.813] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.814] Chunk #1 of 1 ... DONE
[09:29:14.814] Launching 1 futures (chunks) ... DONE
[09:29:14.814] Resolving 1 futures (chunks) ...
[09:29:14.814] resolve() on list ...
[09:29:14.814]  recursive: 0
[09:29:14.815]  length: 1
[09:29:14.815] 
[09:29:14.815] resolved() for ‘SequentialFuture’ ...
[09:29:14.815] - state: ‘finished’
[09:29:14.815] - run: TRUE
[09:29:14.815] - result: ‘FutureResult’
[09:29:14.815] resolved() for ‘SequentialFuture’ ... done
[09:29:14.815] Future #1
[09:29:14.815] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.815] - nx: 1
[09:29:14.816] - relay: TRUE
[09:29:14.816] - stdout: TRUE
[09:29:14.816] - signal: TRUE
[09:29:14.816] - resignal: FALSE
[09:29:14.816] - force: TRUE
[09:29:14.816] - relayed: [n=1] FALSE
[09:29:14.816] - queued futures: [n=1] FALSE
[09:29:14.816]  - until=1
[09:29:14.816]  - relaying element #1
[09:29:14.816] - relayed: [n=1] TRUE
[09:29:14.816] - queued futures: [n=1] TRUE
[09:29:14.817] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.817]  length: 0 (resolved future 1)
[09:29:14.817] Relaying remaining futures
[09:29:14.817] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.817] - nx: 1
[09:29:14.817] - relay: TRUE
[09:29:14.818] - stdout: TRUE
[09:29:14.818] - signal: TRUE
[09:29:14.818] - resignal: FALSE
[09:29:14.818] - force: TRUE
[09:29:14.818] - relayed: [n=1] TRUE
[09:29:14.819] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.819] - relayed: [n=1] TRUE
[09:29:14.819] - queued futures: [n=1] TRUE
[09:29:14.819] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.819] resolve() on list ... DONE
[09:29:14.819]  - Number of value chunks collected: 1
[09:29:14.819] Resolving 1 futures (chunks) ... DONE
[09:29:14.819] Reducing values from 1 chunks ...
[09:29:14.819]  - Number of values collected after concatenation: 1
[09:29:14.819]  - Number of values expected: 1
[09:29:14.820] Reducing values from 1 chunks ... DONE
[09:29:14.820] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[09:29:14.820] future_mapply() ...
[09:29:14.820] Number of chunks: 1
[09:29:14.820] getGlobalsAndPackagesXApply() ...
[09:29:14.820]  - future.globals: TRUE
[09:29:14.820] getGlobalsAndPackages() ...
[09:29:14.820] Searching for globals...
[09:29:14.821] - globals found: [1] ‘FUN’
[09:29:14.821] Searching for globals ... DONE
[09:29:14.822] Resolving globals: FALSE
[09:29:14.822] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[09:29:14.822] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[09:29:14.822] - globals: [1] ‘FUN’
[09:29:14.822] 
[09:29:14.822] getGlobalsAndPackages() ... DONE
[09:29:14.823]  - globals found/used: [n=1] ‘FUN’
[09:29:14.823]  - needed namespaces: [n=0] 
[09:29:14.823] Finding globals ... DONE
[09:29:14.823] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.823] List of 2
[09:29:14.823]  $ ...future.FUN:function (x, y)  
[09:29:14.823]  $ MoreArgs     :List of 1
[09:29:14.823]   ..$ y: int [1:2] 3 4
[09:29:14.823]  - attr(*, "where")=List of 2
[09:29:14.823]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.823]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.823]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.823]  - attr(*, "resolved")= logi FALSE
[09:29:14.823]  - attr(*, "total_size")= num NA
[09:29:14.826] Packages to be attached in all futures: [n=0] 
[09:29:14.826] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.826] Number of futures (= number of chunks): 1
[09:29:14.826] Launching 1 futures (chunks) ...
[09:29:14.826] Chunk #1 of 1 ...
[09:29:14.826]  - Finding globals in '...' for chunk #1 ...
[09:29:14.826] getGlobalsAndPackages() ...
[09:29:14.826] Searching for globals...
[09:29:14.827] 
[09:29:14.827] Searching for globals ... DONE
[09:29:14.827] - globals: [0] <none>
[09:29:14.827] getGlobalsAndPackages() ... DONE
[09:29:14.827]    + additional globals found: [n=0] 
[09:29:14.827]    + additional namespaces needed: [n=0] 
[09:29:14.827]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.827]  - seeds: <none>
[09:29:14.827]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.827] getGlobalsAndPackages() ...
[09:29:14.827] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.828] Resolving globals: FALSE
[09:29:14.828] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[09:29:14.828] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[09:29:14.828] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.829] 
[09:29:14.829] getGlobalsAndPackages() ... DONE
[09:29:14.829] run() for ‘Future’ ...
[09:29:14.829] - state: ‘created’
[09:29:14.829] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.829] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.829] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.830]   - Field: ‘label’
[09:29:14.830]   - Field: ‘local’
[09:29:14.830]   - Field: ‘owner’
[09:29:14.830]   - Field: ‘envir’
[09:29:14.830]   - Field: ‘packages’
[09:29:14.830]   - Field: ‘gc’
[09:29:14.830]   - Field: ‘conditions’
[09:29:14.830]   - Field: ‘expr’
[09:29:14.830]   - Field: ‘uuid’
[09:29:14.830]   - Field: ‘seed’
[09:29:14.830]   - Field: ‘version’
[09:29:14.831]   - Field: ‘result’
[09:29:14.831]   - Field: ‘asynchronous’
[09:29:14.831]   - Field: ‘calls’
[09:29:14.831]   - Field: ‘globals’
[09:29:14.831]   - Field: ‘stdout’
[09:29:14.831]   - Field: ‘earlySignal’
[09:29:14.831]   - Field: ‘lazy’
[09:29:14.831]   - Field: ‘state’
[09:29:14.831] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.831] - Launch lazy future ...
[09:29:14.831] Packages needed by the future expression (n = 0): <none>
[09:29:14.832] Packages needed by future strategies (n = 0): <none>
[09:29:14.832] {
[09:29:14.832]     {
[09:29:14.832]         {
[09:29:14.832]             ...future.startTime <- base::Sys.time()
[09:29:14.832]             {
[09:29:14.832]                 {
[09:29:14.832]                   {
[09:29:14.832]                     base::local({
[09:29:14.832]                       has_future <- base::requireNamespace("future", 
[09:29:14.832]                         quietly = TRUE)
[09:29:14.832]                       if (has_future) {
[09:29:14.832]                         ns <- base::getNamespace("future")
[09:29:14.832]                         version <- ns[[".package"]][["version"]]
[09:29:14.832]                         if (is.null(version)) 
[09:29:14.832]                           version <- utils::packageVersion("future")
[09:29:14.832]                       }
[09:29:14.832]                       else {
[09:29:14.832]                         version <- NULL
[09:29:14.832]                       }
[09:29:14.832]                       if (!has_future || version < "1.8.0") {
[09:29:14.832]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.832]                           "", base::R.version$version.string), 
[09:29:14.832]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.832]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.832]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.832]                             "release", "version")], collapse = " "), 
[09:29:14.832]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.832]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.832]                           info)
[09:29:14.832]                         info <- base::paste(info, collapse = "; ")
[09:29:14.832]                         if (!has_future) {
[09:29:14.832]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.832]                             info)
[09:29:14.832]                         }
[09:29:14.832]                         else {
[09:29:14.832]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.832]                             info, version)
[09:29:14.832]                         }
[09:29:14.832]                         base::stop(msg)
[09:29:14.832]                       }
[09:29:14.832]                     })
[09:29:14.832]                   }
[09:29:14.832]                   ...future.strategy.old <- future::plan("list")
[09:29:14.832]                   options(future.plan = NULL)
[09:29:14.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.832]                 }
[09:29:14.832]                 ...future.workdir <- getwd()
[09:29:14.832]             }
[09:29:14.832]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.832]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.832]         }
[09:29:14.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.832]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.832]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.832]             base::names(...future.oldOptions))
[09:29:14.832]     }
[09:29:14.832]     if (FALSE) {
[09:29:14.832]     }
[09:29:14.832]     else {
[09:29:14.832]         if (TRUE) {
[09:29:14.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.832]                 open = "w")
[09:29:14.832]         }
[09:29:14.832]         else {
[09:29:14.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.832]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.832]         }
[09:29:14.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.832]             base::sink(type = "output", split = FALSE)
[09:29:14.832]             base::close(...future.stdout)
[09:29:14.832]         }, add = TRUE)
[09:29:14.832]     }
[09:29:14.832]     ...future.frame <- base::sys.nframe()
[09:29:14.832]     ...future.conditions <- base::list()
[09:29:14.832]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.832]     if (FALSE) {
[09:29:14.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.832]     }
[09:29:14.832]     ...future.result <- base::tryCatch({
[09:29:14.832]         base::withCallingHandlers({
[09:29:14.832]             ...future.value <- base::withVisible(base::local({
[09:29:14.832]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.832]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.832]                   ...future.globals.maxSize)) {
[09:29:14.832]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.832]                   on.exit(options(oopts), add = TRUE)
[09:29:14.832]                 }
[09:29:14.832]                 {
[09:29:14.832]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.832]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.832]                     USE.NAMES = FALSE)
[09:29:14.832]                   do.call(mapply, args = args)
[09:29:14.832]                 }
[09:29:14.832]             }))
[09:29:14.832]             future::FutureResult(value = ...future.value$value, 
[09:29:14.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.832]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.832]                     ...future.globalenv.names))
[09:29:14.832]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.832]         }, condition = base::local({
[09:29:14.832]             c <- base::c
[09:29:14.832]             inherits <- base::inherits
[09:29:14.832]             invokeRestart <- base::invokeRestart
[09:29:14.832]             length <- base::length
[09:29:14.832]             list <- base::list
[09:29:14.832]             seq.int <- base::seq.int
[09:29:14.832]             signalCondition <- base::signalCondition
[09:29:14.832]             sys.calls <- base::sys.calls
[09:29:14.832]             `[[` <- base::`[[`
[09:29:14.832]             `+` <- base::`+`
[09:29:14.832]             `<<-` <- base::`<<-`
[09:29:14.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.832]                   3L)]
[09:29:14.832]             }
[09:29:14.832]             function(cond) {
[09:29:14.832]                 is_error <- inherits(cond, "error")
[09:29:14.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.832]                   NULL)
[09:29:14.832]                 if (is_error) {
[09:29:14.832]                   sessionInformation <- function() {
[09:29:14.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.832]                       search = base::search(), system = base::Sys.info())
[09:29:14.832]                   }
[09:29:14.832]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.832]                     cond$call), session = sessionInformation(), 
[09:29:14.832]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.832]                   signalCondition(cond)
[09:29:14.832]                 }
[09:29:14.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.832]                 "immediateCondition"))) {
[09:29:14.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.832]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.832]                   if (TRUE && !signal) {
[09:29:14.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.832]                     {
[09:29:14.832]                       inherits <- base::inherits
[09:29:14.832]                       invokeRestart <- base::invokeRestart
[09:29:14.832]                       is.null <- base::is.null
[09:29:14.832]                       muffled <- FALSE
[09:29:14.832]                       if (inherits(cond, "message")) {
[09:29:14.832]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.832]                         if (muffled) 
[09:29:14.832]                           invokeRestart("muffleMessage")
[09:29:14.832]                       }
[09:29:14.832]                       else if (inherits(cond, "warning")) {
[09:29:14.832]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.832]                         if (muffled) 
[09:29:14.832]                           invokeRestart("muffleWarning")
[09:29:14.832]                       }
[09:29:14.832]                       else if (inherits(cond, "condition")) {
[09:29:14.832]                         if (!is.null(pattern)) {
[09:29:14.832]                           computeRestarts <- base::computeRestarts
[09:29:14.832]                           grepl <- base::grepl
[09:29:14.832]                           restarts <- computeRestarts(cond)
[09:29:14.832]                           for (restart in restarts) {
[09:29:14.832]                             name <- restart$name
[09:29:14.832]                             if (is.null(name)) 
[09:29:14.832]                               next
[09:29:14.832]                             if (!grepl(pattern, name)) 
[09:29:14.832]                               next
[09:29:14.832]                             invokeRestart(restart)
[09:29:14.832]                             muffled <- TRUE
[09:29:14.832]                             break
[09:29:14.832]                           }
[09:29:14.832]                         }
[09:29:14.832]                       }
[09:29:14.832]                       invisible(muffled)
[09:29:14.832]                     }
[09:29:14.832]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.832]                   }
[09:29:14.832]                 }
[09:29:14.832]                 else {
[09:29:14.832]                   if (TRUE) {
[09:29:14.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.832]                     {
[09:29:14.832]                       inherits <- base::inherits
[09:29:14.832]                       invokeRestart <- base::invokeRestart
[09:29:14.832]                       is.null <- base::is.null
[09:29:14.832]                       muffled <- FALSE
[09:29:14.832]                       if (inherits(cond, "message")) {
[09:29:14.832]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.832]                         if (muffled) 
[09:29:14.832]                           invokeRestart("muffleMessage")
[09:29:14.832]                       }
[09:29:14.832]                       else if (inherits(cond, "warning")) {
[09:29:14.832]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.832]                         if (muffled) 
[09:29:14.832]                           invokeRestart("muffleWarning")
[09:29:14.832]                       }
[09:29:14.832]                       else if (inherits(cond, "condition")) {
[09:29:14.832]                         if (!is.null(pattern)) {
[09:29:14.832]                           computeRestarts <- base::computeRestarts
[09:29:14.832]                           grepl <- base::grepl
[09:29:14.832]                           restarts <- computeRestarts(cond)
[09:29:14.832]                           for (restart in restarts) {
[09:29:14.832]                             name <- restart$name
[09:29:14.832]                             if (is.null(name)) 
[09:29:14.832]                               next
[09:29:14.832]                             if (!grepl(pattern, name)) 
[09:29:14.832]                               next
[09:29:14.832]                             invokeRestart(restart)
[09:29:14.832]                             muffled <- TRUE
[09:29:14.832]                             break
[09:29:14.832]                           }
[09:29:14.832]                         }
[09:29:14.832]                       }
[09:29:14.832]                       invisible(muffled)
[09:29:14.832]                     }
[09:29:14.832]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.832]                   }
[09:29:14.832]                 }
[09:29:14.832]             }
[09:29:14.832]         }))
[09:29:14.832]     }, error = function(ex) {
[09:29:14.832]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.832]                 ...future.rng), started = ...future.startTime, 
[09:29:14.832]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.832]             version = "1.8"), class = "FutureResult")
[09:29:14.832]     }, finally = {
[09:29:14.832]         if (!identical(...future.workdir, getwd())) 
[09:29:14.832]             setwd(...future.workdir)
[09:29:14.832]         {
[09:29:14.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.832]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.832]             }
[09:29:14.832]             base::options(...future.oldOptions)
[09:29:14.832]             if (.Platform$OS.type == "windows") {
[09:29:14.832]                 old_names <- names(...future.oldEnvVars)
[09:29:14.832]                 envs <- base::Sys.getenv()
[09:29:14.832]                 names <- names(envs)
[09:29:14.832]                 common <- intersect(names, old_names)
[09:29:14.832]                 added <- setdiff(names, old_names)
[09:29:14.832]                 removed <- setdiff(old_names, names)
[09:29:14.832]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.832]                   envs[common]]
[09:29:14.832]                 NAMES <- toupper(changed)
[09:29:14.832]                 args <- list()
[09:29:14.832]                 for (kk in seq_along(NAMES)) {
[09:29:14.832]                   name <- changed[[kk]]
[09:29:14.832]                   NAME <- NAMES[[kk]]
[09:29:14.832]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.832]                     next
[09:29:14.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.832]                 }
[09:29:14.832]                 NAMES <- toupper(added)
[09:29:14.832]                 for (kk in seq_along(NAMES)) {
[09:29:14.832]                   name <- added[[kk]]
[09:29:14.832]                   NAME <- NAMES[[kk]]
[09:29:14.832]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.832]                     next
[09:29:14.832]                   args[[name]] <- ""
[09:29:14.832]                 }
[09:29:14.832]                 NAMES <- toupper(removed)
[09:29:14.832]                 for (kk in seq_along(NAMES)) {
[09:29:14.832]                   name <- removed[[kk]]
[09:29:14.832]                   NAME <- NAMES[[kk]]
[09:29:14.832]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.832]                     next
[09:29:14.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.832]                 }
[09:29:14.832]                 if (length(args) > 0) 
[09:29:14.832]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.832]             }
[09:29:14.832]             else {
[09:29:14.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.832]             }
[09:29:14.832]             {
[09:29:14.832]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.832]                   0L) {
[09:29:14.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.832]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.832]                   base::options(opts)
[09:29:14.832]                 }
[09:29:14.832]                 {
[09:29:14.832]                   {
[09:29:14.832]                     base::assign(".Random.seed", c(10407L, -2127033937L, 
[09:29:14.832]                     556831574L, 1526525595L, -300945518L, -983255142L, 
[09:29:14.832]                     56797152L), envir = base::globalenv(), inherits = FALSE)
[09:29:14.832]                     NULL
[09:29:14.832]                   }
[09:29:14.832]                   options(future.plan = NULL)
[09:29:14.832]                   if (is.na(NA_character_)) 
[09:29:14.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.832]                     .init = FALSE)
[09:29:14.832]                 }
[09:29:14.832]             }
[09:29:14.832]         }
[09:29:14.832]     })
[09:29:14.832]     if (TRUE) {
[09:29:14.832]         base::sink(type = "output", split = FALSE)
[09:29:14.832]         if (TRUE) {
[09:29:14.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.832]         }
[09:29:14.832]         else {
[09:29:14.832]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.832]         }
[09:29:14.832]         base::close(...future.stdout)
[09:29:14.832]         ...future.stdout <- NULL
[09:29:14.832]     }
[09:29:14.832]     ...future.result$conditions <- ...future.conditions
[09:29:14.832]     ...future.result$finished <- base::Sys.time()
[09:29:14.832]     ...future.result
[09:29:14.832] }
[09:29:14.834] assign_globals() ...
[09:29:14.834] List of 5
[09:29:14.834]  $ ...future.FUN            :function (x, y)  
[09:29:14.834]  $ MoreArgs                 :List of 1
[09:29:14.834]   ..$ y: int [1:2] 3 4
[09:29:14.834]  $ ...future.elements_ii    :List of 1
[09:29:14.834]   ..$ x:List of 2
[09:29:14.834]   .. ..$ : int 1
[09:29:14.834]   .. ..$ : int 2
[09:29:14.834]  $ ...future.seeds_ii       : NULL
[09:29:14.834]  $ ...future.globals.maxSize: NULL
[09:29:14.834]  - attr(*, "where")=List of 5
[09:29:14.834]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.834]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.834]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.834]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.834]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.834]  - attr(*, "resolved")= logi FALSE
[09:29:14.834]  - attr(*, "total_size")= num 1872
[09:29:14.834]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.834]  - attr(*, "already-done")= logi TRUE
[09:29:14.838] - reassign environment for ‘...future.FUN’
[09:29:14.838] - copied ‘...future.FUN’ to environment
[09:29:14.839] - copied ‘MoreArgs’ to environment
[09:29:14.839] - copied ‘...future.elements_ii’ to environment
[09:29:14.839] - copied ‘...future.seeds_ii’ to environment
[09:29:14.839] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.839] assign_globals() ... done
[09:29:14.839] plan(): Setting new future strategy stack:
[09:29:14.839] List of future strategies:
[09:29:14.839] 1. sequential:
[09:29:14.839]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.839]    - tweaked: FALSE
[09:29:14.839]    - call: NULL
[09:29:14.840] plan(): nbrOfWorkers() = 1
[09:29:14.841] plan(): Setting new future strategy stack:
[09:29:14.842] List of future strategies:
[09:29:14.842] 1. sequential:
[09:29:14.842]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.842]    - tweaked: FALSE
[09:29:14.842]    - call: plan(strategy)
[09:29:14.842] plan(): nbrOfWorkers() = 1
[09:29:14.842] SequentialFuture started (and completed)
[09:29:14.842] - Launch lazy future ... done
[09:29:14.842] run() for ‘SequentialFuture’ ... done
[09:29:14.842] Created future:
[09:29:14.843] SequentialFuture:
[09:29:14.843] Label: ‘future_mapply-1’
[09:29:14.843] Expression:
[09:29:14.843] {
[09:29:14.843]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.843]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.843]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.843]         on.exit(options(oopts), add = TRUE)
[09:29:14.843]     }
[09:29:14.843]     {
[09:29:14.843]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.843]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.843]         do.call(mapply, args = args)
[09:29:14.843]     }
[09:29:14.843] }
[09:29:14.843] Lazy evaluation: FALSE
[09:29:14.843] Asynchronous evaluation: FALSE
[09:29:14.843] Local evaluation: TRUE
[09:29:14.843] Environment: R_GlobalEnv
[09:29:14.843] Capture standard output: TRUE
[09:29:14.843] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.843] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.843] Packages: <none>
[09:29:14.843] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.843] Resolved: TRUE
[09:29:14.843] Value: 112 bytes of class ‘list’
[09:29:14.843] Early signaling: FALSE
[09:29:14.843] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.843] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.843] Chunk #1 of 1 ... DONE
[09:29:14.843] Launching 1 futures (chunks) ... DONE
[09:29:14.844] Resolving 1 futures (chunks) ...
[09:29:14.844] resolve() on list ...
[09:29:14.844]  recursive: 0
[09:29:14.844]  length: 1
[09:29:14.844] 
[09:29:14.844] resolved() for ‘SequentialFuture’ ...
[09:29:14.844] - state: ‘finished’
[09:29:14.844] - run: TRUE
[09:29:14.844] - result: ‘FutureResult’
[09:29:14.844] resolved() for ‘SequentialFuture’ ... done
[09:29:14.844] Future #1
[09:29:14.845] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.845] - nx: 1
[09:29:14.845] - relay: TRUE
[09:29:14.845] - stdout: TRUE
[09:29:14.845] - signal: TRUE
[09:29:14.845] - resignal: FALSE
[09:29:14.845] - force: TRUE
[09:29:14.845] - relayed: [n=1] FALSE
[09:29:14.845] - queued futures: [n=1] FALSE
[09:29:14.845]  - until=1
[09:29:14.845]  - relaying element #1
[09:29:14.846] - relayed: [n=1] TRUE
[09:29:14.846] - queued futures: [n=1] TRUE
[09:29:14.846] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.846]  length: 0 (resolved future 1)
[09:29:14.846] Relaying remaining futures
[09:29:14.846] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.846] - nx: 1
[09:29:14.846] - relay: TRUE
[09:29:14.846] - stdout: TRUE
[09:29:14.846] - signal: TRUE
[09:29:14.846] - resignal: FALSE
[09:29:14.846] - force: TRUE
[09:29:14.847] - relayed: [n=1] TRUE
[09:29:14.847] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.847] - relayed: [n=1] TRUE
[09:29:14.847] - queued futures: [n=1] TRUE
[09:29:14.847] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.847] resolve() on list ... DONE
[09:29:14.847]  - Number of value chunks collected: 1
[09:29:14.847] Resolving 1 futures (chunks) ... DONE
[09:29:14.847] Reducing values from 1 chunks ...
[09:29:14.847]  - Number of values collected after concatenation: 2
[09:29:14.847]  - Number of values expected: 2
[09:29:14.848] Reducing values from 1 chunks ... DONE
[09:29:14.848] future_mapply() ... DONE
[09:29:14.848] future_mapply() ...
[09:29:14.848] Generating random seeds ...
[09:29:14.848] Generating random seed streams for 2 elements ...
[09:29:14.848] Generating random seed streams for 2 elements ... DONE
[09:29:14.848] Generating random seeds ... DONE
[09:29:14.848] Will set RNG state on exit: 10407, 1526525595, 1834748666, 1375929630, 56797152, -1188802245, 2055751927
[09:29:14.848] Number of chunks: 1
[09:29:14.848] getGlobalsAndPackagesXApply() ...
[09:29:14.849]  - future.globals: TRUE
[09:29:14.849] getGlobalsAndPackages() ...
[09:29:14.849] Searching for globals...
[09:29:14.850] - globals found: [1] ‘FUN’
[09:29:14.850] Searching for globals ... DONE
[09:29:14.850] Resolving globals: FALSE
[09:29:14.850] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[09:29:14.850] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[09:29:14.850] - globals: [1] ‘FUN’
[09:29:14.851] 
[09:29:14.851] getGlobalsAndPackages() ... DONE
[09:29:14.851]  - globals found/used: [n=1] ‘FUN’
[09:29:14.851]  - needed namespaces: [n=0] 
[09:29:14.851] Finding globals ... DONE
[09:29:14.851] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.851] List of 2
[09:29:14.851]  $ ...future.FUN:function (x, y)  
[09:29:14.851]  $ MoreArgs     :List of 1
[09:29:14.851]   ..$ y: int [1:2] 3 4
[09:29:14.851]  - attr(*, "where")=List of 2
[09:29:14.851]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.851]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.851]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.851]  - attr(*, "resolved")= logi FALSE
[09:29:14.851]  - attr(*, "total_size")= num NA
[09:29:14.854] Packages to be attached in all futures: [n=0] 
[09:29:14.854] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.854] Number of futures (= number of chunks): 1
[09:29:14.854] Launching 1 futures (chunks) ...
[09:29:14.854] Chunk #1 of 1 ...
[09:29:14.854]  - Finding globals in '...' for chunk #1 ...
[09:29:14.854] getGlobalsAndPackages() ...
[09:29:14.854] Searching for globals...
[09:29:14.855] 
[09:29:14.855] Searching for globals ... DONE
[09:29:14.855] - globals: [0] <none>
[09:29:14.855] getGlobalsAndPackages() ... DONE
[09:29:14.855]    + additional globals found: [n=0] 
[09:29:14.855]    + additional namespaces needed: [n=0] 
[09:29:14.855]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.855]  - seeds: [2] <seeds>
[09:29:14.855]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.856] getGlobalsAndPackages() ...
[09:29:14.856] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.856] Resolving globals: FALSE
[09:29:14.856] The total size of the 5 globals is 1.98 KiB (2032 bytes)
[09:29:14.857] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (160 bytes of class ‘list’) and ‘...future.elements_ii’ (112 bytes of class ‘list’)
[09:29:14.857] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.857] 
[09:29:14.857] getGlobalsAndPackages() ... DONE
[09:29:14.857] run() for ‘Future’ ...
[09:29:14.857] - state: ‘created’
[09:29:14.857] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.858] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.858] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.858]   - Field: ‘label’
[09:29:14.858]   - Field: ‘local’
[09:29:14.858]   - Field: ‘owner’
[09:29:14.858]   - Field: ‘envir’
[09:29:14.858]   - Field: ‘packages’
[09:29:14.858]   - Field: ‘gc’
[09:29:14.858]   - Field: ‘conditions’
[09:29:14.858]   - Field: ‘expr’
[09:29:14.858]   - Field: ‘uuid’
[09:29:14.859]   - Field: ‘seed’
[09:29:14.859]   - Field: ‘version’
[09:29:14.859]   - Field: ‘result’
[09:29:14.859]   - Field: ‘asynchronous’
[09:29:14.859]   - Field: ‘calls’
[09:29:14.859]   - Field: ‘globals’
[09:29:14.859]   - Field: ‘stdout’
[09:29:14.859]   - Field: ‘earlySignal’
[09:29:14.859]   - Field: ‘lazy’
[09:29:14.859]   - Field: ‘state’
[09:29:14.859] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.859] - Launch lazy future ...
[09:29:14.860] Packages needed by the future expression (n = 0): <none>
[09:29:14.860] Packages needed by future strategies (n = 0): <none>
[09:29:14.860] {
[09:29:14.860]     {
[09:29:14.860]         {
[09:29:14.860]             ...future.startTime <- base::Sys.time()
[09:29:14.860]             {
[09:29:14.860]                 {
[09:29:14.860]                   {
[09:29:14.860]                     base::local({
[09:29:14.860]                       has_future <- base::requireNamespace("future", 
[09:29:14.860]                         quietly = TRUE)
[09:29:14.860]                       if (has_future) {
[09:29:14.860]                         ns <- base::getNamespace("future")
[09:29:14.860]                         version <- ns[[".package"]][["version"]]
[09:29:14.860]                         if (is.null(version)) 
[09:29:14.860]                           version <- utils::packageVersion("future")
[09:29:14.860]                       }
[09:29:14.860]                       else {
[09:29:14.860]                         version <- NULL
[09:29:14.860]                       }
[09:29:14.860]                       if (!has_future || version < "1.8.0") {
[09:29:14.860]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.860]                           "", base::R.version$version.string), 
[09:29:14.860]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.860]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.860]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.860]                             "release", "version")], collapse = " "), 
[09:29:14.860]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.860]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.860]                           info)
[09:29:14.860]                         info <- base::paste(info, collapse = "; ")
[09:29:14.860]                         if (!has_future) {
[09:29:14.860]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.860]                             info)
[09:29:14.860]                         }
[09:29:14.860]                         else {
[09:29:14.860]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.860]                             info, version)
[09:29:14.860]                         }
[09:29:14.860]                         base::stop(msg)
[09:29:14.860]                       }
[09:29:14.860]                     })
[09:29:14.860]                   }
[09:29:14.860]                   ...future.strategy.old <- future::plan("list")
[09:29:14.860]                   options(future.plan = NULL)
[09:29:14.860]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.860]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.860]                 }
[09:29:14.860]                 ...future.workdir <- getwd()
[09:29:14.860]             }
[09:29:14.860]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.860]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.860]         }
[09:29:14.860]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.860]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.860]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.860]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.860]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.860]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.860]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.860]             base::names(...future.oldOptions))
[09:29:14.860]     }
[09:29:14.860]     if (FALSE) {
[09:29:14.860]     }
[09:29:14.860]     else {
[09:29:14.860]         if (TRUE) {
[09:29:14.860]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.860]                 open = "w")
[09:29:14.860]         }
[09:29:14.860]         else {
[09:29:14.860]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.860]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.860]         }
[09:29:14.860]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.860]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.860]             base::sink(type = "output", split = FALSE)
[09:29:14.860]             base::close(...future.stdout)
[09:29:14.860]         }, add = TRUE)
[09:29:14.860]     }
[09:29:14.860]     ...future.frame <- base::sys.nframe()
[09:29:14.860]     ...future.conditions <- base::list()
[09:29:14.860]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.860]     if (FALSE) {
[09:29:14.860]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.860]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.860]     }
[09:29:14.860]     ...future.result <- base::tryCatch({
[09:29:14.860]         base::withCallingHandlers({
[09:29:14.860]             ...future.value <- base::withVisible(base::local({
[09:29:14.860]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.860]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.860]                   ...future.globals.maxSize)) {
[09:29:14.860]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.860]                   on.exit(options(oopts), add = TRUE)
[09:29:14.860]                 }
[09:29:14.860]                 {
[09:29:14.860]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:14.860]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[09:29:14.860]                       envir = globalenv(), inherits = FALSE)
[09:29:14.860]                     ...future.FUN(...)
[09:29:14.860]                   }
[09:29:14.860]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:14.860]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:14.860]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.860]                     USE.NAMES = FALSE)
[09:29:14.860]                   do.call(mapply, args = args)
[09:29:14.860]                 }
[09:29:14.860]             }))
[09:29:14.860]             future::FutureResult(value = ...future.value$value, 
[09:29:14.860]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.860]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.860]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.860]                     ...future.globalenv.names))
[09:29:14.860]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.860]         }, condition = base::local({
[09:29:14.860]             c <- base::c
[09:29:14.860]             inherits <- base::inherits
[09:29:14.860]             invokeRestart <- base::invokeRestart
[09:29:14.860]             length <- base::length
[09:29:14.860]             list <- base::list
[09:29:14.860]             seq.int <- base::seq.int
[09:29:14.860]             signalCondition <- base::signalCondition
[09:29:14.860]             sys.calls <- base::sys.calls
[09:29:14.860]             `[[` <- base::`[[`
[09:29:14.860]             `+` <- base::`+`
[09:29:14.860]             `<<-` <- base::`<<-`
[09:29:14.860]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.860]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.860]                   3L)]
[09:29:14.860]             }
[09:29:14.860]             function(cond) {
[09:29:14.860]                 is_error <- inherits(cond, "error")
[09:29:14.860]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.860]                   NULL)
[09:29:14.860]                 if (is_error) {
[09:29:14.860]                   sessionInformation <- function() {
[09:29:14.860]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.860]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.860]                       search = base::search(), system = base::Sys.info())
[09:29:14.860]                   }
[09:29:14.860]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.860]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.860]                     cond$call), session = sessionInformation(), 
[09:29:14.860]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.860]                   signalCondition(cond)
[09:29:14.860]                 }
[09:29:14.860]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.860]                 "immediateCondition"))) {
[09:29:14.860]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.860]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.860]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.860]                   if (TRUE && !signal) {
[09:29:14.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.860]                     {
[09:29:14.860]                       inherits <- base::inherits
[09:29:14.860]                       invokeRestart <- base::invokeRestart
[09:29:14.860]                       is.null <- base::is.null
[09:29:14.860]                       muffled <- FALSE
[09:29:14.860]                       if (inherits(cond, "message")) {
[09:29:14.860]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.860]                         if (muffled) 
[09:29:14.860]                           invokeRestart("muffleMessage")
[09:29:14.860]                       }
[09:29:14.860]                       else if (inherits(cond, "warning")) {
[09:29:14.860]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.860]                         if (muffled) 
[09:29:14.860]                           invokeRestart("muffleWarning")
[09:29:14.860]                       }
[09:29:14.860]                       else if (inherits(cond, "condition")) {
[09:29:14.860]                         if (!is.null(pattern)) {
[09:29:14.860]                           computeRestarts <- base::computeRestarts
[09:29:14.860]                           grepl <- base::grepl
[09:29:14.860]                           restarts <- computeRestarts(cond)
[09:29:14.860]                           for (restart in restarts) {
[09:29:14.860]                             name <- restart$name
[09:29:14.860]                             if (is.null(name)) 
[09:29:14.860]                               next
[09:29:14.860]                             if (!grepl(pattern, name)) 
[09:29:14.860]                               next
[09:29:14.860]                             invokeRestart(restart)
[09:29:14.860]                             muffled <- TRUE
[09:29:14.860]                             break
[09:29:14.860]                           }
[09:29:14.860]                         }
[09:29:14.860]                       }
[09:29:14.860]                       invisible(muffled)
[09:29:14.860]                     }
[09:29:14.860]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.860]                   }
[09:29:14.860]                 }
[09:29:14.860]                 else {
[09:29:14.860]                   if (TRUE) {
[09:29:14.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.860]                     {
[09:29:14.860]                       inherits <- base::inherits
[09:29:14.860]                       invokeRestart <- base::invokeRestart
[09:29:14.860]                       is.null <- base::is.null
[09:29:14.860]                       muffled <- FALSE
[09:29:14.860]                       if (inherits(cond, "message")) {
[09:29:14.860]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.860]                         if (muffled) 
[09:29:14.860]                           invokeRestart("muffleMessage")
[09:29:14.860]                       }
[09:29:14.860]                       else if (inherits(cond, "warning")) {
[09:29:14.860]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.860]                         if (muffled) 
[09:29:14.860]                           invokeRestart("muffleWarning")
[09:29:14.860]                       }
[09:29:14.860]                       else if (inherits(cond, "condition")) {
[09:29:14.860]                         if (!is.null(pattern)) {
[09:29:14.860]                           computeRestarts <- base::computeRestarts
[09:29:14.860]                           grepl <- base::grepl
[09:29:14.860]                           restarts <- computeRestarts(cond)
[09:29:14.860]                           for (restart in restarts) {
[09:29:14.860]                             name <- restart$name
[09:29:14.860]                             if (is.null(name)) 
[09:29:14.860]                               next
[09:29:14.860]                             if (!grepl(pattern, name)) 
[09:29:14.860]                               next
[09:29:14.860]                             invokeRestart(restart)
[09:29:14.860]                             muffled <- TRUE
[09:29:14.860]                             break
[09:29:14.860]                           }
[09:29:14.860]                         }
[09:29:14.860]                       }
[09:29:14.860]                       invisible(muffled)
[09:29:14.860]                     }
[09:29:14.860]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.860]                   }
[09:29:14.860]                 }
[09:29:14.860]             }
[09:29:14.860]         }))
[09:29:14.860]     }, error = function(ex) {
[09:29:14.860]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.860]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.860]                 ...future.rng), started = ...future.startTime, 
[09:29:14.860]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.860]             version = "1.8"), class = "FutureResult")
[09:29:14.860]     }, finally = {
[09:29:14.860]         if (!identical(...future.workdir, getwd())) 
[09:29:14.860]             setwd(...future.workdir)
[09:29:14.860]         {
[09:29:14.860]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.860]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.860]             }
[09:29:14.860]             base::options(...future.oldOptions)
[09:29:14.860]             if (.Platform$OS.type == "windows") {
[09:29:14.860]                 old_names <- names(...future.oldEnvVars)
[09:29:14.860]                 envs <- base::Sys.getenv()
[09:29:14.860]                 names <- names(envs)
[09:29:14.860]                 common <- intersect(names, old_names)
[09:29:14.860]                 added <- setdiff(names, old_names)
[09:29:14.860]                 removed <- setdiff(old_names, names)
[09:29:14.860]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.860]                   envs[common]]
[09:29:14.860]                 NAMES <- toupper(changed)
[09:29:14.860]                 args <- list()
[09:29:14.860]                 for (kk in seq_along(NAMES)) {
[09:29:14.860]                   name <- changed[[kk]]
[09:29:14.860]                   NAME <- NAMES[[kk]]
[09:29:14.860]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.860]                     next
[09:29:14.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.860]                 }
[09:29:14.860]                 NAMES <- toupper(added)
[09:29:14.860]                 for (kk in seq_along(NAMES)) {
[09:29:14.860]                   name <- added[[kk]]
[09:29:14.860]                   NAME <- NAMES[[kk]]
[09:29:14.860]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.860]                     next
[09:29:14.860]                   args[[name]] <- ""
[09:29:14.860]                 }
[09:29:14.860]                 NAMES <- toupper(removed)
[09:29:14.860]                 for (kk in seq_along(NAMES)) {
[09:29:14.860]                   name <- removed[[kk]]
[09:29:14.860]                   NAME <- NAMES[[kk]]
[09:29:14.860]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.860]                     next
[09:29:14.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.860]                 }
[09:29:14.860]                 if (length(args) > 0) 
[09:29:14.860]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.860]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.860]             }
[09:29:14.860]             else {
[09:29:14.860]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.860]             }
[09:29:14.860]             {
[09:29:14.860]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.860]                   0L) {
[09:29:14.860]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.860]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.860]                   base::options(opts)
[09:29:14.860]                 }
[09:29:14.860]                 {
[09:29:14.860]                   {
[09:29:14.860]                     base::assign(".Random.seed", c(10407L, 1526525595L, 
[09:29:14.860]                     1834748666L, 1375929630L, 56797152L, -1188802245L, 
[09:29:14.860]                     2055751927L), envir = base::globalenv(), 
[09:29:14.860]                       inherits = FALSE)
[09:29:14.860]                     NULL
[09:29:14.860]                   }
[09:29:14.860]                   options(future.plan = NULL)
[09:29:14.860]                   if (is.na(NA_character_)) 
[09:29:14.860]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.860]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.860]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.860]                     .init = FALSE)
[09:29:14.860]                 }
[09:29:14.860]             }
[09:29:14.860]         }
[09:29:14.860]     })
[09:29:14.860]     if (TRUE) {
[09:29:14.860]         base::sink(type = "output", split = FALSE)
[09:29:14.860]         if (TRUE) {
[09:29:14.860]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.860]         }
[09:29:14.860]         else {
[09:29:14.860]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.860]         }
[09:29:14.860]         base::close(...future.stdout)
[09:29:14.860]         ...future.stdout <- NULL
[09:29:14.860]     }
[09:29:14.860]     ...future.result$conditions <- ...future.conditions
[09:29:14.860]     ...future.result$finished <- base::Sys.time()
[09:29:14.860]     ...future.result
[09:29:14.860] }
[09:29:14.862] assign_globals() ...
[09:29:14.862] List of 5
[09:29:14.862]  $ ...future.FUN            :function (x, y)  
[09:29:14.862]  $ MoreArgs                 :List of 1
[09:29:14.862]   ..$ y: int [1:2] 3 4
[09:29:14.862]  $ ...future.elements_ii    :List of 1
[09:29:14.862]   ..$ x:List of 2
[09:29:14.862]   .. ..$ : int 1
[09:29:14.862]   .. ..$ : int 2
[09:29:14.862]  $ ...future.seeds_ii       :List of 2
[09:29:14.862]   ..$ : int [1:7] 10407 1402559525 -1806171132 1256541492 1372440673 -1695583725 -503524822
[09:29:14.862]   ..$ : int [1:7] 10407 2040378968 -937117517 -855567852 309975101 -1847682451 -114943435
[09:29:14.862]  $ ...future.globals.maxSize: NULL
[09:29:14.862]  - attr(*, "where")=List of 5
[09:29:14.862]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.862]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.862]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.862]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.862]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.862]  - attr(*, "resolved")= logi FALSE
[09:29:14.862]  - attr(*, "total_size")= num 2032
[09:29:14.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.862]  - attr(*, "already-done")= logi TRUE
[09:29:14.868] - reassign environment for ‘...future.FUN’
[09:29:14.868] - copied ‘...future.FUN’ to environment
[09:29:14.869] - copied ‘MoreArgs’ to environment
[09:29:14.869] - copied ‘...future.elements_ii’ to environment
[09:29:14.869] - copied ‘...future.seeds_ii’ to environment
[09:29:14.869] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.869] assign_globals() ... done
[09:29:14.869] plan(): Setting new future strategy stack:
[09:29:14.869] List of future strategies:
[09:29:14.869] 1. sequential:
[09:29:14.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.869]    - tweaked: FALSE
[09:29:14.869]    - call: NULL
[09:29:14.870] plan(): nbrOfWorkers() = 1
[09:29:14.870] plan(): Setting new future strategy stack:
[09:29:14.870] List of future strategies:
[09:29:14.870] 1. sequential:
[09:29:14.870]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.870]    - tweaked: FALSE
[09:29:14.870]    - call: plan(strategy)
[09:29:14.871] plan(): nbrOfWorkers() = 1
[09:29:14.871] SequentialFuture started (and completed)
[09:29:14.871] - Launch lazy future ... done
[09:29:14.871] run() for ‘SequentialFuture’ ... done
[09:29:14.871] Created future:
[09:29:14.871] SequentialFuture:
[09:29:14.871] Label: ‘future_mapply-1’
[09:29:14.871] Expression:
[09:29:14.871] {
[09:29:14.871]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.871]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.871]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.871]         on.exit(options(oopts), add = TRUE)
[09:29:14.871]     }
[09:29:14.871]     {
[09:29:14.871]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:14.871]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[09:29:14.871]                 inherits = FALSE)
[09:29:14.871]             ...future.FUN(...)
[09:29:14.871]         }
[09:29:14.871]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:14.871]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:14.871]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.871]         do.call(mapply, args = args)
[09:29:14.871]     }
[09:29:14.871] }
[09:29:14.871] Lazy evaluation: FALSE
[09:29:14.871] Asynchronous evaluation: FALSE
[09:29:14.871] Local evaluation: TRUE
[09:29:14.871] Environment: R_GlobalEnv
[09:29:14.871] Capture standard output: TRUE
[09:29:14.871] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.871] Globals: 5 objects totaling 1.98 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.871] Packages: <none>
[09:29:14.871] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:29:14.871] Resolved: TRUE
[09:29:14.871] Value: 112 bytes of class ‘list’
[09:29:14.871] Early signaling: FALSE
[09:29:14.871] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.871] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.872] Chunk #1 of 1 ... DONE
[09:29:14.872] Launching 1 futures (chunks) ... DONE
[09:29:14.872] Resolving 1 futures (chunks) ...
[09:29:14.872] resolve() on list ...
[09:29:14.873]  recursive: 0
[09:29:14.873]  length: 1
[09:29:14.873] 
[09:29:14.873] resolved() for ‘SequentialFuture’ ...
[09:29:14.873] - state: ‘finished’
[09:29:14.873] - run: TRUE
[09:29:14.873] - result: ‘FutureResult’
[09:29:14.873] resolved() for ‘SequentialFuture’ ... done
[09:29:14.873] Future #1
[09:29:14.873] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.873] - nx: 1
[09:29:14.874] - relay: TRUE
[09:29:14.874] - stdout: TRUE
[09:29:14.874] - signal: TRUE
[09:29:14.874] - resignal: FALSE
[09:29:14.874] - force: TRUE
[09:29:14.874] - relayed: [n=1] FALSE
[09:29:14.874] - queued futures: [n=1] FALSE
[09:29:14.874]  - until=1
[09:29:14.874]  - relaying element #1
[09:29:14.874] - relayed: [n=1] TRUE
[09:29:14.874] - queued futures: [n=1] TRUE
[09:29:14.874] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.875]  length: 0 (resolved future 1)
[09:29:14.875] Relaying remaining futures
[09:29:14.875] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.875] - nx: 1
[09:29:14.875] - relay: TRUE
[09:29:14.875] - stdout: TRUE
[09:29:14.875] - signal: TRUE
[09:29:14.875] - resignal: FALSE
[09:29:14.875] - force: TRUE
[09:29:14.875] - relayed: [n=1] TRUE
[09:29:14.875] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.875] - relayed: [n=1] TRUE
[09:29:14.876] - queued futures: [n=1] TRUE
[09:29:14.876] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.876] resolve() on list ... DONE
[09:29:14.876]  - Number of value chunks collected: 1
[09:29:14.876] Resolving 1 futures (chunks) ... DONE
[09:29:14.876] Reducing values from 1 chunks ...
[09:29:14.876]  - Number of values collected after concatenation: 2
[09:29:14.876]  - Number of values expected: 2
[09:29:14.876] Reducing values from 1 chunks ... DONE
[09:29:14.876] future_mapply() ... DONE
[09:29:14.877] future_mapply() ...
[09:29:14.877] Number of chunks: 1
[09:29:14.877] getGlobalsAndPackagesXApply() ...
[09:29:14.877]  - future.globals: TRUE
[09:29:14.877] getGlobalsAndPackages() ...
[09:29:14.877] Searching for globals...
[09:29:14.878] - globals found: [1] ‘FUN’
[09:29:14.878] Searching for globals ... DONE
[09:29:14.878] Resolving globals: FALSE
[09:29:14.878] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[09:29:14.879] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[09:29:14.879] - globals: [1] ‘FUN’
[09:29:14.879] 
[09:29:14.879] getGlobalsAndPackages() ... DONE
[09:29:14.879]  - globals found/used: [n=1] ‘FUN’
[09:29:14.879]  - needed namespaces: [n=0] 
[09:29:14.879] Finding globals ... DONE
[09:29:14.879] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.879] List of 2
[09:29:14.879]  $ ...future.FUN:function (x, y)  
[09:29:14.879]  $ MoreArgs     :List of 1
[09:29:14.879]   ..$ y: int [1:2] 3 4
[09:29:14.879]  - attr(*, "where")=List of 2
[09:29:14.879]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.879]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.879]  - attr(*, "resolved")= logi FALSE
[09:29:14.879]  - attr(*, "total_size")= num NA
[09:29:14.882] Packages to be attached in all futures: [n=0] 
[09:29:14.882] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.882] Number of futures (= number of chunks): 1
[09:29:14.882] Launching 1 futures (chunks) ...
[09:29:14.882] Chunk #1 of 1 ...
[09:29:14.883]  - Finding globals in '...' for chunk #1 ...
[09:29:14.883] getGlobalsAndPackages() ...
[09:29:14.883] Searching for globals...
[09:29:14.883] 
[09:29:14.883] Searching for globals ... DONE
[09:29:14.883] - globals: [0] <none>
[09:29:14.883] getGlobalsAndPackages() ... DONE
[09:29:14.883]    + additional globals found: [n=0] 
[09:29:14.883]    + additional namespaces needed: [n=0] 
[09:29:14.884]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.884]  - seeds: <none>
[09:29:14.884]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.884] getGlobalsAndPackages() ...
[09:29:14.884] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.884] Resolving globals: FALSE
[09:29:14.885] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[09:29:14.886] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[09:29:14.886] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.886] 
[09:29:14.886] getGlobalsAndPackages() ... DONE
[09:29:14.886] run() for ‘Future’ ...
[09:29:14.887] - state: ‘created’
[09:29:14.887] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.887] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.887] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.887]   - Field: ‘label’
[09:29:14.887]   - Field: ‘local’
[09:29:14.887]   - Field: ‘owner’
[09:29:14.887]   - Field: ‘envir’
[09:29:14.887]   - Field: ‘packages’
[09:29:14.888]   - Field: ‘gc’
[09:29:14.888]   - Field: ‘conditions’
[09:29:14.888]   - Field: ‘expr’
[09:29:14.888]   - Field: ‘uuid’
[09:29:14.888]   - Field: ‘seed’
[09:29:14.888]   - Field: ‘version’
[09:29:14.888]   - Field: ‘result’
[09:29:14.888]   - Field: ‘asynchronous’
[09:29:14.888]   - Field: ‘calls’
[09:29:14.888]   - Field: ‘globals’
[09:29:14.888]   - Field: ‘stdout’
[09:29:14.889]   - Field: ‘earlySignal’
[09:29:14.889]   - Field: ‘lazy’
[09:29:14.889]   - Field: ‘state’
[09:29:14.889] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.889] - Launch lazy future ...
[09:29:14.889] Packages needed by the future expression (n = 0): <none>
[09:29:14.889] Packages needed by future strategies (n = 0): <none>
[09:29:14.890] {
[09:29:14.890]     {
[09:29:14.890]         {
[09:29:14.890]             ...future.startTime <- base::Sys.time()
[09:29:14.890]             {
[09:29:14.890]                 {
[09:29:14.890]                   {
[09:29:14.890]                     base::local({
[09:29:14.890]                       has_future <- base::requireNamespace("future", 
[09:29:14.890]                         quietly = TRUE)
[09:29:14.890]                       if (has_future) {
[09:29:14.890]                         ns <- base::getNamespace("future")
[09:29:14.890]                         version <- ns[[".package"]][["version"]]
[09:29:14.890]                         if (is.null(version)) 
[09:29:14.890]                           version <- utils::packageVersion("future")
[09:29:14.890]                       }
[09:29:14.890]                       else {
[09:29:14.890]                         version <- NULL
[09:29:14.890]                       }
[09:29:14.890]                       if (!has_future || version < "1.8.0") {
[09:29:14.890]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.890]                           "", base::R.version$version.string), 
[09:29:14.890]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.890]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.890]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.890]                             "release", "version")], collapse = " "), 
[09:29:14.890]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.890]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.890]                           info)
[09:29:14.890]                         info <- base::paste(info, collapse = "; ")
[09:29:14.890]                         if (!has_future) {
[09:29:14.890]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.890]                             info)
[09:29:14.890]                         }
[09:29:14.890]                         else {
[09:29:14.890]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.890]                             info, version)
[09:29:14.890]                         }
[09:29:14.890]                         base::stop(msg)
[09:29:14.890]                       }
[09:29:14.890]                     })
[09:29:14.890]                   }
[09:29:14.890]                   ...future.strategy.old <- future::plan("list")
[09:29:14.890]                   options(future.plan = NULL)
[09:29:14.890]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.890]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.890]                 }
[09:29:14.890]                 ...future.workdir <- getwd()
[09:29:14.890]             }
[09:29:14.890]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.890]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.890]         }
[09:29:14.890]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.890]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.890]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.890]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.890]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.890]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.890]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.890]             base::names(...future.oldOptions))
[09:29:14.890]     }
[09:29:14.890]     if (FALSE) {
[09:29:14.890]     }
[09:29:14.890]     else {
[09:29:14.890]         if (TRUE) {
[09:29:14.890]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.890]                 open = "w")
[09:29:14.890]         }
[09:29:14.890]         else {
[09:29:14.890]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.890]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.890]         }
[09:29:14.890]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.890]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.890]             base::sink(type = "output", split = FALSE)
[09:29:14.890]             base::close(...future.stdout)
[09:29:14.890]         }, add = TRUE)
[09:29:14.890]     }
[09:29:14.890]     ...future.frame <- base::sys.nframe()
[09:29:14.890]     ...future.conditions <- base::list()
[09:29:14.890]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.890]     if (FALSE) {
[09:29:14.890]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.890]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.890]     }
[09:29:14.890]     ...future.result <- base::tryCatch({
[09:29:14.890]         base::withCallingHandlers({
[09:29:14.890]             ...future.value <- base::withVisible(base::local({
[09:29:14.890]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.890]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.890]                   ...future.globals.maxSize)) {
[09:29:14.890]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.890]                   on.exit(options(oopts), add = TRUE)
[09:29:14.890]                 }
[09:29:14.890]                 {
[09:29:14.890]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.890]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.890]                     USE.NAMES = FALSE)
[09:29:14.890]                   do.call(mapply, args = args)
[09:29:14.890]                 }
[09:29:14.890]             }))
[09:29:14.890]             future::FutureResult(value = ...future.value$value, 
[09:29:14.890]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.890]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.890]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.890]                     ...future.globalenv.names))
[09:29:14.890]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.890]         }, condition = base::local({
[09:29:14.890]             c <- base::c
[09:29:14.890]             inherits <- base::inherits
[09:29:14.890]             invokeRestart <- base::invokeRestart
[09:29:14.890]             length <- base::length
[09:29:14.890]             list <- base::list
[09:29:14.890]             seq.int <- base::seq.int
[09:29:14.890]             signalCondition <- base::signalCondition
[09:29:14.890]             sys.calls <- base::sys.calls
[09:29:14.890]             `[[` <- base::`[[`
[09:29:14.890]             `+` <- base::`+`
[09:29:14.890]             `<<-` <- base::`<<-`
[09:29:14.890]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.890]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.890]                   3L)]
[09:29:14.890]             }
[09:29:14.890]             function(cond) {
[09:29:14.890]                 is_error <- inherits(cond, "error")
[09:29:14.890]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.890]                   NULL)
[09:29:14.890]                 if (is_error) {
[09:29:14.890]                   sessionInformation <- function() {
[09:29:14.890]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.890]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.890]                       search = base::search(), system = base::Sys.info())
[09:29:14.890]                   }
[09:29:14.890]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.890]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.890]                     cond$call), session = sessionInformation(), 
[09:29:14.890]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.890]                   signalCondition(cond)
[09:29:14.890]                 }
[09:29:14.890]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.890]                 "immediateCondition"))) {
[09:29:14.890]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.890]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.890]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.890]                   if (TRUE && !signal) {
[09:29:14.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.890]                     {
[09:29:14.890]                       inherits <- base::inherits
[09:29:14.890]                       invokeRestart <- base::invokeRestart
[09:29:14.890]                       is.null <- base::is.null
[09:29:14.890]                       muffled <- FALSE
[09:29:14.890]                       if (inherits(cond, "message")) {
[09:29:14.890]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.890]                         if (muffled) 
[09:29:14.890]                           invokeRestart("muffleMessage")
[09:29:14.890]                       }
[09:29:14.890]                       else if (inherits(cond, "warning")) {
[09:29:14.890]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.890]                         if (muffled) 
[09:29:14.890]                           invokeRestart("muffleWarning")
[09:29:14.890]                       }
[09:29:14.890]                       else if (inherits(cond, "condition")) {
[09:29:14.890]                         if (!is.null(pattern)) {
[09:29:14.890]                           computeRestarts <- base::computeRestarts
[09:29:14.890]                           grepl <- base::grepl
[09:29:14.890]                           restarts <- computeRestarts(cond)
[09:29:14.890]                           for (restart in restarts) {
[09:29:14.890]                             name <- restart$name
[09:29:14.890]                             if (is.null(name)) 
[09:29:14.890]                               next
[09:29:14.890]                             if (!grepl(pattern, name)) 
[09:29:14.890]                               next
[09:29:14.890]                             invokeRestart(restart)
[09:29:14.890]                             muffled <- TRUE
[09:29:14.890]                             break
[09:29:14.890]                           }
[09:29:14.890]                         }
[09:29:14.890]                       }
[09:29:14.890]                       invisible(muffled)
[09:29:14.890]                     }
[09:29:14.890]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.890]                   }
[09:29:14.890]                 }
[09:29:14.890]                 else {
[09:29:14.890]                   if (TRUE) {
[09:29:14.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.890]                     {
[09:29:14.890]                       inherits <- base::inherits
[09:29:14.890]                       invokeRestart <- base::invokeRestart
[09:29:14.890]                       is.null <- base::is.null
[09:29:14.890]                       muffled <- FALSE
[09:29:14.890]                       if (inherits(cond, "message")) {
[09:29:14.890]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.890]                         if (muffled) 
[09:29:14.890]                           invokeRestart("muffleMessage")
[09:29:14.890]                       }
[09:29:14.890]                       else if (inherits(cond, "warning")) {
[09:29:14.890]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.890]                         if (muffled) 
[09:29:14.890]                           invokeRestart("muffleWarning")
[09:29:14.890]                       }
[09:29:14.890]                       else if (inherits(cond, "condition")) {
[09:29:14.890]                         if (!is.null(pattern)) {
[09:29:14.890]                           computeRestarts <- base::computeRestarts
[09:29:14.890]                           grepl <- base::grepl
[09:29:14.890]                           restarts <- computeRestarts(cond)
[09:29:14.890]                           for (restart in restarts) {
[09:29:14.890]                             name <- restart$name
[09:29:14.890]                             if (is.null(name)) 
[09:29:14.890]                               next
[09:29:14.890]                             if (!grepl(pattern, name)) 
[09:29:14.890]                               next
[09:29:14.890]                             invokeRestart(restart)
[09:29:14.890]                             muffled <- TRUE
[09:29:14.890]                             break
[09:29:14.890]                           }
[09:29:14.890]                         }
[09:29:14.890]                       }
[09:29:14.890]                       invisible(muffled)
[09:29:14.890]                     }
[09:29:14.890]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.890]                   }
[09:29:14.890]                 }
[09:29:14.890]             }
[09:29:14.890]         }))
[09:29:14.890]     }, error = function(ex) {
[09:29:14.890]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.890]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.890]                 ...future.rng), started = ...future.startTime, 
[09:29:14.890]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.890]             version = "1.8"), class = "FutureResult")
[09:29:14.890]     }, finally = {
[09:29:14.890]         if (!identical(...future.workdir, getwd())) 
[09:29:14.890]             setwd(...future.workdir)
[09:29:14.890]         {
[09:29:14.890]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.890]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.890]             }
[09:29:14.890]             base::options(...future.oldOptions)
[09:29:14.890]             if (.Platform$OS.type == "windows") {
[09:29:14.890]                 old_names <- names(...future.oldEnvVars)
[09:29:14.890]                 envs <- base::Sys.getenv()
[09:29:14.890]                 names <- names(envs)
[09:29:14.890]                 common <- intersect(names, old_names)
[09:29:14.890]                 added <- setdiff(names, old_names)
[09:29:14.890]                 removed <- setdiff(old_names, names)
[09:29:14.890]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.890]                   envs[common]]
[09:29:14.890]                 NAMES <- toupper(changed)
[09:29:14.890]                 args <- list()
[09:29:14.890]                 for (kk in seq_along(NAMES)) {
[09:29:14.890]                   name <- changed[[kk]]
[09:29:14.890]                   NAME <- NAMES[[kk]]
[09:29:14.890]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.890]                     next
[09:29:14.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.890]                 }
[09:29:14.890]                 NAMES <- toupper(added)
[09:29:14.890]                 for (kk in seq_along(NAMES)) {
[09:29:14.890]                   name <- added[[kk]]
[09:29:14.890]                   NAME <- NAMES[[kk]]
[09:29:14.890]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.890]                     next
[09:29:14.890]                   args[[name]] <- ""
[09:29:14.890]                 }
[09:29:14.890]                 NAMES <- toupper(removed)
[09:29:14.890]                 for (kk in seq_along(NAMES)) {
[09:29:14.890]                   name <- removed[[kk]]
[09:29:14.890]                   NAME <- NAMES[[kk]]
[09:29:14.890]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.890]                     next
[09:29:14.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.890]                 }
[09:29:14.890]                 if (length(args) > 0) 
[09:29:14.890]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.890]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.890]             }
[09:29:14.890]             else {
[09:29:14.890]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.890]             }
[09:29:14.890]             {
[09:29:14.890]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.890]                   0L) {
[09:29:14.890]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.890]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.890]                   base::options(opts)
[09:29:14.890]                 }
[09:29:14.890]                 {
[09:29:14.890]                   {
[09:29:14.890]                     base::assign(".Random.seed", c(10407L, 1526525595L, 
[09:29:14.890]                     1834748666L, 1375929630L, 56797152L, -1188802245L, 
[09:29:14.890]                     2055751927L), envir = base::globalenv(), 
[09:29:14.890]                       inherits = FALSE)
[09:29:14.890]                     NULL
[09:29:14.890]                   }
[09:29:14.890]                   options(future.plan = NULL)
[09:29:14.890]                   if (is.na(NA_character_)) 
[09:29:14.890]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.890]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.890]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.890]                     .init = FALSE)
[09:29:14.890]                 }
[09:29:14.890]             }
[09:29:14.890]         }
[09:29:14.890]     })
[09:29:14.890]     if (TRUE) {
[09:29:14.890]         base::sink(type = "output", split = FALSE)
[09:29:14.890]         if (TRUE) {
[09:29:14.890]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.890]         }
[09:29:14.890]         else {
[09:29:14.890]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.890]         }
[09:29:14.890]         base::close(...future.stdout)
[09:29:14.890]         ...future.stdout <- NULL
[09:29:14.890]     }
[09:29:14.890]     ...future.result$conditions <- ...future.conditions
[09:29:14.890]     ...future.result$finished <- base::Sys.time()
[09:29:14.890]     ...future.result
[09:29:14.890] }
[09:29:14.891] assign_globals() ...
[09:29:14.891] List of 5
[09:29:14.891]  $ ...future.FUN            :function (x, y)  
[09:29:14.891]  $ MoreArgs                 :List of 1
[09:29:14.891]   ..$ y: int [1:2] 3 4
[09:29:14.891]  $ ...future.elements_ii    :List of 1
[09:29:14.891]   ..$ x:List of 2
[09:29:14.891]   .. ..$ : int 1
[09:29:14.891]   .. ..$ : int 2
[09:29:14.891]  $ ...future.seeds_ii       : NULL
[09:29:14.891]  $ ...future.globals.maxSize: NULL
[09:29:14.891]  - attr(*, "where")=List of 5
[09:29:14.891]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.891]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.891]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.891]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.891]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.891]  - attr(*, "resolved")= logi FALSE
[09:29:14.891]  - attr(*, "total_size")= num 1872
[09:29:14.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.891]  - attr(*, "already-done")= logi TRUE
[09:29:14.896] - reassign environment for ‘...future.FUN’
[09:29:14.896] - copied ‘...future.FUN’ to environment
[09:29:14.896] - copied ‘MoreArgs’ to environment
[09:29:14.896] - copied ‘...future.elements_ii’ to environment
[09:29:14.896] - copied ‘...future.seeds_ii’ to environment
[09:29:14.896] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.897] assign_globals() ... done
[09:29:14.897] plan(): Setting new future strategy stack:
[09:29:14.897] List of future strategies:
[09:29:14.897] 1. sequential:
[09:29:14.897]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.897]    - tweaked: FALSE
[09:29:14.897]    - call: NULL
[09:29:14.897] plan(): nbrOfWorkers() = 1
[09:29:14.898] plan(): Setting new future strategy stack:
[09:29:14.898] List of future strategies:
[09:29:14.898] 1. sequential:
[09:29:14.898]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.898]    - tweaked: FALSE
[09:29:14.898]    - call: plan(strategy)
[09:29:14.898] plan(): nbrOfWorkers() = 1
[09:29:14.899] SequentialFuture started (and completed)
[09:29:14.899] - Launch lazy future ... done
[09:29:14.899] run() for ‘SequentialFuture’ ... done
[09:29:14.899] Created future:
[09:29:14.899] SequentialFuture:
[09:29:14.899] Label: ‘future_.mapply-1’
[09:29:14.899] Expression:
[09:29:14.899] {
[09:29:14.899]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.899]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.899]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.899]         on.exit(options(oopts), add = TRUE)
[09:29:14.899]     }
[09:29:14.899]     {
[09:29:14.899]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.899]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.899]         do.call(mapply, args = args)
[09:29:14.899]     }
[09:29:14.899] }
[09:29:14.899] Lazy evaluation: FALSE
[09:29:14.899] Asynchronous evaluation: FALSE
[09:29:14.899] Local evaluation: TRUE
[09:29:14.899] Environment: R_GlobalEnv
[09:29:14.899] Capture standard output: TRUE
[09:29:14.899] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.899] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.899] Packages: <none>
[09:29:14.899] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.899] Resolved: TRUE
[09:29:14.899] Value: 112 bytes of class ‘list’
[09:29:14.899] Early signaling: FALSE
[09:29:14.899] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.899] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.900] Chunk #1 of 1 ... DONE
[09:29:14.900] Launching 1 futures (chunks) ... DONE
[09:29:14.900] Resolving 1 futures (chunks) ...
[09:29:14.900] resolve() on list ...
[09:29:14.900]  recursive: 0
[09:29:14.900]  length: 1
[09:29:14.900] 
[09:29:14.900] resolved() for ‘SequentialFuture’ ...
[09:29:14.900] - state: ‘finished’
[09:29:14.901] - run: TRUE
[09:29:14.901] - result: ‘FutureResult’
[09:29:14.901] resolved() for ‘SequentialFuture’ ... done
[09:29:14.901] Future #1
[09:29:14.901] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.901] - nx: 1
[09:29:14.901] - relay: TRUE
[09:29:14.901] - stdout: TRUE
[09:29:14.901] - signal: TRUE
[09:29:14.901] - resignal: FALSE
[09:29:14.901] - force: TRUE
[09:29:14.901] - relayed: [n=1] FALSE
[09:29:14.902] - queued futures: [n=1] FALSE
[09:29:14.902]  - until=1
[09:29:14.902]  - relaying element #1
[09:29:14.902] - relayed: [n=1] TRUE
[09:29:14.902] - queued futures: [n=1] TRUE
[09:29:14.902] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.902]  length: 0 (resolved future 1)
[09:29:14.902] Relaying remaining futures
[09:29:14.902] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.902] - nx: 1
[09:29:14.902] - relay: TRUE
[09:29:14.903] - stdout: TRUE
[09:29:14.903] - signal: TRUE
[09:29:14.903] - resignal: FALSE
[09:29:14.903] - force: TRUE
[09:29:14.903] - relayed: [n=1] TRUE
[09:29:14.903] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.903] - relayed: [n=1] TRUE
[09:29:14.903] - queued futures: [n=1] TRUE
[09:29:14.903] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.903] resolve() on list ... DONE
[09:29:14.903]  - Number of value chunks collected: 1
[09:29:14.904] Resolving 1 futures (chunks) ... DONE
[09:29:14.904] Reducing values from 1 chunks ...
[09:29:14.904]  - Number of values collected after concatenation: 2
[09:29:14.904]  - Number of values expected: 2
[09:29:14.904] Reducing values from 1 chunks ... DONE
[09:29:14.904] future_mapply() ... DONE
- Recycle arguments to same length ...
[09:29:14.904] future_mapply() ...
[09:29:14.904] Number of chunks: 1
[09:29:14.904] getGlobalsAndPackagesXApply() ...
[09:29:14.904]  - future.globals: TRUE
[09:29:14.905] getGlobalsAndPackages() ...
[09:29:14.905] Searching for globals...
[09:29:14.905] - globals found: [1] ‘FUN’
[09:29:14.905] Searching for globals ... DONE
[09:29:14.905] Resolving globals: FALSE
[09:29:14.906] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:14.906] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:14.906] - globals: [1] ‘FUN’
[09:29:14.906] 
[09:29:14.906] getGlobalsAndPackages() ... DONE
[09:29:14.906]  - globals found/used: [n=1] ‘FUN’
[09:29:14.906]  - needed namespaces: [n=0] 
[09:29:14.906] Finding globals ... DONE
[09:29:14.907] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.907] List of 2
[09:29:14.907]  $ ...future.FUN:function (x, ...)  
[09:29:14.907]  $ MoreArgs     : NULL
[09:29:14.907]  - attr(*, "where")=List of 2
[09:29:14.907]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.907]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.907]  - attr(*, "resolved")= logi FALSE
[09:29:14.907]  - attr(*, "total_size")= num NA
[09:29:14.910] Packages to be attached in all futures: [n=0] 
[09:29:14.910] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.910] Number of futures (= number of chunks): 1
[09:29:14.910] Launching 1 futures (chunks) ...
[09:29:14.910] Chunk #1 of 1 ...
[09:29:14.911]  - Finding globals in '...' for chunk #1 ...
[09:29:14.911] getGlobalsAndPackages() ...
[09:29:14.911] Searching for globals...
[09:29:14.911] 
[09:29:14.911] Searching for globals ... DONE
[09:29:14.911] - globals: [0] <none>
[09:29:14.911] getGlobalsAndPackages() ... DONE
[09:29:14.911]    + additional globals found: [n=0] 
[09:29:14.912]    + additional namespaces needed: [n=0] 
[09:29:14.912]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.912]  - seeds: <none>
[09:29:14.912]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.912] getGlobalsAndPackages() ...
[09:29:14.912] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.912] Resolving globals: FALSE
[09:29:14.913] The total size of the 5 globals is 504 bytes (504 bytes)
[09:29:14.913] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.913] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.913] 
[09:29:14.913] getGlobalsAndPackages() ... DONE
[09:29:14.913] run() for ‘Future’ ...
[09:29:14.914] - state: ‘created’
[09:29:14.914] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.914] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.914] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.914]   - Field: ‘label’
[09:29:14.914]   - Field: ‘local’
[09:29:14.914]   - Field: ‘owner’
[09:29:14.914]   - Field: ‘envir’
[09:29:14.914]   - Field: ‘packages’
[09:29:14.915]   - Field: ‘gc’
[09:29:14.915]   - Field: ‘conditions’
[09:29:14.915]   - Field: ‘expr’
[09:29:14.915]   - Field: ‘uuid’
[09:29:14.915]   - Field: ‘seed’
[09:29:14.915]   - Field: ‘version’
[09:29:14.915]   - Field: ‘result’
[09:29:14.915]   - Field: ‘asynchronous’
[09:29:14.915]   - Field: ‘calls’
[09:29:14.915]   - Field: ‘globals’
[09:29:14.915]   - Field: ‘stdout’
[09:29:14.915]   - Field: ‘earlySignal’
[09:29:14.916]   - Field: ‘lazy’
[09:29:14.916]   - Field: ‘state’
[09:29:14.916] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.916] - Launch lazy future ...
[09:29:14.916] Packages needed by the future expression (n = 0): <none>
[09:29:14.916] Packages needed by future strategies (n = 0): <none>
[09:29:14.917] {
[09:29:14.917]     {
[09:29:14.917]         {
[09:29:14.917]             ...future.startTime <- base::Sys.time()
[09:29:14.917]             {
[09:29:14.917]                 {
[09:29:14.917]                   {
[09:29:14.917]                     base::local({
[09:29:14.917]                       has_future <- base::requireNamespace("future", 
[09:29:14.917]                         quietly = TRUE)
[09:29:14.917]                       if (has_future) {
[09:29:14.917]                         ns <- base::getNamespace("future")
[09:29:14.917]                         version <- ns[[".package"]][["version"]]
[09:29:14.917]                         if (is.null(version)) 
[09:29:14.917]                           version <- utils::packageVersion("future")
[09:29:14.917]                       }
[09:29:14.917]                       else {
[09:29:14.917]                         version <- NULL
[09:29:14.917]                       }
[09:29:14.917]                       if (!has_future || version < "1.8.0") {
[09:29:14.917]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.917]                           "", base::R.version$version.string), 
[09:29:14.917]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:14.917]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.917]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.917]                             "release", "version")], collapse = " "), 
[09:29:14.917]                           hostname = base::Sys.info()[["nodename"]])
[09:29:14.917]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.917]                           info)
[09:29:14.917]                         info <- base::paste(info, collapse = "; ")
[09:29:14.917]                         if (!has_future) {
[09:29:14.917]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.917]                             info)
[09:29:14.917]                         }
[09:29:14.917]                         else {
[09:29:14.917]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.917]                             info, version)
[09:29:14.917]                         }
[09:29:14.917]                         base::stop(msg)
[09:29:14.917]                       }
[09:29:14.917]                     })
[09:29:14.917]                   }
[09:29:14.917]                   ...future.strategy.old <- future::plan("list")
[09:29:14.917]                   options(future.plan = NULL)
[09:29:14.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.917]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.917]                 }
[09:29:14.917]                 ...future.workdir <- getwd()
[09:29:14.917]             }
[09:29:14.917]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.917]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.917]         }
[09:29:14.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.917]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.917]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.917]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.917]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.917]             base::names(...future.oldOptions))
[09:29:14.917]     }
[09:29:14.917]     if (FALSE) {
[09:29:14.917]     }
[09:29:14.917]     else {
[09:29:14.917]         if (TRUE) {
[09:29:14.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.917]                 open = "w")
[09:29:14.917]         }
[09:29:14.917]         else {
[09:29:14.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.917]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.917]         }
[09:29:14.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.917]             base::sink(type = "output", split = FALSE)
[09:29:14.917]             base::close(...future.stdout)
[09:29:14.917]         }, add = TRUE)
[09:29:14.917]     }
[09:29:14.917]     ...future.frame <- base::sys.nframe()
[09:29:14.917]     ...future.conditions <- base::list()
[09:29:14.917]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.917]     if (FALSE) {
[09:29:14.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.917]     }
[09:29:14.917]     ...future.result <- base::tryCatch({
[09:29:14.917]         base::withCallingHandlers({
[09:29:14.917]             ...future.value <- base::withVisible(base::local({
[09:29:14.917]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.917]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.917]                   ...future.globals.maxSize)) {
[09:29:14.917]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.917]                   on.exit(options(oopts), add = TRUE)
[09:29:14.917]                 }
[09:29:14.917]                 {
[09:29:14.917]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.917]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.917]                     USE.NAMES = FALSE)
[09:29:14.917]                   do.call(mapply, args = args)
[09:29:14.917]                 }
[09:29:14.917]             }))
[09:29:14.917]             future::FutureResult(value = ...future.value$value, 
[09:29:14.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.917]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.917]                     ...future.globalenv.names))
[09:29:14.917]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.917]         }, condition = base::local({
[09:29:14.917]             c <- base::c
[09:29:14.917]             inherits <- base::inherits
[09:29:14.917]             invokeRestart <- base::invokeRestart
[09:29:14.917]             length <- base::length
[09:29:14.917]             list <- base::list
[09:29:14.917]             seq.int <- base::seq.int
[09:29:14.917]             signalCondition <- base::signalCondition
[09:29:14.917]             sys.calls <- base::sys.calls
[09:29:14.917]             `[[` <- base::`[[`
[09:29:14.917]             `+` <- base::`+`
[09:29:14.917]             `<<-` <- base::`<<-`
[09:29:14.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.917]                   3L)]
[09:29:14.917]             }
[09:29:14.917]             function(cond) {
[09:29:14.917]                 is_error <- inherits(cond, "error")
[09:29:14.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.917]                   NULL)
[09:29:14.917]                 if (is_error) {
[09:29:14.917]                   sessionInformation <- function() {
[09:29:14.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.917]                       search = base::search(), system = base::Sys.info())
[09:29:14.917]                   }
[09:29:14.917]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.917]                     cond$call), session = sessionInformation(), 
[09:29:14.917]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.917]                   signalCondition(cond)
[09:29:14.917]                 }
[09:29:14.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.917]                 "immediateCondition"))) {
[09:29:14.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.917]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.917]                   if (TRUE && !signal) {
[09:29:14.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.917]                     {
[09:29:14.917]                       inherits <- base::inherits
[09:29:14.917]                       invokeRestart <- base::invokeRestart
[09:29:14.917]                       is.null <- base::is.null
[09:29:14.917]                       muffled <- FALSE
[09:29:14.917]                       if (inherits(cond, "message")) {
[09:29:14.917]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.917]                         if (muffled) 
[09:29:14.917]                           invokeRestart("muffleMessage")
[09:29:14.917]                       }
[09:29:14.917]                       else if (inherits(cond, "warning")) {
[09:29:14.917]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.917]                         if (muffled) 
[09:29:14.917]                           invokeRestart("muffleWarning")
[09:29:14.917]                       }
[09:29:14.917]                       else if (inherits(cond, "condition")) {
[09:29:14.917]                         if (!is.null(pattern)) {
[09:29:14.917]                           computeRestarts <- base::computeRestarts
[09:29:14.917]                           grepl <- base::grepl
[09:29:14.917]                           restarts <- computeRestarts(cond)
[09:29:14.917]                           for (restart in restarts) {
[09:29:14.917]                             name <- restart$name
[09:29:14.917]                             if (is.null(name)) 
[09:29:14.917]                               next
[09:29:14.917]                             if (!grepl(pattern, name)) 
[09:29:14.917]                               next
[09:29:14.917]                             invokeRestart(restart)
[09:29:14.917]                             muffled <- TRUE
[09:29:14.917]                             break
[09:29:14.917]                           }
[09:29:14.917]                         }
[09:29:14.917]                       }
[09:29:14.917]                       invisible(muffled)
[09:29:14.917]                     }
[09:29:14.917]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.917]                   }
[09:29:14.917]                 }
[09:29:14.917]                 else {
[09:29:14.917]                   if (TRUE) {
[09:29:14.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.917]                     {
[09:29:14.917]                       inherits <- base::inherits
[09:29:14.917]                       invokeRestart <- base::invokeRestart
[09:29:14.917]                       is.null <- base::is.null
[09:29:14.917]                       muffled <- FALSE
[09:29:14.917]                       if (inherits(cond, "message")) {
[09:29:14.917]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.917]                         if (muffled) 
[09:29:14.917]                           invokeRestart("muffleMessage")
[09:29:14.917]                       }
[09:29:14.917]                       else if (inherits(cond, "warning")) {
[09:29:14.917]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.917]                         if (muffled) 
[09:29:14.917]                           invokeRestart("muffleWarning")
[09:29:14.917]                       }
[09:29:14.917]                       else if (inherits(cond, "condition")) {
[09:29:14.917]                         if (!is.null(pattern)) {
[09:29:14.917]                           computeRestarts <- base::computeRestarts
[09:29:14.917]                           grepl <- base::grepl
[09:29:14.917]                           restarts <- computeRestarts(cond)
[09:29:14.917]                           for (restart in restarts) {
[09:29:14.917]                             name <- restart$name
[09:29:14.917]                             if (is.null(name)) 
[09:29:14.917]                               next
[09:29:14.917]                             if (!grepl(pattern, name)) 
[09:29:14.917]                               next
[09:29:14.917]                             invokeRestart(restart)
[09:29:14.917]                             muffled <- TRUE
[09:29:14.917]                             break
[09:29:14.917]                           }
[09:29:14.917]                         }
[09:29:14.917]                       }
[09:29:14.917]                       invisible(muffled)
[09:29:14.917]                     }
[09:29:14.917]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.917]                   }
[09:29:14.917]                 }
[09:29:14.917]             }
[09:29:14.917]         }))
[09:29:14.917]     }, error = function(ex) {
[09:29:14.917]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.917]                 ...future.rng), started = ...future.startTime, 
[09:29:14.917]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.917]             version = "1.8"), class = "FutureResult")
[09:29:14.917]     }, finally = {
[09:29:14.917]         if (!identical(...future.workdir, getwd())) 
[09:29:14.917]             setwd(...future.workdir)
[09:29:14.917]         {
[09:29:14.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.917]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.917]             }
[09:29:14.917]             base::options(...future.oldOptions)
[09:29:14.917]             if (.Platform$OS.type == "windows") {
[09:29:14.917]                 old_names <- names(...future.oldEnvVars)
[09:29:14.917]                 envs <- base::Sys.getenv()
[09:29:14.917]                 names <- names(envs)
[09:29:14.917]                 common <- intersect(names, old_names)
[09:29:14.917]                 added <- setdiff(names, old_names)
[09:29:14.917]                 removed <- setdiff(old_names, names)
[09:29:14.917]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.917]                   envs[common]]
[09:29:14.917]                 NAMES <- toupper(changed)
[09:29:14.917]                 args <- list()
[09:29:14.917]                 for (kk in seq_along(NAMES)) {
[09:29:14.917]                   name <- changed[[kk]]
[09:29:14.917]                   NAME <- NAMES[[kk]]
[09:29:14.917]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.917]                     next
[09:29:14.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.917]                 }
[09:29:14.917]                 NAMES <- toupper(added)
[09:29:14.917]                 for (kk in seq_along(NAMES)) {
[09:29:14.917]                   name <- added[[kk]]
[09:29:14.917]                   NAME <- NAMES[[kk]]
[09:29:14.917]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.917]                     next
[09:29:14.917]                   args[[name]] <- ""
[09:29:14.917]                 }
[09:29:14.917]                 NAMES <- toupper(removed)
[09:29:14.917]                 for (kk in seq_along(NAMES)) {
[09:29:14.917]                   name <- removed[[kk]]
[09:29:14.917]                   NAME <- NAMES[[kk]]
[09:29:14.917]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.917]                     next
[09:29:14.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.917]                 }
[09:29:14.917]                 if (length(args) > 0) 
[09:29:14.917]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.917]             }
[09:29:14.917]             else {
[09:29:14.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.917]             }
[09:29:14.917]             {
[09:29:14.917]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.917]                   0L) {
[09:29:14.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.917]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.917]                   base::options(opts)
[09:29:14.917]                 }
[09:29:14.917]                 {
[09:29:14.917]                   {
[09:29:14.917]                     base::assign(".Random.seed", c(10407L, 1526525595L, 
[09:29:14.917]                     1834748666L, 1375929630L, 56797152L, -1188802245L, 
[09:29:14.917]                     2055751927L), envir = base::globalenv(), 
[09:29:14.917]                       inherits = FALSE)
[09:29:14.917]                     NULL
[09:29:14.917]                   }
[09:29:14.917]                   options(future.plan = NULL)
[09:29:14.917]                   if (is.na(NA_character_)) 
[09:29:14.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.917]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.917]                     .init = FALSE)
[09:29:14.917]                 }
[09:29:14.917]             }
[09:29:14.917]         }
[09:29:14.917]     })
[09:29:14.917]     if (TRUE) {
[09:29:14.917]         base::sink(type = "output", split = FALSE)
[09:29:14.917]         if (TRUE) {
[09:29:14.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.917]         }
[09:29:14.917]         else {
[09:29:14.917]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.917]         }
[09:29:14.917]         base::close(...future.stdout)
[09:29:14.917]         ...future.stdout <- NULL
[09:29:14.917]     }
[09:29:14.917]     ...future.result$conditions <- ...future.conditions
[09:29:14.917]     ...future.result$finished <- base::Sys.time()
[09:29:14.917]     ...future.result
[09:29:14.917] }
[09:29:14.918] assign_globals() ...
[09:29:14.918] List of 5
[09:29:14.918]  $ ...future.FUN            :function (x, ...)  
[09:29:14.918]  $ MoreArgs                 : NULL
[09:29:14.918]  $ ...future.elements_ii    :List of 2
[09:29:14.918]   ..$ :List of 4
[09:29:14.918]   .. ..$ : int 1
[09:29:14.918]   .. ..$ : int 2
[09:29:14.918]   .. ..$ : int 3
[09:29:14.918]   .. ..$ : int 4
[09:29:14.918]   ..$ :List of 4
[09:29:14.918]   .. ..$ : int 2
[09:29:14.918]   .. ..$ : int 1
[09:29:14.918]   .. ..$ : int 2
[09:29:14.918]   .. ..$ : int 1
[09:29:14.918]  $ ...future.seeds_ii       : NULL
[09:29:14.918]  $ ...future.globals.maxSize: NULL
[09:29:14.918]  - attr(*, "where")=List of 5
[09:29:14.918]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.918]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.918]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.918]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.918]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.918]  - attr(*, "resolved")= logi FALSE
[09:29:14.918]  - attr(*, "total_size")= num 504
[09:29:14.918]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.918]  - attr(*, "already-done")= logi TRUE
[09:29:14.924] - copied ‘...future.FUN’ to environment
[09:29:14.924] - copied ‘MoreArgs’ to environment
[09:29:14.924] - copied ‘...future.elements_ii’ to environment
[09:29:14.925] - copied ‘...future.seeds_ii’ to environment
[09:29:14.925] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.925] assign_globals() ... done
[09:29:14.925] plan(): Setting new future strategy stack:
[09:29:14.925] List of future strategies:
[09:29:14.925] 1. sequential:
[09:29:14.925]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.925]    - tweaked: FALSE
[09:29:14.925]    - call: NULL
[09:29:14.925] plan(): nbrOfWorkers() = 1
[09:29:14.926] plan(): Setting new future strategy stack:
[09:29:14.926] List of future strategies:
[09:29:14.926] 1. sequential:
[09:29:14.926]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.926]    - tweaked: FALSE
[09:29:14.926]    - call: plan(strategy)
[09:29:14.927] plan(): nbrOfWorkers() = 1
[09:29:14.927] SequentialFuture started (and completed)
[09:29:14.927] - Launch lazy future ... done
[09:29:14.927] run() for ‘SequentialFuture’ ... done
[09:29:14.927] Created future:
[09:29:14.927] SequentialFuture:
[09:29:14.927] Label: ‘future_mapply-1’
[09:29:14.927] Expression:
[09:29:14.927] {
[09:29:14.927]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.927]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.927]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.927]         on.exit(options(oopts), add = TRUE)
[09:29:14.927]     }
[09:29:14.927]     {
[09:29:14.927]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.927]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.927]         do.call(mapply, args = args)
[09:29:14.927]     }
[09:29:14.927] }
[09:29:14.927] Lazy evaluation: FALSE
[09:29:14.927] Asynchronous evaluation: FALSE
[09:29:14.927] Local evaluation: TRUE
[09:29:14.927] Environment: R_GlobalEnv
[09:29:14.927] Capture standard output: TRUE
[09:29:14.927] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.927] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.927] Packages: <none>
[09:29:14.927] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.927] Resolved: TRUE
[09:29:14.927] Value: 224 bytes of class ‘list’
[09:29:14.927] Early signaling: FALSE
[09:29:14.927] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.927] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.928] Chunk #1 of 1 ... DONE
[09:29:14.928] Launching 1 futures (chunks) ... DONE
[09:29:14.928] Resolving 1 futures (chunks) ...
[09:29:14.928] resolve() on list ...
[09:29:14.928]  recursive: 0
[09:29:14.928]  length: 1
[09:29:14.929] 
[09:29:14.929] resolved() for ‘SequentialFuture’ ...
[09:29:14.930] - state: ‘finished’
[09:29:14.930] - run: TRUE
[09:29:14.930] - result: ‘FutureResult’
[09:29:14.930] resolved() for ‘SequentialFuture’ ... done
[09:29:14.930] Future #1
[09:29:14.930] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.930] - nx: 1
[09:29:14.930] - relay: TRUE
[09:29:14.930] - stdout: TRUE
[09:29:14.931] - signal: TRUE
[09:29:14.931] - resignal: FALSE
[09:29:14.931] - force: TRUE
[09:29:14.931] - relayed: [n=1] FALSE
[09:29:14.931] - queued futures: [n=1] FALSE
[09:29:14.931]  - until=1
[09:29:14.931]  - relaying element #1
[09:29:14.931] - relayed: [n=1] TRUE
[09:29:14.931] - queued futures: [n=1] TRUE
[09:29:14.931] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.932]  length: 0 (resolved future 1)
[09:29:14.932] Relaying remaining futures
[09:29:14.932] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.932] - nx: 1
[09:29:14.932] - relay: TRUE
[09:29:14.932] - stdout: TRUE
[09:29:14.932] - signal: TRUE
[09:29:14.932] - resignal: FALSE
[09:29:14.932] - force: TRUE
[09:29:14.932] - relayed: [n=1] TRUE
[09:29:14.932] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.932] - relayed: [n=1] TRUE
[09:29:14.933] - queued futures: [n=1] TRUE
[09:29:14.933] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.933] resolve() on list ... DONE
[09:29:14.933]  - Number of value chunks collected: 1
[09:29:14.933] Resolving 1 futures (chunks) ... DONE
[09:29:14.933] Reducing values from 1 chunks ...
[09:29:14.933]  - Number of values collected after concatenation: 4
[09:29:14.933]  - Number of values expected: 4
[09:29:14.933] Reducing values from 1 chunks ... DONE
[09:29:14.933] future_mapply() ... DONE
- Parallel RNG ...
[09:29:14.933] future_mapply() ...
[09:29:14.934] Generating random seeds ...
[09:29:14.934] Generating random seed streams for 4 elements ...
[09:29:14.934] Generating random seed streams for 4 elements ... DONE
[09:29:14.934] Generating random seeds ... DONE
[09:29:14.934] Will set RNG state on exit: 10407, 1375929630, -764567282, 2079058973, 2055751927, -1272738459, -513300596
[09:29:14.934] Number of chunks: 1
[09:29:14.934] getGlobalsAndPackagesXApply() ...
[09:29:14.934]  - future.globals: TRUE
[09:29:14.934] getGlobalsAndPackages() ...
[09:29:14.934] Searching for globals...
[09:29:14.936] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[09:29:14.936] Searching for globals ... DONE
[09:29:14.936] Resolving globals: FALSE
[09:29:14.936] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[09:29:14.936] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[09:29:14.937] - globals: [1] ‘FUN’
[09:29:14.937] - packages: [1] ‘stats’
[09:29:14.937] getGlobalsAndPackages() ... DONE
[09:29:14.937]  - globals found/used: [n=1] ‘FUN’
[09:29:14.937]  - needed namespaces: [n=1] ‘stats’
[09:29:14.937] Finding globals ... DONE
[09:29:14.937] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.937] List of 2
[09:29:14.937]  $ ...future.FUN:function (n, min = 0, max = 1)  
[09:29:14.937]  $ MoreArgs     :List of 1
[09:29:14.937]   ..$ min: num 1
[09:29:14.937]  - attr(*, "where")=List of 2
[09:29:14.937]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.937]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.937]  - attr(*, "resolved")= logi FALSE
[09:29:14.937]  - attr(*, "total_size")= num NA
[09:29:14.940] Packages to be attached in all futures: [n=1] ‘stats’
[09:29:14.940] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.940] Number of futures (= number of chunks): 1
[09:29:14.940] Launching 1 futures (chunks) ...
[09:29:14.940] Chunk #1 of 1 ...
[09:29:14.940]  - Finding globals in '...' for chunk #1 ...
[09:29:14.941] getGlobalsAndPackages() ...
[09:29:14.941] Searching for globals...
[09:29:14.941] 
[09:29:14.941] Searching for globals ... DONE
[09:29:14.941] - globals: [0] <none>
[09:29:14.941] getGlobalsAndPackages() ... DONE
[09:29:14.941]    + additional globals found: [n=0] 
[09:29:14.941]    + additional namespaces needed: [n=0] 
[09:29:14.941]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.941]  - seeds: [4] <seeds>
[09:29:14.942]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.942] getGlobalsAndPackages() ...
[09:29:14.942] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.942] Resolving globals: FALSE
[09:29:14.942] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[09:29:14.943] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[09:29:14.943] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.943] - packages: [1] ‘stats’
[09:29:14.943] getGlobalsAndPackages() ... DONE
[09:29:14.943] run() for ‘Future’ ...
[09:29:14.943] - state: ‘created’
[09:29:14.944] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.944] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.944] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.944]   - Field: ‘label’
[09:29:14.944]   - Field: ‘local’
[09:29:14.944]   - Field: ‘owner’
[09:29:14.944]   - Field: ‘envir’
[09:29:14.944]   - Field: ‘packages’
[09:29:14.944]   - Field: ‘gc’
[09:29:14.945]   - Field: ‘conditions’
[09:29:14.945]   - Field: ‘expr’
[09:29:14.945]   - Field: ‘uuid’
[09:29:14.945]   - Field: ‘seed’
[09:29:14.945]   - Field: ‘version’
[09:29:14.945]   - Field: ‘result’
[09:29:14.945]   - Field: ‘asynchronous’
[09:29:14.945]   - Field: ‘calls’
[09:29:14.945]   - Field: ‘globals’
[09:29:14.945]   - Field: ‘stdout’
[09:29:14.945]   - Field: ‘earlySignal’
[09:29:14.945]   - Field: ‘lazy’
[09:29:14.946]   - Field: ‘state’
[09:29:14.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.946] - Launch lazy future ...
[09:29:14.946] Packages needed by the future expression (n = 1): ‘stats’
[09:29:14.946] Packages needed by future strategies (n = 0): <none>
[09:29:14.946] {
[09:29:14.946]     {
[09:29:14.946]         {
[09:29:14.946]             ...future.startTime <- base::Sys.time()
[09:29:14.946]             {
[09:29:14.946]                 {
[09:29:14.946]                   {
[09:29:14.946]                     {
[09:29:14.946]                       base::local({
[09:29:14.946]                         has_future <- base::requireNamespace("future", 
[09:29:14.946]                           quietly = TRUE)
[09:29:14.946]                         if (has_future) {
[09:29:14.946]                           ns <- base::getNamespace("future")
[09:29:14.946]                           version <- ns[[".package"]][["version"]]
[09:29:14.946]                           if (is.null(version)) 
[09:29:14.946]                             version <- utils::packageVersion("future")
[09:29:14.946]                         }
[09:29:14.946]                         else {
[09:29:14.946]                           version <- NULL
[09:29:14.946]                         }
[09:29:14.946]                         if (!has_future || version < "1.8.0") {
[09:29:14.946]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.946]                             "", base::R.version$version.string), 
[09:29:14.946]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:14.946]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.946]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.946]                               "release", "version")], collapse = " "), 
[09:29:14.946]                             hostname = base::Sys.info()[["nodename"]])
[09:29:14.946]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.946]                             info)
[09:29:14.946]                           info <- base::paste(info, collapse = "; ")
[09:29:14.946]                           if (!has_future) {
[09:29:14.946]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.946]                               info)
[09:29:14.946]                           }
[09:29:14.946]                           else {
[09:29:14.946]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.946]                               info, version)
[09:29:14.946]                           }
[09:29:14.946]                           base::stop(msg)
[09:29:14.946]                         }
[09:29:14.946]                       })
[09:29:14.946]                     }
[09:29:14.946]                     base::local({
[09:29:14.946]                       for (pkg in "stats") {
[09:29:14.946]                         base::loadNamespace(pkg)
[09:29:14.946]                         base::library(pkg, character.only = TRUE)
[09:29:14.946]                       }
[09:29:14.946]                     })
[09:29:14.946]                   }
[09:29:14.946]                   ...future.strategy.old <- future::plan("list")
[09:29:14.946]                   options(future.plan = NULL)
[09:29:14.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.946]                 }
[09:29:14.946]                 ...future.workdir <- getwd()
[09:29:14.946]             }
[09:29:14.946]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.946]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.946]         }
[09:29:14.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.946]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.946]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.946]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.946]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.946]             base::names(...future.oldOptions))
[09:29:14.946]     }
[09:29:14.946]     if (FALSE) {
[09:29:14.946]     }
[09:29:14.946]     else {
[09:29:14.946]         if (TRUE) {
[09:29:14.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.946]                 open = "w")
[09:29:14.946]         }
[09:29:14.946]         else {
[09:29:14.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.946]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.946]         }
[09:29:14.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.946]             base::sink(type = "output", split = FALSE)
[09:29:14.946]             base::close(...future.stdout)
[09:29:14.946]         }, add = TRUE)
[09:29:14.946]     }
[09:29:14.946]     ...future.frame <- base::sys.nframe()
[09:29:14.946]     ...future.conditions <- base::list()
[09:29:14.946]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.946]     if (FALSE) {
[09:29:14.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.946]     }
[09:29:14.946]     ...future.result <- base::tryCatch({
[09:29:14.946]         base::withCallingHandlers({
[09:29:14.946]             ...future.value <- base::withVisible(base::local({
[09:29:14.946]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.946]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.946]                   ...future.globals.maxSize)) {
[09:29:14.946]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.946]                   on.exit(options(oopts), add = TRUE)
[09:29:14.946]                 }
[09:29:14.946]                 {
[09:29:14.946]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:14.946]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[09:29:14.946]                       envir = globalenv(), inherits = FALSE)
[09:29:14.946]                     ...future.FUN(...)
[09:29:14.946]                   }
[09:29:14.946]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:14.946]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:14.946]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.946]                     USE.NAMES = FALSE)
[09:29:14.946]                   do.call(mapply, args = args)
[09:29:14.946]                 }
[09:29:14.946]             }))
[09:29:14.946]             future::FutureResult(value = ...future.value$value, 
[09:29:14.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.946]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.946]                     ...future.globalenv.names))
[09:29:14.946]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.946]         }, condition = base::local({
[09:29:14.946]             c <- base::c
[09:29:14.946]             inherits <- base::inherits
[09:29:14.946]             invokeRestart <- base::invokeRestart
[09:29:14.946]             length <- base::length
[09:29:14.946]             list <- base::list
[09:29:14.946]             seq.int <- base::seq.int
[09:29:14.946]             signalCondition <- base::signalCondition
[09:29:14.946]             sys.calls <- base::sys.calls
[09:29:14.946]             `[[` <- base::`[[`
[09:29:14.946]             `+` <- base::`+`
[09:29:14.946]             `<<-` <- base::`<<-`
[09:29:14.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.946]                   3L)]
[09:29:14.946]             }
[09:29:14.946]             function(cond) {
[09:29:14.946]                 is_error <- inherits(cond, "error")
[09:29:14.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.946]                   NULL)
[09:29:14.946]                 if (is_error) {
[09:29:14.946]                   sessionInformation <- function() {
[09:29:14.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.946]                       search = base::search(), system = base::Sys.info())
[09:29:14.946]                   }
[09:29:14.946]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.946]                     cond$call), session = sessionInformation(), 
[09:29:14.946]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.946]                   signalCondition(cond)
[09:29:14.946]                 }
[09:29:14.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.946]                 "immediateCondition"))) {
[09:29:14.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.946]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.946]                   if (TRUE && !signal) {
[09:29:14.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.946]                     {
[09:29:14.946]                       inherits <- base::inherits
[09:29:14.946]                       invokeRestart <- base::invokeRestart
[09:29:14.946]                       is.null <- base::is.null
[09:29:14.946]                       muffled <- FALSE
[09:29:14.946]                       if (inherits(cond, "message")) {
[09:29:14.946]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.946]                         if (muffled) 
[09:29:14.946]                           invokeRestart("muffleMessage")
[09:29:14.946]                       }
[09:29:14.946]                       else if (inherits(cond, "warning")) {
[09:29:14.946]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.946]                         if (muffled) 
[09:29:14.946]                           invokeRestart("muffleWarning")
[09:29:14.946]                       }
[09:29:14.946]                       else if (inherits(cond, "condition")) {
[09:29:14.946]                         if (!is.null(pattern)) {
[09:29:14.946]                           computeRestarts <- base::computeRestarts
[09:29:14.946]                           grepl <- base::grepl
[09:29:14.946]                           restarts <- computeRestarts(cond)
[09:29:14.946]                           for (restart in restarts) {
[09:29:14.946]                             name <- restart$name
[09:29:14.946]                             if (is.null(name)) 
[09:29:14.946]                               next
[09:29:14.946]                             if (!grepl(pattern, name)) 
[09:29:14.946]                               next
[09:29:14.946]                             invokeRestart(restart)
[09:29:14.946]                             muffled <- TRUE
[09:29:14.946]                             break
[09:29:14.946]                           }
[09:29:14.946]                         }
[09:29:14.946]                       }
[09:29:14.946]                       invisible(muffled)
[09:29:14.946]                     }
[09:29:14.946]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.946]                   }
[09:29:14.946]                 }
[09:29:14.946]                 else {
[09:29:14.946]                   if (TRUE) {
[09:29:14.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.946]                     {
[09:29:14.946]                       inherits <- base::inherits
[09:29:14.946]                       invokeRestart <- base::invokeRestart
[09:29:14.946]                       is.null <- base::is.null
[09:29:14.946]                       muffled <- FALSE
[09:29:14.946]                       if (inherits(cond, "message")) {
[09:29:14.946]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.946]                         if (muffled) 
[09:29:14.946]                           invokeRestart("muffleMessage")
[09:29:14.946]                       }
[09:29:14.946]                       else if (inherits(cond, "warning")) {
[09:29:14.946]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.946]                         if (muffled) 
[09:29:14.946]                           invokeRestart("muffleWarning")
[09:29:14.946]                       }
[09:29:14.946]                       else if (inherits(cond, "condition")) {
[09:29:14.946]                         if (!is.null(pattern)) {
[09:29:14.946]                           computeRestarts <- base::computeRestarts
[09:29:14.946]                           grepl <- base::grepl
[09:29:14.946]                           restarts <- computeRestarts(cond)
[09:29:14.946]                           for (restart in restarts) {
[09:29:14.946]                             name <- restart$name
[09:29:14.946]                             if (is.null(name)) 
[09:29:14.946]                               next
[09:29:14.946]                             if (!grepl(pattern, name)) 
[09:29:14.946]                               next
[09:29:14.946]                             invokeRestart(restart)
[09:29:14.946]                             muffled <- TRUE
[09:29:14.946]                             break
[09:29:14.946]                           }
[09:29:14.946]                         }
[09:29:14.946]                       }
[09:29:14.946]                       invisible(muffled)
[09:29:14.946]                     }
[09:29:14.946]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.946]                   }
[09:29:14.946]                 }
[09:29:14.946]             }
[09:29:14.946]         }))
[09:29:14.946]     }, error = function(ex) {
[09:29:14.946]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.946]                 ...future.rng), started = ...future.startTime, 
[09:29:14.946]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.946]             version = "1.8"), class = "FutureResult")
[09:29:14.946]     }, finally = {
[09:29:14.946]         if (!identical(...future.workdir, getwd())) 
[09:29:14.946]             setwd(...future.workdir)
[09:29:14.946]         {
[09:29:14.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.946]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.946]             }
[09:29:14.946]             base::options(...future.oldOptions)
[09:29:14.946]             if (.Platform$OS.type == "windows") {
[09:29:14.946]                 old_names <- names(...future.oldEnvVars)
[09:29:14.946]                 envs <- base::Sys.getenv()
[09:29:14.946]                 names <- names(envs)
[09:29:14.946]                 common <- intersect(names, old_names)
[09:29:14.946]                 added <- setdiff(names, old_names)
[09:29:14.946]                 removed <- setdiff(old_names, names)
[09:29:14.946]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.946]                   envs[common]]
[09:29:14.946]                 NAMES <- toupper(changed)
[09:29:14.946]                 args <- list()
[09:29:14.946]                 for (kk in seq_along(NAMES)) {
[09:29:14.946]                   name <- changed[[kk]]
[09:29:14.946]                   NAME <- NAMES[[kk]]
[09:29:14.946]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.946]                     next
[09:29:14.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.946]                 }
[09:29:14.946]                 NAMES <- toupper(added)
[09:29:14.946]                 for (kk in seq_along(NAMES)) {
[09:29:14.946]                   name <- added[[kk]]
[09:29:14.946]                   NAME <- NAMES[[kk]]
[09:29:14.946]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.946]                     next
[09:29:14.946]                   args[[name]] <- ""
[09:29:14.946]                 }
[09:29:14.946]                 NAMES <- toupper(removed)
[09:29:14.946]                 for (kk in seq_along(NAMES)) {
[09:29:14.946]                   name <- removed[[kk]]
[09:29:14.946]                   NAME <- NAMES[[kk]]
[09:29:14.946]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.946]                     next
[09:29:14.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.946]                 }
[09:29:14.946]                 if (length(args) > 0) 
[09:29:14.946]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.946]             }
[09:29:14.946]             else {
[09:29:14.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.946]             }
[09:29:14.946]             {
[09:29:14.946]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.946]                   0L) {
[09:29:14.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.946]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.946]                   base::options(opts)
[09:29:14.946]                 }
[09:29:14.946]                 {
[09:29:14.946]                   {
[09:29:14.946]                     base::assign(".Random.seed", c(10407L, 1375929630L, 
[09:29:14.946]                     -764567282L, 2079058973L, 2055751927L, -1272738459L, 
[09:29:14.946]                     -513300596L), envir = base::globalenv(), 
[09:29:14.946]                       inherits = FALSE)
[09:29:14.946]                     NULL
[09:29:14.946]                   }
[09:29:14.946]                   options(future.plan = NULL)
[09:29:14.946]                   if (is.na(NA_character_)) 
[09:29:14.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.946]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.946]                     .init = FALSE)
[09:29:14.946]                 }
[09:29:14.946]             }
[09:29:14.946]         }
[09:29:14.946]     })
[09:29:14.946]     if (TRUE) {
[09:29:14.946]         base::sink(type = "output", split = FALSE)
[09:29:14.946]         if (TRUE) {
[09:29:14.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.946]         }
[09:29:14.946]         else {
[09:29:14.946]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.946]         }
[09:29:14.946]         base::close(...future.stdout)
[09:29:14.946]         ...future.stdout <- NULL
[09:29:14.946]     }
[09:29:14.946]     ...future.result$conditions <- ...future.conditions
[09:29:14.946]     ...future.result$finished <- base::Sys.time()
[09:29:14.946]     ...future.result
[09:29:14.946] }
[09:29:14.948] assign_globals() ...
[09:29:14.948] List of 5
[09:29:14.948]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[09:29:14.948]  $ MoreArgs                 :List of 1
[09:29:14.948]   ..$ min: num 1
[09:29:14.948]  $ ...future.elements_ii    :List of 2
[09:29:14.948]   ..$ n  :List of 4
[09:29:14.948]   .. ..$ : int 1
[09:29:14.948]   .. ..$ : int 2
[09:29:14.948]   .. ..$ : int 3
[09:29:14.948]   .. ..$ : int 4
[09:29:14.948]   ..$ max:List of 4
[09:29:14.948]   .. ..$ : int 2
[09:29:14.948]   .. ..$ : int 3
[09:29:14.948]   .. ..$ : int 4
[09:29:14.948]   .. ..$ : int 5
[09:29:14.948]  $ ...future.seeds_ii       :List of 4
[09:29:14.948]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[09:29:14.948]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[09:29:14.948]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[09:29:14.948]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[09:29:14.948]  $ ...future.globals.maxSize: NULL
[09:29:14.948]  - attr(*, "where")=List of 5
[09:29:14.948]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.948]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.948]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.948]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.948]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.948]  - attr(*, "resolved")= logi FALSE
[09:29:14.948]  - attr(*, "total_size")= num 2912
[09:29:14.948]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.948]  - attr(*, "already-done")= logi TRUE
[09:29:14.957] - copied ‘...future.FUN’ to environment
[09:29:14.957] - copied ‘MoreArgs’ to environment
[09:29:14.957] - copied ‘...future.elements_ii’ to environment
[09:29:14.957] - copied ‘...future.seeds_ii’ to environment
[09:29:14.957] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.957] assign_globals() ... done
[09:29:14.958] plan(): Setting new future strategy stack:
[09:29:14.958] List of future strategies:
[09:29:14.958] 1. sequential:
[09:29:14.958]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.958]    - tweaked: FALSE
[09:29:14.958]    - call: NULL
[09:29:14.958] plan(): nbrOfWorkers() = 1
[09:29:14.959] plan(): Setting new future strategy stack:
[09:29:14.959] List of future strategies:
[09:29:14.959] 1. sequential:
[09:29:14.959]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.959]    - tweaked: FALSE
[09:29:14.959]    - call: plan(strategy)
[09:29:14.959] plan(): nbrOfWorkers() = 1
[09:29:14.960] SequentialFuture started (and completed)
[09:29:14.960] - Launch lazy future ... done
[09:29:14.960] run() for ‘SequentialFuture’ ... done
[09:29:14.960] Created future:
[09:29:14.960] SequentialFuture:
[09:29:14.960] Label: ‘future_mapply-1’
[09:29:14.960] Expression:
[09:29:14.960] {
[09:29:14.960]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.960]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.960]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.960]         on.exit(options(oopts), add = TRUE)
[09:29:14.960]     }
[09:29:14.960]     {
[09:29:14.960]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:14.960]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[09:29:14.960]                 inherits = FALSE)
[09:29:14.960]             ...future.FUN(...)
[09:29:14.960]         }
[09:29:14.960]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:14.960]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:14.960]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.960]         do.call(mapply, args = args)
[09:29:14.960]     }
[09:29:14.960] }
[09:29:14.960] Lazy evaluation: FALSE
[09:29:14.960] Asynchronous evaluation: FALSE
[09:29:14.960] Local evaluation: TRUE
[09:29:14.960] Environment: R_GlobalEnv
[09:29:14.960] Capture standard output: TRUE
[09:29:14.960] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.960] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.960] Packages: 1 packages (‘stats’)
[09:29:14.960] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:29:14.960] Resolved: TRUE
[09:29:14.960] Value: 280 bytes of class ‘list’
[09:29:14.960] Early signaling: FALSE
[09:29:14.960] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.960] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.961] Chunk #1 of 1 ... DONE
[09:29:14.961] Launching 1 futures (chunks) ... DONE
[09:29:14.961] Resolving 1 futures (chunks) ...
[09:29:14.961] resolve() on list ...
[09:29:14.961]  recursive: 0
[09:29:14.961]  length: 1
[09:29:14.961] 
[09:29:14.962] resolved() for ‘SequentialFuture’ ...
[09:29:14.962] - state: ‘finished’
[09:29:14.962] - run: TRUE
[09:29:14.962] - result: ‘FutureResult’
[09:29:14.962] resolved() for ‘SequentialFuture’ ... done
[09:29:14.962] Future #1
[09:29:14.962] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.962] - nx: 1
[09:29:14.962] - relay: TRUE
[09:29:14.962] - stdout: TRUE
[09:29:14.962] - signal: TRUE
[09:29:14.962] - resignal: FALSE
[09:29:14.963] - force: TRUE
[09:29:14.963] - relayed: [n=1] FALSE
[09:29:14.963] - queued futures: [n=1] FALSE
[09:29:14.963]  - until=1
[09:29:14.963]  - relaying element #1
[09:29:14.963] - relayed: [n=1] TRUE
[09:29:14.963] - queued futures: [n=1] TRUE
[09:29:14.963] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.963]  length: 0 (resolved future 1)
[09:29:14.963] Relaying remaining futures
[09:29:14.963] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.964] - nx: 1
[09:29:14.964] - relay: TRUE
[09:29:14.964] - stdout: TRUE
[09:29:14.964] - signal: TRUE
[09:29:14.964] - resignal: FALSE
[09:29:14.964] - force: TRUE
[09:29:14.964] - relayed: [n=1] TRUE
[09:29:14.964] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.964] - relayed: [n=1] TRUE
[09:29:14.964] - queued futures: [n=1] TRUE
[09:29:14.964] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.964] resolve() on list ... DONE
[09:29:14.965]  - Number of value chunks collected: 1
[09:29:14.965] Resolving 1 futures (chunks) ... DONE
[09:29:14.965] Reducing values from 1 chunks ...
[09:29:14.965]  - Number of values collected after concatenation: 4
[09:29:14.965]  - Number of values expected: 4
[09:29:14.965] Reducing values from 1 chunks ... DONE
[09:29:14.965] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[09:29:14.967] future_mapply() ...
[09:29:14.967] Number of chunks: 1
[09:29:14.967] getGlobalsAndPackagesXApply() ...
[09:29:14.967]  - future.globals: TRUE
[09:29:14.968] getGlobalsAndPackages() ...
[09:29:14.968] Searching for globals...
[09:29:14.969] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:29:14.969] Searching for globals ... DONE
[09:29:14.969] Resolving globals: FALSE
[09:29:14.969] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[09:29:14.969] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[09:29:14.970] - globals: [1] ‘FUN’
[09:29:14.970] - packages: [1] ‘stats’
[09:29:14.970] getGlobalsAndPackages() ... DONE
[09:29:14.970]  - globals found/used: [n=1] ‘FUN’
[09:29:14.970]  - needed namespaces: [n=1] ‘stats’
[09:29:14.970] Finding globals ... DONE
[09:29:14.970] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:14.970] List of 2
[09:29:14.970]  $ ...future.FUN:function (x, w, ...)  
[09:29:14.970]  $ MoreArgs     : NULL
[09:29:14.970]  - attr(*, "where")=List of 2
[09:29:14.970]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:14.970]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:14.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.970]  - attr(*, "resolved")= logi FALSE
[09:29:14.970]  - attr(*, "total_size")= num NA
[09:29:14.974] Packages to be attached in all futures: [n=1] ‘stats’
[09:29:14.974] getGlobalsAndPackagesXApply() ... DONE
[09:29:14.974] Number of futures (= number of chunks): 1
[09:29:14.974] Launching 1 futures (chunks) ...
[09:29:14.974] Chunk #1 of 1 ...
[09:29:14.974]  - Finding globals in '...' for chunk #1 ...
[09:29:14.974] getGlobalsAndPackages() ...
[09:29:14.974] Searching for globals...
[09:29:14.975] 
[09:29:14.975] Searching for globals ... DONE
[09:29:14.975] - globals: [0] <none>
[09:29:14.975] getGlobalsAndPackages() ... DONE
[09:29:14.975]    + additional globals found: [n=0] 
[09:29:14.975]    + additional namespaces needed: [n=0] 
[09:29:14.975]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:14.975]  - seeds: <none>
[09:29:14.975]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.975] getGlobalsAndPackages() ...
[09:29:14.976] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.976] Resolving globals: FALSE
[09:29:14.976] The total size of the 5 globals is 3.10 KiB (3176 bytes)
[09:29:14.977] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (1.72 KiB of class ‘list’), ‘...future.FUN’ (1.38 KiB of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:14.977] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:14.977] - packages: [1] ‘stats’
[09:29:14.977] getGlobalsAndPackages() ... DONE
[09:29:14.977] run() for ‘Future’ ...
[09:29:14.977] - state: ‘created’
[09:29:14.977] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:14.978] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.978] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:14.978]   - Field: ‘label’
[09:29:14.978]   - Field: ‘local’
[09:29:14.978]   - Field: ‘owner’
[09:29:14.978]   - Field: ‘envir’
[09:29:14.978]   - Field: ‘packages’
[09:29:14.978]   - Field: ‘gc’
[09:29:14.978]   - Field: ‘conditions’
[09:29:14.978]   - Field: ‘expr’
[09:29:14.979]   - Field: ‘uuid’
[09:29:14.979]   - Field: ‘seed’
[09:29:14.979]   - Field: ‘version’
[09:29:14.979]   - Field: ‘result’
[09:29:14.979]   - Field: ‘asynchronous’
[09:29:14.979]   - Field: ‘calls’
[09:29:14.979]   - Field: ‘globals’
[09:29:14.979]   - Field: ‘stdout’
[09:29:14.979]   - Field: ‘earlySignal’
[09:29:14.979]   - Field: ‘lazy’
[09:29:14.979]   - Field: ‘state’
[09:29:14.979] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:14.980] - Launch lazy future ...
[09:29:14.980] Packages needed by the future expression (n = 1): ‘stats’
[09:29:14.980] Packages needed by future strategies (n = 0): <none>
[09:29:14.980] {
[09:29:14.980]     {
[09:29:14.980]         {
[09:29:14.980]             ...future.startTime <- base::Sys.time()
[09:29:14.980]             {
[09:29:14.980]                 {
[09:29:14.980]                   {
[09:29:14.980]                     {
[09:29:14.980]                       base::local({
[09:29:14.980]                         has_future <- base::requireNamespace("future", 
[09:29:14.980]                           quietly = TRUE)
[09:29:14.980]                         if (has_future) {
[09:29:14.980]                           ns <- base::getNamespace("future")
[09:29:14.980]                           version <- ns[[".package"]][["version"]]
[09:29:14.980]                           if (is.null(version)) 
[09:29:14.980]                             version <- utils::packageVersion("future")
[09:29:14.980]                         }
[09:29:14.980]                         else {
[09:29:14.980]                           version <- NULL
[09:29:14.980]                         }
[09:29:14.980]                         if (!has_future || version < "1.8.0") {
[09:29:14.980]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:14.980]                             "", base::R.version$version.string), 
[09:29:14.980]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:14.980]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:14.980]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:14.980]                               "release", "version")], collapse = " "), 
[09:29:14.980]                             hostname = base::Sys.info()[["nodename"]])
[09:29:14.980]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:14.980]                             info)
[09:29:14.980]                           info <- base::paste(info, collapse = "; ")
[09:29:14.980]                           if (!has_future) {
[09:29:14.980]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:14.980]                               info)
[09:29:14.980]                           }
[09:29:14.980]                           else {
[09:29:14.980]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:14.980]                               info, version)
[09:29:14.980]                           }
[09:29:14.980]                           base::stop(msg)
[09:29:14.980]                         }
[09:29:14.980]                       })
[09:29:14.980]                     }
[09:29:14.980]                     base::local({
[09:29:14.980]                       for (pkg in "stats") {
[09:29:14.980]                         base::loadNamespace(pkg)
[09:29:14.980]                         base::library(pkg, character.only = TRUE)
[09:29:14.980]                       }
[09:29:14.980]                     })
[09:29:14.980]                   }
[09:29:14.980]                   ...future.strategy.old <- future::plan("list")
[09:29:14.980]                   options(future.plan = NULL)
[09:29:14.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:14.980]                 }
[09:29:14.980]                 ...future.workdir <- getwd()
[09:29:14.980]             }
[09:29:14.980]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:14.980]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:14.980]         }
[09:29:14.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:14.980]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:14.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:14.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:14.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:14.980]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:14.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:14.980]             base::names(...future.oldOptions))
[09:29:14.980]     }
[09:29:14.980]     if (FALSE) {
[09:29:14.980]     }
[09:29:14.980]     else {
[09:29:14.980]         if (TRUE) {
[09:29:14.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:14.980]                 open = "w")
[09:29:14.980]         }
[09:29:14.980]         else {
[09:29:14.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:14.980]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:14.980]         }
[09:29:14.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:14.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:14.980]             base::sink(type = "output", split = FALSE)
[09:29:14.980]             base::close(...future.stdout)
[09:29:14.980]         }, add = TRUE)
[09:29:14.980]     }
[09:29:14.980]     ...future.frame <- base::sys.nframe()
[09:29:14.980]     ...future.conditions <- base::list()
[09:29:14.980]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:14.980]     if (FALSE) {
[09:29:14.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:14.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:14.980]     }
[09:29:14.980]     ...future.result <- base::tryCatch({
[09:29:14.980]         base::withCallingHandlers({
[09:29:14.980]             ...future.value <- base::withVisible(base::local({
[09:29:14.980]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.980]                 if (!identical(...future.globals.maxSize.org, 
[09:29:14.980]                   ...future.globals.maxSize)) {
[09:29:14.980]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.980]                   on.exit(options(oopts), add = TRUE)
[09:29:14.980]                 }
[09:29:14.980]                 {
[09:29:14.980]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.980]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:14.980]                     USE.NAMES = FALSE)
[09:29:14.980]                   do.call(mapply, args = args)
[09:29:14.980]                 }
[09:29:14.980]             }))
[09:29:14.980]             future::FutureResult(value = ...future.value$value, 
[09:29:14.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.980]                   ...future.rng), globalenv = if (FALSE) 
[09:29:14.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:14.980]                     ...future.globalenv.names))
[09:29:14.980]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:14.980]         }, condition = base::local({
[09:29:14.980]             c <- base::c
[09:29:14.980]             inherits <- base::inherits
[09:29:14.980]             invokeRestart <- base::invokeRestart
[09:29:14.980]             length <- base::length
[09:29:14.980]             list <- base::list
[09:29:14.980]             seq.int <- base::seq.int
[09:29:14.980]             signalCondition <- base::signalCondition
[09:29:14.980]             sys.calls <- base::sys.calls
[09:29:14.980]             `[[` <- base::`[[`
[09:29:14.980]             `+` <- base::`+`
[09:29:14.980]             `<<-` <- base::`<<-`
[09:29:14.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:14.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:14.980]                   3L)]
[09:29:14.980]             }
[09:29:14.980]             function(cond) {
[09:29:14.980]                 is_error <- inherits(cond, "error")
[09:29:14.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:14.980]                   NULL)
[09:29:14.980]                 if (is_error) {
[09:29:14.980]                   sessionInformation <- function() {
[09:29:14.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:14.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:14.980]                       search = base::search(), system = base::Sys.info())
[09:29:14.980]                   }
[09:29:14.980]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:14.980]                     cond$call), session = sessionInformation(), 
[09:29:14.980]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:14.980]                   signalCondition(cond)
[09:29:14.980]                 }
[09:29:14.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:14.980]                 "immediateCondition"))) {
[09:29:14.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:14.980]                   ...future.conditions[[length(...future.conditions) + 
[09:29:14.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:14.980]                   if (TRUE && !signal) {
[09:29:14.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.980]                     {
[09:29:14.980]                       inherits <- base::inherits
[09:29:14.980]                       invokeRestart <- base::invokeRestart
[09:29:14.980]                       is.null <- base::is.null
[09:29:14.980]                       muffled <- FALSE
[09:29:14.980]                       if (inherits(cond, "message")) {
[09:29:14.980]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.980]                         if (muffled) 
[09:29:14.980]                           invokeRestart("muffleMessage")
[09:29:14.980]                       }
[09:29:14.980]                       else if (inherits(cond, "warning")) {
[09:29:14.980]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.980]                         if (muffled) 
[09:29:14.980]                           invokeRestart("muffleWarning")
[09:29:14.980]                       }
[09:29:14.980]                       else if (inherits(cond, "condition")) {
[09:29:14.980]                         if (!is.null(pattern)) {
[09:29:14.980]                           computeRestarts <- base::computeRestarts
[09:29:14.980]                           grepl <- base::grepl
[09:29:14.980]                           restarts <- computeRestarts(cond)
[09:29:14.980]                           for (restart in restarts) {
[09:29:14.980]                             name <- restart$name
[09:29:14.980]                             if (is.null(name)) 
[09:29:14.980]                               next
[09:29:14.980]                             if (!grepl(pattern, name)) 
[09:29:14.980]                               next
[09:29:14.980]                             invokeRestart(restart)
[09:29:14.980]                             muffled <- TRUE
[09:29:14.980]                             break
[09:29:14.980]                           }
[09:29:14.980]                         }
[09:29:14.980]                       }
[09:29:14.980]                       invisible(muffled)
[09:29:14.980]                     }
[09:29:14.980]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.980]                   }
[09:29:14.980]                 }
[09:29:14.980]                 else {
[09:29:14.980]                   if (TRUE) {
[09:29:14.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:14.980]                     {
[09:29:14.980]                       inherits <- base::inherits
[09:29:14.980]                       invokeRestart <- base::invokeRestart
[09:29:14.980]                       is.null <- base::is.null
[09:29:14.980]                       muffled <- FALSE
[09:29:14.980]                       if (inherits(cond, "message")) {
[09:29:14.980]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:14.980]                         if (muffled) 
[09:29:14.980]                           invokeRestart("muffleMessage")
[09:29:14.980]                       }
[09:29:14.980]                       else if (inherits(cond, "warning")) {
[09:29:14.980]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:14.980]                         if (muffled) 
[09:29:14.980]                           invokeRestart("muffleWarning")
[09:29:14.980]                       }
[09:29:14.980]                       else if (inherits(cond, "condition")) {
[09:29:14.980]                         if (!is.null(pattern)) {
[09:29:14.980]                           computeRestarts <- base::computeRestarts
[09:29:14.980]                           grepl <- base::grepl
[09:29:14.980]                           restarts <- computeRestarts(cond)
[09:29:14.980]                           for (restart in restarts) {
[09:29:14.980]                             name <- restart$name
[09:29:14.980]                             if (is.null(name)) 
[09:29:14.980]                               next
[09:29:14.980]                             if (!grepl(pattern, name)) 
[09:29:14.980]                               next
[09:29:14.980]                             invokeRestart(restart)
[09:29:14.980]                             muffled <- TRUE
[09:29:14.980]                             break
[09:29:14.980]                           }
[09:29:14.980]                         }
[09:29:14.980]                       }
[09:29:14.980]                       invisible(muffled)
[09:29:14.980]                     }
[09:29:14.980]                     muffleCondition(cond, pattern = "^muffle")
[09:29:14.980]                   }
[09:29:14.980]                 }
[09:29:14.980]             }
[09:29:14.980]         }))
[09:29:14.980]     }, error = function(ex) {
[09:29:14.980]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:14.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:14.980]                 ...future.rng), started = ...future.startTime, 
[09:29:14.980]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:14.980]             version = "1.8"), class = "FutureResult")
[09:29:14.980]     }, finally = {
[09:29:14.980]         if (!identical(...future.workdir, getwd())) 
[09:29:14.980]             setwd(...future.workdir)
[09:29:14.980]         {
[09:29:14.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:14.980]                 ...future.oldOptions$nwarnings <- NULL
[09:29:14.980]             }
[09:29:14.980]             base::options(...future.oldOptions)
[09:29:14.980]             if (.Platform$OS.type == "windows") {
[09:29:14.980]                 old_names <- names(...future.oldEnvVars)
[09:29:14.980]                 envs <- base::Sys.getenv()
[09:29:14.980]                 names <- names(envs)
[09:29:14.980]                 common <- intersect(names, old_names)
[09:29:14.980]                 added <- setdiff(names, old_names)
[09:29:14.980]                 removed <- setdiff(old_names, names)
[09:29:14.980]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:14.980]                   envs[common]]
[09:29:14.980]                 NAMES <- toupper(changed)
[09:29:14.980]                 args <- list()
[09:29:14.980]                 for (kk in seq_along(NAMES)) {
[09:29:14.980]                   name <- changed[[kk]]
[09:29:14.980]                   NAME <- NAMES[[kk]]
[09:29:14.980]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.980]                     next
[09:29:14.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.980]                 }
[09:29:14.980]                 NAMES <- toupper(added)
[09:29:14.980]                 for (kk in seq_along(NAMES)) {
[09:29:14.980]                   name <- added[[kk]]
[09:29:14.980]                   NAME <- NAMES[[kk]]
[09:29:14.980]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.980]                     next
[09:29:14.980]                   args[[name]] <- ""
[09:29:14.980]                 }
[09:29:14.980]                 NAMES <- toupper(removed)
[09:29:14.980]                 for (kk in seq_along(NAMES)) {
[09:29:14.980]                   name <- removed[[kk]]
[09:29:14.980]                   NAME <- NAMES[[kk]]
[09:29:14.980]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:14.980]                     next
[09:29:14.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:14.980]                 }
[09:29:14.980]                 if (length(args) > 0) 
[09:29:14.980]                   base::do.call(base::Sys.setenv, args = args)
[09:29:14.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:14.980]             }
[09:29:14.980]             else {
[09:29:14.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:14.980]             }
[09:29:14.980]             {
[09:29:14.980]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:14.980]                   0L) {
[09:29:14.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:14.980]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:14.980]                   base::options(opts)
[09:29:14.980]                 }
[09:29:14.980]                 {
[09:29:14.980]                   {
[09:29:14.980]                     base::assign(".Random.seed", c(10407L, -1055677337L, 
[09:29:14.980]                     1033720650L, -512088055L, -897961199L, -1409881771L, 
[09:29:14.980]                     -1097230566L), envir = base::globalenv(), 
[09:29:14.980]                       inherits = FALSE)
[09:29:14.980]                     NULL
[09:29:14.980]                   }
[09:29:14.980]                   options(future.plan = NULL)
[09:29:14.980]                   if (is.na(NA_character_)) 
[09:29:14.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:14.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:14.980]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:14.980]                     .init = FALSE)
[09:29:14.980]                 }
[09:29:14.980]             }
[09:29:14.980]         }
[09:29:14.980]     })
[09:29:14.980]     if (TRUE) {
[09:29:14.980]         base::sink(type = "output", split = FALSE)
[09:29:14.980]         if (TRUE) {
[09:29:14.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:14.980]         }
[09:29:14.980]         else {
[09:29:14.980]             ...future.result["stdout"] <- base::list(NULL)
[09:29:14.980]         }
[09:29:14.980]         base::close(...future.stdout)
[09:29:14.980]         ...future.stdout <- NULL
[09:29:14.980]     }
[09:29:14.980]     ...future.result$conditions <- ...future.conditions
[09:29:14.980]     ...future.result$finished <- base::Sys.time()
[09:29:14.980]     ...future.result
[09:29:14.980] }
[09:29:14.982] assign_globals() ...
[09:29:14.982] List of 5
[09:29:14.982]  $ ...future.FUN            :function (x, w, ...)  
[09:29:14.982]  $ MoreArgs                 : NULL
[09:29:14.982]  $ ...future.elements_ii    :List of 2
[09:29:14.982]   ..$ :List of 5
[09:29:14.982]   .. ..$ : num [1:10] 0.0717 0.5776 0.3968 0.595 0.1537 ...
[09:29:14.982]   .. ..$ : num [1:10] 0.806 0.169 0.909 0.245 0.908 ...
[09:29:14.982]   .. ..$ : num [1:10] 0.5235 0.5837 0.4514 0.3661 0.0201 ...
[09:29:14.982]   .. ..$ : num [1:10] 0.192 0.712 0.938 0.138 0.418 ...
[09:29:14.982]   .. ..$ : num [1:10] 0.299 0.584 0.9984 0.1035 0.0682 ...
[09:29:14.982]   ..$ :List of 5
[09:29:14.982]   .. ..$ : num [1:10] 8 7 4 8 5 10 3 6 7 3
[09:29:14.982]   .. ..$ : num [1:10] 7 2 4 7 8 4 10 6 8 4
[09:29:14.982]   .. ..$ : num [1:10] 7 5 4 6 7 5 7 4 4 6
[09:29:14.982]   .. ..$ : num [1:10] 7 4 10 12 7 9 3 7 10 8
[09:29:14.982]   .. ..$ : num [1:10] 7 9 6 6 4 4 5 10 6 4
[09:29:14.982]  $ ...future.seeds_ii       : NULL
[09:29:14.982]  $ ...future.globals.maxSize: NULL
[09:29:14.982]  - attr(*, "where")=List of 5
[09:29:14.982]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:14.982]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:14.982]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:14.982]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:14.982]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:14.982]  - attr(*, "resolved")= logi FALSE
[09:29:14.982]  - attr(*, "total_size")= num 3176
[09:29:14.982]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:14.982]  - attr(*, "already-done")= logi TRUE
[09:29:14.989] - copied ‘...future.FUN’ to environment
[09:29:14.989] - copied ‘MoreArgs’ to environment
[09:29:14.989] - copied ‘...future.elements_ii’ to environment
[09:29:14.990] - copied ‘...future.seeds_ii’ to environment
[09:29:14.990] - copied ‘...future.globals.maxSize’ to environment
[09:29:14.990] assign_globals() ... done
[09:29:14.990] plan(): Setting new future strategy stack:
[09:29:14.990] List of future strategies:
[09:29:14.990] 1. sequential:
[09:29:14.990]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.990]    - tweaked: FALSE
[09:29:14.990]    - call: NULL
[09:29:14.991] plan(): nbrOfWorkers() = 1
[09:29:14.991] plan(): Setting new future strategy stack:
[09:29:14.991] List of future strategies:
[09:29:14.991] 1. sequential:
[09:29:14.991]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:14.991]    - tweaked: FALSE
[09:29:14.991]    - call: plan(strategy)
[09:29:14.992] plan(): nbrOfWorkers() = 1
[09:29:14.992] SequentialFuture started (and completed)
[09:29:14.992] - Launch lazy future ... done
[09:29:14.992] run() for ‘SequentialFuture’ ... done
[09:29:14.992] Created future:
[09:29:14.992] SequentialFuture:
[09:29:14.992] Label: ‘future_Map-1’
[09:29:14.992] Expression:
[09:29:14.992] {
[09:29:14.992]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:14.992]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:14.992]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:14.992]         on.exit(options(oopts), add = TRUE)
[09:29:14.992]     }
[09:29:14.992]     {
[09:29:14.992]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:14.992]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:14.992]         do.call(mapply, args = args)
[09:29:14.992]     }
[09:29:14.992] }
[09:29:14.992] Lazy evaluation: FALSE
[09:29:14.992] Asynchronous evaluation: FALSE
[09:29:14.992] Local evaluation: TRUE
[09:29:14.992] Environment: R_GlobalEnv
[09:29:14.992] Capture standard output: TRUE
[09:29:14.992] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:14.992] Globals: 5 objects totaling 3.10 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:14.992] Packages: 1 packages (‘stats’)
[09:29:14.992] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:14.992] Resolved: TRUE
[09:29:14.992] Value: 280 bytes of class ‘list’
[09:29:14.992] Early signaling: FALSE
[09:29:14.992] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:14.992] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:14.994] Chunk #1 of 1 ... DONE
[09:29:14.994] Launching 1 futures (chunks) ... DONE
[09:29:14.995] Resolving 1 futures (chunks) ...
[09:29:14.995] resolve() on list ...
[09:29:14.995]  recursive: 0
[09:29:14.995]  length: 1
[09:29:14.995] 
[09:29:14.995] resolved() for ‘SequentialFuture’ ...
[09:29:14.995] - state: ‘finished’
[09:29:14.995] - run: TRUE
[09:29:14.995] - result: ‘FutureResult’
[09:29:14.995] resolved() for ‘SequentialFuture’ ... done
[09:29:14.995] Future #1
[09:29:14.996] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:14.996] - nx: 1
[09:29:14.996] - relay: TRUE
[09:29:14.996] - stdout: TRUE
[09:29:14.996] - signal: TRUE
[09:29:14.996] - resignal: FALSE
[09:29:14.996] - force: TRUE
[09:29:14.996] - relayed: [n=1] FALSE
[09:29:14.996] - queued futures: [n=1] FALSE
[09:29:14.996]  - until=1
[09:29:14.996]  - relaying element #1
[09:29:14.997] - relayed: [n=1] TRUE
[09:29:14.997] - queued futures: [n=1] TRUE
[09:29:14.997] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:14.997]  length: 0 (resolved future 1)
[09:29:14.997] Relaying remaining futures
[09:29:14.997] signalConditionsASAP(NULL, pos=0) ...
[09:29:14.997] - nx: 1
[09:29:14.997] - relay: TRUE
[09:29:14.997] - stdout: TRUE
[09:29:14.997] - signal: TRUE
[09:29:14.997] - resignal: FALSE
[09:29:14.997] - force: TRUE
[09:29:14.998] - relayed: [n=1] TRUE
[09:29:14.998] - queued futures: [n=1] TRUE
 - flush all
[09:29:14.998] - relayed: [n=1] TRUE
[09:29:14.998] - queued futures: [n=1] TRUE
[09:29:14.998] signalConditionsASAP(NULL, pos=0) ... done
[09:29:14.998] resolve() on list ... DONE
[09:29:14.998]  - Number of value chunks collected: 1
[09:29:14.998] Resolving 1 futures (chunks) ... DONE
[09:29:14.998] Reducing values from 1 chunks ...
[09:29:14.998]  - Number of values collected after concatenation: 5
[09:29:14.999]  - Number of values expected: 5
[09:29:14.999] Reducing values from 1 chunks ... DONE
[09:29:14.999] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[09:29:15.000] future_mapply() ...
[09:29:15.000] Number of chunks: 1
[09:29:15.001] getGlobalsAndPackagesXApply() ...
[09:29:15.001]  - future.globals: TRUE
[09:29:15.001] getGlobalsAndPackages() ...
[09:29:15.001] Searching for globals...
[09:29:15.001] - globals found: [1] ‘FUN’
[09:29:15.001] Searching for globals ... DONE
[09:29:15.002] Resolving globals: FALSE
[09:29:15.002] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:15.002] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:15.002] - globals: [1] ‘FUN’
[09:29:15.002] 
[09:29:15.002] getGlobalsAndPackages() ... DONE
[09:29:15.002]  - globals found/used: [n=1] ‘FUN’
[09:29:15.003]  - needed namespaces: [n=0] 
[09:29:15.003] Finding globals ... DONE
[09:29:15.003] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:15.003] List of 2
[09:29:15.003]  $ ...future.FUN:function (e1, e2)  
[09:29:15.003]  $ MoreArgs     : NULL
[09:29:15.003]  - attr(*, "where")=List of 2
[09:29:15.003]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:15.003]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:15.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.003]  - attr(*, "resolved")= logi FALSE
[09:29:15.003]  - attr(*, "total_size")= num NA
[09:29:15.005] Packages to be attached in all futures: [n=0] 
[09:29:15.005] getGlobalsAndPackagesXApply() ... DONE
[09:29:15.005] Number of futures (= number of chunks): 1
[09:29:15.005] Launching 1 futures (chunks) ...
[09:29:15.006] Chunk #1 of 1 ...
[09:29:15.006]  - Finding globals in '...' for chunk #1 ...
[09:29:15.006] getGlobalsAndPackages() ...
[09:29:15.006] Searching for globals...
[09:29:15.006] 
[09:29:15.006] Searching for globals ... DONE
[09:29:15.006] - globals: [0] <none>
[09:29:15.006] getGlobalsAndPackages() ... DONE
[09:29:15.006]    + additional globals found: [n=0] 
[09:29:15.007]    + additional namespaces needed: [n=0] 
[09:29:15.007]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:15.007]  - seeds: <none>
[09:29:15.007]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.007] getGlobalsAndPackages() ...
[09:29:15.007] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.007] Resolving globals: FALSE
[09:29:15.007] The total size of the 5 globals is 392 bytes (392 bytes)
[09:29:15.008] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 392 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (336 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.008] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.008] 
[09:29:15.008] getGlobalsAndPackages() ... DONE
[09:29:15.008] run() for ‘Future’ ...
[09:29:15.009] - state: ‘created’
[09:29:15.009] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:15.009] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:15.009] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:15.009]   - Field: ‘label’
[09:29:15.009]   - Field: ‘local’
[09:29:15.009]   - Field: ‘owner’
[09:29:15.009]   - Field: ‘envir’
[09:29:15.009]   - Field: ‘packages’
[09:29:15.010]   - Field: ‘gc’
[09:29:15.010]   - Field: ‘conditions’
[09:29:15.010]   - Field: ‘expr’
[09:29:15.010]   - Field: ‘uuid’
[09:29:15.010]   - Field: ‘seed’
[09:29:15.010]   - Field: ‘version’
[09:29:15.010]   - Field: ‘result’
[09:29:15.010]   - Field: ‘asynchronous’
[09:29:15.010]   - Field: ‘calls’
[09:29:15.010]   - Field: ‘globals’
[09:29:15.010]   - Field: ‘stdout’
[09:29:15.011]   - Field: ‘earlySignal’
[09:29:15.011]   - Field: ‘lazy’
[09:29:15.011]   - Field: ‘state’
[09:29:15.011] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:15.011] - Launch lazy future ...
[09:29:15.011] Packages needed by the future expression (n = 0): <none>
[09:29:15.011] Packages needed by future strategies (n = 0): <none>
[09:29:15.012] {
[09:29:15.012]     {
[09:29:15.012]         {
[09:29:15.012]             ...future.startTime <- base::Sys.time()
[09:29:15.012]             {
[09:29:15.012]                 {
[09:29:15.012]                   {
[09:29:15.012]                     base::local({
[09:29:15.012]                       has_future <- base::requireNamespace("future", 
[09:29:15.012]                         quietly = TRUE)
[09:29:15.012]                       if (has_future) {
[09:29:15.012]                         ns <- base::getNamespace("future")
[09:29:15.012]                         version <- ns[[".package"]][["version"]]
[09:29:15.012]                         if (is.null(version)) 
[09:29:15.012]                           version <- utils::packageVersion("future")
[09:29:15.012]                       }
[09:29:15.012]                       else {
[09:29:15.012]                         version <- NULL
[09:29:15.012]                       }
[09:29:15.012]                       if (!has_future || version < "1.8.0") {
[09:29:15.012]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.012]                           "", base::R.version$version.string), 
[09:29:15.012]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:15.012]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.012]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.012]                             "release", "version")], collapse = " "), 
[09:29:15.012]                           hostname = base::Sys.info()[["nodename"]])
[09:29:15.012]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.012]                           info)
[09:29:15.012]                         info <- base::paste(info, collapse = "; ")
[09:29:15.012]                         if (!has_future) {
[09:29:15.012]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.012]                             info)
[09:29:15.012]                         }
[09:29:15.012]                         else {
[09:29:15.012]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.012]                             info, version)
[09:29:15.012]                         }
[09:29:15.012]                         base::stop(msg)
[09:29:15.012]                       }
[09:29:15.012]                     })
[09:29:15.012]                   }
[09:29:15.012]                   ...future.strategy.old <- future::plan("list")
[09:29:15.012]                   options(future.plan = NULL)
[09:29:15.012]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.012]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.012]                 }
[09:29:15.012]                 ...future.workdir <- getwd()
[09:29:15.012]             }
[09:29:15.012]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.012]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.012]         }
[09:29:15.012]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.012]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:15.012]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.012]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.012]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.012]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.012]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.012]             base::names(...future.oldOptions))
[09:29:15.012]     }
[09:29:15.012]     if (FALSE) {
[09:29:15.012]     }
[09:29:15.012]     else {
[09:29:15.012]         if (TRUE) {
[09:29:15.012]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.012]                 open = "w")
[09:29:15.012]         }
[09:29:15.012]         else {
[09:29:15.012]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.012]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.012]         }
[09:29:15.012]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.012]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.012]             base::sink(type = "output", split = FALSE)
[09:29:15.012]             base::close(...future.stdout)
[09:29:15.012]         }, add = TRUE)
[09:29:15.012]     }
[09:29:15.012]     ...future.frame <- base::sys.nframe()
[09:29:15.012]     ...future.conditions <- base::list()
[09:29:15.012]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.012]     if (FALSE) {
[09:29:15.012]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.012]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.012]     }
[09:29:15.012]     ...future.result <- base::tryCatch({
[09:29:15.012]         base::withCallingHandlers({
[09:29:15.012]             ...future.value <- base::withVisible(base::local({
[09:29:15.012]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.012]                 if (!identical(...future.globals.maxSize.org, 
[09:29:15.012]                   ...future.globals.maxSize)) {
[09:29:15.012]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.012]                   on.exit(options(oopts), add = TRUE)
[09:29:15.012]                 }
[09:29:15.012]                 {
[09:29:15.012]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.012]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.012]                     USE.NAMES = FALSE)
[09:29:15.012]                   do.call(mapply, args = args)
[09:29:15.012]                 }
[09:29:15.012]             }))
[09:29:15.012]             future::FutureResult(value = ...future.value$value, 
[09:29:15.012]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.012]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.012]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.012]                     ...future.globalenv.names))
[09:29:15.012]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.012]         }, condition = base::local({
[09:29:15.012]             c <- base::c
[09:29:15.012]             inherits <- base::inherits
[09:29:15.012]             invokeRestart <- base::invokeRestart
[09:29:15.012]             length <- base::length
[09:29:15.012]             list <- base::list
[09:29:15.012]             seq.int <- base::seq.int
[09:29:15.012]             signalCondition <- base::signalCondition
[09:29:15.012]             sys.calls <- base::sys.calls
[09:29:15.012]             `[[` <- base::`[[`
[09:29:15.012]             `+` <- base::`+`
[09:29:15.012]             `<<-` <- base::`<<-`
[09:29:15.012]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.012]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.012]                   3L)]
[09:29:15.012]             }
[09:29:15.012]             function(cond) {
[09:29:15.012]                 is_error <- inherits(cond, "error")
[09:29:15.012]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.012]                   NULL)
[09:29:15.012]                 if (is_error) {
[09:29:15.012]                   sessionInformation <- function() {
[09:29:15.012]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.012]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.012]                       search = base::search(), system = base::Sys.info())
[09:29:15.012]                   }
[09:29:15.012]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.012]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.012]                     cond$call), session = sessionInformation(), 
[09:29:15.012]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.012]                   signalCondition(cond)
[09:29:15.012]                 }
[09:29:15.012]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.012]                 "immediateCondition"))) {
[09:29:15.012]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.012]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.012]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.012]                   if (TRUE && !signal) {
[09:29:15.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.012]                     {
[09:29:15.012]                       inherits <- base::inherits
[09:29:15.012]                       invokeRestart <- base::invokeRestart
[09:29:15.012]                       is.null <- base::is.null
[09:29:15.012]                       muffled <- FALSE
[09:29:15.012]                       if (inherits(cond, "message")) {
[09:29:15.012]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.012]                         if (muffled) 
[09:29:15.012]                           invokeRestart("muffleMessage")
[09:29:15.012]                       }
[09:29:15.012]                       else if (inherits(cond, "warning")) {
[09:29:15.012]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.012]                         if (muffled) 
[09:29:15.012]                           invokeRestart("muffleWarning")
[09:29:15.012]                       }
[09:29:15.012]                       else if (inherits(cond, "condition")) {
[09:29:15.012]                         if (!is.null(pattern)) {
[09:29:15.012]                           computeRestarts <- base::computeRestarts
[09:29:15.012]                           grepl <- base::grepl
[09:29:15.012]                           restarts <- computeRestarts(cond)
[09:29:15.012]                           for (restart in restarts) {
[09:29:15.012]                             name <- restart$name
[09:29:15.012]                             if (is.null(name)) 
[09:29:15.012]                               next
[09:29:15.012]                             if (!grepl(pattern, name)) 
[09:29:15.012]                               next
[09:29:15.012]                             invokeRestart(restart)
[09:29:15.012]                             muffled <- TRUE
[09:29:15.012]                             break
[09:29:15.012]                           }
[09:29:15.012]                         }
[09:29:15.012]                       }
[09:29:15.012]                       invisible(muffled)
[09:29:15.012]                     }
[09:29:15.012]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.012]                   }
[09:29:15.012]                 }
[09:29:15.012]                 else {
[09:29:15.012]                   if (TRUE) {
[09:29:15.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.012]                     {
[09:29:15.012]                       inherits <- base::inherits
[09:29:15.012]                       invokeRestart <- base::invokeRestart
[09:29:15.012]                       is.null <- base::is.null
[09:29:15.012]                       muffled <- FALSE
[09:29:15.012]                       if (inherits(cond, "message")) {
[09:29:15.012]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.012]                         if (muffled) 
[09:29:15.012]                           invokeRestart("muffleMessage")
[09:29:15.012]                       }
[09:29:15.012]                       else if (inherits(cond, "warning")) {
[09:29:15.012]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.012]                         if (muffled) 
[09:29:15.012]                           invokeRestart("muffleWarning")
[09:29:15.012]                       }
[09:29:15.012]                       else if (inherits(cond, "condition")) {
[09:29:15.012]                         if (!is.null(pattern)) {
[09:29:15.012]                           computeRestarts <- base::computeRestarts
[09:29:15.012]                           grepl <- base::grepl
[09:29:15.012]                           restarts <- computeRestarts(cond)
[09:29:15.012]                           for (restart in restarts) {
[09:29:15.012]                             name <- restart$name
[09:29:15.012]                             if (is.null(name)) 
[09:29:15.012]                               next
[09:29:15.012]                             if (!grepl(pattern, name)) 
[09:29:15.012]                               next
[09:29:15.012]                             invokeRestart(restart)
[09:29:15.012]                             muffled <- TRUE
[09:29:15.012]                             break
[09:29:15.012]                           }
[09:29:15.012]                         }
[09:29:15.012]                       }
[09:29:15.012]                       invisible(muffled)
[09:29:15.012]                     }
[09:29:15.012]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.012]                   }
[09:29:15.012]                 }
[09:29:15.012]             }
[09:29:15.012]         }))
[09:29:15.012]     }, error = function(ex) {
[09:29:15.012]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.012]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.012]                 ...future.rng), started = ...future.startTime, 
[09:29:15.012]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.012]             version = "1.8"), class = "FutureResult")
[09:29:15.012]     }, finally = {
[09:29:15.012]         if (!identical(...future.workdir, getwd())) 
[09:29:15.012]             setwd(...future.workdir)
[09:29:15.012]         {
[09:29:15.012]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.012]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.012]             }
[09:29:15.012]             base::options(...future.oldOptions)
[09:29:15.012]             if (.Platform$OS.type == "windows") {
[09:29:15.012]                 old_names <- names(...future.oldEnvVars)
[09:29:15.012]                 envs <- base::Sys.getenv()
[09:29:15.012]                 names <- names(envs)
[09:29:15.012]                 common <- intersect(names, old_names)
[09:29:15.012]                 added <- setdiff(names, old_names)
[09:29:15.012]                 removed <- setdiff(old_names, names)
[09:29:15.012]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.012]                   envs[common]]
[09:29:15.012]                 NAMES <- toupper(changed)
[09:29:15.012]                 args <- list()
[09:29:15.012]                 for (kk in seq_along(NAMES)) {
[09:29:15.012]                   name <- changed[[kk]]
[09:29:15.012]                   NAME <- NAMES[[kk]]
[09:29:15.012]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.012]                     next
[09:29:15.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.012]                 }
[09:29:15.012]                 NAMES <- toupper(added)
[09:29:15.012]                 for (kk in seq_along(NAMES)) {
[09:29:15.012]                   name <- added[[kk]]
[09:29:15.012]                   NAME <- NAMES[[kk]]
[09:29:15.012]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.012]                     next
[09:29:15.012]                   args[[name]] <- ""
[09:29:15.012]                 }
[09:29:15.012]                 NAMES <- toupper(removed)
[09:29:15.012]                 for (kk in seq_along(NAMES)) {
[09:29:15.012]                   name <- removed[[kk]]
[09:29:15.012]                   NAME <- NAMES[[kk]]
[09:29:15.012]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.012]                     next
[09:29:15.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.012]                 }
[09:29:15.012]                 if (length(args) > 0) 
[09:29:15.012]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.012]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.012]             }
[09:29:15.012]             else {
[09:29:15.012]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.012]             }
[09:29:15.012]             {
[09:29:15.012]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.012]                   0L) {
[09:29:15.012]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.012]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.012]                   base::options(opts)
[09:29:15.012]                 }
[09:29:15.012]                 {
[09:29:15.012]                   {
[09:29:15.012]                     base::assign(".Random.seed", c(10407L, -1055677337L, 
[09:29:15.012]                     1033720650L, -512088055L, -897961199L, -1409881771L, 
[09:29:15.012]                     -1097230566L), envir = base::globalenv(), 
[09:29:15.012]                       inherits = FALSE)
[09:29:15.012]                     NULL
[09:29:15.012]                   }
[09:29:15.012]                   options(future.plan = NULL)
[09:29:15.012]                   if (is.na(NA_character_)) 
[09:29:15.012]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.012]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.012]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.012]                     .init = FALSE)
[09:29:15.012]                 }
[09:29:15.012]             }
[09:29:15.012]         }
[09:29:15.012]     })
[09:29:15.012]     if (TRUE) {
[09:29:15.012]         base::sink(type = "output", split = FALSE)
[09:29:15.012]         if (TRUE) {
[09:29:15.012]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.012]         }
[09:29:15.012]         else {
[09:29:15.012]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.012]         }
[09:29:15.012]         base::close(...future.stdout)
[09:29:15.012]         ...future.stdout <- NULL
[09:29:15.012]     }
[09:29:15.012]     ...future.result$conditions <- ...future.conditions
[09:29:15.012]     ...future.result$finished <- base::Sys.time()
[09:29:15.012]     ...future.result
[09:29:15.012] }
[09:29:15.013] assign_globals() ...
[09:29:15.013] List of 5
[09:29:15.013]  $ ...future.FUN            :function (e1, e2)  
[09:29:15.013]  $ MoreArgs                 : NULL
[09:29:15.013]  $ ...future.elements_ii    :List of 2
[09:29:15.013]   ..$ :List of 3
[09:29:15.013]   .. ..$ : num 1
[09:29:15.013]   .. ..$ : num 1
[09:29:15.013]   .. ..$ : num 1
[09:29:15.013]   ..$ :List of 3
[09:29:15.013]   .. ..$ : int 1
[09:29:15.013]   .. ..$ : int 2
[09:29:15.013]   .. ..$ : int 3
[09:29:15.013]  $ ...future.seeds_ii       : NULL
[09:29:15.013]  $ ...future.globals.maxSize: NULL
[09:29:15.013]  - attr(*, "where")=List of 5
[09:29:15.013]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.013]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.013]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.013]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.013]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.013]  - attr(*, "resolved")= logi FALSE
[09:29:15.013]  - attr(*, "total_size")= num 392
[09:29:15.013]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.013]  - attr(*, "already-done")= logi TRUE
[09:29:15.022] - copied ‘...future.FUN’ to environment
[09:29:15.022] - copied ‘MoreArgs’ to environment
[09:29:15.022] - copied ‘...future.elements_ii’ to environment
[09:29:15.022] - copied ‘...future.seeds_ii’ to environment
[09:29:15.022] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.022] assign_globals() ... done
[09:29:15.022] plan(): Setting new future strategy stack:
[09:29:15.023] List of future strategies:
[09:29:15.023] 1. sequential:
[09:29:15.023]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.023]    - tweaked: FALSE
[09:29:15.023]    - call: NULL
[09:29:15.023] plan(): nbrOfWorkers() = 1
[09:29:15.024] plan(): Setting new future strategy stack:
[09:29:15.024] List of future strategies:
[09:29:15.024] 1. sequential:
[09:29:15.024]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.024]    - tweaked: FALSE
[09:29:15.024]    - call: plan(strategy)
[09:29:15.024] plan(): nbrOfWorkers() = 1
[09:29:15.024] SequentialFuture started (and completed)
[09:29:15.024] - Launch lazy future ... done
[09:29:15.025] run() for ‘SequentialFuture’ ... done
[09:29:15.025] Created future:
[09:29:15.025] SequentialFuture:
[09:29:15.025] Label: ‘future_Map-1’
[09:29:15.025] Expression:
[09:29:15.025] {
[09:29:15.025]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.025]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.025]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.025]         on.exit(options(oopts), add = TRUE)
[09:29:15.025]     }
[09:29:15.025]     {
[09:29:15.025]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.025]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.025]         do.call(mapply, args = args)
[09:29:15.025]     }
[09:29:15.025] }
[09:29:15.025] Lazy evaluation: FALSE
[09:29:15.025] Asynchronous evaluation: FALSE
[09:29:15.025] Local evaluation: TRUE
[09:29:15.025] Environment: R_GlobalEnv
[09:29:15.025] Capture standard output: TRUE
[09:29:15.025] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.025] Globals: 5 objects totaling 392 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.025] Packages: <none>
[09:29:15.025] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.025] Resolved: TRUE
[09:29:15.025] Value: 168 bytes of class ‘list’
[09:29:15.025] Early signaling: FALSE
[09:29:15.025] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.025] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:15.026] Chunk #1 of 1 ... DONE
[09:29:15.026] Launching 1 futures (chunks) ... DONE
[09:29:15.026] Resolving 1 futures (chunks) ...
[09:29:15.026] resolve() on list ...
[09:29:15.026]  recursive: 0
[09:29:15.026]  length: 1
[09:29:15.026] 
[09:29:15.026] resolved() for ‘SequentialFuture’ ...
[09:29:15.026] - state: ‘finished’
[09:29:15.026] - run: TRUE
[09:29:15.027] - result: ‘FutureResult’
[09:29:15.027] resolved() for ‘SequentialFuture’ ... done
[09:29:15.027] Future #1
[09:29:15.027] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:15.027] - nx: 1
[09:29:15.027] - relay: TRUE
[09:29:15.027] - stdout: TRUE
[09:29:15.027] - signal: TRUE
[09:29:15.027] - resignal: FALSE
[09:29:15.027] - force: TRUE
[09:29:15.027] - relayed: [n=1] FALSE
[09:29:15.028] - queued futures: [n=1] FALSE
[09:29:15.028]  - until=1
[09:29:15.028]  - relaying element #1
[09:29:15.028] - relayed: [n=1] TRUE
[09:29:15.028] - queued futures: [n=1] TRUE
[09:29:15.028] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:15.028]  length: 0 (resolved future 1)
[09:29:15.028] Relaying remaining futures
[09:29:15.028] signalConditionsASAP(NULL, pos=0) ...
[09:29:15.028] - nx: 1
[09:29:15.029] - relay: TRUE
[09:29:15.029] - stdout: TRUE
[09:29:15.029] - signal: TRUE
[09:29:15.029] - resignal: FALSE
[09:29:15.029] - force: TRUE
[09:29:15.029] - relayed: [n=1] TRUE
[09:29:15.029] - queued futures: [n=1] TRUE
 - flush all
[09:29:15.029] - relayed: [n=1] TRUE
[09:29:15.029] - queued futures: [n=1] TRUE
[09:29:15.029] signalConditionsASAP(NULL, pos=0) ... done
[09:29:15.029] resolve() on list ... DONE
[09:29:15.030]  - Number of value chunks collected: 1
[09:29:15.030] Resolving 1 futures (chunks) ... DONE
[09:29:15.030] Reducing values from 1 chunks ...
[09:29:15.030]  - Number of values collected after concatenation: 3
[09:29:15.030]  - Number of values expected: 3
[09:29:15.030] Reducing values from 1 chunks ... DONE
[09:29:15.030] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[09:29:15.030] future_mapply() ...
[09:29:15.031] Number of chunks: 1
[09:29:15.031] getGlobalsAndPackagesXApply() ...
[09:29:15.031]  - future.globals: TRUE
[09:29:15.031] getGlobalsAndPackages() ...
[09:29:15.031] Searching for globals...
[09:29:15.032] - globals found: [1] ‘FUN’
[09:29:15.032] Searching for globals ... DONE
[09:29:15.032] Resolving globals: FALSE
[09:29:15.032] The total size of the 1 globals is 848 bytes (848 bytes)
[09:29:15.033] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:29:15.033] - globals: [1] ‘FUN’
[09:29:15.033] 
[09:29:15.033] getGlobalsAndPackages() ... DONE
[09:29:15.033]  - globals found/used: [n=1] ‘FUN’
[09:29:15.033]  - needed namespaces: [n=0] 
[09:29:15.033] Finding globals ... DONE
[09:29:15.033] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:15.034] List of 2
[09:29:15.034]  $ ...future.FUN:function (x)  
[09:29:15.034]  $ MoreArgs     : NULL
[09:29:15.034]  - attr(*, "where")=List of 2
[09:29:15.034]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:15.034]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:15.034]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.034]  - attr(*, "resolved")= logi FALSE
[09:29:15.034]  - attr(*, "total_size")= num NA
[09:29:15.036] Packages to be attached in all futures: [n=0] 
[09:29:15.036] getGlobalsAndPackagesXApply() ... DONE
[09:29:15.036] Number of futures (= number of chunks): 1
[09:29:15.036] Launching 1 futures (chunks) ...
[09:29:15.036] Chunk #1 of 1 ...
[09:29:15.036]  - Finding globals in '...' for chunk #1 ...
[09:29:15.037] getGlobalsAndPackages() ...
[09:29:15.037] Searching for globals...
[09:29:15.037] 
[09:29:15.037] Searching for globals ... DONE
[09:29:15.037] - globals: [0] <none>
[09:29:15.037] getGlobalsAndPackages() ... DONE
[09:29:15.037]    + additional globals found: [n=0] 
[09:29:15.037]    + additional namespaces needed: [n=0] 
[09:29:15.037]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:15.037]  - seeds: <none>
[09:29:15.038]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.038] getGlobalsAndPackages() ...
[09:29:15.038] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.038] Resolving globals: FALSE
[09:29:15.038] The total size of the 5 globals is 960 bytes (960 bytes)
[09:29:15.039] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 960 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.040] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.040] 
[09:29:15.040] getGlobalsAndPackages() ... DONE
[09:29:15.041] run() for ‘Future’ ...
[09:29:15.041] - state: ‘created’
[09:29:15.041] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:15.041] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:15.041] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:15.041]   - Field: ‘label’
[09:29:15.042]   - Field: ‘local’
[09:29:15.042]   - Field: ‘owner’
[09:29:15.042]   - Field: ‘envir’
[09:29:15.042]   - Field: ‘packages’
[09:29:15.042]   - Field: ‘gc’
[09:29:15.042]   - Field: ‘conditions’
[09:29:15.042]   - Field: ‘expr’
[09:29:15.042]   - Field: ‘uuid’
[09:29:15.042]   - Field: ‘seed’
[09:29:15.042]   - Field: ‘version’
[09:29:15.042]   - Field: ‘result’
[09:29:15.043]   - Field: ‘asynchronous’
[09:29:15.043]   - Field: ‘calls’
[09:29:15.043]   - Field: ‘globals’
[09:29:15.043]   - Field: ‘stdout’
[09:29:15.043]   - Field: ‘earlySignal’
[09:29:15.043]   - Field: ‘lazy’
[09:29:15.043]   - Field: ‘state’
[09:29:15.043] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:15.043] - Launch lazy future ...
[09:29:15.043] Packages needed by the future expression (n = 0): <none>
[09:29:15.044] Packages needed by future strategies (n = 0): <none>
[09:29:15.044] {
[09:29:15.044]     {
[09:29:15.044]         {
[09:29:15.044]             ...future.startTime <- base::Sys.time()
[09:29:15.044]             {
[09:29:15.044]                 {
[09:29:15.044]                   {
[09:29:15.044]                     base::local({
[09:29:15.044]                       has_future <- base::requireNamespace("future", 
[09:29:15.044]                         quietly = TRUE)
[09:29:15.044]                       if (has_future) {
[09:29:15.044]                         ns <- base::getNamespace("future")
[09:29:15.044]                         version <- ns[[".package"]][["version"]]
[09:29:15.044]                         if (is.null(version)) 
[09:29:15.044]                           version <- utils::packageVersion("future")
[09:29:15.044]                       }
[09:29:15.044]                       else {
[09:29:15.044]                         version <- NULL
[09:29:15.044]                       }
[09:29:15.044]                       if (!has_future || version < "1.8.0") {
[09:29:15.044]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.044]                           "", base::R.version$version.string), 
[09:29:15.044]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:15.044]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.044]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.044]                             "release", "version")], collapse = " "), 
[09:29:15.044]                           hostname = base::Sys.info()[["nodename"]])
[09:29:15.044]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.044]                           info)
[09:29:15.044]                         info <- base::paste(info, collapse = "; ")
[09:29:15.044]                         if (!has_future) {
[09:29:15.044]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.044]                             info)
[09:29:15.044]                         }
[09:29:15.044]                         else {
[09:29:15.044]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.044]                             info, version)
[09:29:15.044]                         }
[09:29:15.044]                         base::stop(msg)
[09:29:15.044]                       }
[09:29:15.044]                     })
[09:29:15.044]                   }
[09:29:15.044]                   ...future.strategy.old <- future::plan("list")
[09:29:15.044]                   options(future.plan = NULL)
[09:29:15.044]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.044]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.044]                 }
[09:29:15.044]                 ...future.workdir <- getwd()
[09:29:15.044]             }
[09:29:15.044]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.044]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.044]         }
[09:29:15.044]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.044]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:15.044]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.044]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.044]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.044]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.044]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.044]             base::names(...future.oldOptions))
[09:29:15.044]     }
[09:29:15.044]     if (FALSE) {
[09:29:15.044]     }
[09:29:15.044]     else {
[09:29:15.044]         if (TRUE) {
[09:29:15.044]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.044]                 open = "w")
[09:29:15.044]         }
[09:29:15.044]         else {
[09:29:15.044]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.044]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.044]         }
[09:29:15.044]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.044]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.044]             base::sink(type = "output", split = FALSE)
[09:29:15.044]             base::close(...future.stdout)
[09:29:15.044]         }, add = TRUE)
[09:29:15.044]     }
[09:29:15.044]     ...future.frame <- base::sys.nframe()
[09:29:15.044]     ...future.conditions <- base::list()
[09:29:15.044]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.044]     if (FALSE) {
[09:29:15.044]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.044]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.044]     }
[09:29:15.044]     ...future.result <- base::tryCatch({
[09:29:15.044]         base::withCallingHandlers({
[09:29:15.044]             ...future.value <- base::withVisible(base::local({
[09:29:15.044]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.044]                 if (!identical(...future.globals.maxSize.org, 
[09:29:15.044]                   ...future.globals.maxSize)) {
[09:29:15.044]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.044]                   on.exit(options(oopts), add = TRUE)
[09:29:15.044]                 }
[09:29:15.044]                 {
[09:29:15.044]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.044]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.044]                     USE.NAMES = FALSE)
[09:29:15.044]                   do.call(mapply, args = args)
[09:29:15.044]                 }
[09:29:15.044]             }))
[09:29:15.044]             future::FutureResult(value = ...future.value$value, 
[09:29:15.044]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.044]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.044]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.044]                     ...future.globalenv.names))
[09:29:15.044]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.044]         }, condition = base::local({
[09:29:15.044]             c <- base::c
[09:29:15.044]             inherits <- base::inherits
[09:29:15.044]             invokeRestart <- base::invokeRestart
[09:29:15.044]             length <- base::length
[09:29:15.044]             list <- base::list
[09:29:15.044]             seq.int <- base::seq.int
[09:29:15.044]             signalCondition <- base::signalCondition
[09:29:15.044]             sys.calls <- base::sys.calls
[09:29:15.044]             `[[` <- base::`[[`
[09:29:15.044]             `+` <- base::`+`
[09:29:15.044]             `<<-` <- base::`<<-`
[09:29:15.044]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.044]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.044]                   3L)]
[09:29:15.044]             }
[09:29:15.044]             function(cond) {
[09:29:15.044]                 is_error <- inherits(cond, "error")
[09:29:15.044]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.044]                   NULL)
[09:29:15.044]                 if (is_error) {
[09:29:15.044]                   sessionInformation <- function() {
[09:29:15.044]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.044]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.044]                       search = base::search(), system = base::Sys.info())
[09:29:15.044]                   }
[09:29:15.044]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.044]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.044]                     cond$call), session = sessionInformation(), 
[09:29:15.044]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.044]                   signalCondition(cond)
[09:29:15.044]                 }
[09:29:15.044]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.044]                 "immediateCondition"))) {
[09:29:15.044]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.044]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.044]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.044]                   if (TRUE && !signal) {
[09:29:15.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.044]                     {
[09:29:15.044]                       inherits <- base::inherits
[09:29:15.044]                       invokeRestart <- base::invokeRestart
[09:29:15.044]                       is.null <- base::is.null
[09:29:15.044]                       muffled <- FALSE
[09:29:15.044]                       if (inherits(cond, "message")) {
[09:29:15.044]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.044]                         if (muffled) 
[09:29:15.044]                           invokeRestart("muffleMessage")
[09:29:15.044]                       }
[09:29:15.044]                       else if (inherits(cond, "warning")) {
[09:29:15.044]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.044]                         if (muffled) 
[09:29:15.044]                           invokeRestart("muffleWarning")
[09:29:15.044]                       }
[09:29:15.044]                       else if (inherits(cond, "condition")) {
[09:29:15.044]                         if (!is.null(pattern)) {
[09:29:15.044]                           computeRestarts <- base::computeRestarts
[09:29:15.044]                           grepl <- base::grepl
[09:29:15.044]                           restarts <- computeRestarts(cond)
[09:29:15.044]                           for (restart in restarts) {
[09:29:15.044]                             name <- restart$name
[09:29:15.044]                             if (is.null(name)) 
[09:29:15.044]                               next
[09:29:15.044]                             if (!grepl(pattern, name)) 
[09:29:15.044]                               next
[09:29:15.044]                             invokeRestart(restart)
[09:29:15.044]                             muffled <- TRUE
[09:29:15.044]                             break
[09:29:15.044]                           }
[09:29:15.044]                         }
[09:29:15.044]                       }
[09:29:15.044]                       invisible(muffled)
[09:29:15.044]                     }
[09:29:15.044]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.044]                   }
[09:29:15.044]                 }
[09:29:15.044]                 else {
[09:29:15.044]                   if (TRUE) {
[09:29:15.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.044]                     {
[09:29:15.044]                       inherits <- base::inherits
[09:29:15.044]                       invokeRestart <- base::invokeRestart
[09:29:15.044]                       is.null <- base::is.null
[09:29:15.044]                       muffled <- FALSE
[09:29:15.044]                       if (inherits(cond, "message")) {
[09:29:15.044]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.044]                         if (muffled) 
[09:29:15.044]                           invokeRestart("muffleMessage")
[09:29:15.044]                       }
[09:29:15.044]                       else if (inherits(cond, "warning")) {
[09:29:15.044]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.044]                         if (muffled) 
[09:29:15.044]                           invokeRestart("muffleWarning")
[09:29:15.044]                       }
[09:29:15.044]                       else if (inherits(cond, "condition")) {
[09:29:15.044]                         if (!is.null(pattern)) {
[09:29:15.044]                           computeRestarts <- base::computeRestarts
[09:29:15.044]                           grepl <- base::grepl
[09:29:15.044]                           restarts <- computeRestarts(cond)
[09:29:15.044]                           for (restart in restarts) {
[09:29:15.044]                             name <- restart$name
[09:29:15.044]                             if (is.null(name)) 
[09:29:15.044]                               next
[09:29:15.044]                             if (!grepl(pattern, name)) 
[09:29:15.044]                               next
[09:29:15.044]                             invokeRestart(restart)
[09:29:15.044]                             muffled <- TRUE
[09:29:15.044]                             break
[09:29:15.044]                           }
[09:29:15.044]                         }
[09:29:15.044]                       }
[09:29:15.044]                       invisible(muffled)
[09:29:15.044]                     }
[09:29:15.044]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.044]                   }
[09:29:15.044]                 }
[09:29:15.044]             }
[09:29:15.044]         }))
[09:29:15.044]     }, error = function(ex) {
[09:29:15.044]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.044]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.044]                 ...future.rng), started = ...future.startTime, 
[09:29:15.044]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.044]             version = "1.8"), class = "FutureResult")
[09:29:15.044]     }, finally = {
[09:29:15.044]         if (!identical(...future.workdir, getwd())) 
[09:29:15.044]             setwd(...future.workdir)
[09:29:15.044]         {
[09:29:15.044]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.044]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.044]             }
[09:29:15.044]             base::options(...future.oldOptions)
[09:29:15.044]             if (.Platform$OS.type == "windows") {
[09:29:15.044]                 old_names <- names(...future.oldEnvVars)
[09:29:15.044]                 envs <- base::Sys.getenv()
[09:29:15.044]                 names <- names(envs)
[09:29:15.044]                 common <- intersect(names, old_names)
[09:29:15.044]                 added <- setdiff(names, old_names)
[09:29:15.044]                 removed <- setdiff(old_names, names)
[09:29:15.044]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.044]                   envs[common]]
[09:29:15.044]                 NAMES <- toupper(changed)
[09:29:15.044]                 args <- list()
[09:29:15.044]                 for (kk in seq_along(NAMES)) {
[09:29:15.044]                   name <- changed[[kk]]
[09:29:15.044]                   NAME <- NAMES[[kk]]
[09:29:15.044]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.044]                     next
[09:29:15.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.044]                 }
[09:29:15.044]                 NAMES <- toupper(added)
[09:29:15.044]                 for (kk in seq_along(NAMES)) {
[09:29:15.044]                   name <- added[[kk]]
[09:29:15.044]                   NAME <- NAMES[[kk]]
[09:29:15.044]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.044]                     next
[09:29:15.044]                   args[[name]] <- ""
[09:29:15.044]                 }
[09:29:15.044]                 NAMES <- toupper(removed)
[09:29:15.044]                 for (kk in seq_along(NAMES)) {
[09:29:15.044]                   name <- removed[[kk]]
[09:29:15.044]                   NAME <- NAMES[[kk]]
[09:29:15.044]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.044]                     next
[09:29:15.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.044]                 }
[09:29:15.044]                 if (length(args) > 0) 
[09:29:15.044]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.044]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.044]             }
[09:29:15.044]             else {
[09:29:15.044]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.044]             }
[09:29:15.044]             {
[09:29:15.044]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.044]                   0L) {
[09:29:15.044]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.044]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.044]                   base::options(opts)
[09:29:15.044]                 }
[09:29:15.044]                 {
[09:29:15.044]                   {
[09:29:15.044]                     base::assign(".Random.seed", c(10407L, -1055677337L, 
[09:29:15.044]                     1033720650L, -512088055L, -897961199L, -1409881771L, 
[09:29:15.044]                     -1097230566L), envir = base::globalenv(), 
[09:29:15.044]                       inherits = FALSE)
[09:29:15.044]                     NULL
[09:29:15.044]                   }
[09:29:15.044]                   options(future.plan = NULL)
[09:29:15.044]                   if (is.na(NA_character_)) 
[09:29:15.044]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.044]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.044]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.044]                     .init = FALSE)
[09:29:15.044]                 }
[09:29:15.044]             }
[09:29:15.044]         }
[09:29:15.044]     })
[09:29:15.044]     if (TRUE) {
[09:29:15.044]         base::sink(type = "output", split = FALSE)
[09:29:15.044]         if (TRUE) {
[09:29:15.044]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.044]         }
[09:29:15.044]         else {
[09:29:15.044]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.044]         }
[09:29:15.044]         base::close(...future.stdout)
[09:29:15.044]         ...future.stdout <- NULL
[09:29:15.044]     }
[09:29:15.044]     ...future.result$conditions <- ...future.conditions
[09:29:15.044]     ...future.result$finished <- base::Sys.time()
[09:29:15.044]     ...future.result
[09:29:15.044] }
[09:29:15.046] assign_globals() ...
[09:29:15.046] List of 5
[09:29:15.046]  $ ...future.FUN            :function (x)  
[09:29:15.046]  $ MoreArgs                 : NULL
[09:29:15.046]  $ ...future.elements_ii    :List of 1
[09:29:15.046]   ..$ :List of 2
[09:29:15.046]   .. ..$ a: num 0
[09:29:15.046]   .. ..$ b: num 0
[09:29:15.046]  $ ...future.seeds_ii       : NULL
[09:29:15.046]  $ ...future.globals.maxSize: NULL
[09:29:15.046]  - attr(*, "where")=List of 5
[09:29:15.046]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.046]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.046]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.046]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.046]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.046]  - attr(*, "resolved")= logi FALSE
[09:29:15.046]  - attr(*, "total_size")= num 960
[09:29:15.046]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.046]  - attr(*, "already-done")= logi TRUE
[09:29:15.050] - copied ‘...future.FUN’ to environment
[09:29:15.050] - copied ‘MoreArgs’ to environment
[09:29:15.050] - copied ‘...future.elements_ii’ to environment
[09:29:15.051] - copied ‘...future.seeds_ii’ to environment
[09:29:15.051] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.051] assign_globals() ... done
[09:29:15.051] plan(): Setting new future strategy stack:
[09:29:15.051] List of future strategies:
[09:29:15.051] 1. sequential:
[09:29:15.051]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.051]    - tweaked: FALSE
[09:29:15.051]    - call: NULL
[09:29:15.051] plan(): nbrOfWorkers() = 1
[09:29:15.052] plan(): Setting new future strategy stack:
[09:29:15.052] List of future strategies:
[09:29:15.052] 1. sequential:
[09:29:15.052]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.052]    - tweaked: FALSE
[09:29:15.052]    - call: plan(strategy)
[09:29:15.053] plan(): nbrOfWorkers() = 1
[09:29:15.053] SequentialFuture started (and completed)
[09:29:15.053] - Launch lazy future ... done
[09:29:15.053] run() for ‘SequentialFuture’ ... done
[09:29:15.053] Created future:
[09:29:15.053] SequentialFuture:
[09:29:15.053] Label: ‘future_mapply-1’
[09:29:15.053] Expression:
[09:29:15.053] {
[09:29:15.053]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.053]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.053]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.053]         on.exit(options(oopts), add = TRUE)
[09:29:15.053]     }
[09:29:15.053]     {
[09:29:15.053]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.053]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.053]         do.call(mapply, args = args)
[09:29:15.053]     }
[09:29:15.053] }
[09:29:15.053] Lazy evaluation: FALSE
[09:29:15.053] Asynchronous evaluation: FALSE
[09:29:15.053] Local evaluation: TRUE
[09:29:15.053] Environment: R_GlobalEnv
[09:29:15.053] Capture standard output: TRUE
[09:29:15.053] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.053] Globals: 5 objects totaling 960 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.053] Packages: <none>
[09:29:15.053] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.053] Resolved: TRUE
[09:29:15.053] Value: 112 bytes of class ‘list’
[09:29:15.053] Early signaling: FALSE
[09:29:15.053] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.053] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:15.054] Chunk #1 of 1 ... DONE
[09:29:15.054] Launching 1 futures (chunks) ... DONE
[09:29:15.054] Resolving 1 futures (chunks) ...
[09:29:15.054] resolve() on list ...
[09:29:15.054]  recursive: 0
[09:29:15.054]  length: 1
[09:29:15.055] 
[09:29:15.055] resolved() for ‘SequentialFuture’ ...
[09:29:15.055] - state: ‘finished’
[09:29:15.055] - run: TRUE
[09:29:15.055] - result: ‘FutureResult’
[09:29:15.055] resolved() for ‘SequentialFuture’ ... done
[09:29:15.055] Future #1
[09:29:15.055] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:15.055] - nx: 1
[09:29:15.055] - relay: TRUE
[09:29:15.055] - stdout: TRUE
[09:29:15.056] - signal: TRUE
[09:29:15.056] - resignal: FALSE
[09:29:15.056] - force: TRUE
[09:29:15.056] - relayed: [n=1] FALSE
[09:29:15.056] - queued futures: [n=1] FALSE
[09:29:15.056]  - until=1
[09:29:15.056]  - relaying element #1
[09:29:15.056] - relayed: [n=1] TRUE
[09:29:15.056] - queued futures: [n=1] TRUE
[09:29:15.056] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:15.057]  length: 0 (resolved future 1)
[09:29:15.057] Relaying remaining futures
[09:29:15.057] signalConditionsASAP(NULL, pos=0) ...
[09:29:15.057] - nx: 1
[09:29:15.057] - relay: TRUE
[09:29:15.057] - stdout: TRUE
[09:29:15.057] - signal: TRUE
[09:29:15.057] - resignal: FALSE
[09:29:15.057] - force: TRUE
[09:29:15.057] - relayed: [n=1] TRUE
[09:29:15.057] - queued futures: [n=1] TRUE
 - flush all
[09:29:15.057] - relayed: [n=1] TRUE
[09:29:15.058] - queued futures: [n=1] TRUE
[09:29:15.058] signalConditionsASAP(NULL, pos=0) ... done
[09:29:15.058] resolve() on list ... DONE
[09:29:15.058]  - Number of value chunks collected: 1
[09:29:15.058] Resolving 1 futures (chunks) ... DONE
[09:29:15.058] Reducing values from 1 chunks ...
[09:29:15.058]  - Number of values collected after concatenation: 2
[09:29:15.058]  - Number of values expected: 2
[09:29:15.058] Reducing values from 1 chunks ... DONE
[09:29:15.058] future_mapply() ... DONE
[09:29:15.058] plan(): Setting new future strategy stack:
[09:29:15.059] List of future strategies:
[09:29:15.059] 1. sequential:
[09:29:15.059]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.059]    - tweaked: FALSE
[09:29:15.059]    - call: plan(sequential)
[09:29:15.059] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[09:29:15.059] plan(): Setting new future strategy stack:
[09:29:15.059] List of future strategies:
[09:29:15.059] 1. multicore:
[09:29:15.059]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.059]    - tweaked: FALSE
[09:29:15.059]    - call: plan(strategy)
[09:29:15.063] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[09:29:15.063] future_mapply() ...
[09:29:15.067] Number of chunks: 2
[09:29:15.067] getGlobalsAndPackagesXApply() ...
[09:29:15.067]  - future.globals: TRUE
[09:29:15.067] getGlobalsAndPackages() ...
[09:29:15.067] Searching for globals...
[09:29:15.068] - globals found: [1] ‘FUN’
[09:29:15.069] Searching for globals ... DONE
[09:29:15.069] Resolving globals: FALSE
[09:29:15.070] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:15.070] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:15.070] - globals: [1] ‘FUN’
[09:29:15.070] 
[09:29:15.070] getGlobalsAndPackages() ... DONE
[09:29:15.070]  - globals found/used: [n=1] ‘FUN’
[09:29:15.070]  - needed namespaces: [n=0] 
[09:29:15.071] Finding globals ... DONE
[09:29:15.071] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:15.071] List of 2
[09:29:15.071]  $ ...future.FUN:function (x, ...)  
[09:29:15.071]  $ MoreArgs     : NULL
[09:29:15.071]  - attr(*, "where")=List of 2
[09:29:15.071]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:15.071]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:15.071]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.071]  - attr(*, "resolved")= logi FALSE
[09:29:15.071]  - attr(*, "total_size")= num NA
[09:29:15.073] Packages to be attached in all futures: [n=0] 
[09:29:15.073] getGlobalsAndPackagesXApply() ... DONE
[09:29:15.074] Number of futures (= number of chunks): 2
[09:29:15.074] Launching 2 futures (chunks) ...
[09:29:15.074] Chunk #1 of 2 ...
[09:29:15.074]  - Finding globals in '...' for chunk #1 ...
[09:29:15.074] getGlobalsAndPackages() ...
[09:29:15.074] Searching for globals...
[09:29:15.074] 
[09:29:15.074] Searching for globals ... DONE
[09:29:15.075] - globals: [0] <none>
[09:29:15.075] getGlobalsAndPackages() ... DONE
[09:29:15.075]    + additional globals found: [n=0] 
[09:29:15.075]    + additional namespaces needed: [n=0] 
[09:29:15.075]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:15.075]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:15.075]  - seeds: <none>
[09:29:15.075]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.075] getGlobalsAndPackages() ...
[09:29:15.075] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.075] Resolving globals: FALSE
[09:29:15.076] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:15.076] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.076] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.077] 
[09:29:15.077] getGlobalsAndPackages() ... DONE
[09:29:15.077] run() for ‘Future’ ...
[09:29:15.077] - state: ‘created’
[09:29:15.077] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.081] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.081] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.081]   - Field: ‘label’
[09:29:15.081]   - Field: ‘local’
[09:29:15.081]   - Field: ‘owner’
[09:29:15.081]   - Field: ‘envir’
[09:29:15.081]   - Field: ‘workers’
[09:29:15.081]   - Field: ‘packages’
[09:29:15.081]   - Field: ‘gc’
[09:29:15.082]   - Field: ‘job’
[09:29:15.082]   - Field: ‘conditions’
[09:29:15.082]   - Field: ‘expr’
[09:29:15.082]   - Field: ‘uuid’
[09:29:15.082]   - Field: ‘seed’
[09:29:15.082]   - Field: ‘version’
[09:29:15.082]   - Field: ‘result’
[09:29:15.082]   - Field: ‘asynchronous’
[09:29:15.082]   - Field: ‘calls’
[09:29:15.082]   - Field: ‘globals’
[09:29:15.082]   - Field: ‘stdout’
[09:29:15.082]   - Field: ‘earlySignal’
[09:29:15.083]   - Field: ‘lazy’
[09:29:15.083]   - Field: ‘state’
[09:29:15.083] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.083] - Launch lazy future ...
[09:29:15.084] Packages needed by the future expression (n = 0): <none>
[09:29:15.084] Packages needed by future strategies (n = 0): <none>
[09:29:15.084] {
[09:29:15.084]     {
[09:29:15.084]         {
[09:29:15.084]             ...future.startTime <- base::Sys.time()
[09:29:15.084]             {
[09:29:15.084]                 {
[09:29:15.084]                   {
[09:29:15.084]                     {
[09:29:15.084]                       base::local({
[09:29:15.084]                         has_future <- base::requireNamespace("future", 
[09:29:15.084]                           quietly = TRUE)
[09:29:15.084]                         if (has_future) {
[09:29:15.084]                           ns <- base::getNamespace("future")
[09:29:15.084]                           version <- ns[[".package"]][["version"]]
[09:29:15.084]                           if (is.null(version)) 
[09:29:15.084]                             version <- utils::packageVersion("future")
[09:29:15.084]                         }
[09:29:15.084]                         else {
[09:29:15.084]                           version <- NULL
[09:29:15.084]                         }
[09:29:15.084]                         if (!has_future || version < "1.8.0") {
[09:29:15.084]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.084]                             "", base::R.version$version.string), 
[09:29:15.084]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.084]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.084]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.084]                               "release", "version")], collapse = " "), 
[09:29:15.084]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.084]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.084]                             info)
[09:29:15.084]                           info <- base::paste(info, collapse = "; ")
[09:29:15.084]                           if (!has_future) {
[09:29:15.084]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.084]                               info)
[09:29:15.084]                           }
[09:29:15.084]                           else {
[09:29:15.084]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.084]                               info, version)
[09:29:15.084]                           }
[09:29:15.084]                           base::stop(msg)
[09:29:15.084]                         }
[09:29:15.084]                       })
[09:29:15.084]                     }
[09:29:15.084]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.084]                     base::options(mc.cores = 1L)
[09:29:15.084]                   }
[09:29:15.084]                   ...future.strategy.old <- future::plan("list")
[09:29:15.084]                   options(future.plan = NULL)
[09:29:15.084]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.084]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.084]                 }
[09:29:15.084]                 ...future.workdir <- getwd()
[09:29:15.084]             }
[09:29:15.084]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.084]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.084]         }
[09:29:15.084]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.084]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:15.084]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.084]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.084]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.084]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.084]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.084]             base::names(...future.oldOptions))
[09:29:15.084]     }
[09:29:15.084]     if (FALSE) {
[09:29:15.084]     }
[09:29:15.084]     else {
[09:29:15.084]         if (TRUE) {
[09:29:15.084]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.084]                 open = "w")
[09:29:15.084]         }
[09:29:15.084]         else {
[09:29:15.084]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.084]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.084]         }
[09:29:15.084]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.084]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.084]             base::sink(type = "output", split = FALSE)
[09:29:15.084]             base::close(...future.stdout)
[09:29:15.084]         }, add = TRUE)
[09:29:15.084]     }
[09:29:15.084]     ...future.frame <- base::sys.nframe()
[09:29:15.084]     ...future.conditions <- base::list()
[09:29:15.084]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.084]     if (FALSE) {
[09:29:15.084]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.084]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.084]     }
[09:29:15.084]     ...future.result <- base::tryCatch({
[09:29:15.084]         base::withCallingHandlers({
[09:29:15.084]             ...future.value <- base::withVisible(base::local({
[09:29:15.084]                 withCallingHandlers({
[09:29:15.084]                   {
[09:29:15.084]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.084]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.084]                       ...future.globals.maxSize)) {
[09:29:15.084]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.084]                       on.exit(options(oopts), add = TRUE)
[09:29:15.084]                     }
[09:29:15.084]                     {
[09:29:15.084]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.084]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.084]                         USE.NAMES = FALSE)
[09:29:15.084]                       do.call(mapply, args = args)
[09:29:15.084]                     }
[09:29:15.084]                   }
[09:29:15.084]                 }, immediateCondition = function(cond) {
[09:29:15.084]                   save_rds <- function (object, pathname, ...) 
[09:29:15.084]                   {
[09:29:15.084]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.084]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.084]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.084]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.084]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.084]                         fi_tmp[["mtime"]])
[09:29:15.084]                     }
[09:29:15.084]                     tryCatch({
[09:29:15.084]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.084]                     }, error = function(ex) {
[09:29:15.084]                       msg <- conditionMessage(ex)
[09:29:15.084]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.084]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.084]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.084]                         fi_tmp[["mtime"]], msg)
[09:29:15.084]                       ex$message <- msg
[09:29:15.084]                       stop(ex)
[09:29:15.084]                     })
[09:29:15.084]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.084]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.084]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.084]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.084]                       fi <- file.info(pathname)
[09:29:15.084]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.084]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.084]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.084]                         fi[["size"]], fi[["mtime"]])
[09:29:15.084]                       stop(msg)
[09:29:15.084]                     }
[09:29:15.084]                     invisible(pathname)
[09:29:15.084]                   }
[09:29:15.084]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.084]                     rootPath = tempdir()) 
[09:29:15.084]                   {
[09:29:15.084]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.084]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.084]                       tmpdir = path, fileext = ".rds")
[09:29:15.084]                     save_rds(obj, file)
[09:29:15.084]                   }
[09:29:15.084]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.084]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.084]                   {
[09:29:15.084]                     inherits <- base::inherits
[09:29:15.084]                     invokeRestart <- base::invokeRestart
[09:29:15.084]                     is.null <- base::is.null
[09:29:15.084]                     muffled <- FALSE
[09:29:15.084]                     if (inherits(cond, "message")) {
[09:29:15.084]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.084]                       if (muffled) 
[09:29:15.084]                         invokeRestart("muffleMessage")
[09:29:15.084]                     }
[09:29:15.084]                     else if (inherits(cond, "warning")) {
[09:29:15.084]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.084]                       if (muffled) 
[09:29:15.084]                         invokeRestart("muffleWarning")
[09:29:15.084]                     }
[09:29:15.084]                     else if (inherits(cond, "condition")) {
[09:29:15.084]                       if (!is.null(pattern)) {
[09:29:15.084]                         computeRestarts <- base::computeRestarts
[09:29:15.084]                         grepl <- base::grepl
[09:29:15.084]                         restarts <- computeRestarts(cond)
[09:29:15.084]                         for (restart in restarts) {
[09:29:15.084]                           name <- restart$name
[09:29:15.084]                           if (is.null(name)) 
[09:29:15.084]                             next
[09:29:15.084]                           if (!grepl(pattern, name)) 
[09:29:15.084]                             next
[09:29:15.084]                           invokeRestart(restart)
[09:29:15.084]                           muffled <- TRUE
[09:29:15.084]                           break
[09:29:15.084]                         }
[09:29:15.084]                       }
[09:29:15.084]                     }
[09:29:15.084]                     invisible(muffled)
[09:29:15.084]                   }
[09:29:15.084]                   muffleCondition(cond)
[09:29:15.084]                 })
[09:29:15.084]             }))
[09:29:15.084]             future::FutureResult(value = ...future.value$value, 
[09:29:15.084]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.084]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.084]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.084]                     ...future.globalenv.names))
[09:29:15.084]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.084]         }, condition = base::local({
[09:29:15.084]             c <- base::c
[09:29:15.084]             inherits <- base::inherits
[09:29:15.084]             invokeRestart <- base::invokeRestart
[09:29:15.084]             length <- base::length
[09:29:15.084]             list <- base::list
[09:29:15.084]             seq.int <- base::seq.int
[09:29:15.084]             signalCondition <- base::signalCondition
[09:29:15.084]             sys.calls <- base::sys.calls
[09:29:15.084]             `[[` <- base::`[[`
[09:29:15.084]             `+` <- base::`+`
[09:29:15.084]             `<<-` <- base::`<<-`
[09:29:15.084]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.084]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.084]                   3L)]
[09:29:15.084]             }
[09:29:15.084]             function(cond) {
[09:29:15.084]                 is_error <- inherits(cond, "error")
[09:29:15.084]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.084]                   NULL)
[09:29:15.084]                 if (is_error) {
[09:29:15.084]                   sessionInformation <- function() {
[09:29:15.084]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.084]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.084]                       search = base::search(), system = base::Sys.info())
[09:29:15.084]                   }
[09:29:15.084]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.084]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.084]                     cond$call), session = sessionInformation(), 
[09:29:15.084]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.084]                   signalCondition(cond)
[09:29:15.084]                 }
[09:29:15.084]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.084]                 "immediateCondition"))) {
[09:29:15.084]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.084]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.084]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.084]                   if (TRUE && !signal) {
[09:29:15.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.084]                     {
[09:29:15.084]                       inherits <- base::inherits
[09:29:15.084]                       invokeRestart <- base::invokeRestart
[09:29:15.084]                       is.null <- base::is.null
[09:29:15.084]                       muffled <- FALSE
[09:29:15.084]                       if (inherits(cond, "message")) {
[09:29:15.084]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.084]                         if (muffled) 
[09:29:15.084]                           invokeRestart("muffleMessage")
[09:29:15.084]                       }
[09:29:15.084]                       else if (inherits(cond, "warning")) {
[09:29:15.084]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.084]                         if (muffled) 
[09:29:15.084]                           invokeRestart("muffleWarning")
[09:29:15.084]                       }
[09:29:15.084]                       else if (inherits(cond, "condition")) {
[09:29:15.084]                         if (!is.null(pattern)) {
[09:29:15.084]                           computeRestarts <- base::computeRestarts
[09:29:15.084]                           grepl <- base::grepl
[09:29:15.084]                           restarts <- computeRestarts(cond)
[09:29:15.084]                           for (restart in restarts) {
[09:29:15.084]                             name <- restart$name
[09:29:15.084]                             if (is.null(name)) 
[09:29:15.084]                               next
[09:29:15.084]                             if (!grepl(pattern, name)) 
[09:29:15.084]                               next
[09:29:15.084]                             invokeRestart(restart)
[09:29:15.084]                             muffled <- TRUE
[09:29:15.084]                             break
[09:29:15.084]                           }
[09:29:15.084]                         }
[09:29:15.084]                       }
[09:29:15.084]                       invisible(muffled)
[09:29:15.084]                     }
[09:29:15.084]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.084]                   }
[09:29:15.084]                 }
[09:29:15.084]                 else {
[09:29:15.084]                   if (TRUE) {
[09:29:15.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.084]                     {
[09:29:15.084]                       inherits <- base::inherits
[09:29:15.084]                       invokeRestart <- base::invokeRestart
[09:29:15.084]                       is.null <- base::is.null
[09:29:15.084]                       muffled <- FALSE
[09:29:15.084]                       if (inherits(cond, "message")) {
[09:29:15.084]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.084]                         if (muffled) 
[09:29:15.084]                           invokeRestart("muffleMessage")
[09:29:15.084]                       }
[09:29:15.084]                       else if (inherits(cond, "warning")) {
[09:29:15.084]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.084]                         if (muffled) 
[09:29:15.084]                           invokeRestart("muffleWarning")
[09:29:15.084]                       }
[09:29:15.084]                       else if (inherits(cond, "condition")) {
[09:29:15.084]                         if (!is.null(pattern)) {
[09:29:15.084]                           computeRestarts <- base::computeRestarts
[09:29:15.084]                           grepl <- base::grepl
[09:29:15.084]                           restarts <- computeRestarts(cond)
[09:29:15.084]                           for (restart in restarts) {
[09:29:15.084]                             name <- restart$name
[09:29:15.084]                             if (is.null(name)) 
[09:29:15.084]                               next
[09:29:15.084]                             if (!grepl(pattern, name)) 
[09:29:15.084]                               next
[09:29:15.084]                             invokeRestart(restart)
[09:29:15.084]                             muffled <- TRUE
[09:29:15.084]                             break
[09:29:15.084]                           }
[09:29:15.084]                         }
[09:29:15.084]                       }
[09:29:15.084]                       invisible(muffled)
[09:29:15.084]                     }
[09:29:15.084]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.084]                   }
[09:29:15.084]                 }
[09:29:15.084]             }
[09:29:15.084]         }))
[09:29:15.084]     }, error = function(ex) {
[09:29:15.084]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.084]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.084]                 ...future.rng), started = ...future.startTime, 
[09:29:15.084]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.084]             version = "1.8"), class = "FutureResult")
[09:29:15.084]     }, finally = {
[09:29:15.084]         if (!identical(...future.workdir, getwd())) 
[09:29:15.084]             setwd(...future.workdir)
[09:29:15.084]         {
[09:29:15.084]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.084]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.084]             }
[09:29:15.084]             base::options(...future.oldOptions)
[09:29:15.084]             if (.Platform$OS.type == "windows") {
[09:29:15.084]                 old_names <- names(...future.oldEnvVars)
[09:29:15.084]                 envs <- base::Sys.getenv()
[09:29:15.084]                 names <- names(envs)
[09:29:15.084]                 common <- intersect(names, old_names)
[09:29:15.084]                 added <- setdiff(names, old_names)
[09:29:15.084]                 removed <- setdiff(old_names, names)
[09:29:15.084]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.084]                   envs[common]]
[09:29:15.084]                 NAMES <- toupper(changed)
[09:29:15.084]                 args <- list()
[09:29:15.084]                 for (kk in seq_along(NAMES)) {
[09:29:15.084]                   name <- changed[[kk]]
[09:29:15.084]                   NAME <- NAMES[[kk]]
[09:29:15.084]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.084]                     next
[09:29:15.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.084]                 }
[09:29:15.084]                 NAMES <- toupper(added)
[09:29:15.084]                 for (kk in seq_along(NAMES)) {
[09:29:15.084]                   name <- added[[kk]]
[09:29:15.084]                   NAME <- NAMES[[kk]]
[09:29:15.084]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.084]                     next
[09:29:15.084]                   args[[name]] <- ""
[09:29:15.084]                 }
[09:29:15.084]                 NAMES <- toupper(removed)
[09:29:15.084]                 for (kk in seq_along(NAMES)) {
[09:29:15.084]                   name <- removed[[kk]]
[09:29:15.084]                   NAME <- NAMES[[kk]]
[09:29:15.084]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.084]                     next
[09:29:15.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.084]                 }
[09:29:15.084]                 if (length(args) > 0) 
[09:29:15.084]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.084]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.084]             }
[09:29:15.084]             else {
[09:29:15.084]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.084]             }
[09:29:15.084]             {
[09:29:15.084]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.084]                   0L) {
[09:29:15.084]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.084]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.084]                   base::options(opts)
[09:29:15.084]                 }
[09:29:15.084]                 {
[09:29:15.084]                   {
[09:29:15.084]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.084]                     NULL
[09:29:15.084]                   }
[09:29:15.084]                   options(future.plan = NULL)
[09:29:15.084]                   if (is.na(NA_character_)) 
[09:29:15.084]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.084]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.084]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.084]                     .init = FALSE)
[09:29:15.084]                 }
[09:29:15.084]             }
[09:29:15.084]         }
[09:29:15.084]     })
[09:29:15.084]     if (TRUE) {
[09:29:15.084]         base::sink(type = "output", split = FALSE)
[09:29:15.084]         if (TRUE) {
[09:29:15.084]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.084]         }
[09:29:15.084]         else {
[09:29:15.084]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.084]         }
[09:29:15.084]         base::close(...future.stdout)
[09:29:15.084]         ...future.stdout <- NULL
[09:29:15.084]     }
[09:29:15.084]     ...future.result$conditions <- ...future.conditions
[09:29:15.084]     ...future.result$finished <- base::Sys.time()
[09:29:15.084]     ...future.result
[09:29:15.084] }
[09:29:15.087] assign_globals() ...
[09:29:15.087] List of 5
[09:29:15.087]  $ ...future.FUN            :function (x, ...)  
[09:29:15.087]  $ MoreArgs                 : NULL
[09:29:15.087]  $ ...future.elements_ii    :List of 2
[09:29:15.087]   ..$ :List of 2
[09:29:15.087]   .. ..$ : int 1
[09:29:15.087]   .. ..$ : int 2
[09:29:15.087]   ..$ :List of 2
[09:29:15.087]   .. ..$ : int 4
[09:29:15.087]   .. ..$ : int 3
[09:29:15.087]  $ ...future.seeds_ii       : NULL
[09:29:15.087]  $ ...future.globals.maxSize: NULL
[09:29:15.087]  - attr(*, "where")=List of 5
[09:29:15.087]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.087]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.087]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.087]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.087]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.087]  - attr(*, "resolved")= logi FALSE
[09:29:15.087]  - attr(*, "total_size")= num 280
[09:29:15.087]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.087]  - attr(*, "already-done")= logi TRUE
[09:29:15.092] - copied ‘...future.FUN’ to environment
[09:29:15.093] - copied ‘MoreArgs’ to environment
[09:29:15.093] - copied ‘...future.elements_ii’ to environment
[09:29:15.093] - copied ‘...future.seeds_ii’ to environment
[09:29:15.093] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.093] assign_globals() ... done
[09:29:15.093] requestCore(): workers = 2
[09:29:15.096] MulticoreFuture started
[09:29:15.097] - Launch lazy future ... done
[09:29:15.097] plan(): Setting new future strategy stack:
[09:29:15.097] run() for ‘MulticoreFuture’ ... done
[09:29:15.097] Created future:
[09:29:15.097] List of future strategies:
[09:29:15.097] 1. sequential:
[09:29:15.097]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.097]    - tweaked: FALSE
[09:29:15.097]    - call: NULL
[09:29:15.098] plan(): nbrOfWorkers() = 1
[09:29:15.101] plan(): Setting new future strategy stack:
[09:29:15.101] List of future strategies:
[09:29:15.101] 1. multicore:
[09:29:15.101]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.101]    - tweaked: FALSE
[09:29:15.101]    - call: plan(strategy)
[09:29:15.111] plan(): nbrOfWorkers() = 2
[09:29:15.098] MulticoreFuture:
[09:29:15.098] Label: ‘future_mapply-1’
[09:29:15.098] Expression:
[09:29:15.098] {
[09:29:15.098]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.098]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.098]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.098]         on.exit(options(oopts), add = TRUE)
[09:29:15.098]     }
[09:29:15.098]     {
[09:29:15.098]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.098]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.098]         do.call(mapply, args = args)
[09:29:15.098]     }
[09:29:15.098] }
[09:29:15.098] Lazy evaluation: FALSE
[09:29:15.098] Asynchronous evaluation: TRUE
[09:29:15.098] Local evaluation: TRUE
[09:29:15.098] Environment: R_GlobalEnv
[09:29:15.098] Capture standard output: TRUE
[09:29:15.098] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.098] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.098] Packages: <none>
[09:29:15.098] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.098] Resolved: FALSE
[09:29:15.098] Value: <not collected>
[09:29:15.098] Conditions captured: <none>
[09:29:15.098] Early signaling: FALSE
[09:29:15.098] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.098] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.112] Chunk #1 of 2 ... DONE
[09:29:15.112] Chunk #2 of 2 ...
[09:29:15.113]  - Finding globals in '...' for chunk #2 ...
[09:29:15.113] getGlobalsAndPackages() ...
[09:29:15.113] Searching for globals...
[09:29:15.116] 
[09:29:15.117] Searching for globals ... DONE
[09:29:15.117] - globals: [0] <none>
[09:29:15.117] getGlobalsAndPackages() ... DONE
[09:29:15.117]    + additional globals found: [n=0] 
[09:29:15.117]    + additional namespaces needed: [n=0] 
[09:29:15.118]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:15.118]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:15.119]  - seeds: <none>
[09:29:15.119]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.119] getGlobalsAndPackages() ...
[09:29:15.119] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.120] Resolving globals: FALSE
[09:29:15.121] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:15.122] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.122] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.122] 
[09:29:15.123] getGlobalsAndPackages() ... DONE
[09:29:15.123] run() for ‘Future’ ...
[09:29:15.123] - state: ‘created’
[09:29:15.124] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.128] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.129]   - Field: ‘label’
[09:29:15.129]   - Field: ‘local’
[09:29:15.129]   - Field: ‘owner’
[09:29:15.129]   - Field: ‘envir’
[09:29:15.129]   - Field: ‘workers’
[09:29:15.129]   - Field: ‘packages’
[09:29:15.129]   - Field: ‘gc’
[09:29:15.130]   - Field: ‘job’
[09:29:15.130]   - Field: ‘conditions’
[09:29:15.130]   - Field: ‘expr’
[09:29:15.130]   - Field: ‘uuid’
[09:29:15.130]   - Field: ‘seed’
[09:29:15.130]   - Field: ‘version’
[09:29:15.130]   - Field: ‘result’
[09:29:15.131]   - Field: ‘asynchronous’
[09:29:15.131]   - Field: ‘calls’
[09:29:15.131]   - Field: ‘globals’
[09:29:15.131]   - Field: ‘stdout’
[09:29:15.131]   - Field: ‘earlySignal’
[09:29:15.131]   - Field: ‘lazy’
[09:29:15.132]   - Field: ‘state’
[09:29:15.132] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.132] - Launch lazy future ...
[09:29:15.132] Packages needed by the future expression (n = 0): <none>
[09:29:15.132] Packages needed by future strategies (n = 0): <none>
[09:29:15.133] {
[09:29:15.133]     {
[09:29:15.133]         {
[09:29:15.133]             ...future.startTime <- base::Sys.time()
[09:29:15.133]             {
[09:29:15.133]                 {
[09:29:15.133]                   {
[09:29:15.133]                     {
[09:29:15.133]                       base::local({
[09:29:15.133]                         has_future <- base::requireNamespace("future", 
[09:29:15.133]                           quietly = TRUE)
[09:29:15.133]                         if (has_future) {
[09:29:15.133]                           ns <- base::getNamespace("future")
[09:29:15.133]                           version <- ns[[".package"]][["version"]]
[09:29:15.133]                           if (is.null(version)) 
[09:29:15.133]                             version <- utils::packageVersion("future")
[09:29:15.133]                         }
[09:29:15.133]                         else {
[09:29:15.133]                           version <- NULL
[09:29:15.133]                         }
[09:29:15.133]                         if (!has_future || version < "1.8.0") {
[09:29:15.133]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.133]                             "", base::R.version$version.string), 
[09:29:15.133]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.133]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.133]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.133]                               "release", "version")], collapse = " "), 
[09:29:15.133]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.133]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.133]                             info)
[09:29:15.133]                           info <- base::paste(info, collapse = "; ")
[09:29:15.133]                           if (!has_future) {
[09:29:15.133]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.133]                               info)
[09:29:15.133]                           }
[09:29:15.133]                           else {
[09:29:15.133]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.133]                               info, version)
[09:29:15.133]                           }
[09:29:15.133]                           base::stop(msg)
[09:29:15.133]                         }
[09:29:15.133]                       })
[09:29:15.133]                     }
[09:29:15.133]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.133]                     base::options(mc.cores = 1L)
[09:29:15.133]                   }
[09:29:15.133]                   ...future.strategy.old <- future::plan("list")
[09:29:15.133]                   options(future.plan = NULL)
[09:29:15.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.133]                 }
[09:29:15.133]                 ...future.workdir <- getwd()
[09:29:15.133]             }
[09:29:15.133]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.133]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.133]         }
[09:29:15.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.133]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:15.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.133]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.133]             base::names(...future.oldOptions))
[09:29:15.133]     }
[09:29:15.133]     if (FALSE) {
[09:29:15.133]     }
[09:29:15.133]     else {
[09:29:15.133]         if (TRUE) {
[09:29:15.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.133]                 open = "w")
[09:29:15.133]         }
[09:29:15.133]         else {
[09:29:15.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.133]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.133]         }
[09:29:15.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.133]             base::sink(type = "output", split = FALSE)
[09:29:15.133]             base::close(...future.stdout)
[09:29:15.133]         }, add = TRUE)
[09:29:15.133]     }
[09:29:15.133]     ...future.frame <- base::sys.nframe()
[09:29:15.133]     ...future.conditions <- base::list()
[09:29:15.133]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.133]     if (FALSE) {
[09:29:15.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.133]     }
[09:29:15.133]     ...future.result <- base::tryCatch({
[09:29:15.133]         base::withCallingHandlers({
[09:29:15.133]             ...future.value <- base::withVisible(base::local({
[09:29:15.133]                 withCallingHandlers({
[09:29:15.133]                   {
[09:29:15.133]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.133]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.133]                       ...future.globals.maxSize)) {
[09:29:15.133]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.133]                       on.exit(options(oopts), add = TRUE)
[09:29:15.133]                     }
[09:29:15.133]                     {
[09:29:15.133]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.133]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.133]                         USE.NAMES = FALSE)
[09:29:15.133]                       do.call(mapply, args = args)
[09:29:15.133]                     }
[09:29:15.133]                   }
[09:29:15.133]                 }, immediateCondition = function(cond) {
[09:29:15.133]                   save_rds <- function (object, pathname, ...) 
[09:29:15.133]                   {
[09:29:15.133]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.133]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.133]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.133]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.133]                         fi_tmp[["mtime"]])
[09:29:15.133]                     }
[09:29:15.133]                     tryCatch({
[09:29:15.133]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.133]                     }, error = function(ex) {
[09:29:15.133]                       msg <- conditionMessage(ex)
[09:29:15.133]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.133]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.133]                         fi_tmp[["mtime"]], msg)
[09:29:15.133]                       ex$message <- msg
[09:29:15.133]                       stop(ex)
[09:29:15.133]                     })
[09:29:15.133]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.133]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.133]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.133]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.133]                       fi <- file.info(pathname)
[09:29:15.133]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.133]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.133]                         fi[["size"]], fi[["mtime"]])
[09:29:15.133]                       stop(msg)
[09:29:15.133]                     }
[09:29:15.133]                     invisible(pathname)
[09:29:15.133]                   }
[09:29:15.133]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.133]                     rootPath = tempdir()) 
[09:29:15.133]                   {
[09:29:15.133]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.133]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.133]                       tmpdir = path, fileext = ".rds")
[09:29:15.133]                     save_rds(obj, file)
[09:29:15.133]                   }
[09:29:15.133]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.133]                   {
[09:29:15.133]                     inherits <- base::inherits
[09:29:15.133]                     invokeRestart <- base::invokeRestart
[09:29:15.133]                     is.null <- base::is.null
[09:29:15.133]                     muffled <- FALSE
[09:29:15.133]                     if (inherits(cond, "message")) {
[09:29:15.133]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.133]                       if (muffled) 
[09:29:15.133]                         invokeRestart("muffleMessage")
[09:29:15.133]                     }
[09:29:15.133]                     else if (inherits(cond, "warning")) {
[09:29:15.133]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.133]                       if (muffled) 
[09:29:15.133]                         invokeRestart("muffleWarning")
[09:29:15.133]                     }
[09:29:15.133]                     else if (inherits(cond, "condition")) {
[09:29:15.133]                       if (!is.null(pattern)) {
[09:29:15.133]                         computeRestarts <- base::computeRestarts
[09:29:15.133]                         grepl <- base::grepl
[09:29:15.133]                         restarts <- computeRestarts(cond)
[09:29:15.133]                         for (restart in restarts) {
[09:29:15.133]                           name <- restart$name
[09:29:15.133]                           if (is.null(name)) 
[09:29:15.133]                             next
[09:29:15.133]                           if (!grepl(pattern, name)) 
[09:29:15.133]                             next
[09:29:15.133]                           invokeRestart(restart)
[09:29:15.133]                           muffled <- TRUE
[09:29:15.133]                           break
[09:29:15.133]                         }
[09:29:15.133]                       }
[09:29:15.133]                     }
[09:29:15.133]                     invisible(muffled)
[09:29:15.133]                   }
[09:29:15.133]                   muffleCondition(cond)
[09:29:15.133]                 })
[09:29:15.133]             }))
[09:29:15.133]             future::FutureResult(value = ...future.value$value, 
[09:29:15.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.133]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.133]                     ...future.globalenv.names))
[09:29:15.133]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.133]         }, condition = base::local({
[09:29:15.133]             c <- base::c
[09:29:15.133]             inherits <- base::inherits
[09:29:15.133]             invokeRestart <- base::invokeRestart
[09:29:15.133]             length <- base::length
[09:29:15.133]             list <- base::list
[09:29:15.133]             seq.int <- base::seq.int
[09:29:15.133]             signalCondition <- base::signalCondition
[09:29:15.133]             sys.calls <- base::sys.calls
[09:29:15.133]             `[[` <- base::`[[`
[09:29:15.133]             `+` <- base::`+`
[09:29:15.133]             `<<-` <- base::`<<-`
[09:29:15.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.133]                   3L)]
[09:29:15.133]             }
[09:29:15.133]             function(cond) {
[09:29:15.133]                 is_error <- inherits(cond, "error")
[09:29:15.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.133]                   NULL)
[09:29:15.133]                 if (is_error) {
[09:29:15.133]                   sessionInformation <- function() {
[09:29:15.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.133]                       search = base::search(), system = base::Sys.info())
[09:29:15.133]                   }
[09:29:15.133]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.133]                     cond$call), session = sessionInformation(), 
[09:29:15.133]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.133]                   signalCondition(cond)
[09:29:15.133]                 }
[09:29:15.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.133]                 "immediateCondition"))) {
[09:29:15.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.133]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.133]                   if (TRUE && !signal) {
[09:29:15.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.133]                     {
[09:29:15.133]                       inherits <- base::inherits
[09:29:15.133]                       invokeRestart <- base::invokeRestart
[09:29:15.133]                       is.null <- base::is.null
[09:29:15.133]                       muffled <- FALSE
[09:29:15.133]                       if (inherits(cond, "message")) {
[09:29:15.133]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.133]                         if (muffled) 
[09:29:15.133]                           invokeRestart("muffleMessage")
[09:29:15.133]                       }
[09:29:15.133]                       else if (inherits(cond, "warning")) {
[09:29:15.133]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.133]                         if (muffled) 
[09:29:15.133]                           invokeRestart("muffleWarning")
[09:29:15.133]                       }
[09:29:15.133]                       else if (inherits(cond, "condition")) {
[09:29:15.133]                         if (!is.null(pattern)) {
[09:29:15.133]                           computeRestarts <- base::computeRestarts
[09:29:15.133]                           grepl <- base::grepl
[09:29:15.133]                           restarts <- computeRestarts(cond)
[09:29:15.133]                           for (restart in restarts) {
[09:29:15.133]                             name <- restart$name
[09:29:15.133]                             if (is.null(name)) 
[09:29:15.133]                               next
[09:29:15.133]                             if (!grepl(pattern, name)) 
[09:29:15.133]                               next
[09:29:15.133]                             invokeRestart(restart)
[09:29:15.133]                             muffled <- TRUE
[09:29:15.133]                             break
[09:29:15.133]                           }
[09:29:15.133]                         }
[09:29:15.133]                       }
[09:29:15.133]                       invisible(muffled)
[09:29:15.133]                     }
[09:29:15.133]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.133]                   }
[09:29:15.133]                 }
[09:29:15.133]                 else {
[09:29:15.133]                   if (TRUE) {
[09:29:15.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.133]                     {
[09:29:15.133]                       inherits <- base::inherits
[09:29:15.133]                       invokeRestart <- base::invokeRestart
[09:29:15.133]                       is.null <- base::is.null
[09:29:15.133]                       muffled <- FALSE
[09:29:15.133]                       if (inherits(cond, "message")) {
[09:29:15.133]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.133]                         if (muffled) 
[09:29:15.133]                           invokeRestart("muffleMessage")
[09:29:15.133]                       }
[09:29:15.133]                       else if (inherits(cond, "warning")) {
[09:29:15.133]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.133]                         if (muffled) 
[09:29:15.133]                           invokeRestart("muffleWarning")
[09:29:15.133]                       }
[09:29:15.133]                       else if (inherits(cond, "condition")) {
[09:29:15.133]                         if (!is.null(pattern)) {
[09:29:15.133]                           computeRestarts <- base::computeRestarts
[09:29:15.133]                           grepl <- base::grepl
[09:29:15.133]                           restarts <- computeRestarts(cond)
[09:29:15.133]                           for (restart in restarts) {
[09:29:15.133]                             name <- restart$name
[09:29:15.133]                             if (is.null(name)) 
[09:29:15.133]                               next
[09:29:15.133]                             if (!grepl(pattern, name)) 
[09:29:15.133]                               next
[09:29:15.133]                             invokeRestart(restart)
[09:29:15.133]                             muffled <- TRUE
[09:29:15.133]                             break
[09:29:15.133]                           }
[09:29:15.133]                         }
[09:29:15.133]                       }
[09:29:15.133]                       invisible(muffled)
[09:29:15.133]                     }
[09:29:15.133]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.133]                   }
[09:29:15.133]                 }
[09:29:15.133]             }
[09:29:15.133]         }))
[09:29:15.133]     }, error = function(ex) {
[09:29:15.133]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.133]                 ...future.rng), started = ...future.startTime, 
[09:29:15.133]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.133]             version = "1.8"), class = "FutureResult")
[09:29:15.133]     }, finally = {
[09:29:15.133]         if (!identical(...future.workdir, getwd())) 
[09:29:15.133]             setwd(...future.workdir)
[09:29:15.133]         {
[09:29:15.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.133]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.133]             }
[09:29:15.133]             base::options(...future.oldOptions)
[09:29:15.133]             if (.Platform$OS.type == "windows") {
[09:29:15.133]                 old_names <- names(...future.oldEnvVars)
[09:29:15.133]                 envs <- base::Sys.getenv()
[09:29:15.133]                 names <- names(envs)
[09:29:15.133]                 common <- intersect(names, old_names)
[09:29:15.133]                 added <- setdiff(names, old_names)
[09:29:15.133]                 removed <- setdiff(old_names, names)
[09:29:15.133]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.133]                   envs[common]]
[09:29:15.133]                 NAMES <- toupper(changed)
[09:29:15.133]                 args <- list()
[09:29:15.133]                 for (kk in seq_along(NAMES)) {
[09:29:15.133]                   name <- changed[[kk]]
[09:29:15.133]                   NAME <- NAMES[[kk]]
[09:29:15.133]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.133]                     next
[09:29:15.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.133]                 }
[09:29:15.133]                 NAMES <- toupper(added)
[09:29:15.133]                 for (kk in seq_along(NAMES)) {
[09:29:15.133]                   name <- added[[kk]]
[09:29:15.133]                   NAME <- NAMES[[kk]]
[09:29:15.133]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.133]                     next
[09:29:15.133]                   args[[name]] <- ""
[09:29:15.133]                 }
[09:29:15.133]                 NAMES <- toupper(removed)
[09:29:15.133]                 for (kk in seq_along(NAMES)) {
[09:29:15.133]                   name <- removed[[kk]]
[09:29:15.133]                   NAME <- NAMES[[kk]]
[09:29:15.133]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.133]                     next
[09:29:15.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.133]                 }
[09:29:15.133]                 if (length(args) > 0) 
[09:29:15.133]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.133]             }
[09:29:15.133]             else {
[09:29:15.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.133]             }
[09:29:15.133]             {
[09:29:15.133]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.133]                   0L) {
[09:29:15.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.133]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.133]                   base::options(opts)
[09:29:15.133]                 }
[09:29:15.133]                 {
[09:29:15.133]                   {
[09:29:15.133]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.133]                     NULL
[09:29:15.133]                   }
[09:29:15.133]                   options(future.plan = NULL)
[09:29:15.133]                   if (is.na(NA_character_)) 
[09:29:15.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.133]                     .init = FALSE)
[09:29:15.133]                 }
[09:29:15.133]             }
[09:29:15.133]         }
[09:29:15.133]     })
[09:29:15.133]     if (TRUE) {
[09:29:15.133]         base::sink(type = "output", split = FALSE)
[09:29:15.133]         if (TRUE) {
[09:29:15.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.133]         }
[09:29:15.133]         else {
[09:29:15.133]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.133]         }
[09:29:15.133]         base::close(...future.stdout)
[09:29:15.133]         ...future.stdout <- NULL
[09:29:15.133]     }
[09:29:15.133]     ...future.result$conditions <- ...future.conditions
[09:29:15.133]     ...future.result$finished <- base::Sys.time()
[09:29:15.133]     ...future.result
[09:29:15.133] }
[09:29:15.136] assign_globals() ...
[09:29:15.136] List of 5
[09:29:15.136]  $ ...future.FUN            :function (x, ...)  
[09:29:15.136]  $ MoreArgs                 : NULL
[09:29:15.136]  $ ...future.elements_ii    :List of 2
[09:29:15.136]   ..$ :List of 2
[09:29:15.136]   .. ..$ : int 3
[09:29:15.136]   .. ..$ : int 4
[09:29:15.136]   ..$ :List of 2
[09:29:15.136]   .. ..$ : int 2
[09:29:15.136]   .. ..$ : int 1
[09:29:15.136]  $ ...future.seeds_ii       : NULL
[09:29:15.136]  $ ...future.globals.maxSize: NULL
[09:29:15.136]  - attr(*, "where")=List of 5
[09:29:15.136]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.136]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.136]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.136]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.136]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.136]  - attr(*, "resolved")= logi FALSE
[09:29:15.136]  - attr(*, "total_size")= num 280
[09:29:15.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.136]  - attr(*, "already-done")= logi TRUE
[09:29:15.142] - copied ‘...future.FUN’ to environment
[09:29:15.143] - copied ‘MoreArgs’ to environment
[09:29:15.143] - copied ‘...future.elements_ii’ to environment
[09:29:15.143] - copied ‘...future.seeds_ii’ to environment
[09:29:15.143] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.143] assign_globals() ... done
[09:29:15.143] requestCore(): workers = 2
[09:29:15.148] MulticoreFuture started
[09:29:15.149] - Launch lazy future ... done
[09:29:15.149] run() for ‘MulticoreFuture’ ... done
[09:29:15.149] Created future:
[09:29:15.149] plan(): Setting new future strategy stack:
[09:29:15.150] List of future strategies:
[09:29:15.150] 1. sequential:
[09:29:15.150]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.150]    - tweaked: FALSE
[09:29:15.150]    - call: NULL
[09:29:15.151] plan(): nbrOfWorkers() = 1
[09:29:15.153] plan(): Setting new future strategy stack:
[09:29:15.153] List of future strategies:
[09:29:15.153] 1. multicore:
[09:29:15.153]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.153]    - tweaked: FALSE
[09:29:15.153]    - call: plan(strategy)
[09:29:15.158] plan(): nbrOfWorkers() = 2
[09:29:15.149] MulticoreFuture:
[09:29:15.149] Label: ‘future_mapply-2’
[09:29:15.149] Expression:
[09:29:15.149] {
[09:29:15.149]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.149]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.149]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.149]         on.exit(options(oopts), add = TRUE)
[09:29:15.149]     }
[09:29:15.149]     {
[09:29:15.149]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.149]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.149]         do.call(mapply, args = args)
[09:29:15.149]     }
[09:29:15.149] }
[09:29:15.149] Lazy evaluation: FALSE
[09:29:15.149] Asynchronous evaluation: TRUE
[09:29:15.149] Local evaluation: TRUE
[09:29:15.149] Environment: R_GlobalEnv
[09:29:15.149] Capture standard output: TRUE
[09:29:15.149] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.149] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.149] Packages: <none>
[09:29:15.149] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.149] Resolved: TRUE
[09:29:15.149] Value: <not collected>
[09:29:15.149] Conditions captured: <none>
[09:29:15.149] Early signaling: FALSE
[09:29:15.149] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.149] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.159] Chunk #2 of 2 ... DONE
[09:29:15.159] Launching 2 futures (chunks) ... DONE
[09:29:15.159] Resolving 2 futures (chunks) ...
[09:29:15.159] resolve() on list ...
[09:29:15.160]  recursive: 0
[09:29:15.160]  length: 2
[09:29:15.160] 
[09:29:15.160] Future #1
[09:29:15.161] result() for MulticoreFuture ...
[09:29:15.163] result() for MulticoreFuture ...
[09:29:15.163] result() for MulticoreFuture ... done
[09:29:15.163] result() for MulticoreFuture ... done
[09:29:15.163] result() for MulticoreFuture ...
[09:29:15.163] result() for MulticoreFuture ... done
[09:29:15.163] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:15.164] - nx: 2
[09:29:15.164] - relay: TRUE
[09:29:15.164] - stdout: TRUE
[09:29:15.164] - signal: TRUE
[09:29:15.164] - resignal: FALSE
[09:29:15.164] - force: TRUE
[09:29:15.164] - relayed: [n=2] FALSE, FALSE
[09:29:15.165] - queued futures: [n=2] FALSE, FALSE
[09:29:15.165]  - until=1
[09:29:15.165]  - relaying element #1
[09:29:15.165] result() for MulticoreFuture ...
[09:29:15.165] result() for MulticoreFuture ... done
[09:29:15.169] result() for MulticoreFuture ...
[09:29:15.169] result() for MulticoreFuture ... done
[09:29:15.170] result() for MulticoreFuture ...
[09:29:15.170] result() for MulticoreFuture ... done
[09:29:15.170] result() for MulticoreFuture ...
[09:29:15.171] result() for MulticoreFuture ... done
[09:29:15.171] - relayed: [n=2] TRUE, FALSE
[09:29:15.171] - queued futures: [n=2] TRUE, FALSE
[09:29:15.171] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:15.172]  length: 1 (resolved future 1)
[09:29:15.172] Future #2
[09:29:15.173] result() for MulticoreFuture ...
[09:29:15.174] result() for MulticoreFuture ...
[09:29:15.174] result() for MulticoreFuture ... done
[09:29:15.174] result() for MulticoreFuture ... done
[09:29:15.174] result() for MulticoreFuture ...
[09:29:15.175] result() for MulticoreFuture ... done
[09:29:15.175] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:15.175] - nx: 2
[09:29:15.175] - relay: TRUE
[09:29:15.176] - stdout: TRUE
[09:29:15.176] - signal: TRUE
[09:29:15.176] - resignal: FALSE
[09:29:15.176] - force: TRUE
[09:29:15.176] - relayed: [n=2] TRUE, FALSE
[09:29:15.177] - queued futures: [n=2] TRUE, FALSE
[09:29:15.177]  - until=2
[09:29:15.177]  - relaying element #2
[09:29:15.177] result() for MulticoreFuture ...
[09:29:15.177] result() for MulticoreFuture ... done
[09:29:15.177] result() for MulticoreFuture ...
[09:29:15.177] result() for MulticoreFuture ... done
[09:29:15.178] result() for MulticoreFuture ...
[09:29:15.178] result() for MulticoreFuture ... done
[09:29:15.178] result() for MulticoreFuture ...
[09:29:15.178] result() for MulticoreFuture ... done
[09:29:15.178] - relayed: [n=2] TRUE, TRUE
[09:29:15.178] - queued futures: [n=2] TRUE, TRUE
[09:29:15.178] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:15.178]  length: 0 (resolved future 2)
[09:29:15.179] Relaying remaining futures
[09:29:15.179] signalConditionsASAP(NULL, pos=0) ...
[09:29:15.179] - nx: 2
[09:29:15.179] - relay: TRUE
[09:29:15.179] - stdout: TRUE
[09:29:15.179] - signal: TRUE
[09:29:15.179] - resignal: FALSE
[09:29:15.179] - force: TRUE
[09:29:15.179] - relayed: [n=2] TRUE, TRUE
[09:29:15.179] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:15.180] - relayed: [n=2] TRUE, TRUE
[09:29:15.180] - queued futures: [n=2] TRUE, TRUE
[09:29:15.180] signalConditionsASAP(NULL, pos=0) ... done
[09:29:15.180] resolve() on list ... DONE
[09:29:15.180] result() for MulticoreFuture ...
[09:29:15.181] result() for MulticoreFuture ... done
[09:29:15.181] result() for MulticoreFuture ...
[09:29:15.181] result() for MulticoreFuture ... done
[09:29:15.181] result() for MulticoreFuture ...
[09:29:15.181] result() for MulticoreFuture ... done
[09:29:15.181] result() for MulticoreFuture ...
[09:29:15.182] result() for MulticoreFuture ... done
[09:29:15.182]  - Number of value chunks collected: 2
[09:29:15.182] Resolving 2 futures (chunks) ... DONE
[09:29:15.182] Reducing values from 2 chunks ...
[09:29:15.182]  - Number of values collected after concatenation: 4
[09:29:15.182]  - Number of values expected: 4
[09:29:15.182] Reducing values from 2 chunks ... DONE
[09:29:15.183] future_mapply() ... DONE
[09:29:15.183] future_mapply() ...
[09:29:15.186] Number of chunks: 2
[09:29:15.187] getGlobalsAndPackagesXApply() ...
[09:29:15.187]  - future.globals: TRUE
[09:29:15.187] getGlobalsAndPackages() ...
[09:29:15.187] Searching for globals...
[09:29:15.188] - globals found: [1] ‘FUN’
[09:29:15.188] Searching for globals ... DONE
[09:29:15.188] Resolving globals: FALSE
[09:29:15.188] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:15.189] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:15.189] - globals: [1] ‘FUN’
[09:29:15.189] 
[09:29:15.189] getGlobalsAndPackages() ... DONE
[09:29:15.189]  - globals found/used: [n=1] ‘FUN’
[09:29:15.189]  - needed namespaces: [n=0] 
[09:29:15.189] Finding globals ... DONE
[09:29:15.189] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:15.190] List of 2
[09:29:15.190]  $ ...future.FUN:function (x, ...)  
[09:29:15.190]  $ MoreArgs     : NULL
[09:29:15.190]  - attr(*, "where")=List of 2
[09:29:15.190]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:15.190]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:15.190]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.190]  - attr(*, "resolved")= logi FALSE
[09:29:15.190]  - attr(*, "total_size")= num NA
[09:29:15.192] Packages to be attached in all futures: [n=0] 
[09:29:15.192] getGlobalsAndPackagesXApply() ... DONE
[09:29:15.193] Number of futures (= number of chunks): 2
[09:29:15.193] Launching 2 futures (chunks) ...
[09:29:15.193] Chunk #1 of 2 ...
[09:29:15.193]  - Finding globals in '...' for chunk #1 ...
[09:29:15.193] getGlobalsAndPackages() ...
[09:29:15.193] Searching for globals...
[09:29:15.193] 
[09:29:15.194] Searching for globals ... DONE
[09:29:15.194] - globals: [0] <none>
[09:29:15.194] getGlobalsAndPackages() ... DONE
[09:29:15.194]    + additional globals found: [n=0] 
[09:29:15.194]    + additional namespaces needed: [n=0] 
[09:29:15.194]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:15.194]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:15.194]  - seeds: <none>
[09:29:15.194]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.194] getGlobalsAndPackages() ...
[09:29:15.195] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.195] Resolving globals: FALSE
[09:29:15.195] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:15.196] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.196] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.196] 
[09:29:15.196] getGlobalsAndPackages() ... DONE
[09:29:15.196] run() for ‘Future’ ...
[09:29:15.196] - state: ‘created’
[09:29:15.197] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.200] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.200] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.200]   - Field: ‘label’
[09:29:15.200]   - Field: ‘local’
[09:29:15.201]   - Field: ‘owner’
[09:29:15.201]   - Field: ‘envir’
[09:29:15.201]   - Field: ‘workers’
[09:29:15.201]   - Field: ‘packages’
[09:29:15.201]   - Field: ‘gc’
[09:29:15.201]   - Field: ‘job’
[09:29:15.201]   - Field: ‘conditions’
[09:29:15.201]   - Field: ‘expr’
[09:29:15.201]   - Field: ‘uuid’
[09:29:15.201]   - Field: ‘seed’
[09:29:15.201]   - Field: ‘version’
[09:29:15.201]   - Field: ‘result’
[09:29:15.202]   - Field: ‘asynchronous’
[09:29:15.202]   - Field: ‘calls’
[09:29:15.202]   - Field: ‘globals’
[09:29:15.202]   - Field: ‘stdout’
[09:29:15.202]   - Field: ‘earlySignal’
[09:29:15.202]   - Field: ‘lazy’
[09:29:15.202]   - Field: ‘state’
[09:29:15.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.202] - Launch lazy future ...
[09:29:15.203] Packages needed by the future expression (n = 0): <none>
[09:29:15.203] Packages needed by future strategies (n = 0): <none>
[09:29:15.205] {
[09:29:15.205]     {
[09:29:15.205]         {
[09:29:15.205]             ...future.startTime <- base::Sys.time()
[09:29:15.205]             {
[09:29:15.205]                 {
[09:29:15.205]                   {
[09:29:15.205]                     {
[09:29:15.205]                       base::local({
[09:29:15.205]                         has_future <- base::requireNamespace("future", 
[09:29:15.205]                           quietly = TRUE)
[09:29:15.205]                         if (has_future) {
[09:29:15.205]                           ns <- base::getNamespace("future")
[09:29:15.205]                           version <- ns[[".package"]][["version"]]
[09:29:15.205]                           if (is.null(version)) 
[09:29:15.205]                             version <- utils::packageVersion("future")
[09:29:15.205]                         }
[09:29:15.205]                         else {
[09:29:15.205]                           version <- NULL
[09:29:15.205]                         }
[09:29:15.205]                         if (!has_future || version < "1.8.0") {
[09:29:15.205]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.205]                             "", base::R.version$version.string), 
[09:29:15.205]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.205]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.205]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.205]                               "release", "version")], collapse = " "), 
[09:29:15.205]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.205]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.205]                             info)
[09:29:15.205]                           info <- base::paste(info, collapse = "; ")
[09:29:15.205]                           if (!has_future) {
[09:29:15.205]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.205]                               info)
[09:29:15.205]                           }
[09:29:15.205]                           else {
[09:29:15.205]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.205]                               info, version)
[09:29:15.205]                           }
[09:29:15.205]                           base::stop(msg)
[09:29:15.205]                         }
[09:29:15.205]                       })
[09:29:15.205]                     }
[09:29:15.205]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.205]                     base::options(mc.cores = 1L)
[09:29:15.205]                   }
[09:29:15.205]                   ...future.strategy.old <- future::plan("list")
[09:29:15.205]                   options(future.plan = NULL)
[09:29:15.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.205]                 }
[09:29:15.205]                 ...future.workdir <- getwd()
[09:29:15.205]             }
[09:29:15.205]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.205]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.205]         }
[09:29:15.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.205]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:15.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.205]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.205]             base::names(...future.oldOptions))
[09:29:15.205]     }
[09:29:15.205]     if (FALSE) {
[09:29:15.205]     }
[09:29:15.205]     else {
[09:29:15.205]         if (TRUE) {
[09:29:15.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.205]                 open = "w")
[09:29:15.205]         }
[09:29:15.205]         else {
[09:29:15.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.205]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.205]         }
[09:29:15.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.205]             base::sink(type = "output", split = FALSE)
[09:29:15.205]             base::close(...future.stdout)
[09:29:15.205]         }, add = TRUE)
[09:29:15.205]     }
[09:29:15.205]     ...future.frame <- base::sys.nframe()
[09:29:15.205]     ...future.conditions <- base::list()
[09:29:15.205]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.205]     if (FALSE) {
[09:29:15.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.205]     }
[09:29:15.205]     ...future.result <- base::tryCatch({
[09:29:15.205]         base::withCallingHandlers({
[09:29:15.205]             ...future.value <- base::withVisible(base::local({
[09:29:15.205]                 withCallingHandlers({
[09:29:15.205]                   {
[09:29:15.205]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.205]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.205]                       ...future.globals.maxSize)) {
[09:29:15.205]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.205]                       on.exit(options(oopts), add = TRUE)
[09:29:15.205]                     }
[09:29:15.205]                     {
[09:29:15.205]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.205]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.205]                         USE.NAMES = FALSE)
[09:29:15.205]                       do.call(mapply, args = args)
[09:29:15.205]                     }
[09:29:15.205]                   }
[09:29:15.205]                 }, immediateCondition = function(cond) {
[09:29:15.205]                   save_rds <- function (object, pathname, ...) 
[09:29:15.205]                   {
[09:29:15.205]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.205]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.205]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.205]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.205]                         fi_tmp[["mtime"]])
[09:29:15.205]                     }
[09:29:15.205]                     tryCatch({
[09:29:15.205]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.205]                     }, error = function(ex) {
[09:29:15.205]                       msg <- conditionMessage(ex)
[09:29:15.205]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.205]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.205]                         fi_tmp[["mtime"]], msg)
[09:29:15.205]                       ex$message <- msg
[09:29:15.205]                       stop(ex)
[09:29:15.205]                     })
[09:29:15.205]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.205]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.205]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.205]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.205]                       fi <- file.info(pathname)
[09:29:15.205]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.205]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.205]                         fi[["size"]], fi[["mtime"]])
[09:29:15.205]                       stop(msg)
[09:29:15.205]                     }
[09:29:15.205]                     invisible(pathname)
[09:29:15.205]                   }
[09:29:15.205]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.205]                     rootPath = tempdir()) 
[09:29:15.205]                   {
[09:29:15.205]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.205]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.205]                       tmpdir = path, fileext = ".rds")
[09:29:15.205]                     save_rds(obj, file)
[09:29:15.205]                   }
[09:29:15.205]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.205]                   {
[09:29:15.205]                     inherits <- base::inherits
[09:29:15.205]                     invokeRestart <- base::invokeRestart
[09:29:15.205]                     is.null <- base::is.null
[09:29:15.205]                     muffled <- FALSE
[09:29:15.205]                     if (inherits(cond, "message")) {
[09:29:15.205]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.205]                       if (muffled) 
[09:29:15.205]                         invokeRestart("muffleMessage")
[09:29:15.205]                     }
[09:29:15.205]                     else if (inherits(cond, "warning")) {
[09:29:15.205]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.205]                       if (muffled) 
[09:29:15.205]                         invokeRestart("muffleWarning")
[09:29:15.205]                     }
[09:29:15.205]                     else if (inherits(cond, "condition")) {
[09:29:15.205]                       if (!is.null(pattern)) {
[09:29:15.205]                         computeRestarts <- base::computeRestarts
[09:29:15.205]                         grepl <- base::grepl
[09:29:15.205]                         restarts <- computeRestarts(cond)
[09:29:15.205]                         for (restart in restarts) {
[09:29:15.205]                           name <- restart$name
[09:29:15.205]                           if (is.null(name)) 
[09:29:15.205]                             next
[09:29:15.205]                           if (!grepl(pattern, name)) 
[09:29:15.205]                             next
[09:29:15.205]                           invokeRestart(restart)
[09:29:15.205]                           muffled <- TRUE
[09:29:15.205]                           break
[09:29:15.205]                         }
[09:29:15.205]                       }
[09:29:15.205]                     }
[09:29:15.205]                     invisible(muffled)
[09:29:15.205]                   }
[09:29:15.205]                   muffleCondition(cond)
[09:29:15.205]                 })
[09:29:15.205]             }))
[09:29:15.205]             future::FutureResult(value = ...future.value$value, 
[09:29:15.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.205]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.205]                     ...future.globalenv.names))
[09:29:15.205]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.205]         }, condition = base::local({
[09:29:15.205]             c <- base::c
[09:29:15.205]             inherits <- base::inherits
[09:29:15.205]             invokeRestart <- base::invokeRestart
[09:29:15.205]             length <- base::length
[09:29:15.205]             list <- base::list
[09:29:15.205]             seq.int <- base::seq.int
[09:29:15.205]             signalCondition <- base::signalCondition
[09:29:15.205]             sys.calls <- base::sys.calls
[09:29:15.205]             `[[` <- base::`[[`
[09:29:15.205]             `+` <- base::`+`
[09:29:15.205]             `<<-` <- base::`<<-`
[09:29:15.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.205]                   3L)]
[09:29:15.205]             }
[09:29:15.205]             function(cond) {
[09:29:15.205]                 is_error <- inherits(cond, "error")
[09:29:15.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.205]                   NULL)
[09:29:15.205]                 if (is_error) {
[09:29:15.205]                   sessionInformation <- function() {
[09:29:15.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.205]                       search = base::search(), system = base::Sys.info())
[09:29:15.205]                   }
[09:29:15.205]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.205]                     cond$call), session = sessionInformation(), 
[09:29:15.205]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.205]                   signalCondition(cond)
[09:29:15.205]                 }
[09:29:15.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.205]                 "immediateCondition"))) {
[09:29:15.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.205]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.205]                   if (TRUE && !signal) {
[09:29:15.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.205]                     {
[09:29:15.205]                       inherits <- base::inherits
[09:29:15.205]                       invokeRestart <- base::invokeRestart
[09:29:15.205]                       is.null <- base::is.null
[09:29:15.205]                       muffled <- FALSE
[09:29:15.205]                       if (inherits(cond, "message")) {
[09:29:15.205]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.205]                         if (muffled) 
[09:29:15.205]                           invokeRestart("muffleMessage")
[09:29:15.205]                       }
[09:29:15.205]                       else if (inherits(cond, "warning")) {
[09:29:15.205]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.205]                         if (muffled) 
[09:29:15.205]                           invokeRestart("muffleWarning")
[09:29:15.205]                       }
[09:29:15.205]                       else if (inherits(cond, "condition")) {
[09:29:15.205]                         if (!is.null(pattern)) {
[09:29:15.205]                           computeRestarts <- base::computeRestarts
[09:29:15.205]                           grepl <- base::grepl
[09:29:15.205]                           restarts <- computeRestarts(cond)
[09:29:15.205]                           for (restart in restarts) {
[09:29:15.205]                             name <- restart$name
[09:29:15.205]                             if (is.null(name)) 
[09:29:15.205]                               next
[09:29:15.205]                             if (!grepl(pattern, name)) 
[09:29:15.205]                               next
[09:29:15.205]                             invokeRestart(restart)
[09:29:15.205]                             muffled <- TRUE
[09:29:15.205]                             break
[09:29:15.205]                           }
[09:29:15.205]                         }
[09:29:15.205]                       }
[09:29:15.205]                       invisible(muffled)
[09:29:15.205]                     }
[09:29:15.205]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.205]                   }
[09:29:15.205]                 }
[09:29:15.205]                 else {
[09:29:15.205]                   if (TRUE) {
[09:29:15.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.205]                     {
[09:29:15.205]                       inherits <- base::inherits
[09:29:15.205]                       invokeRestart <- base::invokeRestart
[09:29:15.205]                       is.null <- base::is.null
[09:29:15.205]                       muffled <- FALSE
[09:29:15.205]                       if (inherits(cond, "message")) {
[09:29:15.205]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.205]                         if (muffled) 
[09:29:15.205]                           invokeRestart("muffleMessage")
[09:29:15.205]                       }
[09:29:15.205]                       else if (inherits(cond, "warning")) {
[09:29:15.205]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.205]                         if (muffled) 
[09:29:15.205]                           invokeRestart("muffleWarning")
[09:29:15.205]                       }
[09:29:15.205]                       else if (inherits(cond, "condition")) {
[09:29:15.205]                         if (!is.null(pattern)) {
[09:29:15.205]                           computeRestarts <- base::computeRestarts
[09:29:15.205]                           grepl <- base::grepl
[09:29:15.205]                           restarts <- computeRestarts(cond)
[09:29:15.205]                           for (restart in restarts) {
[09:29:15.205]                             name <- restart$name
[09:29:15.205]                             if (is.null(name)) 
[09:29:15.205]                               next
[09:29:15.205]                             if (!grepl(pattern, name)) 
[09:29:15.205]                               next
[09:29:15.205]                             invokeRestart(restart)
[09:29:15.205]                             muffled <- TRUE
[09:29:15.205]                             break
[09:29:15.205]                           }
[09:29:15.205]                         }
[09:29:15.205]                       }
[09:29:15.205]                       invisible(muffled)
[09:29:15.205]                     }
[09:29:15.205]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.205]                   }
[09:29:15.205]                 }
[09:29:15.205]             }
[09:29:15.205]         }))
[09:29:15.205]     }, error = function(ex) {
[09:29:15.205]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.205]                 ...future.rng), started = ...future.startTime, 
[09:29:15.205]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.205]             version = "1.8"), class = "FutureResult")
[09:29:15.205]     }, finally = {
[09:29:15.205]         if (!identical(...future.workdir, getwd())) 
[09:29:15.205]             setwd(...future.workdir)
[09:29:15.205]         {
[09:29:15.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.205]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.205]             }
[09:29:15.205]             base::options(...future.oldOptions)
[09:29:15.205]             if (.Platform$OS.type == "windows") {
[09:29:15.205]                 old_names <- names(...future.oldEnvVars)
[09:29:15.205]                 envs <- base::Sys.getenv()
[09:29:15.205]                 names <- names(envs)
[09:29:15.205]                 common <- intersect(names, old_names)
[09:29:15.205]                 added <- setdiff(names, old_names)
[09:29:15.205]                 removed <- setdiff(old_names, names)
[09:29:15.205]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.205]                   envs[common]]
[09:29:15.205]                 NAMES <- toupper(changed)
[09:29:15.205]                 args <- list()
[09:29:15.205]                 for (kk in seq_along(NAMES)) {
[09:29:15.205]                   name <- changed[[kk]]
[09:29:15.205]                   NAME <- NAMES[[kk]]
[09:29:15.205]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.205]                     next
[09:29:15.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.205]                 }
[09:29:15.205]                 NAMES <- toupper(added)
[09:29:15.205]                 for (kk in seq_along(NAMES)) {
[09:29:15.205]                   name <- added[[kk]]
[09:29:15.205]                   NAME <- NAMES[[kk]]
[09:29:15.205]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.205]                     next
[09:29:15.205]                   args[[name]] <- ""
[09:29:15.205]                 }
[09:29:15.205]                 NAMES <- toupper(removed)
[09:29:15.205]                 for (kk in seq_along(NAMES)) {
[09:29:15.205]                   name <- removed[[kk]]
[09:29:15.205]                   NAME <- NAMES[[kk]]
[09:29:15.205]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.205]                     next
[09:29:15.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.205]                 }
[09:29:15.205]                 if (length(args) > 0) 
[09:29:15.205]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.205]             }
[09:29:15.205]             else {
[09:29:15.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.205]             }
[09:29:15.205]             {
[09:29:15.205]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.205]                   0L) {
[09:29:15.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.205]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.205]                   base::options(opts)
[09:29:15.205]                 }
[09:29:15.205]                 {
[09:29:15.205]                   {
[09:29:15.205]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.205]                     NULL
[09:29:15.205]                   }
[09:29:15.205]                   options(future.plan = NULL)
[09:29:15.205]                   if (is.na(NA_character_)) 
[09:29:15.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.205]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.205]                     .init = FALSE)
[09:29:15.205]                 }
[09:29:15.205]             }
[09:29:15.205]         }
[09:29:15.205]     })
[09:29:15.205]     if (TRUE) {
[09:29:15.205]         base::sink(type = "output", split = FALSE)
[09:29:15.205]         if (TRUE) {
[09:29:15.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.205]         }
[09:29:15.205]         else {
[09:29:15.205]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.205]         }
[09:29:15.205]         base::close(...future.stdout)
[09:29:15.205]         ...future.stdout <- NULL
[09:29:15.205]     }
[09:29:15.205]     ...future.result$conditions <- ...future.conditions
[09:29:15.205]     ...future.result$finished <- base::Sys.time()
[09:29:15.205]     ...future.result
[09:29:15.205] }
[09:29:15.207] assign_globals() ...
[09:29:15.207] List of 5
[09:29:15.207]  $ ...future.FUN            :function (x, ...)  
[09:29:15.207]  $ MoreArgs                 : NULL
[09:29:15.207]  $ ...future.elements_ii    :List of 2
[09:29:15.207]   ..$ :List of 2
[09:29:15.207]   .. ..$ : int 1
[09:29:15.207]   .. ..$ : int 2
[09:29:15.207]   ..$ :List of 2
[09:29:15.207]   .. ..$ : int 4
[09:29:15.207]   .. ..$ : int 3
[09:29:15.207]  $ ...future.seeds_ii       : NULL
[09:29:15.207]  $ ...future.globals.maxSize: NULL
[09:29:15.207]  - attr(*, "where")=List of 5
[09:29:15.207]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.207]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.207]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.207]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.207]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.207]  - attr(*, "resolved")= logi FALSE
[09:29:15.207]  - attr(*, "total_size")= num 280
[09:29:15.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.207]  - attr(*, "already-done")= logi TRUE
[09:29:15.213] - copied ‘...future.FUN’ to environment
[09:29:15.213] - copied ‘MoreArgs’ to environment
[09:29:15.213] - copied ‘...future.elements_ii’ to environment
[09:29:15.213] - copied ‘...future.seeds_ii’ to environment
[09:29:15.213] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.213] assign_globals() ... done
[09:29:15.214] requestCore(): workers = 2
[09:29:15.215] MulticoreFuture started
[09:29:15.216] - Launch lazy future ... done
[09:29:15.216] run() for ‘MulticoreFuture’ ... done
[09:29:15.216] Created future:
[09:29:15.216] plan(): Setting new future strategy stack:
[09:29:15.217] List of future strategies:
[09:29:15.217] 1. sequential:
[09:29:15.217]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.217]    - tweaked: FALSE
[09:29:15.217]    - call: NULL
[09:29:15.218] plan(): nbrOfWorkers() = 1
[09:29:15.220] plan(): Setting new future strategy stack:
[09:29:15.220] List of future strategies:
[09:29:15.220] 1. multicore:
[09:29:15.220]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.220]    - tweaked: FALSE
[09:29:15.220]    - call: plan(strategy)
[09:29:15.225] plan(): nbrOfWorkers() = 2
[09:29:15.217] MulticoreFuture:
[09:29:15.217] Label: ‘future_mapply-1’
[09:29:15.217] Expression:
[09:29:15.217] {
[09:29:15.217]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.217]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.217]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.217]         on.exit(options(oopts), add = TRUE)
[09:29:15.217]     }
[09:29:15.217]     {
[09:29:15.217]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.217]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.217]         do.call(mapply, args = args)
[09:29:15.217]     }
[09:29:15.217] }
[09:29:15.217] Lazy evaluation: FALSE
[09:29:15.217] Asynchronous evaluation: TRUE
[09:29:15.217] Local evaluation: TRUE
[09:29:15.217] Environment: R_GlobalEnv
[09:29:15.217] Capture standard output: TRUE
[09:29:15.217] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.217] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.217] Packages: <none>
[09:29:15.217] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.217] Resolved: TRUE
[09:29:15.217] Value: <not collected>
[09:29:15.217] Conditions captured: <none>
[09:29:15.217] Early signaling: FALSE
[09:29:15.217] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.217] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.226] Chunk #1 of 2 ... DONE
[09:29:15.226] Chunk #2 of 2 ...
[09:29:15.226]  - Finding globals in '...' for chunk #2 ...
[09:29:15.227] getGlobalsAndPackages() ...
[09:29:15.227] Searching for globals...
[09:29:15.227] 
[09:29:15.227] Searching for globals ... DONE
[09:29:15.228] - globals: [0] <none>
[09:29:15.228] getGlobalsAndPackages() ... DONE
[09:29:15.228]    + additional globals found: [n=0] 
[09:29:15.228]    + additional namespaces needed: [n=0] 
[09:29:15.228]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:15.228]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:15.228]  - seeds: <none>
[09:29:15.229]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.229] getGlobalsAndPackages() ...
[09:29:15.229] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.229] Resolving globals: FALSE
[09:29:15.230] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:15.231] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.231] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.231] 
[09:29:15.231] getGlobalsAndPackages() ... DONE
[09:29:15.232] run() for ‘Future’ ...
[09:29:15.232] - state: ‘created’
[09:29:15.232] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.237] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.237] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.237]   - Field: ‘label’
[09:29:15.237]   - Field: ‘local’
[09:29:15.237]   - Field: ‘owner’
[09:29:15.237]   - Field: ‘envir’
[09:29:15.237]   - Field: ‘workers’
[09:29:15.238]   - Field: ‘packages’
[09:29:15.238]   - Field: ‘gc’
[09:29:15.238]   - Field: ‘job’
[09:29:15.238]   - Field: ‘conditions’
[09:29:15.238]   - Field: ‘expr’
[09:29:15.238]   - Field: ‘uuid’
[09:29:15.238]   - Field: ‘seed’
[09:29:15.239]   - Field: ‘version’
[09:29:15.239]   - Field: ‘result’
[09:29:15.239]   - Field: ‘asynchronous’
[09:29:15.239]   - Field: ‘calls’
[09:29:15.239]   - Field: ‘globals’
[09:29:15.239]   - Field: ‘stdout’
[09:29:15.239]   - Field: ‘earlySignal’
[09:29:15.240]   - Field: ‘lazy’
[09:29:15.240]   - Field: ‘state’
[09:29:15.240] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.240] - Launch lazy future ...
[09:29:15.240] Packages needed by the future expression (n = 0): <none>
[09:29:15.241] Packages needed by future strategies (n = 0): <none>
[09:29:15.241] {
[09:29:15.241]     {
[09:29:15.241]         {
[09:29:15.241]             ...future.startTime <- base::Sys.time()
[09:29:15.241]             {
[09:29:15.241]                 {
[09:29:15.241]                   {
[09:29:15.241]                     {
[09:29:15.241]                       base::local({
[09:29:15.241]                         has_future <- base::requireNamespace("future", 
[09:29:15.241]                           quietly = TRUE)
[09:29:15.241]                         if (has_future) {
[09:29:15.241]                           ns <- base::getNamespace("future")
[09:29:15.241]                           version <- ns[[".package"]][["version"]]
[09:29:15.241]                           if (is.null(version)) 
[09:29:15.241]                             version <- utils::packageVersion("future")
[09:29:15.241]                         }
[09:29:15.241]                         else {
[09:29:15.241]                           version <- NULL
[09:29:15.241]                         }
[09:29:15.241]                         if (!has_future || version < "1.8.0") {
[09:29:15.241]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.241]                             "", base::R.version$version.string), 
[09:29:15.241]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.241]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.241]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.241]                               "release", "version")], collapse = " "), 
[09:29:15.241]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.241]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.241]                             info)
[09:29:15.241]                           info <- base::paste(info, collapse = "; ")
[09:29:15.241]                           if (!has_future) {
[09:29:15.241]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.241]                               info)
[09:29:15.241]                           }
[09:29:15.241]                           else {
[09:29:15.241]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.241]                               info, version)
[09:29:15.241]                           }
[09:29:15.241]                           base::stop(msg)
[09:29:15.241]                         }
[09:29:15.241]                       })
[09:29:15.241]                     }
[09:29:15.241]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.241]                     base::options(mc.cores = 1L)
[09:29:15.241]                   }
[09:29:15.241]                   ...future.strategy.old <- future::plan("list")
[09:29:15.241]                   options(future.plan = NULL)
[09:29:15.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.241]                 }
[09:29:15.241]                 ...future.workdir <- getwd()
[09:29:15.241]             }
[09:29:15.241]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.241]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.241]         }
[09:29:15.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.241]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:15.241]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.241]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.241]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.241]             base::names(...future.oldOptions))
[09:29:15.241]     }
[09:29:15.241]     if (FALSE) {
[09:29:15.241]     }
[09:29:15.241]     else {
[09:29:15.241]         if (TRUE) {
[09:29:15.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.241]                 open = "w")
[09:29:15.241]         }
[09:29:15.241]         else {
[09:29:15.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.241]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.241]         }
[09:29:15.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.241]             base::sink(type = "output", split = FALSE)
[09:29:15.241]             base::close(...future.stdout)
[09:29:15.241]         }, add = TRUE)
[09:29:15.241]     }
[09:29:15.241]     ...future.frame <- base::sys.nframe()
[09:29:15.241]     ...future.conditions <- base::list()
[09:29:15.241]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.241]     if (FALSE) {
[09:29:15.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.241]     }
[09:29:15.241]     ...future.result <- base::tryCatch({
[09:29:15.241]         base::withCallingHandlers({
[09:29:15.241]             ...future.value <- base::withVisible(base::local({
[09:29:15.241]                 withCallingHandlers({
[09:29:15.241]                   {
[09:29:15.241]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.241]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.241]                       ...future.globals.maxSize)) {
[09:29:15.241]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.241]                       on.exit(options(oopts), add = TRUE)
[09:29:15.241]                     }
[09:29:15.241]                     {
[09:29:15.241]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.241]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.241]                         USE.NAMES = FALSE)
[09:29:15.241]                       do.call(mapply, args = args)
[09:29:15.241]                     }
[09:29:15.241]                   }
[09:29:15.241]                 }, immediateCondition = function(cond) {
[09:29:15.241]                   save_rds <- function (object, pathname, ...) 
[09:29:15.241]                   {
[09:29:15.241]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.241]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.241]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.241]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.241]                         fi_tmp[["mtime"]])
[09:29:15.241]                     }
[09:29:15.241]                     tryCatch({
[09:29:15.241]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.241]                     }, error = function(ex) {
[09:29:15.241]                       msg <- conditionMessage(ex)
[09:29:15.241]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.241]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.241]                         fi_tmp[["mtime"]], msg)
[09:29:15.241]                       ex$message <- msg
[09:29:15.241]                       stop(ex)
[09:29:15.241]                     })
[09:29:15.241]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.241]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.241]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.241]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.241]                       fi <- file.info(pathname)
[09:29:15.241]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.241]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.241]                         fi[["size"]], fi[["mtime"]])
[09:29:15.241]                       stop(msg)
[09:29:15.241]                     }
[09:29:15.241]                     invisible(pathname)
[09:29:15.241]                   }
[09:29:15.241]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.241]                     rootPath = tempdir()) 
[09:29:15.241]                   {
[09:29:15.241]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.241]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.241]                       tmpdir = path, fileext = ".rds")
[09:29:15.241]                     save_rds(obj, file)
[09:29:15.241]                   }
[09:29:15.241]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.241]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.241]                   {
[09:29:15.241]                     inherits <- base::inherits
[09:29:15.241]                     invokeRestart <- base::invokeRestart
[09:29:15.241]                     is.null <- base::is.null
[09:29:15.241]                     muffled <- FALSE
[09:29:15.241]                     if (inherits(cond, "message")) {
[09:29:15.241]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.241]                       if (muffled) 
[09:29:15.241]                         invokeRestart("muffleMessage")
[09:29:15.241]                     }
[09:29:15.241]                     else if (inherits(cond, "warning")) {
[09:29:15.241]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.241]                       if (muffled) 
[09:29:15.241]                         invokeRestart("muffleWarning")
[09:29:15.241]                     }
[09:29:15.241]                     else if (inherits(cond, "condition")) {
[09:29:15.241]                       if (!is.null(pattern)) {
[09:29:15.241]                         computeRestarts <- base::computeRestarts
[09:29:15.241]                         grepl <- base::grepl
[09:29:15.241]                         restarts <- computeRestarts(cond)
[09:29:15.241]                         for (restart in restarts) {
[09:29:15.241]                           name <- restart$name
[09:29:15.241]                           if (is.null(name)) 
[09:29:15.241]                             next
[09:29:15.241]                           if (!grepl(pattern, name)) 
[09:29:15.241]                             next
[09:29:15.241]                           invokeRestart(restart)
[09:29:15.241]                           muffled <- TRUE
[09:29:15.241]                           break
[09:29:15.241]                         }
[09:29:15.241]                       }
[09:29:15.241]                     }
[09:29:15.241]                     invisible(muffled)
[09:29:15.241]                   }
[09:29:15.241]                   muffleCondition(cond)
[09:29:15.241]                 })
[09:29:15.241]             }))
[09:29:15.241]             future::FutureResult(value = ...future.value$value, 
[09:29:15.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.241]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.241]                     ...future.globalenv.names))
[09:29:15.241]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.241]         }, condition = base::local({
[09:29:15.241]             c <- base::c
[09:29:15.241]             inherits <- base::inherits
[09:29:15.241]             invokeRestart <- base::invokeRestart
[09:29:15.241]             length <- base::length
[09:29:15.241]             list <- base::list
[09:29:15.241]             seq.int <- base::seq.int
[09:29:15.241]             signalCondition <- base::signalCondition
[09:29:15.241]             sys.calls <- base::sys.calls
[09:29:15.241]             `[[` <- base::`[[`
[09:29:15.241]             `+` <- base::`+`
[09:29:15.241]             `<<-` <- base::`<<-`
[09:29:15.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.241]                   3L)]
[09:29:15.241]             }
[09:29:15.241]             function(cond) {
[09:29:15.241]                 is_error <- inherits(cond, "error")
[09:29:15.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.241]                   NULL)
[09:29:15.241]                 if (is_error) {
[09:29:15.241]                   sessionInformation <- function() {
[09:29:15.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.241]                       search = base::search(), system = base::Sys.info())
[09:29:15.241]                   }
[09:29:15.241]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.241]                     cond$call), session = sessionInformation(), 
[09:29:15.241]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.241]                   signalCondition(cond)
[09:29:15.241]                 }
[09:29:15.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.241]                 "immediateCondition"))) {
[09:29:15.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.241]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.241]                   if (TRUE && !signal) {
[09:29:15.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.241]                     {
[09:29:15.241]                       inherits <- base::inherits
[09:29:15.241]                       invokeRestart <- base::invokeRestart
[09:29:15.241]                       is.null <- base::is.null
[09:29:15.241]                       muffled <- FALSE
[09:29:15.241]                       if (inherits(cond, "message")) {
[09:29:15.241]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.241]                         if (muffled) 
[09:29:15.241]                           invokeRestart("muffleMessage")
[09:29:15.241]                       }
[09:29:15.241]                       else if (inherits(cond, "warning")) {
[09:29:15.241]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.241]                         if (muffled) 
[09:29:15.241]                           invokeRestart("muffleWarning")
[09:29:15.241]                       }
[09:29:15.241]                       else if (inherits(cond, "condition")) {
[09:29:15.241]                         if (!is.null(pattern)) {
[09:29:15.241]                           computeRestarts <- base::computeRestarts
[09:29:15.241]                           grepl <- base::grepl
[09:29:15.241]                           restarts <- computeRestarts(cond)
[09:29:15.241]                           for (restart in restarts) {
[09:29:15.241]                             name <- restart$name
[09:29:15.241]                             if (is.null(name)) 
[09:29:15.241]                               next
[09:29:15.241]                             if (!grepl(pattern, name)) 
[09:29:15.241]                               next
[09:29:15.241]                             invokeRestart(restart)
[09:29:15.241]                             muffled <- TRUE
[09:29:15.241]                             break
[09:29:15.241]                           }
[09:29:15.241]                         }
[09:29:15.241]                       }
[09:29:15.241]                       invisible(muffled)
[09:29:15.241]                     }
[09:29:15.241]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.241]                   }
[09:29:15.241]                 }
[09:29:15.241]                 else {
[09:29:15.241]                   if (TRUE) {
[09:29:15.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.241]                     {
[09:29:15.241]                       inherits <- base::inherits
[09:29:15.241]                       invokeRestart <- base::invokeRestart
[09:29:15.241]                       is.null <- base::is.null
[09:29:15.241]                       muffled <- FALSE
[09:29:15.241]                       if (inherits(cond, "message")) {
[09:29:15.241]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.241]                         if (muffled) 
[09:29:15.241]                           invokeRestart("muffleMessage")
[09:29:15.241]                       }
[09:29:15.241]                       else if (inherits(cond, "warning")) {
[09:29:15.241]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.241]                         if (muffled) 
[09:29:15.241]                           invokeRestart("muffleWarning")
[09:29:15.241]                       }
[09:29:15.241]                       else if (inherits(cond, "condition")) {
[09:29:15.241]                         if (!is.null(pattern)) {
[09:29:15.241]                           computeRestarts <- base::computeRestarts
[09:29:15.241]                           grepl <- base::grepl
[09:29:15.241]                           restarts <- computeRestarts(cond)
[09:29:15.241]                           for (restart in restarts) {
[09:29:15.241]                             name <- restart$name
[09:29:15.241]                             if (is.null(name)) 
[09:29:15.241]                               next
[09:29:15.241]                             if (!grepl(pattern, name)) 
[09:29:15.241]                               next
[09:29:15.241]                             invokeRestart(restart)
[09:29:15.241]                             muffled <- TRUE
[09:29:15.241]                             break
[09:29:15.241]                           }
[09:29:15.241]                         }
[09:29:15.241]                       }
[09:29:15.241]                       invisible(muffled)
[09:29:15.241]                     }
[09:29:15.241]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.241]                   }
[09:29:15.241]                 }
[09:29:15.241]             }
[09:29:15.241]         }))
[09:29:15.241]     }, error = function(ex) {
[09:29:15.241]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.241]                 ...future.rng), started = ...future.startTime, 
[09:29:15.241]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.241]             version = "1.8"), class = "FutureResult")
[09:29:15.241]     }, finally = {
[09:29:15.241]         if (!identical(...future.workdir, getwd())) 
[09:29:15.241]             setwd(...future.workdir)
[09:29:15.241]         {
[09:29:15.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.241]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.241]             }
[09:29:15.241]             base::options(...future.oldOptions)
[09:29:15.241]             if (.Platform$OS.type == "windows") {
[09:29:15.241]                 old_names <- names(...future.oldEnvVars)
[09:29:15.241]                 envs <- base::Sys.getenv()
[09:29:15.241]                 names <- names(envs)
[09:29:15.241]                 common <- intersect(names, old_names)
[09:29:15.241]                 added <- setdiff(names, old_names)
[09:29:15.241]                 removed <- setdiff(old_names, names)
[09:29:15.241]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.241]                   envs[common]]
[09:29:15.241]                 NAMES <- toupper(changed)
[09:29:15.241]                 args <- list()
[09:29:15.241]                 for (kk in seq_along(NAMES)) {
[09:29:15.241]                   name <- changed[[kk]]
[09:29:15.241]                   NAME <- NAMES[[kk]]
[09:29:15.241]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.241]                     next
[09:29:15.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.241]                 }
[09:29:15.241]                 NAMES <- toupper(added)
[09:29:15.241]                 for (kk in seq_along(NAMES)) {
[09:29:15.241]                   name <- added[[kk]]
[09:29:15.241]                   NAME <- NAMES[[kk]]
[09:29:15.241]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.241]                     next
[09:29:15.241]                   args[[name]] <- ""
[09:29:15.241]                 }
[09:29:15.241]                 NAMES <- toupper(removed)
[09:29:15.241]                 for (kk in seq_along(NAMES)) {
[09:29:15.241]                   name <- removed[[kk]]
[09:29:15.241]                   NAME <- NAMES[[kk]]
[09:29:15.241]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.241]                     next
[09:29:15.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.241]                 }
[09:29:15.241]                 if (length(args) > 0) 
[09:29:15.241]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.241]             }
[09:29:15.241]             else {
[09:29:15.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.241]             }
[09:29:15.241]             {
[09:29:15.241]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.241]                   0L) {
[09:29:15.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.241]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.241]                   base::options(opts)
[09:29:15.241]                 }
[09:29:15.241]                 {
[09:29:15.241]                   {
[09:29:15.241]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.241]                     NULL
[09:29:15.241]                   }
[09:29:15.241]                   options(future.plan = NULL)
[09:29:15.241]                   if (is.na(NA_character_)) 
[09:29:15.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.241]                     .init = FALSE)
[09:29:15.241]                 }
[09:29:15.241]             }
[09:29:15.241]         }
[09:29:15.241]     })
[09:29:15.241]     if (TRUE) {
[09:29:15.241]         base::sink(type = "output", split = FALSE)
[09:29:15.241]         if (TRUE) {
[09:29:15.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.241]         }
[09:29:15.241]         else {
[09:29:15.241]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.241]         }
[09:29:15.241]         base::close(...future.stdout)
[09:29:15.241]         ...future.stdout <- NULL
[09:29:15.241]     }
[09:29:15.241]     ...future.result$conditions <- ...future.conditions
[09:29:15.241]     ...future.result$finished <- base::Sys.time()
[09:29:15.241]     ...future.result
[09:29:15.241] }
[09:29:15.245] assign_globals() ...
[09:29:15.245] List of 5
[09:29:15.245]  $ ...future.FUN            :function (x, ...)  
[09:29:15.245]  $ MoreArgs                 : NULL
[09:29:15.245]  $ ...future.elements_ii    :List of 2
[09:29:15.245]   ..$ :List of 2
[09:29:15.245]   .. ..$ : int 3
[09:29:15.245]   .. ..$ : int 4
[09:29:15.245]   ..$ :List of 2
[09:29:15.245]   .. ..$ : int 2
[09:29:15.245]   .. ..$ : int 1
[09:29:15.245]  $ ...future.seeds_ii       : NULL
[09:29:15.245]  $ ...future.globals.maxSize: NULL
[09:29:15.245]  - attr(*, "where")=List of 5
[09:29:15.245]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.245]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.245]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.245]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.245]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.245]  - attr(*, "resolved")= logi FALSE
[09:29:15.245]  - attr(*, "total_size")= num 280
[09:29:15.245]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.245]  - attr(*, "already-done")= logi TRUE
[09:29:15.258] - copied ‘...future.FUN’ to environment
[09:29:15.258] - copied ‘MoreArgs’ to environment
[09:29:15.258] - copied ‘...future.elements_ii’ to environment
[09:29:15.258] - copied ‘...future.seeds_ii’ to environment
[09:29:15.259] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.259] assign_globals() ... done
[09:29:15.259] requestCore(): workers = 2
[09:29:15.261] MulticoreFuture started
[09:29:15.262] - Launch lazy future ... done
[09:29:15.262] run() for ‘MulticoreFuture’ ... done
[09:29:15.262] plan(): Setting new future strategy stack:
[09:29:15.262] Created future:
[09:29:15.263] List of future strategies:
[09:29:15.263] 1. sequential:
[09:29:15.263]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.263]    - tweaked: FALSE
[09:29:15.263]    - call: NULL
[09:29:15.264] plan(): nbrOfWorkers() = 1
[09:29:15.266] plan(): Setting new future strategy stack:
[09:29:15.267] List of future strategies:
[09:29:15.267] 1. multicore:
[09:29:15.267]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.267]    - tweaked: FALSE
[09:29:15.267]    - call: plan(strategy)
[09:29:15.272] plan(): nbrOfWorkers() = 2
[09:29:15.263] MulticoreFuture:
[09:29:15.263] Label: ‘future_mapply-2’
[09:29:15.263] Expression:
[09:29:15.263] {
[09:29:15.263]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.263]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.263]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.263]         on.exit(options(oopts), add = TRUE)
[09:29:15.263]     }
[09:29:15.263]     {
[09:29:15.263]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.263]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.263]         do.call(mapply, args = args)
[09:29:15.263]     }
[09:29:15.263] }
[09:29:15.263] Lazy evaluation: FALSE
[09:29:15.263] Asynchronous evaluation: TRUE
[09:29:15.263] Local evaluation: TRUE
[09:29:15.263] Environment: R_GlobalEnv
[09:29:15.263] Capture standard output: TRUE
[09:29:15.263] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.263] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.263] Packages: <none>
[09:29:15.263] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.263] Resolved: TRUE
[09:29:15.263] Value: <not collected>
[09:29:15.263] Conditions captured: <none>
[09:29:15.263] Early signaling: FALSE
[09:29:15.263] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.263] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.273] Chunk #2 of 2 ... DONE
[09:29:15.273] Launching 2 futures (chunks) ... DONE
[09:29:15.273] Resolving 2 futures (chunks) ...
[09:29:15.274] resolve() on list ...
[09:29:15.274]  recursive: 0
[09:29:15.274]  length: 2
[09:29:15.274] 
[09:29:15.275] Future #1
[09:29:15.275] result() for MulticoreFuture ...
[09:29:15.276] result() for MulticoreFuture ...
[09:29:15.276] result() for MulticoreFuture ... done
[09:29:15.276] result() for MulticoreFuture ... done
[09:29:15.276] result() for MulticoreFuture ...
[09:29:15.276] result() for MulticoreFuture ... done
[09:29:15.277] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:15.277] - nx: 2
[09:29:15.277] - relay: TRUE
[09:29:15.277] - stdout: TRUE
[09:29:15.277] - signal: TRUE
[09:29:15.277] - resignal: FALSE
[09:29:15.278] - force: TRUE
[09:29:15.278] - relayed: [n=2] FALSE, FALSE
[09:29:15.278] - queued futures: [n=2] FALSE, FALSE
[09:29:15.278]  - until=1
[09:29:15.278]  - relaying element #1
[09:29:15.278] result() for MulticoreFuture ...
[09:29:15.279] result() for MulticoreFuture ... done
[09:29:15.279] result() for MulticoreFuture ...
[09:29:15.279] result() for MulticoreFuture ... done
[09:29:15.279] result() for MulticoreFuture ...
[09:29:15.279] result() for MulticoreFuture ... done
[09:29:15.279] result() for MulticoreFuture ...
[09:29:15.280] result() for MulticoreFuture ... done
[09:29:15.280] - relayed: [n=2] TRUE, FALSE
[09:29:15.280] - queued futures: [n=2] TRUE, FALSE
[09:29:15.280] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:15.280]  length: 1 (resolved future 1)
[09:29:15.280] Future #2
[09:29:15.281] result() for MulticoreFuture ...
[09:29:15.281] result() for MulticoreFuture ...
[09:29:15.281] result() for MulticoreFuture ... done
[09:29:15.282] result() for MulticoreFuture ... done
[09:29:15.282] result() for MulticoreFuture ...
[09:29:15.282] result() for MulticoreFuture ... done
[09:29:15.282] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:15.282] - nx: 2
[09:29:15.282] - relay: TRUE
[09:29:15.282] - stdout: TRUE
[09:29:15.282] - signal: TRUE
[09:29:15.283] - resignal: FALSE
[09:29:15.283] - force: TRUE
[09:29:15.283] - relayed: [n=2] TRUE, FALSE
[09:29:15.283] - queued futures: [n=2] TRUE, FALSE
[09:29:15.283]  - until=2
[09:29:15.283]  - relaying element #2
[09:29:15.283] result() for MulticoreFuture ...
[09:29:15.283] result() for MulticoreFuture ... done
[09:29:15.284] result() for MulticoreFuture ...
[09:29:15.284] result() for MulticoreFuture ... done
[09:29:15.284] result() for MulticoreFuture ...
[09:29:15.284] result() for MulticoreFuture ... done
[09:29:15.284] result() for MulticoreFuture ...
[09:29:15.284] result() for MulticoreFuture ... done
[09:29:15.284] - relayed: [n=2] TRUE, TRUE
[09:29:15.284] - queued futures: [n=2] TRUE, TRUE
[09:29:15.284] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:15.285]  length: 0 (resolved future 2)
[09:29:15.285] Relaying remaining futures
[09:29:15.285] signalConditionsASAP(NULL, pos=0) ...
[09:29:15.285] - nx: 2
[09:29:15.285] - relay: TRUE
[09:29:15.285] - stdout: TRUE
[09:29:15.285] - signal: TRUE
[09:29:15.285] - resignal: FALSE
[09:29:15.285] - force: TRUE
[09:29:15.285] - relayed: [n=2] TRUE, TRUE
[09:29:15.286] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:15.286] - relayed: [n=2] TRUE, TRUE
[09:29:15.286] - queued futures: [n=2] TRUE, TRUE
[09:29:15.286] signalConditionsASAP(NULL, pos=0) ... done
[09:29:15.286] resolve() on list ... DONE
[09:29:15.286] result() for MulticoreFuture ...
[09:29:15.286] result() for MulticoreFuture ... done
[09:29:15.286] result() for MulticoreFuture ...
[09:29:15.286] result() for MulticoreFuture ... done
[09:29:15.287] result() for MulticoreFuture ...
[09:29:15.287] result() for MulticoreFuture ... done
[09:29:15.287] result() for MulticoreFuture ...
[09:29:15.287] result() for MulticoreFuture ... done
[09:29:15.287]  - Number of value chunks collected: 2
[09:29:15.287] Resolving 2 futures (chunks) ... DONE
[09:29:15.287] Reducing values from 2 chunks ...
[09:29:15.287]  - Number of values collected after concatenation: 4
[09:29:15.287]  - Number of values expected: 4
[09:29:15.288] Reducing values from 2 chunks ... DONE
[09:29:15.288] future_mapply() ... DONE
[09:29:15.288] future_mapply() ...
[09:29:15.292] Number of chunks: 2
[09:29:15.292] getGlobalsAndPackagesXApply() ...
[09:29:15.292]  - future.globals: TRUE
[09:29:15.292] getGlobalsAndPackages() ...
[09:29:15.292] Searching for globals...
[09:29:15.293] - globals found: [1] ‘FUN’
[09:29:15.293] Searching for globals ... DONE
[09:29:15.293] Resolving globals: FALSE
[09:29:15.294] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:15.294] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:15.294] - globals: [1] ‘FUN’
[09:29:15.294] 
[09:29:15.295] getGlobalsAndPackages() ... DONE
[09:29:15.295]  - globals found/used: [n=1] ‘FUN’
[09:29:15.295]  - needed namespaces: [n=0] 
[09:29:15.295] Finding globals ... DONE
[09:29:15.295] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:15.295] List of 2
[09:29:15.295]  $ ...future.FUN:function (x, ...)  
[09:29:15.295]  $ MoreArgs     : NULL
[09:29:15.295]  - attr(*, "where")=List of 2
[09:29:15.295]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:15.295]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:15.295]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.295]  - attr(*, "resolved")= logi FALSE
[09:29:15.295]  - attr(*, "total_size")= num NA
[09:29:15.298] Packages to be attached in all futures: [n=0] 
[09:29:15.298] getGlobalsAndPackagesXApply() ... DONE
[09:29:15.299] Number of futures (= number of chunks): 2
[09:29:15.299] Launching 2 futures (chunks) ...
[09:29:15.299] Chunk #1 of 2 ...
[09:29:15.301]  - Finding globals in '...' for chunk #1 ...
[09:29:15.301] getGlobalsAndPackages() ...
[09:29:15.301] Searching for globals...
[09:29:15.302] 
[09:29:15.302] Searching for globals ... DONE
[09:29:15.302] - globals: [0] <none>
[09:29:15.302] getGlobalsAndPackages() ... DONE
[09:29:15.302]    + additional globals found: [n=0] 
[09:29:15.302]    + additional namespaces needed: [n=0] 
[09:29:15.303]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:15.303]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:15.303]  - seeds: <none>
[09:29:15.303]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.303] getGlobalsAndPackages() ...
[09:29:15.303] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.303] Resolving globals: FALSE
[09:29:15.304] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:15.304] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.305] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.305] 
[09:29:15.305] getGlobalsAndPackages() ... DONE
[09:29:15.305] run() for ‘Future’ ...
[09:29:15.305] - state: ‘created’
[09:29:15.306] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.309] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.309] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.309]   - Field: ‘label’
[09:29:15.309]   - Field: ‘local’
[09:29:15.310]   - Field: ‘owner’
[09:29:15.310]   - Field: ‘envir’
[09:29:15.310]   - Field: ‘workers’
[09:29:15.310]   - Field: ‘packages’
[09:29:15.310]   - Field: ‘gc’
[09:29:15.310]   - Field: ‘job’
[09:29:15.310]   - Field: ‘conditions’
[09:29:15.310]   - Field: ‘expr’
[09:29:15.310]   - Field: ‘uuid’
[09:29:15.310]   - Field: ‘seed’
[09:29:15.310]   - Field: ‘version’
[09:29:15.310]   - Field: ‘result’
[09:29:15.311]   - Field: ‘asynchronous’
[09:29:15.311]   - Field: ‘calls’
[09:29:15.311]   - Field: ‘globals’
[09:29:15.311]   - Field: ‘stdout’
[09:29:15.311]   - Field: ‘earlySignal’
[09:29:15.311]   - Field: ‘lazy’
[09:29:15.311]   - Field: ‘state’
[09:29:15.311] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.311] - Launch lazy future ...
[09:29:15.312] Packages needed by the future expression (n = 0): <none>
[09:29:15.312] Packages needed by future strategies (n = 0): <none>
[09:29:15.312] {
[09:29:15.312]     {
[09:29:15.312]         {
[09:29:15.312]             ...future.startTime <- base::Sys.time()
[09:29:15.312]             {
[09:29:15.312]                 {
[09:29:15.312]                   {
[09:29:15.312]                     {
[09:29:15.312]                       base::local({
[09:29:15.312]                         has_future <- base::requireNamespace("future", 
[09:29:15.312]                           quietly = TRUE)
[09:29:15.312]                         if (has_future) {
[09:29:15.312]                           ns <- base::getNamespace("future")
[09:29:15.312]                           version <- ns[[".package"]][["version"]]
[09:29:15.312]                           if (is.null(version)) 
[09:29:15.312]                             version <- utils::packageVersion("future")
[09:29:15.312]                         }
[09:29:15.312]                         else {
[09:29:15.312]                           version <- NULL
[09:29:15.312]                         }
[09:29:15.312]                         if (!has_future || version < "1.8.0") {
[09:29:15.312]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.312]                             "", base::R.version$version.string), 
[09:29:15.312]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.312]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.312]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.312]                               "release", "version")], collapse = " "), 
[09:29:15.312]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.312]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.312]                             info)
[09:29:15.312]                           info <- base::paste(info, collapse = "; ")
[09:29:15.312]                           if (!has_future) {
[09:29:15.312]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.312]                               info)
[09:29:15.312]                           }
[09:29:15.312]                           else {
[09:29:15.312]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.312]                               info, version)
[09:29:15.312]                           }
[09:29:15.312]                           base::stop(msg)
[09:29:15.312]                         }
[09:29:15.312]                       })
[09:29:15.312]                     }
[09:29:15.312]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.312]                     base::options(mc.cores = 1L)
[09:29:15.312]                   }
[09:29:15.312]                   ...future.strategy.old <- future::plan("list")
[09:29:15.312]                   options(future.plan = NULL)
[09:29:15.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.312]                 }
[09:29:15.312]                 ...future.workdir <- getwd()
[09:29:15.312]             }
[09:29:15.312]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.312]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.312]         }
[09:29:15.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.312]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:15.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.312]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.312]             base::names(...future.oldOptions))
[09:29:15.312]     }
[09:29:15.312]     if (FALSE) {
[09:29:15.312]     }
[09:29:15.312]     else {
[09:29:15.312]         if (TRUE) {
[09:29:15.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.312]                 open = "w")
[09:29:15.312]         }
[09:29:15.312]         else {
[09:29:15.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.312]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.312]         }
[09:29:15.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.312]             base::sink(type = "output", split = FALSE)
[09:29:15.312]             base::close(...future.stdout)
[09:29:15.312]         }, add = TRUE)
[09:29:15.312]     }
[09:29:15.312]     ...future.frame <- base::sys.nframe()
[09:29:15.312]     ...future.conditions <- base::list()
[09:29:15.312]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.312]     if (FALSE) {
[09:29:15.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.312]     }
[09:29:15.312]     ...future.result <- base::tryCatch({
[09:29:15.312]         base::withCallingHandlers({
[09:29:15.312]             ...future.value <- base::withVisible(base::local({
[09:29:15.312]                 withCallingHandlers({
[09:29:15.312]                   {
[09:29:15.312]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.312]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.312]                       ...future.globals.maxSize)) {
[09:29:15.312]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.312]                       on.exit(options(oopts), add = TRUE)
[09:29:15.312]                     }
[09:29:15.312]                     {
[09:29:15.312]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.312]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.312]                         USE.NAMES = FALSE)
[09:29:15.312]                       do.call(mapply, args = args)
[09:29:15.312]                     }
[09:29:15.312]                   }
[09:29:15.312]                 }, immediateCondition = function(cond) {
[09:29:15.312]                   save_rds <- function (object, pathname, ...) 
[09:29:15.312]                   {
[09:29:15.312]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.312]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.312]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.312]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.312]                         fi_tmp[["mtime"]])
[09:29:15.312]                     }
[09:29:15.312]                     tryCatch({
[09:29:15.312]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.312]                     }, error = function(ex) {
[09:29:15.312]                       msg <- conditionMessage(ex)
[09:29:15.312]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.312]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.312]                         fi_tmp[["mtime"]], msg)
[09:29:15.312]                       ex$message <- msg
[09:29:15.312]                       stop(ex)
[09:29:15.312]                     })
[09:29:15.312]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.312]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.312]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.312]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.312]                       fi <- file.info(pathname)
[09:29:15.312]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.312]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.312]                         fi[["size"]], fi[["mtime"]])
[09:29:15.312]                       stop(msg)
[09:29:15.312]                     }
[09:29:15.312]                     invisible(pathname)
[09:29:15.312]                   }
[09:29:15.312]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.312]                     rootPath = tempdir()) 
[09:29:15.312]                   {
[09:29:15.312]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.312]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.312]                       tmpdir = path, fileext = ".rds")
[09:29:15.312]                     save_rds(obj, file)
[09:29:15.312]                   }
[09:29:15.312]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.312]                   {
[09:29:15.312]                     inherits <- base::inherits
[09:29:15.312]                     invokeRestart <- base::invokeRestart
[09:29:15.312]                     is.null <- base::is.null
[09:29:15.312]                     muffled <- FALSE
[09:29:15.312]                     if (inherits(cond, "message")) {
[09:29:15.312]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.312]                       if (muffled) 
[09:29:15.312]                         invokeRestart("muffleMessage")
[09:29:15.312]                     }
[09:29:15.312]                     else if (inherits(cond, "warning")) {
[09:29:15.312]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.312]                       if (muffled) 
[09:29:15.312]                         invokeRestart("muffleWarning")
[09:29:15.312]                     }
[09:29:15.312]                     else if (inherits(cond, "condition")) {
[09:29:15.312]                       if (!is.null(pattern)) {
[09:29:15.312]                         computeRestarts <- base::computeRestarts
[09:29:15.312]                         grepl <- base::grepl
[09:29:15.312]                         restarts <- computeRestarts(cond)
[09:29:15.312]                         for (restart in restarts) {
[09:29:15.312]                           name <- restart$name
[09:29:15.312]                           if (is.null(name)) 
[09:29:15.312]                             next
[09:29:15.312]                           if (!grepl(pattern, name)) 
[09:29:15.312]                             next
[09:29:15.312]                           invokeRestart(restart)
[09:29:15.312]                           muffled <- TRUE
[09:29:15.312]                           break
[09:29:15.312]                         }
[09:29:15.312]                       }
[09:29:15.312]                     }
[09:29:15.312]                     invisible(muffled)
[09:29:15.312]                   }
[09:29:15.312]                   muffleCondition(cond)
[09:29:15.312]                 })
[09:29:15.312]             }))
[09:29:15.312]             future::FutureResult(value = ...future.value$value, 
[09:29:15.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.312]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.312]                     ...future.globalenv.names))
[09:29:15.312]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.312]         }, condition = base::local({
[09:29:15.312]             c <- base::c
[09:29:15.312]             inherits <- base::inherits
[09:29:15.312]             invokeRestart <- base::invokeRestart
[09:29:15.312]             length <- base::length
[09:29:15.312]             list <- base::list
[09:29:15.312]             seq.int <- base::seq.int
[09:29:15.312]             signalCondition <- base::signalCondition
[09:29:15.312]             sys.calls <- base::sys.calls
[09:29:15.312]             `[[` <- base::`[[`
[09:29:15.312]             `+` <- base::`+`
[09:29:15.312]             `<<-` <- base::`<<-`
[09:29:15.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.312]                   3L)]
[09:29:15.312]             }
[09:29:15.312]             function(cond) {
[09:29:15.312]                 is_error <- inherits(cond, "error")
[09:29:15.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.312]                   NULL)
[09:29:15.312]                 if (is_error) {
[09:29:15.312]                   sessionInformation <- function() {
[09:29:15.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.312]                       search = base::search(), system = base::Sys.info())
[09:29:15.312]                   }
[09:29:15.312]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.312]                     cond$call), session = sessionInformation(), 
[09:29:15.312]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.312]                   signalCondition(cond)
[09:29:15.312]                 }
[09:29:15.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.312]                 "immediateCondition"))) {
[09:29:15.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.312]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.312]                   if (TRUE && !signal) {
[09:29:15.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.312]                     {
[09:29:15.312]                       inherits <- base::inherits
[09:29:15.312]                       invokeRestart <- base::invokeRestart
[09:29:15.312]                       is.null <- base::is.null
[09:29:15.312]                       muffled <- FALSE
[09:29:15.312]                       if (inherits(cond, "message")) {
[09:29:15.312]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.312]                         if (muffled) 
[09:29:15.312]                           invokeRestart("muffleMessage")
[09:29:15.312]                       }
[09:29:15.312]                       else if (inherits(cond, "warning")) {
[09:29:15.312]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.312]                         if (muffled) 
[09:29:15.312]                           invokeRestart("muffleWarning")
[09:29:15.312]                       }
[09:29:15.312]                       else if (inherits(cond, "condition")) {
[09:29:15.312]                         if (!is.null(pattern)) {
[09:29:15.312]                           computeRestarts <- base::computeRestarts
[09:29:15.312]                           grepl <- base::grepl
[09:29:15.312]                           restarts <- computeRestarts(cond)
[09:29:15.312]                           for (restart in restarts) {
[09:29:15.312]                             name <- restart$name
[09:29:15.312]                             if (is.null(name)) 
[09:29:15.312]                               next
[09:29:15.312]                             if (!grepl(pattern, name)) 
[09:29:15.312]                               next
[09:29:15.312]                             invokeRestart(restart)
[09:29:15.312]                             muffled <- TRUE
[09:29:15.312]                             break
[09:29:15.312]                           }
[09:29:15.312]                         }
[09:29:15.312]                       }
[09:29:15.312]                       invisible(muffled)
[09:29:15.312]                     }
[09:29:15.312]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.312]                   }
[09:29:15.312]                 }
[09:29:15.312]                 else {
[09:29:15.312]                   if (TRUE) {
[09:29:15.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.312]                     {
[09:29:15.312]                       inherits <- base::inherits
[09:29:15.312]                       invokeRestart <- base::invokeRestart
[09:29:15.312]                       is.null <- base::is.null
[09:29:15.312]                       muffled <- FALSE
[09:29:15.312]                       if (inherits(cond, "message")) {
[09:29:15.312]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.312]                         if (muffled) 
[09:29:15.312]                           invokeRestart("muffleMessage")
[09:29:15.312]                       }
[09:29:15.312]                       else if (inherits(cond, "warning")) {
[09:29:15.312]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.312]                         if (muffled) 
[09:29:15.312]                           invokeRestart("muffleWarning")
[09:29:15.312]                       }
[09:29:15.312]                       else if (inherits(cond, "condition")) {
[09:29:15.312]                         if (!is.null(pattern)) {
[09:29:15.312]                           computeRestarts <- base::computeRestarts
[09:29:15.312]                           grepl <- base::grepl
[09:29:15.312]                           restarts <- computeRestarts(cond)
[09:29:15.312]                           for (restart in restarts) {
[09:29:15.312]                             name <- restart$name
[09:29:15.312]                             if (is.null(name)) 
[09:29:15.312]                               next
[09:29:15.312]                             if (!grepl(pattern, name)) 
[09:29:15.312]                               next
[09:29:15.312]                             invokeRestart(restart)
[09:29:15.312]                             muffled <- TRUE
[09:29:15.312]                             break
[09:29:15.312]                           }
[09:29:15.312]                         }
[09:29:15.312]                       }
[09:29:15.312]                       invisible(muffled)
[09:29:15.312]                     }
[09:29:15.312]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.312]                   }
[09:29:15.312]                 }
[09:29:15.312]             }
[09:29:15.312]         }))
[09:29:15.312]     }, error = function(ex) {
[09:29:15.312]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.312]                 ...future.rng), started = ...future.startTime, 
[09:29:15.312]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.312]             version = "1.8"), class = "FutureResult")
[09:29:15.312]     }, finally = {
[09:29:15.312]         if (!identical(...future.workdir, getwd())) 
[09:29:15.312]             setwd(...future.workdir)
[09:29:15.312]         {
[09:29:15.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.312]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.312]             }
[09:29:15.312]             base::options(...future.oldOptions)
[09:29:15.312]             if (.Platform$OS.type == "windows") {
[09:29:15.312]                 old_names <- names(...future.oldEnvVars)
[09:29:15.312]                 envs <- base::Sys.getenv()
[09:29:15.312]                 names <- names(envs)
[09:29:15.312]                 common <- intersect(names, old_names)
[09:29:15.312]                 added <- setdiff(names, old_names)
[09:29:15.312]                 removed <- setdiff(old_names, names)
[09:29:15.312]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.312]                   envs[common]]
[09:29:15.312]                 NAMES <- toupper(changed)
[09:29:15.312]                 args <- list()
[09:29:15.312]                 for (kk in seq_along(NAMES)) {
[09:29:15.312]                   name <- changed[[kk]]
[09:29:15.312]                   NAME <- NAMES[[kk]]
[09:29:15.312]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.312]                     next
[09:29:15.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.312]                 }
[09:29:15.312]                 NAMES <- toupper(added)
[09:29:15.312]                 for (kk in seq_along(NAMES)) {
[09:29:15.312]                   name <- added[[kk]]
[09:29:15.312]                   NAME <- NAMES[[kk]]
[09:29:15.312]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.312]                     next
[09:29:15.312]                   args[[name]] <- ""
[09:29:15.312]                 }
[09:29:15.312]                 NAMES <- toupper(removed)
[09:29:15.312]                 for (kk in seq_along(NAMES)) {
[09:29:15.312]                   name <- removed[[kk]]
[09:29:15.312]                   NAME <- NAMES[[kk]]
[09:29:15.312]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.312]                     next
[09:29:15.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.312]                 }
[09:29:15.312]                 if (length(args) > 0) 
[09:29:15.312]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.312]             }
[09:29:15.312]             else {
[09:29:15.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.312]             }
[09:29:15.312]             {
[09:29:15.312]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.312]                   0L) {
[09:29:15.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.312]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.312]                   base::options(opts)
[09:29:15.312]                 }
[09:29:15.312]                 {
[09:29:15.312]                   {
[09:29:15.312]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.312]                     NULL
[09:29:15.312]                   }
[09:29:15.312]                   options(future.plan = NULL)
[09:29:15.312]                   if (is.na(NA_character_)) 
[09:29:15.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.312]                     .init = FALSE)
[09:29:15.312]                 }
[09:29:15.312]             }
[09:29:15.312]         }
[09:29:15.312]     })
[09:29:15.312]     if (TRUE) {
[09:29:15.312]         base::sink(type = "output", split = FALSE)
[09:29:15.312]         if (TRUE) {
[09:29:15.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.312]         }
[09:29:15.312]         else {
[09:29:15.312]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.312]         }
[09:29:15.312]         base::close(...future.stdout)
[09:29:15.312]         ...future.stdout <- NULL
[09:29:15.312]     }
[09:29:15.312]     ...future.result$conditions <- ...future.conditions
[09:29:15.312]     ...future.result$finished <- base::Sys.time()
[09:29:15.312]     ...future.result
[09:29:15.312] }
[09:29:15.315] assign_globals() ...
[09:29:15.315] List of 5
[09:29:15.315]  $ ...future.FUN            :function (x, ...)  
[09:29:15.315]  $ MoreArgs                 : NULL
[09:29:15.315]  $ ...future.elements_ii    :List of 2
[09:29:15.315]   ..$ times:List of 2
[09:29:15.315]   .. ..$ : int 1
[09:29:15.315]   .. ..$ : int 2
[09:29:15.315]   ..$ x    :List of 2
[09:29:15.315]   .. ..$ : int 4
[09:29:15.315]   .. ..$ : int 3
[09:29:15.315]  $ ...future.seeds_ii       : NULL
[09:29:15.315]  $ ...future.globals.maxSize: NULL
[09:29:15.315]  - attr(*, "where")=List of 5
[09:29:15.315]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.315]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.315]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.315]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.315]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.315]  - attr(*, "resolved")= logi FALSE
[09:29:15.315]  - attr(*, "total_size")= num 280
[09:29:15.315]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.315]  - attr(*, "already-done")= logi TRUE
[09:29:15.320] - copied ‘...future.FUN’ to environment
[09:29:15.320] - copied ‘MoreArgs’ to environment
[09:29:15.320] - copied ‘...future.elements_ii’ to environment
[09:29:15.320] - copied ‘...future.seeds_ii’ to environment
[09:29:15.320] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.321] assign_globals() ... done
[09:29:15.321] requestCore(): workers = 2
[09:29:15.322] MulticoreFuture started
[09:29:15.323] - Launch lazy future ... done
[09:29:15.323] run() for ‘MulticoreFuture’ ... done
[09:29:15.323] Created future:
[09:29:15.324] plan(): Setting new future strategy stack:
[09:29:15.324] List of future strategies:
[09:29:15.324] 1. sequential:
[09:29:15.324]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.324]    - tweaked: FALSE
[09:29:15.324]    - call: NULL
[09:29:15.325] plan(): nbrOfWorkers() = 1
[09:29:15.327] plan(): Setting new future strategy stack:
[09:29:15.327] List of future strategies:
[09:29:15.327] 1. multicore:
[09:29:15.327]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.327]    - tweaked: FALSE
[09:29:15.327]    - call: plan(strategy)
[09:29:15.332] plan(): nbrOfWorkers() = 2
[09:29:15.323] MulticoreFuture:
[09:29:15.323] Label: ‘future_mapply-1’
[09:29:15.323] Expression:
[09:29:15.323] {
[09:29:15.323]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.323]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.323]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.323]         on.exit(options(oopts), add = TRUE)
[09:29:15.323]     }
[09:29:15.323]     {
[09:29:15.323]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.323]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.323]         do.call(mapply, args = args)
[09:29:15.323]     }
[09:29:15.323] }
[09:29:15.323] Lazy evaluation: FALSE
[09:29:15.323] Asynchronous evaluation: TRUE
[09:29:15.323] Local evaluation: TRUE
[09:29:15.323] Environment: R_GlobalEnv
[09:29:15.323] Capture standard output: TRUE
[09:29:15.323] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.323] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.323] Packages: <none>
[09:29:15.323] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.323] Resolved: TRUE
[09:29:15.323] Value: <not collected>
[09:29:15.323] Conditions captured: <none>
[09:29:15.323] Early signaling: FALSE
[09:29:15.323] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.323] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.333] Chunk #1 of 2 ... DONE
[09:29:15.333] Chunk #2 of 2 ...
[09:29:15.333]  - Finding globals in '...' for chunk #2 ...
[09:29:15.333] getGlobalsAndPackages() ...
[09:29:15.333] Searching for globals...
[09:29:15.334] 
[09:29:15.334] Searching for globals ... DONE
[09:29:15.334] - globals: [0] <none>
[09:29:15.334] getGlobalsAndPackages() ... DONE
[09:29:15.335]    + additional globals found: [n=0] 
[09:29:15.335]    + additional namespaces needed: [n=0] 
[09:29:15.335]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:15.335]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:15.335]  - seeds: <none>
[09:29:15.335]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.335] getGlobalsAndPackages() ...
[09:29:15.336] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.336] Resolving globals: FALSE
[09:29:15.337] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:15.337] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.338] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.338] 
[09:29:15.338] getGlobalsAndPackages() ... DONE
[09:29:15.339] run() for ‘Future’ ...
[09:29:15.339] - state: ‘created’
[09:29:15.339] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.347] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.347] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.347]   - Field: ‘label’
[09:29:15.348]   - Field: ‘local’
[09:29:15.348]   - Field: ‘owner’
[09:29:15.348]   - Field: ‘envir’
[09:29:15.349]   - Field: ‘workers’
[09:29:15.349]   - Field: ‘packages’
[09:29:15.349]   - Field: ‘gc’
[09:29:15.350]   - Field: ‘job’
[09:29:15.350]   - Field: ‘conditions’
[09:29:15.350]   - Field: ‘expr’
[09:29:15.350]   - Field: ‘uuid’
[09:29:15.351]   - Field: ‘seed’
[09:29:15.351]   - Field: ‘version’
[09:29:15.351]   - Field: ‘result’
[09:29:15.351]   - Field: ‘asynchronous’
[09:29:15.351]   - Field: ‘calls’
[09:29:15.352]   - Field: ‘globals’
[09:29:15.352]   - Field: ‘stdout’
[09:29:15.352]   - Field: ‘earlySignal’
[09:29:15.352]   - Field: ‘lazy’
[09:29:15.353]   - Field: ‘state’
[09:29:15.353] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.353] - Launch lazy future ...
[09:29:15.354] Packages needed by the future expression (n = 0): <none>
[09:29:15.354] Packages needed by future strategies (n = 0): <none>
[09:29:15.355] {
[09:29:15.355]     {
[09:29:15.355]         {
[09:29:15.355]             ...future.startTime <- base::Sys.time()
[09:29:15.355]             {
[09:29:15.355]                 {
[09:29:15.355]                   {
[09:29:15.355]                     {
[09:29:15.355]                       base::local({
[09:29:15.355]                         has_future <- base::requireNamespace("future", 
[09:29:15.355]                           quietly = TRUE)
[09:29:15.355]                         if (has_future) {
[09:29:15.355]                           ns <- base::getNamespace("future")
[09:29:15.355]                           version <- ns[[".package"]][["version"]]
[09:29:15.355]                           if (is.null(version)) 
[09:29:15.355]                             version <- utils::packageVersion("future")
[09:29:15.355]                         }
[09:29:15.355]                         else {
[09:29:15.355]                           version <- NULL
[09:29:15.355]                         }
[09:29:15.355]                         if (!has_future || version < "1.8.0") {
[09:29:15.355]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.355]                             "", base::R.version$version.string), 
[09:29:15.355]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.355]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.355]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.355]                               "release", "version")], collapse = " "), 
[09:29:15.355]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.355]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.355]                             info)
[09:29:15.355]                           info <- base::paste(info, collapse = "; ")
[09:29:15.355]                           if (!has_future) {
[09:29:15.355]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.355]                               info)
[09:29:15.355]                           }
[09:29:15.355]                           else {
[09:29:15.355]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.355]                               info, version)
[09:29:15.355]                           }
[09:29:15.355]                           base::stop(msg)
[09:29:15.355]                         }
[09:29:15.355]                       })
[09:29:15.355]                     }
[09:29:15.355]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.355]                     base::options(mc.cores = 1L)
[09:29:15.355]                   }
[09:29:15.355]                   ...future.strategy.old <- future::plan("list")
[09:29:15.355]                   options(future.plan = NULL)
[09:29:15.355]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.355]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.355]                 }
[09:29:15.355]                 ...future.workdir <- getwd()
[09:29:15.355]             }
[09:29:15.355]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.355]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.355]         }
[09:29:15.355]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.355]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:15.355]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.355]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.355]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.355]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.355]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.355]             base::names(...future.oldOptions))
[09:29:15.355]     }
[09:29:15.355]     if (FALSE) {
[09:29:15.355]     }
[09:29:15.355]     else {
[09:29:15.355]         if (TRUE) {
[09:29:15.355]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.355]                 open = "w")
[09:29:15.355]         }
[09:29:15.355]         else {
[09:29:15.355]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.355]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.355]         }
[09:29:15.355]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.355]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.355]             base::sink(type = "output", split = FALSE)
[09:29:15.355]             base::close(...future.stdout)
[09:29:15.355]         }, add = TRUE)
[09:29:15.355]     }
[09:29:15.355]     ...future.frame <- base::sys.nframe()
[09:29:15.355]     ...future.conditions <- base::list()
[09:29:15.355]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.355]     if (FALSE) {
[09:29:15.355]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.355]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.355]     }
[09:29:15.355]     ...future.result <- base::tryCatch({
[09:29:15.355]         base::withCallingHandlers({
[09:29:15.355]             ...future.value <- base::withVisible(base::local({
[09:29:15.355]                 withCallingHandlers({
[09:29:15.355]                   {
[09:29:15.355]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.355]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.355]                       ...future.globals.maxSize)) {
[09:29:15.355]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.355]                       on.exit(options(oopts), add = TRUE)
[09:29:15.355]                     }
[09:29:15.355]                     {
[09:29:15.355]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.355]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.355]                         USE.NAMES = FALSE)
[09:29:15.355]                       do.call(mapply, args = args)
[09:29:15.355]                     }
[09:29:15.355]                   }
[09:29:15.355]                 }, immediateCondition = function(cond) {
[09:29:15.355]                   save_rds <- function (object, pathname, ...) 
[09:29:15.355]                   {
[09:29:15.355]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.355]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.355]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.355]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.355]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.355]                         fi_tmp[["mtime"]])
[09:29:15.355]                     }
[09:29:15.355]                     tryCatch({
[09:29:15.355]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.355]                     }, error = function(ex) {
[09:29:15.355]                       msg <- conditionMessage(ex)
[09:29:15.355]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.355]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.355]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.355]                         fi_tmp[["mtime"]], msg)
[09:29:15.355]                       ex$message <- msg
[09:29:15.355]                       stop(ex)
[09:29:15.355]                     })
[09:29:15.355]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.355]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.355]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.355]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.355]                       fi <- file.info(pathname)
[09:29:15.355]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.355]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.355]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.355]                         fi[["size"]], fi[["mtime"]])
[09:29:15.355]                       stop(msg)
[09:29:15.355]                     }
[09:29:15.355]                     invisible(pathname)
[09:29:15.355]                   }
[09:29:15.355]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.355]                     rootPath = tempdir()) 
[09:29:15.355]                   {
[09:29:15.355]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.355]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.355]                       tmpdir = path, fileext = ".rds")
[09:29:15.355]                     save_rds(obj, file)
[09:29:15.355]                   }
[09:29:15.355]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.355]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.355]                   {
[09:29:15.355]                     inherits <- base::inherits
[09:29:15.355]                     invokeRestart <- base::invokeRestart
[09:29:15.355]                     is.null <- base::is.null
[09:29:15.355]                     muffled <- FALSE
[09:29:15.355]                     if (inherits(cond, "message")) {
[09:29:15.355]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.355]                       if (muffled) 
[09:29:15.355]                         invokeRestart("muffleMessage")
[09:29:15.355]                     }
[09:29:15.355]                     else if (inherits(cond, "warning")) {
[09:29:15.355]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.355]                       if (muffled) 
[09:29:15.355]                         invokeRestart("muffleWarning")
[09:29:15.355]                     }
[09:29:15.355]                     else if (inherits(cond, "condition")) {
[09:29:15.355]                       if (!is.null(pattern)) {
[09:29:15.355]                         computeRestarts <- base::computeRestarts
[09:29:15.355]                         grepl <- base::grepl
[09:29:15.355]                         restarts <- computeRestarts(cond)
[09:29:15.355]                         for (restart in restarts) {
[09:29:15.355]                           name <- restart$name
[09:29:15.355]                           if (is.null(name)) 
[09:29:15.355]                             next
[09:29:15.355]                           if (!grepl(pattern, name)) 
[09:29:15.355]                             next
[09:29:15.355]                           invokeRestart(restart)
[09:29:15.355]                           muffled <- TRUE
[09:29:15.355]                           break
[09:29:15.355]                         }
[09:29:15.355]                       }
[09:29:15.355]                     }
[09:29:15.355]                     invisible(muffled)
[09:29:15.355]                   }
[09:29:15.355]                   muffleCondition(cond)
[09:29:15.355]                 })
[09:29:15.355]             }))
[09:29:15.355]             future::FutureResult(value = ...future.value$value, 
[09:29:15.355]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.355]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.355]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.355]                     ...future.globalenv.names))
[09:29:15.355]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.355]         }, condition = base::local({
[09:29:15.355]             c <- base::c
[09:29:15.355]             inherits <- base::inherits
[09:29:15.355]             invokeRestart <- base::invokeRestart
[09:29:15.355]             length <- base::length
[09:29:15.355]             list <- base::list
[09:29:15.355]             seq.int <- base::seq.int
[09:29:15.355]             signalCondition <- base::signalCondition
[09:29:15.355]             sys.calls <- base::sys.calls
[09:29:15.355]             `[[` <- base::`[[`
[09:29:15.355]             `+` <- base::`+`
[09:29:15.355]             `<<-` <- base::`<<-`
[09:29:15.355]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.355]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.355]                   3L)]
[09:29:15.355]             }
[09:29:15.355]             function(cond) {
[09:29:15.355]                 is_error <- inherits(cond, "error")
[09:29:15.355]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.355]                   NULL)
[09:29:15.355]                 if (is_error) {
[09:29:15.355]                   sessionInformation <- function() {
[09:29:15.355]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.355]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.355]                       search = base::search(), system = base::Sys.info())
[09:29:15.355]                   }
[09:29:15.355]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.355]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.355]                     cond$call), session = sessionInformation(), 
[09:29:15.355]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.355]                   signalCondition(cond)
[09:29:15.355]                 }
[09:29:15.355]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.355]                 "immediateCondition"))) {
[09:29:15.355]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.355]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.355]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.355]                   if (TRUE && !signal) {
[09:29:15.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.355]                     {
[09:29:15.355]                       inherits <- base::inherits
[09:29:15.355]                       invokeRestart <- base::invokeRestart
[09:29:15.355]                       is.null <- base::is.null
[09:29:15.355]                       muffled <- FALSE
[09:29:15.355]                       if (inherits(cond, "message")) {
[09:29:15.355]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.355]                         if (muffled) 
[09:29:15.355]                           invokeRestart("muffleMessage")
[09:29:15.355]                       }
[09:29:15.355]                       else if (inherits(cond, "warning")) {
[09:29:15.355]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.355]                         if (muffled) 
[09:29:15.355]                           invokeRestart("muffleWarning")
[09:29:15.355]                       }
[09:29:15.355]                       else if (inherits(cond, "condition")) {
[09:29:15.355]                         if (!is.null(pattern)) {
[09:29:15.355]                           computeRestarts <- base::computeRestarts
[09:29:15.355]                           grepl <- base::grepl
[09:29:15.355]                           restarts <- computeRestarts(cond)
[09:29:15.355]                           for (restart in restarts) {
[09:29:15.355]                             name <- restart$name
[09:29:15.355]                             if (is.null(name)) 
[09:29:15.355]                               next
[09:29:15.355]                             if (!grepl(pattern, name)) 
[09:29:15.355]                               next
[09:29:15.355]                             invokeRestart(restart)
[09:29:15.355]                             muffled <- TRUE
[09:29:15.355]                             break
[09:29:15.355]                           }
[09:29:15.355]                         }
[09:29:15.355]                       }
[09:29:15.355]                       invisible(muffled)
[09:29:15.355]                     }
[09:29:15.355]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.355]                   }
[09:29:15.355]                 }
[09:29:15.355]                 else {
[09:29:15.355]                   if (TRUE) {
[09:29:15.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.355]                     {
[09:29:15.355]                       inherits <- base::inherits
[09:29:15.355]                       invokeRestart <- base::invokeRestart
[09:29:15.355]                       is.null <- base::is.null
[09:29:15.355]                       muffled <- FALSE
[09:29:15.355]                       if (inherits(cond, "message")) {
[09:29:15.355]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.355]                         if (muffled) 
[09:29:15.355]                           invokeRestart("muffleMessage")
[09:29:15.355]                       }
[09:29:15.355]                       else if (inherits(cond, "warning")) {
[09:29:15.355]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.355]                         if (muffled) 
[09:29:15.355]                           invokeRestart("muffleWarning")
[09:29:15.355]                       }
[09:29:15.355]                       else if (inherits(cond, "condition")) {
[09:29:15.355]                         if (!is.null(pattern)) {
[09:29:15.355]                           computeRestarts <- base::computeRestarts
[09:29:15.355]                           grepl <- base::grepl
[09:29:15.355]                           restarts <- computeRestarts(cond)
[09:29:15.355]                           for (restart in restarts) {
[09:29:15.355]                             name <- restart$name
[09:29:15.355]                             if (is.null(name)) 
[09:29:15.355]                               next
[09:29:15.355]                             if (!grepl(pattern, name)) 
[09:29:15.355]                               next
[09:29:15.355]                             invokeRestart(restart)
[09:29:15.355]                             muffled <- TRUE
[09:29:15.355]                             break
[09:29:15.355]                           }
[09:29:15.355]                         }
[09:29:15.355]                       }
[09:29:15.355]                       invisible(muffled)
[09:29:15.355]                     }
[09:29:15.355]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.355]                   }
[09:29:15.355]                 }
[09:29:15.355]             }
[09:29:15.355]         }))
[09:29:15.355]     }, error = function(ex) {
[09:29:15.355]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.355]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.355]                 ...future.rng), started = ...future.startTime, 
[09:29:15.355]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.355]             version = "1.8"), class = "FutureResult")
[09:29:15.355]     }, finally = {
[09:29:15.355]         if (!identical(...future.workdir, getwd())) 
[09:29:15.355]             setwd(...future.workdir)
[09:29:15.355]         {
[09:29:15.355]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.355]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.355]             }
[09:29:15.355]             base::options(...future.oldOptions)
[09:29:15.355]             if (.Platform$OS.type == "windows") {
[09:29:15.355]                 old_names <- names(...future.oldEnvVars)
[09:29:15.355]                 envs <- base::Sys.getenv()
[09:29:15.355]                 names <- names(envs)
[09:29:15.355]                 common <- intersect(names, old_names)
[09:29:15.355]                 added <- setdiff(names, old_names)
[09:29:15.355]                 removed <- setdiff(old_names, names)
[09:29:15.355]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.355]                   envs[common]]
[09:29:15.355]                 NAMES <- toupper(changed)
[09:29:15.355]                 args <- list()
[09:29:15.355]                 for (kk in seq_along(NAMES)) {
[09:29:15.355]                   name <- changed[[kk]]
[09:29:15.355]                   NAME <- NAMES[[kk]]
[09:29:15.355]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.355]                     next
[09:29:15.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.355]                 }
[09:29:15.355]                 NAMES <- toupper(added)
[09:29:15.355]                 for (kk in seq_along(NAMES)) {
[09:29:15.355]                   name <- added[[kk]]
[09:29:15.355]                   NAME <- NAMES[[kk]]
[09:29:15.355]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.355]                     next
[09:29:15.355]                   args[[name]] <- ""
[09:29:15.355]                 }
[09:29:15.355]                 NAMES <- toupper(removed)
[09:29:15.355]                 for (kk in seq_along(NAMES)) {
[09:29:15.355]                   name <- removed[[kk]]
[09:29:15.355]                   NAME <- NAMES[[kk]]
[09:29:15.355]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.355]                     next
[09:29:15.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.355]                 }
[09:29:15.355]                 if (length(args) > 0) 
[09:29:15.355]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.355]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.355]             }
[09:29:15.355]             else {
[09:29:15.355]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.355]             }
[09:29:15.355]             {
[09:29:15.355]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.355]                   0L) {
[09:29:15.355]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.355]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.355]                   base::options(opts)
[09:29:15.355]                 }
[09:29:15.355]                 {
[09:29:15.355]                   {
[09:29:15.355]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.355]                     NULL
[09:29:15.355]                   }
[09:29:15.355]                   options(future.plan = NULL)
[09:29:15.355]                   if (is.na(NA_character_)) 
[09:29:15.355]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.355]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.355]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.355]                     .init = FALSE)
[09:29:15.355]                 }
[09:29:15.355]             }
[09:29:15.355]         }
[09:29:15.355]     })
[09:29:15.355]     if (TRUE) {
[09:29:15.355]         base::sink(type = "output", split = FALSE)
[09:29:15.355]         if (TRUE) {
[09:29:15.355]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.355]         }
[09:29:15.355]         else {
[09:29:15.355]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.355]         }
[09:29:15.355]         base::close(...future.stdout)
[09:29:15.355]         ...future.stdout <- NULL
[09:29:15.355]     }
[09:29:15.355]     ...future.result$conditions <- ...future.conditions
[09:29:15.355]     ...future.result$finished <- base::Sys.time()
[09:29:15.355]     ...future.result
[09:29:15.355] }
[09:29:15.357] assign_globals() ...
[09:29:15.357] List of 5
[09:29:15.357]  $ ...future.FUN            :function (x, ...)  
[09:29:15.357]  $ MoreArgs                 : NULL
[09:29:15.357]  $ ...future.elements_ii    :List of 2
[09:29:15.357]   ..$ times:List of 2
[09:29:15.357]   .. ..$ : int 3
[09:29:15.357]   .. ..$ : int 4
[09:29:15.357]   ..$ x    :List of 2
[09:29:15.357]   .. ..$ : int 2
[09:29:15.357]   .. ..$ : int 1
[09:29:15.357]  $ ...future.seeds_ii       : NULL
[09:29:15.357]  $ ...future.globals.maxSize: NULL
[09:29:15.357]  - attr(*, "where")=List of 5
[09:29:15.357]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.357]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.357]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.357]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.357]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.357]  - attr(*, "resolved")= logi FALSE
[09:29:15.357]  - attr(*, "total_size")= num 280
[09:29:15.357]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.357]  - attr(*, "already-done")= logi TRUE
[09:29:15.365] - copied ‘...future.FUN’ to environment
[09:29:15.365] - copied ‘MoreArgs’ to environment
[09:29:15.366] - copied ‘...future.elements_ii’ to environment
[09:29:15.366] - copied ‘...future.seeds_ii’ to environment
[09:29:15.366] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.366] assign_globals() ... done
[09:29:15.366] requestCore(): workers = 2
[09:29:15.368] MulticoreFuture started
[09:29:15.368] - Launch lazy future ... done
[09:29:15.369] run() for ‘MulticoreFuture’ ... done
[09:29:15.369] Created future:
[09:29:15.369] plan(): Setting new future strategy stack:
[09:29:15.369] List of future strategies:
[09:29:15.369] 1. sequential:
[09:29:15.369]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.369]    - tweaked: FALSE
[09:29:15.369]    - call: NULL
[09:29:15.370] plan(): nbrOfWorkers() = 1
[09:29:15.372] plan(): Setting new future strategy stack:
[09:29:15.373] List of future strategies:
[09:29:15.373] 1. multicore:
[09:29:15.373]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.373]    - tweaked: FALSE
[09:29:15.373]    - call: plan(strategy)
[09:29:15.377] plan(): nbrOfWorkers() = 2
[09:29:15.369] MulticoreFuture:
[09:29:15.369] Label: ‘future_mapply-2’
[09:29:15.369] Expression:
[09:29:15.369] {
[09:29:15.369]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.369]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.369]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.369]         on.exit(options(oopts), add = TRUE)
[09:29:15.369]     }
[09:29:15.369]     {
[09:29:15.369]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.369]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.369]         do.call(mapply, args = args)
[09:29:15.369]     }
[09:29:15.369] }
[09:29:15.369] Lazy evaluation: FALSE
[09:29:15.369] Asynchronous evaluation: TRUE
[09:29:15.369] Local evaluation: TRUE
[09:29:15.369] Environment: R_GlobalEnv
[09:29:15.369] Capture standard output: TRUE
[09:29:15.369] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.369] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.369] Packages: <none>
[09:29:15.369] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.369] Resolved: TRUE
[09:29:15.369] Value: <not collected>
[09:29:15.369] Conditions captured: <none>
[09:29:15.369] Early signaling: FALSE
[09:29:15.369] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.369] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.378] Chunk #2 of 2 ... DONE
[09:29:15.379] Launching 2 futures (chunks) ... DONE
[09:29:15.379] Resolving 2 futures (chunks) ...
[09:29:15.379] resolve() on list ...
[09:29:15.379]  recursive: 0
[09:29:15.379]  length: 2
[09:29:15.379] 
[09:29:15.380] Future #1
[09:29:15.380] result() for MulticoreFuture ...
[09:29:15.381] result() for MulticoreFuture ...
[09:29:15.381] result() for MulticoreFuture ... done
[09:29:15.381] result() for MulticoreFuture ... done
[09:29:15.382] result() for MulticoreFuture ...
[09:29:15.382] result() for MulticoreFuture ... done
[09:29:15.382] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:15.382] - nx: 2
[09:29:15.382] - relay: TRUE
[09:29:15.383] - stdout: TRUE
[09:29:15.383] - signal: TRUE
[09:29:15.383] - resignal: FALSE
[09:29:15.383] - force: TRUE
[09:29:15.383] - relayed: [n=2] FALSE, FALSE
[09:29:15.383] - queued futures: [n=2] FALSE, FALSE
[09:29:15.384]  - until=1
[09:29:15.384]  - relaying element #1
[09:29:15.384] result() for MulticoreFuture ...
[09:29:15.384] result() for MulticoreFuture ... done
[09:29:15.384] result() for MulticoreFuture ...
[09:29:15.385] result() for MulticoreFuture ... done
[09:29:15.385] result() for MulticoreFuture ...
[09:29:15.385] result() for MulticoreFuture ... done
[09:29:15.385] result() for MulticoreFuture ...
[09:29:15.385] result() for MulticoreFuture ... done
[09:29:15.386] - relayed: [n=2] TRUE, FALSE
[09:29:15.386] - queued futures: [n=2] TRUE, FALSE
[09:29:15.386] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:15.386]  length: 1 (resolved future 1)
[09:29:15.386] Future #2
[09:29:15.386] result() for MulticoreFuture ...
[09:29:15.387] result() for MulticoreFuture ...
[09:29:15.387] result() for MulticoreFuture ... done
[09:29:15.387] result() for MulticoreFuture ... done
[09:29:15.388] result() for MulticoreFuture ...
[09:29:15.388] result() for MulticoreFuture ... done
[09:29:15.388] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:15.388] - nx: 2
[09:29:15.388] - relay: TRUE
[09:29:15.388] - stdout: TRUE
[09:29:15.389] - signal: TRUE
[09:29:15.389] - resignal: FALSE
[09:29:15.389] - force: TRUE
[09:29:15.389] - relayed: [n=2] TRUE, FALSE
[09:29:15.389] - queued futures: [n=2] TRUE, FALSE
[09:29:15.389]  - until=2
[09:29:15.389]  - relaying element #2
[09:29:15.389] result() for MulticoreFuture ...
[09:29:15.389] result() for MulticoreFuture ... done
[09:29:15.390] result() for MulticoreFuture ...
[09:29:15.390] result() for MulticoreFuture ... done
[09:29:15.390] result() for MulticoreFuture ...
[09:29:15.390] result() for MulticoreFuture ... done
[09:29:15.390] result() for MulticoreFuture ...
[09:29:15.390] result() for MulticoreFuture ... done
[09:29:15.390] - relayed: [n=2] TRUE, TRUE
[09:29:15.390] - queued futures: [n=2] TRUE, TRUE
[09:29:15.391] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:15.391]  length: 0 (resolved future 2)
[09:29:15.391] Relaying remaining futures
[09:29:15.391] signalConditionsASAP(NULL, pos=0) ...
[09:29:15.391] - nx: 2
[09:29:15.391] - relay: TRUE
[09:29:15.391] - stdout: TRUE
[09:29:15.391] - signal: TRUE
[09:29:15.391] - resignal: FALSE
[09:29:15.392] - force: TRUE
[09:29:15.392] - relayed: [n=2] TRUE, TRUE
[09:29:15.392] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:15.392] - relayed: [n=2] TRUE, TRUE
[09:29:15.392] - queued futures: [n=2] TRUE, TRUE
[09:29:15.392] signalConditionsASAP(NULL, pos=0) ... done
[09:29:15.392] resolve() on list ... DONE
[09:29:15.392] result() for MulticoreFuture ...
[09:29:15.393] result() for MulticoreFuture ... done
[09:29:15.393] result() for MulticoreFuture ...
[09:29:15.393] result() for MulticoreFuture ... done
[09:29:15.393] result() for MulticoreFuture ...
[09:29:15.396] result() for MulticoreFuture ... done
[09:29:15.396] result() for MulticoreFuture ...
[09:29:15.396] result() for MulticoreFuture ... done
[09:29:15.396]  - Number of value chunks collected: 2
[09:29:15.396] Resolving 2 futures (chunks) ... DONE
[09:29:15.397] Reducing values from 2 chunks ...
[09:29:15.397]  - Number of values collected after concatenation: 4
[09:29:15.397]  - Number of values expected: 4
[09:29:15.397] Reducing values from 2 chunks ... DONE
[09:29:15.397] future_mapply() ... DONE
[09:29:15.398] future_mapply() ...
[09:29:15.402] Number of chunks: 2
[09:29:15.403] getGlobalsAndPackagesXApply() ...
[09:29:15.403]  - future.globals: TRUE
[09:29:15.403] getGlobalsAndPackages() ...
[09:29:15.403] Searching for globals...
[09:29:15.404] - globals found: [1] ‘FUN’
[09:29:15.404] Searching for globals ... DONE
[09:29:15.404] Resolving globals: FALSE
[09:29:15.404] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:15.405] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:15.405] - globals: [1] ‘FUN’
[09:29:15.405] 
[09:29:15.405] getGlobalsAndPackages() ... DONE
[09:29:15.405]  - globals found/used: [n=1] ‘FUN’
[09:29:15.406]  - needed namespaces: [n=0] 
[09:29:15.406] Finding globals ... DONE
[09:29:15.406] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:15.406] List of 2
[09:29:15.406]  $ ...future.FUN:function (x, ...)  
[09:29:15.406]  $ MoreArgs     :List of 1
[09:29:15.406]   ..$ x: num 42
[09:29:15.406]  - attr(*, "where")=List of 2
[09:29:15.406]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:15.406]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:15.406]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.406]  - attr(*, "resolved")= logi FALSE
[09:29:15.406]  - attr(*, "total_size")= num NA
[09:29:15.410] Packages to be attached in all futures: [n=0] 
[09:29:15.410] getGlobalsAndPackagesXApply() ... DONE
[09:29:15.410] Number of futures (= number of chunks): 2
[09:29:15.410] Launching 2 futures (chunks) ...
[09:29:15.410] Chunk #1 of 2 ...
[09:29:15.410]  - Finding globals in '...' for chunk #1 ...
[09:29:15.411] getGlobalsAndPackages() ...
[09:29:15.411] Searching for globals...
[09:29:15.411] 
[09:29:15.411] Searching for globals ... DONE
[09:29:15.411] - globals: [0] <none>
[09:29:15.411] getGlobalsAndPackages() ... DONE
[09:29:15.411]    + additional globals found: [n=0] 
[09:29:15.412]    + additional namespaces needed: [n=0] 
[09:29:15.412]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:15.412]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:15.412]  - seeds: <none>
[09:29:15.412]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.412] getGlobalsAndPackages() ...
[09:29:15.412] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.412] Resolving globals: FALSE
[09:29:15.413] The total size of the 5 globals is 224 bytes (224 bytes)
[09:29:15.413] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[09:29:15.413] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.414] 
[09:29:15.414] getGlobalsAndPackages() ... DONE
[09:29:15.414] run() for ‘Future’ ...
[09:29:15.414] - state: ‘created’
[09:29:15.414] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.418] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.418] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.418]   - Field: ‘label’
[09:29:15.419]   - Field: ‘local’
[09:29:15.419]   - Field: ‘owner’
[09:29:15.419]   - Field: ‘envir’
[09:29:15.419]   - Field: ‘workers’
[09:29:15.419]   - Field: ‘packages’
[09:29:15.419]   - Field: ‘gc’
[09:29:15.419]   - Field: ‘job’
[09:29:15.419]   - Field: ‘conditions’
[09:29:15.419]   - Field: ‘expr’
[09:29:15.419]   - Field: ‘uuid’
[09:29:15.419]   - Field: ‘seed’
[09:29:15.420]   - Field: ‘version’
[09:29:15.420]   - Field: ‘result’
[09:29:15.420]   - Field: ‘asynchronous’
[09:29:15.420]   - Field: ‘calls’
[09:29:15.420]   - Field: ‘globals’
[09:29:15.420]   - Field: ‘stdout’
[09:29:15.420]   - Field: ‘earlySignal’
[09:29:15.420]   - Field: ‘lazy’
[09:29:15.420]   - Field: ‘state’
[09:29:15.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.421] - Launch lazy future ...
[09:29:15.421] Packages needed by the future expression (n = 0): <none>
[09:29:15.421] Packages needed by future strategies (n = 0): <none>
[09:29:15.421] {
[09:29:15.421]     {
[09:29:15.421]         {
[09:29:15.421]             ...future.startTime <- base::Sys.time()
[09:29:15.421]             {
[09:29:15.421]                 {
[09:29:15.421]                   {
[09:29:15.421]                     {
[09:29:15.421]                       base::local({
[09:29:15.421]                         has_future <- base::requireNamespace("future", 
[09:29:15.421]                           quietly = TRUE)
[09:29:15.421]                         if (has_future) {
[09:29:15.421]                           ns <- base::getNamespace("future")
[09:29:15.421]                           version <- ns[[".package"]][["version"]]
[09:29:15.421]                           if (is.null(version)) 
[09:29:15.421]                             version <- utils::packageVersion("future")
[09:29:15.421]                         }
[09:29:15.421]                         else {
[09:29:15.421]                           version <- NULL
[09:29:15.421]                         }
[09:29:15.421]                         if (!has_future || version < "1.8.0") {
[09:29:15.421]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.421]                             "", base::R.version$version.string), 
[09:29:15.421]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.421]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.421]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.421]                               "release", "version")], collapse = " "), 
[09:29:15.421]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.421]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.421]                             info)
[09:29:15.421]                           info <- base::paste(info, collapse = "; ")
[09:29:15.421]                           if (!has_future) {
[09:29:15.421]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.421]                               info)
[09:29:15.421]                           }
[09:29:15.421]                           else {
[09:29:15.421]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.421]                               info, version)
[09:29:15.421]                           }
[09:29:15.421]                           base::stop(msg)
[09:29:15.421]                         }
[09:29:15.421]                       })
[09:29:15.421]                     }
[09:29:15.421]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.421]                     base::options(mc.cores = 1L)
[09:29:15.421]                   }
[09:29:15.421]                   ...future.strategy.old <- future::plan("list")
[09:29:15.421]                   options(future.plan = NULL)
[09:29:15.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.421]                 }
[09:29:15.421]                 ...future.workdir <- getwd()
[09:29:15.421]             }
[09:29:15.421]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.421]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.421]         }
[09:29:15.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.421]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:15.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.421]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.421]             base::names(...future.oldOptions))
[09:29:15.421]     }
[09:29:15.421]     if (FALSE) {
[09:29:15.421]     }
[09:29:15.421]     else {
[09:29:15.421]         if (TRUE) {
[09:29:15.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.421]                 open = "w")
[09:29:15.421]         }
[09:29:15.421]         else {
[09:29:15.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.421]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.421]         }
[09:29:15.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.421]             base::sink(type = "output", split = FALSE)
[09:29:15.421]             base::close(...future.stdout)
[09:29:15.421]         }, add = TRUE)
[09:29:15.421]     }
[09:29:15.421]     ...future.frame <- base::sys.nframe()
[09:29:15.421]     ...future.conditions <- base::list()
[09:29:15.421]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.421]     if (FALSE) {
[09:29:15.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.421]     }
[09:29:15.421]     ...future.result <- base::tryCatch({
[09:29:15.421]         base::withCallingHandlers({
[09:29:15.421]             ...future.value <- base::withVisible(base::local({
[09:29:15.421]                 withCallingHandlers({
[09:29:15.421]                   {
[09:29:15.421]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.421]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.421]                       ...future.globals.maxSize)) {
[09:29:15.421]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.421]                       on.exit(options(oopts), add = TRUE)
[09:29:15.421]                     }
[09:29:15.421]                     {
[09:29:15.421]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.421]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.421]                         USE.NAMES = FALSE)
[09:29:15.421]                       do.call(mapply, args = args)
[09:29:15.421]                     }
[09:29:15.421]                   }
[09:29:15.421]                 }, immediateCondition = function(cond) {
[09:29:15.421]                   save_rds <- function (object, pathname, ...) 
[09:29:15.421]                   {
[09:29:15.421]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.421]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.421]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.421]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.421]                         fi_tmp[["mtime"]])
[09:29:15.421]                     }
[09:29:15.421]                     tryCatch({
[09:29:15.421]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.421]                     }, error = function(ex) {
[09:29:15.421]                       msg <- conditionMessage(ex)
[09:29:15.421]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.421]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.421]                         fi_tmp[["mtime"]], msg)
[09:29:15.421]                       ex$message <- msg
[09:29:15.421]                       stop(ex)
[09:29:15.421]                     })
[09:29:15.421]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.421]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.421]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.421]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.421]                       fi <- file.info(pathname)
[09:29:15.421]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.421]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.421]                         fi[["size"]], fi[["mtime"]])
[09:29:15.421]                       stop(msg)
[09:29:15.421]                     }
[09:29:15.421]                     invisible(pathname)
[09:29:15.421]                   }
[09:29:15.421]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.421]                     rootPath = tempdir()) 
[09:29:15.421]                   {
[09:29:15.421]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.421]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.421]                       tmpdir = path, fileext = ".rds")
[09:29:15.421]                     save_rds(obj, file)
[09:29:15.421]                   }
[09:29:15.421]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.421]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.421]                   {
[09:29:15.421]                     inherits <- base::inherits
[09:29:15.421]                     invokeRestart <- base::invokeRestart
[09:29:15.421]                     is.null <- base::is.null
[09:29:15.421]                     muffled <- FALSE
[09:29:15.421]                     if (inherits(cond, "message")) {
[09:29:15.421]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.421]                       if (muffled) 
[09:29:15.421]                         invokeRestart("muffleMessage")
[09:29:15.421]                     }
[09:29:15.421]                     else if (inherits(cond, "warning")) {
[09:29:15.421]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.421]                       if (muffled) 
[09:29:15.421]                         invokeRestart("muffleWarning")
[09:29:15.421]                     }
[09:29:15.421]                     else if (inherits(cond, "condition")) {
[09:29:15.421]                       if (!is.null(pattern)) {
[09:29:15.421]                         computeRestarts <- base::computeRestarts
[09:29:15.421]                         grepl <- base::grepl
[09:29:15.421]                         restarts <- computeRestarts(cond)
[09:29:15.421]                         for (restart in restarts) {
[09:29:15.421]                           name <- restart$name
[09:29:15.421]                           if (is.null(name)) 
[09:29:15.421]                             next
[09:29:15.421]                           if (!grepl(pattern, name)) 
[09:29:15.421]                             next
[09:29:15.421]                           invokeRestart(restart)
[09:29:15.421]                           muffled <- TRUE
[09:29:15.421]                           break
[09:29:15.421]                         }
[09:29:15.421]                       }
[09:29:15.421]                     }
[09:29:15.421]                     invisible(muffled)
[09:29:15.421]                   }
[09:29:15.421]                   muffleCondition(cond)
[09:29:15.421]                 })
[09:29:15.421]             }))
[09:29:15.421]             future::FutureResult(value = ...future.value$value, 
[09:29:15.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.421]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.421]                     ...future.globalenv.names))
[09:29:15.421]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.421]         }, condition = base::local({
[09:29:15.421]             c <- base::c
[09:29:15.421]             inherits <- base::inherits
[09:29:15.421]             invokeRestart <- base::invokeRestart
[09:29:15.421]             length <- base::length
[09:29:15.421]             list <- base::list
[09:29:15.421]             seq.int <- base::seq.int
[09:29:15.421]             signalCondition <- base::signalCondition
[09:29:15.421]             sys.calls <- base::sys.calls
[09:29:15.421]             `[[` <- base::`[[`
[09:29:15.421]             `+` <- base::`+`
[09:29:15.421]             `<<-` <- base::`<<-`
[09:29:15.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.421]                   3L)]
[09:29:15.421]             }
[09:29:15.421]             function(cond) {
[09:29:15.421]                 is_error <- inherits(cond, "error")
[09:29:15.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.421]                   NULL)
[09:29:15.421]                 if (is_error) {
[09:29:15.421]                   sessionInformation <- function() {
[09:29:15.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.421]                       search = base::search(), system = base::Sys.info())
[09:29:15.421]                   }
[09:29:15.421]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.421]                     cond$call), session = sessionInformation(), 
[09:29:15.421]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.421]                   signalCondition(cond)
[09:29:15.421]                 }
[09:29:15.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.421]                 "immediateCondition"))) {
[09:29:15.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.421]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.421]                   if (TRUE && !signal) {
[09:29:15.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.421]                     {
[09:29:15.421]                       inherits <- base::inherits
[09:29:15.421]                       invokeRestart <- base::invokeRestart
[09:29:15.421]                       is.null <- base::is.null
[09:29:15.421]                       muffled <- FALSE
[09:29:15.421]                       if (inherits(cond, "message")) {
[09:29:15.421]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.421]                         if (muffled) 
[09:29:15.421]                           invokeRestart("muffleMessage")
[09:29:15.421]                       }
[09:29:15.421]                       else if (inherits(cond, "warning")) {
[09:29:15.421]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.421]                         if (muffled) 
[09:29:15.421]                           invokeRestart("muffleWarning")
[09:29:15.421]                       }
[09:29:15.421]                       else if (inherits(cond, "condition")) {
[09:29:15.421]                         if (!is.null(pattern)) {
[09:29:15.421]                           computeRestarts <- base::computeRestarts
[09:29:15.421]                           grepl <- base::grepl
[09:29:15.421]                           restarts <- computeRestarts(cond)
[09:29:15.421]                           for (restart in restarts) {
[09:29:15.421]                             name <- restart$name
[09:29:15.421]                             if (is.null(name)) 
[09:29:15.421]                               next
[09:29:15.421]                             if (!grepl(pattern, name)) 
[09:29:15.421]                               next
[09:29:15.421]                             invokeRestart(restart)
[09:29:15.421]                             muffled <- TRUE
[09:29:15.421]                             break
[09:29:15.421]                           }
[09:29:15.421]                         }
[09:29:15.421]                       }
[09:29:15.421]                       invisible(muffled)
[09:29:15.421]                     }
[09:29:15.421]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.421]                   }
[09:29:15.421]                 }
[09:29:15.421]                 else {
[09:29:15.421]                   if (TRUE) {
[09:29:15.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.421]                     {
[09:29:15.421]                       inherits <- base::inherits
[09:29:15.421]                       invokeRestart <- base::invokeRestart
[09:29:15.421]                       is.null <- base::is.null
[09:29:15.421]                       muffled <- FALSE
[09:29:15.421]                       if (inherits(cond, "message")) {
[09:29:15.421]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.421]                         if (muffled) 
[09:29:15.421]                           invokeRestart("muffleMessage")
[09:29:15.421]                       }
[09:29:15.421]                       else if (inherits(cond, "warning")) {
[09:29:15.421]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.421]                         if (muffled) 
[09:29:15.421]                           invokeRestart("muffleWarning")
[09:29:15.421]                       }
[09:29:15.421]                       else if (inherits(cond, "condition")) {
[09:29:15.421]                         if (!is.null(pattern)) {
[09:29:15.421]                           computeRestarts <- base::computeRestarts
[09:29:15.421]                           grepl <- base::grepl
[09:29:15.421]                           restarts <- computeRestarts(cond)
[09:29:15.421]                           for (restart in restarts) {
[09:29:15.421]                             name <- restart$name
[09:29:15.421]                             if (is.null(name)) 
[09:29:15.421]                               next
[09:29:15.421]                             if (!grepl(pattern, name)) 
[09:29:15.421]                               next
[09:29:15.421]                             invokeRestart(restart)
[09:29:15.421]                             muffled <- TRUE
[09:29:15.421]                             break
[09:29:15.421]                           }
[09:29:15.421]                         }
[09:29:15.421]                       }
[09:29:15.421]                       invisible(muffled)
[09:29:15.421]                     }
[09:29:15.421]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.421]                   }
[09:29:15.421]                 }
[09:29:15.421]             }
[09:29:15.421]         }))
[09:29:15.421]     }, error = function(ex) {
[09:29:15.421]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.421]                 ...future.rng), started = ...future.startTime, 
[09:29:15.421]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.421]             version = "1.8"), class = "FutureResult")
[09:29:15.421]     }, finally = {
[09:29:15.421]         if (!identical(...future.workdir, getwd())) 
[09:29:15.421]             setwd(...future.workdir)
[09:29:15.421]         {
[09:29:15.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.421]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.421]             }
[09:29:15.421]             base::options(...future.oldOptions)
[09:29:15.421]             if (.Platform$OS.type == "windows") {
[09:29:15.421]                 old_names <- names(...future.oldEnvVars)
[09:29:15.421]                 envs <- base::Sys.getenv()
[09:29:15.421]                 names <- names(envs)
[09:29:15.421]                 common <- intersect(names, old_names)
[09:29:15.421]                 added <- setdiff(names, old_names)
[09:29:15.421]                 removed <- setdiff(old_names, names)
[09:29:15.421]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.421]                   envs[common]]
[09:29:15.421]                 NAMES <- toupper(changed)
[09:29:15.421]                 args <- list()
[09:29:15.421]                 for (kk in seq_along(NAMES)) {
[09:29:15.421]                   name <- changed[[kk]]
[09:29:15.421]                   NAME <- NAMES[[kk]]
[09:29:15.421]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.421]                     next
[09:29:15.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.421]                 }
[09:29:15.421]                 NAMES <- toupper(added)
[09:29:15.421]                 for (kk in seq_along(NAMES)) {
[09:29:15.421]                   name <- added[[kk]]
[09:29:15.421]                   NAME <- NAMES[[kk]]
[09:29:15.421]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.421]                     next
[09:29:15.421]                   args[[name]] <- ""
[09:29:15.421]                 }
[09:29:15.421]                 NAMES <- toupper(removed)
[09:29:15.421]                 for (kk in seq_along(NAMES)) {
[09:29:15.421]                   name <- removed[[kk]]
[09:29:15.421]                   NAME <- NAMES[[kk]]
[09:29:15.421]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.421]                     next
[09:29:15.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.421]                 }
[09:29:15.421]                 if (length(args) > 0) 
[09:29:15.421]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.421]             }
[09:29:15.421]             else {
[09:29:15.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.421]             }
[09:29:15.421]             {
[09:29:15.421]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.421]                   0L) {
[09:29:15.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.421]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.421]                   base::options(opts)
[09:29:15.421]                 }
[09:29:15.421]                 {
[09:29:15.421]                   {
[09:29:15.421]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.421]                     NULL
[09:29:15.421]                   }
[09:29:15.421]                   options(future.plan = NULL)
[09:29:15.421]                   if (is.na(NA_character_)) 
[09:29:15.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.421]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.421]                     .init = FALSE)
[09:29:15.421]                 }
[09:29:15.421]             }
[09:29:15.421]         }
[09:29:15.421]     })
[09:29:15.421]     if (TRUE) {
[09:29:15.421]         base::sink(type = "output", split = FALSE)
[09:29:15.421]         if (TRUE) {
[09:29:15.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.421]         }
[09:29:15.421]         else {
[09:29:15.421]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.421]         }
[09:29:15.421]         base::close(...future.stdout)
[09:29:15.421]         ...future.stdout <- NULL
[09:29:15.421]     }
[09:29:15.421]     ...future.result$conditions <- ...future.conditions
[09:29:15.421]     ...future.result$finished <- base::Sys.time()
[09:29:15.421]     ...future.result
[09:29:15.421] }
[09:29:15.424] assign_globals() ...
[09:29:15.424] List of 5
[09:29:15.424]  $ ...future.FUN            :function (x, ...)  
[09:29:15.424]  $ MoreArgs                 :List of 1
[09:29:15.424]   ..$ x: num 42
[09:29:15.424]  $ ...future.elements_ii    :List of 1
[09:29:15.424]   ..$ times:List of 2
[09:29:15.424]   .. ..$ : int 1
[09:29:15.424]   .. ..$ : int 2
[09:29:15.424]  $ ...future.seeds_ii       : NULL
[09:29:15.424]  $ ...future.globals.maxSize: NULL
[09:29:15.424]  - attr(*, "where")=List of 5
[09:29:15.424]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.424]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.424]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.424]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.424]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.424]  - attr(*, "resolved")= logi FALSE
[09:29:15.424]  - attr(*, "total_size")= num 224
[09:29:15.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.424]  - attr(*, "already-done")= logi TRUE
[09:29:15.432] - copied ‘...future.FUN’ to environment
[09:29:15.432] - copied ‘MoreArgs’ to environment
[09:29:15.432] - copied ‘...future.elements_ii’ to environment
[09:29:15.432] - copied ‘...future.seeds_ii’ to environment
[09:29:15.432] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.432] assign_globals() ... done
[09:29:15.433] requestCore(): workers = 2
[09:29:15.435] MulticoreFuture started
[09:29:15.436] - Launch lazy future ... done
[09:29:15.436] plan(): Setting new future strategy stack:
[09:29:15.436] run() for ‘MulticoreFuture’ ... done
[09:29:15.437] Created future:
[09:29:15.437] List of future strategies:
[09:29:15.437] 1. sequential:
[09:29:15.437]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.437]    - tweaked: FALSE
[09:29:15.437]    - call: NULL
[09:29:15.438] plan(): nbrOfWorkers() = 1
[09:29:15.441] plan(): Setting new future strategy stack:
[09:29:15.441] List of future strategies:
[09:29:15.441] 1. multicore:
[09:29:15.441]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.441]    - tweaked: FALSE
[09:29:15.441]    - call: plan(strategy)
[09:29:15.447] plan(): nbrOfWorkers() = 2
[09:29:15.437] MulticoreFuture:
[09:29:15.437] Label: ‘future_mapply-1’
[09:29:15.437] Expression:
[09:29:15.437] {
[09:29:15.437]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.437]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.437]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.437]         on.exit(options(oopts), add = TRUE)
[09:29:15.437]     }
[09:29:15.437]     {
[09:29:15.437]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.437]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.437]         do.call(mapply, args = args)
[09:29:15.437]     }
[09:29:15.437] }
[09:29:15.437] Lazy evaluation: FALSE
[09:29:15.437] Asynchronous evaluation: TRUE
[09:29:15.437] Local evaluation: TRUE
[09:29:15.437] Environment: R_GlobalEnv
[09:29:15.437] Capture standard output: TRUE
[09:29:15.437] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.437] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.437] Packages: <none>
[09:29:15.437] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.437] Resolved: TRUE
[09:29:15.437] Value: <not collected>
[09:29:15.437] Conditions captured: <none>
[09:29:15.437] Early signaling: FALSE
[09:29:15.437] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.437] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.448] Chunk #1 of 2 ... DONE
[09:29:15.448] Chunk #2 of 2 ...
[09:29:15.448]  - Finding globals in '...' for chunk #2 ...
[09:29:15.448] getGlobalsAndPackages() ...
[09:29:15.449] Searching for globals...
[09:29:15.449] 
[09:29:15.449] Searching for globals ... DONE
[09:29:15.450] - globals: [0] <none>
[09:29:15.450] getGlobalsAndPackages() ... DONE
[09:29:15.450]    + additional globals found: [n=0] 
[09:29:15.450]    + additional namespaces needed: [n=0] 
[09:29:15.450]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:15.450]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:15.450]  - seeds: <none>
[09:29:15.451]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.451] getGlobalsAndPackages() ...
[09:29:15.451] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.451] Resolving globals: FALSE
[09:29:15.452] The total size of the 5 globals is 224 bytes (224 bytes)
[09:29:15.453] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[09:29:15.453] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.453] 
[09:29:15.454] getGlobalsAndPackages() ... DONE
[09:29:15.454] run() for ‘Future’ ...
[09:29:15.454] - state: ‘created’
[09:29:15.454] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.459] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.459] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.459]   - Field: ‘label’
[09:29:15.459]   - Field: ‘local’
[09:29:15.460]   - Field: ‘owner’
[09:29:15.460]   - Field: ‘envir’
[09:29:15.460]   - Field: ‘workers’
[09:29:15.460]   - Field: ‘packages’
[09:29:15.460]   - Field: ‘gc’
[09:29:15.460]   - Field: ‘job’
[09:29:15.461]   - Field: ‘conditions’
[09:29:15.461]   - Field: ‘expr’
[09:29:15.461]   - Field: ‘uuid’
[09:29:15.461]   - Field: ‘seed’
[09:29:15.461]   - Field: ‘version’
[09:29:15.461]   - Field: ‘result’
[09:29:15.461]   - Field: ‘asynchronous’
[09:29:15.461]   - Field: ‘calls’
[09:29:15.462]   - Field: ‘globals’
[09:29:15.462]   - Field: ‘stdout’
[09:29:15.462]   - Field: ‘earlySignal’
[09:29:15.462]   - Field: ‘lazy’
[09:29:15.462]   - Field: ‘state’
[09:29:15.462] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.462] - Launch lazy future ...
[09:29:15.463] Packages needed by the future expression (n = 0): <none>
[09:29:15.463] Packages needed by future strategies (n = 0): <none>
[09:29:15.463] {
[09:29:15.463]     {
[09:29:15.463]         {
[09:29:15.463]             ...future.startTime <- base::Sys.time()
[09:29:15.463]             {
[09:29:15.463]                 {
[09:29:15.463]                   {
[09:29:15.463]                     {
[09:29:15.463]                       base::local({
[09:29:15.463]                         has_future <- base::requireNamespace("future", 
[09:29:15.463]                           quietly = TRUE)
[09:29:15.463]                         if (has_future) {
[09:29:15.463]                           ns <- base::getNamespace("future")
[09:29:15.463]                           version <- ns[[".package"]][["version"]]
[09:29:15.463]                           if (is.null(version)) 
[09:29:15.463]                             version <- utils::packageVersion("future")
[09:29:15.463]                         }
[09:29:15.463]                         else {
[09:29:15.463]                           version <- NULL
[09:29:15.463]                         }
[09:29:15.463]                         if (!has_future || version < "1.8.0") {
[09:29:15.463]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.463]                             "", base::R.version$version.string), 
[09:29:15.463]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.463]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.463]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.463]                               "release", "version")], collapse = " "), 
[09:29:15.463]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.463]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.463]                             info)
[09:29:15.463]                           info <- base::paste(info, collapse = "; ")
[09:29:15.463]                           if (!has_future) {
[09:29:15.463]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.463]                               info)
[09:29:15.463]                           }
[09:29:15.463]                           else {
[09:29:15.463]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.463]                               info, version)
[09:29:15.463]                           }
[09:29:15.463]                           base::stop(msg)
[09:29:15.463]                         }
[09:29:15.463]                       })
[09:29:15.463]                     }
[09:29:15.463]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.463]                     base::options(mc.cores = 1L)
[09:29:15.463]                   }
[09:29:15.463]                   ...future.strategy.old <- future::plan("list")
[09:29:15.463]                   options(future.plan = NULL)
[09:29:15.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.463]                 }
[09:29:15.463]                 ...future.workdir <- getwd()
[09:29:15.463]             }
[09:29:15.463]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.463]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.463]         }
[09:29:15.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.463]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:15.463]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.463]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.463]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.463]             base::names(...future.oldOptions))
[09:29:15.463]     }
[09:29:15.463]     if (FALSE) {
[09:29:15.463]     }
[09:29:15.463]     else {
[09:29:15.463]         if (TRUE) {
[09:29:15.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.463]                 open = "w")
[09:29:15.463]         }
[09:29:15.463]         else {
[09:29:15.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.463]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.463]         }
[09:29:15.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.463]             base::sink(type = "output", split = FALSE)
[09:29:15.463]             base::close(...future.stdout)
[09:29:15.463]         }, add = TRUE)
[09:29:15.463]     }
[09:29:15.463]     ...future.frame <- base::sys.nframe()
[09:29:15.463]     ...future.conditions <- base::list()
[09:29:15.463]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.463]     if (FALSE) {
[09:29:15.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.463]     }
[09:29:15.463]     ...future.result <- base::tryCatch({
[09:29:15.463]         base::withCallingHandlers({
[09:29:15.463]             ...future.value <- base::withVisible(base::local({
[09:29:15.463]                 withCallingHandlers({
[09:29:15.463]                   {
[09:29:15.463]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.463]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.463]                       ...future.globals.maxSize)) {
[09:29:15.463]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.463]                       on.exit(options(oopts), add = TRUE)
[09:29:15.463]                     }
[09:29:15.463]                     {
[09:29:15.463]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.463]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.463]                         USE.NAMES = FALSE)
[09:29:15.463]                       do.call(mapply, args = args)
[09:29:15.463]                     }
[09:29:15.463]                   }
[09:29:15.463]                 }, immediateCondition = function(cond) {
[09:29:15.463]                   save_rds <- function (object, pathname, ...) 
[09:29:15.463]                   {
[09:29:15.463]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.463]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.463]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.463]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.463]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.463]                         fi_tmp[["mtime"]])
[09:29:15.463]                     }
[09:29:15.463]                     tryCatch({
[09:29:15.463]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.463]                     }, error = function(ex) {
[09:29:15.463]                       msg <- conditionMessage(ex)
[09:29:15.463]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.463]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.463]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.463]                         fi_tmp[["mtime"]], msg)
[09:29:15.463]                       ex$message <- msg
[09:29:15.463]                       stop(ex)
[09:29:15.463]                     })
[09:29:15.463]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.463]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.463]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.463]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.463]                       fi <- file.info(pathname)
[09:29:15.463]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.463]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.463]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.463]                         fi[["size"]], fi[["mtime"]])
[09:29:15.463]                       stop(msg)
[09:29:15.463]                     }
[09:29:15.463]                     invisible(pathname)
[09:29:15.463]                   }
[09:29:15.463]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.463]                     rootPath = tempdir()) 
[09:29:15.463]                   {
[09:29:15.463]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.463]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.463]                       tmpdir = path, fileext = ".rds")
[09:29:15.463]                     save_rds(obj, file)
[09:29:15.463]                   }
[09:29:15.463]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.463]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.463]                   {
[09:29:15.463]                     inherits <- base::inherits
[09:29:15.463]                     invokeRestart <- base::invokeRestart
[09:29:15.463]                     is.null <- base::is.null
[09:29:15.463]                     muffled <- FALSE
[09:29:15.463]                     if (inherits(cond, "message")) {
[09:29:15.463]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.463]                       if (muffled) 
[09:29:15.463]                         invokeRestart("muffleMessage")
[09:29:15.463]                     }
[09:29:15.463]                     else if (inherits(cond, "warning")) {
[09:29:15.463]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.463]                       if (muffled) 
[09:29:15.463]                         invokeRestart("muffleWarning")
[09:29:15.463]                     }
[09:29:15.463]                     else if (inherits(cond, "condition")) {
[09:29:15.463]                       if (!is.null(pattern)) {
[09:29:15.463]                         computeRestarts <- base::computeRestarts
[09:29:15.463]                         grepl <- base::grepl
[09:29:15.463]                         restarts <- computeRestarts(cond)
[09:29:15.463]                         for (restart in restarts) {
[09:29:15.463]                           name <- restart$name
[09:29:15.463]                           if (is.null(name)) 
[09:29:15.463]                             next
[09:29:15.463]                           if (!grepl(pattern, name)) 
[09:29:15.463]                             next
[09:29:15.463]                           invokeRestart(restart)
[09:29:15.463]                           muffled <- TRUE
[09:29:15.463]                           break
[09:29:15.463]                         }
[09:29:15.463]                       }
[09:29:15.463]                     }
[09:29:15.463]                     invisible(muffled)
[09:29:15.463]                   }
[09:29:15.463]                   muffleCondition(cond)
[09:29:15.463]                 })
[09:29:15.463]             }))
[09:29:15.463]             future::FutureResult(value = ...future.value$value, 
[09:29:15.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.463]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.463]                     ...future.globalenv.names))
[09:29:15.463]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.463]         }, condition = base::local({
[09:29:15.463]             c <- base::c
[09:29:15.463]             inherits <- base::inherits
[09:29:15.463]             invokeRestart <- base::invokeRestart
[09:29:15.463]             length <- base::length
[09:29:15.463]             list <- base::list
[09:29:15.463]             seq.int <- base::seq.int
[09:29:15.463]             signalCondition <- base::signalCondition
[09:29:15.463]             sys.calls <- base::sys.calls
[09:29:15.463]             `[[` <- base::`[[`
[09:29:15.463]             `+` <- base::`+`
[09:29:15.463]             `<<-` <- base::`<<-`
[09:29:15.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.463]                   3L)]
[09:29:15.463]             }
[09:29:15.463]             function(cond) {
[09:29:15.463]                 is_error <- inherits(cond, "error")
[09:29:15.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.463]                   NULL)
[09:29:15.463]                 if (is_error) {
[09:29:15.463]                   sessionInformation <- function() {
[09:29:15.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.463]                       search = base::search(), system = base::Sys.info())
[09:29:15.463]                   }
[09:29:15.463]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.463]                     cond$call), session = sessionInformation(), 
[09:29:15.463]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.463]                   signalCondition(cond)
[09:29:15.463]                 }
[09:29:15.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.463]                 "immediateCondition"))) {
[09:29:15.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.463]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.463]                   if (TRUE && !signal) {
[09:29:15.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.463]                     {
[09:29:15.463]                       inherits <- base::inherits
[09:29:15.463]                       invokeRestart <- base::invokeRestart
[09:29:15.463]                       is.null <- base::is.null
[09:29:15.463]                       muffled <- FALSE
[09:29:15.463]                       if (inherits(cond, "message")) {
[09:29:15.463]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.463]                         if (muffled) 
[09:29:15.463]                           invokeRestart("muffleMessage")
[09:29:15.463]                       }
[09:29:15.463]                       else if (inherits(cond, "warning")) {
[09:29:15.463]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.463]                         if (muffled) 
[09:29:15.463]                           invokeRestart("muffleWarning")
[09:29:15.463]                       }
[09:29:15.463]                       else if (inherits(cond, "condition")) {
[09:29:15.463]                         if (!is.null(pattern)) {
[09:29:15.463]                           computeRestarts <- base::computeRestarts
[09:29:15.463]                           grepl <- base::grepl
[09:29:15.463]                           restarts <- computeRestarts(cond)
[09:29:15.463]                           for (restart in restarts) {
[09:29:15.463]                             name <- restart$name
[09:29:15.463]                             if (is.null(name)) 
[09:29:15.463]                               next
[09:29:15.463]                             if (!grepl(pattern, name)) 
[09:29:15.463]                               next
[09:29:15.463]                             invokeRestart(restart)
[09:29:15.463]                             muffled <- TRUE
[09:29:15.463]                             break
[09:29:15.463]                           }
[09:29:15.463]                         }
[09:29:15.463]                       }
[09:29:15.463]                       invisible(muffled)
[09:29:15.463]                     }
[09:29:15.463]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.463]                   }
[09:29:15.463]                 }
[09:29:15.463]                 else {
[09:29:15.463]                   if (TRUE) {
[09:29:15.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.463]                     {
[09:29:15.463]                       inherits <- base::inherits
[09:29:15.463]                       invokeRestart <- base::invokeRestart
[09:29:15.463]                       is.null <- base::is.null
[09:29:15.463]                       muffled <- FALSE
[09:29:15.463]                       if (inherits(cond, "message")) {
[09:29:15.463]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.463]                         if (muffled) 
[09:29:15.463]                           invokeRestart("muffleMessage")
[09:29:15.463]                       }
[09:29:15.463]                       else if (inherits(cond, "warning")) {
[09:29:15.463]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.463]                         if (muffled) 
[09:29:15.463]                           invokeRestart("muffleWarning")
[09:29:15.463]                       }
[09:29:15.463]                       else if (inherits(cond, "condition")) {
[09:29:15.463]                         if (!is.null(pattern)) {
[09:29:15.463]                           computeRestarts <- base::computeRestarts
[09:29:15.463]                           grepl <- base::grepl
[09:29:15.463]                           restarts <- computeRestarts(cond)
[09:29:15.463]                           for (restart in restarts) {
[09:29:15.463]                             name <- restart$name
[09:29:15.463]                             if (is.null(name)) 
[09:29:15.463]                               next
[09:29:15.463]                             if (!grepl(pattern, name)) 
[09:29:15.463]                               next
[09:29:15.463]                             invokeRestart(restart)
[09:29:15.463]                             muffled <- TRUE
[09:29:15.463]                             break
[09:29:15.463]                           }
[09:29:15.463]                         }
[09:29:15.463]                       }
[09:29:15.463]                       invisible(muffled)
[09:29:15.463]                     }
[09:29:15.463]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.463]                   }
[09:29:15.463]                 }
[09:29:15.463]             }
[09:29:15.463]         }))
[09:29:15.463]     }, error = function(ex) {
[09:29:15.463]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.463]                 ...future.rng), started = ...future.startTime, 
[09:29:15.463]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.463]             version = "1.8"), class = "FutureResult")
[09:29:15.463]     }, finally = {
[09:29:15.463]         if (!identical(...future.workdir, getwd())) 
[09:29:15.463]             setwd(...future.workdir)
[09:29:15.463]         {
[09:29:15.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.463]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.463]             }
[09:29:15.463]             base::options(...future.oldOptions)
[09:29:15.463]             if (.Platform$OS.type == "windows") {
[09:29:15.463]                 old_names <- names(...future.oldEnvVars)
[09:29:15.463]                 envs <- base::Sys.getenv()
[09:29:15.463]                 names <- names(envs)
[09:29:15.463]                 common <- intersect(names, old_names)
[09:29:15.463]                 added <- setdiff(names, old_names)
[09:29:15.463]                 removed <- setdiff(old_names, names)
[09:29:15.463]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.463]                   envs[common]]
[09:29:15.463]                 NAMES <- toupper(changed)
[09:29:15.463]                 args <- list()
[09:29:15.463]                 for (kk in seq_along(NAMES)) {
[09:29:15.463]                   name <- changed[[kk]]
[09:29:15.463]                   NAME <- NAMES[[kk]]
[09:29:15.463]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.463]                     next
[09:29:15.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.463]                 }
[09:29:15.463]                 NAMES <- toupper(added)
[09:29:15.463]                 for (kk in seq_along(NAMES)) {
[09:29:15.463]                   name <- added[[kk]]
[09:29:15.463]                   NAME <- NAMES[[kk]]
[09:29:15.463]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.463]                     next
[09:29:15.463]                   args[[name]] <- ""
[09:29:15.463]                 }
[09:29:15.463]                 NAMES <- toupper(removed)
[09:29:15.463]                 for (kk in seq_along(NAMES)) {
[09:29:15.463]                   name <- removed[[kk]]
[09:29:15.463]                   NAME <- NAMES[[kk]]
[09:29:15.463]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.463]                     next
[09:29:15.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.463]                 }
[09:29:15.463]                 if (length(args) > 0) 
[09:29:15.463]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.463]             }
[09:29:15.463]             else {
[09:29:15.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.463]             }
[09:29:15.463]             {
[09:29:15.463]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.463]                   0L) {
[09:29:15.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.463]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.463]                   base::options(opts)
[09:29:15.463]                 }
[09:29:15.463]                 {
[09:29:15.463]                   {
[09:29:15.463]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.463]                     NULL
[09:29:15.463]                   }
[09:29:15.463]                   options(future.plan = NULL)
[09:29:15.463]                   if (is.na(NA_character_)) 
[09:29:15.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.463]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.463]                     .init = FALSE)
[09:29:15.463]                 }
[09:29:15.463]             }
[09:29:15.463]         }
[09:29:15.463]     })
[09:29:15.463]     if (TRUE) {
[09:29:15.463]         base::sink(type = "output", split = FALSE)
[09:29:15.463]         if (TRUE) {
[09:29:15.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.463]         }
[09:29:15.463]         else {
[09:29:15.463]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.463]         }
[09:29:15.463]         base::close(...future.stdout)
[09:29:15.463]         ...future.stdout <- NULL
[09:29:15.463]     }
[09:29:15.463]     ...future.result$conditions <- ...future.conditions
[09:29:15.463]     ...future.result$finished <- base::Sys.time()
[09:29:15.463]     ...future.result
[09:29:15.463] }
[09:29:15.467] assign_globals() ...
[09:29:15.467] List of 5
[09:29:15.467]  $ ...future.FUN            :function (x, ...)  
[09:29:15.467]  $ MoreArgs                 :List of 1
[09:29:15.467]   ..$ x: num 42
[09:29:15.467]  $ ...future.elements_ii    :List of 1
[09:29:15.467]   ..$ times:List of 2
[09:29:15.467]   .. ..$ : int 3
[09:29:15.467]   .. ..$ : int 4
[09:29:15.467]  $ ...future.seeds_ii       : NULL
[09:29:15.467]  $ ...future.globals.maxSize: NULL
[09:29:15.467]  - attr(*, "where")=List of 5
[09:29:15.467]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.467]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.467]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.467]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.467]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.467]  - attr(*, "resolved")= logi FALSE
[09:29:15.467]  - attr(*, "total_size")= num 224
[09:29:15.467]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.467]  - attr(*, "already-done")= logi TRUE
[09:29:15.475] - copied ‘...future.FUN’ to environment
[09:29:15.475] - copied ‘MoreArgs’ to environment
[09:29:15.475] - copied ‘...future.elements_ii’ to environment
[09:29:15.475] - copied ‘...future.seeds_ii’ to environment
[09:29:15.475] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.475] assign_globals() ... done
[09:29:15.476] requestCore(): workers = 2
[09:29:15.478] MulticoreFuture started
[09:29:15.478] - Launch lazy future ... done
[09:29:15.479] run() for ‘MulticoreFuture’ ... done
[09:29:15.479] Created future:
[09:29:15.479] plan(): Setting new future strategy stack:
[09:29:15.479] List of future strategies:
[09:29:15.479] 1. sequential:
[09:29:15.479]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.479]    - tweaked: FALSE
[09:29:15.479]    - call: NULL
[09:29:15.480] plan(): nbrOfWorkers() = 1
[09:29:15.482] plan(): Setting new future strategy stack:
[09:29:15.483] List of future strategies:
[09:29:15.483] 1. multicore:
[09:29:15.483]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.483]    - tweaked: FALSE
[09:29:15.483]    - call: plan(strategy)
[09:29:15.479] MulticoreFuture:
[09:29:15.479] Label: ‘future_mapply-2’
[09:29:15.479] Expression:
[09:29:15.479] {
[09:29:15.479]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.479]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.479]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.479]         on.exit(options(oopts), add = TRUE)
[09:29:15.479]     }
[09:29:15.479]     {
[09:29:15.479]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.479]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.479]         do.call(mapply, args = args)
[09:29:15.479]     }
[09:29:15.479] }
[09:29:15.479] Lazy evaluation: FALSE
[09:29:15.479] Asynchronous evaluation: TRUE
[09:29:15.479] Local evaluation: TRUE
[09:29:15.479] Environment: R_GlobalEnv
[09:29:15.479] Capture standard output: TRUE
[09:29:15.479] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.479] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.479] Packages: <none>
[09:29:15.479] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.479] Resolved: FALSE
[09:29:15.479] Value: <not collected>
[09:29:15.479] Conditions captured: <none>
[09:29:15.479] Early signaling: FALSE
[09:29:15.479] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.479] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.492] Chunk #2 of 2 ... DONE
[09:29:15.492] Launching 2 futures (chunks) ... DONE
[09:29:15.492] Resolving 2 futures (chunks) ...
[09:29:15.492] resolve() on list ...
[09:29:15.492]  recursive: 0
[09:29:15.493]  length: 2
[09:29:15.493] 
[09:29:15.493] plan(): nbrOfWorkers() = 2
[09:29:15.493] Future #1
[09:29:15.493] result() for MulticoreFuture ...
[09:29:15.498] result() for MulticoreFuture ...
[09:29:15.498] result() for MulticoreFuture ... done
[09:29:15.498] result() for MulticoreFuture ... done
[09:29:15.499] result() for MulticoreFuture ...
[09:29:15.499] result() for MulticoreFuture ... done
[09:29:15.499] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:15.500] - nx: 2
[09:29:15.500] - relay: TRUE
[09:29:15.500] - stdout: TRUE
[09:29:15.501] - signal: TRUE
[09:29:15.501] - resignal: FALSE
[09:29:15.501] - force: TRUE
[09:29:15.501] - relayed: [n=2] FALSE, FALSE
[09:29:15.502] - queued futures: [n=2] FALSE, FALSE
[09:29:15.502]  - until=1
[09:29:15.502]  - relaying element #1
[09:29:15.502] result() for MulticoreFuture ...
[09:29:15.503] result() for MulticoreFuture ... done
[09:29:15.503] result() for MulticoreFuture ...
[09:29:15.503] result() for MulticoreFuture ... done
[09:29:15.504] result() for MulticoreFuture ...
[09:29:15.504] result() for MulticoreFuture ... done
[09:29:15.504] result() for MulticoreFuture ...
[09:29:15.504] result() for MulticoreFuture ... done
[09:29:15.504] - relayed: [n=2] TRUE, FALSE
[09:29:15.505] - queued futures: [n=2] TRUE, FALSE
[09:29:15.505] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:15.505]  length: 1 (resolved future 1)
[09:29:15.506] Future #2
[09:29:15.506] result() for MulticoreFuture ...
[09:29:15.506] result() for MulticoreFuture ...
[09:29:15.507] result() for MulticoreFuture ... done
[09:29:15.507] result() for MulticoreFuture ... done
[09:29:15.507] result() for MulticoreFuture ...
[09:29:15.507] result() for MulticoreFuture ... done
[09:29:15.507] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:15.507] - nx: 2
[09:29:15.507] - relay: TRUE
[09:29:15.508] - stdout: TRUE
[09:29:15.508] - signal: TRUE
[09:29:15.508] - resignal: FALSE
[09:29:15.508] - force: TRUE
[09:29:15.508] - relayed: [n=2] TRUE, FALSE
[09:29:15.508] - queued futures: [n=2] TRUE, FALSE
[09:29:15.508]  - until=2
[09:29:15.508]  - relaying element #2
[09:29:15.508] result() for MulticoreFuture ...
[09:29:15.509] result() for MulticoreFuture ... done
[09:29:15.509] result() for MulticoreFuture ...
[09:29:15.509] result() for MulticoreFuture ... done
[09:29:15.509] result() for MulticoreFuture ...
[09:29:15.509] result() for MulticoreFuture ... done
[09:29:15.509] result() for MulticoreFuture ...
[09:29:15.509] result() for MulticoreFuture ... done
[09:29:15.509] - relayed: [n=2] TRUE, TRUE
[09:29:15.510] - queued futures: [n=2] TRUE, TRUE
[09:29:15.510] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:15.510]  length: 0 (resolved future 2)
[09:29:15.510] Relaying remaining futures
[09:29:15.510] signalConditionsASAP(NULL, pos=0) ...
[09:29:15.510] - nx: 2
[09:29:15.510] - relay: TRUE
[09:29:15.510] - stdout: TRUE
[09:29:15.510] - signal: TRUE
[09:29:15.511] - resignal: FALSE
[09:29:15.511] - force: TRUE
[09:29:15.511] - relayed: [n=2] TRUE, TRUE
[09:29:15.511] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:15.511] - relayed: [n=2] TRUE, TRUE
[09:29:15.511] - queued futures: [n=2] TRUE, TRUE
[09:29:15.511] signalConditionsASAP(NULL, pos=0) ... done
[09:29:15.511] resolve() on list ... DONE
[09:29:15.511] result() for MulticoreFuture ...
[09:29:15.512] result() for MulticoreFuture ... done
[09:29:15.512] result() for MulticoreFuture ...
[09:29:15.512] result() for MulticoreFuture ... done
[09:29:15.512] result() for MulticoreFuture ...
[09:29:15.512] result() for MulticoreFuture ... done
[09:29:15.512] result() for MulticoreFuture ...
[09:29:15.512] result() for MulticoreFuture ... done
[09:29:15.512]  - Number of value chunks collected: 2
[09:29:15.512] Resolving 2 futures (chunks) ... DONE
[09:29:15.513] Reducing values from 2 chunks ...
[09:29:15.513]  - Number of values collected after concatenation: 4
[09:29:15.513]  - Number of values expected: 4
[09:29:15.513] Reducing values from 2 chunks ... DONE
[09:29:15.513] future_mapply() ... DONE
[09:29:15.513] future_mapply() ...
[09:29:15.517] Number of chunks: 2
[09:29:15.517] getGlobalsAndPackagesXApply() ...
[09:29:15.517]  - future.globals: TRUE
[09:29:15.518] getGlobalsAndPackages() ...
[09:29:15.518] Searching for globals...
[09:29:15.519] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[09:29:15.519] Searching for globals ... DONE
[09:29:15.519] Resolving globals: FALSE
[09:29:15.520] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[09:29:15.520] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[09:29:15.520] - globals: [1] ‘FUN’
[09:29:15.520] 
[09:29:15.521] getGlobalsAndPackages() ... DONE
[09:29:15.521]  - globals found/used: [n=1] ‘FUN’
[09:29:15.521]  - needed namespaces: [n=0] 
[09:29:15.521] Finding globals ... DONE
[09:29:15.521] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:15.521] List of 2
[09:29:15.521]  $ ...future.FUN:function (x, y)  
[09:29:15.521]  $ MoreArgs     : NULL
[09:29:15.521]  - attr(*, "where")=List of 2
[09:29:15.521]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:15.521]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:15.521]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.521]  - attr(*, "resolved")= logi FALSE
[09:29:15.521]  - attr(*, "total_size")= num NA
[09:29:15.524] Packages to be attached in all futures: [n=0] 
[09:29:15.524] getGlobalsAndPackagesXApply() ... DONE
[09:29:15.524] Number of futures (= number of chunks): 2
[09:29:15.524] Launching 2 futures (chunks) ...
[09:29:15.524] Chunk #1 of 2 ...
[09:29:15.525]  - Finding globals in '...' for chunk #1 ...
[09:29:15.525] getGlobalsAndPackages() ...
[09:29:15.525] Searching for globals...
[09:29:15.525] 
[09:29:15.525] Searching for globals ... DONE
[09:29:15.525] - globals: [0] <none>
[09:29:15.525] getGlobalsAndPackages() ... DONE
[09:29:15.526]    + additional globals found: [n=0] 
[09:29:15.526]    + additional namespaces needed: [n=0] 
[09:29:15.526]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:15.526]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:15.526]  - seeds: <none>
[09:29:15.526]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.526] getGlobalsAndPackages() ...
[09:29:15.526] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.526] Resolving globals: FALSE
[09:29:15.527] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[09:29:15.527] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.527] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.528] 
[09:29:15.528] getGlobalsAndPackages() ... DONE
[09:29:15.528] run() for ‘Future’ ...
[09:29:15.528] - state: ‘created’
[09:29:15.528] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.534] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.534] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.534]   - Field: ‘label’
[09:29:15.534]   - Field: ‘local’
[09:29:15.534]   - Field: ‘owner’
[09:29:15.534]   - Field: ‘envir’
[09:29:15.534]   - Field: ‘workers’
[09:29:15.535]   - Field: ‘packages’
[09:29:15.535]   - Field: ‘gc’
[09:29:15.535]   - Field: ‘job’
[09:29:15.535]   - Field: ‘conditions’
[09:29:15.535]   - Field: ‘expr’
[09:29:15.535]   - Field: ‘uuid’
[09:29:15.535]   - Field: ‘seed’
[09:29:15.535]   - Field: ‘version’
[09:29:15.535]   - Field: ‘result’
[09:29:15.535]   - Field: ‘asynchronous’
[09:29:15.536]   - Field: ‘calls’
[09:29:15.536]   - Field: ‘globals’
[09:29:15.536]   - Field: ‘stdout’
[09:29:15.536]   - Field: ‘earlySignal’
[09:29:15.536]   - Field: ‘lazy’
[09:29:15.536]   - Field: ‘state’
[09:29:15.536] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.536] - Launch lazy future ...
[09:29:15.537] Packages needed by the future expression (n = 0): <none>
[09:29:15.537] Packages needed by future strategies (n = 0): <none>
[09:29:15.537] {
[09:29:15.537]     {
[09:29:15.537]         {
[09:29:15.537]             ...future.startTime <- base::Sys.time()
[09:29:15.537]             {
[09:29:15.537]                 {
[09:29:15.537]                   {
[09:29:15.537]                     {
[09:29:15.537]                       base::local({
[09:29:15.537]                         has_future <- base::requireNamespace("future", 
[09:29:15.537]                           quietly = TRUE)
[09:29:15.537]                         if (has_future) {
[09:29:15.537]                           ns <- base::getNamespace("future")
[09:29:15.537]                           version <- ns[[".package"]][["version"]]
[09:29:15.537]                           if (is.null(version)) 
[09:29:15.537]                             version <- utils::packageVersion("future")
[09:29:15.537]                         }
[09:29:15.537]                         else {
[09:29:15.537]                           version <- NULL
[09:29:15.537]                         }
[09:29:15.537]                         if (!has_future || version < "1.8.0") {
[09:29:15.537]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.537]                             "", base::R.version$version.string), 
[09:29:15.537]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.537]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.537]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.537]                               "release", "version")], collapse = " "), 
[09:29:15.537]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.537]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.537]                             info)
[09:29:15.537]                           info <- base::paste(info, collapse = "; ")
[09:29:15.537]                           if (!has_future) {
[09:29:15.537]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.537]                               info)
[09:29:15.537]                           }
[09:29:15.537]                           else {
[09:29:15.537]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.537]                               info, version)
[09:29:15.537]                           }
[09:29:15.537]                           base::stop(msg)
[09:29:15.537]                         }
[09:29:15.537]                       })
[09:29:15.537]                     }
[09:29:15.537]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.537]                     base::options(mc.cores = 1L)
[09:29:15.537]                   }
[09:29:15.537]                   ...future.strategy.old <- future::plan("list")
[09:29:15.537]                   options(future.plan = NULL)
[09:29:15.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.537]                 }
[09:29:15.537]                 ...future.workdir <- getwd()
[09:29:15.537]             }
[09:29:15.537]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.537]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.537]         }
[09:29:15.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.537]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:15.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.537]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.537]             base::names(...future.oldOptions))
[09:29:15.537]     }
[09:29:15.537]     if (FALSE) {
[09:29:15.537]     }
[09:29:15.537]     else {
[09:29:15.537]         if (TRUE) {
[09:29:15.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.537]                 open = "w")
[09:29:15.537]         }
[09:29:15.537]         else {
[09:29:15.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.537]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.537]         }
[09:29:15.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.537]             base::sink(type = "output", split = FALSE)
[09:29:15.537]             base::close(...future.stdout)
[09:29:15.537]         }, add = TRUE)
[09:29:15.537]     }
[09:29:15.537]     ...future.frame <- base::sys.nframe()
[09:29:15.537]     ...future.conditions <- base::list()
[09:29:15.537]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.537]     if (FALSE) {
[09:29:15.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.537]     }
[09:29:15.537]     ...future.result <- base::tryCatch({
[09:29:15.537]         base::withCallingHandlers({
[09:29:15.537]             ...future.value <- base::withVisible(base::local({
[09:29:15.537]                 withCallingHandlers({
[09:29:15.537]                   {
[09:29:15.537]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.537]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.537]                       ...future.globals.maxSize)) {
[09:29:15.537]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.537]                       on.exit(options(oopts), add = TRUE)
[09:29:15.537]                     }
[09:29:15.537]                     {
[09:29:15.537]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.537]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.537]                         USE.NAMES = FALSE)
[09:29:15.537]                       do.call(mapply, args = args)
[09:29:15.537]                     }
[09:29:15.537]                   }
[09:29:15.537]                 }, immediateCondition = function(cond) {
[09:29:15.537]                   save_rds <- function (object, pathname, ...) 
[09:29:15.537]                   {
[09:29:15.537]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.537]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.537]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.537]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.537]                         fi_tmp[["mtime"]])
[09:29:15.537]                     }
[09:29:15.537]                     tryCatch({
[09:29:15.537]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.537]                     }, error = function(ex) {
[09:29:15.537]                       msg <- conditionMessage(ex)
[09:29:15.537]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.537]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.537]                         fi_tmp[["mtime"]], msg)
[09:29:15.537]                       ex$message <- msg
[09:29:15.537]                       stop(ex)
[09:29:15.537]                     })
[09:29:15.537]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.537]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.537]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.537]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.537]                       fi <- file.info(pathname)
[09:29:15.537]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.537]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.537]                         fi[["size"]], fi[["mtime"]])
[09:29:15.537]                       stop(msg)
[09:29:15.537]                     }
[09:29:15.537]                     invisible(pathname)
[09:29:15.537]                   }
[09:29:15.537]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.537]                     rootPath = tempdir()) 
[09:29:15.537]                   {
[09:29:15.537]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.537]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.537]                       tmpdir = path, fileext = ".rds")
[09:29:15.537]                     save_rds(obj, file)
[09:29:15.537]                   }
[09:29:15.537]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.537]                   {
[09:29:15.537]                     inherits <- base::inherits
[09:29:15.537]                     invokeRestart <- base::invokeRestart
[09:29:15.537]                     is.null <- base::is.null
[09:29:15.537]                     muffled <- FALSE
[09:29:15.537]                     if (inherits(cond, "message")) {
[09:29:15.537]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.537]                       if (muffled) 
[09:29:15.537]                         invokeRestart("muffleMessage")
[09:29:15.537]                     }
[09:29:15.537]                     else if (inherits(cond, "warning")) {
[09:29:15.537]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.537]                       if (muffled) 
[09:29:15.537]                         invokeRestart("muffleWarning")
[09:29:15.537]                     }
[09:29:15.537]                     else if (inherits(cond, "condition")) {
[09:29:15.537]                       if (!is.null(pattern)) {
[09:29:15.537]                         computeRestarts <- base::computeRestarts
[09:29:15.537]                         grepl <- base::grepl
[09:29:15.537]                         restarts <- computeRestarts(cond)
[09:29:15.537]                         for (restart in restarts) {
[09:29:15.537]                           name <- restart$name
[09:29:15.537]                           if (is.null(name)) 
[09:29:15.537]                             next
[09:29:15.537]                           if (!grepl(pattern, name)) 
[09:29:15.537]                             next
[09:29:15.537]                           invokeRestart(restart)
[09:29:15.537]                           muffled <- TRUE
[09:29:15.537]                           break
[09:29:15.537]                         }
[09:29:15.537]                       }
[09:29:15.537]                     }
[09:29:15.537]                     invisible(muffled)
[09:29:15.537]                   }
[09:29:15.537]                   muffleCondition(cond)
[09:29:15.537]                 })
[09:29:15.537]             }))
[09:29:15.537]             future::FutureResult(value = ...future.value$value, 
[09:29:15.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.537]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.537]                     ...future.globalenv.names))
[09:29:15.537]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.537]         }, condition = base::local({
[09:29:15.537]             c <- base::c
[09:29:15.537]             inherits <- base::inherits
[09:29:15.537]             invokeRestart <- base::invokeRestart
[09:29:15.537]             length <- base::length
[09:29:15.537]             list <- base::list
[09:29:15.537]             seq.int <- base::seq.int
[09:29:15.537]             signalCondition <- base::signalCondition
[09:29:15.537]             sys.calls <- base::sys.calls
[09:29:15.537]             `[[` <- base::`[[`
[09:29:15.537]             `+` <- base::`+`
[09:29:15.537]             `<<-` <- base::`<<-`
[09:29:15.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.537]                   3L)]
[09:29:15.537]             }
[09:29:15.537]             function(cond) {
[09:29:15.537]                 is_error <- inherits(cond, "error")
[09:29:15.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.537]                   NULL)
[09:29:15.537]                 if (is_error) {
[09:29:15.537]                   sessionInformation <- function() {
[09:29:15.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.537]                       search = base::search(), system = base::Sys.info())
[09:29:15.537]                   }
[09:29:15.537]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.537]                     cond$call), session = sessionInformation(), 
[09:29:15.537]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.537]                   signalCondition(cond)
[09:29:15.537]                 }
[09:29:15.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.537]                 "immediateCondition"))) {
[09:29:15.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.537]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.537]                   if (TRUE && !signal) {
[09:29:15.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.537]                     {
[09:29:15.537]                       inherits <- base::inherits
[09:29:15.537]                       invokeRestart <- base::invokeRestart
[09:29:15.537]                       is.null <- base::is.null
[09:29:15.537]                       muffled <- FALSE
[09:29:15.537]                       if (inherits(cond, "message")) {
[09:29:15.537]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.537]                         if (muffled) 
[09:29:15.537]                           invokeRestart("muffleMessage")
[09:29:15.537]                       }
[09:29:15.537]                       else if (inherits(cond, "warning")) {
[09:29:15.537]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.537]                         if (muffled) 
[09:29:15.537]                           invokeRestart("muffleWarning")
[09:29:15.537]                       }
[09:29:15.537]                       else if (inherits(cond, "condition")) {
[09:29:15.537]                         if (!is.null(pattern)) {
[09:29:15.537]                           computeRestarts <- base::computeRestarts
[09:29:15.537]                           grepl <- base::grepl
[09:29:15.537]                           restarts <- computeRestarts(cond)
[09:29:15.537]                           for (restart in restarts) {
[09:29:15.537]                             name <- restart$name
[09:29:15.537]                             if (is.null(name)) 
[09:29:15.537]                               next
[09:29:15.537]                             if (!grepl(pattern, name)) 
[09:29:15.537]                               next
[09:29:15.537]                             invokeRestart(restart)
[09:29:15.537]                             muffled <- TRUE
[09:29:15.537]                             break
[09:29:15.537]                           }
[09:29:15.537]                         }
[09:29:15.537]                       }
[09:29:15.537]                       invisible(muffled)
[09:29:15.537]                     }
[09:29:15.537]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.537]                   }
[09:29:15.537]                 }
[09:29:15.537]                 else {
[09:29:15.537]                   if (TRUE) {
[09:29:15.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.537]                     {
[09:29:15.537]                       inherits <- base::inherits
[09:29:15.537]                       invokeRestart <- base::invokeRestart
[09:29:15.537]                       is.null <- base::is.null
[09:29:15.537]                       muffled <- FALSE
[09:29:15.537]                       if (inherits(cond, "message")) {
[09:29:15.537]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.537]                         if (muffled) 
[09:29:15.537]                           invokeRestart("muffleMessage")
[09:29:15.537]                       }
[09:29:15.537]                       else if (inherits(cond, "warning")) {
[09:29:15.537]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.537]                         if (muffled) 
[09:29:15.537]                           invokeRestart("muffleWarning")
[09:29:15.537]                       }
[09:29:15.537]                       else if (inherits(cond, "condition")) {
[09:29:15.537]                         if (!is.null(pattern)) {
[09:29:15.537]                           computeRestarts <- base::computeRestarts
[09:29:15.537]                           grepl <- base::grepl
[09:29:15.537]                           restarts <- computeRestarts(cond)
[09:29:15.537]                           for (restart in restarts) {
[09:29:15.537]                             name <- restart$name
[09:29:15.537]                             if (is.null(name)) 
[09:29:15.537]                               next
[09:29:15.537]                             if (!grepl(pattern, name)) 
[09:29:15.537]                               next
[09:29:15.537]                             invokeRestart(restart)
[09:29:15.537]                             muffled <- TRUE
[09:29:15.537]                             break
[09:29:15.537]                           }
[09:29:15.537]                         }
[09:29:15.537]                       }
[09:29:15.537]                       invisible(muffled)
[09:29:15.537]                     }
[09:29:15.537]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.537]                   }
[09:29:15.537]                 }
[09:29:15.537]             }
[09:29:15.537]         }))
[09:29:15.537]     }, error = function(ex) {
[09:29:15.537]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.537]                 ...future.rng), started = ...future.startTime, 
[09:29:15.537]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.537]             version = "1.8"), class = "FutureResult")
[09:29:15.537]     }, finally = {
[09:29:15.537]         if (!identical(...future.workdir, getwd())) 
[09:29:15.537]             setwd(...future.workdir)
[09:29:15.537]         {
[09:29:15.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.537]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.537]             }
[09:29:15.537]             base::options(...future.oldOptions)
[09:29:15.537]             if (.Platform$OS.type == "windows") {
[09:29:15.537]                 old_names <- names(...future.oldEnvVars)
[09:29:15.537]                 envs <- base::Sys.getenv()
[09:29:15.537]                 names <- names(envs)
[09:29:15.537]                 common <- intersect(names, old_names)
[09:29:15.537]                 added <- setdiff(names, old_names)
[09:29:15.537]                 removed <- setdiff(old_names, names)
[09:29:15.537]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.537]                   envs[common]]
[09:29:15.537]                 NAMES <- toupper(changed)
[09:29:15.537]                 args <- list()
[09:29:15.537]                 for (kk in seq_along(NAMES)) {
[09:29:15.537]                   name <- changed[[kk]]
[09:29:15.537]                   NAME <- NAMES[[kk]]
[09:29:15.537]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.537]                     next
[09:29:15.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.537]                 }
[09:29:15.537]                 NAMES <- toupper(added)
[09:29:15.537]                 for (kk in seq_along(NAMES)) {
[09:29:15.537]                   name <- added[[kk]]
[09:29:15.537]                   NAME <- NAMES[[kk]]
[09:29:15.537]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.537]                     next
[09:29:15.537]                   args[[name]] <- ""
[09:29:15.537]                 }
[09:29:15.537]                 NAMES <- toupper(removed)
[09:29:15.537]                 for (kk in seq_along(NAMES)) {
[09:29:15.537]                   name <- removed[[kk]]
[09:29:15.537]                   NAME <- NAMES[[kk]]
[09:29:15.537]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.537]                     next
[09:29:15.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.537]                 }
[09:29:15.537]                 if (length(args) > 0) 
[09:29:15.537]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.537]             }
[09:29:15.537]             else {
[09:29:15.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.537]             }
[09:29:15.537]             {
[09:29:15.537]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.537]                   0L) {
[09:29:15.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.537]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.537]                   base::options(opts)
[09:29:15.537]                 }
[09:29:15.537]                 {
[09:29:15.537]                   {
[09:29:15.537]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.537]                     NULL
[09:29:15.537]                   }
[09:29:15.537]                   options(future.plan = NULL)
[09:29:15.537]                   if (is.na(NA_character_)) 
[09:29:15.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.537]                     .init = FALSE)
[09:29:15.537]                 }
[09:29:15.537]             }
[09:29:15.537]         }
[09:29:15.537]     })
[09:29:15.537]     if (TRUE) {
[09:29:15.537]         base::sink(type = "output", split = FALSE)
[09:29:15.537]         if (TRUE) {
[09:29:15.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.537]         }
[09:29:15.537]         else {
[09:29:15.537]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.537]         }
[09:29:15.537]         base::close(...future.stdout)
[09:29:15.537]         ...future.stdout <- NULL
[09:29:15.537]     }
[09:29:15.537]     ...future.result$conditions <- ...future.conditions
[09:29:15.537]     ...future.result$finished <- base::Sys.time()
[09:29:15.537]     ...future.result
[09:29:15.537] }
[09:29:15.539] assign_globals() ...
[09:29:15.540] List of 5
[09:29:15.540]  $ ...future.FUN            :function (x, y)  
[09:29:15.540]  $ MoreArgs                 : NULL
[09:29:15.540]  $ ...future.elements_ii    :List of 2
[09:29:15.540]   ..$ :List of 1
[09:29:15.540]   .. ..$ a: num 1
[09:29:15.540]   ..$ :List of 1
[09:29:15.540]   .. ..$ A: num 10
[09:29:15.540]  $ ...future.seeds_ii       : NULL
[09:29:15.540]  $ ...future.globals.maxSize: NULL
[09:29:15.540]  - attr(*, "where")=List of 5
[09:29:15.540]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.540]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.540]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.540]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.540]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.540]  - attr(*, "resolved")= logi FALSE
[09:29:15.540]  - attr(*, "total_size")= num 2088
[09:29:15.540]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.540]  - attr(*, "already-done")= logi TRUE
[09:29:15.544] - reassign environment for ‘...future.FUN’
[09:29:15.545] - copied ‘...future.FUN’ to environment
[09:29:15.545] - copied ‘MoreArgs’ to environment
[09:29:15.545] - copied ‘...future.elements_ii’ to environment
[09:29:15.545] - copied ‘...future.seeds_ii’ to environment
[09:29:15.545] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.545] assign_globals() ... done
[09:29:15.545] requestCore(): workers = 2
[09:29:15.547] MulticoreFuture started
[09:29:15.547] - Launch lazy future ... done
[09:29:15.547] run() for ‘MulticoreFuture’ ... done
[09:29:15.548] Created future:
[09:29:15.548] plan(): Setting new future strategy stack:
[09:29:15.548] List of future strategies:
[09:29:15.548] 1. sequential:
[09:29:15.548]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.548]    - tweaked: FALSE
[09:29:15.548]    - call: NULL
[09:29:15.549] plan(): nbrOfWorkers() = 1
[09:29:15.551] plan(): Setting new future strategy stack:
[09:29:15.551] List of future strategies:
[09:29:15.551] 1. multicore:
[09:29:15.551]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.551]    - tweaked: FALSE
[09:29:15.551]    - call: plan(strategy)
[09:29:15.556] plan(): nbrOfWorkers() = 2
[09:29:15.548] MulticoreFuture:
[09:29:15.548] Label: ‘future_mapply-1’
[09:29:15.548] Expression:
[09:29:15.548] {
[09:29:15.548]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.548]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.548]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.548]         on.exit(options(oopts), add = TRUE)
[09:29:15.548]     }
[09:29:15.548]     {
[09:29:15.548]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.548]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.548]         do.call(mapply, args = args)
[09:29:15.548]     }
[09:29:15.548] }
[09:29:15.548] Lazy evaluation: FALSE
[09:29:15.548] Asynchronous evaluation: TRUE
[09:29:15.548] Local evaluation: TRUE
[09:29:15.548] Environment: R_GlobalEnv
[09:29:15.548] Capture standard output: TRUE
[09:29:15.548] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.548] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.548] Packages: <none>
[09:29:15.548] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.548] Resolved: TRUE
[09:29:15.548] Value: <not collected>
[09:29:15.548] Conditions captured: <none>
[09:29:15.548] Early signaling: FALSE
[09:29:15.548] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.548] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.557] Chunk #1 of 2 ... DONE
[09:29:15.557] Chunk #2 of 2 ...
[09:29:15.558]  - Finding globals in '...' for chunk #2 ...
[09:29:15.558] getGlobalsAndPackages() ...
[09:29:15.558] Searching for globals...
[09:29:15.558] 
[09:29:15.558] Searching for globals ... DONE
[09:29:15.559] - globals: [0] <none>
[09:29:15.559] getGlobalsAndPackages() ... DONE
[09:29:15.559]    + additional globals found: [n=0] 
[09:29:15.559]    + additional namespaces needed: [n=0] 
[09:29:15.559]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:15.559]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:15.559]  - seeds: <none>
[09:29:15.559]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.560] getGlobalsAndPackages() ...
[09:29:15.560] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.560] Resolving globals: FALSE
[09:29:15.561] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[09:29:15.562] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.562] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.562] 
[09:29:15.562] getGlobalsAndPackages() ... DONE
[09:29:15.563] run() for ‘Future’ ...
[09:29:15.563] - state: ‘created’
[09:29:15.563] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.568] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.568] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.568]   - Field: ‘label’
[09:29:15.568]   - Field: ‘local’
[09:29:15.568]   - Field: ‘owner’
[09:29:15.569]   - Field: ‘envir’
[09:29:15.569]   - Field: ‘workers’
[09:29:15.569]   - Field: ‘packages’
[09:29:15.569]   - Field: ‘gc’
[09:29:15.569]   - Field: ‘job’
[09:29:15.569]   - Field: ‘conditions’
[09:29:15.570]   - Field: ‘expr’
[09:29:15.570]   - Field: ‘uuid’
[09:29:15.570]   - Field: ‘seed’
[09:29:15.570]   - Field: ‘version’
[09:29:15.570]   - Field: ‘result’
[09:29:15.570]   - Field: ‘asynchronous’
[09:29:15.570]   - Field: ‘calls’
[09:29:15.571]   - Field: ‘globals’
[09:29:15.571]   - Field: ‘stdout’
[09:29:15.571]   - Field: ‘earlySignal’
[09:29:15.571]   - Field: ‘lazy’
[09:29:15.571]   - Field: ‘state’
[09:29:15.571] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.571] - Launch lazy future ...
[09:29:15.572] Packages needed by the future expression (n = 0): <none>
[09:29:15.572] Packages needed by future strategies (n = 0): <none>
[09:29:15.573] {
[09:29:15.573]     {
[09:29:15.573]         {
[09:29:15.573]             ...future.startTime <- base::Sys.time()
[09:29:15.573]             {
[09:29:15.573]                 {
[09:29:15.573]                   {
[09:29:15.573]                     {
[09:29:15.573]                       base::local({
[09:29:15.573]                         has_future <- base::requireNamespace("future", 
[09:29:15.573]                           quietly = TRUE)
[09:29:15.573]                         if (has_future) {
[09:29:15.573]                           ns <- base::getNamespace("future")
[09:29:15.573]                           version <- ns[[".package"]][["version"]]
[09:29:15.573]                           if (is.null(version)) 
[09:29:15.573]                             version <- utils::packageVersion("future")
[09:29:15.573]                         }
[09:29:15.573]                         else {
[09:29:15.573]                           version <- NULL
[09:29:15.573]                         }
[09:29:15.573]                         if (!has_future || version < "1.8.0") {
[09:29:15.573]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.573]                             "", base::R.version$version.string), 
[09:29:15.573]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.573]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.573]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.573]                               "release", "version")], collapse = " "), 
[09:29:15.573]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.573]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.573]                             info)
[09:29:15.573]                           info <- base::paste(info, collapse = "; ")
[09:29:15.573]                           if (!has_future) {
[09:29:15.573]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.573]                               info)
[09:29:15.573]                           }
[09:29:15.573]                           else {
[09:29:15.573]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.573]                               info, version)
[09:29:15.573]                           }
[09:29:15.573]                           base::stop(msg)
[09:29:15.573]                         }
[09:29:15.573]                       })
[09:29:15.573]                     }
[09:29:15.573]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.573]                     base::options(mc.cores = 1L)
[09:29:15.573]                   }
[09:29:15.573]                   ...future.strategy.old <- future::plan("list")
[09:29:15.573]                   options(future.plan = NULL)
[09:29:15.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.573]                 }
[09:29:15.573]                 ...future.workdir <- getwd()
[09:29:15.573]             }
[09:29:15.573]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.573]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.573]         }
[09:29:15.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.573]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:15.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.573]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.573]             base::names(...future.oldOptions))
[09:29:15.573]     }
[09:29:15.573]     if (FALSE) {
[09:29:15.573]     }
[09:29:15.573]     else {
[09:29:15.573]         if (TRUE) {
[09:29:15.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.573]                 open = "w")
[09:29:15.573]         }
[09:29:15.573]         else {
[09:29:15.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.573]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.573]         }
[09:29:15.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.573]             base::sink(type = "output", split = FALSE)
[09:29:15.573]             base::close(...future.stdout)
[09:29:15.573]         }, add = TRUE)
[09:29:15.573]     }
[09:29:15.573]     ...future.frame <- base::sys.nframe()
[09:29:15.573]     ...future.conditions <- base::list()
[09:29:15.573]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.573]     if (FALSE) {
[09:29:15.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.573]     }
[09:29:15.573]     ...future.result <- base::tryCatch({
[09:29:15.573]         base::withCallingHandlers({
[09:29:15.573]             ...future.value <- base::withVisible(base::local({
[09:29:15.573]                 withCallingHandlers({
[09:29:15.573]                   {
[09:29:15.573]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.573]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.573]                       ...future.globals.maxSize)) {
[09:29:15.573]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.573]                       on.exit(options(oopts), add = TRUE)
[09:29:15.573]                     }
[09:29:15.573]                     {
[09:29:15.573]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.573]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.573]                         USE.NAMES = FALSE)
[09:29:15.573]                       do.call(mapply, args = args)
[09:29:15.573]                     }
[09:29:15.573]                   }
[09:29:15.573]                 }, immediateCondition = function(cond) {
[09:29:15.573]                   save_rds <- function (object, pathname, ...) 
[09:29:15.573]                   {
[09:29:15.573]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.573]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.573]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.573]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.573]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.573]                         fi_tmp[["mtime"]])
[09:29:15.573]                     }
[09:29:15.573]                     tryCatch({
[09:29:15.573]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.573]                     }, error = function(ex) {
[09:29:15.573]                       msg <- conditionMessage(ex)
[09:29:15.573]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.573]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.573]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.573]                         fi_tmp[["mtime"]], msg)
[09:29:15.573]                       ex$message <- msg
[09:29:15.573]                       stop(ex)
[09:29:15.573]                     })
[09:29:15.573]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.573]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.573]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.573]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.573]                       fi <- file.info(pathname)
[09:29:15.573]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.573]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.573]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.573]                         fi[["size"]], fi[["mtime"]])
[09:29:15.573]                       stop(msg)
[09:29:15.573]                     }
[09:29:15.573]                     invisible(pathname)
[09:29:15.573]                   }
[09:29:15.573]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.573]                     rootPath = tempdir()) 
[09:29:15.573]                   {
[09:29:15.573]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.573]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.573]                       tmpdir = path, fileext = ".rds")
[09:29:15.573]                     save_rds(obj, file)
[09:29:15.573]                   }
[09:29:15.573]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.573]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.573]                   {
[09:29:15.573]                     inherits <- base::inherits
[09:29:15.573]                     invokeRestart <- base::invokeRestart
[09:29:15.573]                     is.null <- base::is.null
[09:29:15.573]                     muffled <- FALSE
[09:29:15.573]                     if (inherits(cond, "message")) {
[09:29:15.573]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.573]                       if (muffled) 
[09:29:15.573]                         invokeRestart("muffleMessage")
[09:29:15.573]                     }
[09:29:15.573]                     else if (inherits(cond, "warning")) {
[09:29:15.573]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.573]                       if (muffled) 
[09:29:15.573]                         invokeRestart("muffleWarning")
[09:29:15.573]                     }
[09:29:15.573]                     else if (inherits(cond, "condition")) {
[09:29:15.573]                       if (!is.null(pattern)) {
[09:29:15.573]                         computeRestarts <- base::computeRestarts
[09:29:15.573]                         grepl <- base::grepl
[09:29:15.573]                         restarts <- computeRestarts(cond)
[09:29:15.573]                         for (restart in restarts) {
[09:29:15.573]                           name <- restart$name
[09:29:15.573]                           if (is.null(name)) 
[09:29:15.573]                             next
[09:29:15.573]                           if (!grepl(pattern, name)) 
[09:29:15.573]                             next
[09:29:15.573]                           invokeRestart(restart)
[09:29:15.573]                           muffled <- TRUE
[09:29:15.573]                           break
[09:29:15.573]                         }
[09:29:15.573]                       }
[09:29:15.573]                     }
[09:29:15.573]                     invisible(muffled)
[09:29:15.573]                   }
[09:29:15.573]                   muffleCondition(cond)
[09:29:15.573]                 })
[09:29:15.573]             }))
[09:29:15.573]             future::FutureResult(value = ...future.value$value, 
[09:29:15.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.573]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.573]                     ...future.globalenv.names))
[09:29:15.573]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.573]         }, condition = base::local({
[09:29:15.573]             c <- base::c
[09:29:15.573]             inherits <- base::inherits
[09:29:15.573]             invokeRestart <- base::invokeRestart
[09:29:15.573]             length <- base::length
[09:29:15.573]             list <- base::list
[09:29:15.573]             seq.int <- base::seq.int
[09:29:15.573]             signalCondition <- base::signalCondition
[09:29:15.573]             sys.calls <- base::sys.calls
[09:29:15.573]             `[[` <- base::`[[`
[09:29:15.573]             `+` <- base::`+`
[09:29:15.573]             `<<-` <- base::`<<-`
[09:29:15.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.573]                   3L)]
[09:29:15.573]             }
[09:29:15.573]             function(cond) {
[09:29:15.573]                 is_error <- inherits(cond, "error")
[09:29:15.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.573]                   NULL)
[09:29:15.573]                 if (is_error) {
[09:29:15.573]                   sessionInformation <- function() {
[09:29:15.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.573]                       search = base::search(), system = base::Sys.info())
[09:29:15.573]                   }
[09:29:15.573]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.573]                     cond$call), session = sessionInformation(), 
[09:29:15.573]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.573]                   signalCondition(cond)
[09:29:15.573]                 }
[09:29:15.573]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.573]                 "immediateCondition"))) {
[09:29:15.573]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.573]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.573]                   if (TRUE && !signal) {
[09:29:15.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.573]                     {
[09:29:15.573]                       inherits <- base::inherits
[09:29:15.573]                       invokeRestart <- base::invokeRestart
[09:29:15.573]                       is.null <- base::is.null
[09:29:15.573]                       muffled <- FALSE
[09:29:15.573]                       if (inherits(cond, "message")) {
[09:29:15.573]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.573]                         if (muffled) 
[09:29:15.573]                           invokeRestart("muffleMessage")
[09:29:15.573]                       }
[09:29:15.573]                       else if (inherits(cond, "warning")) {
[09:29:15.573]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.573]                         if (muffled) 
[09:29:15.573]                           invokeRestart("muffleWarning")
[09:29:15.573]                       }
[09:29:15.573]                       else if (inherits(cond, "condition")) {
[09:29:15.573]                         if (!is.null(pattern)) {
[09:29:15.573]                           computeRestarts <- base::computeRestarts
[09:29:15.573]                           grepl <- base::grepl
[09:29:15.573]                           restarts <- computeRestarts(cond)
[09:29:15.573]                           for (restart in restarts) {
[09:29:15.573]                             name <- restart$name
[09:29:15.573]                             if (is.null(name)) 
[09:29:15.573]                               next
[09:29:15.573]                             if (!grepl(pattern, name)) 
[09:29:15.573]                               next
[09:29:15.573]                             invokeRestart(restart)
[09:29:15.573]                             muffled <- TRUE
[09:29:15.573]                             break
[09:29:15.573]                           }
[09:29:15.573]                         }
[09:29:15.573]                       }
[09:29:15.573]                       invisible(muffled)
[09:29:15.573]                     }
[09:29:15.573]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.573]                   }
[09:29:15.573]                 }
[09:29:15.573]                 else {
[09:29:15.573]                   if (TRUE) {
[09:29:15.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.573]                     {
[09:29:15.573]                       inherits <- base::inherits
[09:29:15.573]                       invokeRestart <- base::invokeRestart
[09:29:15.573]                       is.null <- base::is.null
[09:29:15.573]                       muffled <- FALSE
[09:29:15.573]                       if (inherits(cond, "message")) {
[09:29:15.573]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.573]                         if (muffled) 
[09:29:15.573]                           invokeRestart("muffleMessage")
[09:29:15.573]                       }
[09:29:15.573]                       else if (inherits(cond, "warning")) {
[09:29:15.573]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.573]                         if (muffled) 
[09:29:15.573]                           invokeRestart("muffleWarning")
[09:29:15.573]                       }
[09:29:15.573]                       else if (inherits(cond, "condition")) {
[09:29:15.573]                         if (!is.null(pattern)) {
[09:29:15.573]                           computeRestarts <- base::computeRestarts
[09:29:15.573]                           grepl <- base::grepl
[09:29:15.573]                           restarts <- computeRestarts(cond)
[09:29:15.573]                           for (restart in restarts) {
[09:29:15.573]                             name <- restart$name
[09:29:15.573]                             if (is.null(name)) 
[09:29:15.573]                               next
[09:29:15.573]                             if (!grepl(pattern, name)) 
[09:29:15.573]                               next
[09:29:15.573]                             invokeRestart(restart)
[09:29:15.573]                             muffled <- TRUE
[09:29:15.573]                             break
[09:29:15.573]                           }
[09:29:15.573]                         }
[09:29:15.573]                       }
[09:29:15.573]                       invisible(muffled)
[09:29:15.573]                     }
[09:29:15.573]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.573]                   }
[09:29:15.573]                 }
[09:29:15.573]             }
[09:29:15.573]         }))
[09:29:15.573]     }, error = function(ex) {
[09:29:15.573]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.573]                 ...future.rng), started = ...future.startTime, 
[09:29:15.573]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.573]             version = "1.8"), class = "FutureResult")
[09:29:15.573]     }, finally = {
[09:29:15.573]         if (!identical(...future.workdir, getwd())) 
[09:29:15.573]             setwd(...future.workdir)
[09:29:15.573]         {
[09:29:15.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.573]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.573]             }
[09:29:15.573]             base::options(...future.oldOptions)
[09:29:15.573]             if (.Platform$OS.type == "windows") {
[09:29:15.573]                 old_names <- names(...future.oldEnvVars)
[09:29:15.573]                 envs <- base::Sys.getenv()
[09:29:15.573]                 names <- names(envs)
[09:29:15.573]                 common <- intersect(names, old_names)
[09:29:15.573]                 added <- setdiff(names, old_names)
[09:29:15.573]                 removed <- setdiff(old_names, names)
[09:29:15.573]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.573]                   envs[common]]
[09:29:15.573]                 NAMES <- toupper(changed)
[09:29:15.573]                 args <- list()
[09:29:15.573]                 for (kk in seq_along(NAMES)) {
[09:29:15.573]                   name <- changed[[kk]]
[09:29:15.573]                   NAME <- NAMES[[kk]]
[09:29:15.573]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.573]                     next
[09:29:15.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.573]                 }
[09:29:15.573]                 NAMES <- toupper(added)
[09:29:15.573]                 for (kk in seq_along(NAMES)) {
[09:29:15.573]                   name <- added[[kk]]
[09:29:15.573]                   NAME <- NAMES[[kk]]
[09:29:15.573]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.573]                     next
[09:29:15.573]                   args[[name]] <- ""
[09:29:15.573]                 }
[09:29:15.573]                 NAMES <- toupper(removed)
[09:29:15.573]                 for (kk in seq_along(NAMES)) {
[09:29:15.573]                   name <- removed[[kk]]
[09:29:15.573]                   NAME <- NAMES[[kk]]
[09:29:15.573]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.573]                     next
[09:29:15.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.573]                 }
[09:29:15.573]                 if (length(args) > 0) 
[09:29:15.573]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.573]             }
[09:29:15.573]             else {
[09:29:15.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.573]             }
[09:29:15.573]             {
[09:29:15.573]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.573]                   0L) {
[09:29:15.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.573]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.573]                   base::options(opts)
[09:29:15.573]                 }
[09:29:15.573]                 {
[09:29:15.573]                   {
[09:29:15.573]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.573]                     NULL
[09:29:15.573]                   }
[09:29:15.573]                   options(future.plan = NULL)
[09:29:15.573]                   if (is.na(NA_character_)) 
[09:29:15.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.573]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.573]                     .init = FALSE)
[09:29:15.573]                 }
[09:29:15.573]             }
[09:29:15.573]         }
[09:29:15.573]     })
[09:29:15.573]     if (TRUE) {
[09:29:15.573]         base::sink(type = "output", split = FALSE)
[09:29:15.573]         if (TRUE) {
[09:29:15.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.573]         }
[09:29:15.573]         else {
[09:29:15.573]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.573]         }
[09:29:15.573]         base::close(...future.stdout)
[09:29:15.573]         ...future.stdout <- NULL
[09:29:15.573]     }
[09:29:15.573]     ...future.result$conditions <- ...future.conditions
[09:29:15.573]     ...future.result$finished <- base::Sys.time()
[09:29:15.573]     ...future.result
[09:29:15.573] }
[09:29:15.579] assign_globals() ...
[09:29:15.580] List of 5
[09:29:15.580]  $ ...future.FUN            :function (x, y)  
[09:29:15.580]  $ MoreArgs                 : NULL
[09:29:15.580]  $ ...future.elements_ii    :List of 2
[09:29:15.580]   ..$ :List of 2
[09:29:15.580]   .. ..$ b: num 2
[09:29:15.580]   .. ..$ c: num 3
[09:29:15.580]   ..$ :List of 2
[09:29:15.580]   .. ..$ B: num 0
[09:29:15.580]   .. ..$ C: num -10
[09:29:15.580]  $ ...future.seeds_ii       : NULL
[09:29:15.580]  $ ...future.globals.maxSize: NULL
[09:29:15.580]  - attr(*, "where")=List of 5
[09:29:15.580]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.580]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.580]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.580]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.580]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.580]  - attr(*, "resolved")= logi FALSE
[09:29:15.580]  - attr(*, "total_size")= num 2200
[09:29:15.580]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.580]  - attr(*, "already-done")= logi TRUE
[09:29:15.590] - reassign environment for ‘...future.FUN’
[09:29:15.590] - copied ‘...future.FUN’ to environment
[09:29:15.591] - copied ‘MoreArgs’ to environment
[09:29:15.591] - copied ‘...future.elements_ii’ to environment
[09:29:15.591] - copied ‘...future.seeds_ii’ to environment
[09:29:15.591] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.591] assign_globals() ... done
[09:29:15.591] requestCore(): workers = 2
[09:29:15.593] MulticoreFuture started
[09:29:15.594] - Launch lazy future ... done
[09:29:15.594] run() for ‘MulticoreFuture’ ... done
[09:29:15.594] Created future:
[09:29:15.595] plan(): Setting new future strategy stack:
[09:29:15.595] List of future strategies:
[09:29:15.595] 1. sequential:
[09:29:15.595]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.595]    - tweaked: FALSE
[09:29:15.595]    - call: NULL
[09:29:15.596] plan(): nbrOfWorkers() = 1
[09:29:15.598] plan(): Setting new future strategy stack:
[09:29:15.598] List of future strategies:
[09:29:15.598] 1. multicore:
[09:29:15.598]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.598]    - tweaked: FALSE
[09:29:15.598]    - call: plan(strategy)
[09:29:15.603] plan(): nbrOfWorkers() = 2
[09:29:15.595] MulticoreFuture:
[09:29:15.595] Label: ‘future_mapply-2’
[09:29:15.595] Expression:
[09:29:15.595] {
[09:29:15.595]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.595]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.595]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.595]         on.exit(options(oopts), add = TRUE)
[09:29:15.595]     }
[09:29:15.595]     {
[09:29:15.595]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.595]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.595]         do.call(mapply, args = args)
[09:29:15.595]     }
[09:29:15.595] }
[09:29:15.595] Lazy evaluation: FALSE
[09:29:15.595] Asynchronous evaluation: TRUE
[09:29:15.595] Local evaluation: TRUE
[09:29:15.595] Environment: R_GlobalEnv
[09:29:15.595] Capture standard output: TRUE
[09:29:15.595] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.595] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.595] Packages: <none>
[09:29:15.595] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.595] Resolved: TRUE
[09:29:15.595] Value: <not collected>
[09:29:15.595] Conditions captured: <none>
[09:29:15.595] Early signaling: FALSE
[09:29:15.595] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.595] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.604] Chunk #2 of 2 ... DONE
[09:29:15.605] Launching 2 futures (chunks) ... DONE
[09:29:15.605] Resolving 2 futures (chunks) ...
[09:29:15.605] resolve() on list ...
[09:29:15.605]  recursive: 0
[09:29:15.605]  length: 2
[09:29:15.605] 
[09:29:15.606] Future #1
[09:29:15.606] result() for MulticoreFuture ...
[09:29:15.607] result() for MulticoreFuture ...
[09:29:15.607] result() for MulticoreFuture ... done
[09:29:15.607] result() for MulticoreFuture ... done
[09:29:15.607] result() for MulticoreFuture ...
[09:29:15.607] result() for MulticoreFuture ... done
[09:29:15.607] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:15.608] - nx: 2
[09:29:15.608] - relay: TRUE
[09:29:15.608] - stdout: TRUE
[09:29:15.608] - signal: TRUE
[09:29:15.608] - resignal: FALSE
[09:29:15.608] - force: TRUE
[09:29:15.608] - relayed: [n=2] FALSE, FALSE
[09:29:15.608] - queued futures: [n=2] FALSE, FALSE
[09:29:15.609]  - until=1
[09:29:15.609]  - relaying element #1
[09:29:15.609] result() for MulticoreFuture ...
[09:29:15.609] result() for MulticoreFuture ... done
[09:29:15.609] result() for MulticoreFuture ...
[09:29:15.609] result() for MulticoreFuture ... done
[09:29:15.610] result() for MulticoreFuture ...
[09:29:15.610] result() for MulticoreFuture ... done
[09:29:15.610] result() for MulticoreFuture ...
[09:29:15.610] result() for MulticoreFuture ... done
[09:29:15.610] - relayed: [n=2] TRUE, FALSE
[09:29:15.610] - queued futures: [n=2] TRUE, FALSE
[09:29:15.611] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:15.611]  length: 1 (resolved future 1)
[09:29:15.611] Future #2
[09:29:15.611] result() for MulticoreFuture ...
[09:29:15.612] result() for MulticoreFuture ...
[09:29:15.612] result() for MulticoreFuture ... done
[09:29:15.612] result() for MulticoreFuture ... done
[09:29:15.612] result() for MulticoreFuture ...
[09:29:15.612] result() for MulticoreFuture ... done
[09:29:15.613] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:15.613] - nx: 2
[09:29:15.613] - relay: TRUE
[09:29:15.613] - stdout: TRUE
[09:29:15.613] - signal: TRUE
[09:29:15.613] - resignal: FALSE
[09:29:15.613] - force: TRUE
[09:29:15.614] - relayed: [n=2] TRUE, FALSE
[09:29:15.614] - queued futures: [n=2] TRUE, FALSE
[09:29:15.614]  - until=2
[09:29:15.614]  - relaying element #2
[09:29:15.614] result() for MulticoreFuture ...
[09:29:15.614] result() for MulticoreFuture ... done
[09:29:15.614] result() for MulticoreFuture ...
[09:29:15.614] result() for MulticoreFuture ... done
[09:29:15.615] result() for MulticoreFuture ...
[09:29:15.615] result() for MulticoreFuture ... done
[09:29:15.615] result() for MulticoreFuture ...
[09:29:15.615] result() for MulticoreFuture ... done
[09:29:15.615] - relayed: [n=2] TRUE, TRUE
[09:29:15.615] - queued futures: [n=2] TRUE, TRUE
[09:29:15.615] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:15.615]  length: 0 (resolved future 2)
[09:29:15.616] Relaying remaining futures
[09:29:15.616] signalConditionsASAP(NULL, pos=0) ...
[09:29:15.616] - nx: 2
[09:29:15.616] - relay: TRUE
[09:29:15.616] - stdout: TRUE
[09:29:15.616] - signal: TRUE
[09:29:15.616] - resignal: FALSE
[09:29:15.616] - force: TRUE
[09:29:15.616] - relayed: [n=2] TRUE, TRUE
[09:29:15.617] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:15.617] - relayed: [n=2] TRUE, TRUE
[09:29:15.617] - queued futures: [n=2] TRUE, TRUE
[09:29:15.617] signalConditionsASAP(NULL, pos=0) ... done
[09:29:15.617] resolve() on list ... DONE
[09:29:15.617] result() for MulticoreFuture ...
[09:29:15.617] result() for MulticoreFuture ... done
[09:29:15.617] result() for MulticoreFuture ...
[09:29:15.618] result() for MulticoreFuture ... done
[09:29:15.618] result() for MulticoreFuture ...
[09:29:15.618] result() for MulticoreFuture ... done
[09:29:15.618] result() for MulticoreFuture ...
[09:29:15.618] result() for MulticoreFuture ... done
[09:29:15.618]  - Number of value chunks collected: 2
[09:29:15.618] Resolving 2 futures (chunks) ... DONE
[09:29:15.618] Reducing values from 2 chunks ...
[09:29:15.618]  - Number of values collected after concatenation: 3
[09:29:15.619]  - Number of values expected: 3
[09:29:15.619] Reducing values from 2 chunks ... DONE
[09:29:15.619] future_mapply() ... DONE
- future_.mapply()
[09:29:15.619] future_mapply() ...
[09:29:15.626] Number of chunks: 2
[09:29:15.626] getGlobalsAndPackagesXApply() ...
[09:29:15.626]  - future.globals: TRUE
[09:29:15.626] getGlobalsAndPackages() ...
[09:29:15.626] Searching for globals...
[09:29:15.628] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[09:29:15.628] Searching for globals ... DONE
[09:29:15.628] Resolving globals: FALSE
[09:29:15.629] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[09:29:15.629] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[09:29:15.630] - globals: [1] ‘FUN’
[09:29:15.630] 
[09:29:15.630] getGlobalsAndPackages() ... DONE
[09:29:15.630]  - globals found/used: [n=1] ‘FUN’
[09:29:15.630]  - needed namespaces: [n=0] 
[09:29:15.630] Finding globals ... DONE
[09:29:15.630] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:15.630] List of 2
[09:29:15.630]  $ ...future.FUN:function (x, y)  
[09:29:15.630]  $ MoreArgs     : list()
[09:29:15.630]  - attr(*, "where")=List of 2
[09:29:15.630]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:15.630]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:15.630]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.630]  - attr(*, "resolved")= logi FALSE
[09:29:15.630]  - attr(*, "total_size")= num NA
[09:29:15.633] Packages to be attached in all futures: [n=0] 
[09:29:15.634] getGlobalsAndPackagesXApply() ... DONE
[09:29:15.634] Number of futures (= number of chunks): 2
[09:29:15.634] Launching 2 futures (chunks) ...
[09:29:15.634] Chunk #1 of 2 ...
[09:29:15.634]  - Finding globals in '...' for chunk #1 ...
[09:29:15.634] getGlobalsAndPackages() ...
[09:29:15.634] Searching for globals...
[09:29:15.635] 
[09:29:15.635] Searching for globals ... DONE
[09:29:15.635] - globals: [0] <none>
[09:29:15.635] getGlobalsAndPackages() ... DONE
[09:29:15.635]    + additional globals found: [n=0] 
[09:29:15.635]    + additional namespaces needed: [n=0] 
[09:29:15.635]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:15.635]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:15.635]  - seeds: <none>
[09:29:15.636]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.636] getGlobalsAndPackages() ...
[09:29:15.636] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.636] Resolving globals: FALSE
[09:29:15.636] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[09:29:15.637] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:15.637] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.637] 
[09:29:15.637] getGlobalsAndPackages() ... DONE
[09:29:15.637] run() for ‘Future’ ...
[09:29:15.638] - state: ‘created’
[09:29:15.638] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.641] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.641] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.642]   - Field: ‘label’
[09:29:15.642]   - Field: ‘local’
[09:29:15.642]   - Field: ‘owner’
[09:29:15.642]   - Field: ‘envir’
[09:29:15.642]   - Field: ‘workers’
[09:29:15.642]   - Field: ‘packages’
[09:29:15.642]   - Field: ‘gc’
[09:29:15.642]   - Field: ‘job’
[09:29:15.642]   - Field: ‘conditions’
[09:29:15.642]   - Field: ‘expr’
[09:29:15.642]   - Field: ‘uuid’
[09:29:15.643]   - Field: ‘seed’
[09:29:15.643]   - Field: ‘version’
[09:29:15.643]   - Field: ‘result’
[09:29:15.643]   - Field: ‘asynchronous’
[09:29:15.643]   - Field: ‘calls’
[09:29:15.643]   - Field: ‘globals’
[09:29:15.643]   - Field: ‘stdout’
[09:29:15.643]   - Field: ‘earlySignal’
[09:29:15.643]   - Field: ‘lazy’
[09:29:15.643]   - Field: ‘state’
[09:29:15.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.643] - Launch lazy future ...
[09:29:15.644] Packages needed by the future expression (n = 0): <none>
[09:29:15.644] Packages needed by future strategies (n = 0): <none>
[09:29:15.644] {
[09:29:15.644]     {
[09:29:15.644]         {
[09:29:15.644]             ...future.startTime <- base::Sys.time()
[09:29:15.644]             {
[09:29:15.644]                 {
[09:29:15.644]                   {
[09:29:15.644]                     {
[09:29:15.644]                       base::local({
[09:29:15.644]                         has_future <- base::requireNamespace("future", 
[09:29:15.644]                           quietly = TRUE)
[09:29:15.644]                         if (has_future) {
[09:29:15.644]                           ns <- base::getNamespace("future")
[09:29:15.644]                           version <- ns[[".package"]][["version"]]
[09:29:15.644]                           if (is.null(version)) 
[09:29:15.644]                             version <- utils::packageVersion("future")
[09:29:15.644]                         }
[09:29:15.644]                         else {
[09:29:15.644]                           version <- NULL
[09:29:15.644]                         }
[09:29:15.644]                         if (!has_future || version < "1.8.0") {
[09:29:15.644]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.644]                             "", base::R.version$version.string), 
[09:29:15.644]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.644]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.644]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.644]                               "release", "version")], collapse = " "), 
[09:29:15.644]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.644]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.644]                             info)
[09:29:15.644]                           info <- base::paste(info, collapse = "; ")
[09:29:15.644]                           if (!has_future) {
[09:29:15.644]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.644]                               info)
[09:29:15.644]                           }
[09:29:15.644]                           else {
[09:29:15.644]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.644]                               info, version)
[09:29:15.644]                           }
[09:29:15.644]                           base::stop(msg)
[09:29:15.644]                         }
[09:29:15.644]                       })
[09:29:15.644]                     }
[09:29:15.644]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.644]                     base::options(mc.cores = 1L)
[09:29:15.644]                   }
[09:29:15.644]                   ...future.strategy.old <- future::plan("list")
[09:29:15.644]                   options(future.plan = NULL)
[09:29:15.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.644]                 }
[09:29:15.644]                 ...future.workdir <- getwd()
[09:29:15.644]             }
[09:29:15.644]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.644]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.644]         }
[09:29:15.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.644]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:15.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.644]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.644]             base::names(...future.oldOptions))
[09:29:15.644]     }
[09:29:15.644]     if (FALSE) {
[09:29:15.644]     }
[09:29:15.644]     else {
[09:29:15.644]         if (TRUE) {
[09:29:15.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.644]                 open = "w")
[09:29:15.644]         }
[09:29:15.644]         else {
[09:29:15.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.644]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.644]         }
[09:29:15.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.644]             base::sink(type = "output", split = FALSE)
[09:29:15.644]             base::close(...future.stdout)
[09:29:15.644]         }, add = TRUE)
[09:29:15.644]     }
[09:29:15.644]     ...future.frame <- base::sys.nframe()
[09:29:15.644]     ...future.conditions <- base::list()
[09:29:15.644]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.644]     if (FALSE) {
[09:29:15.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.644]     }
[09:29:15.644]     ...future.result <- base::tryCatch({
[09:29:15.644]         base::withCallingHandlers({
[09:29:15.644]             ...future.value <- base::withVisible(base::local({
[09:29:15.644]                 withCallingHandlers({
[09:29:15.644]                   {
[09:29:15.644]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.644]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.644]                       ...future.globals.maxSize)) {
[09:29:15.644]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.644]                       on.exit(options(oopts), add = TRUE)
[09:29:15.644]                     }
[09:29:15.644]                     {
[09:29:15.644]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.644]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.644]                         USE.NAMES = FALSE)
[09:29:15.644]                       do.call(mapply, args = args)
[09:29:15.644]                     }
[09:29:15.644]                   }
[09:29:15.644]                 }, immediateCondition = function(cond) {
[09:29:15.644]                   save_rds <- function (object, pathname, ...) 
[09:29:15.644]                   {
[09:29:15.644]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.644]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.644]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.644]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.644]                         fi_tmp[["mtime"]])
[09:29:15.644]                     }
[09:29:15.644]                     tryCatch({
[09:29:15.644]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.644]                     }, error = function(ex) {
[09:29:15.644]                       msg <- conditionMessage(ex)
[09:29:15.644]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.644]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.644]                         fi_tmp[["mtime"]], msg)
[09:29:15.644]                       ex$message <- msg
[09:29:15.644]                       stop(ex)
[09:29:15.644]                     })
[09:29:15.644]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.644]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.644]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.644]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.644]                       fi <- file.info(pathname)
[09:29:15.644]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.644]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.644]                         fi[["size"]], fi[["mtime"]])
[09:29:15.644]                       stop(msg)
[09:29:15.644]                     }
[09:29:15.644]                     invisible(pathname)
[09:29:15.644]                   }
[09:29:15.644]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.644]                     rootPath = tempdir()) 
[09:29:15.644]                   {
[09:29:15.644]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.644]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.644]                       tmpdir = path, fileext = ".rds")
[09:29:15.644]                     save_rds(obj, file)
[09:29:15.644]                   }
[09:29:15.644]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.644]                   {
[09:29:15.644]                     inherits <- base::inherits
[09:29:15.644]                     invokeRestart <- base::invokeRestart
[09:29:15.644]                     is.null <- base::is.null
[09:29:15.644]                     muffled <- FALSE
[09:29:15.644]                     if (inherits(cond, "message")) {
[09:29:15.644]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.644]                       if (muffled) 
[09:29:15.644]                         invokeRestart("muffleMessage")
[09:29:15.644]                     }
[09:29:15.644]                     else if (inherits(cond, "warning")) {
[09:29:15.644]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.644]                       if (muffled) 
[09:29:15.644]                         invokeRestart("muffleWarning")
[09:29:15.644]                     }
[09:29:15.644]                     else if (inherits(cond, "condition")) {
[09:29:15.644]                       if (!is.null(pattern)) {
[09:29:15.644]                         computeRestarts <- base::computeRestarts
[09:29:15.644]                         grepl <- base::grepl
[09:29:15.644]                         restarts <- computeRestarts(cond)
[09:29:15.644]                         for (restart in restarts) {
[09:29:15.644]                           name <- restart$name
[09:29:15.644]                           if (is.null(name)) 
[09:29:15.644]                             next
[09:29:15.644]                           if (!grepl(pattern, name)) 
[09:29:15.644]                             next
[09:29:15.644]                           invokeRestart(restart)
[09:29:15.644]                           muffled <- TRUE
[09:29:15.644]                           break
[09:29:15.644]                         }
[09:29:15.644]                       }
[09:29:15.644]                     }
[09:29:15.644]                     invisible(muffled)
[09:29:15.644]                   }
[09:29:15.644]                   muffleCondition(cond)
[09:29:15.644]                 })
[09:29:15.644]             }))
[09:29:15.644]             future::FutureResult(value = ...future.value$value, 
[09:29:15.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.644]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.644]                     ...future.globalenv.names))
[09:29:15.644]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.644]         }, condition = base::local({
[09:29:15.644]             c <- base::c
[09:29:15.644]             inherits <- base::inherits
[09:29:15.644]             invokeRestart <- base::invokeRestart
[09:29:15.644]             length <- base::length
[09:29:15.644]             list <- base::list
[09:29:15.644]             seq.int <- base::seq.int
[09:29:15.644]             signalCondition <- base::signalCondition
[09:29:15.644]             sys.calls <- base::sys.calls
[09:29:15.644]             `[[` <- base::`[[`
[09:29:15.644]             `+` <- base::`+`
[09:29:15.644]             `<<-` <- base::`<<-`
[09:29:15.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.644]                   3L)]
[09:29:15.644]             }
[09:29:15.644]             function(cond) {
[09:29:15.644]                 is_error <- inherits(cond, "error")
[09:29:15.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.644]                   NULL)
[09:29:15.644]                 if (is_error) {
[09:29:15.644]                   sessionInformation <- function() {
[09:29:15.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.644]                       search = base::search(), system = base::Sys.info())
[09:29:15.644]                   }
[09:29:15.644]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.644]                     cond$call), session = sessionInformation(), 
[09:29:15.644]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.644]                   signalCondition(cond)
[09:29:15.644]                 }
[09:29:15.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.644]                 "immediateCondition"))) {
[09:29:15.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.644]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.644]                   if (TRUE && !signal) {
[09:29:15.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.644]                     {
[09:29:15.644]                       inherits <- base::inherits
[09:29:15.644]                       invokeRestart <- base::invokeRestart
[09:29:15.644]                       is.null <- base::is.null
[09:29:15.644]                       muffled <- FALSE
[09:29:15.644]                       if (inherits(cond, "message")) {
[09:29:15.644]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.644]                         if (muffled) 
[09:29:15.644]                           invokeRestart("muffleMessage")
[09:29:15.644]                       }
[09:29:15.644]                       else if (inherits(cond, "warning")) {
[09:29:15.644]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.644]                         if (muffled) 
[09:29:15.644]                           invokeRestart("muffleWarning")
[09:29:15.644]                       }
[09:29:15.644]                       else if (inherits(cond, "condition")) {
[09:29:15.644]                         if (!is.null(pattern)) {
[09:29:15.644]                           computeRestarts <- base::computeRestarts
[09:29:15.644]                           grepl <- base::grepl
[09:29:15.644]                           restarts <- computeRestarts(cond)
[09:29:15.644]                           for (restart in restarts) {
[09:29:15.644]                             name <- restart$name
[09:29:15.644]                             if (is.null(name)) 
[09:29:15.644]                               next
[09:29:15.644]                             if (!grepl(pattern, name)) 
[09:29:15.644]                               next
[09:29:15.644]                             invokeRestart(restart)
[09:29:15.644]                             muffled <- TRUE
[09:29:15.644]                             break
[09:29:15.644]                           }
[09:29:15.644]                         }
[09:29:15.644]                       }
[09:29:15.644]                       invisible(muffled)
[09:29:15.644]                     }
[09:29:15.644]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.644]                   }
[09:29:15.644]                 }
[09:29:15.644]                 else {
[09:29:15.644]                   if (TRUE) {
[09:29:15.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.644]                     {
[09:29:15.644]                       inherits <- base::inherits
[09:29:15.644]                       invokeRestart <- base::invokeRestart
[09:29:15.644]                       is.null <- base::is.null
[09:29:15.644]                       muffled <- FALSE
[09:29:15.644]                       if (inherits(cond, "message")) {
[09:29:15.644]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.644]                         if (muffled) 
[09:29:15.644]                           invokeRestart("muffleMessage")
[09:29:15.644]                       }
[09:29:15.644]                       else if (inherits(cond, "warning")) {
[09:29:15.644]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.644]                         if (muffled) 
[09:29:15.644]                           invokeRestart("muffleWarning")
[09:29:15.644]                       }
[09:29:15.644]                       else if (inherits(cond, "condition")) {
[09:29:15.644]                         if (!is.null(pattern)) {
[09:29:15.644]                           computeRestarts <- base::computeRestarts
[09:29:15.644]                           grepl <- base::grepl
[09:29:15.644]                           restarts <- computeRestarts(cond)
[09:29:15.644]                           for (restart in restarts) {
[09:29:15.644]                             name <- restart$name
[09:29:15.644]                             if (is.null(name)) 
[09:29:15.644]                               next
[09:29:15.644]                             if (!grepl(pattern, name)) 
[09:29:15.644]                               next
[09:29:15.644]                             invokeRestart(restart)
[09:29:15.644]                             muffled <- TRUE
[09:29:15.644]                             break
[09:29:15.644]                           }
[09:29:15.644]                         }
[09:29:15.644]                       }
[09:29:15.644]                       invisible(muffled)
[09:29:15.644]                     }
[09:29:15.644]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.644]                   }
[09:29:15.644]                 }
[09:29:15.644]             }
[09:29:15.644]         }))
[09:29:15.644]     }, error = function(ex) {
[09:29:15.644]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.644]                 ...future.rng), started = ...future.startTime, 
[09:29:15.644]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.644]             version = "1.8"), class = "FutureResult")
[09:29:15.644]     }, finally = {
[09:29:15.644]         if (!identical(...future.workdir, getwd())) 
[09:29:15.644]             setwd(...future.workdir)
[09:29:15.644]         {
[09:29:15.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.644]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.644]             }
[09:29:15.644]             base::options(...future.oldOptions)
[09:29:15.644]             if (.Platform$OS.type == "windows") {
[09:29:15.644]                 old_names <- names(...future.oldEnvVars)
[09:29:15.644]                 envs <- base::Sys.getenv()
[09:29:15.644]                 names <- names(envs)
[09:29:15.644]                 common <- intersect(names, old_names)
[09:29:15.644]                 added <- setdiff(names, old_names)
[09:29:15.644]                 removed <- setdiff(old_names, names)
[09:29:15.644]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.644]                   envs[common]]
[09:29:15.644]                 NAMES <- toupper(changed)
[09:29:15.644]                 args <- list()
[09:29:15.644]                 for (kk in seq_along(NAMES)) {
[09:29:15.644]                   name <- changed[[kk]]
[09:29:15.644]                   NAME <- NAMES[[kk]]
[09:29:15.644]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.644]                     next
[09:29:15.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.644]                 }
[09:29:15.644]                 NAMES <- toupper(added)
[09:29:15.644]                 for (kk in seq_along(NAMES)) {
[09:29:15.644]                   name <- added[[kk]]
[09:29:15.644]                   NAME <- NAMES[[kk]]
[09:29:15.644]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.644]                     next
[09:29:15.644]                   args[[name]] <- ""
[09:29:15.644]                 }
[09:29:15.644]                 NAMES <- toupper(removed)
[09:29:15.644]                 for (kk in seq_along(NAMES)) {
[09:29:15.644]                   name <- removed[[kk]]
[09:29:15.644]                   NAME <- NAMES[[kk]]
[09:29:15.644]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.644]                     next
[09:29:15.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.644]                 }
[09:29:15.644]                 if (length(args) > 0) 
[09:29:15.644]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.644]             }
[09:29:15.644]             else {
[09:29:15.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.644]             }
[09:29:15.644]             {
[09:29:15.644]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.644]                   0L) {
[09:29:15.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.644]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.644]                   base::options(opts)
[09:29:15.644]                 }
[09:29:15.644]                 {
[09:29:15.644]                   {
[09:29:15.644]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.644]                     NULL
[09:29:15.644]                   }
[09:29:15.644]                   options(future.plan = NULL)
[09:29:15.644]                   if (is.na(NA_character_)) 
[09:29:15.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.644]                     .init = FALSE)
[09:29:15.644]                 }
[09:29:15.644]             }
[09:29:15.644]         }
[09:29:15.644]     })
[09:29:15.644]     if (TRUE) {
[09:29:15.644]         base::sink(type = "output", split = FALSE)
[09:29:15.644]         if (TRUE) {
[09:29:15.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.644]         }
[09:29:15.644]         else {
[09:29:15.644]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.644]         }
[09:29:15.644]         base::close(...future.stdout)
[09:29:15.644]         ...future.stdout <- NULL
[09:29:15.644]     }
[09:29:15.644]     ...future.result$conditions <- ...future.conditions
[09:29:15.644]     ...future.result$finished <- base::Sys.time()
[09:29:15.644]     ...future.result
[09:29:15.644] }
[09:29:15.647] assign_globals() ...
[09:29:15.647] List of 5
[09:29:15.647]  $ ...future.FUN            :function (x, y)  
[09:29:15.647]  $ MoreArgs                 : list()
[09:29:15.647]  $ ...future.elements_ii    :List of 2
[09:29:15.647]   ..$ :List of 1
[09:29:15.647]   .. ..$ a: num 1
[09:29:15.647]   ..$ :List of 1
[09:29:15.647]   .. ..$ A: num 10
[09:29:15.647]  $ ...future.seeds_ii       : NULL
[09:29:15.647]  $ ...future.globals.maxSize: NULL
[09:29:15.647]  - attr(*, "where")=List of 5
[09:29:15.647]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.647]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.647]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.647]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.647]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.647]  - attr(*, "resolved")= logi FALSE
[09:29:15.647]  - attr(*, "total_size")= num 2088
[09:29:15.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.647]  - attr(*, "already-done")= logi TRUE
[09:29:15.654] - reassign environment for ‘...future.FUN’
[09:29:15.654] - copied ‘...future.FUN’ to environment
[09:29:15.654] - copied ‘MoreArgs’ to environment
[09:29:15.654] - copied ‘...future.elements_ii’ to environment
[09:29:15.654] - copied ‘...future.seeds_ii’ to environment
[09:29:15.655] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.655] assign_globals() ... done
[09:29:15.655] requestCore(): workers = 2
[09:29:15.657] MulticoreFuture started
[09:29:15.658] - Launch lazy future ... done
[09:29:15.658] plan(): Setting new future strategy stack:
[09:29:15.658] run() for ‘MulticoreFuture’ ... done
[09:29:15.659] Created future:
[09:29:15.658] List of future strategies:
[09:29:15.658] 1. sequential:
[09:29:15.658]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.658]    - tweaked: FALSE
[09:29:15.658]    - call: NULL
[09:29:15.660] plan(): nbrOfWorkers() = 1
[09:29:15.663] plan(): Setting new future strategy stack:
[09:29:15.664] List of future strategies:
[09:29:15.664] 1. multicore:
[09:29:15.664]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.664]    - tweaked: FALSE
[09:29:15.664]    - call: plan(strategy)
[09:29:15.669] plan(): nbrOfWorkers() = 2
[09:29:15.659] MulticoreFuture:
[09:29:15.659] Label: ‘future_.mapply-1’
[09:29:15.659] Expression:
[09:29:15.659] {
[09:29:15.659]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.659]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.659]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.659]         on.exit(options(oopts), add = TRUE)
[09:29:15.659]     }
[09:29:15.659]     {
[09:29:15.659]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.659]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.659]         do.call(mapply, args = args)
[09:29:15.659]     }
[09:29:15.659] }
[09:29:15.659] Lazy evaluation: FALSE
[09:29:15.659] Asynchronous evaluation: TRUE
[09:29:15.659] Local evaluation: TRUE
[09:29:15.659] Environment: R_GlobalEnv
[09:29:15.659] Capture standard output: TRUE
[09:29:15.659] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.659] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.659] Packages: <none>
[09:29:15.659] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.659] Resolved: TRUE
[09:29:15.659] Value: <not collected>
[09:29:15.659] Conditions captured: <none>
[09:29:15.659] Early signaling: FALSE
[09:29:15.659] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.659] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.671] Chunk #1 of 2 ... DONE
[09:29:15.671] Chunk #2 of 2 ...
[09:29:15.671]  - Finding globals in '...' for chunk #2 ...
[09:29:15.671] getGlobalsAndPackages() ...
[09:29:15.672] Searching for globals...
[09:29:15.672] 
[09:29:15.672] Searching for globals ... DONE
[09:29:15.673] - globals: [0] <none>
[09:29:15.673] getGlobalsAndPackages() ... DONE
[09:29:15.673]    + additional globals found: [n=0] 
[09:29:15.673]    + additional namespaces needed: [n=0] 
[09:29:15.673]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:15.673]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:15.673]  - seeds: <none>
[09:29:15.674]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.674] getGlobalsAndPackages() ...
[09:29:15.674] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.674] Resolving globals: FALSE
[09:29:15.675] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[09:29:15.676] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:15.676] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.676] 
[09:29:15.676] getGlobalsAndPackages() ... DONE
[09:29:15.677] run() for ‘Future’ ...
[09:29:15.677] - state: ‘created’
[09:29:15.677] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.682] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.682] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.682]   - Field: ‘label’
[09:29:15.682]   - Field: ‘local’
[09:29:15.683]   - Field: ‘owner’
[09:29:15.683]   - Field: ‘envir’
[09:29:15.683]   - Field: ‘workers’
[09:29:15.683]   - Field: ‘packages’
[09:29:15.683]   - Field: ‘gc’
[09:29:15.683]   - Field: ‘job’
[09:29:15.683]   - Field: ‘conditions’
[09:29:15.684]   - Field: ‘expr’
[09:29:15.684]   - Field: ‘uuid’
[09:29:15.684]   - Field: ‘seed’
[09:29:15.684]   - Field: ‘version’
[09:29:15.684]   - Field: ‘result’
[09:29:15.684]   - Field: ‘asynchronous’
[09:29:15.684]   - Field: ‘calls’
[09:29:15.684]   - Field: ‘globals’
[09:29:15.685]   - Field: ‘stdout’
[09:29:15.685]   - Field: ‘earlySignal’
[09:29:15.685]   - Field: ‘lazy’
[09:29:15.685]   - Field: ‘state’
[09:29:15.685] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.685] - Launch lazy future ...
[09:29:15.686] Packages needed by the future expression (n = 0): <none>
[09:29:15.686] Packages needed by future strategies (n = 0): <none>
[09:29:15.686] {
[09:29:15.686]     {
[09:29:15.686]         {
[09:29:15.686]             ...future.startTime <- base::Sys.time()
[09:29:15.686]             {
[09:29:15.686]                 {
[09:29:15.686]                   {
[09:29:15.686]                     {
[09:29:15.686]                       base::local({
[09:29:15.686]                         has_future <- base::requireNamespace("future", 
[09:29:15.686]                           quietly = TRUE)
[09:29:15.686]                         if (has_future) {
[09:29:15.686]                           ns <- base::getNamespace("future")
[09:29:15.686]                           version <- ns[[".package"]][["version"]]
[09:29:15.686]                           if (is.null(version)) 
[09:29:15.686]                             version <- utils::packageVersion("future")
[09:29:15.686]                         }
[09:29:15.686]                         else {
[09:29:15.686]                           version <- NULL
[09:29:15.686]                         }
[09:29:15.686]                         if (!has_future || version < "1.8.0") {
[09:29:15.686]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.686]                             "", base::R.version$version.string), 
[09:29:15.686]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.686]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.686]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.686]                               "release", "version")], collapse = " "), 
[09:29:15.686]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.686]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.686]                             info)
[09:29:15.686]                           info <- base::paste(info, collapse = "; ")
[09:29:15.686]                           if (!has_future) {
[09:29:15.686]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.686]                               info)
[09:29:15.686]                           }
[09:29:15.686]                           else {
[09:29:15.686]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.686]                               info, version)
[09:29:15.686]                           }
[09:29:15.686]                           base::stop(msg)
[09:29:15.686]                         }
[09:29:15.686]                       })
[09:29:15.686]                     }
[09:29:15.686]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.686]                     base::options(mc.cores = 1L)
[09:29:15.686]                   }
[09:29:15.686]                   ...future.strategy.old <- future::plan("list")
[09:29:15.686]                   options(future.plan = NULL)
[09:29:15.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.686]                 }
[09:29:15.686]                 ...future.workdir <- getwd()
[09:29:15.686]             }
[09:29:15.686]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.686]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.686]         }
[09:29:15.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.686]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:15.686]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.686]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.686]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.686]             base::names(...future.oldOptions))
[09:29:15.686]     }
[09:29:15.686]     if (FALSE) {
[09:29:15.686]     }
[09:29:15.686]     else {
[09:29:15.686]         if (TRUE) {
[09:29:15.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.686]                 open = "w")
[09:29:15.686]         }
[09:29:15.686]         else {
[09:29:15.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.686]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.686]         }
[09:29:15.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.686]             base::sink(type = "output", split = FALSE)
[09:29:15.686]             base::close(...future.stdout)
[09:29:15.686]         }, add = TRUE)
[09:29:15.686]     }
[09:29:15.686]     ...future.frame <- base::sys.nframe()
[09:29:15.686]     ...future.conditions <- base::list()
[09:29:15.686]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.686]     if (FALSE) {
[09:29:15.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.686]     }
[09:29:15.686]     ...future.result <- base::tryCatch({
[09:29:15.686]         base::withCallingHandlers({
[09:29:15.686]             ...future.value <- base::withVisible(base::local({
[09:29:15.686]                 withCallingHandlers({
[09:29:15.686]                   {
[09:29:15.686]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.686]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.686]                       ...future.globals.maxSize)) {
[09:29:15.686]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.686]                       on.exit(options(oopts), add = TRUE)
[09:29:15.686]                     }
[09:29:15.686]                     {
[09:29:15.686]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.686]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.686]                         USE.NAMES = FALSE)
[09:29:15.686]                       do.call(mapply, args = args)
[09:29:15.686]                     }
[09:29:15.686]                   }
[09:29:15.686]                 }, immediateCondition = function(cond) {
[09:29:15.686]                   save_rds <- function (object, pathname, ...) 
[09:29:15.686]                   {
[09:29:15.686]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.686]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.686]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.686]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.686]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.686]                         fi_tmp[["mtime"]])
[09:29:15.686]                     }
[09:29:15.686]                     tryCatch({
[09:29:15.686]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.686]                     }, error = function(ex) {
[09:29:15.686]                       msg <- conditionMessage(ex)
[09:29:15.686]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.686]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.686]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.686]                         fi_tmp[["mtime"]], msg)
[09:29:15.686]                       ex$message <- msg
[09:29:15.686]                       stop(ex)
[09:29:15.686]                     })
[09:29:15.686]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.686]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.686]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.686]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.686]                       fi <- file.info(pathname)
[09:29:15.686]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.686]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.686]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.686]                         fi[["size"]], fi[["mtime"]])
[09:29:15.686]                       stop(msg)
[09:29:15.686]                     }
[09:29:15.686]                     invisible(pathname)
[09:29:15.686]                   }
[09:29:15.686]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.686]                     rootPath = tempdir()) 
[09:29:15.686]                   {
[09:29:15.686]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.686]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.686]                       tmpdir = path, fileext = ".rds")
[09:29:15.686]                     save_rds(obj, file)
[09:29:15.686]                   }
[09:29:15.686]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.686]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.686]                   {
[09:29:15.686]                     inherits <- base::inherits
[09:29:15.686]                     invokeRestart <- base::invokeRestart
[09:29:15.686]                     is.null <- base::is.null
[09:29:15.686]                     muffled <- FALSE
[09:29:15.686]                     if (inherits(cond, "message")) {
[09:29:15.686]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.686]                       if (muffled) 
[09:29:15.686]                         invokeRestart("muffleMessage")
[09:29:15.686]                     }
[09:29:15.686]                     else if (inherits(cond, "warning")) {
[09:29:15.686]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.686]                       if (muffled) 
[09:29:15.686]                         invokeRestart("muffleWarning")
[09:29:15.686]                     }
[09:29:15.686]                     else if (inherits(cond, "condition")) {
[09:29:15.686]                       if (!is.null(pattern)) {
[09:29:15.686]                         computeRestarts <- base::computeRestarts
[09:29:15.686]                         grepl <- base::grepl
[09:29:15.686]                         restarts <- computeRestarts(cond)
[09:29:15.686]                         for (restart in restarts) {
[09:29:15.686]                           name <- restart$name
[09:29:15.686]                           if (is.null(name)) 
[09:29:15.686]                             next
[09:29:15.686]                           if (!grepl(pattern, name)) 
[09:29:15.686]                             next
[09:29:15.686]                           invokeRestart(restart)
[09:29:15.686]                           muffled <- TRUE
[09:29:15.686]                           break
[09:29:15.686]                         }
[09:29:15.686]                       }
[09:29:15.686]                     }
[09:29:15.686]                     invisible(muffled)
[09:29:15.686]                   }
[09:29:15.686]                   muffleCondition(cond)
[09:29:15.686]                 })
[09:29:15.686]             }))
[09:29:15.686]             future::FutureResult(value = ...future.value$value, 
[09:29:15.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.686]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.686]                     ...future.globalenv.names))
[09:29:15.686]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.686]         }, condition = base::local({
[09:29:15.686]             c <- base::c
[09:29:15.686]             inherits <- base::inherits
[09:29:15.686]             invokeRestart <- base::invokeRestart
[09:29:15.686]             length <- base::length
[09:29:15.686]             list <- base::list
[09:29:15.686]             seq.int <- base::seq.int
[09:29:15.686]             signalCondition <- base::signalCondition
[09:29:15.686]             sys.calls <- base::sys.calls
[09:29:15.686]             `[[` <- base::`[[`
[09:29:15.686]             `+` <- base::`+`
[09:29:15.686]             `<<-` <- base::`<<-`
[09:29:15.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.686]                   3L)]
[09:29:15.686]             }
[09:29:15.686]             function(cond) {
[09:29:15.686]                 is_error <- inherits(cond, "error")
[09:29:15.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.686]                   NULL)
[09:29:15.686]                 if (is_error) {
[09:29:15.686]                   sessionInformation <- function() {
[09:29:15.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.686]                       search = base::search(), system = base::Sys.info())
[09:29:15.686]                   }
[09:29:15.686]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.686]                     cond$call), session = sessionInformation(), 
[09:29:15.686]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.686]                   signalCondition(cond)
[09:29:15.686]                 }
[09:29:15.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.686]                 "immediateCondition"))) {
[09:29:15.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.686]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.686]                   if (TRUE && !signal) {
[09:29:15.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.686]                     {
[09:29:15.686]                       inherits <- base::inherits
[09:29:15.686]                       invokeRestart <- base::invokeRestart
[09:29:15.686]                       is.null <- base::is.null
[09:29:15.686]                       muffled <- FALSE
[09:29:15.686]                       if (inherits(cond, "message")) {
[09:29:15.686]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.686]                         if (muffled) 
[09:29:15.686]                           invokeRestart("muffleMessage")
[09:29:15.686]                       }
[09:29:15.686]                       else if (inherits(cond, "warning")) {
[09:29:15.686]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.686]                         if (muffled) 
[09:29:15.686]                           invokeRestart("muffleWarning")
[09:29:15.686]                       }
[09:29:15.686]                       else if (inherits(cond, "condition")) {
[09:29:15.686]                         if (!is.null(pattern)) {
[09:29:15.686]                           computeRestarts <- base::computeRestarts
[09:29:15.686]                           grepl <- base::grepl
[09:29:15.686]                           restarts <- computeRestarts(cond)
[09:29:15.686]                           for (restart in restarts) {
[09:29:15.686]                             name <- restart$name
[09:29:15.686]                             if (is.null(name)) 
[09:29:15.686]                               next
[09:29:15.686]                             if (!grepl(pattern, name)) 
[09:29:15.686]                               next
[09:29:15.686]                             invokeRestart(restart)
[09:29:15.686]                             muffled <- TRUE
[09:29:15.686]                             break
[09:29:15.686]                           }
[09:29:15.686]                         }
[09:29:15.686]                       }
[09:29:15.686]                       invisible(muffled)
[09:29:15.686]                     }
[09:29:15.686]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.686]                   }
[09:29:15.686]                 }
[09:29:15.686]                 else {
[09:29:15.686]                   if (TRUE) {
[09:29:15.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.686]                     {
[09:29:15.686]                       inherits <- base::inherits
[09:29:15.686]                       invokeRestart <- base::invokeRestart
[09:29:15.686]                       is.null <- base::is.null
[09:29:15.686]                       muffled <- FALSE
[09:29:15.686]                       if (inherits(cond, "message")) {
[09:29:15.686]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.686]                         if (muffled) 
[09:29:15.686]                           invokeRestart("muffleMessage")
[09:29:15.686]                       }
[09:29:15.686]                       else if (inherits(cond, "warning")) {
[09:29:15.686]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.686]                         if (muffled) 
[09:29:15.686]                           invokeRestart("muffleWarning")
[09:29:15.686]                       }
[09:29:15.686]                       else if (inherits(cond, "condition")) {
[09:29:15.686]                         if (!is.null(pattern)) {
[09:29:15.686]                           computeRestarts <- base::computeRestarts
[09:29:15.686]                           grepl <- base::grepl
[09:29:15.686]                           restarts <- computeRestarts(cond)
[09:29:15.686]                           for (restart in restarts) {
[09:29:15.686]                             name <- restart$name
[09:29:15.686]                             if (is.null(name)) 
[09:29:15.686]                               next
[09:29:15.686]                             if (!grepl(pattern, name)) 
[09:29:15.686]                               next
[09:29:15.686]                             invokeRestart(restart)
[09:29:15.686]                             muffled <- TRUE
[09:29:15.686]                             break
[09:29:15.686]                           }
[09:29:15.686]                         }
[09:29:15.686]                       }
[09:29:15.686]                       invisible(muffled)
[09:29:15.686]                     }
[09:29:15.686]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.686]                   }
[09:29:15.686]                 }
[09:29:15.686]             }
[09:29:15.686]         }))
[09:29:15.686]     }, error = function(ex) {
[09:29:15.686]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.686]                 ...future.rng), started = ...future.startTime, 
[09:29:15.686]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.686]             version = "1.8"), class = "FutureResult")
[09:29:15.686]     }, finally = {
[09:29:15.686]         if (!identical(...future.workdir, getwd())) 
[09:29:15.686]             setwd(...future.workdir)
[09:29:15.686]         {
[09:29:15.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.686]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.686]             }
[09:29:15.686]             base::options(...future.oldOptions)
[09:29:15.686]             if (.Platform$OS.type == "windows") {
[09:29:15.686]                 old_names <- names(...future.oldEnvVars)
[09:29:15.686]                 envs <- base::Sys.getenv()
[09:29:15.686]                 names <- names(envs)
[09:29:15.686]                 common <- intersect(names, old_names)
[09:29:15.686]                 added <- setdiff(names, old_names)
[09:29:15.686]                 removed <- setdiff(old_names, names)
[09:29:15.686]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.686]                   envs[common]]
[09:29:15.686]                 NAMES <- toupper(changed)
[09:29:15.686]                 args <- list()
[09:29:15.686]                 for (kk in seq_along(NAMES)) {
[09:29:15.686]                   name <- changed[[kk]]
[09:29:15.686]                   NAME <- NAMES[[kk]]
[09:29:15.686]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.686]                     next
[09:29:15.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.686]                 }
[09:29:15.686]                 NAMES <- toupper(added)
[09:29:15.686]                 for (kk in seq_along(NAMES)) {
[09:29:15.686]                   name <- added[[kk]]
[09:29:15.686]                   NAME <- NAMES[[kk]]
[09:29:15.686]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.686]                     next
[09:29:15.686]                   args[[name]] <- ""
[09:29:15.686]                 }
[09:29:15.686]                 NAMES <- toupper(removed)
[09:29:15.686]                 for (kk in seq_along(NAMES)) {
[09:29:15.686]                   name <- removed[[kk]]
[09:29:15.686]                   NAME <- NAMES[[kk]]
[09:29:15.686]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.686]                     next
[09:29:15.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.686]                 }
[09:29:15.686]                 if (length(args) > 0) 
[09:29:15.686]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.686]             }
[09:29:15.686]             else {
[09:29:15.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.686]             }
[09:29:15.686]             {
[09:29:15.686]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.686]                   0L) {
[09:29:15.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.686]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.686]                   base::options(opts)
[09:29:15.686]                 }
[09:29:15.686]                 {
[09:29:15.686]                   {
[09:29:15.686]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.686]                     NULL
[09:29:15.686]                   }
[09:29:15.686]                   options(future.plan = NULL)
[09:29:15.686]                   if (is.na(NA_character_)) 
[09:29:15.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.686]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.686]                     .init = FALSE)
[09:29:15.686]                 }
[09:29:15.686]             }
[09:29:15.686]         }
[09:29:15.686]     })
[09:29:15.686]     if (TRUE) {
[09:29:15.686]         base::sink(type = "output", split = FALSE)
[09:29:15.686]         if (TRUE) {
[09:29:15.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.686]         }
[09:29:15.686]         else {
[09:29:15.686]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.686]         }
[09:29:15.686]         base::close(...future.stdout)
[09:29:15.686]         ...future.stdout <- NULL
[09:29:15.686]     }
[09:29:15.686]     ...future.result$conditions <- ...future.conditions
[09:29:15.686]     ...future.result$finished <- base::Sys.time()
[09:29:15.686]     ...future.result
[09:29:15.686] }
[09:29:15.690] assign_globals() ...
[09:29:15.690] List of 5
[09:29:15.690]  $ ...future.FUN            :function (x, y)  
[09:29:15.690]  $ MoreArgs                 : list()
[09:29:15.690]  $ ...future.elements_ii    :List of 2
[09:29:15.690]   ..$ :List of 2
[09:29:15.690]   .. ..$ b: num 2
[09:29:15.690]   .. ..$ c: num 3
[09:29:15.690]   ..$ :List of 2
[09:29:15.690]   .. ..$ B: num 0
[09:29:15.690]   .. ..$ C: num -10
[09:29:15.690]  $ ...future.seeds_ii       : NULL
[09:29:15.690]  $ ...future.globals.maxSize: NULL
[09:29:15.690]  - attr(*, "where")=List of 5
[09:29:15.690]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.690]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.690]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.690]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.690]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.690]  - attr(*, "resolved")= logi FALSE
[09:29:15.690]  - attr(*, "total_size")= num 2200
[09:29:15.690]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.690]  - attr(*, "already-done")= logi TRUE
[09:29:15.698] - reassign environment for ‘...future.FUN’
[09:29:15.698] - copied ‘...future.FUN’ to environment
[09:29:15.698] - copied ‘MoreArgs’ to environment
[09:29:15.698] - copied ‘...future.elements_ii’ to environment
[09:29:15.698] - copied ‘...future.seeds_ii’ to environment
[09:29:15.698] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.698] assign_globals() ... done
[09:29:15.699] requestCore(): workers = 2
[09:29:15.701] MulticoreFuture started
[09:29:15.701] - Launch lazy future ... done
[09:29:15.702] run() for ‘MulticoreFuture’ ... done
[09:29:15.702] Created future:
[09:29:15.702] plan(): Setting new future strategy stack:
[09:29:15.702] List of future strategies:
[09:29:15.702] 1. sequential:
[09:29:15.702]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.702]    - tweaked: FALSE
[09:29:15.702]    - call: NULL
[09:29:15.703] plan(): nbrOfWorkers() = 1
[09:29:15.705] plan(): Setting new future strategy stack:
[09:29:15.705] List of future strategies:
[09:29:15.705] 1. multicore:
[09:29:15.705]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.705]    - tweaked: FALSE
[09:29:15.705]    - call: plan(strategy)
[09:29:15.702] MulticoreFuture:
[09:29:15.702] Label: ‘future_.mapply-2’
[09:29:15.702] Expression:
[09:29:15.702] {
[09:29:15.702]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.702]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.702]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.702]         on.exit(options(oopts), add = TRUE)
[09:29:15.702]     }
[09:29:15.702]     {
[09:29:15.702]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.702]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.702]         do.call(mapply, args = args)
[09:29:15.702]     }
[09:29:15.702] }
[09:29:15.702] Lazy evaluation: FALSE
[09:29:15.702] Asynchronous evaluation: TRUE
[09:29:15.702] Local evaluation: TRUE
[09:29:15.702] Environment: R_GlobalEnv
[09:29:15.702] Capture standard output: TRUE
[09:29:15.702] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.702] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.702] Packages: <none>
[09:29:15.702] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.702] Resolved: FALSE
[09:29:15.702] Value: <not collected>
[09:29:15.702] Conditions captured: <none>
[09:29:15.702] Early signaling: FALSE
[09:29:15.702] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.702] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.714] Chunk #2 of 2 ... DONE
[09:29:15.715] Launching 2 futures (chunks) ... DONE
[09:29:15.715] Resolving 2 futures (chunks) ...
[09:29:15.715] resolve() on list ...
[09:29:15.715]  recursive: 0
[09:29:15.715]  length: 2
[09:29:15.716] plan(): nbrOfWorkers() = 2
[09:29:15.715] 
[09:29:15.719] Future #1
[09:29:15.719] result() for MulticoreFuture ...
[09:29:15.720] result() for MulticoreFuture ...
[09:29:15.720] result() for MulticoreFuture ... done
[09:29:15.721] result() for MulticoreFuture ... done
[09:29:15.721] result() for MulticoreFuture ...
[09:29:15.721] result() for MulticoreFuture ... done
[09:29:15.721] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:15.722] - nx: 2
[09:29:15.722] - relay: TRUE
[09:29:15.722] - stdout: TRUE
[09:29:15.722] - signal: TRUE
[09:29:15.722] - resignal: FALSE
[09:29:15.723] - force: TRUE
[09:29:15.723] - relayed: [n=2] FALSE, FALSE
[09:29:15.723] - queued futures: [n=2] FALSE, FALSE
[09:29:15.724]  - until=1
[09:29:15.724]  - relaying element #1
[09:29:15.724] result() for MulticoreFuture ...
[09:29:15.724] result() for MulticoreFuture ... done
[09:29:15.725] result() for MulticoreFuture ...
[09:29:15.725] result() for MulticoreFuture ... done
[09:29:15.725] result() for MulticoreFuture ...
[09:29:15.725] result() for MulticoreFuture ... done
[09:29:15.726] result() for MulticoreFuture ...
[09:29:15.726] result() for MulticoreFuture ... done
[09:29:15.726] - relayed: [n=2] TRUE, FALSE
[09:29:15.726] - queued futures: [n=2] TRUE, FALSE
[09:29:15.726] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:15.727]  length: 1 (resolved future 1)
[09:29:15.727] Future #2
[09:29:15.727] result() for MulticoreFuture ...
[09:29:15.728] result() for MulticoreFuture ...
[09:29:15.728] result() for MulticoreFuture ... done
[09:29:15.728] result() for MulticoreFuture ... done
[09:29:15.728] result() for MulticoreFuture ...
[09:29:15.728] result() for MulticoreFuture ... done
[09:29:15.728] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:15.729] - nx: 2
[09:29:15.729] - relay: TRUE
[09:29:15.729] - stdout: TRUE
[09:29:15.729] - signal: TRUE
[09:29:15.729] - resignal: FALSE
[09:29:15.729] - force: TRUE
[09:29:15.729] - relayed: [n=2] TRUE, FALSE
[09:29:15.729] - queued futures: [n=2] TRUE, FALSE
[09:29:15.729]  - until=2
[09:29:15.730]  - relaying element #2
[09:29:15.730] result() for MulticoreFuture ...
[09:29:15.730] result() for MulticoreFuture ... done
[09:29:15.730] result() for MulticoreFuture ...
[09:29:15.730] result() for MulticoreFuture ... done
[09:29:15.730] result() for MulticoreFuture ...
[09:29:15.730] result() for MulticoreFuture ... done
[09:29:15.731] result() for MulticoreFuture ...
[09:29:15.731] result() for MulticoreFuture ... done
[09:29:15.731] - relayed: [n=2] TRUE, TRUE
[09:29:15.731] - queued futures: [n=2] TRUE, TRUE
[09:29:15.731] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:15.731]  length: 0 (resolved future 2)
[09:29:15.731] Relaying remaining futures
[09:29:15.731] signalConditionsASAP(NULL, pos=0) ...
[09:29:15.731] - nx: 2
[09:29:15.731] - relay: TRUE
[09:29:15.732] - stdout: TRUE
[09:29:15.732] - signal: TRUE
[09:29:15.732] - resignal: FALSE
[09:29:15.732] - force: TRUE
[09:29:15.732] - relayed: [n=2] TRUE, TRUE
[09:29:15.732] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:15.732] - relayed: [n=2] TRUE, TRUE
[09:29:15.732] - queued futures: [n=2] TRUE, TRUE
[09:29:15.732] signalConditionsASAP(NULL, pos=0) ... done
[09:29:15.733] resolve() on list ... DONE
[09:29:15.733] result() for MulticoreFuture ...
[09:29:15.733] result() for MulticoreFuture ... done
[09:29:15.733] result() for MulticoreFuture ...
[09:29:15.733] result() for MulticoreFuture ... done
[09:29:15.733] result() for MulticoreFuture ...
[09:29:15.733] result() for MulticoreFuture ... done
[09:29:15.733] result() for MulticoreFuture ...
[09:29:15.733] result() for MulticoreFuture ... done
[09:29:15.734]  - Number of value chunks collected: 2
[09:29:15.734] Resolving 2 futures (chunks) ... DONE
[09:29:15.734] Reducing values from 2 chunks ...
[09:29:15.734]  - Number of values collected after concatenation: 3
[09:29:15.734]  - Number of values expected: 3
[09:29:15.734] Reducing values from 2 chunks ... DONE
[09:29:15.734] future_mapply() ... DONE
[09:29:15.734] future_mapply() ...
[09:29:15.739] Number of chunks: 5
[09:29:15.739] getGlobalsAndPackagesXApply() ...
[09:29:15.739]  - future.globals: TRUE
[09:29:15.739] getGlobalsAndPackages() ...
[09:29:15.739] Searching for globals...
[09:29:15.741] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:15.741] Searching for globals ... DONE
[09:29:15.741] Resolving globals: FALSE
[09:29:15.741] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:15.742] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:15.742] - globals: [1] ‘FUN’
[09:29:15.742] 
[09:29:15.742] getGlobalsAndPackages() ... DONE
[09:29:15.742]  - globals found/used: [n=1] ‘FUN’
[09:29:15.742]  - needed namespaces: [n=0] 
[09:29:15.742] Finding globals ... DONE
[09:29:15.743] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:15.743] List of 2
[09:29:15.743]  $ ...future.FUN:function (C, k)  
[09:29:15.743]  $ MoreArgs     : NULL
[09:29:15.743]  - attr(*, "where")=List of 2
[09:29:15.743]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:15.743]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:15.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.743]  - attr(*, "resolved")= logi FALSE
[09:29:15.743]  - attr(*, "total_size")= num NA
[09:29:15.745] Packages to be attached in all futures: [n=0] 
[09:29:15.746] getGlobalsAndPackagesXApply() ... DONE
[09:29:15.746] Number of futures (= number of chunks): 5
[09:29:15.746] Launching 5 futures (chunks) ...
[09:29:15.746] Chunk #1 of 5 ...
[09:29:15.746]  - Finding globals in '...' for chunk #1 ...
[09:29:15.746] getGlobalsAndPackages() ...
[09:29:15.746] Searching for globals...
[09:29:15.747] 
[09:29:15.747] Searching for globals ... DONE
[09:29:15.747] - globals: [0] <none>
[09:29:15.747] getGlobalsAndPackages() ... DONE
[09:29:15.747]    + additional globals found: [n=0] 
[09:29:15.747]    + additional namespaces needed: [n=0] 
[09:29:15.747]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:15.747]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:15.747]  - seeds: <none>
[09:29:15.748]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.748] getGlobalsAndPackages() ...
[09:29:15.748] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.748] Resolving globals: FALSE
[09:29:15.748] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:15.751] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.751] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.751] 
[09:29:15.751] getGlobalsAndPackages() ... DONE
[09:29:15.752] run() for ‘Future’ ...
[09:29:15.752] - state: ‘created’
[09:29:15.752] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.755] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.756] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.756]   - Field: ‘label’
[09:29:15.756]   - Field: ‘local’
[09:29:15.756]   - Field: ‘owner’
[09:29:15.756]   - Field: ‘envir’
[09:29:15.756]   - Field: ‘workers’
[09:29:15.756]   - Field: ‘packages’
[09:29:15.756]   - Field: ‘gc’
[09:29:15.756]   - Field: ‘job’
[09:29:15.757]   - Field: ‘conditions’
[09:29:15.757]   - Field: ‘expr’
[09:29:15.757]   - Field: ‘uuid’
[09:29:15.757]   - Field: ‘seed’
[09:29:15.757]   - Field: ‘version’
[09:29:15.757]   - Field: ‘result’
[09:29:15.757]   - Field: ‘asynchronous’
[09:29:15.757]   - Field: ‘calls’
[09:29:15.757]   - Field: ‘globals’
[09:29:15.757]   - Field: ‘stdout’
[09:29:15.757]   - Field: ‘earlySignal’
[09:29:15.758]   - Field: ‘lazy’
[09:29:15.758]   - Field: ‘state’
[09:29:15.758] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.758] - Launch lazy future ...
[09:29:15.758] Packages needed by the future expression (n = 0): <none>
[09:29:15.758] Packages needed by future strategies (n = 0): <none>
[09:29:15.759] {
[09:29:15.759]     {
[09:29:15.759]         {
[09:29:15.759]             ...future.startTime <- base::Sys.time()
[09:29:15.759]             {
[09:29:15.759]                 {
[09:29:15.759]                   {
[09:29:15.759]                     {
[09:29:15.759]                       base::local({
[09:29:15.759]                         has_future <- base::requireNamespace("future", 
[09:29:15.759]                           quietly = TRUE)
[09:29:15.759]                         if (has_future) {
[09:29:15.759]                           ns <- base::getNamespace("future")
[09:29:15.759]                           version <- ns[[".package"]][["version"]]
[09:29:15.759]                           if (is.null(version)) 
[09:29:15.759]                             version <- utils::packageVersion("future")
[09:29:15.759]                         }
[09:29:15.759]                         else {
[09:29:15.759]                           version <- NULL
[09:29:15.759]                         }
[09:29:15.759]                         if (!has_future || version < "1.8.0") {
[09:29:15.759]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.759]                             "", base::R.version$version.string), 
[09:29:15.759]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.759]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.759]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.759]                               "release", "version")], collapse = " "), 
[09:29:15.759]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.759]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.759]                             info)
[09:29:15.759]                           info <- base::paste(info, collapse = "; ")
[09:29:15.759]                           if (!has_future) {
[09:29:15.759]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.759]                               info)
[09:29:15.759]                           }
[09:29:15.759]                           else {
[09:29:15.759]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.759]                               info, version)
[09:29:15.759]                           }
[09:29:15.759]                           base::stop(msg)
[09:29:15.759]                         }
[09:29:15.759]                       })
[09:29:15.759]                     }
[09:29:15.759]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.759]                     base::options(mc.cores = 1L)
[09:29:15.759]                   }
[09:29:15.759]                   ...future.strategy.old <- future::plan("list")
[09:29:15.759]                   options(future.plan = NULL)
[09:29:15.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.759]                 }
[09:29:15.759]                 ...future.workdir <- getwd()
[09:29:15.759]             }
[09:29:15.759]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.759]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.759]         }
[09:29:15.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.759]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:15.759]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.759]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.759]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.759]             base::names(...future.oldOptions))
[09:29:15.759]     }
[09:29:15.759]     if (FALSE) {
[09:29:15.759]     }
[09:29:15.759]     else {
[09:29:15.759]         if (TRUE) {
[09:29:15.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.759]                 open = "w")
[09:29:15.759]         }
[09:29:15.759]         else {
[09:29:15.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.759]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.759]         }
[09:29:15.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.759]             base::sink(type = "output", split = FALSE)
[09:29:15.759]             base::close(...future.stdout)
[09:29:15.759]         }, add = TRUE)
[09:29:15.759]     }
[09:29:15.759]     ...future.frame <- base::sys.nframe()
[09:29:15.759]     ...future.conditions <- base::list()
[09:29:15.759]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.759]     if (FALSE) {
[09:29:15.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.759]     }
[09:29:15.759]     ...future.result <- base::tryCatch({
[09:29:15.759]         base::withCallingHandlers({
[09:29:15.759]             ...future.value <- base::withVisible(base::local({
[09:29:15.759]                 withCallingHandlers({
[09:29:15.759]                   {
[09:29:15.759]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.759]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.759]                       ...future.globals.maxSize)) {
[09:29:15.759]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.759]                       on.exit(options(oopts), add = TRUE)
[09:29:15.759]                     }
[09:29:15.759]                     {
[09:29:15.759]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.759]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.759]                         USE.NAMES = FALSE)
[09:29:15.759]                       do.call(mapply, args = args)
[09:29:15.759]                     }
[09:29:15.759]                   }
[09:29:15.759]                 }, immediateCondition = function(cond) {
[09:29:15.759]                   save_rds <- function (object, pathname, ...) 
[09:29:15.759]                   {
[09:29:15.759]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.759]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.759]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.759]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.759]                         fi_tmp[["mtime"]])
[09:29:15.759]                     }
[09:29:15.759]                     tryCatch({
[09:29:15.759]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.759]                     }, error = function(ex) {
[09:29:15.759]                       msg <- conditionMessage(ex)
[09:29:15.759]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.759]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.759]                         fi_tmp[["mtime"]], msg)
[09:29:15.759]                       ex$message <- msg
[09:29:15.759]                       stop(ex)
[09:29:15.759]                     })
[09:29:15.759]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.759]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.759]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.759]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.759]                       fi <- file.info(pathname)
[09:29:15.759]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.759]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.759]                         fi[["size"]], fi[["mtime"]])
[09:29:15.759]                       stop(msg)
[09:29:15.759]                     }
[09:29:15.759]                     invisible(pathname)
[09:29:15.759]                   }
[09:29:15.759]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.759]                     rootPath = tempdir()) 
[09:29:15.759]                   {
[09:29:15.759]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.759]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.759]                       tmpdir = path, fileext = ".rds")
[09:29:15.759]                     save_rds(obj, file)
[09:29:15.759]                   }
[09:29:15.759]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.759]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.759]                   {
[09:29:15.759]                     inherits <- base::inherits
[09:29:15.759]                     invokeRestart <- base::invokeRestart
[09:29:15.759]                     is.null <- base::is.null
[09:29:15.759]                     muffled <- FALSE
[09:29:15.759]                     if (inherits(cond, "message")) {
[09:29:15.759]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.759]                       if (muffled) 
[09:29:15.759]                         invokeRestart("muffleMessage")
[09:29:15.759]                     }
[09:29:15.759]                     else if (inherits(cond, "warning")) {
[09:29:15.759]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.759]                       if (muffled) 
[09:29:15.759]                         invokeRestart("muffleWarning")
[09:29:15.759]                     }
[09:29:15.759]                     else if (inherits(cond, "condition")) {
[09:29:15.759]                       if (!is.null(pattern)) {
[09:29:15.759]                         computeRestarts <- base::computeRestarts
[09:29:15.759]                         grepl <- base::grepl
[09:29:15.759]                         restarts <- computeRestarts(cond)
[09:29:15.759]                         for (restart in restarts) {
[09:29:15.759]                           name <- restart$name
[09:29:15.759]                           if (is.null(name)) 
[09:29:15.759]                             next
[09:29:15.759]                           if (!grepl(pattern, name)) 
[09:29:15.759]                             next
[09:29:15.759]                           invokeRestart(restart)
[09:29:15.759]                           muffled <- TRUE
[09:29:15.759]                           break
[09:29:15.759]                         }
[09:29:15.759]                       }
[09:29:15.759]                     }
[09:29:15.759]                     invisible(muffled)
[09:29:15.759]                   }
[09:29:15.759]                   muffleCondition(cond)
[09:29:15.759]                 })
[09:29:15.759]             }))
[09:29:15.759]             future::FutureResult(value = ...future.value$value, 
[09:29:15.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.759]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.759]                     ...future.globalenv.names))
[09:29:15.759]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.759]         }, condition = base::local({
[09:29:15.759]             c <- base::c
[09:29:15.759]             inherits <- base::inherits
[09:29:15.759]             invokeRestart <- base::invokeRestart
[09:29:15.759]             length <- base::length
[09:29:15.759]             list <- base::list
[09:29:15.759]             seq.int <- base::seq.int
[09:29:15.759]             signalCondition <- base::signalCondition
[09:29:15.759]             sys.calls <- base::sys.calls
[09:29:15.759]             `[[` <- base::`[[`
[09:29:15.759]             `+` <- base::`+`
[09:29:15.759]             `<<-` <- base::`<<-`
[09:29:15.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.759]                   3L)]
[09:29:15.759]             }
[09:29:15.759]             function(cond) {
[09:29:15.759]                 is_error <- inherits(cond, "error")
[09:29:15.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.759]                   NULL)
[09:29:15.759]                 if (is_error) {
[09:29:15.759]                   sessionInformation <- function() {
[09:29:15.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.759]                       search = base::search(), system = base::Sys.info())
[09:29:15.759]                   }
[09:29:15.759]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.759]                     cond$call), session = sessionInformation(), 
[09:29:15.759]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.759]                   signalCondition(cond)
[09:29:15.759]                 }
[09:29:15.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.759]                 "immediateCondition"))) {
[09:29:15.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.759]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.759]                   if (TRUE && !signal) {
[09:29:15.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.759]                     {
[09:29:15.759]                       inherits <- base::inherits
[09:29:15.759]                       invokeRestart <- base::invokeRestart
[09:29:15.759]                       is.null <- base::is.null
[09:29:15.759]                       muffled <- FALSE
[09:29:15.759]                       if (inherits(cond, "message")) {
[09:29:15.759]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.759]                         if (muffled) 
[09:29:15.759]                           invokeRestart("muffleMessage")
[09:29:15.759]                       }
[09:29:15.759]                       else if (inherits(cond, "warning")) {
[09:29:15.759]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.759]                         if (muffled) 
[09:29:15.759]                           invokeRestart("muffleWarning")
[09:29:15.759]                       }
[09:29:15.759]                       else if (inherits(cond, "condition")) {
[09:29:15.759]                         if (!is.null(pattern)) {
[09:29:15.759]                           computeRestarts <- base::computeRestarts
[09:29:15.759]                           grepl <- base::grepl
[09:29:15.759]                           restarts <- computeRestarts(cond)
[09:29:15.759]                           for (restart in restarts) {
[09:29:15.759]                             name <- restart$name
[09:29:15.759]                             if (is.null(name)) 
[09:29:15.759]                               next
[09:29:15.759]                             if (!grepl(pattern, name)) 
[09:29:15.759]                               next
[09:29:15.759]                             invokeRestart(restart)
[09:29:15.759]                             muffled <- TRUE
[09:29:15.759]                             break
[09:29:15.759]                           }
[09:29:15.759]                         }
[09:29:15.759]                       }
[09:29:15.759]                       invisible(muffled)
[09:29:15.759]                     }
[09:29:15.759]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.759]                   }
[09:29:15.759]                 }
[09:29:15.759]                 else {
[09:29:15.759]                   if (TRUE) {
[09:29:15.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.759]                     {
[09:29:15.759]                       inherits <- base::inherits
[09:29:15.759]                       invokeRestart <- base::invokeRestart
[09:29:15.759]                       is.null <- base::is.null
[09:29:15.759]                       muffled <- FALSE
[09:29:15.759]                       if (inherits(cond, "message")) {
[09:29:15.759]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.759]                         if (muffled) 
[09:29:15.759]                           invokeRestart("muffleMessage")
[09:29:15.759]                       }
[09:29:15.759]                       else if (inherits(cond, "warning")) {
[09:29:15.759]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.759]                         if (muffled) 
[09:29:15.759]                           invokeRestart("muffleWarning")
[09:29:15.759]                       }
[09:29:15.759]                       else if (inherits(cond, "condition")) {
[09:29:15.759]                         if (!is.null(pattern)) {
[09:29:15.759]                           computeRestarts <- base::computeRestarts
[09:29:15.759]                           grepl <- base::grepl
[09:29:15.759]                           restarts <- computeRestarts(cond)
[09:29:15.759]                           for (restart in restarts) {
[09:29:15.759]                             name <- restart$name
[09:29:15.759]                             if (is.null(name)) 
[09:29:15.759]                               next
[09:29:15.759]                             if (!grepl(pattern, name)) 
[09:29:15.759]                               next
[09:29:15.759]                             invokeRestart(restart)
[09:29:15.759]                             muffled <- TRUE
[09:29:15.759]                             break
[09:29:15.759]                           }
[09:29:15.759]                         }
[09:29:15.759]                       }
[09:29:15.759]                       invisible(muffled)
[09:29:15.759]                     }
[09:29:15.759]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.759]                   }
[09:29:15.759]                 }
[09:29:15.759]             }
[09:29:15.759]         }))
[09:29:15.759]     }, error = function(ex) {
[09:29:15.759]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.759]                 ...future.rng), started = ...future.startTime, 
[09:29:15.759]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.759]             version = "1.8"), class = "FutureResult")
[09:29:15.759]     }, finally = {
[09:29:15.759]         if (!identical(...future.workdir, getwd())) 
[09:29:15.759]             setwd(...future.workdir)
[09:29:15.759]         {
[09:29:15.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.759]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.759]             }
[09:29:15.759]             base::options(...future.oldOptions)
[09:29:15.759]             if (.Platform$OS.type == "windows") {
[09:29:15.759]                 old_names <- names(...future.oldEnvVars)
[09:29:15.759]                 envs <- base::Sys.getenv()
[09:29:15.759]                 names <- names(envs)
[09:29:15.759]                 common <- intersect(names, old_names)
[09:29:15.759]                 added <- setdiff(names, old_names)
[09:29:15.759]                 removed <- setdiff(old_names, names)
[09:29:15.759]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.759]                   envs[common]]
[09:29:15.759]                 NAMES <- toupper(changed)
[09:29:15.759]                 args <- list()
[09:29:15.759]                 for (kk in seq_along(NAMES)) {
[09:29:15.759]                   name <- changed[[kk]]
[09:29:15.759]                   NAME <- NAMES[[kk]]
[09:29:15.759]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.759]                     next
[09:29:15.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.759]                 }
[09:29:15.759]                 NAMES <- toupper(added)
[09:29:15.759]                 for (kk in seq_along(NAMES)) {
[09:29:15.759]                   name <- added[[kk]]
[09:29:15.759]                   NAME <- NAMES[[kk]]
[09:29:15.759]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.759]                     next
[09:29:15.759]                   args[[name]] <- ""
[09:29:15.759]                 }
[09:29:15.759]                 NAMES <- toupper(removed)
[09:29:15.759]                 for (kk in seq_along(NAMES)) {
[09:29:15.759]                   name <- removed[[kk]]
[09:29:15.759]                   NAME <- NAMES[[kk]]
[09:29:15.759]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.759]                     next
[09:29:15.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.759]                 }
[09:29:15.759]                 if (length(args) > 0) 
[09:29:15.759]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.759]             }
[09:29:15.759]             else {
[09:29:15.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.759]             }
[09:29:15.759]             {
[09:29:15.759]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.759]                   0L) {
[09:29:15.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.759]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.759]                   base::options(opts)
[09:29:15.759]                 }
[09:29:15.759]                 {
[09:29:15.759]                   {
[09:29:15.759]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.759]                     NULL
[09:29:15.759]                   }
[09:29:15.759]                   options(future.plan = NULL)
[09:29:15.759]                   if (is.na(NA_character_)) 
[09:29:15.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.759]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.759]                     .init = FALSE)
[09:29:15.759]                 }
[09:29:15.759]             }
[09:29:15.759]         }
[09:29:15.759]     })
[09:29:15.759]     if (TRUE) {
[09:29:15.759]         base::sink(type = "output", split = FALSE)
[09:29:15.759]         if (TRUE) {
[09:29:15.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.759]         }
[09:29:15.759]         else {
[09:29:15.759]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.759]         }
[09:29:15.759]         base::close(...future.stdout)
[09:29:15.759]         ...future.stdout <- NULL
[09:29:15.759]     }
[09:29:15.759]     ...future.result$conditions <- ...future.conditions
[09:29:15.759]     ...future.result$finished <- base::Sys.time()
[09:29:15.759]     ...future.result
[09:29:15.759] }
[09:29:15.761] assign_globals() ...
[09:29:15.761] List of 5
[09:29:15.761]  $ ...future.FUN            :function (C, k)  
[09:29:15.761]  $ MoreArgs                 : NULL
[09:29:15.761]  $ ...future.elements_ii    :List of 2
[09:29:15.761]   ..$ :List of 1
[09:29:15.761]   .. ..$ : chr "A"
[09:29:15.761]   ..$ :List of 1
[09:29:15.761]   .. ..$ : int 5
[09:29:15.761]  $ ...future.seeds_ii       : NULL
[09:29:15.761]  $ ...future.globals.maxSize: NULL
[09:29:15.761]  - attr(*, "where")=List of 5
[09:29:15.761]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.761]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.761]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.761]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.761]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.761]  - attr(*, "resolved")= logi FALSE
[09:29:15.761]  - attr(*, "total_size")= num 3488
[09:29:15.761]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.761]  - attr(*, "already-done")= logi TRUE
[09:29:15.766] - reassign environment for ‘...future.FUN’
[09:29:15.766] - copied ‘...future.FUN’ to environment
[09:29:15.766] - copied ‘MoreArgs’ to environment
[09:29:15.766] - copied ‘...future.elements_ii’ to environment
[09:29:15.766] - copied ‘...future.seeds_ii’ to environment
[09:29:15.766] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.767] assign_globals() ... done
[09:29:15.767] requestCore(): workers = 2
[09:29:15.768] MulticoreFuture started
[09:29:15.769] - Launch lazy future ... done
[09:29:15.769] run() for ‘MulticoreFuture’ ... done
[09:29:15.769] Created future:
[09:29:15.769] plan(): Setting new future strategy stack:
[09:29:15.770] List of future strategies:
[09:29:15.770] 1. sequential:
[09:29:15.770]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.770]    - tweaked: FALSE
[09:29:15.770]    - call: NULL
[09:29:15.771] plan(): nbrOfWorkers() = 1
[09:29:15.773] plan(): Setting new future strategy stack:
[09:29:15.773] List of future strategies:
[09:29:15.773] 1. multicore:
[09:29:15.773]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.773]    - tweaked: FALSE
[09:29:15.773]    - call: plan(strategy)
[09:29:15.778] plan(): nbrOfWorkers() = 2
[09:29:15.769] MulticoreFuture:
[09:29:15.769] Label: ‘future_mapply-1’
[09:29:15.769] Expression:
[09:29:15.769] {
[09:29:15.769]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.769]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.769]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.769]         on.exit(options(oopts), add = TRUE)
[09:29:15.769]     }
[09:29:15.769]     {
[09:29:15.769]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.769]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.769]         do.call(mapply, args = args)
[09:29:15.769]     }
[09:29:15.769] }
[09:29:15.769] Lazy evaluation: FALSE
[09:29:15.769] Asynchronous evaluation: TRUE
[09:29:15.769] Local evaluation: TRUE
[09:29:15.769] Environment: R_GlobalEnv
[09:29:15.769] Capture standard output: TRUE
[09:29:15.769] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.769] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.769] Packages: <none>
[09:29:15.769] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.769] Resolved: TRUE
[09:29:15.769] Value: <not collected>
[09:29:15.769] Conditions captured: <none>
[09:29:15.769] Early signaling: FALSE
[09:29:15.769] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.769] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.779] Chunk #1 of 5 ... DONE
[09:29:15.779] Chunk #2 of 5 ...
[09:29:15.779]  - Finding globals in '...' for chunk #2 ...
[09:29:15.779] getGlobalsAndPackages() ...
[09:29:15.780] Searching for globals...
[09:29:15.780] 
[09:29:15.780] Searching for globals ... DONE
[09:29:15.780] - globals: [0] <none>
[09:29:15.781] getGlobalsAndPackages() ... DONE
[09:29:15.781]    + additional globals found: [n=0] 
[09:29:15.781]    + additional namespaces needed: [n=0] 
[09:29:15.781]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:15.781]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:15.781]  - seeds: <none>
[09:29:15.781]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.782] getGlobalsAndPackages() ...
[09:29:15.782] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.782] Resolving globals: FALSE
[09:29:15.783] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:15.784] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.784] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.784] 
[09:29:15.784] getGlobalsAndPackages() ... DONE
[09:29:15.785] run() for ‘Future’ ...
[09:29:15.785] - state: ‘created’
[09:29:15.785] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.790] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.790] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.790]   - Field: ‘label’
[09:29:15.790]   - Field: ‘local’
[09:29:15.790]   - Field: ‘owner’
[09:29:15.791]   - Field: ‘envir’
[09:29:15.791]   - Field: ‘workers’
[09:29:15.791]   - Field: ‘packages’
[09:29:15.791]   - Field: ‘gc’
[09:29:15.791]   - Field: ‘job’
[09:29:15.791]   - Field: ‘conditions’
[09:29:15.791]   - Field: ‘expr’
[09:29:15.792]   - Field: ‘uuid’
[09:29:15.792]   - Field: ‘seed’
[09:29:15.792]   - Field: ‘version’
[09:29:15.795]   - Field: ‘result’
[09:29:15.796]   - Field: ‘asynchronous’
[09:29:15.796]   - Field: ‘calls’
[09:29:15.796]   - Field: ‘globals’
[09:29:15.797]   - Field: ‘stdout’
[09:29:15.797]   - Field: ‘earlySignal’
[09:29:15.797]   - Field: ‘lazy’
[09:29:15.797]   - Field: ‘state’
[09:29:15.798] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.798] - Launch lazy future ...
[09:29:15.799] Packages needed by the future expression (n = 0): <none>
[09:29:15.799] Packages needed by future strategies (n = 0): <none>
[09:29:15.800] {
[09:29:15.800]     {
[09:29:15.800]         {
[09:29:15.800]             ...future.startTime <- base::Sys.time()
[09:29:15.800]             {
[09:29:15.800]                 {
[09:29:15.800]                   {
[09:29:15.800]                     {
[09:29:15.800]                       base::local({
[09:29:15.800]                         has_future <- base::requireNamespace("future", 
[09:29:15.800]                           quietly = TRUE)
[09:29:15.800]                         if (has_future) {
[09:29:15.800]                           ns <- base::getNamespace("future")
[09:29:15.800]                           version <- ns[[".package"]][["version"]]
[09:29:15.800]                           if (is.null(version)) 
[09:29:15.800]                             version <- utils::packageVersion("future")
[09:29:15.800]                         }
[09:29:15.800]                         else {
[09:29:15.800]                           version <- NULL
[09:29:15.800]                         }
[09:29:15.800]                         if (!has_future || version < "1.8.0") {
[09:29:15.800]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.800]                             "", base::R.version$version.string), 
[09:29:15.800]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.800]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.800]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.800]                               "release", "version")], collapse = " "), 
[09:29:15.800]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.800]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.800]                             info)
[09:29:15.800]                           info <- base::paste(info, collapse = "; ")
[09:29:15.800]                           if (!has_future) {
[09:29:15.800]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.800]                               info)
[09:29:15.800]                           }
[09:29:15.800]                           else {
[09:29:15.800]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.800]                               info, version)
[09:29:15.800]                           }
[09:29:15.800]                           base::stop(msg)
[09:29:15.800]                         }
[09:29:15.800]                       })
[09:29:15.800]                     }
[09:29:15.800]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.800]                     base::options(mc.cores = 1L)
[09:29:15.800]                   }
[09:29:15.800]                   ...future.strategy.old <- future::plan("list")
[09:29:15.800]                   options(future.plan = NULL)
[09:29:15.800]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.800]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.800]                 }
[09:29:15.800]                 ...future.workdir <- getwd()
[09:29:15.800]             }
[09:29:15.800]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.800]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.800]         }
[09:29:15.800]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.800]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:15.800]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.800]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.800]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.800]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.800]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.800]             base::names(...future.oldOptions))
[09:29:15.800]     }
[09:29:15.800]     if (FALSE) {
[09:29:15.800]     }
[09:29:15.800]     else {
[09:29:15.800]         if (TRUE) {
[09:29:15.800]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.800]                 open = "w")
[09:29:15.800]         }
[09:29:15.800]         else {
[09:29:15.800]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.800]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.800]         }
[09:29:15.800]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.800]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.800]             base::sink(type = "output", split = FALSE)
[09:29:15.800]             base::close(...future.stdout)
[09:29:15.800]         }, add = TRUE)
[09:29:15.800]     }
[09:29:15.800]     ...future.frame <- base::sys.nframe()
[09:29:15.800]     ...future.conditions <- base::list()
[09:29:15.800]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.800]     if (FALSE) {
[09:29:15.800]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.800]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.800]     }
[09:29:15.800]     ...future.result <- base::tryCatch({
[09:29:15.800]         base::withCallingHandlers({
[09:29:15.800]             ...future.value <- base::withVisible(base::local({
[09:29:15.800]                 withCallingHandlers({
[09:29:15.800]                   {
[09:29:15.800]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.800]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.800]                       ...future.globals.maxSize)) {
[09:29:15.800]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.800]                       on.exit(options(oopts), add = TRUE)
[09:29:15.800]                     }
[09:29:15.800]                     {
[09:29:15.800]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.800]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.800]                         USE.NAMES = FALSE)
[09:29:15.800]                       do.call(mapply, args = args)
[09:29:15.800]                     }
[09:29:15.800]                   }
[09:29:15.800]                 }, immediateCondition = function(cond) {
[09:29:15.800]                   save_rds <- function (object, pathname, ...) 
[09:29:15.800]                   {
[09:29:15.800]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.800]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.800]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.800]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.800]                         fi_tmp[["mtime"]])
[09:29:15.800]                     }
[09:29:15.800]                     tryCatch({
[09:29:15.800]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.800]                     }, error = function(ex) {
[09:29:15.800]                       msg <- conditionMessage(ex)
[09:29:15.800]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.800]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.800]                         fi_tmp[["mtime"]], msg)
[09:29:15.800]                       ex$message <- msg
[09:29:15.800]                       stop(ex)
[09:29:15.800]                     })
[09:29:15.800]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.800]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.800]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.800]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.800]                       fi <- file.info(pathname)
[09:29:15.800]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.800]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.800]                         fi[["size"]], fi[["mtime"]])
[09:29:15.800]                       stop(msg)
[09:29:15.800]                     }
[09:29:15.800]                     invisible(pathname)
[09:29:15.800]                   }
[09:29:15.800]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.800]                     rootPath = tempdir()) 
[09:29:15.800]                   {
[09:29:15.800]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.800]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.800]                       tmpdir = path, fileext = ".rds")
[09:29:15.800]                     save_rds(obj, file)
[09:29:15.800]                   }
[09:29:15.800]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.800]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.800]                   {
[09:29:15.800]                     inherits <- base::inherits
[09:29:15.800]                     invokeRestart <- base::invokeRestart
[09:29:15.800]                     is.null <- base::is.null
[09:29:15.800]                     muffled <- FALSE
[09:29:15.800]                     if (inherits(cond, "message")) {
[09:29:15.800]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.800]                       if (muffled) 
[09:29:15.800]                         invokeRestart("muffleMessage")
[09:29:15.800]                     }
[09:29:15.800]                     else if (inherits(cond, "warning")) {
[09:29:15.800]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.800]                       if (muffled) 
[09:29:15.800]                         invokeRestart("muffleWarning")
[09:29:15.800]                     }
[09:29:15.800]                     else if (inherits(cond, "condition")) {
[09:29:15.800]                       if (!is.null(pattern)) {
[09:29:15.800]                         computeRestarts <- base::computeRestarts
[09:29:15.800]                         grepl <- base::grepl
[09:29:15.800]                         restarts <- computeRestarts(cond)
[09:29:15.800]                         for (restart in restarts) {
[09:29:15.800]                           name <- restart$name
[09:29:15.800]                           if (is.null(name)) 
[09:29:15.800]                             next
[09:29:15.800]                           if (!grepl(pattern, name)) 
[09:29:15.800]                             next
[09:29:15.800]                           invokeRestart(restart)
[09:29:15.800]                           muffled <- TRUE
[09:29:15.800]                           break
[09:29:15.800]                         }
[09:29:15.800]                       }
[09:29:15.800]                     }
[09:29:15.800]                     invisible(muffled)
[09:29:15.800]                   }
[09:29:15.800]                   muffleCondition(cond)
[09:29:15.800]                 })
[09:29:15.800]             }))
[09:29:15.800]             future::FutureResult(value = ...future.value$value, 
[09:29:15.800]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.800]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.800]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.800]                     ...future.globalenv.names))
[09:29:15.800]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.800]         }, condition = base::local({
[09:29:15.800]             c <- base::c
[09:29:15.800]             inherits <- base::inherits
[09:29:15.800]             invokeRestart <- base::invokeRestart
[09:29:15.800]             length <- base::length
[09:29:15.800]             list <- base::list
[09:29:15.800]             seq.int <- base::seq.int
[09:29:15.800]             signalCondition <- base::signalCondition
[09:29:15.800]             sys.calls <- base::sys.calls
[09:29:15.800]             `[[` <- base::`[[`
[09:29:15.800]             `+` <- base::`+`
[09:29:15.800]             `<<-` <- base::`<<-`
[09:29:15.800]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.800]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.800]                   3L)]
[09:29:15.800]             }
[09:29:15.800]             function(cond) {
[09:29:15.800]                 is_error <- inherits(cond, "error")
[09:29:15.800]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.800]                   NULL)
[09:29:15.800]                 if (is_error) {
[09:29:15.800]                   sessionInformation <- function() {
[09:29:15.800]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.800]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.800]                       search = base::search(), system = base::Sys.info())
[09:29:15.800]                   }
[09:29:15.800]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.800]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.800]                     cond$call), session = sessionInformation(), 
[09:29:15.800]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.800]                   signalCondition(cond)
[09:29:15.800]                 }
[09:29:15.800]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.800]                 "immediateCondition"))) {
[09:29:15.800]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.800]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.800]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.800]                   if (TRUE && !signal) {
[09:29:15.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.800]                     {
[09:29:15.800]                       inherits <- base::inherits
[09:29:15.800]                       invokeRestart <- base::invokeRestart
[09:29:15.800]                       is.null <- base::is.null
[09:29:15.800]                       muffled <- FALSE
[09:29:15.800]                       if (inherits(cond, "message")) {
[09:29:15.800]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.800]                         if (muffled) 
[09:29:15.800]                           invokeRestart("muffleMessage")
[09:29:15.800]                       }
[09:29:15.800]                       else if (inherits(cond, "warning")) {
[09:29:15.800]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.800]                         if (muffled) 
[09:29:15.800]                           invokeRestart("muffleWarning")
[09:29:15.800]                       }
[09:29:15.800]                       else if (inherits(cond, "condition")) {
[09:29:15.800]                         if (!is.null(pattern)) {
[09:29:15.800]                           computeRestarts <- base::computeRestarts
[09:29:15.800]                           grepl <- base::grepl
[09:29:15.800]                           restarts <- computeRestarts(cond)
[09:29:15.800]                           for (restart in restarts) {
[09:29:15.800]                             name <- restart$name
[09:29:15.800]                             if (is.null(name)) 
[09:29:15.800]                               next
[09:29:15.800]                             if (!grepl(pattern, name)) 
[09:29:15.800]                               next
[09:29:15.800]                             invokeRestart(restart)
[09:29:15.800]                             muffled <- TRUE
[09:29:15.800]                             break
[09:29:15.800]                           }
[09:29:15.800]                         }
[09:29:15.800]                       }
[09:29:15.800]                       invisible(muffled)
[09:29:15.800]                     }
[09:29:15.800]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.800]                   }
[09:29:15.800]                 }
[09:29:15.800]                 else {
[09:29:15.800]                   if (TRUE) {
[09:29:15.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.800]                     {
[09:29:15.800]                       inherits <- base::inherits
[09:29:15.800]                       invokeRestart <- base::invokeRestart
[09:29:15.800]                       is.null <- base::is.null
[09:29:15.800]                       muffled <- FALSE
[09:29:15.800]                       if (inherits(cond, "message")) {
[09:29:15.800]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.800]                         if (muffled) 
[09:29:15.800]                           invokeRestart("muffleMessage")
[09:29:15.800]                       }
[09:29:15.800]                       else if (inherits(cond, "warning")) {
[09:29:15.800]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.800]                         if (muffled) 
[09:29:15.800]                           invokeRestart("muffleWarning")
[09:29:15.800]                       }
[09:29:15.800]                       else if (inherits(cond, "condition")) {
[09:29:15.800]                         if (!is.null(pattern)) {
[09:29:15.800]                           computeRestarts <- base::computeRestarts
[09:29:15.800]                           grepl <- base::grepl
[09:29:15.800]                           restarts <- computeRestarts(cond)
[09:29:15.800]                           for (restart in restarts) {
[09:29:15.800]                             name <- restart$name
[09:29:15.800]                             if (is.null(name)) 
[09:29:15.800]                               next
[09:29:15.800]                             if (!grepl(pattern, name)) 
[09:29:15.800]                               next
[09:29:15.800]                             invokeRestart(restart)
[09:29:15.800]                             muffled <- TRUE
[09:29:15.800]                             break
[09:29:15.800]                           }
[09:29:15.800]                         }
[09:29:15.800]                       }
[09:29:15.800]                       invisible(muffled)
[09:29:15.800]                     }
[09:29:15.800]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.800]                   }
[09:29:15.800]                 }
[09:29:15.800]             }
[09:29:15.800]         }))
[09:29:15.800]     }, error = function(ex) {
[09:29:15.800]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.800]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.800]                 ...future.rng), started = ...future.startTime, 
[09:29:15.800]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.800]             version = "1.8"), class = "FutureResult")
[09:29:15.800]     }, finally = {
[09:29:15.800]         if (!identical(...future.workdir, getwd())) 
[09:29:15.800]             setwd(...future.workdir)
[09:29:15.800]         {
[09:29:15.800]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.800]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.800]             }
[09:29:15.800]             base::options(...future.oldOptions)
[09:29:15.800]             if (.Platform$OS.type == "windows") {
[09:29:15.800]                 old_names <- names(...future.oldEnvVars)
[09:29:15.800]                 envs <- base::Sys.getenv()
[09:29:15.800]                 names <- names(envs)
[09:29:15.800]                 common <- intersect(names, old_names)
[09:29:15.800]                 added <- setdiff(names, old_names)
[09:29:15.800]                 removed <- setdiff(old_names, names)
[09:29:15.800]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.800]                   envs[common]]
[09:29:15.800]                 NAMES <- toupper(changed)
[09:29:15.800]                 args <- list()
[09:29:15.800]                 for (kk in seq_along(NAMES)) {
[09:29:15.800]                   name <- changed[[kk]]
[09:29:15.800]                   NAME <- NAMES[[kk]]
[09:29:15.800]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.800]                     next
[09:29:15.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.800]                 }
[09:29:15.800]                 NAMES <- toupper(added)
[09:29:15.800]                 for (kk in seq_along(NAMES)) {
[09:29:15.800]                   name <- added[[kk]]
[09:29:15.800]                   NAME <- NAMES[[kk]]
[09:29:15.800]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.800]                     next
[09:29:15.800]                   args[[name]] <- ""
[09:29:15.800]                 }
[09:29:15.800]                 NAMES <- toupper(removed)
[09:29:15.800]                 for (kk in seq_along(NAMES)) {
[09:29:15.800]                   name <- removed[[kk]]
[09:29:15.800]                   NAME <- NAMES[[kk]]
[09:29:15.800]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.800]                     next
[09:29:15.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.800]                 }
[09:29:15.800]                 if (length(args) > 0) 
[09:29:15.800]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.800]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.800]             }
[09:29:15.800]             else {
[09:29:15.800]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.800]             }
[09:29:15.800]             {
[09:29:15.800]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.800]                   0L) {
[09:29:15.800]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.800]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.800]                   base::options(opts)
[09:29:15.800]                 }
[09:29:15.800]                 {
[09:29:15.800]                   {
[09:29:15.800]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.800]                     NULL
[09:29:15.800]                   }
[09:29:15.800]                   options(future.plan = NULL)
[09:29:15.800]                   if (is.na(NA_character_)) 
[09:29:15.800]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.800]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.800]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.800]                     .init = FALSE)
[09:29:15.800]                 }
[09:29:15.800]             }
[09:29:15.800]         }
[09:29:15.800]     })
[09:29:15.800]     if (TRUE) {
[09:29:15.800]         base::sink(type = "output", split = FALSE)
[09:29:15.800]         if (TRUE) {
[09:29:15.800]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.800]         }
[09:29:15.800]         else {
[09:29:15.800]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.800]         }
[09:29:15.800]         base::close(...future.stdout)
[09:29:15.800]         ...future.stdout <- NULL
[09:29:15.800]     }
[09:29:15.800]     ...future.result$conditions <- ...future.conditions
[09:29:15.800]     ...future.result$finished <- base::Sys.time()
[09:29:15.800]     ...future.result
[09:29:15.800] }
[09:29:15.803] assign_globals() ...
[09:29:15.803] List of 5
[09:29:15.803]  $ ...future.FUN            :function (C, k)  
[09:29:15.803]  $ MoreArgs                 : NULL
[09:29:15.803]  $ ...future.elements_ii    :List of 2
[09:29:15.803]   ..$ :List of 1
[09:29:15.803]   .. ..$ : chr "B"
[09:29:15.803]   ..$ :List of 1
[09:29:15.803]   .. ..$ : int 4
[09:29:15.803]  $ ...future.seeds_ii       : NULL
[09:29:15.803]  $ ...future.globals.maxSize: NULL
[09:29:15.803]  - attr(*, "where")=List of 5
[09:29:15.803]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.803]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.803]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.803]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.803]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.803]  - attr(*, "resolved")= logi FALSE
[09:29:15.803]  - attr(*, "total_size")= num 3488
[09:29:15.803]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.803]  - attr(*, "already-done")= logi TRUE
[09:29:15.811] - reassign environment for ‘...future.FUN’
[09:29:15.811] - copied ‘...future.FUN’ to environment
[09:29:15.811] - copied ‘MoreArgs’ to environment
[09:29:15.812] - copied ‘...future.elements_ii’ to environment
[09:29:15.812] - copied ‘...future.seeds_ii’ to environment
[09:29:15.812] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.812] assign_globals() ... done
[09:29:15.812] requestCore(): workers = 2
[09:29:15.814] MulticoreFuture started
[09:29:15.815] - Launch lazy future ... done
[09:29:15.815] run() for ‘MulticoreFuture’ ... done
[09:29:15.815] Created future:
[09:29:15.815] plan(): Setting new future strategy stack:
[09:29:15.816] List of future strategies:
[09:29:15.816] 1. sequential:
[09:29:15.816]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.816]    - tweaked: FALSE
[09:29:15.816]    - call: NULL
[09:29:15.817] plan(): nbrOfWorkers() = 1
[09:29:15.819] plan(): Setting new future strategy stack:
[09:29:15.819] List of future strategies:
[09:29:15.819] 1. multicore:
[09:29:15.819]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.819]    - tweaked: FALSE
[09:29:15.819]    - call: plan(strategy)
[09:29:15.824] plan(): nbrOfWorkers() = 2
[09:29:15.815] MulticoreFuture:
[09:29:15.815] Label: ‘future_mapply-2’
[09:29:15.815] Expression:
[09:29:15.815] {
[09:29:15.815]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.815]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.815]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.815]         on.exit(options(oopts), add = TRUE)
[09:29:15.815]     }
[09:29:15.815]     {
[09:29:15.815]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.815]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.815]         do.call(mapply, args = args)
[09:29:15.815]     }
[09:29:15.815] }
[09:29:15.815] Lazy evaluation: FALSE
[09:29:15.815] Asynchronous evaluation: TRUE
[09:29:15.815] Local evaluation: TRUE
[09:29:15.815] Environment: R_GlobalEnv
[09:29:15.815] Capture standard output: TRUE
[09:29:15.815] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.815] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.815] Packages: <none>
[09:29:15.815] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.815] Resolved: TRUE
[09:29:15.815] Value: <not collected>
[09:29:15.815] Conditions captured: <none>
[09:29:15.815] Early signaling: FALSE
[09:29:15.815] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.815] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.825] Chunk #2 of 5 ... DONE
[09:29:15.825] Chunk #3 of 5 ...
[09:29:15.825]  - Finding globals in '...' for chunk #3 ...
[09:29:15.825] getGlobalsAndPackages() ...
[09:29:15.825] Searching for globals...
[09:29:15.826] 
[09:29:15.826] Searching for globals ... DONE
[09:29:15.826] - globals: [0] <none>
[09:29:15.826] getGlobalsAndPackages() ... DONE
[09:29:15.826]    + additional globals found: [n=0] 
[09:29:15.827]    + additional namespaces needed: [n=0] 
[09:29:15.827]  - Finding globals in '...' for chunk #3 ... DONE
[09:29:15.827]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:15.827]  - seeds: <none>
[09:29:15.827]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.827] getGlobalsAndPackages() ...
[09:29:15.827] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.828] Resolving globals: FALSE
[09:29:15.828] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:15.829] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.829] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.830] 
[09:29:15.830] getGlobalsAndPackages() ... DONE
[09:29:15.830] run() for ‘Future’ ...
[09:29:15.830] - state: ‘created’
[09:29:15.831] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.835] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.835] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.835]   - Field: ‘label’
[09:29:15.836]   - Field: ‘local’
[09:29:15.836]   - Field: ‘owner’
[09:29:15.836]   - Field: ‘envir’
[09:29:15.836]   - Field: ‘workers’
[09:29:15.836]   - Field: ‘packages’
[09:29:15.836]   - Field: ‘gc’
[09:29:15.837]   - Field: ‘job’
[09:29:15.837]   - Field: ‘conditions’
[09:29:15.837]   - Field: ‘expr’
[09:29:15.837]   - Field: ‘uuid’
[09:29:15.837]   - Field: ‘seed’
[09:29:15.837]   - Field: ‘version’
[09:29:15.837]   - Field: ‘result’
[09:29:15.838]   - Field: ‘asynchronous’
[09:29:15.838]   - Field: ‘calls’
[09:29:15.838]   - Field: ‘globals’
[09:29:15.838]   - Field: ‘stdout’
[09:29:15.838]   - Field: ‘earlySignal’
[09:29:15.838]   - Field: ‘lazy’
[09:29:15.839]   - Field: ‘state’
[09:29:15.839] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.839] - Launch lazy future ...
[09:29:15.839] Packages needed by the future expression (n = 0): <none>
[09:29:15.839] Packages needed by future strategies (n = 0): <none>
[09:29:15.840] {
[09:29:15.840]     {
[09:29:15.840]         {
[09:29:15.840]             ...future.startTime <- base::Sys.time()
[09:29:15.840]             {
[09:29:15.840]                 {
[09:29:15.840]                   {
[09:29:15.840]                     {
[09:29:15.840]                       base::local({
[09:29:15.840]                         has_future <- base::requireNamespace("future", 
[09:29:15.840]                           quietly = TRUE)
[09:29:15.840]                         if (has_future) {
[09:29:15.840]                           ns <- base::getNamespace("future")
[09:29:15.840]                           version <- ns[[".package"]][["version"]]
[09:29:15.840]                           if (is.null(version)) 
[09:29:15.840]                             version <- utils::packageVersion("future")
[09:29:15.840]                         }
[09:29:15.840]                         else {
[09:29:15.840]                           version <- NULL
[09:29:15.840]                         }
[09:29:15.840]                         if (!has_future || version < "1.8.0") {
[09:29:15.840]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.840]                             "", base::R.version$version.string), 
[09:29:15.840]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.840]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.840]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.840]                               "release", "version")], collapse = " "), 
[09:29:15.840]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.840]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.840]                             info)
[09:29:15.840]                           info <- base::paste(info, collapse = "; ")
[09:29:15.840]                           if (!has_future) {
[09:29:15.840]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.840]                               info)
[09:29:15.840]                           }
[09:29:15.840]                           else {
[09:29:15.840]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.840]                               info, version)
[09:29:15.840]                           }
[09:29:15.840]                           base::stop(msg)
[09:29:15.840]                         }
[09:29:15.840]                       })
[09:29:15.840]                     }
[09:29:15.840]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.840]                     base::options(mc.cores = 1L)
[09:29:15.840]                   }
[09:29:15.840]                   ...future.strategy.old <- future::plan("list")
[09:29:15.840]                   options(future.plan = NULL)
[09:29:15.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.840]                 }
[09:29:15.840]                 ...future.workdir <- getwd()
[09:29:15.840]             }
[09:29:15.840]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.840]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.840]         }
[09:29:15.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.840]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:15.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.840]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.840]             base::names(...future.oldOptions))
[09:29:15.840]     }
[09:29:15.840]     if (FALSE) {
[09:29:15.840]     }
[09:29:15.840]     else {
[09:29:15.840]         if (TRUE) {
[09:29:15.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.840]                 open = "w")
[09:29:15.840]         }
[09:29:15.840]         else {
[09:29:15.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.840]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.840]         }
[09:29:15.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.840]             base::sink(type = "output", split = FALSE)
[09:29:15.840]             base::close(...future.stdout)
[09:29:15.840]         }, add = TRUE)
[09:29:15.840]     }
[09:29:15.840]     ...future.frame <- base::sys.nframe()
[09:29:15.840]     ...future.conditions <- base::list()
[09:29:15.840]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.840]     if (FALSE) {
[09:29:15.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.840]     }
[09:29:15.840]     ...future.result <- base::tryCatch({
[09:29:15.840]         base::withCallingHandlers({
[09:29:15.840]             ...future.value <- base::withVisible(base::local({
[09:29:15.840]                 withCallingHandlers({
[09:29:15.840]                   {
[09:29:15.840]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.840]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.840]                       ...future.globals.maxSize)) {
[09:29:15.840]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.840]                       on.exit(options(oopts), add = TRUE)
[09:29:15.840]                     }
[09:29:15.840]                     {
[09:29:15.840]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.840]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.840]                         USE.NAMES = FALSE)
[09:29:15.840]                       do.call(mapply, args = args)
[09:29:15.840]                     }
[09:29:15.840]                   }
[09:29:15.840]                 }, immediateCondition = function(cond) {
[09:29:15.840]                   save_rds <- function (object, pathname, ...) 
[09:29:15.840]                   {
[09:29:15.840]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.840]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.840]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.840]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.840]                         fi_tmp[["mtime"]])
[09:29:15.840]                     }
[09:29:15.840]                     tryCatch({
[09:29:15.840]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.840]                     }, error = function(ex) {
[09:29:15.840]                       msg <- conditionMessage(ex)
[09:29:15.840]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.840]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.840]                         fi_tmp[["mtime"]], msg)
[09:29:15.840]                       ex$message <- msg
[09:29:15.840]                       stop(ex)
[09:29:15.840]                     })
[09:29:15.840]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.840]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.840]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.840]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.840]                       fi <- file.info(pathname)
[09:29:15.840]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.840]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.840]                         fi[["size"]], fi[["mtime"]])
[09:29:15.840]                       stop(msg)
[09:29:15.840]                     }
[09:29:15.840]                     invisible(pathname)
[09:29:15.840]                   }
[09:29:15.840]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.840]                     rootPath = tempdir()) 
[09:29:15.840]                   {
[09:29:15.840]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.840]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.840]                       tmpdir = path, fileext = ".rds")
[09:29:15.840]                     save_rds(obj, file)
[09:29:15.840]                   }
[09:29:15.840]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.840]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.840]                   {
[09:29:15.840]                     inherits <- base::inherits
[09:29:15.840]                     invokeRestart <- base::invokeRestart
[09:29:15.840]                     is.null <- base::is.null
[09:29:15.840]                     muffled <- FALSE
[09:29:15.840]                     if (inherits(cond, "message")) {
[09:29:15.840]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.840]                       if (muffled) 
[09:29:15.840]                         invokeRestart("muffleMessage")
[09:29:15.840]                     }
[09:29:15.840]                     else if (inherits(cond, "warning")) {
[09:29:15.840]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.840]                       if (muffled) 
[09:29:15.840]                         invokeRestart("muffleWarning")
[09:29:15.840]                     }
[09:29:15.840]                     else if (inherits(cond, "condition")) {
[09:29:15.840]                       if (!is.null(pattern)) {
[09:29:15.840]                         computeRestarts <- base::computeRestarts
[09:29:15.840]                         grepl <- base::grepl
[09:29:15.840]                         restarts <- computeRestarts(cond)
[09:29:15.840]                         for (restart in restarts) {
[09:29:15.840]                           name <- restart$name
[09:29:15.840]                           if (is.null(name)) 
[09:29:15.840]                             next
[09:29:15.840]                           if (!grepl(pattern, name)) 
[09:29:15.840]                             next
[09:29:15.840]                           invokeRestart(restart)
[09:29:15.840]                           muffled <- TRUE
[09:29:15.840]                           break
[09:29:15.840]                         }
[09:29:15.840]                       }
[09:29:15.840]                     }
[09:29:15.840]                     invisible(muffled)
[09:29:15.840]                   }
[09:29:15.840]                   muffleCondition(cond)
[09:29:15.840]                 })
[09:29:15.840]             }))
[09:29:15.840]             future::FutureResult(value = ...future.value$value, 
[09:29:15.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.840]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.840]                     ...future.globalenv.names))
[09:29:15.840]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.840]         }, condition = base::local({
[09:29:15.840]             c <- base::c
[09:29:15.840]             inherits <- base::inherits
[09:29:15.840]             invokeRestart <- base::invokeRestart
[09:29:15.840]             length <- base::length
[09:29:15.840]             list <- base::list
[09:29:15.840]             seq.int <- base::seq.int
[09:29:15.840]             signalCondition <- base::signalCondition
[09:29:15.840]             sys.calls <- base::sys.calls
[09:29:15.840]             `[[` <- base::`[[`
[09:29:15.840]             `+` <- base::`+`
[09:29:15.840]             `<<-` <- base::`<<-`
[09:29:15.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.840]                   3L)]
[09:29:15.840]             }
[09:29:15.840]             function(cond) {
[09:29:15.840]                 is_error <- inherits(cond, "error")
[09:29:15.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.840]                   NULL)
[09:29:15.840]                 if (is_error) {
[09:29:15.840]                   sessionInformation <- function() {
[09:29:15.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.840]                       search = base::search(), system = base::Sys.info())
[09:29:15.840]                   }
[09:29:15.840]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.840]                     cond$call), session = sessionInformation(), 
[09:29:15.840]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.840]                   signalCondition(cond)
[09:29:15.840]                 }
[09:29:15.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.840]                 "immediateCondition"))) {
[09:29:15.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.840]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.840]                   if (TRUE && !signal) {
[09:29:15.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.840]                     {
[09:29:15.840]                       inherits <- base::inherits
[09:29:15.840]                       invokeRestart <- base::invokeRestart
[09:29:15.840]                       is.null <- base::is.null
[09:29:15.840]                       muffled <- FALSE
[09:29:15.840]                       if (inherits(cond, "message")) {
[09:29:15.840]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.840]                         if (muffled) 
[09:29:15.840]                           invokeRestart("muffleMessage")
[09:29:15.840]                       }
[09:29:15.840]                       else if (inherits(cond, "warning")) {
[09:29:15.840]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.840]                         if (muffled) 
[09:29:15.840]                           invokeRestart("muffleWarning")
[09:29:15.840]                       }
[09:29:15.840]                       else if (inherits(cond, "condition")) {
[09:29:15.840]                         if (!is.null(pattern)) {
[09:29:15.840]                           computeRestarts <- base::computeRestarts
[09:29:15.840]                           grepl <- base::grepl
[09:29:15.840]                           restarts <- computeRestarts(cond)
[09:29:15.840]                           for (restart in restarts) {
[09:29:15.840]                             name <- restart$name
[09:29:15.840]                             if (is.null(name)) 
[09:29:15.840]                               next
[09:29:15.840]                             if (!grepl(pattern, name)) 
[09:29:15.840]                               next
[09:29:15.840]                             invokeRestart(restart)
[09:29:15.840]                             muffled <- TRUE
[09:29:15.840]                             break
[09:29:15.840]                           }
[09:29:15.840]                         }
[09:29:15.840]                       }
[09:29:15.840]                       invisible(muffled)
[09:29:15.840]                     }
[09:29:15.840]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.840]                   }
[09:29:15.840]                 }
[09:29:15.840]                 else {
[09:29:15.840]                   if (TRUE) {
[09:29:15.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.840]                     {
[09:29:15.840]                       inherits <- base::inherits
[09:29:15.840]                       invokeRestart <- base::invokeRestart
[09:29:15.840]                       is.null <- base::is.null
[09:29:15.840]                       muffled <- FALSE
[09:29:15.840]                       if (inherits(cond, "message")) {
[09:29:15.840]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.840]                         if (muffled) 
[09:29:15.840]                           invokeRestart("muffleMessage")
[09:29:15.840]                       }
[09:29:15.840]                       else if (inherits(cond, "warning")) {
[09:29:15.840]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.840]                         if (muffled) 
[09:29:15.840]                           invokeRestart("muffleWarning")
[09:29:15.840]                       }
[09:29:15.840]                       else if (inherits(cond, "condition")) {
[09:29:15.840]                         if (!is.null(pattern)) {
[09:29:15.840]                           computeRestarts <- base::computeRestarts
[09:29:15.840]                           grepl <- base::grepl
[09:29:15.840]                           restarts <- computeRestarts(cond)
[09:29:15.840]                           for (restart in restarts) {
[09:29:15.840]                             name <- restart$name
[09:29:15.840]                             if (is.null(name)) 
[09:29:15.840]                               next
[09:29:15.840]                             if (!grepl(pattern, name)) 
[09:29:15.840]                               next
[09:29:15.840]                             invokeRestart(restart)
[09:29:15.840]                             muffled <- TRUE
[09:29:15.840]                             break
[09:29:15.840]                           }
[09:29:15.840]                         }
[09:29:15.840]                       }
[09:29:15.840]                       invisible(muffled)
[09:29:15.840]                     }
[09:29:15.840]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.840]                   }
[09:29:15.840]                 }
[09:29:15.840]             }
[09:29:15.840]         }))
[09:29:15.840]     }, error = function(ex) {
[09:29:15.840]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.840]                 ...future.rng), started = ...future.startTime, 
[09:29:15.840]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.840]             version = "1.8"), class = "FutureResult")
[09:29:15.840]     }, finally = {
[09:29:15.840]         if (!identical(...future.workdir, getwd())) 
[09:29:15.840]             setwd(...future.workdir)
[09:29:15.840]         {
[09:29:15.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.840]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.840]             }
[09:29:15.840]             base::options(...future.oldOptions)
[09:29:15.840]             if (.Platform$OS.type == "windows") {
[09:29:15.840]                 old_names <- names(...future.oldEnvVars)
[09:29:15.840]                 envs <- base::Sys.getenv()
[09:29:15.840]                 names <- names(envs)
[09:29:15.840]                 common <- intersect(names, old_names)
[09:29:15.840]                 added <- setdiff(names, old_names)
[09:29:15.840]                 removed <- setdiff(old_names, names)
[09:29:15.840]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.840]                   envs[common]]
[09:29:15.840]                 NAMES <- toupper(changed)
[09:29:15.840]                 args <- list()
[09:29:15.840]                 for (kk in seq_along(NAMES)) {
[09:29:15.840]                   name <- changed[[kk]]
[09:29:15.840]                   NAME <- NAMES[[kk]]
[09:29:15.840]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.840]                     next
[09:29:15.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.840]                 }
[09:29:15.840]                 NAMES <- toupper(added)
[09:29:15.840]                 for (kk in seq_along(NAMES)) {
[09:29:15.840]                   name <- added[[kk]]
[09:29:15.840]                   NAME <- NAMES[[kk]]
[09:29:15.840]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.840]                     next
[09:29:15.840]                   args[[name]] <- ""
[09:29:15.840]                 }
[09:29:15.840]                 NAMES <- toupper(removed)
[09:29:15.840]                 for (kk in seq_along(NAMES)) {
[09:29:15.840]                   name <- removed[[kk]]
[09:29:15.840]                   NAME <- NAMES[[kk]]
[09:29:15.840]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.840]                     next
[09:29:15.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.840]                 }
[09:29:15.840]                 if (length(args) > 0) 
[09:29:15.840]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.840]             }
[09:29:15.840]             else {
[09:29:15.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.840]             }
[09:29:15.840]             {
[09:29:15.840]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.840]                   0L) {
[09:29:15.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.840]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.840]                   base::options(opts)
[09:29:15.840]                 }
[09:29:15.840]                 {
[09:29:15.840]                   {
[09:29:15.840]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.840]                     NULL
[09:29:15.840]                   }
[09:29:15.840]                   options(future.plan = NULL)
[09:29:15.840]                   if (is.na(NA_character_)) 
[09:29:15.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.840]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.840]                     .init = FALSE)
[09:29:15.840]                 }
[09:29:15.840]             }
[09:29:15.840]         }
[09:29:15.840]     })
[09:29:15.840]     if (TRUE) {
[09:29:15.840]         base::sink(type = "output", split = FALSE)
[09:29:15.840]         if (TRUE) {
[09:29:15.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.840]         }
[09:29:15.840]         else {
[09:29:15.840]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.840]         }
[09:29:15.840]         base::close(...future.stdout)
[09:29:15.840]         ...future.stdout <- NULL
[09:29:15.840]     }
[09:29:15.840]     ...future.result$conditions <- ...future.conditions
[09:29:15.840]     ...future.result$finished <- base::Sys.time()
[09:29:15.840]     ...future.result
[09:29:15.840] }
[09:29:15.843] assign_globals() ...
[09:29:15.843] List of 5
[09:29:15.843]  $ ...future.FUN            :function (C, k)  
[09:29:15.843]  $ MoreArgs                 : NULL
[09:29:15.843]  $ ...future.elements_ii    :List of 2
[09:29:15.843]   ..$ :List of 1
[09:29:15.843]   .. ..$ : chr "C"
[09:29:15.843]   ..$ :List of 1
[09:29:15.843]   .. ..$ : int 3
[09:29:15.843]  $ ...future.seeds_ii       : NULL
[09:29:15.843]  $ ...future.globals.maxSize: NULL
[09:29:15.843]  - attr(*, "where")=List of 5
[09:29:15.843]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.843]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.843]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.843]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.843]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.843]  - attr(*, "resolved")= logi FALSE
[09:29:15.843]  - attr(*, "total_size")= num 3488
[09:29:15.843]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.843]  - attr(*, "already-done")= logi TRUE
[09:29:15.856] - reassign environment for ‘...future.FUN’
[09:29:15.856] - copied ‘...future.FUN’ to environment
[09:29:15.857] - copied ‘MoreArgs’ to environment
[09:29:15.857] - copied ‘...future.elements_ii’ to environment
[09:29:15.857] - copied ‘...future.seeds_ii’ to environment
[09:29:15.857] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.857] assign_globals() ... done
[09:29:15.857] requestCore(): workers = 2
[09:29:15.858] Poll #1 (0): usedCores() = 2, workers = 2
[09:29:15.868] result() for MulticoreFuture ...
[09:29:15.869] result() for MulticoreFuture ...
[09:29:15.869] result() for MulticoreFuture ... done
[09:29:15.869] result() for MulticoreFuture ... done
[09:29:15.870] result() for MulticoreFuture ...
[09:29:15.870] result() for MulticoreFuture ... done
[09:29:15.872] MulticoreFuture started
[09:29:15.873] - Launch lazy future ... done
[09:29:15.873] run() for ‘MulticoreFuture’ ... done
[09:29:15.874] plan(): Setting new future strategy stack:
[09:29:15.874] Created future:
[09:29:15.874] List of future strategies:
[09:29:15.874] 1. sequential:
[09:29:15.874]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.874]    - tweaked: FALSE
[09:29:15.874]    - call: NULL
[09:29:15.876] plan(): nbrOfWorkers() = 1
[09:29:15.878] plan(): Setting new future strategy stack:
[09:29:15.878] List of future strategies:
[09:29:15.878] 1. multicore:
[09:29:15.878]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.878]    - tweaked: FALSE
[09:29:15.878]    - call: plan(strategy)
[09:29:15.884] plan(): nbrOfWorkers() = 2
[09:29:15.874] MulticoreFuture:
[09:29:15.874] Label: ‘future_mapply-3’
[09:29:15.874] Expression:
[09:29:15.874] {
[09:29:15.874]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.874]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.874]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.874]         on.exit(options(oopts), add = TRUE)
[09:29:15.874]     }
[09:29:15.874]     {
[09:29:15.874]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.874]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.874]         do.call(mapply, args = args)
[09:29:15.874]     }
[09:29:15.874] }
[09:29:15.874] Lazy evaluation: FALSE
[09:29:15.874] Asynchronous evaluation: TRUE
[09:29:15.874] Local evaluation: TRUE
[09:29:15.874] Environment: R_GlobalEnv
[09:29:15.874] Capture standard output: TRUE
[09:29:15.874] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.874] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.874] Packages: <none>
[09:29:15.874] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.874] Resolved: TRUE
[09:29:15.874] Value: <not collected>
[09:29:15.874] Conditions captured: <none>
[09:29:15.874] Early signaling: FALSE
[09:29:15.874] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.874] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.885] Chunk #3 of 5 ... DONE
[09:29:15.885] Chunk #4 of 5 ...
[09:29:15.885]  - Finding globals in '...' for chunk #4 ...
[09:29:15.885] getGlobalsAndPackages() ...
[09:29:15.885] Searching for globals...
[09:29:15.886] 
[09:29:15.886] Searching for globals ... DONE
[09:29:15.886] - globals: [0] <none>
[09:29:15.887] getGlobalsAndPackages() ... DONE
[09:29:15.887]    + additional globals found: [n=0] 
[09:29:15.887]    + additional namespaces needed: [n=0] 
[09:29:15.887]  - Finding globals in '...' for chunk #4 ... DONE
[09:29:15.887]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:15.887]  - seeds: <none>
[09:29:15.887]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.888] getGlobalsAndPackages() ...
[09:29:15.888] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.888] Resolving globals: FALSE
[09:29:15.889] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:15.890] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.890] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.890] 
[09:29:15.890] getGlobalsAndPackages() ... DONE
[09:29:15.891] run() for ‘Future’ ...
[09:29:15.891] - state: ‘created’
[09:29:15.891] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.895] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.896] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.896]   - Field: ‘label’
[09:29:15.896]   - Field: ‘local’
[09:29:15.896]   - Field: ‘owner’
[09:29:15.896]   - Field: ‘envir’
[09:29:15.896]   - Field: ‘workers’
[09:29:15.897]   - Field: ‘packages’
[09:29:15.897]   - Field: ‘gc’
[09:29:15.897]   - Field: ‘job’
[09:29:15.897]   - Field: ‘conditions’
[09:29:15.897]   - Field: ‘expr’
[09:29:15.897]   - Field: ‘uuid’
[09:29:15.897]   - Field: ‘seed’
[09:29:15.898]   - Field: ‘version’
[09:29:15.898]   - Field: ‘result’
[09:29:15.898]   - Field: ‘asynchronous’
[09:29:15.898]   - Field: ‘calls’
[09:29:15.898]   - Field: ‘globals’
[09:29:15.898]   - Field: ‘stdout’
[09:29:15.898]   - Field: ‘earlySignal’
[09:29:15.899]   - Field: ‘lazy’
[09:29:15.899]   - Field: ‘state’
[09:29:15.899] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.899] - Launch lazy future ...
[09:29:15.899] Packages needed by the future expression (n = 0): <none>
[09:29:15.900] Packages needed by future strategies (n = 0): <none>
[09:29:15.900] {
[09:29:15.900]     {
[09:29:15.900]         {
[09:29:15.900]             ...future.startTime <- base::Sys.time()
[09:29:15.900]             {
[09:29:15.900]                 {
[09:29:15.900]                   {
[09:29:15.900]                     {
[09:29:15.900]                       base::local({
[09:29:15.900]                         has_future <- base::requireNamespace("future", 
[09:29:15.900]                           quietly = TRUE)
[09:29:15.900]                         if (has_future) {
[09:29:15.900]                           ns <- base::getNamespace("future")
[09:29:15.900]                           version <- ns[[".package"]][["version"]]
[09:29:15.900]                           if (is.null(version)) 
[09:29:15.900]                             version <- utils::packageVersion("future")
[09:29:15.900]                         }
[09:29:15.900]                         else {
[09:29:15.900]                           version <- NULL
[09:29:15.900]                         }
[09:29:15.900]                         if (!has_future || version < "1.8.0") {
[09:29:15.900]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.900]                             "", base::R.version$version.string), 
[09:29:15.900]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.900]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.900]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.900]                               "release", "version")], collapse = " "), 
[09:29:15.900]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.900]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.900]                             info)
[09:29:15.900]                           info <- base::paste(info, collapse = "; ")
[09:29:15.900]                           if (!has_future) {
[09:29:15.900]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.900]                               info)
[09:29:15.900]                           }
[09:29:15.900]                           else {
[09:29:15.900]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.900]                               info, version)
[09:29:15.900]                           }
[09:29:15.900]                           base::stop(msg)
[09:29:15.900]                         }
[09:29:15.900]                       })
[09:29:15.900]                     }
[09:29:15.900]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.900]                     base::options(mc.cores = 1L)
[09:29:15.900]                   }
[09:29:15.900]                   ...future.strategy.old <- future::plan("list")
[09:29:15.900]                   options(future.plan = NULL)
[09:29:15.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.900]                 }
[09:29:15.900]                 ...future.workdir <- getwd()
[09:29:15.900]             }
[09:29:15.900]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.900]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.900]         }
[09:29:15.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.900]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:15.900]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.900]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.900]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.900]             base::names(...future.oldOptions))
[09:29:15.900]     }
[09:29:15.900]     if (FALSE) {
[09:29:15.900]     }
[09:29:15.900]     else {
[09:29:15.900]         if (TRUE) {
[09:29:15.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.900]                 open = "w")
[09:29:15.900]         }
[09:29:15.900]         else {
[09:29:15.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.900]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.900]         }
[09:29:15.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.900]             base::sink(type = "output", split = FALSE)
[09:29:15.900]             base::close(...future.stdout)
[09:29:15.900]         }, add = TRUE)
[09:29:15.900]     }
[09:29:15.900]     ...future.frame <- base::sys.nframe()
[09:29:15.900]     ...future.conditions <- base::list()
[09:29:15.900]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.900]     if (FALSE) {
[09:29:15.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.900]     }
[09:29:15.900]     ...future.result <- base::tryCatch({
[09:29:15.900]         base::withCallingHandlers({
[09:29:15.900]             ...future.value <- base::withVisible(base::local({
[09:29:15.900]                 withCallingHandlers({
[09:29:15.900]                   {
[09:29:15.900]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.900]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.900]                       ...future.globals.maxSize)) {
[09:29:15.900]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.900]                       on.exit(options(oopts), add = TRUE)
[09:29:15.900]                     }
[09:29:15.900]                     {
[09:29:15.900]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.900]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.900]                         USE.NAMES = FALSE)
[09:29:15.900]                       do.call(mapply, args = args)
[09:29:15.900]                     }
[09:29:15.900]                   }
[09:29:15.900]                 }, immediateCondition = function(cond) {
[09:29:15.900]                   save_rds <- function (object, pathname, ...) 
[09:29:15.900]                   {
[09:29:15.900]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.900]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.900]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.900]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.900]                         fi_tmp[["mtime"]])
[09:29:15.900]                     }
[09:29:15.900]                     tryCatch({
[09:29:15.900]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.900]                     }, error = function(ex) {
[09:29:15.900]                       msg <- conditionMessage(ex)
[09:29:15.900]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.900]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.900]                         fi_tmp[["mtime"]], msg)
[09:29:15.900]                       ex$message <- msg
[09:29:15.900]                       stop(ex)
[09:29:15.900]                     })
[09:29:15.900]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.900]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.900]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.900]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.900]                       fi <- file.info(pathname)
[09:29:15.900]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.900]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.900]                         fi[["size"]], fi[["mtime"]])
[09:29:15.900]                       stop(msg)
[09:29:15.900]                     }
[09:29:15.900]                     invisible(pathname)
[09:29:15.900]                   }
[09:29:15.900]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.900]                     rootPath = tempdir()) 
[09:29:15.900]                   {
[09:29:15.900]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.900]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.900]                       tmpdir = path, fileext = ".rds")
[09:29:15.900]                     save_rds(obj, file)
[09:29:15.900]                   }
[09:29:15.900]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.900]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.900]                   {
[09:29:15.900]                     inherits <- base::inherits
[09:29:15.900]                     invokeRestart <- base::invokeRestart
[09:29:15.900]                     is.null <- base::is.null
[09:29:15.900]                     muffled <- FALSE
[09:29:15.900]                     if (inherits(cond, "message")) {
[09:29:15.900]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.900]                       if (muffled) 
[09:29:15.900]                         invokeRestart("muffleMessage")
[09:29:15.900]                     }
[09:29:15.900]                     else if (inherits(cond, "warning")) {
[09:29:15.900]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.900]                       if (muffled) 
[09:29:15.900]                         invokeRestart("muffleWarning")
[09:29:15.900]                     }
[09:29:15.900]                     else if (inherits(cond, "condition")) {
[09:29:15.900]                       if (!is.null(pattern)) {
[09:29:15.900]                         computeRestarts <- base::computeRestarts
[09:29:15.900]                         grepl <- base::grepl
[09:29:15.900]                         restarts <- computeRestarts(cond)
[09:29:15.900]                         for (restart in restarts) {
[09:29:15.900]                           name <- restart$name
[09:29:15.900]                           if (is.null(name)) 
[09:29:15.900]                             next
[09:29:15.900]                           if (!grepl(pattern, name)) 
[09:29:15.900]                             next
[09:29:15.900]                           invokeRestart(restart)
[09:29:15.900]                           muffled <- TRUE
[09:29:15.900]                           break
[09:29:15.900]                         }
[09:29:15.900]                       }
[09:29:15.900]                     }
[09:29:15.900]                     invisible(muffled)
[09:29:15.900]                   }
[09:29:15.900]                   muffleCondition(cond)
[09:29:15.900]                 })
[09:29:15.900]             }))
[09:29:15.900]             future::FutureResult(value = ...future.value$value, 
[09:29:15.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.900]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.900]                     ...future.globalenv.names))
[09:29:15.900]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.900]         }, condition = base::local({
[09:29:15.900]             c <- base::c
[09:29:15.900]             inherits <- base::inherits
[09:29:15.900]             invokeRestart <- base::invokeRestart
[09:29:15.900]             length <- base::length
[09:29:15.900]             list <- base::list
[09:29:15.900]             seq.int <- base::seq.int
[09:29:15.900]             signalCondition <- base::signalCondition
[09:29:15.900]             sys.calls <- base::sys.calls
[09:29:15.900]             `[[` <- base::`[[`
[09:29:15.900]             `+` <- base::`+`
[09:29:15.900]             `<<-` <- base::`<<-`
[09:29:15.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.900]                   3L)]
[09:29:15.900]             }
[09:29:15.900]             function(cond) {
[09:29:15.900]                 is_error <- inherits(cond, "error")
[09:29:15.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.900]                   NULL)
[09:29:15.900]                 if (is_error) {
[09:29:15.900]                   sessionInformation <- function() {
[09:29:15.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.900]                       search = base::search(), system = base::Sys.info())
[09:29:15.900]                   }
[09:29:15.900]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.900]                     cond$call), session = sessionInformation(), 
[09:29:15.900]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.900]                   signalCondition(cond)
[09:29:15.900]                 }
[09:29:15.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.900]                 "immediateCondition"))) {
[09:29:15.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.900]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.900]                   if (TRUE && !signal) {
[09:29:15.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.900]                     {
[09:29:15.900]                       inherits <- base::inherits
[09:29:15.900]                       invokeRestart <- base::invokeRestart
[09:29:15.900]                       is.null <- base::is.null
[09:29:15.900]                       muffled <- FALSE
[09:29:15.900]                       if (inherits(cond, "message")) {
[09:29:15.900]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.900]                         if (muffled) 
[09:29:15.900]                           invokeRestart("muffleMessage")
[09:29:15.900]                       }
[09:29:15.900]                       else if (inherits(cond, "warning")) {
[09:29:15.900]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.900]                         if (muffled) 
[09:29:15.900]                           invokeRestart("muffleWarning")
[09:29:15.900]                       }
[09:29:15.900]                       else if (inherits(cond, "condition")) {
[09:29:15.900]                         if (!is.null(pattern)) {
[09:29:15.900]                           computeRestarts <- base::computeRestarts
[09:29:15.900]                           grepl <- base::grepl
[09:29:15.900]                           restarts <- computeRestarts(cond)
[09:29:15.900]                           for (restart in restarts) {
[09:29:15.900]                             name <- restart$name
[09:29:15.900]                             if (is.null(name)) 
[09:29:15.900]                               next
[09:29:15.900]                             if (!grepl(pattern, name)) 
[09:29:15.900]                               next
[09:29:15.900]                             invokeRestart(restart)
[09:29:15.900]                             muffled <- TRUE
[09:29:15.900]                             break
[09:29:15.900]                           }
[09:29:15.900]                         }
[09:29:15.900]                       }
[09:29:15.900]                       invisible(muffled)
[09:29:15.900]                     }
[09:29:15.900]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.900]                   }
[09:29:15.900]                 }
[09:29:15.900]                 else {
[09:29:15.900]                   if (TRUE) {
[09:29:15.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.900]                     {
[09:29:15.900]                       inherits <- base::inherits
[09:29:15.900]                       invokeRestart <- base::invokeRestart
[09:29:15.900]                       is.null <- base::is.null
[09:29:15.900]                       muffled <- FALSE
[09:29:15.900]                       if (inherits(cond, "message")) {
[09:29:15.900]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.900]                         if (muffled) 
[09:29:15.900]                           invokeRestart("muffleMessage")
[09:29:15.900]                       }
[09:29:15.900]                       else if (inherits(cond, "warning")) {
[09:29:15.900]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.900]                         if (muffled) 
[09:29:15.900]                           invokeRestart("muffleWarning")
[09:29:15.900]                       }
[09:29:15.900]                       else if (inherits(cond, "condition")) {
[09:29:15.900]                         if (!is.null(pattern)) {
[09:29:15.900]                           computeRestarts <- base::computeRestarts
[09:29:15.900]                           grepl <- base::grepl
[09:29:15.900]                           restarts <- computeRestarts(cond)
[09:29:15.900]                           for (restart in restarts) {
[09:29:15.900]                             name <- restart$name
[09:29:15.900]                             if (is.null(name)) 
[09:29:15.900]                               next
[09:29:15.900]                             if (!grepl(pattern, name)) 
[09:29:15.900]                               next
[09:29:15.900]                             invokeRestart(restart)
[09:29:15.900]                             muffled <- TRUE
[09:29:15.900]                             break
[09:29:15.900]                           }
[09:29:15.900]                         }
[09:29:15.900]                       }
[09:29:15.900]                       invisible(muffled)
[09:29:15.900]                     }
[09:29:15.900]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.900]                   }
[09:29:15.900]                 }
[09:29:15.900]             }
[09:29:15.900]         }))
[09:29:15.900]     }, error = function(ex) {
[09:29:15.900]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.900]                 ...future.rng), started = ...future.startTime, 
[09:29:15.900]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.900]             version = "1.8"), class = "FutureResult")
[09:29:15.900]     }, finally = {
[09:29:15.900]         if (!identical(...future.workdir, getwd())) 
[09:29:15.900]             setwd(...future.workdir)
[09:29:15.900]         {
[09:29:15.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.900]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.900]             }
[09:29:15.900]             base::options(...future.oldOptions)
[09:29:15.900]             if (.Platform$OS.type == "windows") {
[09:29:15.900]                 old_names <- names(...future.oldEnvVars)
[09:29:15.900]                 envs <- base::Sys.getenv()
[09:29:15.900]                 names <- names(envs)
[09:29:15.900]                 common <- intersect(names, old_names)
[09:29:15.900]                 added <- setdiff(names, old_names)
[09:29:15.900]                 removed <- setdiff(old_names, names)
[09:29:15.900]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.900]                   envs[common]]
[09:29:15.900]                 NAMES <- toupper(changed)
[09:29:15.900]                 args <- list()
[09:29:15.900]                 for (kk in seq_along(NAMES)) {
[09:29:15.900]                   name <- changed[[kk]]
[09:29:15.900]                   NAME <- NAMES[[kk]]
[09:29:15.900]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.900]                     next
[09:29:15.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.900]                 }
[09:29:15.900]                 NAMES <- toupper(added)
[09:29:15.900]                 for (kk in seq_along(NAMES)) {
[09:29:15.900]                   name <- added[[kk]]
[09:29:15.900]                   NAME <- NAMES[[kk]]
[09:29:15.900]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.900]                     next
[09:29:15.900]                   args[[name]] <- ""
[09:29:15.900]                 }
[09:29:15.900]                 NAMES <- toupper(removed)
[09:29:15.900]                 for (kk in seq_along(NAMES)) {
[09:29:15.900]                   name <- removed[[kk]]
[09:29:15.900]                   NAME <- NAMES[[kk]]
[09:29:15.900]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.900]                     next
[09:29:15.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.900]                 }
[09:29:15.900]                 if (length(args) > 0) 
[09:29:15.900]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.900]             }
[09:29:15.900]             else {
[09:29:15.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.900]             }
[09:29:15.900]             {
[09:29:15.900]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.900]                   0L) {
[09:29:15.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.900]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.900]                   base::options(opts)
[09:29:15.900]                 }
[09:29:15.900]                 {
[09:29:15.900]                   {
[09:29:15.900]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.900]                     NULL
[09:29:15.900]                   }
[09:29:15.900]                   options(future.plan = NULL)
[09:29:15.900]                   if (is.na(NA_character_)) 
[09:29:15.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.900]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.900]                     .init = FALSE)
[09:29:15.900]                 }
[09:29:15.900]             }
[09:29:15.900]         }
[09:29:15.900]     })
[09:29:15.900]     if (TRUE) {
[09:29:15.900]         base::sink(type = "output", split = FALSE)
[09:29:15.900]         if (TRUE) {
[09:29:15.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.900]         }
[09:29:15.900]         else {
[09:29:15.900]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.900]         }
[09:29:15.900]         base::close(...future.stdout)
[09:29:15.900]         ...future.stdout <- NULL
[09:29:15.900]     }
[09:29:15.900]     ...future.result$conditions <- ...future.conditions
[09:29:15.900]     ...future.result$finished <- base::Sys.time()
[09:29:15.900]     ...future.result
[09:29:15.900] }
[09:29:15.904] assign_globals() ...
[09:29:15.904] List of 5
[09:29:15.904]  $ ...future.FUN            :function (C, k)  
[09:29:15.904]  $ MoreArgs                 : NULL
[09:29:15.904]  $ ...future.elements_ii    :List of 2
[09:29:15.904]   ..$ :List of 1
[09:29:15.904]   .. ..$ : chr "D"
[09:29:15.904]   ..$ :List of 1
[09:29:15.904]   .. ..$ : int 2
[09:29:15.904]  $ ...future.seeds_ii       : NULL
[09:29:15.904]  $ ...future.globals.maxSize: NULL
[09:29:15.904]  - attr(*, "where")=List of 5
[09:29:15.904]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.904]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.904]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.904]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.904]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.904]  - attr(*, "resolved")= logi FALSE
[09:29:15.904]  - attr(*, "total_size")= num 3488
[09:29:15.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.904]  - attr(*, "already-done")= logi TRUE
[09:29:15.916] - reassign environment for ‘...future.FUN’
[09:29:15.916] - copied ‘...future.FUN’ to environment
[09:29:15.917] - copied ‘MoreArgs’ to environment
[09:29:15.917] - copied ‘...future.elements_ii’ to environment
[09:29:15.917] - copied ‘...future.seeds_ii’ to environment
[09:29:15.917] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.917] assign_globals() ... done
[09:29:15.917] requestCore(): workers = 2
[09:29:15.918] Poll #1 (0): usedCores() = 2, workers = 2
[09:29:15.938] result() for MulticoreFuture ...
[09:29:15.938] result() for MulticoreFuture ...
[09:29:15.939] result() for MulticoreFuture ... done
[09:29:15.939] result() for MulticoreFuture ... done
[09:29:15.939] result() for MulticoreFuture ...
[09:29:15.939] result() for MulticoreFuture ... done
[09:29:15.941] MulticoreFuture started
[09:29:15.942] - Launch lazy future ... done
[09:29:15.942] run() for ‘MulticoreFuture’ ... done
[09:29:15.942] Created future:
[09:29:15.942] plan(): Setting new future strategy stack:
[09:29:15.943] List of future strategies:
[09:29:15.943] 1. sequential:
[09:29:15.943]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:15.943]    - tweaked: FALSE
[09:29:15.943]    - call: NULL
[09:29:15.944] plan(): nbrOfWorkers() = 1
[09:29:15.947] plan(): Setting new future strategy stack:
[09:29:15.947] List of future strategies:
[09:29:15.947] 1. multicore:
[09:29:15.947]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:15.947]    - tweaked: FALSE
[09:29:15.947]    - call: plan(strategy)
[09:29:15.952] plan(): nbrOfWorkers() = 2
[09:29:15.943] MulticoreFuture:
[09:29:15.943] Label: ‘future_mapply-4’
[09:29:15.943] Expression:
[09:29:15.943] {
[09:29:15.943]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.943]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:15.943]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.943]         on.exit(options(oopts), add = TRUE)
[09:29:15.943]     }
[09:29:15.943]     {
[09:29:15.943]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.943]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:15.943]         do.call(mapply, args = args)
[09:29:15.943]     }
[09:29:15.943] }
[09:29:15.943] Lazy evaluation: FALSE
[09:29:15.943] Asynchronous evaluation: TRUE
[09:29:15.943] Local evaluation: TRUE
[09:29:15.943] Environment: R_GlobalEnv
[09:29:15.943] Capture standard output: TRUE
[09:29:15.943] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:15.943] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:15.943] Packages: <none>
[09:29:15.943] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:15.943] Resolved: TRUE
[09:29:15.943] Value: <not collected>
[09:29:15.943] Conditions captured: <none>
[09:29:15.943] Early signaling: FALSE
[09:29:15.943] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:15.943] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.953] Chunk #4 of 5 ... DONE
[09:29:15.953] Chunk #5 of 5 ...
[09:29:15.953]  - Finding globals in '...' for chunk #5 ...
[09:29:15.953] getGlobalsAndPackages() ...
[09:29:15.954] Searching for globals...
[09:29:15.954] 
[09:29:15.954] Searching for globals ... DONE
[09:29:15.954] - globals: [0] <none>
[09:29:15.955] getGlobalsAndPackages() ... DONE
[09:29:15.955]    + additional globals found: [n=0] 
[09:29:15.955]    + additional namespaces needed: [n=0] 
[09:29:15.955]  - Finding globals in '...' for chunk #5 ... DONE
[09:29:15.955]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:15.955]  - seeds: <none>
[09:29:15.955]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.956] getGlobalsAndPackages() ...
[09:29:15.956] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.956] Resolving globals: FALSE
[09:29:15.957] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:15.958] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:15.958] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:15.958] 
[09:29:15.958] getGlobalsAndPackages() ... DONE
[09:29:15.969] run() for ‘Future’ ...
[09:29:15.969] - state: ‘created’
[09:29:15.969] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:15.973] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:15.974] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:15.974]   - Field: ‘label’
[09:29:15.974]   - Field: ‘local’
[09:29:15.974]   - Field: ‘owner’
[09:29:15.974]   - Field: ‘envir’
[09:29:15.974]   - Field: ‘workers’
[09:29:15.975]   - Field: ‘packages’
[09:29:15.975]   - Field: ‘gc’
[09:29:15.975]   - Field: ‘job’
[09:29:15.975]   - Field: ‘conditions’
[09:29:15.975]   - Field: ‘expr’
[09:29:15.976]   - Field: ‘uuid’
[09:29:15.976]   - Field: ‘seed’
[09:29:15.976]   - Field: ‘version’
[09:29:15.976]   - Field: ‘result’
[09:29:15.976]   - Field: ‘asynchronous’
[09:29:15.977]   - Field: ‘calls’
[09:29:15.977]   - Field: ‘globals’
[09:29:15.977]   - Field: ‘stdout’
[09:29:15.977]   - Field: ‘earlySignal’
[09:29:15.977]   - Field: ‘lazy’
[09:29:15.978]   - Field: ‘state’
[09:29:15.978] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:15.978] - Launch lazy future ...
[09:29:15.978] Packages needed by the future expression (n = 0): <none>
[09:29:15.979] Packages needed by future strategies (n = 0): <none>
[09:29:15.979] {
[09:29:15.979]     {
[09:29:15.979]         {
[09:29:15.979]             ...future.startTime <- base::Sys.time()
[09:29:15.979]             {
[09:29:15.979]                 {
[09:29:15.979]                   {
[09:29:15.979]                     {
[09:29:15.979]                       base::local({
[09:29:15.979]                         has_future <- base::requireNamespace("future", 
[09:29:15.979]                           quietly = TRUE)
[09:29:15.979]                         if (has_future) {
[09:29:15.979]                           ns <- base::getNamespace("future")
[09:29:15.979]                           version <- ns[[".package"]][["version"]]
[09:29:15.979]                           if (is.null(version)) 
[09:29:15.979]                             version <- utils::packageVersion("future")
[09:29:15.979]                         }
[09:29:15.979]                         else {
[09:29:15.979]                           version <- NULL
[09:29:15.979]                         }
[09:29:15.979]                         if (!has_future || version < "1.8.0") {
[09:29:15.979]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:15.979]                             "", base::R.version$version.string), 
[09:29:15.979]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:15.979]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:15.979]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:15.979]                               "release", "version")], collapse = " "), 
[09:29:15.979]                             hostname = base::Sys.info()[["nodename"]])
[09:29:15.979]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:15.979]                             info)
[09:29:15.979]                           info <- base::paste(info, collapse = "; ")
[09:29:15.979]                           if (!has_future) {
[09:29:15.979]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:15.979]                               info)
[09:29:15.979]                           }
[09:29:15.979]                           else {
[09:29:15.979]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:15.979]                               info, version)
[09:29:15.979]                           }
[09:29:15.979]                           base::stop(msg)
[09:29:15.979]                         }
[09:29:15.979]                       })
[09:29:15.979]                     }
[09:29:15.979]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:15.979]                     base::options(mc.cores = 1L)
[09:29:15.979]                   }
[09:29:15.979]                   ...future.strategy.old <- future::plan("list")
[09:29:15.979]                   options(future.plan = NULL)
[09:29:15.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:15.979]                 }
[09:29:15.979]                 ...future.workdir <- getwd()
[09:29:15.979]             }
[09:29:15.979]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:15.979]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:15.979]         }
[09:29:15.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:15.979]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:15.979]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:15.979]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:15.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:15.979]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:15.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:15.979]             base::names(...future.oldOptions))
[09:29:15.979]     }
[09:29:15.979]     if (FALSE) {
[09:29:15.979]     }
[09:29:15.979]     else {
[09:29:15.979]         if (TRUE) {
[09:29:15.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:15.979]                 open = "w")
[09:29:15.979]         }
[09:29:15.979]         else {
[09:29:15.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:15.979]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:15.979]         }
[09:29:15.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:15.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:15.979]             base::sink(type = "output", split = FALSE)
[09:29:15.979]             base::close(...future.stdout)
[09:29:15.979]         }, add = TRUE)
[09:29:15.979]     }
[09:29:15.979]     ...future.frame <- base::sys.nframe()
[09:29:15.979]     ...future.conditions <- base::list()
[09:29:15.979]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:15.979]     if (FALSE) {
[09:29:15.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:15.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:15.979]     }
[09:29:15.979]     ...future.result <- base::tryCatch({
[09:29:15.979]         base::withCallingHandlers({
[09:29:15.979]             ...future.value <- base::withVisible(base::local({
[09:29:15.979]                 withCallingHandlers({
[09:29:15.979]                   {
[09:29:15.979]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:15.979]                     if (!identical(...future.globals.maxSize.org, 
[09:29:15.979]                       ...future.globals.maxSize)) {
[09:29:15.979]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:15.979]                       on.exit(options(oopts), add = TRUE)
[09:29:15.979]                     }
[09:29:15.979]                     {
[09:29:15.979]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:15.979]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:15.979]                         USE.NAMES = FALSE)
[09:29:15.979]                       do.call(mapply, args = args)
[09:29:15.979]                     }
[09:29:15.979]                   }
[09:29:15.979]                 }, immediateCondition = function(cond) {
[09:29:15.979]                   save_rds <- function (object, pathname, ...) 
[09:29:15.979]                   {
[09:29:15.979]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:15.979]                     if (file_test("-f", pathname_tmp)) {
[09:29:15.979]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.979]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:15.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.979]                         fi_tmp[["mtime"]])
[09:29:15.979]                     }
[09:29:15.979]                     tryCatch({
[09:29:15.979]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:15.979]                     }, error = function(ex) {
[09:29:15.979]                       msg <- conditionMessage(ex)
[09:29:15.979]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.979]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:15.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.979]                         fi_tmp[["mtime"]], msg)
[09:29:15.979]                       ex$message <- msg
[09:29:15.979]                       stop(ex)
[09:29:15.979]                     })
[09:29:15.979]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:15.979]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:15.979]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:15.979]                       fi_tmp <- file.info(pathname_tmp)
[09:29:15.979]                       fi <- file.info(pathname)
[09:29:15.979]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:15.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:15.979]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:15.979]                         fi[["size"]], fi[["mtime"]])
[09:29:15.979]                       stop(msg)
[09:29:15.979]                     }
[09:29:15.979]                     invisible(pathname)
[09:29:15.979]                   }
[09:29:15.979]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:15.979]                     rootPath = tempdir()) 
[09:29:15.979]                   {
[09:29:15.979]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:15.979]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:15.979]                       tmpdir = path, fileext = ".rds")
[09:29:15.979]                     save_rds(obj, file)
[09:29:15.979]                   }
[09:29:15.979]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:15.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.979]                   {
[09:29:15.979]                     inherits <- base::inherits
[09:29:15.979]                     invokeRestart <- base::invokeRestart
[09:29:15.979]                     is.null <- base::is.null
[09:29:15.979]                     muffled <- FALSE
[09:29:15.979]                     if (inherits(cond, "message")) {
[09:29:15.979]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:15.979]                       if (muffled) 
[09:29:15.979]                         invokeRestart("muffleMessage")
[09:29:15.979]                     }
[09:29:15.979]                     else if (inherits(cond, "warning")) {
[09:29:15.979]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:15.979]                       if (muffled) 
[09:29:15.979]                         invokeRestart("muffleWarning")
[09:29:15.979]                     }
[09:29:15.979]                     else if (inherits(cond, "condition")) {
[09:29:15.979]                       if (!is.null(pattern)) {
[09:29:15.979]                         computeRestarts <- base::computeRestarts
[09:29:15.979]                         grepl <- base::grepl
[09:29:15.979]                         restarts <- computeRestarts(cond)
[09:29:15.979]                         for (restart in restarts) {
[09:29:15.979]                           name <- restart$name
[09:29:15.979]                           if (is.null(name)) 
[09:29:15.979]                             next
[09:29:15.979]                           if (!grepl(pattern, name)) 
[09:29:15.979]                             next
[09:29:15.979]                           invokeRestart(restart)
[09:29:15.979]                           muffled <- TRUE
[09:29:15.979]                           break
[09:29:15.979]                         }
[09:29:15.979]                       }
[09:29:15.979]                     }
[09:29:15.979]                     invisible(muffled)
[09:29:15.979]                   }
[09:29:15.979]                   muffleCondition(cond)
[09:29:15.979]                 })
[09:29:15.979]             }))
[09:29:15.979]             future::FutureResult(value = ...future.value$value, 
[09:29:15.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.979]                   ...future.rng), globalenv = if (FALSE) 
[09:29:15.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:15.979]                     ...future.globalenv.names))
[09:29:15.979]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:15.979]         }, condition = base::local({
[09:29:15.979]             c <- base::c
[09:29:15.979]             inherits <- base::inherits
[09:29:15.979]             invokeRestart <- base::invokeRestart
[09:29:15.979]             length <- base::length
[09:29:15.979]             list <- base::list
[09:29:15.979]             seq.int <- base::seq.int
[09:29:15.979]             signalCondition <- base::signalCondition
[09:29:15.979]             sys.calls <- base::sys.calls
[09:29:15.979]             `[[` <- base::`[[`
[09:29:15.979]             `+` <- base::`+`
[09:29:15.979]             `<<-` <- base::`<<-`
[09:29:15.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:15.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:15.979]                   3L)]
[09:29:15.979]             }
[09:29:15.979]             function(cond) {
[09:29:15.979]                 is_error <- inherits(cond, "error")
[09:29:15.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:15.979]                   NULL)
[09:29:15.979]                 if (is_error) {
[09:29:15.979]                   sessionInformation <- function() {
[09:29:15.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:15.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:15.979]                       search = base::search(), system = base::Sys.info())
[09:29:15.979]                   }
[09:29:15.979]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:15.979]                     cond$call), session = sessionInformation(), 
[09:29:15.979]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:15.979]                   signalCondition(cond)
[09:29:15.979]                 }
[09:29:15.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:15.979]                 "immediateCondition"))) {
[09:29:15.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:15.979]                   ...future.conditions[[length(...future.conditions) + 
[09:29:15.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:15.979]                   if (TRUE && !signal) {
[09:29:15.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.979]                     {
[09:29:15.979]                       inherits <- base::inherits
[09:29:15.979]                       invokeRestart <- base::invokeRestart
[09:29:15.979]                       is.null <- base::is.null
[09:29:15.979]                       muffled <- FALSE
[09:29:15.979]                       if (inherits(cond, "message")) {
[09:29:15.979]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.979]                         if (muffled) 
[09:29:15.979]                           invokeRestart("muffleMessage")
[09:29:15.979]                       }
[09:29:15.979]                       else if (inherits(cond, "warning")) {
[09:29:15.979]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.979]                         if (muffled) 
[09:29:15.979]                           invokeRestart("muffleWarning")
[09:29:15.979]                       }
[09:29:15.979]                       else if (inherits(cond, "condition")) {
[09:29:15.979]                         if (!is.null(pattern)) {
[09:29:15.979]                           computeRestarts <- base::computeRestarts
[09:29:15.979]                           grepl <- base::grepl
[09:29:15.979]                           restarts <- computeRestarts(cond)
[09:29:15.979]                           for (restart in restarts) {
[09:29:15.979]                             name <- restart$name
[09:29:15.979]                             if (is.null(name)) 
[09:29:15.979]                               next
[09:29:15.979]                             if (!grepl(pattern, name)) 
[09:29:15.979]                               next
[09:29:15.979]                             invokeRestart(restart)
[09:29:15.979]                             muffled <- TRUE
[09:29:15.979]                             break
[09:29:15.979]                           }
[09:29:15.979]                         }
[09:29:15.979]                       }
[09:29:15.979]                       invisible(muffled)
[09:29:15.979]                     }
[09:29:15.979]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.979]                   }
[09:29:15.979]                 }
[09:29:15.979]                 else {
[09:29:15.979]                   if (TRUE) {
[09:29:15.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:15.979]                     {
[09:29:15.979]                       inherits <- base::inherits
[09:29:15.979]                       invokeRestart <- base::invokeRestart
[09:29:15.979]                       is.null <- base::is.null
[09:29:15.979]                       muffled <- FALSE
[09:29:15.979]                       if (inherits(cond, "message")) {
[09:29:15.979]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:15.979]                         if (muffled) 
[09:29:15.979]                           invokeRestart("muffleMessage")
[09:29:15.979]                       }
[09:29:15.979]                       else if (inherits(cond, "warning")) {
[09:29:15.979]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:15.979]                         if (muffled) 
[09:29:15.979]                           invokeRestart("muffleWarning")
[09:29:15.979]                       }
[09:29:15.979]                       else if (inherits(cond, "condition")) {
[09:29:15.979]                         if (!is.null(pattern)) {
[09:29:15.979]                           computeRestarts <- base::computeRestarts
[09:29:15.979]                           grepl <- base::grepl
[09:29:15.979]                           restarts <- computeRestarts(cond)
[09:29:15.979]                           for (restart in restarts) {
[09:29:15.979]                             name <- restart$name
[09:29:15.979]                             if (is.null(name)) 
[09:29:15.979]                               next
[09:29:15.979]                             if (!grepl(pattern, name)) 
[09:29:15.979]                               next
[09:29:15.979]                             invokeRestart(restart)
[09:29:15.979]                             muffled <- TRUE
[09:29:15.979]                             break
[09:29:15.979]                           }
[09:29:15.979]                         }
[09:29:15.979]                       }
[09:29:15.979]                       invisible(muffled)
[09:29:15.979]                     }
[09:29:15.979]                     muffleCondition(cond, pattern = "^muffle")
[09:29:15.979]                   }
[09:29:15.979]                 }
[09:29:15.979]             }
[09:29:15.979]         }))
[09:29:15.979]     }, error = function(ex) {
[09:29:15.979]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:15.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:15.979]                 ...future.rng), started = ...future.startTime, 
[09:29:15.979]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:15.979]             version = "1.8"), class = "FutureResult")
[09:29:15.979]     }, finally = {
[09:29:15.979]         if (!identical(...future.workdir, getwd())) 
[09:29:15.979]             setwd(...future.workdir)
[09:29:15.979]         {
[09:29:15.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:15.979]                 ...future.oldOptions$nwarnings <- NULL
[09:29:15.979]             }
[09:29:15.979]             base::options(...future.oldOptions)
[09:29:15.979]             if (.Platform$OS.type == "windows") {
[09:29:15.979]                 old_names <- names(...future.oldEnvVars)
[09:29:15.979]                 envs <- base::Sys.getenv()
[09:29:15.979]                 names <- names(envs)
[09:29:15.979]                 common <- intersect(names, old_names)
[09:29:15.979]                 added <- setdiff(names, old_names)
[09:29:15.979]                 removed <- setdiff(old_names, names)
[09:29:15.979]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:15.979]                   envs[common]]
[09:29:15.979]                 NAMES <- toupper(changed)
[09:29:15.979]                 args <- list()
[09:29:15.979]                 for (kk in seq_along(NAMES)) {
[09:29:15.979]                   name <- changed[[kk]]
[09:29:15.979]                   NAME <- NAMES[[kk]]
[09:29:15.979]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.979]                     next
[09:29:15.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.979]                 }
[09:29:15.979]                 NAMES <- toupper(added)
[09:29:15.979]                 for (kk in seq_along(NAMES)) {
[09:29:15.979]                   name <- added[[kk]]
[09:29:15.979]                   NAME <- NAMES[[kk]]
[09:29:15.979]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.979]                     next
[09:29:15.979]                   args[[name]] <- ""
[09:29:15.979]                 }
[09:29:15.979]                 NAMES <- toupper(removed)
[09:29:15.979]                 for (kk in seq_along(NAMES)) {
[09:29:15.979]                   name <- removed[[kk]]
[09:29:15.979]                   NAME <- NAMES[[kk]]
[09:29:15.979]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:15.979]                     next
[09:29:15.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:15.979]                 }
[09:29:15.979]                 if (length(args) > 0) 
[09:29:15.979]                   base::do.call(base::Sys.setenv, args = args)
[09:29:15.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:15.979]             }
[09:29:15.979]             else {
[09:29:15.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:15.979]             }
[09:29:15.979]             {
[09:29:15.979]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:15.979]                   0L) {
[09:29:15.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:15.979]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:15.979]                   base::options(opts)
[09:29:15.979]                 }
[09:29:15.979]                 {
[09:29:15.979]                   {
[09:29:15.979]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:15.979]                     NULL
[09:29:15.979]                   }
[09:29:15.979]                   options(future.plan = NULL)
[09:29:15.979]                   if (is.na(NA_character_)) 
[09:29:15.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:15.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:15.979]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:15.979]                     .init = FALSE)
[09:29:15.979]                 }
[09:29:15.979]             }
[09:29:15.979]         }
[09:29:15.979]     })
[09:29:15.979]     if (TRUE) {
[09:29:15.979]         base::sink(type = "output", split = FALSE)
[09:29:15.979]         if (TRUE) {
[09:29:15.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:15.979]         }
[09:29:15.979]         else {
[09:29:15.979]             ...future.result["stdout"] <- base::list(NULL)
[09:29:15.979]         }
[09:29:15.979]         base::close(...future.stdout)
[09:29:15.979]         ...future.stdout <- NULL
[09:29:15.979]     }
[09:29:15.979]     ...future.result$conditions <- ...future.conditions
[09:29:15.979]     ...future.result$finished <- base::Sys.time()
[09:29:15.979]     ...future.result
[09:29:15.979] }
[09:29:15.982] assign_globals() ...
[09:29:15.982] List of 5
[09:29:15.982]  $ ...future.FUN            :function (C, k)  
[09:29:15.982]  $ MoreArgs                 : NULL
[09:29:15.982]  $ ...future.elements_ii    :List of 2
[09:29:15.982]   ..$ :List of 1
[09:29:15.982]   .. ..$ : chr "E"
[09:29:15.982]   ..$ :List of 1
[09:29:15.982]   .. ..$ : int 1
[09:29:15.982]  $ ...future.seeds_ii       : NULL
[09:29:15.982]  $ ...future.globals.maxSize: NULL
[09:29:15.982]  - attr(*, "where")=List of 5
[09:29:15.982]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:15.982]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:15.982]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:15.982]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:15.982]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:15.982]  - attr(*, "resolved")= logi FALSE
[09:29:15.982]  - attr(*, "total_size")= num 3488
[09:29:15.982]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:15.982]  - attr(*, "already-done")= logi TRUE
[09:29:15.989] - reassign environment for ‘...future.FUN’
[09:29:15.989] - copied ‘...future.FUN’ to environment
[09:29:15.989] - copied ‘MoreArgs’ to environment
[09:29:15.989] - copied ‘...future.elements_ii’ to environment
[09:29:15.989] - copied ‘...future.seeds_ii’ to environment
[09:29:15.990] - copied ‘...future.globals.maxSize’ to environment
[09:29:15.990] assign_globals() ... done
[09:29:15.990] requestCore(): workers = 2
[09:29:15.990] Poll #1 (0): usedCores() = 2, workers = 2
[09:29:16.001] result() for MulticoreFuture ...
[09:29:16.001] result() for MulticoreFuture ...
[09:29:16.002] result() for MulticoreFuture ... done
[09:29:16.002] result() for MulticoreFuture ... done
[09:29:16.002] result() for MulticoreFuture ...
[09:29:16.002] result() for MulticoreFuture ... done
[09:29:16.005] MulticoreFuture started
[09:29:16.006] - Launch lazy future ... done
[09:29:16.006] run() for ‘MulticoreFuture’ ... done
[09:29:16.006] plan(): Setting new future strategy stack:
[09:29:16.006] Created future:
[09:29:16.006] List of future strategies:
[09:29:16.006] 1. sequential:
[09:29:16.006]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.006]    - tweaked: FALSE
[09:29:16.006]    - call: NULL
[09:29:16.007] plan(): nbrOfWorkers() = 1
[09:29:16.010] plan(): Setting new future strategy stack:
[09:29:16.010] List of future strategies:
[09:29:16.010] 1. multicore:
[09:29:16.010]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.010]    - tweaked: FALSE
[09:29:16.010]    - call: plan(strategy)
[09:29:16.015] plan(): nbrOfWorkers() = 2
[09:29:16.006] MulticoreFuture:
[09:29:16.006] Label: ‘future_mapply-5’
[09:29:16.006] Expression:
[09:29:16.006] {
[09:29:16.006]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.006]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.006]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.006]         on.exit(options(oopts), add = TRUE)
[09:29:16.006]     }
[09:29:16.006]     {
[09:29:16.006]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.006]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.006]         do.call(mapply, args = args)
[09:29:16.006]     }
[09:29:16.006] }
[09:29:16.006] Lazy evaluation: FALSE
[09:29:16.006] Asynchronous evaluation: TRUE
[09:29:16.006] Local evaluation: TRUE
[09:29:16.006] Environment: R_GlobalEnv
[09:29:16.006] Capture standard output: TRUE
[09:29:16.006] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.006] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.006] Packages: <none>
[09:29:16.006] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.006] Resolved: TRUE
[09:29:16.006] Value: <not collected>
[09:29:16.006] Conditions captured: <none>
[09:29:16.006] Early signaling: FALSE
[09:29:16.006] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.006] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.017] Chunk #5 of 5 ... DONE
[09:29:16.017] Launching 5 futures (chunks) ... DONE
[09:29:16.017] Resolving 5 futures (chunks) ...
[09:29:16.017] resolve() on list ...
[09:29:16.017]  recursive: 0
[09:29:16.017]  length: 5
[09:29:16.018] 
[09:29:16.018] Future #1
[09:29:16.018] result() for MulticoreFuture ...
[09:29:16.018] result() for MulticoreFuture ... done
[09:29:16.018] result() for MulticoreFuture ...
[09:29:16.018] result() for MulticoreFuture ... done
[09:29:16.018] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:16.019] - nx: 5
[09:29:16.019] - relay: TRUE
[09:29:16.019] - stdout: TRUE
[09:29:16.019] - signal: TRUE
[09:29:16.019] - resignal: FALSE
[09:29:16.019] - force: TRUE
[09:29:16.019] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[09:29:16.020] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[09:29:16.020]  - until=1
[09:29:16.020]  - relaying element #1
[09:29:16.020] result() for MulticoreFuture ...
[09:29:16.020] result() for MulticoreFuture ... done
[09:29:16.020] result() for MulticoreFuture ...
[09:29:16.021] result() for MulticoreFuture ... done
[09:29:16.021] result() for MulticoreFuture ...
[09:29:16.021] result() for MulticoreFuture ... done
[09:29:16.021] result() for MulticoreFuture ...
[09:29:16.021] result() for MulticoreFuture ... done
[09:29:16.021] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[09:29:16.022] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[09:29:16.022] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:16.022]  length: 4 (resolved future 1)
[09:29:16.022] Future #2
[09:29:16.022] result() for MulticoreFuture ...
[09:29:16.022] result() for MulticoreFuture ... done
[09:29:16.023] result() for MulticoreFuture ...
[09:29:16.023] result() for MulticoreFuture ... done
[09:29:16.023] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:16.023] - nx: 5
[09:29:16.023] - relay: TRUE
[09:29:16.023] - stdout: TRUE
[09:29:16.023] - signal: TRUE
[09:29:16.024] - resignal: FALSE
[09:29:16.024] - force: TRUE
[09:29:16.024] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[09:29:16.024] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[09:29:16.024]  - until=2
[09:29:16.024]  - relaying element #2
[09:29:16.024] result() for MulticoreFuture ...
[09:29:16.025] result() for MulticoreFuture ... done
[09:29:16.025] result() for MulticoreFuture ...
[09:29:16.025] result() for MulticoreFuture ... done
[09:29:16.025] result() for MulticoreFuture ...
[09:29:16.025] result() for MulticoreFuture ... done
[09:29:16.025] result() for MulticoreFuture ...
[09:29:16.026] result() for MulticoreFuture ... done
[09:29:16.026] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[09:29:16.026] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[09:29:16.026] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:16.026]  length: 3 (resolved future 2)
[09:29:16.026] Future #3
[09:29:16.026] result() for MulticoreFuture ...
[09:29:16.027] result() for MulticoreFuture ... done
[09:29:16.027] result() for MulticoreFuture ...
[09:29:16.027] result() for MulticoreFuture ... done
[09:29:16.031] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:29:16.031] - nx: 5
[09:29:16.031] - relay: TRUE
[09:29:16.032] - stdout: TRUE
[09:29:16.032] - signal: TRUE
[09:29:16.032] - resignal: FALSE
[09:29:16.032] - force: TRUE
[09:29:16.033] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[09:29:16.033] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[09:29:16.033]  - until=3
[09:29:16.033]  - relaying element #3
[09:29:16.034] result() for MulticoreFuture ...
[09:29:16.034] result() for MulticoreFuture ... done
[09:29:16.034] result() for MulticoreFuture ...
[09:29:16.034] result() for MulticoreFuture ... done
[09:29:16.035] result() for MulticoreFuture ...
[09:29:16.035] result() for MulticoreFuture ... done
[09:29:16.035] result() for MulticoreFuture ...
[09:29:16.035] result() for MulticoreFuture ... done
[09:29:16.035] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[09:29:16.035] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[09:29:16.036] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:29:16.036]  length: 2 (resolved future 3)
[09:29:16.036] Future #4
[09:29:16.037] result() for MulticoreFuture ...
[09:29:16.038] result() for MulticoreFuture ...
[09:29:16.038] result() for MulticoreFuture ... done
[09:29:16.038] result() for MulticoreFuture ... done
[09:29:16.038] result() for MulticoreFuture ...
[09:29:16.039] result() for MulticoreFuture ... done
[09:29:16.039] signalConditionsASAP(MulticoreFuture, pos=4) ...
[09:29:16.039] - nx: 5
[09:29:16.039] - relay: TRUE
[09:29:16.040] - stdout: TRUE
[09:29:16.040] - signal: TRUE
[09:29:16.040] - resignal: FALSE
[09:29:16.040] - force: TRUE
[09:29:16.041] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[09:29:16.041] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[09:29:16.041]  - until=4
[09:29:16.041]  - relaying element #4
[09:29:16.041] result() for MulticoreFuture ...
[09:29:16.042] result() for MulticoreFuture ... done
[09:29:16.042] result() for MulticoreFuture ...
[09:29:16.042] result() for MulticoreFuture ... done
[09:29:16.042] result() for MulticoreFuture ...
[09:29:16.043] result() for MulticoreFuture ... done
[09:29:16.043] result() for MulticoreFuture ...
[09:29:16.043] result() for MulticoreFuture ... done
[09:29:16.043] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[09:29:16.043] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[09:29:16.043] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[09:29:16.043]  length: 1 (resolved future 4)
[09:29:16.044] Future #5
[09:29:16.044] result() for MulticoreFuture ...
[09:29:16.044] result() for MulticoreFuture ...
[09:29:16.045] result() for MulticoreFuture ... done
[09:29:16.045] result() for MulticoreFuture ... done
[09:29:16.045] result() for MulticoreFuture ...
[09:29:16.045] result() for MulticoreFuture ... done
[09:29:16.045] signalConditionsASAP(MulticoreFuture, pos=5) ...
[09:29:16.045] - nx: 5
[09:29:16.045] - relay: TRUE
[09:29:16.046] - stdout: TRUE
[09:29:16.046] - signal: TRUE
[09:29:16.046] - resignal: FALSE
[09:29:16.046] - force: TRUE
[09:29:16.046] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[09:29:16.046] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[09:29:16.046]  - until=5
[09:29:16.046]  - relaying element #5
[09:29:16.046] result() for MulticoreFuture ...
[09:29:16.047] result() for MulticoreFuture ... done
[09:29:16.047] result() for MulticoreFuture ...
[09:29:16.047] result() for MulticoreFuture ... done
[09:29:16.047] result() for MulticoreFuture ...
[09:29:16.047] result() for MulticoreFuture ... done
[09:29:16.047] result() for MulticoreFuture ...
[09:29:16.047] result() for MulticoreFuture ... done
[09:29:16.047] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:16.048] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:16.048] signalConditionsASAP(MulticoreFuture, pos=5) ... done
[09:29:16.048]  length: 0 (resolved future 5)
[09:29:16.048] Relaying remaining futures
[09:29:16.048] signalConditionsASAP(NULL, pos=0) ...
[09:29:16.048] - nx: 5
[09:29:16.048] - relay: TRUE
[09:29:16.048] - stdout: TRUE
[09:29:16.048] - signal: TRUE
[09:29:16.048] - resignal: FALSE
[09:29:16.048] - force: TRUE
[09:29:16.049] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:16.049] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[09:29:16.049] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:16.049] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:16.049] signalConditionsASAP(NULL, pos=0) ... done
[09:29:16.049] resolve() on list ... DONE
[09:29:16.049] result() for MulticoreFuture ...
[09:29:16.049] result() for MulticoreFuture ... done
[09:29:16.049] result() for MulticoreFuture ...
[09:29:16.050] result() for MulticoreFuture ... done
[09:29:16.050] result() for MulticoreFuture ...
[09:29:16.050] result() for MulticoreFuture ... done
[09:29:16.050] result() for MulticoreFuture ...
[09:29:16.050] result() for MulticoreFuture ... done
[09:29:16.050] result() for MulticoreFuture ...
[09:29:16.050] result() for MulticoreFuture ... done
[09:29:16.050] result() for MulticoreFuture ...
[09:29:16.050] result() for MulticoreFuture ... done
[09:29:16.050] result() for MulticoreFuture ...
[09:29:16.051] result() for MulticoreFuture ... done
[09:29:16.051] result() for MulticoreFuture ...
[09:29:16.051] result() for MulticoreFuture ... done
[09:29:16.051] result() for MulticoreFuture ...
[09:29:16.051] result() for MulticoreFuture ... done
[09:29:16.051] result() for MulticoreFuture ...
[09:29:16.051] result() for MulticoreFuture ... done
[09:29:16.051]  - Number of value chunks collected: 5
[09:29:16.052] Resolving 5 futures (chunks) ... DONE
[09:29:16.052] Reducing values from 5 chunks ...
[09:29:16.052]  - Number of values collected after concatenation: 5
[09:29:16.052]  - Number of values expected: 5
[09:29:16.052] Reducing values from 5 chunks ... DONE
[09:29:16.052] future_mapply() ... DONE
[09:29:16.052] future_mapply() ...
[09:29:16.056] Number of chunks: 2
[09:29:16.057] getGlobalsAndPackagesXApply() ...
[09:29:16.057]  - future.globals: TRUE
[09:29:16.057] getGlobalsAndPackages() ...
[09:29:16.057] Searching for globals...
[09:29:16.058] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:16.058] Searching for globals ... DONE
[09:29:16.058] Resolving globals: FALSE
[09:29:16.059] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:16.059] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:16.059] - globals: [1] ‘FUN’
[09:29:16.059] 
[09:29:16.060] getGlobalsAndPackages() ... DONE
[09:29:16.060]  - globals found/used: [n=1] ‘FUN’
[09:29:16.060]  - needed namespaces: [n=0] 
[09:29:16.060] Finding globals ... DONE
[09:29:16.060] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:16.060] List of 2
[09:29:16.060]  $ ...future.FUN:function (C, k)  
[09:29:16.060]  $ MoreArgs     : list()
[09:29:16.060]  - attr(*, "where")=List of 2
[09:29:16.060]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:16.060]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:16.060]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.060]  - attr(*, "resolved")= logi FALSE
[09:29:16.060]  - attr(*, "total_size")= num NA
[09:29:16.063] Packages to be attached in all futures: [n=0] 
[09:29:16.063] getGlobalsAndPackagesXApply() ... DONE
[09:29:16.063] Number of futures (= number of chunks): 2
[09:29:16.065] Launching 2 futures (chunks) ...
[09:29:16.065] Chunk #1 of 2 ...
[09:29:16.066]  - Finding globals in '...' for chunk #1 ...
[09:29:16.066] getGlobalsAndPackages() ...
[09:29:16.066] Searching for globals...
[09:29:16.066] 
[09:29:16.066] Searching for globals ... DONE
[09:29:16.066] - globals: [0] <none>
[09:29:16.066] getGlobalsAndPackages() ... DONE
[09:29:16.067]    + additional globals found: [n=0] 
[09:29:16.067]    + additional namespaces needed: [n=0] 
[09:29:16.067]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:16.067]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:16.067]  - seeds: <none>
[09:29:16.067]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.067] getGlobalsAndPackages() ...
[09:29:16.067] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.067] Resolving globals: FALSE
[09:29:16.068] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:16.068] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:16.069] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.069] 
[09:29:16.069] getGlobalsAndPackages() ... DONE
[09:29:16.069] run() for ‘Future’ ...
[09:29:16.069] - state: ‘created’
[09:29:16.069] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.073] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.073] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.074]   - Field: ‘label’
[09:29:16.074]   - Field: ‘local’
[09:29:16.074]   - Field: ‘owner’
[09:29:16.074]   - Field: ‘envir’
[09:29:16.074]   - Field: ‘workers’
[09:29:16.074]   - Field: ‘packages’
[09:29:16.074]   - Field: ‘gc’
[09:29:16.074]   - Field: ‘job’
[09:29:16.074]   - Field: ‘conditions’
[09:29:16.074]   - Field: ‘expr’
[09:29:16.074]   - Field: ‘uuid’
[09:29:16.075]   - Field: ‘seed’
[09:29:16.075]   - Field: ‘version’
[09:29:16.075]   - Field: ‘result’
[09:29:16.075]   - Field: ‘asynchronous’
[09:29:16.075]   - Field: ‘calls’
[09:29:16.075]   - Field: ‘globals’
[09:29:16.075]   - Field: ‘stdout’
[09:29:16.075]   - Field: ‘earlySignal’
[09:29:16.075]   - Field: ‘lazy’
[09:29:16.075]   - Field: ‘state’
[09:29:16.075] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.076] - Launch lazy future ...
[09:29:16.076] Packages needed by the future expression (n = 0): <none>
[09:29:16.076] Packages needed by future strategies (n = 0): <none>
[09:29:16.076] {
[09:29:16.076]     {
[09:29:16.076]         {
[09:29:16.076]             ...future.startTime <- base::Sys.time()
[09:29:16.076]             {
[09:29:16.076]                 {
[09:29:16.076]                   {
[09:29:16.076]                     {
[09:29:16.076]                       base::local({
[09:29:16.076]                         has_future <- base::requireNamespace("future", 
[09:29:16.076]                           quietly = TRUE)
[09:29:16.076]                         if (has_future) {
[09:29:16.076]                           ns <- base::getNamespace("future")
[09:29:16.076]                           version <- ns[[".package"]][["version"]]
[09:29:16.076]                           if (is.null(version)) 
[09:29:16.076]                             version <- utils::packageVersion("future")
[09:29:16.076]                         }
[09:29:16.076]                         else {
[09:29:16.076]                           version <- NULL
[09:29:16.076]                         }
[09:29:16.076]                         if (!has_future || version < "1.8.0") {
[09:29:16.076]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.076]                             "", base::R.version$version.string), 
[09:29:16.076]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.076]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.076]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.076]                               "release", "version")], collapse = " "), 
[09:29:16.076]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.076]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.076]                             info)
[09:29:16.076]                           info <- base::paste(info, collapse = "; ")
[09:29:16.076]                           if (!has_future) {
[09:29:16.076]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.076]                               info)
[09:29:16.076]                           }
[09:29:16.076]                           else {
[09:29:16.076]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.076]                               info, version)
[09:29:16.076]                           }
[09:29:16.076]                           base::stop(msg)
[09:29:16.076]                         }
[09:29:16.076]                       })
[09:29:16.076]                     }
[09:29:16.076]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.076]                     base::options(mc.cores = 1L)
[09:29:16.076]                   }
[09:29:16.076]                   ...future.strategy.old <- future::plan("list")
[09:29:16.076]                   options(future.plan = NULL)
[09:29:16.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.076]                 }
[09:29:16.076]                 ...future.workdir <- getwd()
[09:29:16.076]             }
[09:29:16.076]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.076]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.076]         }
[09:29:16.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.076]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:16.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.076]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.076]             base::names(...future.oldOptions))
[09:29:16.076]     }
[09:29:16.076]     if (FALSE) {
[09:29:16.076]     }
[09:29:16.076]     else {
[09:29:16.076]         if (TRUE) {
[09:29:16.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.076]                 open = "w")
[09:29:16.076]         }
[09:29:16.076]         else {
[09:29:16.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.076]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.076]         }
[09:29:16.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.076]             base::sink(type = "output", split = FALSE)
[09:29:16.076]             base::close(...future.stdout)
[09:29:16.076]         }, add = TRUE)
[09:29:16.076]     }
[09:29:16.076]     ...future.frame <- base::sys.nframe()
[09:29:16.076]     ...future.conditions <- base::list()
[09:29:16.076]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.076]     if (FALSE) {
[09:29:16.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.076]     }
[09:29:16.076]     ...future.result <- base::tryCatch({
[09:29:16.076]         base::withCallingHandlers({
[09:29:16.076]             ...future.value <- base::withVisible(base::local({
[09:29:16.076]                 withCallingHandlers({
[09:29:16.076]                   {
[09:29:16.076]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.076]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.076]                       ...future.globals.maxSize)) {
[09:29:16.076]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.076]                       on.exit(options(oopts), add = TRUE)
[09:29:16.076]                     }
[09:29:16.076]                     {
[09:29:16.076]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.076]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.076]                         USE.NAMES = FALSE)
[09:29:16.076]                       do.call(mapply, args = args)
[09:29:16.076]                     }
[09:29:16.076]                   }
[09:29:16.076]                 }, immediateCondition = function(cond) {
[09:29:16.076]                   save_rds <- function (object, pathname, ...) 
[09:29:16.076]                   {
[09:29:16.076]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.076]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.076]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.076]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.076]                         fi_tmp[["mtime"]])
[09:29:16.076]                     }
[09:29:16.076]                     tryCatch({
[09:29:16.076]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.076]                     }, error = function(ex) {
[09:29:16.076]                       msg <- conditionMessage(ex)
[09:29:16.076]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.076]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.076]                         fi_tmp[["mtime"]], msg)
[09:29:16.076]                       ex$message <- msg
[09:29:16.076]                       stop(ex)
[09:29:16.076]                     })
[09:29:16.076]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.076]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.076]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.076]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.076]                       fi <- file.info(pathname)
[09:29:16.076]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.076]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.076]                         fi[["size"]], fi[["mtime"]])
[09:29:16.076]                       stop(msg)
[09:29:16.076]                     }
[09:29:16.076]                     invisible(pathname)
[09:29:16.076]                   }
[09:29:16.076]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.076]                     rootPath = tempdir()) 
[09:29:16.076]                   {
[09:29:16.076]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.076]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.076]                       tmpdir = path, fileext = ".rds")
[09:29:16.076]                     save_rds(obj, file)
[09:29:16.076]                   }
[09:29:16.076]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.076]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.076]                   {
[09:29:16.076]                     inherits <- base::inherits
[09:29:16.076]                     invokeRestart <- base::invokeRestart
[09:29:16.076]                     is.null <- base::is.null
[09:29:16.076]                     muffled <- FALSE
[09:29:16.076]                     if (inherits(cond, "message")) {
[09:29:16.076]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.076]                       if (muffled) 
[09:29:16.076]                         invokeRestart("muffleMessage")
[09:29:16.076]                     }
[09:29:16.076]                     else if (inherits(cond, "warning")) {
[09:29:16.076]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.076]                       if (muffled) 
[09:29:16.076]                         invokeRestart("muffleWarning")
[09:29:16.076]                     }
[09:29:16.076]                     else if (inherits(cond, "condition")) {
[09:29:16.076]                       if (!is.null(pattern)) {
[09:29:16.076]                         computeRestarts <- base::computeRestarts
[09:29:16.076]                         grepl <- base::grepl
[09:29:16.076]                         restarts <- computeRestarts(cond)
[09:29:16.076]                         for (restart in restarts) {
[09:29:16.076]                           name <- restart$name
[09:29:16.076]                           if (is.null(name)) 
[09:29:16.076]                             next
[09:29:16.076]                           if (!grepl(pattern, name)) 
[09:29:16.076]                             next
[09:29:16.076]                           invokeRestart(restart)
[09:29:16.076]                           muffled <- TRUE
[09:29:16.076]                           break
[09:29:16.076]                         }
[09:29:16.076]                       }
[09:29:16.076]                     }
[09:29:16.076]                     invisible(muffled)
[09:29:16.076]                   }
[09:29:16.076]                   muffleCondition(cond)
[09:29:16.076]                 })
[09:29:16.076]             }))
[09:29:16.076]             future::FutureResult(value = ...future.value$value, 
[09:29:16.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.076]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.076]                     ...future.globalenv.names))
[09:29:16.076]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.076]         }, condition = base::local({
[09:29:16.076]             c <- base::c
[09:29:16.076]             inherits <- base::inherits
[09:29:16.076]             invokeRestart <- base::invokeRestart
[09:29:16.076]             length <- base::length
[09:29:16.076]             list <- base::list
[09:29:16.076]             seq.int <- base::seq.int
[09:29:16.076]             signalCondition <- base::signalCondition
[09:29:16.076]             sys.calls <- base::sys.calls
[09:29:16.076]             `[[` <- base::`[[`
[09:29:16.076]             `+` <- base::`+`
[09:29:16.076]             `<<-` <- base::`<<-`
[09:29:16.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.076]                   3L)]
[09:29:16.076]             }
[09:29:16.076]             function(cond) {
[09:29:16.076]                 is_error <- inherits(cond, "error")
[09:29:16.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.076]                   NULL)
[09:29:16.076]                 if (is_error) {
[09:29:16.076]                   sessionInformation <- function() {
[09:29:16.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.076]                       search = base::search(), system = base::Sys.info())
[09:29:16.076]                   }
[09:29:16.076]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.076]                     cond$call), session = sessionInformation(), 
[09:29:16.076]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.076]                   signalCondition(cond)
[09:29:16.076]                 }
[09:29:16.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.076]                 "immediateCondition"))) {
[09:29:16.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.076]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.076]                   if (TRUE && !signal) {
[09:29:16.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.076]                     {
[09:29:16.076]                       inherits <- base::inherits
[09:29:16.076]                       invokeRestart <- base::invokeRestart
[09:29:16.076]                       is.null <- base::is.null
[09:29:16.076]                       muffled <- FALSE
[09:29:16.076]                       if (inherits(cond, "message")) {
[09:29:16.076]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.076]                         if (muffled) 
[09:29:16.076]                           invokeRestart("muffleMessage")
[09:29:16.076]                       }
[09:29:16.076]                       else if (inherits(cond, "warning")) {
[09:29:16.076]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.076]                         if (muffled) 
[09:29:16.076]                           invokeRestart("muffleWarning")
[09:29:16.076]                       }
[09:29:16.076]                       else if (inherits(cond, "condition")) {
[09:29:16.076]                         if (!is.null(pattern)) {
[09:29:16.076]                           computeRestarts <- base::computeRestarts
[09:29:16.076]                           grepl <- base::grepl
[09:29:16.076]                           restarts <- computeRestarts(cond)
[09:29:16.076]                           for (restart in restarts) {
[09:29:16.076]                             name <- restart$name
[09:29:16.076]                             if (is.null(name)) 
[09:29:16.076]                               next
[09:29:16.076]                             if (!grepl(pattern, name)) 
[09:29:16.076]                               next
[09:29:16.076]                             invokeRestart(restart)
[09:29:16.076]                             muffled <- TRUE
[09:29:16.076]                             break
[09:29:16.076]                           }
[09:29:16.076]                         }
[09:29:16.076]                       }
[09:29:16.076]                       invisible(muffled)
[09:29:16.076]                     }
[09:29:16.076]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.076]                   }
[09:29:16.076]                 }
[09:29:16.076]                 else {
[09:29:16.076]                   if (TRUE) {
[09:29:16.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.076]                     {
[09:29:16.076]                       inherits <- base::inherits
[09:29:16.076]                       invokeRestart <- base::invokeRestart
[09:29:16.076]                       is.null <- base::is.null
[09:29:16.076]                       muffled <- FALSE
[09:29:16.076]                       if (inherits(cond, "message")) {
[09:29:16.076]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.076]                         if (muffled) 
[09:29:16.076]                           invokeRestart("muffleMessage")
[09:29:16.076]                       }
[09:29:16.076]                       else if (inherits(cond, "warning")) {
[09:29:16.076]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.076]                         if (muffled) 
[09:29:16.076]                           invokeRestart("muffleWarning")
[09:29:16.076]                       }
[09:29:16.076]                       else if (inherits(cond, "condition")) {
[09:29:16.076]                         if (!is.null(pattern)) {
[09:29:16.076]                           computeRestarts <- base::computeRestarts
[09:29:16.076]                           grepl <- base::grepl
[09:29:16.076]                           restarts <- computeRestarts(cond)
[09:29:16.076]                           for (restart in restarts) {
[09:29:16.076]                             name <- restart$name
[09:29:16.076]                             if (is.null(name)) 
[09:29:16.076]                               next
[09:29:16.076]                             if (!grepl(pattern, name)) 
[09:29:16.076]                               next
[09:29:16.076]                             invokeRestart(restart)
[09:29:16.076]                             muffled <- TRUE
[09:29:16.076]                             break
[09:29:16.076]                           }
[09:29:16.076]                         }
[09:29:16.076]                       }
[09:29:16.076]                       invisible(muffled)
[09:29:16.076]                     }
[09:29:16.076]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.076]                   }
[09:29:16.076]                 }
[09:29:16.076]             }
[09:29:16.076]         }))
[09:29:16.076]     }, error = function(ex) {
[09:29:16.076]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.076]                 ...future.rng), started = ...future.startTime, 
[09:29:16.076]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.076]             version = "1.8"), class = "FutureResult")
[09:29:16.076]     }, finally = {
[09:29:16.076]         if (!identical(...future.workdir, getwd())) 
[09:29:16.076]             setwd(...future.workdir)
[09:29:16.076]         {
[09:29:16.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.076]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.076]             }
[09:29:16.076]             base::options(...future.oldOptions)
[09:29:16.076]             if (.Platform$OS.type == "windows") {
[09:29:16.076]                 old_names <- names(...future.oldEnvVars)
[09:29:16.076]                 envs <- base::Sys.getenv()
[09:29:16.076]                 names <- names(envs)
[09:29:16.076]                 common <- intersect(names, old_names)
[09:29:16.076]                 added <- setdiff(names, old_names)
[09:29:16.076]                 removed <- setdiff(old_names, names)
[09:29:16.076]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.076]                   envs[common]]
[09:29:16.076]                 NAMES <- toupper(changed)
[09:29:16.076]                 args <- list()
[09:29:16.076]                 for (kk in seq_along(NAMES)) {
[09:29:16.076]                   name <- changed[[kk]]
[09:29:16.076]                   NAME <- NAMES[[kk]]
[09:29:16.076]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.076]                     next
[09:29:16.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.076]                 }
[09:29:16.076]                 NAMES <- toupper(added)
[09:29:16.076]                 for (kk in seq_along(NAMES)) {
[09:29:16.076]                   name <- added[[kk]]
[09:29:16.076]                   NAME <- NAMES[[kk]]
[09:29:16.076]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.076]                     next
[09:29:16.076]                   args[[name]] <- ""
[09:29:16.076]                 }
[09:29:16.076]                 NAMES <- toupper(removed)
[09:29:16.076]                 for (kk in seq_along(NAMES)) {
[09:29:16.076]                   name <- removed[[kk]]
[09:29:16.076]                   NAME <- NAMES[[kk]]
[09:29:16.076]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.076]                     next
[09:29:16.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.076]                 }
[09:29:16.076]                 if (length(args) > 0) 
[09:29:16.076]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.076]             }
[09:29:16.076]             else {
[09:29:16.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.076]             }
[09:29:16.076]             {
[09:29:16.076]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.076]                   0L) {
[09:29:16.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.076]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.076]                   base::options(opts)
[09:29:16.076]                 }
[09:29:16.076]                 {
[09:29:16.076]                   {
[09:29:16.076]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.076]                     NULL
[09:29:16.076]                   }
[09:29:16.076]                   options(future.plan = NULL)
[09:29:16.076]                   if (is.na(NA_character_)) 
[09:29:16.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.076]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.076]                     .init = FALSE)
[09:29:16.076]                 }
[09:29:16.076]             }
[09:29:16.076]         }
[09:29:16.076]     })
[09:29:16.076]     if (TRUE) {
[09:29:16.076]         base::sink(type = "output", split = FALSE)
[09:29:16.076]         if (TRUE) {
[09:29:16.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.076]         }
[09:29:16.076]         else {
[09:29:16.076]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.076]         }
[09:29:16.076]         base::close(...future.stdout)
[09:29:16.076]         ...future.stdout <- NULL
[09:29:16.076]     }
[09:29:16.076]     ...future.result$conditions <- ...future.conditions
[09:29:16.076]     ...future.result$finished <- base::Sys.time()
[09:29:16.076]     ...future.result
[09:29:16.076] }
[09:29:16.079] assign_globals() ...
[09:29:16.079] List of 5
[09:29:16.079]  $ ...future.FUN            :function (C, k)  
[09:29:16.079]  $ MoreArgs                 : list()
[09:29:16.079]  $ ...future.elements_ii    :List of 2
[09:29:16.079]   ..$ :List of 2
[09:29:16.079]   .. ..$ : chr "A"
[09:29:16.079]   .. ..$ : chr "B"
[09:29:16.079]   ..$ :List of 2
[09:29:16.079]   .. ..$ : int 5
[09:29:16.079]   .. ..$ : int 4
[09:29:16.079]  $ ...future.seeds_ii       : NULL
[09:29:16.079]  $ ...future.globals.maxSize: NULL
[09:29:16.079]  - attr(*, "where")=List of 5
[09:29:16.079]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.079]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.079]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.079]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.079]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.079]  - attr(*, "resolved")= logi FALSE
[09:29:16.079]  - attr(*, "total_size")= num 3656
[09:29:16.079]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.079]  - attr(*, "already-done")= logi TRUE
[09:29:16.084] - reassign environment for ‘...future.FUN’
[09:29:16.084] - copied ‘...future.FUN’ to environment
[09:29:16.084] - copied ‘MoreArgs’ to environment
[09:29:16.085] - copied ‘...future.elements_ii’ to environment
[09:29:16.085] - copied ‘...future.seeds_ii’ to environment
[09:29:16.085] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.085] assign_globals() ... done
[09:29:16.085] requestCore(): workers = 2
[09:29:16.087] MulticoreFuture started
[09:29:16.087] - Launch lazy future ... done
[09:29:16.088] run() for ‘MulticoreFuture’ ... done
[09:29:16.088] Created future:
[09:29:16.088] plan(): Setting new future strategy stack:
[09:29:16.088] List of future strategies:
[09:29:16.088] 1. sequential:
[09:29:16.088]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.088]    - tweaked: FALSE
[09:29:16.088]    - call: NULL
[09:29:16.089] plan(): nbrOfWorkers() = 1
[09:29:16.092] plan(): Setting new future strategy stack:
[09:29:16.092] List of future strategies:
[09:29:16.092] 1. multicore:
[09:29:16.092]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.092]    - tweaked: FALSE
[09:29:16.092]    - call: plan(strategy)
[09:29:16.097] plan(): nbrOfWorkers() = 2
[09:29:16.088] MulticoreFuture:
[09:29:16.088] Label: ‘future_.mapply-1’
[09:29:16.088] Expression:
[09:29:16.088] {
[09:29:16.088]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.088]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.088]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.088]         on.exit(options(oopts), add = TRUE)
[09:29:16.088]     }
[09:29:16.088]     {
[09:29:16.088]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.088]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.088]         do.call(mapply, args = args)
[09:29:16.088]     }
[09:29:16.088] }
[09:29:16.088] Lazy evaluation: FALSE
[09:29:16.088] Asynchronous evaluation: TRUE
[09:29:16.088] Local evaluation: TRUE
[09:29:16.088] Environment: R_GlobalEnv
[09:29:16.088] Capture standard output: TRUE
[09:29:16.088] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.088] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.088] Packages: <none>
[09:29:16.088] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.088] Resolved: TRUE
[09:29:16.088] Value: <not collected>
[09:29:16.088] Conditions captured: <none>
[09:29:16.088] Early signaling: FALSE
[09:29:16.088] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.088] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.098] Chunk #1 of 2 ... DONE
[09:29:16.098] Chunk #2 of 2 ...
[09:29:16.098]  - Finding globals in '...' for chunk #2 ...
[09:29:16.099] getGlobalsAndPackages() ...
[09:29:16.099] Searching for globals...
[09:29:16.099] 
[09:29:16.099] Searching for globals ... DONE
[09:29:16.100] - globals: [0] <none>
[09:29:16.100] getGlobalsAndPackages() ... DONE
[09:29:16.100]    + additional globals found: [n=0] 
[09:29:16.100]    + additional namespaces needed: [n=0] 
[09:29:16.100]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:16.100]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:16.100]  - seeds: <none>
[09:29:16.101]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.101] getGlobalsAndPackages() ...
[09:29:16.101] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.101] Resolving globals: FALSE
[09:29:16.102] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[09:29:16.103] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:16.103] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.103] 
[09:29:16.103] getGlobalsAndPackages() ... DONE
[09:29:16.104] run() for ‘Future’ ...
[09:29:16.104] - state: ‘created’
[09:29:16.104] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.113] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.114] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.114]   - Field: ‘label’
[09:29:16.114]   - Field: ‘local’
[09:29:16.115]   - Field: ‘owner’
[09:29:16.115]   - Field: ‘envir’
[09:29:16.115]   - Field: ‘workers’
[09:29:16.115]   - Field: ‘packages’
[09:29:16.116]   - Field: ‘gc’
[09:29:16.116]   - Field: ‘job’
[09:29:16.116]   - Field: ‘conditions’
[09:29:16.116]   - Field: ‘expr’
[09:29:16.116]   - Field: ‘uuid’
[09:29:16.117]   - Field: ‘seed’
[09:29:16.117]   - Field: ‘version’
[09:29:16.117]   - Field: ‘result’
[09:29:16.117]   - Field: ‘asynchronous’
[09:29:16.118]   - Field: ‘calls’
[09:29:16.118]   - Field: ‘globals’
[09:29:16.118]   - Field: ‘stdout’
[09:29:16.118]   - Field: ‘earlySignal’
[09:29:16.119]   - Field: ‘lazy’
[09:29:16.119]   - Field: ‘state’
[09:29:16.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.119] - Launch lazy future ...
[09:29:16.120] Packages needed by the future expression (n = 0): <none>
[09:29:16.120] Packages needed by future strategies (n = 0): <none>
[09:29:16.121] {
[09:29:16.121]     {
[09:29:16.121]         {
[09:29:16.121]             ...future.startTime <- base::Sys.time()
[09:29:16.121]             {
[09:29:16.121]                 {
[09:29:16.121]                   {
[09:29:16.121]                     {
[09:29:16.121]                       base::local({
[09:29:16.121]                         has_future <- base::requireNamespace("future", 
[09:29:16.121]                           quietly = TRUE)
[09:29:16.121]                         if (has_future) {
[09:29:16.121]                           ns <- base::getNamespace("future")
[09:29:16.121]                           version <- ns[[".package"]][["version"]]
[09:29:16.121]                           if (is.null(version)) 
[09:29:16.121]                             version <- utils::packageVersion("future")
[09:29:16.121]                         }
[09:29:16.121]                         else {
[09:29:16.121]                           version <- NULL
[09:29:16.121]                         }
[09:29:16.121]                         if (!has_future || version < "1.8.0") {
[09:29:16.121]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.121]                             "", base::R.version$version.string), 
[09:29:16.121]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.121]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.121]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.121]                               "release", "version")], collapse = " "), 
[09:29:16.121]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.121]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.121]                             info)
[09:29:16.121]                           info <- base::paste(info, collapse = "; ")
[09:29:16.121]                           if (!has_future) {
[09:29:16.121]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.121]                               info)
[09:29:16.121]                           }
[09:29:16.121]                           else {
[09:29:16.121]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.121]                               info, version)
[09:29:16.121]                           }
[09:29:16.121]                           base::stop(msg)
[09:29:16.121]                         }
[09:29:16.121]                       })
[09:29:16.121]                     }
[09:29:16.121]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.121]                     base::options(mc.cores = 1L)
[09:29:16.121]                   }
[09:29:16.121]                   ...future.strategy.old <- future::plan("list")
[09:29:16.121]                   options(future.plan = NULL)
[09:29:16.121]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.121]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.121]                 }
[09:29:16.121]                 ...future.workdir <- getwd()
[09:29:16.121]             }
[09:29:16.121]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.121]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.121]         }
[09:29:16.121]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.121]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:16.121]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.121]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.121]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.121]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.121]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.121]             base::names(...future.oldOptions))
[09:29:16.121]     }
[09:29:16.121]     if (FALSE) {
[09:29:16.121]     }
[09:29:16.121]     else {
[09:29:16.121]         if (TRUE) {
[09:29:16.121]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.121]                 open = "w")
[09:29:16.121]         }
[09:29:16.121]         else {
[09:29:16.121]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.121]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.121]         }
[09:29:16.121]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.121]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.121]             base::sink(type = "output", split = FALSE)
[09:29:16.121]             base::close(...future.stdout)
[09:29:16.121]         }, add = TRUE)
[09:29:16.121]     }
[09:29:16.121]     ...future.frame <- base::sys.nframe()
[09:29:16.121]     ...future.conditions <- base::list()
[09:29:16.121]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.121]     if (FALSE) {
[09:29:16.121]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.121]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.121]     }
[09:29:16.121]     ...future.result <- base::tryCatch({
[09:29:16.121]         base::withCallingHandlers({
[09:29:16.121]             ...future.value <- base::withVisible(base::local({
[09:29:16.121]                 withCallingHandlers({
[09:29:16.121]                   {
[09:29:16.121]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.121]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.121]                       ...future.globals.maxSize)) {
[09:29:16.121]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.121]                       on.exit(options(oopts), add = TRUE)
[09:29:16.121]                     }
[09:29:16.121]                     {
[09:29:16.121]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.121]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.121]                         USE.NAMES = FALSE)
[09:29:16.121]                       do.call(mapply, args = args)
[09:29:16.121]                     }
[09:29:16.121]                   }
[09:29:16.121]                 }, immediateCondition = function(cond) {
[09:29:16.121]                   save_rds <- function (object, pathname, ...) 
[09:29:16.121]                   {
[09:29:16.121]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.121]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.121]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.121]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.121]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.121]                         fi_tmp[["mtime"]])
[09:29:16.121]                     }
[09:29:16.121]                     tryCatch({
[09:29:16.121]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.121]                     }, error = function(ex) {
[09:29:16.121]                       msg <- conditionMessage(ex)
[09:29:16.121]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.121]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.121]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.121]                         fi_tmp[["mtime"]], msg)
[09:29:16.121]                       ex$message <- msg
[09:29:16.121]                       stop(ex)
[09:29:16.121]                     })
[09:29:16.121]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.121]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.121]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.121]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.121]                       fi <- file.info(pathname)
[09:29:16.121]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.121]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.121]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.121]                         fi[["size"]], fi[["mtime"]])
[09:29:16.121]                       stop(msg)
[09:29:16.121]                     }
[09:29:16.121]                     invisible(pathname)
[09:29:16.121]                   }
[09:29:16.121]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.121]                     rootPath = tempdir()) 
[09:29:16.121]                   {
[09:29:16.121]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.121]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.121]                       tmpdir = path, fileext = ".rds")
[09:29:16.121]                     save_rds(obj, file)
[09:29:16.121]                   }
[09:29:16.121]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.121]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.121]                   {
[09:29:16.121]                     inherits <- base::inherits
[09:29:16.121]                     invokeRestart <- base::invokeRestart
[09:29:16.121]                     is.null <- base::is.null
[09:29:16.121]                     muffled <- FALSE
[09:29:16.121]                     if (inherits(cond, "message")) {
[09:29:16.121]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.121]                       if (muffled) 
[09:29:16.121]                         invokeRestart("muffleMessage")
[09:29:16.121]                     }
[09:29:16.121]                     else if (inherits(cond, "warning")) {
[09:29:16.121]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.121]                       if (muffled) 
[09:29:16.121]                         invokeRestart("muffleWarning")
[09:29:16.121]                     }
[09:29:16.121]                     else if (inherits(cond, "condition")) {
[09:29:16.121]                       if (!is.null(pattern)) {
[09:29:16.121]                         computeRestarts <- base::computeRestarts
[09:29:16.121]                         grepl <- base::grepl
[09:29:16.121]                         restarts <- computeRestarts(cond)
[09:29:16.121]                         for (restart in restarts) {
[09:29:16.121]                           name <- restart$name
[09:29:16.121]                           if (is.null(name)) 
[09:29:16.121]                             next
[09:29:16.121]                           if (!grepl(pattern, name)) 
[09:29:16.121]                             next
[09:29:16.121]                           invokeRestart(restart)
[09:29:16.121]                           muffled <- TRUE
[09:29:16.121]                           break
[09:29:16.121]                         }
[09:29:16.121]                       }
[09:29:16.121]                     }
[09:29:16.121]                     invisible(muffled)
[09:29:16.121]                   }
[09:29:16.121]                   muffleCondition(cond)
[09:29:16.121]                 })
[09:29:16.121]             }))
[09:29:16.121]             future::FutureResult(value = ...future.value$value, 
[09:29:16.121]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.121]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.121]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.121]                     ...future.globalenv.names))
[09:29:16.121]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.121]         }, condition = base::local({
[09:29:16.121]             c <- base::c
[09:29:16.121]             inherits <- base::inherits
[09:29:16.121]             invokeRestart <- base::invokeRestart
[09:29:16.121]             length <- base::length
[09:29:16.121]             list <- base::list
[09:29:16.121]             seq.int <- base::seq.int
[09:29:16.121]             signalCondition <- base::signalCondition
[09:29:16.121]             sys.calls <- base::sys.calls
[09:29:16.121]             `[[` <- base::`[[`
[09:29:16.121]             `+` <- base::`+`
[09:29:16.121]             `<<-` <- base::`<<-`
[09:29:16.121]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.121]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.121]                   3L)]
[09:29:16.121]             }
[09:29:16.121]             function(cond) {
[09:29:16.121]                 is_error <- inherits(cond, "error")
[09:29:16.121]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.121]                   NULL)
[09:29:16.121]                 if (is_error) {
[09:29:16.121]                   sessionInformation <- function() {
[09:29:16.121]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.121]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.121]                       search = base::search(), system = base::Sys.info())
[09:29:16.121]                   }
[09:29:16.121]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.121]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.121]                     cond$call), session = sessionInformation(), 
[09:29:16.121]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.121]                   signalCondition(cond)
[09:29:16.121]                 }
[09:29:16.121]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.121]                 "immediateCondition"))) {
[09:29:16.121]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.121]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.121]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.121]                   if (TRUE && !signal) {
[09:29:16.121]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.121]                     {
[09:29:16.121]                       inherits <- base::inherits
[09:29:16.121]                       invokeRestart <- base::invokeRestart
[09:29:16.121]                       is.null <- base::is.null
[09:29:16.121]                       muffled <- FALSE
[09:29:16.121]                       if (inherits(cond, "message")) {
[09:29:16.121]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.121]                         if (muffled) 
[09:29:16.121]                           invokeRestart("muffleMessage")
[09:29:16.121]                       }
[09:29:16.121]                       else if (inherits(cond, "warning")) {
[09:29:16.121]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.121]                         if (muffled) 
[09:29:16.121]                           invokeRestart("muffleWarning")
[09:29:16.121]                       }
[09:29:16.121]                       else if (inherits(cond, "condition")) {
[09:29:16.121]                         if (!is.null(pattern)) {
[09:29:16.121]                           computeRestarts <- base::computeRestarts
[09:29:16.121]                           grepl <- base::grepl
[09:29:16.121]                           restarts <- computeRestarts(cond)
[09:29:16.121]                           for (restart in restarts) {
[09:29:16.121]                             name <- restart$name
[09:29:16.121]                             if (is.null(name)) 
[09:29:16.121]                               next
[09:29:16.121]                             if (!grepl(pattern, name)) 
[09:29:16.121]                               next
[09:29:16.121]                             invokeRestart(restart)
[09:29:16.121]                             muffled <- TRUE
[09:29:16.121]                             break
[09:29:16.121]                           }
[09:29:16.121]                         }
[09:29:16.121]                       }
[09:29:16.121]                       invisible(muffled)
[09:29:16.121]                     }
[09:29:16.121]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.121]                   }
[09:29:16.121]                 }
[09:29:16.121]                 else {
[09:29:16.121]                   if (TRUE) {
[09:29:16.121]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.121]                     {
[09:29:16.121]                       inherits <- base::inherits
[09:29:16.121]                       invokeRestart <- base::invokeRestart
[09:29:16.121]                       is.null <- base::is.null
[09:29:16.121]                       muffled <- FALSE
[09:29:16.121]                       if (inherits(cond, "message")) {
[09:29:16.121]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.121]                         if (muffled) 
[09:29:16.121]                           invokeRestart("muffleMessage")
[09:29:16.121]                       }
[09:29:16.121]                       else if (inherits(cond, "warning")) {
[09:29:16.121]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.121]                         if (muffled) 
[09:29:16.121]                           invokeRestart("muffleWarning")
[09:29:16.121]                       }
[09:29:16.121]                       else if (inherits(cond, "condition")) {
[09:29:16.121]                         if (!is.null(pattern)) {
[09:29:16.121]                           computeRestarts <- base::computeRestarts
[09:29:16.121]                           grepl <- base::grepl
[09:29:16.121]                           restarts <- computeRestarts(cond)
[09:29:16.121]                           for (restart in restarts) {
[09:29:16.121]                             name <- restart$name
[09:29:16.121]                             if (is.null(name)) 
[09:29:16.121]                               next
[09:29:16.121]                             if (!grepl(pattern, name)) 
[09:29:16.121]                               next
[09:29:16.121]                             invokeRestart(restart)
[09:29:16.121]                             muffled <- TRUE
[09:29:16.121]                             break
[09:29:16.121]                           }
[09:29:16.121]                         }
[09:29:16.121]                       }
[09:29:16.121]                       invisible(muffled)
[09:29:16.121]                     }
[09:29:16.121]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.121]                   }
[09:29:16.121]                 }
[09:29:16.121]             }
[09:29:16.121]         }))
[09:29:16.121]     }, error = function(ex) {
[09:29:16.121]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.121]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.121]                 ...future.rng), started = ...future.startTime, 
[09:29:16.121]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.121]             version = "1.8"), class = "FutureResult")
[09:29:16.121]     }, finally = {
[09:29:16.121]         if (!identical(...future.workdir, getwd())) 
[09:29:16.121]             setwd(...future.workdir)
[09:29:16.121]         {
[09:29:16.121]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.121]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.121]             }
[09:29:16.121]             base::options(...future.oldOptions)
[09:29:16.121]             if (.Platform$OS.type == "windows") {
[09:29:16.121]                 old_names <- names(...future.oldEnvVars)
[09:29:16.121]                 envs <- base::Sys.getenv()
[09:29:16.121]                 names <- names(envs)
[09:29:16.121]                 common <- intersect(names, old_names)
[09:29:16.121]                 added <- setdiff(names, old_names)
[09:29:16.121]                 removed <- setdiff(old_names, names)
[09:29:16.121]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.121]                   envs[common]]
[09:29:16.121]                 NAMES <- toupper(changed)
[09:29:16.121]                 args <- list()
[09:29:16.121]                 for (kk in seq_along(NAMES)) {
[09:29:16.121]                   name <- changed[[kk]]
[09:29:16.121]                   NAME <- NAMES[[kk]]
[09:29:16.121]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.121]                     next
[09:29:16.121]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.121]                 }
[09:29:16.121]                 NAMES <- toupper(added)
[09:29:16.121]                 for (kk in seq_along(NAMES)) {
[09:29:16.121]                   name <- added[[kk]]
[09:29:16.121]                   NAME <- NAMES[[kk]]
[09:29:16.121]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.121]                     next
[09:29:16.121]                   args[[name]] <- ""
[09:29:16.121]                 }
[09:29:16.121]                 NAMES <- toupper(removed)
[09:29:16.121]                 for (kk in seq_along(NAMES)) {
[09:29:16.121]                   name <- removed[[kk]]
[09:29:16.121]                   NAME <- NAMES[[kk]]
[09:29:16.121]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.121]                     next
[09:29:16.121]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.121]                 }
[09:29:16.121]                 if (length(args) > 0) 
[09:29:16.121]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.121]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.121]             }
[09:29:16.121]             else {
[09:29:16.121]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.121]             }
[09:29:16.121]             {
[09:29:16.121]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.121]                   0L) {
[09:29:16.121]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.121]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.121]                   base::options(opts)
[09:29:16.121]                 }
[09:29:16.121]                 {
[09:29:16.121]                   {
[09:29:16.121]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.121]                     NULL
[09:29:16.121]                   }
[09:29:16.121]                   options(future.plan = NULL)
[09:29:16.121]                   if (is.na(NA_character_)) 
[09:29:16.121]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.121]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.121]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.121]                     .init = FALSE)
[09:29:16.121]                 }
[09:29:16.121]             }
[09:29:16.121]         }
[09:29:16.121]     })
[09:29:16.121]     if (TRUE) {
[09:29:16.121]         base::sink(type = "output", split = FALSE)
[09:29:16.121]         if (TRUE) {
[09:29:16.121]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.121]         }
[09:29:16.121]         else {
[09:29:16.121]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.121]         }
[09:29:16.121]         base::close(...future.stdout)
[09:29:16.121]         ...future.stdout <- NULL
[09:29:16.121]     }
[09:29:16.121]     ...future.result$conditions <- ...future.conditions
[09:29:16.121]     ...future.result$finished <- base::Sys.time()
[09:29:16.121]     ...future.result
[09:29:16.121] }
[09:29:16.124] assign_globals() ...
[09:29:16.124] List of 5
[09:29:16.124]  $ ...future.FUN            :function (C, k)  
[09:29:16.124]  $ MoreArgs                 : list()
[09:29:16.124]  $ ...future.elements_ii    :List of 2
[09:29:16.124]   ..$ :List of 3
[09:29:16.124]   .. ..$ : chr "C"
[09:29:16.124]   .. ..$ : chr "D"
[09:29:16.124]   .. ..$ : chr "E"
[09:29:16.124]   ..$ :List of 3
[09:29:16.124]   .. ..$ : int 3
[09:29:16.124]   .. ..$ : int 2
[09:29:16.124]   .. ..$ : int 1
[09:29:16.124]  $ ...future.seeds_ii       : NULL
[09:29:16.124]  $ ...future.globals.maxSize: NULL
[09:29:16.124]  - attr(*, "where")=List of 5
[09:29:16.124]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.124]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.124]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.124]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.124]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.124]  - attr(*, "resolved")= logi FALSE
[09:29:16.124]  - attr(*, "total_size")= num 3824
[09:29:16.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.124]  - attr(*, "already-done")= logi TRUE
[09:29:16.133] - reassign environment for ‘...future.FUN’
[09:29:16.133] - copied ‘...future.FUN’ to environment
[09:29:16.133] - copied ‘MoreArgs’ to environment
[09:29:16.133] - copied ‘...future.elements_ii’ to environment
[09:29:16.133] - copied ‘...future.seeds_ii’ to environment
[09:29:16.133] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.133] assign_globals() ... done
[09:29:16.134] requestCore(): workers = 2
[09:29:16.136] MulticoreFuture started
[09:29:16.136] - Launch lazy future ... done
[09:29:16.136] run() for ‘MulticoreFuture’ ... done
[09:29:16.137] Created future:
[09:29:16.137] plan(): Setting new future strategy stack:
[09:29:16.137] List of future strategies:
[09:29:16.137] 1. sequential:
[09:29:16.137]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.137]    - tweaked: FALSE
[09:29:16.137]    - call: NULL
[09:29:16.138] plan(): nbrOfWorkers() = 1
[09:29:16.140] plan(): Setting new future strategy stack:
[09:29:16.140] List of future strategies:
[09:29:16.140] 1. multicore:
[09:29:16.140]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.140]    - tweaked: FALSE
[09:29:16.140]    - call: plan(strategy)
[09:29:16.146] plan(): nbrOfWorkers() = 2
[09:29:16.137] MulticoreFuture:
[09:29:16.137] Label: ‘future_.mapply-2’
[09:29:16.137] Expression:
[09:29:16.137] {
[09:29:16.137]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.137]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.137]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.137]         on.exit(options(oopts), add = TRUE)
[09:29:16.137]     }
[09:29:16.137]     {
[09:29:16.137]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.137]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.137]         do.call(mapply, args = args)
[09:29:16.137]     }
[09:29:16.137] }
[09:29:16.137] Lazy evaluation: FALSE
[09:29:16.137] Asynchronous evaluation: TRUE
[09:29:16.137] Local evaluation: TRUE
[09:29:16.137] Environment: R_GlobalEnv
[09:29:16.137] Capture standard output: TRUE
[09:29:16.137] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.137] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.137] Packages: <none>
[09:29:16.137] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.137] Resolved: TRUE
[09:29:16.137] Value: <not collected>
[09:29:16.137] Conditions captured: <none>
[09:29:16.137] Early signaling: FALSE
[09:29:16.137] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.137] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.147] Chunk #2 of 2 ... DONE
[09:29:16.147] Launching 2 futures (chunks) ... DONE
[09:29:16.147] Resolving 2 futures (chunks) ...
[09:29:16.147] resolve() on list ...
[09:29:16.147]  recursive: 0
[09:29:16.147]  length: 2
[09:29:16.148] 
[09:29:16.148] Future #1
[09:29:16.148] result() for MulticoreFuture ...
[09:29:16.149] result() for MulticoreFuture ...
[09:29:16.149] result() for MulticoreFuture ... done
[09:29:16.149] result() for MulticoreFuture ... done
[09:29:16.150] result() for MulticoreFuture ...
[09:29:16.150] result() for MulticoreFuture ... done
[09:29:16.150] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:16.150] - nx: 2
[09:29:16.150] - relay: TRUE
[09:29:16.151] - stdout: TRUE
[09:29:16.151] - signal: TRUE
[09:29:16.151] - resignal: FALSE
[09:29:16.151] - force: TRUE
[09:29:16.151] - relayed: [n=2] FALSE, FALSE
[09:29:16.152] - queued futures: [n=2] FALSE, FALSE
[09:29:16.152]  - until=1
[09:29:16.152]  - relaying element #1
[09:29:16.152] result() for MulticoreFuture ...
[09:29:16.152] result() for MulticoreFuture ... done
[09:29:16.153] result() for MulticoreFuture ...
[09:29:16.153] result() for MulticoreFuture ... done
[09:29:16.153] result() for MulticoreFuture ...
[09:29:16.153] result() for MulticoreFuture ... done
[09:29:16.154] result() for MulticoreFuture ...
[09:29:16.154] result() for MulticoreFuture ... done
[09:29:16.154] - relayed: [n=2] TRUE, FALSE
[09:29:16.154] - queued futures: [n=2] TRUE, FALSE
[09:29:16.154] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:16.154]  length: 1 (resolved future 1)
[09:29:16.155] Future #2
[09:29:16.155] result() for MulticoreFuture ...
[09:29:16.156] result() for MulticoreFuture ...
[09:29:16.156] result() for MulticoreFuture ... done
[09:29:16.156] result() for MulticoreFuture ... done
[09:29:16.156] result() for MulticoreFuture ...
[09:29:16.156] result() for MulticoreFuture ... done
[09:29:16.156] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:16.157] - nx: 2
[09:29:16.157] - relay: TRUE
[09:29:16.157] - stdout: TRUE
[09:29:16.157] - signal: TRUE
[09:29:16.157] - resignal: FALSE
[09:29:16.157] - force: TRUE
[09:29:16.157] - relayed: [n=2] TRUE, FALSE
[09:29:16.158] - queued futures: [n=2] TRUE, FALSE
[09:29:16.158]  - until=2
[09:29:16.158]  - relaying element #2
[09:29:16.158] result() for MulticoreFuture ...
[09:29:16.158] result() for MulticoreFuture ... done
[09:29:16.158] result() for MulticoreFuture ...
[09:29:16.158] result() for MulticoreFuture ... done
[09:29:16.158] result() for MulticoreFuture ...
[09:29:16.159] result() for MulticoreFuture ... done
[09:29:16.159] result() for MulticoreFuture ...
[09:29:16.159] result() for MulticoreFuture ... done
[09:29:16.159] - relayed: [n=2] TRUE, TRUE
[09:29:16.159] - queued futures: [n=2] TRUE, TRUE
[09:29:16.159] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:16.159]  length: 0 (resolved future 2)
[09:29:16.159] Relaying remaining futures
[09:29:16.162] signalConditionsASAP(NULL, pos=0) ...
[09:29:16.162] - nx: 2
[09:29:16.163] - relay: TRUE
[09:29:16.163] - stdout: TRUE
[09:29:16.163] - signal: TRUE
[09:29:16.163] - resignal: FALSE
[09:29:16.163] - force: TRUE
[09:29:16.163] - relayed: [n=2] TRUE, TRUE
[09:29:16.164] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:16.164] - relayed: [n=2] TRUE, TRUE
[09:29:16.164] - queued futures: [n=2] TRUE, TRUE
[09:29:16.164] signalConditionsASAP(NULL, pos=0) ... done
[09:29:16.164] resolve() on list ... DONE
[09:29:16.165] result() for MulticoreFuture ...
[09:29:16.165] result() for MulticoreFuture ... done
[09:29:16.165] result() for MulticoreFuture ...
[09:29:16.165] result() for MulticoreFuture ... done
[09:29:16.165] result() for MulticoreFuture ...
[09:29:16.165] result() for MulticoreFuture ... done
[09:29:16.165] result() for MulticoreFuture ...
[09:29:16.166] result() for MulticoreFuture ... done
[09:29:16.166]  - Number of value chunks collected: 2
[09:29:16.166] Resolving 2 futures (chunks) ... DONE
[09:29:16.166] Reducing values from 2 chunks ...
[09:29:16.166]  - Number of values collected after concatenation: 5
[09:29:16.166]  - Number of values expected: 5
[09:29:16.166] Reducing values from 2 chunks ... DONE
[09:29:16.167] future_mapply() ... DONE
[09:29:16.167] future_mapply() ...
[09:29:16.171] Number of chunks: 3
[09:29:16.171] Index remapping (attribute 'ordering'): [n = 5] 1, 5, 4, 2, 3
[09:29:16.172] getGlobalsAndPackagesXApply() ...
[09:29:16.172]  - future.globals: TRUE
[09:29:16.172] getGlobalsAndPackages() ...
[09:29:16.172] Searching for globals...
[09:29:16.173] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:16.174] Searching for globals ... DONE
[09:29:16.174] Resolving globals: FALSE
[09:29:16.174] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:16.175] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:16.175] - globals: [1] ‘FUN’
[09:29:16.175] 
[09:29:16.175] getGlobalsAndPackages() ... DONE
[09:29:16.175]  - globals found/used: [n=1] ‘FUN’
[09:29:16.175]  - needed namespaces: [n=0] 
[09:29:16.175] Finding globals ... DONE
[09:29:16.176] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:16.176] List of 2
[09:29:16.176]  $ ...future.FUN:function (C, k)  
[09:29:16.176]  $ MoreArgs     : NULL
[09:29:16.176]  - attr(*, "where")=List of 2
[09:29:16.176]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:16.176]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:16.176]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.176]  - attr(*, "resolved")= logi FALSE
[09:29:16.176]  - attr(*, "total_size")= num NA
[09:29:16.178] Packages to be attached in all futures: [n=0] 
[09:29:16.179] getGlobalsAndPackagesXApply() ... DONE
[09:29:16.179] Number of futures (= number of chunks): 3
[09:29:16.179] Launching 3 futures (chunks) ...
[09:29:16.179] Chunk #1 of 3 ...
[09:29:16.179]  - Finding globals in '...' for chunk #1 ...
[09:29:16.179] getGlobalsAndPackages() ...
[09:29:16.179] Searching for globals...
[09:29:16.180] 
[09:29:16.180] Searching for globals ... DONE
[09:29:16.180] - globals: [0] <none>
[09:29:16.180] getGlobalsAndPackages() ... DONE
[09:29:16.180]    + additional globals found: [n=0] 
[09:29:16.180]    + additional namespaces needed: [n=0] 
[09:29:16.180]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:16.180]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[09:29:16.180]  - seeds: <none>
[09:29:16.181]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.181] getGlobalsAndPackages() ...
[09:29:16.181] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.181] Resolving globals: FALSE
[09:29:16.181] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:16.182] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:16.182] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.182] 
[09:29:16.182] getGlobalsAndPackages() ... DONE
[09:29:16.182] run() for ‘Future’ ...
[09:29:16.183] - state: ‘created’
[09:29:16.183] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.186] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.187] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.187]   - Field: ‘label’
[09:29:16.187]   - Field: ‘local’
[09:29:16.187]   - Field: ‘owner’
[09:29:16.187]   - Field: ‘envir’
[09:29:16.187]   - Field: ‘workers’
[09:29:16.187]   - Field: ‘packages’
[09:29:16.187]   - Field: ‘gc’
[09:29:16.187]   - Field: ‘job’
[09:29:16.187]   - Field: ‘conditions’
[09:29:16.188]   - Field: ‘expr’
[09:29:16.188]   - Field: ‘uuid’
[09:29:16.188]   - Field: ‘seed’
[09:29:16.188]   - Field: ‘version’
[09:29:16.188]   - Field: ‘result’
[09:29:16.188]   - Field: ‘asynchronous’
[09:29:16.188]   - Field: ‘calls’
[09:29:16.188]   - Field: ‘globals’
[09:29:16.188]   - Field: ‘stdout’
[09:29:16.188]   - Field: ‘earlySignal’
[09:29:16.188]   - Field: ‘lazy’
[09:29:16.189]   - Field: ‘state’
[09:29:16.189] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.189] - Launch lazy future ...
[09:29:16.189] Packages needed by the future expression (n = 0): <none>
[09:29:16.189] Packages needed by future strategies (n = 0): <none>
[09:29:16.190] {
[09:29:16.190]     {
[09:29:16.190]         {
[09:29:16.190]             ...future.startTime <- base::Sys.time()
[09:29:16.190]             {
[09:29:16.190]                 {
[09:29:16.190]                   {
[09:29:16.190]                     {
[09:29:16.190]                       base::local({
[09:29:16.190]                         has_future <- base::requireNamespace("future", 
[09:29:16.190]                           quietly = TRUE)
[09:29:16.190]                         if (has_future) {
[09:29:16.190]                           ns <- base::getNamespace("future")
[09:29:16.190]                           version <- ns[[".package"]][["version"]]
[09:29:16.190]                           if (is.null(version)) 
[09:29:16.190]                             version <- utils::packageVersion("future")
[09:29:16.190]                         }
[09:29:16.190]                         else {
[09:29:16.190]                           version <- NULL
[09:29:16.190]                         }
[09:29:16.190]                         if (!has_future || version < "1.8.0") {
[09:29:16.190]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.190]                             "", base::R.version$version.string), 
[09:29:16.190]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.190]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.190]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.190]                               "release", "version")], collapse = " "), 
[09:29:16.190]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.190]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.190]                             info)
[09:29:16.190]                           info <- base::paste(info, collapse = "; ")
[09:29:16.190]                           if (!has_future) {
[09:29:16.190]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.190]                               info)
[09:29:16.190]                           }
[09:29:16.190]                           else {
[09:29:16.190]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.190]                               info, version)
[09:29:16.190]                           }
[09:29:16.190]                           base::stop(msg)
[09:29:16.190]                         }
[09:29:16.190]                       })
[09:29:16.190]                     }
[09:29:16.190]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.190]                     base::options(mc.cores = 1L)
[09:29:16.190]                   }
[09:29:16.190]                   ...future.strategy.old <- future::plan("list")
[09:29:16.190]                   options(future.plan = NULL)
[09:29:16.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.190]                 }
[09:29:16.190]                 ...future.workdir <- getwd()
[09:29:16.190]             }
[09:29:16.190]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.190]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.190]         }
[09:29:16.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.190]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[09:29:16.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.190]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.190]             base::names(...future.oldOptions))
[09:29:16.190]     }
[09:29:16.190]     if (FALSE) {
[09:29:16.190]     }
[09:29:16.190]     else {
[09:29:16.190]         if (TRUE) {
[09:29:16.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.190]                 open = "w")
[09:29:16.190]         }
[09:29:16.190]         else {
[09:29:16.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.190]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.190]         }
[09:29:16.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.190]             base::sink(type = "output", split = FALSE)
[09:29:16.190]             base::close(...future.stdout)
[09:29:16.190]         }, add = TRUE)
[09:29:16.190]     }
[09:29:16.190]     ...future.frame <- base::sys.nframe()
[09:29:16.190]     ...future.conditions <- base::list()
[09:29:16.190]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.190]     if (FALSE) {
[09:29:16.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.190]     }
[09:29:16.190]     ...future.result <- base::tryCatch({
[09:29:16.190]         base::withCallingHandlers({
[09:29:16.190]             ...future.value <- base::withVisible(base::local({
[09:29:16.190]                 withCallingHandlers({
[09:29:16.190]                   {
[09:29:16.190]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.190]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.190]                       ...future.globals.maxSize)) {
[09:29:16.190]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.190]                       on.exit(options(oopts), add = TRUE)
[09:29:16.190]                     }
[09:29:16.190]                     {
[09:29:16.190]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.190]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.190]                         USE.NAMES = FALSE)
[09:29:16.190]                       do.call(mapply, args = args)
[09:29:16.190]                     }
[09:29:16.190]                   }
[09:29:16.190]                 }, immediateCondition = function(cond) {
[09:29:16.190]                   save_rds <- function (object, pathname, ...) 
[09:29:16.190]                   {
[09:29:16.190]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.190]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.190]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.190]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.190]                         fi_tmp[["mtime"]])
[09:29:16.190]                     }
[09:29:16.190]                     tryCatch({
[09:29:16.190]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.190]                     }, error = function(ex) {
[09:29:16.190]                       msg <- conditionMessage(ex)
[09:29:16.190]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.190]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.190]                         fi_tmp[["mtime"]], msg)
[09:29:16.190]                       ex$message <- msg
[09:29:16.190]                       stop(ex)
[09:29:16.190]                     })
[09:29:16.190]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.190]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.190]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.190]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.190]                       fi <- file.info(pathname)
[09:29:16.190]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.190]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.190]                         fi[["size"]], fi[["mtime"]])
[09:29:16.190]                       stop(msg)
[09:29:16.190]                     }
[09:29:16.190]                     invisible(pathname)
[09:29:16.190]                   }
[09:29:16.190]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.190]                     rootPath = tempdir()) 
[09:29:16.190]                   {
[09:29:16.190]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.190]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.190]                       tmpdir = path, fileext = ".rds")
[09:29:16.190]                     save_rds(obj, file)
[09:29:16.190]                   }
[09:29:16.190]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.190]                   {
[09:29:16.190]                     inherits <- base::inherits
[09:29:16.190]                     invokeRestart <- base::invokeRestart
[09:29:16.190]                     is.null <- base::is.null
[09:29:16.190]                     muffled <- FALSE
[09:29:16.190]                     if (inherits(cond, "message")) {
[09:29:16.190]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.190]                       if (muffled) 
[09:29:16.190]                         invokeRestart("muffleMessage")
[09:29:16.190]                     }
[09:29:16.190]                     else if (inherits(cond, "warning")) {
[09:29:16.190]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.190]                       if (muffled) 
[09:29:16.190]                         invokeRestart("muffleWarning")
[09:29:16.190]                     }
[09:29:16.190]                     else if (inherits(cond, "condition")) {
[09:29:16.190]                       if (!is.null(pattern)) {
[09:29:16.190]                         computeRestarts <- base::computeRestarts
[09:29:16.190]                         grepl <- base::grepl
[09:29:16.190]                         restarts <- computeRestarts(cond)
[09:29:16.190]                         for (restart in restarts) {
[09:29:16.190]                           name <- restart$name
[09:29:16.190]                           if (is.null(name)) 
[09:29:16.190]                             next
[09:29:16.190]                           if (!grepl(pattern, name)) 
[09:29:16.190]                             next
[09:29:16.190]                           invokeRestart(restart)
[09:29:16.190]                           muffled <- TRUE
[09:29:16.190]                           break
[09:29:16.190]                         }
[09:29:16.190]                       }
[09:29:16.190]                     }
[09:29:16.190]                     invisible(muffled)
[09:29:16.190]                   }
[09:29:16.190]                   muffleCondition(cond)
[09:29:16.190]                 })
[09:29:16.190]             }))
[09:29:16.190]             future::FutureResult(value = ...future.value$value, 
[09:29:16.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.190]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.190]                     ...future.globalenv.names))
[09:29:16.190]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.190]         }, condition = base::local({
[09:29:16.190]             c <- base::c
[09:29:16.190]             inherits <- base::inherits
[09:29:16.190]             invokeRestart <- base::invokeRestart
[09:29:16.190]             length <- base::length
[09:29:16.190]             list <- base::list
[09:29:16.190]             seq.int <- base::seq.int
[09:29:16.190]             signalCondition <- base::signalCondition
[09:29:16.190]             sys.calls <- base::sys.calls
[09:29:16.190]             `[[` <- base::`[[`
[09:29:16.190]             `+` <- base::`+`
[09:29:16.190]             `<<-` <- base::`<<-`
[09:29:16.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.190]                   3L)]
[09:29:16.190]             }
[09:29:16.190]             function(cond) {
[09:29:16.190]                 is_error <- inherits(cond, "error")
[09:29:16.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.190]                   NULL)
[09:29:16.190]                 if (is_error) {
[09:29:16.190]                   sessionInformation <- function() {
[09:29:16.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.190]                       search = base::search(), system = base::Sys.info())
[09:29:16.190]                   }
[09:29:16.190]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.190]                     cond$call), session = sessionInformation(), 
[09:29:16.190]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.190]                   signalCondition(cond)
[09:29:16.190]                 }
[09:29:16.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.190]                 "immediateCondition"))) {
[09:29:16.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.190]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.190]                   if (TRUE && !signal) {
[09:29:16.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.190]                     {
[09:29:16.190]                       inherits <- base::inherits
[09:29:16.190]                       invokeRestart <- base::invokeRestart
[09:29:16.190]                       is.null <- base::is.null
[09:29:16.190]                       muffled <- FALSE
[09:29:16.190]                       if (inherits(cond, "message")) {
[09:29:16.190]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.190]                         if (muffled) 
[09:29:16.190]                           invokeRestart("muffleMessage")
[09:29:16.190]                       }
[09:29:16.190]                       else if (inherits(cond, "warning")) {
[09:29:16.190]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.190]                         if (muffled) 
[09:29:16.190]                           invokeRestart("muffleWarning")
[09:29:16.190]                       }
[09:29:16.190]                       else if (inherits(cond, "condition")) {
[09:29:16.190]                         if (!is.null(pattern)) {
[09:29:16.190]                           computeRestarts <- base::computeRestarts
[09:29:16.190]                           grepl <- base::grepl
[09:29:16.190]                           restarts <- computeRestarts(cond)
[09:29:16.190]                           for (restart in restarts) {
[09:29:16.190]                             name <- restart$name
[09:29:16.190]                             if (is.null(name)) 
[09:29:16.190]                               next
[09:29:16.190]                             if (!grepl(pattern, name)) 
[09:29:16.190]                               next
[09:29:16.190]                             invokeRestart(restart)
[09:29:16.190]                             muffled <- TRUE
[09:29:16.190]                             break
[09:29:16.190]                           }
[09:29:16.190]                         }
[09:29:16.190]                       }
[09:29:16.190]                       invisible(muffled)
[09:29:16.190]                     }
[09:29:16.190]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.190]                   }
[09:29:16.190]                 }
[09:29:16.190]                 else {
[09:29:16.190]                   if (TRUE) {
[09:29:16.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.190]                     {
[09:29:16.190]                       inherits <- base::inherits
[09:29:16.190]                       invokeRestart <- base::invokeRestart
[09:29:16.190]                       is.null <- base::is.null
[09:29:16.190]                       muffled <- FALSE
[09:29:16.190]                       if (inherits(cond, "message")) {
[09:29:16.190]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.190]                         if (muffled) 
[09:29:16.190]                           invokeRestart("muffleMessage")
[09:29:16.190]                       }
[09:29:16.190]                       else if (inherits(cond, "warning")) {
[09:29:16.190]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.190]                         if (muffled) 
[09:29:16.190]                           invokeRestart("muffleWarning")
[09:29:16.190]                       }
[09:29:16.190]                       else if (inherits(cond, "condition")) {
[09:29:16.190]                         if (!is.null(pattern)) {
[09:29:16.190]                           computeRestarts <- base::computeRestarts
[09:29:16.190]                           grepl <- base::grepl
[09:29:16.190]                           restarts <- computeRestarts(cond)
[09:29:16.190]                           for (restart in restarts) {
[09:29:16.190]                             name <- restart$name
[09:29:16.190]                             if (is.null(name)) 
[09:29:16.190]                               next
[09:29:16.190]                             if (!grepl(pattern, name)) 
[09:29:16.190]                               next
[09:29:16.190]                             invokeRestart(restart)
[09:29:16.190]                             muffled <- TRUE
[09:29:16.190]                             break
[09:29:16.190]                           }
[09:29:16.190]                         }
[09:29:16.190]                       }
[09:29:16.190]                       invisible(muffled)
[09:29:16.190]                     }
[09:29:16.190]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.190]                   }
[09:29:16.190]                 }
[09:29:16.190]             }
[09:29:16.190]         }))
[09:29:16.190]     }, error = function(ex) {
[09:29:16.190]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.190]                 ...future.rng), started = ...future.startTime, 
[09:29:16.190]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.190]             version = "1.8"), class = "FutureResult")
[09:29:16.190]     }, finally = {
[09:29:16.190]         if (!identical(...future.workdir, getwd())) 
[09:29:16.190]             setwd(...future.workdir)
[09:29:16.190]         {
[09:29:16.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.190]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.190]             }
[09:29:16.190]             base::options(...future.oldOptions)
[09:29:16.190]             if (.Platform$OS.type == "windows") {
[09:29:16.190]                 old_names <- names(...future.oldEnvVars)
[09:29:16.190]                 envs <- base::Sys.getenv()
[09:29:16.190]                 names <- names(envs)
[09:29:16.190]                 common <- intersect(names, old_names)
[09:29:16.190]                 added <- setdiff(names, old_names)
[09:29:16.190]                 removed <- setdiff(old_names, names)
[09:29:16.190]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.190]                   envs[common]]
[09:29:16.190]                 NAMES <- toupper(changed)
[09:29:16.190]                 args <- list()
[09:29:16.190]                 for (kk in seq_along(NAMES)) {
[09:29:16.190]                   name <- changed[[kk]]
[09:29:16.190]                   NAME <- NAMES[[kk]]
[09:29:16.190]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.190]                     next
[09:29:16.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.190]                 }
[09:29:16.190]                 NAMES <- toupper(added)
[09:29:16.190]                 for (kk in seq_along(NAMES)) {
[09:29:16.190]                   name <- added[[kk]]
[09:29:16.190]                   NAME <- NAMES[[kk]]
[09:29:16.190]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.190]                     next
[09:29:16.190]                   args[[name]] <- ""
[09:29:16.190]                 }
[09:29:16.190]                 NAMES <- toupper(removed)
[09:29:16.190]                 for (kk in seq_along(NAMES)) {
[09:29:16.190]                   name <- removed[[kk]]
[09:29:16.190]                   NAME <- NAMES[[kk]]
[09:29:16.190]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.190]                     next
[09:29:16.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.190]                 }
[09:29:16.190]                 if (length(args) > 0) 
[09:29:16.190]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.190]             }
[09:29:16.190]             else {
[09:29:16.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.190]             }
[09:29:16.190]             {
[09:29:16.190]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.190]                   0L) {
[09:29:16.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.190]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.190]                   base::options(opts)
[09:29:16.190]                 }
[09:29:16.190]                 {
[09:29:16.190]                   {
[09:29:16.190]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.190]                     NULL
[09:29:16.190]                   }
[09:29:16.190]                   options(future.plan = NULL)
[09:29:16.190]                   if (is.na(NA_character_)) 
[09:29:16.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.190]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.190]                     .init = FALSE)
[09:29:16.190]                 }
[09:29:16.190]             }
[09:29:16.190]         }
[09:29:16.190]     })
[09:29:16.190]     if (TRUE) {
[09:29:16.190]         base::sink(type = "output", split = FALSE)
[09:29:16.190]         if (TRUE) {
[09:29:16.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.190]         }
[09:29:16.190]         else {
[09:29:16.190]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.190]         }
[09:29:16.190]         base::close(...future.stdout)
[09:29:16.190]         ...future.stdout <- NULL
[09:29:16.190]     }
[09:29:16.190]     ...future.result$conditions <- ...future.conditions
[09:29:16.190]     ...future.result$finished <- base::Sys.time()
[09:29:16.190]     ...future.result
[09:29:16.190] }
[09:29:16.192] assign_globals() ...
[09:29:16.192] List of 5
[09:29:16.192]  $ ...future.FUN            :function (C, k)  
[09:29:16.192]  $ MoreArgs                 : NULL
[09:29:16.192]  $ ...future.elements_ii    :List of 2
[09:29:16.192]   ..$ :List of 2
[09:29:16.192]   .. ..$ : chr "A"
[09:29:16.192]   .. ..$ : chr "E"
[09:29:16.192]   ..$ :List of 2
[09:29:16.192]   .. ..$ : int 5
[09:29:16.192]   .. ..$ : int 1
[09:29:16.192]  $ ...future.seeds_ii       : NULL
[09:29:16.192]  $ ...future.globals.maxSize: NULL
[09:29:16.192]  - attr(*, "where")=List of 5
[09:29:16.192]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.192]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.192]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.192]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.192]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.192]  - attr(*, "resolved")= logi FALSE
[09:29:16.192]  - attr(*, "total_size")= num 3656
[09:29:16.192]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.192]  - attr(*, "already-done")= logi TRUE
[09:29:16.200] - reassign environment for ‘...future.FUN’
[09:29:16.200] - copied ‘...future.FUN’ to environment
[09:29:16.200] - copied ‘MoreArgs’ to environment
[09:29:16.200] - copied ‘...future.elements_ii’ to environment
[09:29:16.200] - copied ‘...future.seeds_ii’ to environment
[09:29:16.200] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.201] assign_globals() ... done
[09:29:16.201] requestCore(): workers = 2
[09:29:16.203] MulticoreFuture started
[09:29:16.203] - Launch lazy future ... done
[09:29:16.204] run() for ‘MulticoreFuture’ ... done
[09:29:16.204] plan(): Setting new future strategy stack:
[09:29:16.204] Created future:
[09:29:16.204] List of future strategies:
[09:29:16.204] 1. sequential:
[09:29:16.204]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.204]    - tweaked: FALSE
[09:29:16.204]    - call: NULL
[09:29:16.206] plan(): nbrOfWorkers() = 1
[09:29:16.208] plan(): Setting new future strategy stack:
[09:29:16.208] List of future strategies:
[09:29:16.208] 1. multicore:
[09:29:16.208]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.208]    - tweaked: FALSE
[09:29:16.208]    - call: plan(strategy)
[09:29:16.214] plan(): nbrOfWorkers() = 2
[09:29:16.204] MulticoreFuture:
[09:29:16.204] Label: ‘future_mapply-1’
[09:29:16.204] Expression:
[09:29:16.204] {
[09:29:16.204]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.204]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.204]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.204]         on.exit(options(oopts), add = TRUE)
[09:29:16.204]     }
[09:29:16.204]     {
[09:29:16.204]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.204]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.204]         do.call(mapply, args = args)
[09:29:16.204]     }
[09:29:16.204] }
[09:29:16.204] Lazy evaluation: FALSE
[09:29:16.204] Asynchronous evaluation: TRUE
[09:29:16.204] Local evaluation: TRUE
[09:29:16.204] Environment: R_GlobalEnv
[09:29:16.204] Capture standard output: TRUE
[09:29:16.204] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.204] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.204] Packages: <none>
[09:29:16.204] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.204] Resolved: TRUE
[09:29:16.204] Value: <not collected>
[09:29:16.204] Conditions captured: <none>
[09:29:16.204] Early signaling: FALSE
[09:29:16.204] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.204] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.215] Chunk #1 of 3 ... DONE
[09:29:16.215] Chunk #2 of 3 ...
[09:29:16.216]  - Finding globals in '...' for chunk #2 ...
[09:29:16.216] getGlobalsAndPackages() ...
[09:29:16.216] Searching for globals...
[09:29:16.216] 
[09:29:16.217] Searching for globals ... DONE
[09:29:16.217] - globals: [0] <none>
[09:29:16.217] getGlobalsAndPackages() ... DONE
[09:29:16.217]    + additional globals found: [n=0] 
[09:29:16.217]    + additional namespaces needed: [n=0] 
[09:29:16.217]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:16.217]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[09:29:16.218]  - seeds: <none>
[09:29:16.218]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.218] getGlobalsAndPackages() ...
[09:29:16.218] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.218] Resolving globals: FALSE
[09:29:16.219] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:16.220] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:16.220] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.220] 
[09:29:16.220] getGlobalsAndPackages() ... DONE
[09:29:16.221] run() for ‘Future’ ...
[09:29:16.221] - state: ‘created’
[09:29:16.221] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.226] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.226] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.226]   - Field: ‘label’
[09:29:16.226]   - Field: ‘local’
[09:29:16.226]   - Field: ‘owner’
[09:29:16.226]   - Field: ‘envir’
[09:29:16.227]   - Field: ‘workers’
[09:29:16.227]   - Field: ‘packages’
[09:29:16.227]   - Field: ‘gc’
[09:29:16.227]   - Field: ‘job’
[09:29:16.227]   - Field: ‘conditions’
[09:29:16.227]   - Field: ‘expr’
[09:29:16.227]   - Field: ‘uuid’
[09:29:16.227]   - Field: ‘seed’
[09:29:16.228]   - Field: ‘version’
[09:29:16.228]   - Field: ‘result’
[09:29:16.228]   - Field: ‘asynchronous’
[09:29:16.228]   - Field: ‘calls’
[09:29:16.228]   - Field: ‘globals’
[09:29:16.228]   - Field: ‘stdout’
[09:29:16.228]   - Field: ‘earlySignal’
[09:29:16.229]   - Field: ‘lazy’
[09:29:16.229]   - Field: ‘state’
[09:29:16.229] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.229] - Launch lazy future ...
[09:29:16.229] Packages needed by the future expression (n = 0): <none>
[09:29:16.230] Packages needed by future strategies (n = 0): <none>
[09:29:16.230] {
[09:29:16.230]     {
[09:29:16.230]         {
[09:29:16.230]             ...future.startTime <- base::Sys.time()
[09:29:16.230]             {
[09:29:16.230]                 {
[09:29:16.230]                   {
[09:29:16.230]                     {
[09:29:16.230]                       base::local({
[09:29:16.230]                         has_future <- base::requireNamespace("future", 
[09:29:16.230]                           quietly = TRUE)
[09:29:16.230]                         if (has_future) {
[09:29:16.230]                           ns <- base::getNamespace("future")
[09:29:16.230]                           version <- ns[[".package"]][["version"]]
[09:29:16.230]                           if (is.null(version)) 
[09:29:16.230]                             version <- utils::packageVersion("future")
[09:29:16.230]                         }
[09:29:16.230]                         else {
[09:29:16.230]                           version <- NULL
[09:29:16.230]                         }
[09:29:16.230]                         if (!has_future || version < "1.8.0") {
[09:29:16.230]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.230]                             "", base::R.version$version.string), 
[09:29:16.230]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.230]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.230]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.230]                               "release", "version")], collapse = " "), 
[09:29:16.230]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.230]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.230]                             info)
[09:29:16.230]                           info <- base::paste(info, collapse = "; ")
[09:29:16.230]                           if (!has_future) {
[09:29:16.230]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.230]                               info)
[09:29:16.230]                           }
[09:29:16.230]                           else {
[09:29:16.230]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.230]                               info, version)
[09:29:16.230]                           }
[09:29:16.230]                           base::stop(msg)
[09:29:16.230]                         }
[09:29:16.230]                       })
[09:29:16.230]                     }
[09:29:16.230]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.230]                     base::options(mc.cores = 1L)
[09:29:16.230]                   }
[09:29:16.230]                   ...future.strategy.old <- future::plan("list")
[09:29:16.230]                   options(future.plan = NULL)
[09:29:16.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.230]                 }
[09:29:16.230]                 ...future.workdir <- getwd()
[09:29:16.230]             }
[09:29:16.230]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.230]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.230]         }
[09:29:16.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.230]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[09:29:16.230]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.230]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.230]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.230]             base::names(...future.oldOptions))
[09:29:16.230]     }
[09:29:16.230]     if (FALSE) {
[09:29:16.230]     }
[09:29:16.230]     else {
[09:29:16.230]         if (TRUE) {
[09:29:16.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.230]                 open = "w")
[09:29:16.230]         }
[09:29:16.230]         else {
[09:29:16.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.230]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.230]         }
[09:29:16.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.230]             base::sink(type = "output", split = FALSE)
[09:29:16.230]             base::close(...future.stdout)
[09:29:16.230]         }, add = TRUE)
[09:29:16.230]     }
[09:29:16.230]     ...future.frame <- base::sys.nframe()
[09:29:16.230]     ...future.conditions <- base::list()
[09:29:16.230]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.230]     if (FALSE) {
[09:29:16.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.230]     }
[09:29:16.230]     ...future.result <- base::tryCatch({
[09:29:16.230]         base::withCallingHandlers({
[09:29:16.230]             ...future.value <- base::withVisible(base::local({
[09:29:16.230]                 withCallingHandlers({
[09:29:16.230]                   {
[09:29:16.230]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.230]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.230]                       ...future.globals.maxSize)) {
[09:29:16.230]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.230]                       on.exit(options(oopts), add = TRUE)
[09:29:16.230]                     }
[09:29:16.230]                     {
[09:29:16.230]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.230]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.230]                         USE.NAMES = FALSE)
[09:29:16.230]                       do.call(mapply, args = args)
[09:29:16.230]                     }
[09:29:16.230]                   }
[09:29:16.230]                 }, immediateCondition = function(cond) {
[09:29:16.230]                   save_rds <- function (object, pathname, ...) 
[09:29:16.230]                   {
[09:29:16.230]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.230]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.230]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.230]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.230]                         fi_tmp[["mtime"]])
[09:29:16.230]                     }
[09:29:16.230]                     tryCatch({
[09:29:16.230]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.230]                     }, error = function(ex) {
[09:29:16.230]                       msg <- conditionMessage(ex)
[09:29:16.230]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.230]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.230]                         fi_tmp[["mtime"]], msg)
[09:29:16.230]                       ex$message <- msg
[09:29:16.230]                       stop(ex)
[09:29:16.230]                     })
[09:29:16.230]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.230]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.230]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.230]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.230]                       fi <- file.info(pathname)
[09:29:16.230]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.230]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.230]                         fi[["size"]], fi[["mtime"]])
[09:29:16.230]                       stop(msg)
[09:29:16.230]                     }
[09:29:16.230]                     invisible(pathname)
[09:29:16.230]                   }
[09:29:16.230]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.230]                     rootPath = tempdir()) 
[09:29:16.230]                   {
[09:29:16.230]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.230]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.230]                       tmpdir = path, fileext = ".rds")
[09:29:16.230]                     save_rds(obj, file)
[09:29:16.230]                   }
[09:29:16.230]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.230]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.230]                   {
[09:29:16.230]                     inherits <- base::inherits
[09:29:16.230]                     invokeRestart <- base::invokeRestart
[09:29:16.230]                     is.null <- base::is.null
[09:29:16.230]                     muffled <- FALSE
[09:29:16.230]                     if (inherits(cond, "message")) {
[09:29:16.230]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.230]                       if (muffled) 
[09:29:16.230]                         invokeRestart("muffleMessage")
[09:29:16.230]                     }
[09:29:16.230]                     else if (inherits(cond, "warning")) {
[09:29:16.230]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.230]                       if (muffled) 
[09:29:16.230]                         invokeRestart("muffleWarning")
[09:29:16.230]                     }
[09:29:16.230]                     else if (inherits(cond, "condition")) {
[09:29:16.230]                       if (!is.null(pattern)) {
[09:29:16.230]                         computeRestarts <- base::computeRestarts
[09:29:16.230]                         grepl <- base::grepl
[09:29:16.230]                         restarts <- computeRestarts(cond)
[09:29:16.230]                         for (restart in restarts) {
[09:29:16.230]                           name <- restart$name
[09:29:16.230]                           if (is.null(name)) 
[09:29:16.230]                             next
[09:29:16.230]                           if (!grepl(pattern, name)) 
[09:29:16.230]                             next
[09:29:16.230]                           invokeRestart(restart)
[09:29:16.230]                           muffled <- TRUE
[09:29:16.230]                           break
[09:29:16.230]                         }
[09:29:16.230]                       }
[09:29:16.230]                     }
[09:29:16.230]                     invisible(muffled)
[09:29:16.230]                   }
[09:29:16.230]                   muffleCondition(cond)
[09:29:16.230]                 })
[09:29:16.230]             }))
[09:29:16.230]             future::FutureResult(value = ...future.value$value, 
[09:29:16.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.230]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.230]                     ...future.globalenv.names))
[09:29:16.230]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.230]         }, condition = base::local({
[09:29:16.230]             c <- base::c
[09:29:16.230]             inherits <- base::inherits
[09:29:16.230]             invokeRestart <- base::invokeRestart
[09:29:16.230]             length <- base::length
[09:29:16.230]             list <- base::list
[09:29:16.230]             seq.int <- base::seq.int
[09:29:16.230]             signalCondition <- base::signalCondition
[09:29:16.230]             sys.calls <- base::sys.calls
[09:29:16.230]             `[[` <- base::`[[`
[09:29:16.230]             `+` <- base::`+`
[09:29:16.230]             `<<-` <- base::`<<-`
[09:29:16.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.230]                   3L)]
[09:29:16.230]             }
[09:29:16.230]             function(cond) {
[09:29:16.230]                 is_error <- inherits(cond, "error")
[09:29:16.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.230]                   NULL)
[09:29:16.230]                 if (is_error) {
[09:29:16.230]                   sessionInformation <- function() {
[09:29:16.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.230]                       search = base::search(), system = base::Sys.info())
[09:29:16.230]                   }
[09:29:16.230]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.230]                     cond$call), session = sessionInformation(), 
[09:29:16.230]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.230]                   signalCondition(cond)
[09:29:16.230]                 }
[09:29:16.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.230]                 "immediateCondition"))) {
[09:29:16.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.230]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.230]                   if (TRUE && !signal) {
[09:29:16.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.230]                     {
[09:29:16.230]                       inherits <- base::inherits
[09:29:16.230]                       invokeRestart <- base::invokeRestart
[09:29:16.230]                       is.null <- base::is.null
[09:29:16.230]                       muffled <- FALSE
[09:29:16.230]                       if (inherits(cond, "message")) {
[09:29:16.230]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.230]                         if (muffled) 
[09:29:16.230]                           invokeRestart("muffleMessage")
[09:29:16.230]                       }
[09:29:16.230]                       else if (inherits(cond, "warning")) {
[09:29:16.230]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.230]                         if (muffled) 
[09:29:16.230]                           invokeRestart("muffleWarning")
[09:29:16.230]                       }
[09:29:16.230]                       else if (inherits(cond, "condition")) {
[09:29:16.230]                         if (!is.null(pattern)) {
[09:29:16.230]                           computeRestarts <- base::computeRestarts
[09:29:16.230]                           grepl <- base::grepl
[09:29:16.230]                           restarts <- computeRestarts(cond)
[09:29:16.230]                           for (restart in restarts) {
[09:29:16.230]                             name <- restart$name
[09:29:16.230]                             if (is.null(name)) 
[09:29:16.230]                               next
[09:29:16.230]                             if (!grepl(pattern, name)) 
[09:29:16.230]                               next
[09:29:16.230]                             invokeRestart(restart)
[09:29:16.230]                             muffled <- TRUE
[09:29:16.230]                             break
[09:29:16.230]                           }
[09:29:16.230]                         }
[09:29:16.230]                       }
[09:29:16.230]                       invisible(muffled)
[09:29:16.230]                     }
[09:29:16.230]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.230]                   }
[09:29:16.230]                 }
[09:29:16.230]                 else {
[09:29:16.230]                   if (TRUE) {
[09:29:16.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.230]                     {
[09:29:16.230]                       inherits <- base::inherits
[09:29:16.230]                       invokeRestart <- base::invokeRestart
[09:29:16.230]                       is.null <- base::is.null
[09:29:16.230]                       muffled <- FALSE
[09:29:16.230]                       if (inherits(cond, "message")) {
[09:29:16.230]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.230]                         if (muffled) 
[09:29:16.230]                           invokeRestart("muffleMessage")
[09:29:16.230]                       }
[09:29:16.230]                       else if (inherits(cond, "warning")) {
[09:29:16.230]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.230]                         if (muffled) 
[09:29:16.230]                           invokeRestart("muffleWarning")
[09:29:16.230]                       }
[09:29:16.230]                       else if (inherits(cond, "condition")) {
[09:29:16.230]                         if (!is.null(pattern)) {
[09:29:16.230]                           computeRestarts <- base::computeRestarts
[09:29:16.230]                           grepl <- base::grepl
[09:29:16.230]                           restarts <- computeRestarts(cond)
[09:29:16.230]                           for (restart in restarts) {
[09:29:16.230]                             name <- restart$name
[09:29:16.230]                             if (is.null(name)) 
[09:29:16.230]                               next
[09:29:16.230]                             if (!grepl(pattern, name)) 
[09:29:16.230]                               next
[09:29:16.230]                             invokeRestart(restart)
[09:29:16.230]                             muffled <- TRUE
[09:29:16.230]                             break
[09:29:16.230]                           }
[09:29:16.230]                         }
[09:29:16.230]                       }
[09:29:16.230]                       invisible(muffled)
[09:29:16.230]                     }
[09:29:16.230]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.230]                   }
[09:29:16.230]                 }
[09:29:16.230]             }
[09:29:16.230]         }))
[09:29:16.230]     }, error = function(ex) {
[09:29:16.230]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.230]                 ...future.rng), started = ...future.startTime, 
[09:29:16.230]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.230]             version = "1.8"), class = "FutureResult")
[09:29:16.230]     }, finally = {
[09:29:16.230]         if (!identical(...future.workdir, getwd())) 
[09:29:16.230]             setwd(...future.workdir)
[09:29:16.230]         {
[09:29:16.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.230]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.230]             }
[09:29:16.230]             base::options(...future.oldOptions)
[09:29:16.230]             if (.Platform$OS.type == "windows") {
[09:29:16.230]                 old_names <- names(...future.oldEnvVars)
[09:29:16.230]                 envs <- base::Sys.getenv()
[09:29:16.230]                 names <- names(envs)
[09:29:16.230]                 common <- intersect(names, old_names)
[09:29:16.230]                 added <- setdiff(names, old_names)
[09:29:16.230]                 removed <- setdiff(old_names, names)
[09:29:16.230]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.230]                   envs[common]]
[09:29:16.230]                 NAMES <- toupper(changed)
[09:29:16.230]                 args <- list()
[09:29:16.230]                 for (kk in seq_along(NAMES)) {
[09:29:16.230]                   name <- changed[[kk]]
[09:29:16.230]                   NAME <- NAMES[[kk]]
[09:29:16.230]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.230]                     next
[09:29:16.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.230]                 }
[09:29:16.230]                 NAMES <- toupper(added)
[09:29:16.230]                 for (kk in seq_along(NAMES)) {
[09:29:16.230]                   name <- added[[kk]]
[09:29:16.230]                   NAME <- NAMES[[kk]]
[09:29:16.230]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.230]                     next
[09:29:16.230]                   args[[name]] <- ""
[09:29:16.230]                 }
[09:29:16.230]                 NAMES <- toupper(removed)
[09:29:16.230]                 for (kk in seq_along(NAMES)) {
[09:29:16.230]                   name <- removed[[kk]]
[09:29:16.230]                   NAME <- NAMES[[kk]]
[09:29:16.230]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.230]                     next
[09:29:16.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.230]                 }
[09:29:16.230]                 if (length(args) > 0) 
[09:29:16.230]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.230]             }
[09:29:16.230]             else {
[09:29:16.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.230]             }
[09:29:16.230]             {
[09:29:16.230]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.230]                   0L) {
[09:29:16.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.230]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.230]                   base::options(opts)
[09:29:16.230]                 }
[09:29:16.230]                 {
[09:29:16.230]                   {
[09:29:16.230]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.230]                     NULL
[09:29:16.230]                   }
[09:29:16.230]                   options(future.plan = NULL)
[09:29:16.230]                   if (is.na(NA_character_)) 
[09:29:16.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.230]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.230]                     .init = FALSE)
[09:29:16.230]                 }
[09:29:16.230]             }
[09:29:16.230]         }
[09:29:16.230]     })
[09:29:16.230]     if (TRUE) {
[09:29:16.230]         base::sink(type = "output", split = FALSE)
[09:29:16.230]         if (TRUE) {
[09:29:16.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.230]         }
[09:29:16.230]         else {
[09:29:16.230]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.230]         }
[09:29:16.230]         base::close(...future.stdout)
[09:29:16.230]         ...future.stdout <- NULL
[09:29:16.230]     }
[09:29:16.230]     ...future.result$conditions <- ...future.conditions
[09:29:16.230]     ...future.result$finished <- base::Sys.time()
[09:29:16.230]     ...future.result
[09:29:16.230] }
[09:29:16.234] assign_globals() ...
[09:29:16.234] List of 5
[09:29:16.234]  $ ...future.FUN            :function (C, k)  
[09:29:16.234]  $ MoreArgs                 : NULL
[09:29:16.234]  $ ...future.elements_ii    :List of 2
[09:29:16.234]   ..$ :List of 1
[09:29:16.234]   .. ..$ : chr "D"
[09:29:16.234]   ..$ :List of 1
[09:29:16.234]   .. ..$ : int 2
[09:29:16.234]  $ ...future.seeds_ii       : NULL
[09:29:16.234]  $ ...future.globals.maxSize: NULL
[09:29:16.234]  - attr(*, "where")=List of 5
[09:29:16.234]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.234]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.234]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.234]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.234]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.234]  - attr(*, "resolved")= logi FALSE
[09:29:16.234]  - attr(*, "total_size")= num 3488
[09:29:16.234]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.234]  - attr(*, "already-done")= logi TRUE
[09:29:16.244] - reassign environment for ‘...future.FUN’
[09:29:16.245] - copied ‘...future.FUN’ to environment
[09:29:16.245] - copied ‘MoreArgs’ to environment
[09:29:16.245] - copied ‘...future.elements_ii’ to environment
[09:29:16.245] - copied ‘...future.seeds_ii’ to environment
[09:29:16.245] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.246] assign_globals() ... done
[09:29:16.246] requestCore(): workers = 2
[09:29:16.248] MulticoreFuture started
[09:29:16.249] - Launch lazy future ... done
[09:29:16.249] plan(): Setting new future strategy stack:
[09:29:16.249] run() for ‘MulticoreFuture’ ... done
[09:29:16.250] Created future:
[09:29:16.250] List of future strategies:
[09:29:16.250] 1. sequential:
[09:29:16.250]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.250]    - tweaked: FALSE
[09:29:16.250]    - call: NULL
[09:29:16.252] plan(): nbrOfWorkers() = 1
[09:29:16.255] plan(): Setting new future strategy stack:
[09:29:16.255] List of future strategies:
[09:29:16.255] 1. multicore:
[09:29:16.255]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.255]    - tweaked: FALSE
[09:29:16.255]    - call: plan(strategy)
[09:29:16.262] plan(): nbrOfWorkers() = 2
[09:29:16.251] MulticoreFuture:
[09:29:16.251] Label: ‘future_mapply-2’
[09:29:16.251] Expression:
[09:29:16.251] {
[09:29:16.251]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.251]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.251]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.251]         on.exit(options(oopts), add = TRUE)
[09:29:16.251]     }
[09:29:16.251]     {
[09:29:16.251]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.251]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.251]         do.call(mapply, args = args)
[09:29:16.251]     }
[09:29:16.251] }
[09:29:16.251] Lazy evaluation: FALSE
[09:29:16.251] Asynchronous evaluation: TRUE
[09:29:16.251] Local evaluation: TRUE
[09:29:16.251] Environment: R_GlobalEnv
[09:29:16.251] Capture standard output: TRUE
[09:29:16.251] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.251] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.251] Packages: <none>
[09:29:16.251] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.251] Resolved: TRUE
[09:29:16.251] Value: <not collected>
[09:29:16.251] Conditions captured: <none>
[09:29:16.251] Early signaling: FALSE
[09:29:16.251] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.251] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.263] Chunk #2 of 3 ... DONE
[09:29:16.263] Chunk #3 of 3 ...
[09:29:16.263]  - Finding globals in '...' for chunk #3 ...
[09:29:16.264] getGlobalsAndPackages() ...
[09:29:16.264] Searching for globals...
[09:29:16.265] 
[09:29:16.265] Searching for globals ... DONE
[09:29:16.265] - globals: [0] <none>
[09:29:16.265] getGlobalsAndPackages() ... DONE
[09:29:16.266]    + additional globals found: [n=0] 
[09:29:16.266]    + additional namespaces needed: [n=0] 
[09:29:16.266]  - Finding globals in '...' for chunk #3 ... DONE
[09:29:16.266]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[09:29:16.266]  - seeds: <none>
[09:29:16.267]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.267] getGlobalsAndPackages() ...
[09:29:16.267] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.267] Resolving globals: FALSE
[09:29:16.268] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:16.269] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:16.269] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.269] 
[09:29:16.269] getGlobalsAndPackages() ... DONE
[09:29:16.270] run() for ‘Future’ ...
[09:29:16.270] - state: ‘created’
[09:29:16.270] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.275] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.275] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.275]   - Field: ‘label’
[09:29:16.275]   - Field: ‘local’
[09:29:16.276]   - Field: ‘owner’
[09:29:16.276]   - Field: ‘envir’
[09:29:16.276]   - Field: ‘workers’
[09:29:16.276]   - Field: ‘packages’
[09:29:16.276]   - Field: ‘gc’
[09:29:16.276]   - Field: ‘job’
[09:29:16.276]   - Field: ‘conditions’
[09:29:16.277]   - Field: ‘expr’
[09:29:16.277]   - Field: ‘uuid’
[09:29:16.277]   - Field: ‘seed’
[09:29:16.277]   - Field: ‘version’
[09:29:16.277]   - Field: ‘result’
[09:29:16.277]   - Field: ‘asynchronous’
[09:29:16.277]   - Field: ‘calls’
[09:29:16.277]   - Field: ‘globals’
[09:29:16.278]   - Field: ‘stdout’
[09:29:16.278]   - Field: ‘earlySignal’
[09:29:16.278]   - Field: ‘lazy’
[09:29:16.278]   - Field: ‘state’
[09:29:16.278] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.278] - Launch lazy future ...
[09:29:16.279] Packages needed by the future expression (n = 0): <none>
[09:29:16.279] Packages needed by future strategies (n = 0): <none>
[09:29:16.279] {
[09:29:16.279]     {
[09:29:16.279]         {
[09:29:16.279]             ...future.startTime <- base::Sys.time()
[09:29:16.279]             {
[09:29:16.279]                 {
[09:29:16.279]                   {
[09:29:16.279]                     {
[09:29:16.279]                       base::local({
[09:29:16.279]                         has_future <- base::requireNamespace("future", 
[09:29:16.279]                           quietly = TRUE)
[09:29:16.279]                         if (has_future) {
[09:29:16.279]                           ns <- base::getNamespace("future")
[09:29:16.279]                           version <- ns[[".package"]][["version"]]
[09:29:16.279]                           if (is.null(version)) 
[09:29:16.279]                             version <- utils::packageVersion("future")
[09:29:16.279]                         }
[09:29:16.279]                         else {
[09:29:16.279]                           version <- NULL
[09:29:16.279]                         }
[09:29:16.279]                         if (!has_future || version < "1.8.0") {
[09:29:16.279]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.279]                             "", base::R.version$version.string), 
[09:29:16.279]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.279]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.279]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.279]                               "release", "version")], collapse = " "), 
[09:29:16.279]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.279]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.279]                             info)
[09:29:16.279]                           info <- base::paste(info, collapse = "; ")
[09:29:16.279]                           if (!has_future) {
[09:29:16.279]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.279]                               info)
[09:29:16.279]                           }
[09:29:16.279]                           else {
[09:29:16.279]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.279]                               info, version)
[09:29:16.279]                           }
[09:29:16.279]                           base::stop(msg)
[09:29:16.279]                         }
[09:29:16.279]                       })
[09:29:16.279]                     }
[09:29:16.279]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.279]                     base::options(mc.cores = 1L)
[09:29:16.279]                   }
[09:29:16.279]                   ...future.strategy.old <- future::plan("list")
[09:29:16.279]                   options(future.plan = NULL)
[09:29:16.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.279]                 }
[09:29:16.279]                 ...future.workdir <- getwd()
[09:29:16.279]             }
[09:29:16.279]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.279]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.279]         }
[09:29:16.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.279]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[09:29:16.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.279]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.279]             base::names(...future.oldOptions))
[09:29:16.279]     }
[09:29:16.279]     if (FALSE) {
[09:29:16.279]     }
[09:29:16.279]     else {
[09:29:16.279]         if (TRUE) {
[09:29:16.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.279]                 open = "w")
[09:29:16.279]         }
[09:29:16.279]         else {
[09:29:16.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.279]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.279]         }
[09:29:16.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.279]             base::sink(type = "output", split = FALSE)
[09:29:16.279]             base::close(...future.stdout)
[09:29:16.279]         }, add = TRUE)
[09:29:16.279]     }
[09:29:16.279]     ...future.frame <- base::sys.nframe()
[09:29:16.279]     ...future.conditions <- base::list()
[09:29:16.279]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.279]     if (FALSE) {
[09:29:16.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.279]     }
[09:29:16.279]     ...future.result <- base::tryCatch({
[09:29:16.279]         base::withCallingHandlers({
[09:29:16.279]             ...future.value <- base::withVisible(base::local({
[09:29:16.279]                 withCallingHandlers({
[09:29:16.279]                   {
[09:29:16.279]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.279]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.279]                       ...future.globals.maxSize)) {
[09:29:16.279]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.279]                       on.exit(options(oopts), add = TRUE)
[09:29:16.279]                     }
[09:29:16.279]                     {
[09:29:16.279]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.279]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.279]                         USE.NAMES = FALSE)
[09:29:16.279]                       do.call(mapply, args = args)
[09:29:16.279]                     }
[09:29:16.279]                   }
[09:29:16.279]                 }, immediateCondition = function(cond) {
[09:29:16.279]                   save_rds <- function (object, pathname, ...) 
[09:29:16.279]                   {
[09:29:16.279]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.279]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.279]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.279]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.279]                         fi_tmp[["mtime"]])
[09:29:16.279]                     }
[09:29:16.279]                     tryCatch({
[09:29:16.279]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.279]                     }, error = function(ex) {
[09:29:16.279]                       msg <- conditionMessage(ex)
[09:29:16.279]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.279]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.279]                         fi_tmp[["mtime"]], msg)
[09:29:16.279]                       ex$message <- msg
[09:29:16.279]                       stop(ex)
[09:29:16.279]                     })
[09:29:16.279]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.279]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.279]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.279]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.279]                       fi <- file.info(pathname)
[09:29:16.279]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.279]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.279]                         fi[["size"]], fi[["mtime"]])
[09:29:16.279]                       stop(msg)
[09:29:16.279]                     }
[09:29:16.279]                     invisible(pathname)
[09:29:16.279]                   }
[09:29:16.279]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.279]                     rootPath = tempdir()) 
[09:29:16.279]                   {
[09:29:16.279]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.279]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.279]                       tmpdir = path, fileext = ".rds")
[09:29:16.279]                     save_rds(obj, file)
[09:29:16.279]                   }
[09:29:16.279]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.279]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.279]                   {
[09:29:16.279]                     inherits <- base::inherits
[09:29:16.279]                     invokeRestart <- base::invokeRestart
[09:29:16.279]                     is.null <- base::is.null
[09:29:16.279]                     muffled <- FALSE
[09:29:16.279]                     if (inherits(cond, "message")) {
[09:29:16.279]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.279]                       if (muffled) 
[09:29:16.279]                         invokeRestart("muffleMessage")
[09:29:16.279]                     }
[09:29:16.279]                     else if (inherits(cond, "warning")) {
[09:29:16.279]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.279]                       if (muffled) 
[09:29:16.279]                         invokeRestart("muffleWarning")
[09:29:16.279]                     }
[09:29:16.279]                     else if (inherits(cond, "condition")) {
[09:29:16.279]                       if (!is.null(pattern)) {
[09:29:16.279]                         computeRestarts <- base::computeRestarts
[09:29:16.279]                         grepl <- base::grepl
[09:29:16.279]                         restarts <- computeRestarts(cond)
[09:29:16.279]                         for (restart in restarts) {
[09:29:16.279]                           name <- restart$name
[09:29:16.279]                           if (is.null(name)) 
[09:29:16.279]                             next
[09:29:16.279]                           if (!grepl(pattern, name)) 
[09:29:16.279]                             next
[09:29:16.279]                           invokeRestart(restart)
[09:29:16.279]                           muffled <- TRUE
[09:29:16.279]                           break
[09:29:16.279]                         }
[09:29:16.279]                       }
[09:29:16.279]                     }
[09:29:16.279]                     invisible(muffled)
[09:29:16.279]                   }
[09:29:16.279]                   muffleCondition(cond)
[09:29:16.279]                 })
[09:29:16.279]             }))
[09:29:16.279]             future::FutureResult(value = ...future.value$value, 
[09:29:16.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.279]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.279]                     ...future.globalenv.names))
[09:29:16.279]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.279]         }, condition = base::local({
[09:29:16.279]             c <- base::c
[09:29:16.279]             inherits <- base::inherits
[09:29:16.279]             invokeRestart <- base::invokeRestart
[09:29:16.279]             length <- base::length
[09:29:16.279]             list <- base::list
[09:29:16.279]             seq.int <- base::seq.int
[09:29:16.279]             signalCondition <- base::signalCondition
[09:29:16.279]             sys.calls <- base::sys.calls
[09:29:16.279]             `[[` <- base::`[[`
[09:29:16.279]             `+` <- base::`+`
[09:29:16.279]             `<<-` <- base::`<<-`
[09:29:16.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.279]                   3L)]
[09:29:16.279]             }
[09:29:16.279]             function(cond) {
[09:29:16.279]                 is_error <- inherits(cond, "error")
[09:29:16.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.279]                   NULL)
[09:29:16.279]                 if (is_error) {
[09:29:16.279]                   sessionInformation <- function() {
[09:29:16.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.279]                       search = base::search(), system = base::Sys.info())
[09:29:16.279]                   }
[09:29:16.279]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.279]                     cond$call), session = sessionInformation(), 
[09:29:16.279]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.279]                   signalCondition(cond)
[09:29:16.279]                 }
[09:29:16.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.279]                 "immediateCondition"))) {
[09:29:16.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.279]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.279]                   if (TRUE && !signal) {
[09:29:16.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.279]                     {
[09:29:16.279]                       inherits <- base::inherits
[09:29:16.279]                       invokeRestart <- base::invokeRestart
[09:29:16.279]                       is.null <- base::is.null
[09:29:16.279]                       muffled <- FALSE
[09:29:16.279]                       if (inherits(cond, "message")) {
[09:29:16.279]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.279]                         if (muffled) 
[09:29:16.279]                           invokeRestart("muffleMessage")
[09:29:16.279]                       }
[09:29:16.279]                       else if (inherits(cond, "warning")) {
[09:29:16.279]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.279]                         if (muffled) 
[09:29:16.279]                           invokeRestart("muffleWarning")
[09:29:16.279]                       }
[09:29:16.279]                       else if (inherits(cond, "condition")) {
[09:29:16.279]                         if (!is.null(pattern)) {
[09:29:16.279]                           computeRestarts <- base::computeRestarts
[09:29:16.279]                           grepl <- base::grepl
[09:29:16.279]                           restarts <- computeRestarts(cond)
[09:29:16.279]                           for (restart in restarts) {
[09:29:16.279]                             name <- restart$name
[09:29:16.279]                             if (is.null(name)) 
[09:29:16.279]                               next
[09:29:16.279]                             if (!grepl(pattern, name)) 
[09:29:16.279]                               next
[09:29:16.279]                             invokeRestart(restart)
[09:29:16.279]                             muffled <- TRUE
[09:29:16.279]                             break
[09:29:16.279]                           }
[09:29:16.279]                         }
[09:29:16.279]                       }
[09:29:16.279]                       invisible(muffled)
[09:29:16.279]                     }
[09:29:16.279]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.279]                   }
[09:29:16.279]                 }
[09:29:16.279]                 else {
[09:29:16.279]                   if (TRUE) {
[09:29:16.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.279]                     {
[09:29:16.279]                       inherits <- base::inherits
[09:29:16.279]                       invokeRestart <- base::invokeRestart
[09:29:16.279]                       is.null <- base::is.null
[09:29:16.279]                       muffled <- FALSE
[09:29:16.279]                       if (inherits(cond, "message")) {
[09:29:16.279]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.279]                         if (muffled) 
[09:29:16.279]                           invokeRestart("muffleMessage")
[09:29:16.279]                       }
[09:29:16.279]                       else if (inherits(cond, "warning")) {
[09:29:16.279]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.279]                         if (muffled) 
[09:29:16.279]                           invokeRestart("muffleWarning")
[09:29:16.279]                       }
[09:29:16.279]                       else if (inherits(cond, "condition")) {
[09:29:16.279]                         if (!is.null(pattern)) {
[09:29:16.279]                           computeRestarts <- base::computeRestarts
[09:29:16.279]                           grepl <- base::grepl
[09:29:16.279]                           restarts <- computeRestarts(cond)
[09:29:16.279]                           for (restart in restarts) {
[09:29:16.279]                             name <- restart$name
[09:29:16.279]                             if (is.null(name)) 
[09:29:16.279]                               next
[09:29:16.279]                             if (!grepl(pattern, name)) 
[09:29:16.279]                               next
[09:29:16.279]                             invokeRestart(restart)
[09:29:16.279]                             muffled <- TRUE
[09:29:16.279]                             break
[09:29:16.279]                           }
[09:29:16.279]                         }
[09:29:16.279]                       }
[09:29:16.279]                       invisible(muffled)
[09:29:16.279]                     }
[09:29:16.279]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.279]                   }
[09:29:16.279]                 }
[09:29:16.279]             }
[09:29:16.279]         }))
[09:29:16.279]     }, error = function(ex) {
[09:29:16.279]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.279]                 ...future.rng), started = ...future.startTime, 
[09:29:16.279]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.279]             version = "1.8"), class = "FutureResult")
[09:29:16.279]     }, finally = {
[09:29:16.279]         if (!identical(...future.workdir, getwd())) 
[09:29:16.279]             setwd(...future.workdir)
[09:29:16.279]         {
[09:29:16.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.279]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.279]             }
[09:29:16.279]             base::options(...future.oldOptions)
[09:29:16.279]             if (.Platform$OS.type == "windows") {
[09:29:16.279]                 old_names <- names(...future.oldEnvVars)
[09:29:16.279]                 envs <- base::Sys.getenv()
[09:29:16.279]                 names <- names(envs)
[09:29:16.279]                 common <- intersect(names, old_names)
[09:29:16.279]                 added <- setdiff(names, old_names)
[09:29:16.279]                 removed <- setdiff(old_names, names)
[09:29:16.279]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.279]                   envs[common]]
[09:29:16.279]                 NAMES <- toupper(changed)
[09:29:16.279]                 args <- list()
[09:29:16.279]                 for (kk in seq_along(NAMES)) {
[09:29:16.279]                   name <- changed[[kk]]
[09:29:16.279]                   NAME <- NAMES[[kk]]
[09:29:16.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.279]                     next
[09:29:16.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.279]                 }
[09:29:16.279]                 NAMES <- toupper(added)
[09:29:16.279]                 for (kk in seq_along(NAMES)) {
[09:29:16.279]                   name <- added[[kk]]
[09:29:16.279]                   NAME <- NAMES[[kk]]
[09:29:16.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.279]                     next
[09:29:16.279]                   args[[name]] <- ""
[09:29:16.279]                 }
[09:29:16.279]                 NAMES <- toupper(removed)
[09:29:16.279]                 for (kk in seq_along(NAMES)) {
[09:29:16.279]                   name <- removed[[kk]]
[09:29:16.279]                   NAME <- NAMES[[kk]]
[09:29:16.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.279]                     next
[09:29:16.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.279]                 }
[09:29:16.279]                 if (length(args) > 0) 
[09:29:16.279]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.279]             }
[09:29:16.279]             else {
[09:29:16.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.279]             }
[09:29:16.279]             {
[09:29:16.279]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.279]                   0L) {
[09:29:16.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.279]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.279]                   base::options(opts)
[09:29:16.279]                 }
[09:29:16.279]                 {
[09:29:16.279]                   {
[09:29:16.279]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.279]                     NULL
[09:29:16.279]                   }
[09:29:16.279]                   options(future.plan = NULL)
[09:29:16.279]                   if (is.na(NA_character_)) 
[09:29:16.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.279]                     .init = FALSE)
[09:29:16.279]                 }
[09:29:16.279]             }
[09:29:16.279]         }
[09:29:16.279]     })
[09:29:16.279]     if (TRUE) {
[09:29:16.279]         base::sink(type = "output", split = FALSE)
[09:29:16.279]         if (TRUE) {
[09:29:16.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.279]         }
[09:29:16.279]         else {
[09:29:16.279]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.279]         }
[09:29:16.279]         base::close(...future.stdout)
[09:29:16.279]         ...future.stdout <- NULL
[09:29:16.279]     }
[09:29:16.279]     ...future.result$conditions <- ...future.conditions
[09:29:16.279]     ...future.result$finished <- base::Sys.time()
[09:29:16.279]     ...future.result
[09:29:16.279] }
[09:29:16.283] assign_globals() ...
[09:29:16.283] List of 5
[09:29:16.283]  $ ...future.FUN            :function (C, k)  
[09:29:16.283]  $ MoreArgs                 : NULL
[09:29:16.283]  $ ...future.elements_ii    :List of 2
[09:29:16.283]   ..$ :List of 2
[09:29:16.283]   .. ..$ : chr "B"
[09:29:16.283]   .. ..$ : chr "C"
[09:29:16.283]   ..$ :List of 2
[09:29:16.283]   .. ..$ : int 4
[09:29:16.283]   .. ..$ : int 3
[09:29:16.283]  $ ...future.seeds_ii       : NULL
[09:29:16.283]  $ ...future.globals.maxSize: NULL
[09:29:16.283]  - attr(*, "where")=List of 5
[09:29:16.283]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.283]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.283]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.283]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.283]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.283]  - attr(*, "resolved")= logi FALSE
[09:29:16.283]  - attr(*, "total_size")= num 3656
[09:29:16.283]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.283]  - attr(*, "already-done")= logi TRUE
[09:29:16.291] - reassign environment for ‘...future.FUN’
[09:29:16.291] - copied ‘...future.FUN’ to environment
[09:29:16.291] - copied ‘MoreArgs’ to environment
[09:29:16.291] - copied ‘...future.elements_ii’ to environment
[09:29:16.291] - copied ‘...future.seeds_ii’ to environment
[09:29:16.291] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.292] assign_globals() ... done
[09:29:16.292] requestCore(): workers = 2
[09:29:16.292] Poll #1 (0): usedCores() = 2, workers = 2
[09:29:16.303] result() for MulticoreFuture ...
[09:29:16.304] result() for MulticoreFuture ...
[09:29:16.304] result() for MulticoreFuture ... done
[09:29:16.304] result() for MulticoreFuture ... done
[09:29:16.304] result() for MulticoreFuture ...
[09:29:16.304] result() for MulticoreFuture ... done
[09:29:16.307] MulticoreFuture started
[09:29:16.307] - Launch lazy future ... done
[09:29:16.307] run() for ‘MulticoreFuture’ ... done
[09:29:16.308] Created future:
[09:29:16.308] plan(): Setting new future strategy stack:
[09:29:16.308] List of future strategies:
[09:29:16.308] 1. sequential:
[09:29:16.308]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.308]    - tweaked: FALSE
[09:29:16.308]    - call: NULL
[09:29:16.315] plan(): nbrOfWorkers() = 1
[09:29:16.319] plan(): Setting new future strategy stack:
[09:29:16.319] List of future strategies:
[09:29:16.319] 1. multicore:
[09:29:16.319]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.319]    - tweaked: FALSE
[09:29:16.319]    - call: plan(strategy)
[09:29:16.325] plan(): nbrOfWorkers() = 2
[09:29:16.308] MulticoreFuture:
[09:29:16.308] Label: ‘future_mapply-3’
[09:29:16.308] Expression:
[09:29:16.308] {
[09:29:16.308]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.308]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.308]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.308]         on.exit(options(oopts), add = TRUE)
[09:29:16.308]     }
[09:29:16.308]     {
[09:29:16.308]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.308]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.308]         do.call(mapply, args = args)
[09:29:16.308]     }
[09:29:16.308] }
[09:29:16.308] Lazy evaluation: FALSE
[09:29:16.308] Asynchronous evaluation: TRUE
[09:29:16.308] Local evaluation: TRUE
[09:29:16.308] Environment: R_GlobalEnv
[09:29:16.308] Capture standard output: TRUE
[09:29:16.308] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.308] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.308] Packages: <none>
[09:29:16.308] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.308] Resolved: TRUE
[09:29:16.308] Value: <not collected>
[09:29:16.308] Conditions captured: <none>
[09:29:16.308] Early signaling: FALSE
[09:29:16.308] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.308] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.327] Chunk #3 of 3 ... DONE
[09:29:16.327] Launching 3 futures (chunks) ... DONE
[09:29:16.327] Resolving 3 futures (chunks) ...
[09:29:16.327] resolve() on list ...
[09:29:16.328]  recursive: 0
[09:29:16.328]  length: 3
[09:29:16.328] 
[09:29:16.328] Future #1
[09:29:16.329] result() for MulticoreFuture ...
[09:29:16.329] result() for MulticoreFuture ... done
[09:29:16.329] result() for MulticoreFuture ...
[09:29:16.329] result() for MulticoreFuture ... done
[09:29:16.329] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:16.330] - nx: 3
[09:29:16.330] - relay: TRUE
[09:29:16.330] - stdout: TRUE
[09:29:16.330] - signal: TRUE
[09:29:16.330] - resignal: FALSE
[09:29:16.331] - force: TRUE
[09:29:16.331] - relayed: [n=3] FALSE, FALSE, FALSE
[09:29:16.331] - queued futures: [n=3] FALSE, FALSE, FALSE
[09:29:16.331]  - until=1
[09:29:16.332]  - relaying element #1
[09:29:16.332] result() for MulticoreFuture ...
[09:29:16.332] result() for MulticoreFuture ... done
[09:29:16.332] result() for MulticoreFuture ...
[09:29:16.332] result() for MulticoreFuture ... done
[09:29:16.333] result() for MulticoreFuture ...
[09:29:16.333] result() for MulticoreFuture ... done
[09:29:16.333] result() for MulticoreFuture ...
[09:29:16.333] result() for MulticoreFuture ... done
[09:29:16.334] - relayed: [n=3] TRUE, FALSE, FALSE
[09:29:16.334] - queued futures: [n=3] TRUE, FALSE, FALSE
[09:29:16.334] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:16.334]  length: 2 (resolved future 1)
[09:29:16.335] Future #2
[09:29:16.335] result() for MulticoreFuture ...
[09:29:16.336] result() for MulticoreFuture ...
[09:29:16.336] result() for MulticoreFuture ... done
[09:29:16.336] result() for MulticoreFuture ... done
[09:29:16.337] result() for MulticoreFuture ...
[09:29:16.337] result() for MulticoreFuture ... done
[09:29:16.337] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:16.337] - nx: 3
[09:29:16.337] - relay: TRUE
[09:29:16.337] - stdout: TRUE
[09:29:16.338] - signal: TRUE
[09:29:16.338] - resignal: FALSE
[09:29:16.338] - force: TRUE
[09:29:16.338] - relayed: [n=3] TRUE, FALSE, FALSE
[09:29:16.338] - queued futures: [n=3] TRUE, FALSE, FALSE
[09:29:16.338]  - until=2
[09:29:16.339]  - relaying element #2
[09:29:16.339] result() for MulticoreFuture ...
[09:29:16.339] result() for MulticoreFuture ... done
[09:29:16.339] result() for MulticoreFuture ...
[09:29:16.339] result() for MulticoreFuture ... done
[09:29:16.340] result() for MulticoreFuture ...
[09:29:16.340] result() for MulticoreFuture ... done
[09:29:16.340] result() for MulticoreFuture ...
[09:29:16.340] result() for MulticoreFuture ... done
[09:29:16.340] - relayed: [n=3] TRUE, TRUE, FALSE
[09:29:16.341] - queued futures: [n=3] TRUE, TRUE, FALSE
[09:29:16.341] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:16.341]  length: 1 (resolved future 2)
[09:29:16.341] Future #3
[09:29:16.341] result() for MulticoreFuture ...
[09:29:16.342] result() for MulticoreFuture ...
[09:29:16.342] result() for MulticoreFuture ... done
[09:29:16.342] result() for MulticoreFuture ... done
[09:29:16.342] result() for MulticoreFuture ...
[09:29:16.343] result() for MulticoreFuture ... done
[09:29:16.343] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:29:16.343] - nx: 3
[09:29:16.343] - relay: TRUE
[09:29:16.343] - stdout: TRUE
[09:29:16.343] - signal: TRUE
[09:29:16.343] - resignal: FALSE
[09:29:16.343] - force: TRUE
[09:29:16.343] - relayed: [n=3] TRUE, TRUE, FALSE
[09:29:16.343] - queued futures: [n=3] TRUE, TRUE, FALSE
[09:29:16.344]  - until=3
[09:29:16.344]  - relaying element #3
[09:29:16.344] result() for MulticoreFuture ...
[09:29:16.344] result() for MulticoreFuture ... done
[09:29:16.344] result() for MulticoreFuture ...
[09:29:16.344] result() for MulticoreFuture ... done
[09:29:16.344] result() for MulticoreFuture ...
[09:29:16.344] result() for MulticoreFuture ... done
[09:29:16.345] result() for MulticoreFuture ...
[09:29:16.345] result() for MulticoreFuture ... done
[09:29:16.345] - relayed: [n=3] TRUE, TRUE, TRUE
[09:29:16.345] - queued futures: [n=3] TRUE, TRUE, TRUE
[09:29:16.345] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:29:16.345]  length: 0 (resolved future 3)
[09:29:16.345] Relaying remaining futures
[09:29:16.345] signalConditionsASAP(NULL, pos=0) ...
[09:29:16.345] - nx: 3
[09:29:16.345] - relay: TRUE
[09:29:16.346] - stdout: TRUE
[09:29:16.346] - signal: TRUE
[09:29:16.346] - resignal: FALSE
[09:29:16.346] - force: TRUE
[09:29:16.346] - relayed: [n=3] TRUE, TRUE, TRUE
[09:29:16.346] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[09:29:16.346] - relayed: [n=3] TRUE, TRUE, TRUE
[09:29:16.346] - queued futures: [n=3] TRUE, TRUE, TRUE
[09:29:16.346] signalConditionsASAP(NULL, pos=0) ... done
[09:29:16.346] resolve() on list ... DONE
[09:29:16.347] result() for MulticoreFuture ...
[09:29:16.347] result() for MulticoreFuture ... done
[09:29:16.347] result() for MulticoreFuture ...
[09:29:16.347] result() for MulticoreFuture ... done
[09:29:16.347] result() for MulticoreFuture ...
[09:29:16.347] result() for MulticoreFuture ... done
[09:29:16.347] result() for MulticoreFuture ...
[09:29:16.347] result() for MulticoreFuture ... done
[09:29:16.347] result() for MulticoreFuture ...
[09:29:16.347] result() for MulticoreFuture ... done
[09:29:16.348] result() for MulticoreFuture ...
[09:29:16.348] result() for MulticoreFuture ... done
[09:29:16.348]  - Number of value chunks collected: 3
[09:29:16.348] Resolving 3 futures (chunks) ... DONE
[09:29:16.348] Reducing values from 3 chunks ...
[09:29:16.348]  - Number of values collected after concatenation: 5
[09:29:16.348]  - Number of values expected: 5
[09:29:16.348] Reverse index remapping (attribute 'ordering'): [n = 5] 1, 4, 5, 3, 2
[09:29:16.348] Reducing values from 3 chunks ... DONE
[09:29:16.349] future_mapply() ... DONE
[09:29:16.349] future_mapply() ...
[09:29:16.353] Number of chunks: 2
[09:29:16.354] getGlobalsAndPackagesXApply() ...
[09:29:16.354]  - future.globals: TRUE
[09:29:16.354] getGlobalsAndPackages() ...
[09:29:16.354] Searching for globals...
[09:29:16.356] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:16.356] Searching for globals ... DONE
[09:29:16.356] Resolving globals: FALSE
[09:29:16.356] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:16.357] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:16.357] - globals: [1] ‘FUN’
[09:29:16.357] 
[09:29:16.357] getGlobalsAndPackages() ... DONE
[09:29:16.357]  - globals found/used: [n=1] ‘FUN’
[09:29:16.357]  - needed namespaces: [n=0] 
[09:29:16.357] Finding globals ... DONE
[09:29:16.358] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:16.358] List of 2
[09:29:16.358]  $ ...future.FUN:function (C, k)  
[09:29:16.358]  $ MoreArgs     : list()
[09:29:16.358]  - attr(*, "where")=List of 2
[09:29:16.358]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:16.358]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:16.358]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.358]  - attr(*, "resolved")= logi FALSE
[09:29:16.358]  - attr(*, "total_size")= num NA
[09:29:16.363] Packages to be attached in all futures: [n=0] 
[09:29:16.363] getGlobalsAndPackagesXApply() ... DONE
[09:29:16.363] Number of futures (= number of chunks): 2
[09:29:16.363] Launching 2 futures (chunks) ...
[09:29:16.363] Chunk #1 of 2 ...
[09:29:16.364]  - Finding globals in '...' for chunk #1 ...
[09:29:16.364] getGlobalsAndPackages() ...
[09:29:16.364] Searching for globals...
[09:29:16.364] 
[09:29:16.364] Searching for globals ... DONE
[09:29:16.364] - globals: [0] <none>
[09:29:16.365] getGlobalsAndPackages() ... DONE
[09:29:16.365]    + additional globals found: [n=0] 
[09:29:16.365]    + additional namespaces needed: [n=0] 
[09:29:16.365]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:16.365]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:16.365]  - seeds: <none>
[09:29:16.365]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.365] getGlobalsAndPackages() ...
[09:29:16.365] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.366] Resolving globals: FALSE
[09:29:16.366] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:16.367] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:16.367] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.367] 
[09:29:16.367] getGlobalsAndPackages() ... DONE
[09:29:16.367] run() for ‘Future’ ...
[09:29:16.367] - state: ‘created’
[09:29:16.367] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.371] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.371] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.371]   - Field: ‘label’
[09:29:16.371]   - Field: ‘local’
[09:29:16.371]   - Field: ‘owner’
[09:29:16.371]   - Field: ‘envir’
[09:29:16.372]   - Field: ‘workers’
[09:29:16.372]   - Field: ‘packages’
[09:29:16.372]   - Field: ‘gc’
[09:29:16.372]   - Field: ‘job’
[09:29:16.372]   - Field: ‘conditions’
[09:29:16.372]   - Field: ‘expr’
[09:29:16.372]   - Field: ‘uuid’
[09:29:16.372]   - Field: ‘seed’
[09:29:16.372]   - Field: ‘version’
[09:29:16.372]   - Field: ‘result’
[09:29:16.373]   - Field: ‘asynchronous’
[09:29:16.373]   - Field: ‘calls’
[09:29:16.373]   - Field: ‘globals’
[09:29:16.373]   - Field: ‘stdout’
[09:29:16.373]   - Field: ‘earlySignal’
[09:29:16.373]   - Field: ‘lazy’
[09:29:16.373]   - Field: ‘state’
[09:29:16.373] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.373] - Launch lazy future ...
[09:29:16.374] Packages needed by the future expression (n = 0): <none>
[09:29:16.374] Packages needed by future strategies (n = 0): <none>
[09:29:16.374] {
[09:29:16.374]     {
[09:29:16.374]         {
[09:29:16.374]             ...future.startTime <- base::Sys.time()
[09:29:16.374]             {
[09:29:16.374]                 {
[09:29:16.374]                   {
[09:29:16.374]                     {
[09:29:16.374]                       base::local({
[09:29:16.374]                         has_future <- base::requireNamespace("future", 
[09:29:16.374]                           quietly = TRUE)
[09:29:16.374]                         if (has_future) {
[09:29:16.374]                           ns <- base::getNamespace("future")
[09:29:16.374]                           version <- ns[[".package"]][["version"]]
[09:29:16.374]                           if (is.null(version)) 
[09:29:16.374]                             version <- utils::packageVersion("future")
[09:29:16.374]                         }
[09:29:16.374]                         else {
[09:29:16.374]                           version <- NULL
[09:29:16.374]                         }
[09:29:16.374]                         if (!has_future || version < "1.8.0") {
[09:29:16.374]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.374]                             "", base::R.version$version.string), 
[09:29:16.374]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.374]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.374]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.374]                               "release", "version")], collapse = " "), 
[09:29:16.374]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.374]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.374]                             info)
[09:29:16.374]                           info <- base::paste(info, collapse = "; ")
[09:29:16.374]                           if (!has_future) {
[09:29:16.374]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.374]                               info)
[09:29:16.374]                           }
[09:29:16.374]                           else {
[09:29:16.374]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.374]                               info, version)
[09:29:16.374]                           }
[09:29:16.374]                           base::stop(msg)
[09:29:16.374]                         }
[09:29:16.374]                       })
[09:29:16.374]                     }
[09:29:16.374]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.374]                     base::options(mc.cores = 1L)
[09:29:16.374]                   }
[09:29:16.374]                   ...future.strategy.old <- future::plan("list")
[09:29:16.374]                   options(future.plan = NULL)
[09:29:16.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.374]                 }
[09:29:16.374]                 ...future.workdir <- getwd()
[09:29:16.374]             }
[09:29:16.374]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.374]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.374]         }
[09:29:16.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.374]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:16.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.374]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.374]             base::names(...future.oldOptions))
[09:29:16.374]     }
[09:29:16.374]     if (FALSE) {
[09:29:16.374]     }
[09:29:16.374]     else {
[09:29:16.374]         if (TRUE) {
[09:29:16.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.374]                 open = "w")
[09:29:16.374]         }
[09:29:16.374]         else {
[09:29:16.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.374]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.374]         }
[09:29:16.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.374]             base::sink(type = "output", split = FALSE)
[09:29:16.374]             base::close(...future.stdout)
[09:29:16.374]         }, add = TRUE)
[09:29:16.374]     }
[09:29:16.374]     ...future.frame <- base::sys.nframe()
[09:29:16.374]     ...future.conditions <- base::list()
[09:29:16.374]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.374]     if (FALSE) {
[09:29:16.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.374]     }
[09:29:16.374]     ...future.result <- base::tryCatch({
[09:29:16.374]         base::withCallingHandlers({
[09:29:16.374]             ...future.value <- base::withVisible(base::local({
[09:29:16.374]                 withCallingHandlers({
[09:29:16.374]                   {
[09:29:16.374]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.374]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.374]                       ...future.globals.maxSize)) {
[09:29:16.374]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.374]                       on.exit(options(oopts), add = TRUE)
[09:29:16.374]                     }
[09:29:16.374]                     {
[09:29:16.374]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.374]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.374]                         USE.NAMES = FALSE)
[09:29:16.374]                       do.call(mapply, args = args)
[09:29:16.374]                     }
[09:29:16.374]                   }
[09:29:16.374]                 }, immediateCondition = function(cond) {
[09:29:16.374]                   save_rds <- function (object, pathname, ...) 
[09:29:16.374]                   {
[09:29:16.374]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.374]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.374]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.374]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.374]                         fi_tmp[["mtime"]])
[09:29:16.374]                     }
[09:29:16.374]                     tryCatch({
[09:29:16.374]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.374]                     }, error = function(ex) {
[09:29:16.374]                       msg <- conditionMessage(ex)
[09:29:16.374]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.374]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.374]                         fi_tmp[["mtime"]], msg)
[09:29:16.374]                       ex$message <- msg
[09:29:16.374]                       stop(ex)
[09:29:16.374]                     })
[09:29:16.374]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.374]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.374]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.374]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.374]                       fi <- file.info(pathname)
[09:29:16.374]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.374]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.374]                         fi[["size"]], fi[["mtime"]])
[09:29:16.374]                       stop(msg)
[09:29:16.374]                     }
[09:29:16.374]                     invisible(pathname)
[09:29:16.374]                   }
[09:29:16.374]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.374]                     rootPath = tempdir()) 
[09:29:16.374]                   {
[09:29:16.374]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.374]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.374]                       tmpdir = path, fileext = ".rds")
[09:29:16.374]                     save_rds(obj, file)
[09:29:16.374]                   }
[09:29:16.374]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.374]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.374]                   {
[09:29:16.374]                     inherits <- base::inherits
[09:29:16.374]                     invokeRestart <- base::invokeRestart
[09:29:16.374]                     is.null <- base::is.null
[09:29:16.374]                     muffled <- FALSE
[09:29:16.374]                     if (inherits(cond, "message")) {
[09:29:16.374]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.374]                       if (muffled) 
[09:29:16.374]                         invokeRestart("muffleMessage")
[09:29:16.374]                     }
[09:29:16.374]                     else if (inherits(cond, "warning")) {
[09:29:16.374]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.374]                       if (muffled) 
[09:29:16.374]                         invokeRestart("muffleWarning")
[09:29:16.374]                     }
[09:29:16.374]                     else if (inherits(cond, "condition")) {
[09:29:16.374]                       if (!is.null(pattern)) {
[09:29:16.374]                         computeRestarts <- base::computeRestarts
[09:29:16.374]                         grepl <- base::grepl
[09:29:16.374]                         restarts <- computeRestarts(cond)
[09:29:16.374]                         for (restart in restarts) {
[09:29:16.374]                           name <- restart$name
[09:29:16.374]                           if (is.null(name)) 
[09:29:16.374]                             next
[09:29:16.374]                           if (!grepl(pattern, name)) 
[09:29:16.374]                             next
[09:29:16.374]                           invokeRestart(restart)
[09:29:16.374]                           muffled <- TRUE
[09:29:16.374]                           break
[09:29:16.374]                         }
[09:29:16.374]                       }
[09:29:16.374]                     }
[09:29:16.374]                     invisible(muffled)
[09:29:16.374]                   }
[09:29:16.374]                   muffleCondition(cond)
[09:29:16.374]                 })
[09:29:16.374]             }))
[09:29:16.374]             future::FutureResult(value = ...future.value$value, 
[09:29:16.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.374]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.374]                     ...future.globalenv.names))
[09:29:16.374]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.374]         }, condition = base::local({
[09:29:16.374]             c <- base::c
[09:29:16.374]             inherits <- base::inherits
[09:29:16.374]             invokeRestart <- base::invokeRestart
[09:29:16.374]             length <- base::length
[09:29:16.374]             list <- base::list
[09:29:16.374]             seq.int <- base::seq.int
[09:29:16.374]             signalCondition <- base::signalCondition
[09:29:16.374]             sys.calls <- base::sys.calls
[09:29:16.374]             `[[` <- base::`[[`
[09:29:16.374]             `+` <- base::`+`
[09:29:16.374]             `<<-` <- base::`<<-`
[09:29:16.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.374]                   3L)]
[09:29:16.374]             }
[09:29:16.374]             function(cond) {
[09:29:16.374]                 is_error <- inherits(cond, "error")
[09:29:16.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.374]                   NULL)
[09:29:16.374]                 if (is_error) {
[09:29:16.374]                   sessionInformation <- function() {
[09:29:16.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.374]                       search = base::search(), system = base::Sys.info())
[09:29:16.374]                   }
[09:29:16.374]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.374]                     cond$call), session = sessionInformation(), 
[09:29:16.374]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.374]                   signalCondition(cond)
[09:29:16.374]                 }
[09:29:16.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.374]                 "immediateCondition"))) {
[09:29:16.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.374]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.374]                   if (TRUE && !signal) {
[09:29:16.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.374]                     {
[09:29:16.374]                       inherits <- base::inherits
[09:29:16.374]                       invokeRestart <- base::invokeRestart
[09:29:16.374]                       is.null <- base::is.null
[09:29:16.374]                       muffled <- FALSE
[09:29:16.374]                       if (inherits(cond, "message")) {
[09:29:16.374]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.374]                         if (muffled) 
[09:29:16.374]                           invokeRestart("muffleMessage")
[09:29:16.374]                       }
[09:29:16.374]                       else if (inherits(cond, "warning")) {
[09:29:16.374]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.374]                         if (muffled) 
[09:29:16.374]                           invokeRestart("muffleWarning")
[09:29:16.374]                       }
[09:29:16.374]                       else if (inherits(cond, "condition")) {
[09:29:16.374]                         if (!is.null(pattern)) {
[09:29:16.374]                           computeRestarts <- base::computeRestarts
[09:29:16.374]                           grepl <- base::grepl
[09:29:16.374]                           restarts <- computeRestarts(cond)
[09:29:16.374]                           for (restart in restarts) {
[09:29:16.374]                             name <- restart$name
[09:29:16.374]                             if (is.null(name)) 
[09:29:16.374]                               next
[09:29:16.374]                             if (!grepl(pattern, name)) 
[09:29:16.374]                               next
[09:29:16.374]                             invokeRestart(restart)
[09:29:16.374]                             muffled <- TRUE
[09:29:16.374]                             break
[09:29:16.374]                           }
[09:29:16.374]                         }
[09:29:16.374]                       }
[09:29:16.374]                       invisible(muffled)
[09:29:16.374]                     }
[09:29:16.374]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.374]                   }
[09:29:16.374]                 }
[09:29:16.374]                 else {
[09:29:16.374]                   if (TRUE) {
[09:29:16.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.374]                     {
[09:29:16.374]                       inherits <- base::inherits
[09:29:16.374]                       invokeRestart <- base::invokeRestart
[09:29:16.374]                       is.null <- base::is.null
[09:29:16.374]                       muffled <- FALSE
[09:29:16.374]                       if (inherits(cond, "message")) {
[09:29:16.374]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.374]                         if (muffled) 
[09:29:16.374]                           invokeRestart("muffleMessage")
[09:29:16.374]                       }
[09:29:16.374]                       else if (inherits(cond, "warning")) {
[09:29:16.374]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.374]                         if (muffled) 
[09:29:16.374]                           invokeRestart("muffleWarning")
[09:29:16.374]                       }
[09:29:16.374]                       else if (inherits(cond, "condition")) {
[09:29:16.374]                         if (!is.null(pattern)) {
[09:29:16.374]                           computeRestarts <- base::computeRestarts
[09:29:16.374]                           grepl <- base::grepl
[09:29:16.374]                           restarts <- computeRestarts(cond)
[09:29:16.374]                           for (restart in restarts) {
[09:29:16.374]                             name <- restart$name
[09:29:16.374]                             if (is.null(name)) 
[09:29:16.374]                               next
[09:29:16.374]                             if (!grepl(pattern, name)) 
[09:29:16.374]                               next
[09:29:16.374]                             invokeRestart(restart)
[09:29:16.374]                             muffled <- TRUE
[09:29:16.374]                             break
[09:29:16.374]                           }
[09:29:16.374]                         }
[09:29:16.374]                       }
[09:29:16.374]                       invisible(muffled)
[09:29:16.374]                     }
[09:29:16.374]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.374]                   }
[09:29:16.374]                 }
[09:29:16.374]             }
[09:29:16.374]         }))
[09:29:16.374]     }, error = function(ex) {
[09:29:16.374]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.374]                 ...future.rng), started = ...future.startTime, 
[09:29:16.374]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.374]             version = "1.8"), class = "FutureResult")
[09:29:16.374]     }, finally = {
[09:29:16.374]         if (!identical(...future.workdir, getwd())) 
[09:29:16.374]             setwd(...future.workdir)
[09:29:16.374]         {
[09:29:16.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.374]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.374]             }
[09:29:16.374]             base::options(...future.oldOptions)
[09:29:16.374]             if (.Platform$OS.type == "windows") {
[09:29:16.374]                 old_names <- names(...future.oldEnvVars)
[09:29:16.374]                 envs <- base::Sys.getenv()
[09:29:16.374]                 names <- names(envs)
[09:29:16.374]                 common <- intersect(names, old_names)
[09:29:16.374]                 added <- setdiff(names, old_names)
[09:29:16.374]                 removed <- setdiff(old_names, names)
[09:29:16.374]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.374]                   envs[common]]
[09:29:16.374]                 NAMES <- toupper(changed)
[09:29:16.374]                 args <- list()
[09:29:16.374]                 for (kk in seq_along(NAMES)) {
[09:29:16.374]                   name <- changed[[kk]]
[09:29:16.374]                   NAME <- NAMES[[kk]]
[09:29:16.374]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.374]                     next
[09:29:16.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.374]                 }
[09:29:16.374]                 NAMES <- toupper(added)
[09:29:16.374]                 for (kk in seq_along(NAMES)) {
[09:29:16.374]                   name <- added[[kk]]
[09:29:16.374]                   NAME <- NAMES[[kk]]
[09:29:16.374]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.374]                     next
[09:29:16.374]                   args[[name]] <- ""
[09:29:16.374]                 }
[09:29:16.374]                 NAMES <- toupper(removed)
[09:29:16.374]                 for (kk in seq_along(NAMES)) {
[09:29:16.374]                   name <- removed[[kk]]
[09:29:16.374]                   NAME <- NAMES[[kk]]
[09:29:16.374]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.374]                     next
[09:29:16.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.374]                 }
[09:29:16.374]                 if (length(args) > 0) 
[09:29:16.374]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.374]             }
[09:29:16.374]             else {
[09:29:16.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.374]             }
[09:29:16.374]             {
[09:29:16.374]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.374]                   0L) {
[09:29:16.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.374]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.374]                   base::options(opts)
[09:29:16.374]                 }
[09:29:16.374]                 {
[09:29:16.374]                   {
[09:29:16.374]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.374]                     NULL
[09:29:16.374]                   }
[09:29:16.374]                   options(future.plan = NULL)
[09:29:16.374]                   if (is.na(NA_character_)) 
[09:29:16.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.374]                     .init = FALSE)
[09:29:16.374]                 }
[09:29:16.374]             }
[09:29:16.374]         }
[09:29:16.374]     })
[09:29:16.374]     if (TRUE) {
[09:29:16.374]         base::sink(type = "output", split = FALSE)
[09:29:16.374]         if (TRUE) {
[09:29:16.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.374]         }
[09:29:16.374]         else {
[09:29:16.374]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.374]         }
[09:29:16.374]         base::close(...future.stdout)
[09:29:16.374]         ...future.stdout <- NULL
[09:29:16.374]     }
[09:29:16.374]     ...future.result$conditions <- ...future.conditions
[09:29:16.374]     ...future.result$finished <- base::Sys.time()
[09:29:16.374]     ...future.result
[09:29:16.374] }
[09:29:16.376] assign_globals() ...
[09:29:16.377] List of 5
[09:29:16.377]  $ ...future.FUN            :function (C, k)  
[09:29:16.377]  $ MoreArgs                 : list()
[09:29:16.377]  $ ...future.elements_ii    :List of 2
[09:29:16.377]   ..$ :List of 2
[09:29:16.377]   .. ..$ : chr "A"
[09:29:16.377]   .. ..$ : chr "B"
[09:29:16.377]   ..$ :List of 2
[09:29:16.377]   .. ..$ : int 5
[09:29:16.377]   .. ..$ : int 4
[09:29:16.377]  $ ...future.seeds_ii       : NULL
[09:29:16.377]  $ ...future.globals.maxSize: NULL
[09:29:16.377]  - attr(*, "where")=List of 5
[09:29:16.377]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.377]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.377]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.377]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.377]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.377]  - attr(*, "resolved")= logi FALSE
[09:29:16.377]  - attr(*, "total_size")= num 3656
[09:29:16.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.377]  - attr(*, "already-done")= logi TRUE
[09:29:16.382] - reassign environment for ‘...future.FUN’
[09:29:16.382] - copied ‘...future.FUN’ to environment
[09:29:16.382] - copied ‘MoreArgs’ to environment
[09:29:16.382] - copied ‘...future.elements_ii’ to environment
[09:29:16.382] - copied ‘...future.seeds_ii’ to environment
[09:29:16.382] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.383] assign_globals() ... done
[09:29:16.383] requestCore(): workers = 2
[09:29:16.385] MulticoreFuture started
[09:29:16.385] - Launch lazy future ... done
[09:29:16.385] run() for ‘MulticoreFuture’ ... done
[09:29:16.385] Created future:
[09:29:16.386] plan(): Setting new future strategy stack:
[09:29:16.386] List of future strategies:
[09:29:16.386] 1. sequential:
[09:29:16.386]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.386]    - tweaked: FALSE
[09:29:16.386]    - call: NULL
[09:29:16.387] plan(): nbrOfWorkers() = 1
[09:29:16.389] plan(): Setting new future strategy stack:
[09:29:16.389] List of future strategies:
[09:29:16.389] 1. multicore:
[09:29:16.389]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.389]    - tweaked: FALSE
[09:29:16.389]    - call: plan(strategy)
[09:29:16.386] MulticoreFuture:
[09:29:16.386] Label: ‘future_.mapply-1’
[09:29:16.386] Expression:
[09:29:16.386] {
[09:29:16.386]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.386]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.386]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.386]         on.exit(options(oopts), add = TRUE)
[09:29:16.386]     }
[09:29:16.386]     {
[09:29:16.386]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.386]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.386]         do.call(mapply, args = args)
[09:29:16.386]     }
[09:29:16.386] }
[09:29:16.386] Lazy evaluation: FALSE
[09:29:16.386] Asynchronous evaluation: TRUE
[09:29:16.386] Local evaluation: TRUE
[09:29:16.386] Environment: R_GlobalEnv
[09:29:16.386] Capture standard output: TRUE
[09:29:16.386] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.386] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.386] Packages: <none>
[09:29:16.386] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.386] Resolved: FALSE
[09:29:16.386] Value: <not collected>
[09:29:16.386] Conditions captured: <none>
[09:29:16.386] Early signaling: FALSE
[09:29:16.386] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.386] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.398] Chunk #1 of 2 ... DONE
[09:29:16.398] Chunk #2 of 2 ...
[09:29:16.399]  - Finding globals in '...' for chunk #2 ...
[09:29:16.399] getGlobalsAndPackages() ...
[09:29:16.399] Searching for globals...
[09:29:16.399] 
[09:29:16.399] plan(): nbrOfWorkers() = 2
[09:29:16.400] Searching for globals ... DONE
[09:29:16.400] - globals: [0] <none>
[09:29:16.403] getGlobalsAndPackages() ... DONE
[09:29:16.403]    + additional globals found: [n=0] 
[09:29:16.403]    + additional namespaces needed: [n=0] 
[09:29:16.403]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:16.404]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:16.404]  - seeds: <none>
[09:29:16.404]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.404] getGlobalsAndPackages() ...
[09:29:16.405] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.405] Resolving globals: FALSE
[09:29:16.407] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[09:29:16.408] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:16.408] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.408] 
[09:29:16.409] getGlobalsAndPackages() ... DONE
[09:29:16.409] run() for ‘Future’ ...
[09:29:16.410] - state: ‘created’
[09:29:16.410] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.415] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.416] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.416]   - Field: ‘label’
[09:29:16.416]   - Field: ‘local’
[09:29:16.416]   - Field: ‘owner’
[09:29:16.417]   - Field: ‘envir’
[09:29:16.417]   - Field: ‘workers’
[09:29:16.417]   - Field: ‘packages’
[09:29:16.417]   - Field: ‘gc’
[09:29:16.417]   - Field: ‘job’
[09:29:16.418]   - Field: ‘conditions’
[09:29:16.418]   - Field: ‘expr’
[09:29:16.418]   - Field: ‘uuid’
[09:29:16.418]   - Field: ‘seed’
[09:29:16.418]   - Field: ‘version’
[09:29:16.418]   - Field: ‘result’
[09:29:16.418]   - Field: ‘asynchronous’
[09:29:16.418]   - Field: ‘calls’
[09:29:16.419]   - Field: ‘globals’
[09:29:16.419]   - Field: ‘stdout’
[09:29:16.419]   - Field: ‘earlySignal’
[09:29:16.419]   - Field: ‘lazy’
[09:29:16.419]   - Field: ‘state’
[09:29:16.419] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.419] - Launch lazy future ...
[09:29:16.420] Packages needed by the future expression (n = 0): <none>
[09:29:16.420] Packages needed by future strategies (n = 0): <none>
[09:29:16.421] {
[09:29:16.421]     {
[09:29:16.421]         {
[09:29:16.421]             ...future.startTime <- base::Sys.time()
[09:29:16.421]             {
[09:29:16.421]                 {
[09:29:16.421]                   {
[09:29:16.421]                     {
[09:29:16.421]                       base::local({
[09:29:16.421]                         has_future <- base::requireNamespace("future", 
[09:29:16.421]                           quietly = TRUE)
[09:29:16.421]                         if (has_future) {
[09:29:16.421]                           ns <- base::getNamespace("future")
[09:29:16.421]                           version <- ns[[".package"]][["version"]]
[09:29:16.421]                           if (is.null(version)) 
[09:29:16.421]                             version <- utils::packageVersion("future")
[09:29:16.421]                         }
[09:29:16.421]                         else {
[09:29:16.421]                           version <- NULL
[09:29:16.421]                         }
[09:29:16.421]                         if (!has_future || version < "1.8.0") {
[09:29:16.421]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.421]                             "", base::R.version$version.string), 
[09:29:16.421]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.421]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.421]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.421]                               "release", "version")], collapse = " "), 
[09:29:16.421]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.421]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.421]                             info)
[09:29:16.421]                           info <- base::paste(info, collapse = "; ")
[09:29:16.421]                           if (!has_future) {
[09:29:16.421]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.421]                               info)
[09:29:16.421]                           }
[09:29:16.421]                           else {
[09:29:16.421]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.421]                               info, version)
[09:29:16.421]                           }
[09:29:16.421]                           base::stop(msg)
[09:29:16.421]                         }
[09:29:16.421]                       })
[09:29:16.421]                     }
[09:29:16.421]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.421]                     base::options(mc.cores = 1L)
[09:29:16.421]                   }
[09:29:16.421]                   ...future.strategy.old <- future::plan("list")
[09:29:16.421]                   options(future.plan = NULL)
[09:29:16.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.421]                 }
[09:29:16.421]                 ...future.workdir <- getwd()
[09:29:16.421]             }
[09:29:16.421]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.421]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.421]         }
[09:29:16.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.421]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:16.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.421]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.421]             base::names(...future.oldOptions))
[09:29:16.421]     }
[09:29:16.421]     if (FALSE) {
[09:29:16.421]     }
[09:29:16.421]     else {
[09:29:16.421]         if (TRUE) {
[09:29:16.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.421]                 open = "w")
[09:29:16.421]         }
[09:29:16.421]         else {
[09:29:16.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.421]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.421]         }
[09:29:16.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.421]             base::sink(type = "output", split = FALSE)
[09:29:16.421]             base::close(...future.stdout)
[09:29:16.421]         }, add = TRUE)
[09:29:16.421]     }
[09:29:16.421]     ...future.frame <- base::sys.nframe()
[09:29:16.421]     ...future.conditions <- base::list()
[09:29:16.421]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.421]     if (FALSE) {
[09:29:16.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.421]     }
[09:29:16.421]     ...future.result <- base::tryCatch({
[09:29:16.421]         base::withCallingHandlers({
[09:29:16.421]             ...future.value <- base::withVisible(base::local({
[09:29:16.421]                 withCallingHandlers({
[09:29:16.421]                   {
[09:29:16.421]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.421]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.421]                       ...future.globals.maxSize)) {
[09:29:16.421]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.421]                       on.exit(options(oopts), add = TRUE)
[09:29:16.421]                     }
[09:29:16.421]                     {
[09:29:16.421]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.421]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.421]                         USE.NAMES = FALSE)
[09:29:16.421]                       do.call(mapply, args = args)
[09:29:16.421]                     }
[09:29:16.421]                   }
[09:29:16.421]                 }, immediateCondition = function(cond) {
[09:29:16.421]                   save_rds <- function (object, pathname, ...) 
[09:29:16.421]                   {
[09:29:16.421]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.421]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.421]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.421]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.421]                         fi_tmp[["mtime"]])
[09:29:16.421]                     }
[09:29:16.421]                     tryCatch({
[09:29:16.421]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.421]                     }, error = function(ex) {
[09:29:16.421]                       msg <- conditionMessage(ex)
[09:29:16.421]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.421]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.421]                         fi_tmp[["mtime"]], msg)
[09:29:16.421]                       ex$message <- msg
[09:29:16.421]                       stop(ex)
[09:29:16.421]                     })
[09:29:16.421]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.421]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.421]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.421]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.421]                       fi <- file.info(pathname)
[09:29:16.421]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.421]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.421]                         fi[["size"]], fi[["mtime"]])
[09:29:16.421]                       stop(msg)
[09:29:16.421]                     }
[09:29:16.421]                     invisible(pathname)
[09:29:16.421]                   }
[09:29:16.421]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.421]                     rootPath = tempdir()) 
[09:29:16.421]                   {
[09:29:16.421]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.421]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.421]                       tmpdir = path, fileext = ".rds")
[09:29:16.421]                     save_rds(obj, file)
[09:29:16.421]                   }
[09:29:16.421]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.421]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.421]                   {
[09:29:16.421]                     inherits <- base::inherits
[09:29:16.421]                     invokeRestart <- base::invokeRestart
[09:29:16.421]                     is.null <- base::is.null
[09:29:16.421]                     muffled <- FALSE
[09:29:16.421]                     if (inherits(cond, "message")) {
[09:29:16.421]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.421]                       if (muffled) 
[09:29:16.421]                         invokeRestart("muffleMessage")
[09:29:16.421]                     }
[09:29:16.421]                     else if (inherits(cond, "warning")) {
[09:29:16.421]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.421]                       if (muffled) 
[09:29:16.421]                         invokeRestart("muffleWarning")
[09:29:16.421]                     }
[09:29:16.421]                     else if (inherits(cond, "condition")) {
[09:29:16.421]                       if (!is.null(pattern)) {
[09:29:16.421]                         computeRestarts <- base::computeRestarts
[09:29:16.421]                         grepl <- base::grepl
[09:29:16.421]                         restarts <- computeRestarts(cond)
[09:29:16.421]                         for (restart in restarts) {
[09:29:16.421]                           name <- restart$name
[09:29:16.421]                           if (is.null(name)) 
[09:29:16.421]                             next
[09:29:16.421]                           if (!grepl(pattern, name)) 
[09:29:16.421]                             next
[09:29:16.421]                           invokeRestart(restart)
[09:29:16.421]                           muffled <- TRUE
[09:29:16.421]                           break
[09:29:16.421]                         }
[09:29:16.421]                       }
[09:29:16.421]                     }
[09:29:16.421]                     invisible(muffled)
[09:29:16.421]                   }
[09:29:16.421]                   muffleCondition(cond)
[09:29:16.421]                 })
[09:29:16.421]             }))
[09:29:16.421]             future::FutureResult(value = ...future.value$value, 
[09:29:16.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.421]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.421]                     ...future.globalenv.names))
[09:29:16.421]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.421]         }, condition = base::local({
[09:29:16.421]             c <- base::c
[09:29:16.421]             inherits <- base::inherits
[09:29:16.421]             invokeRestart <- base::invokeRestart
[09:29:16.421]             length <- base::length
[09:29:16.421]             list <- base::list
[09:29:16.421]             seq.int <- base::seq.int
[09:29:16.421]             signalCondition <- base::signalCondition
[09:29:16.421]             sys.calls <- base::sys.calls
[09:29:16.421]             `[[` <- base::`[[`
[09:29:16.421]             `+` <- base::`+`
[09:29:16.421]             `<<-` <- base::`<<-`
[09:29:16.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.421]                   3L)]
[09:29:16.421]             }
[09:29:16.421]             function(cond) {
[09:29:16.421]                 is_error <- inherits(cond, "error")
[09:29:16.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.421]                   NULL)
[09:29:16.421]                 if (is_error) {
[09:29:16.421]                   sessionInformation <- function() {
[09:29:16.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.421]                       search = base::search(), system = base::Sys.info())
[09:29:16.421]                   }
[09:29:16.421]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.421]                     cond$call), session = sessionInformation(), 
[09:29:16.421]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.421]                   signalCondition(cond)
[09:29:16.421]                 }
[09:29:16.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.421]                 "immediateCondition"))) {
[09:29:16.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.421]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.421]                   if (TRUE && !signal) {
[09:29:16.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.421]                     {
[09:29:16.421]                       inherits <- base::inherits
[09:29:16.421]                       invokeRestart <- base::invokeRestart
[09:29:16.421]                       is.null <- base::is.null
[09:29:16.421]                       muffled <- FALSE
[09:29:16.421]                       if (inherits(cond, "message")) {
[09:29:16.421]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.421]                         if (muffled) 
[09:29:16.421]                           invokeRestart("muffleMessage")
[09:29:16.421]                       }
[09:29:16.421]                       else if (inherits(cond, "warning")) {
[09:29:16.421]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.421]                         if (muffled) 
[09:29:16.421]                           invokeRestart("muffleWarning")
[09:29:16.421]                       }
[09:29:16.421]                       else if (inherits(cond, "condition")) {
[09:29:16.421]                         if (!is.null(pattern)) {
[09:29:16.421]                           computeRestarts <- base::computeRestarts
[09:29:16.421]                           grepl <- base::grepl
[09:29:16.421]                           restarts <- computeRestarts(cond)
[09:29:16.421]                           for (restart in restarts) {
[09:29:16.421]                             name <- restart$name
[09:29:16.421]                             if (is.null(name)) 
[09:29:16.421]                               next
[09:29:16.421]                             if (!grepl(pattern, name)) 
[09:29:16.421]                               next
[09:29:16.421]                             invokeRestart(restart)
[09:29:16.421]                             muffled <- TRUE
[09:29:16.421]                             break
[09:29:16.421]                           }
[09:29:16.421]                         }
[09:29:16.421]                       }
[09:29:16.421]                       invisible(muffled)
[09:29:16.421]                     }
[09:29:16.421]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.421]                   }
[09:29:16.421]                 }
[09:29:16.421]                 else {
[09:29:16.421]                   if (TRUE) {
[09:29:16.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.421]                     {
[09:29:16.421]                       inherits <- base::inherits
[09:29:16.421]                       invokeRestart <- base::invokeRestart
[09:29:16.421]                       is.null <- base::is.null
[09:29:16.421]                       muffled <- FALSE
[09:29:16.421]                       if (inherits(cond, "message")) {
[09:29:16.421]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.421]                         if (muffled) 
[09:29:16.421]                           invokeRestart("muffleMessage")
[09:29:16.421]                       }
[09:29:16.421]                       else if (inherits(cond, "warning")) {
[09:29:16.421]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.421]                         if (muffled) 
[09:29:16.421]                           invokeRestart("muffleWarning")
[09:29:16.421]                       }
[09:29:16.421]                       else if (inherits(cond, "condition")) {
[09:29:16.421]                         if (!is.null(pattern)) {
[09:29:16.421]                           computeRestarts <- base::computeRestarts
[09:29:16.421]                           grepl <- base::grepl
[09:29:16.421]                           restarts <- computeRestarts(cond)
[09:29:16.421]                           for (restart in restarts) {
[09:29:16.421]                             name <- restart$name
[09:29:16.421]                             if (is.null(name)) 
[09:29:16.421]                               next
[09:29:16.421]                             if (!grepl(pattern, name)) 
[09:29:16.421]                               next
[09:29:16.421]                             invokeRestart(restart)
[09:29:16.421]                             muffled <- TRUE
[09:29:16.421]                             break
[09:29:16.421]                           }
[09:29:16.421]                         }
[09:29:16.421]                       }
[09:29:16.421]                       invisible(muffled)
[09:29:16.421]                     }
[09:29:16.421]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.421]                   }
[09:29:16.421]                 }
[09:29:16.421]             }
[09:29:16.421]         }))
[09:29:16.421]     }, error = function(ex) {
[09:29:16.421]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.421]                 ...future.rng), started = ...future.startTime, 
[09:29:16.421]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.421]             version = "1.8"), class = "FutureResult")
[09:29:16.421]     }, finally = {
[09:29:16.421]         if (!identical(...future.workdir, getwd())) 
[09:29:16.421]             setwd(...future.workdir)
[09:29:16.421]         {
[09:29:16.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.421]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.421]             }
[09:29:16.421]             base::options(...future.oldOptions)
[09:29:16.421]             if (.Platform$OS.type == "windows") {
[09:29:16.421]                 old_names <- names(...future.oldEnvVars)
[09:29:16.421]                 envs <- base::Sys.getenv()
[09:29:16.421]                 names <- names(envs)
[09:29:16.421]                 common <- intersect(names, old_names)
[09:29:16.421]                 added <- setdiff(names, old_names)
[09:29:16.421]                 removed <- setdiff(old_names, names)
[09:29:16.421]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.421]                   envs[common]]
[09:29:16.421]                 NAMES <- toupper(changed)
[09:29:16.421]                 args <- list()
[09:29:16.421]                 for (kk in seq_along(NAMES)) {
[09:29:16.421]                   name <- changed[[kk]]
[09:29:16.421]                   NAME <- NAMES[[kk]]
[09:29:16.421]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.421]                     next
[09:29:16.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.421]                 }
[09:29:16.421]                 NAMES <- toupper(added)
[09:29:16.421]                 for (kk in seq_along(NAMES)) {
[09:29:16.421]                   name <- added[[kk]]
[09:29:16.421]                   NAME <- NAMES[[kk]]
[09:29:16.421]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.421]                     next
[09:29:16.421]                   args[[name]] <- ""
[09:29:16.421]                 }
[09:29:16.421]                 NAMES <- toupper(removed)
[09:29:16.421]                 for (kk in seq_along(NAMES)) {
[09:29:16.421]                   name <- removed[[kk]]
[09:29:16.421]                   NAME <- NAMES[[kk]]
[09:29:16.421]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.421]                     next
[09:29:16.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.421]                 }
[09:29:16.421]                 if (length(args) > 0) 
[09:29:16.421]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.421]             }
[09:29:16.421]             else {
[09:29:16.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.421]             }
[09:29:16.421]             {
[09:29:16.421]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.421]                   0L) {
[09:29:16.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.421]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.421]                   base::options(opts)
[09:29:16.421]                 }
[09:29:16.421]                 {
[09:29:16.421]                   {
[09:29:16.421]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.421]                     NULL
[09:29:16.421]                   }
[09:29:16.421]                   options(future.plan = NULL)
[09:29:16.421]                   if (is.na(NA_character_)) 
[09:29:16.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.421]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.421]                     .init = FALSE)
[09:29:16.421]                 }
[09:29:16.421]             }
[09:29:16.421]         }
[09:29:16.421]     })
[09:29:16.421]     if (TRUE) {
[09:29:16.421]         base::sink(type = "output", split = FALSE)
[09:29:16.421]         if (TRUE) {
[09:29:16.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.421]         }
[09:29:16.421]         else {
[09:29:16.421]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.421]         }
[09:29:16.421]         base::close(...future.stdout)
[09:29:16.421]         ...future.stdout <- NULL
[09:29:16.421]     }
[09:29:16.421]     ...future.result$conditions <- ...future.conditions
[09:29:16.421]     ...future.result$finished <- base::Sys.time()
[09:29:16.421]     ...future.result
[09:29:16.421] }
[09:29:16.424] assign_globals() ...
[09:29:16.424] List of 5
[09:29:16.424]  $ ...future.FUN            :function (C, k)  
[09:29:16.424]  $ MoreArgs                 : list()
[09:29:16.424]  $ ...future.elements_ii    :List of 2
[09:29:16.424]   ..$ :List of 3
[09:29:16.424]   .. ..$ : chr "C"
[09:29:16.424]   .. ..$ : chr "D"
[09:29:16.424]   .. ..$ : chr "E"
[09:29:16.424]   ..$ :List of 3
[09:29:16.424]   .. ..$ : int 3
[09:29:16.424]   .. ..$ : int 2
[09:29:16.424]   .. ..$ : int 1
[09:29:16.424]  $ ...future.seeds_ii       : NULL
[09:29:16.424]  $ ...future.globals.maxSize: NULL
[09:29:16.424]  - attr(*, "where")=List of 5
[09:29:16.424]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.424]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.424]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.424]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.424]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.424]  - attr(*, "resolved")= logi FALSE
[09:29:16.424]  - attr(*, "total_size")= num 3824
[09:29:16.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.424]  - attr(*, "already-done")= logi TRUE
[09:29:16.431] - reassign environment for ‘...future.FUN’
[09:29:16.432] - copied ‘...future.FUN’ to environment
[09:29:16.432] - copied ‘MoreArgs’ to environment
[09:29:16.432] - copied ‘...future.elements_ii’ to environment
[09:29:16.432] - copied ‘...future.seeds_ii’ to environment
[09:29:16.432] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.432] assign_globals() ... done
[09:29:16.432] requestCore(): workers = 2
[09:29:16.435] MulticoreFuture started
[09:29:16.435] - Launch lazy future ... done
[09:29:16.435] run() for ‘MulticoreFuture’ ... done
[09:29:16.436] Created future:
[09:29:16.436] plan(): Setting new future strategy stack:
[09:29:16.436] List of future strategies:
[09:29:16.436] 1. sequential:
[09:29:16.436]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.436]    - tweaked: FALSE
[09:29:16.436]    - call: NULL
[09:29:16.437] plan(): nbrOfWorkers() = 1
[09:29:16.439] plan(): Setting new future strategy stack:
[09:29:16.439] List of future strategies:
[09:29:16.439] 1. multicore:
[09:29:16.439]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.439]    - tweaked: FALSE
[09:29:16.439]    - call: plan(strategy)
[09:29:16.444] plan(): nbrOfWorkers() = 2
[09:29:16.436] MulticoreFuture:
[09:29:16.436] Label: ‘future_.mapply-2’
[09:29:16.436] Expression:
[09:29:16.436] {
[09:29:16.436]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.436]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.436]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.436]         on.exit(options(oopts), add = TRUE)
[09:29:16.436]     }
[09:29:16.436]     {
[09:29:16.436]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.436]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.436]         do.call(mapply, args = args)
[09:29:16.436]     }
[09:29:16.436] }
[09:29:16.436] Lazy evaluation: FALSE
[09:29:16.436] Asynchronous evaluation: TRUE
[09:29:16.436] Local evaluation: TRUE
[09:29:16.436] Environment: R_GlobalEnv
[09:29:16.436] Capture standard output: TRUE
[09:29:16.436] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.436] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.436] Packages: <none>
[09:29:16.436] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.436] Resolved: TRUE
[09:29:16.436] Value: <not collected>
[09:29:16.436] Conditions captured: <none>
[09:29:16.436] Early signaling: FALSE
[09:29:16.436] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.436] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.445] Chunk #2 of 2 ... DONE
[09:29:16.445] Launching 2 futures (chunks) ... DONE
[09:29:16.445] Resolving 2 futures (chunks) ...
[09:29:16.446] resolve() on list ...
[09:29:16.446]  recursive: 0
[09:29:16.446]  length: 2
[09:29:16.446] 
[09:29:16.446] Future #1
[09:29:16.447] result() for MulticoreFuture ...
[09:29:16.448] result() for MulticoreFuture ...
[09:29:16.448] result() for MulticoreFuture ... done
[09:29:16.448] result() for MulticoreFuture ... done
[09:29:16.448] result() for MulticoreFuture ...
[09:29:16.448] result() for MulticoreFuture ... done
[09:29:16.448] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:16.449] - nx: 2
[09:29:16.449] - relay: TRUE
[09:29:16.449] - stdout: TRUE
[09:29:16.449] - signal: TRUE
[09:29:16.449] - resignal: FALSE
[09:29:16.449] - force: TRUE
[09:29:16.449] - relayed: [n=2] FALSE, FALSE
[09:29:16.450] - queued futures: [n=2] FALSE, FALSE
[09:29:16.450]  - until=1
[09:29:16.450]  - relaying element #1
[09:29:16.450] result() for MulticoreFuture ...
[09:29:16.450] result() for MulticoreFuture ... done
[09:29:16.450] result() for MulticoreFuture ...
[09:29:16.450] result() for MulticoreFuture ... done
[09:29:16.451] result() for MulticoreFuture ...
[09:29:16.451] result() for MulticoreFuture ... done
[09:29:16.455] result() for MulticoreFuture ...
[09:29:16.455] result() for MulticoreFuture ... done
[09:29:16.455] - relayed: [n=2] TRUE, FALSE
[09:29:16.456] - queued futures: [n=2] TRUE, FALSE
[09:29:16.456] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:16.457]  length: 1 (resolved future 1)
[09:29:16.457] Future #2
[09:29:16.458] result() for MulticoreFuture ...
[09:29:16.459] result() for MulticoreFuture ...
[09:29:16.459] result() for MulticoreFuture ... done
[09:29:16.459] result() for MulticoreFuture ... done
[09:29:16.460] result() for MulticoreFuture ...
[09:29:16.460] result() for MulticoreFuture ... done
[09:29:16.460] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:16.460] - nx: 2
[09:29:16.460] - relay: TRUE
[09:29:16.461] - stdout: TRUE
[09:29:16.461] - signal: TRUE
[09:29:16.461] - resignal: FALSE
[09:29:16.461] - force: TRUE
[09:29:16.461] - relayed: [n=2] TRUE, FALSE
[09:29:16.461] - queued futures: [n=2] TRUE, FALSE
[09:29:16.461]  - until=2
[09:29:16.462]  - relaying element #2
[09:29:16.462] result() for MulticoreFuture ...
[09:29:16.462] result() for MulticoreFuture ... done
[09:29:16.462] result() for MulticoreFuture ...
[09:29:16.462] result() for MulticoreFuture ... done
[09:29:16.462] result() for MulticoreFuture ...
[09:29:16.463] result() for MulticoreFuture ... done
[09:29:16.463] result() for MulticoreFuture ...
[09:29:16.463] result() for MulticoreFuture ... done
[09:29:16.463] - relayed: [n=2] TRUE, TRUE
[09:29:16.463] - queued futures: [n=2] TRUE, TRUE
[09:29:16.463] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:16.463]  length: 0 (resolved future 2)
[09:29:16.464] Relaying remaining futures
[09:29:16.464] signalConditionsASAP(NULL, pos=0) ...
[09:29:16.464] - nx: 2
[09:29:16.464] - relay: TRUE
[09:29:16.464] - stdout: TRUE
[09:29:16.464] - signal: TRUE
[09:29:16.464] - resignal: FALSE
[09:29:16.465] - force: TRUE
[09:29:16.465] - relayed: [n=2] TRUE, TRUE
[09:29:16.465] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:16.465] - relayed: [n=2] TRUE, TRUE
[09:29:16.465] - queued futures: [n=2] TRUE, TRUE
[09:29:16.465] signalConditionsASAP(NULL, pos=0) ... done
[09:29:16.465] resolve() on list ... DONE
[09:29:16.466] result() for MulticoreFuture ...
[09:29:16.466] result() for MulticoreFuture ... done
[09:29:16.466] result() for MulticoreFuture ...
[09:29:16.466] result() for MulticoreFuture ... done
[09:29:16.466] result() for MulticoreFuture ...
[09:29:16.466] result() for MulticoreFuture ... done
[09:29:16.466] result() for MulticoreFuture ...
[09:29:16.466] result() for MulticoreFuture ... done
[09:29:16.466]  - Number of value chunks collected: 2
[09:29:16.467] Resolving 2 futures (chunks) ... DONE
[09:29:16.467] Reducing values from 2 chunks ...
[09:29:16.467]  - Number of values collected after concatenation: 5
[09:29:16.467]  - Number of values expected: 5
[09:29:16.467] Reducing values from 2 chunks ... DONE
[09:29:16.467] future_mapply() ... DONE
[09:29:16.467] future_mapply() ...
[09:29:16.471] Number of chunks: 2
[09:29:16.472] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[09:29:16.472] getGlobalsAndPackagesXApply() ...
[09:29:16.472]  - future.globals: TRUE
[09:29:16.472] getGlobalsAndPackages() ...
[09:29:16.472] Searching for globals...
[09:29:16.473] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:16.474] Searching for globals ... DONE
[09:29:16.474] Resolving globals: FALSE
[09:29:16.474] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:16.475] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:16.475] - globals: [1] ‘FUN’
[09:29:16.475] 
[09:29:16.475] getGlobalsAndPackages() ... DONE
[09:29:16.475]  - globals found/used: [n=1] ‘FUN’
[09:29:16.475]  - needed namespaces: [n=0] 
[09:29:16.475] Finding globals ... DONE
[09:29:16.475] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:16.475] List of 2
[09:29:16.475]  $ ...future.FUN:function (C, k)  
[09:29:16.475]  $ MoreArgs     : NULL
[09:29:16.475]  - attr(*, "where")=List of 2
[09:29:16.475]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:16.475]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:16.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.475]  - attr(*, "resolved")= logi FALSE
[09:29:16.475]  - attr(*, "total_size")= num NA
[09:29:16.478] Packages to be attached in all futures: [n=0] 
[09:29:16.478] getGlobalsAndPackagesXApply() ... DONE
[09:29:16.478] Number of futures (= number of chunks): 2
[09:29:16.479] Launching 2 futures (chunks) ...
[09:29:16.479] Chunk #1 of 2 ...
[09:29:16.479]  - Finding globals in '...' for chunk #1 ...
[09:29:16.479] getGlobalsAndPackages() ...
[09:29:16.479] Searching for globals...
[09:29:16.479] 
[09:29:16.479] Searching for globals ... DONE
[09:29:16.479] - globals: [0] <none>
[09:29:16.480] getGlobalsAndPackages() ... DONE
[09:29:16.480]    + additional globals found: [n=0] 
[09:29:16.480]    + additional namespaces needed: [n=0] 
[09:29:16.480]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:16.480]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:16.480]  - seeds: <none>
[09:29:16.480]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.480] getGlobalsAndPackages() ...
[09:29:16.480] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.481] Resolving globals: FALSE
[09:29:16.481] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:16.481] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:16.482] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.482] 
[09:29:16.482] getGlobalsAndPackages() ... DONE
[09:29:16.482] run() for ‘Future’ ...
[09:29:16.482] - state: ‘created’
[09:29:16.482] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.486] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.486] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.488]   - Field: ‘label’
[09:29:16.488]   - Field: ‘local’
[09:29:16.489]   - Field: ‘owner’
[09:29:16.489]   - Field: ‘envir’
[09:29:16.489]   - Field: ‘workers’
[09:29:16.489]   - Field: ‘packages’
[09:29:16.489]   - Field: ‘gc’
[09:29:16.489]   - Field: ‘job’
[09:29:16.489]   - Field: ‘conditions’
[09:29:16.489]   - Field: ‘expr’
[09:29:16.489]   - Field: ‘uuid’
[09:29:16.490]   - Field: ‘seed’
[09:29:16.490]   - Field: ‘version’
[09:29:16.490]   - Field: ‘result’
[09:29:16.490]   - Field: ‘asynchronous’
[09:29:16.490]   - Field: ‘calls’
[09:29:16.490]   - Field: ‘globals’
[09:29:16.490]   - Field: ‘stdout’
[09:29:16.490]   - Field: ‘earlySignal’
[09:29:16.490]   - Field: ‘lazy’
[09:29:16.490]   - Field: ‘state’
[09:29:16.491] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.491] - Launch lazy future ...
[09:29:16.491] Packages needed by the future expression (n = 0): <none>
[09:29:16.491] Packages needed by future strategies (n = 0): <none>
[09:29:16.492] {
[09:29:16.492]     {
[09:29:16.492]         {
[09:29:16.492]             ...future.startTime <- base::Sys.time()
[09:29:16.492]             {
[09:29:16.492]                 {
[09:29:16.492]                   {
[09:29:16.492]                     {
[09:29:16.492]                       base::local({
[09:29:16.492]                         has_future <- base::requireNamespace("future", 
[09:29:16.492]                           quietly = TRUE)
[09:29:16.492]                         if (has_future) {
[09:29:16.492]                           ns <- base::getNamespace("future")
[09:29:16.492]                           version <- ns[[".package"]][["version"]]
[09:29:16.492]                           if (is.null(version)) 
[09:29:16.492]                             version <- utils::packageVersion("future")
[09:29:16.492]                         }
[09:29:16.492]                         else {
[09:29:16.492]                           version <- NULL
[09:29:16.492]                         }
[09:29:16.492]                         if (!has_future || version < "1.8.0") {
[09:29:16.492]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.492]                             "", base::R.version$version.string), 
[09:29:16.492]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.492]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.492]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.492]                               "release", "version")], collapse = " "), 
[09:29:16.492]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.492]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.492]                             info)
[09:29:16.492]                           info <- base::paste(info, collapse = "; ")
[09:29:16.492]                           if (!has_future) {
[09:29:16.492]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.492]                               info)
[09:29:16.492]                           }
[09:29:16.492]                           else {
[09:29:16.492]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.492]                               info, version)
[09:29:16.492]                           }
[09:29:16.492]                           base::stop(msg)
[09:29:16.492]                         }
[09:29:16.492]                       })
[09:29:16.492]                     }
[09:29:16.492]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.492]                     base::options(mc.cores = 1L)
[09:29:16.492]                   }
[09:29:16.492]                   ...future.strategy.old <- future::plan("list")
[09:29:16.492]                   options(future.plan = NULL)
[09:29:16.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.492]                 }
[09:29:16.492]                 ...future.workdir <- getwd()
[09:29:16.492]             }
[09:29:16.492]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.492]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.492]         }
[09:29:16.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.492]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:16.492]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.492]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.492]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.492]             base::names(...future.oldOptions))
[09:29:16.492]     }
[09:29:16.492]     if (FALSE) {
[09:29:16.492]     }
[09:29:16.492]     else {
[09:29:16.492]         if (TRUE) {
[09:29:16.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.492]                 open = "w")
[09:29:16.492]         }
[09:29:16.492]         else {
[09:29:16.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.492]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.492]         }
[09:29:16.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.492]             base::sink(type = "output", split = FALSE)
[09:29:16.492]             base::close(...future.stdout)
[09:29:16.492]         }, add = TRUE)
[09:29:16.492]     }
[09:29:16.492]     ...future.frame <- base::sys.nframe()
[09:29:16.492]     ...future.conditions <- base::list()
[09:29:16.492]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.492]     if (FALSE) {
[09:29:16.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.492]     }
[09:29:16.492]     ...future.result <- base::tryCatch({
[09:29:16.492]         base::withCallingHandlers({
[09:29:16.492]             ...future.value <- base::withVisible(base::local({
[09:29:16.492]                 withCallingHandlers({
[09:29:16.492]                   {
[09:29:16.492]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.492]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.492]                       ...future.globals.maxSize)) {
[09:29:16.492]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.492]                       on.exit(options(oopts), add = TRUE)
[09:29:16.492]                     }
[09:29:16.492]                     {
[09:29:16.492]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.492]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.492]                         USE.NAMES = FALSE)
[09:29:16.492]                       do.call(mapply, args = args)
[09:29:16.492]                     }
[09:29:16.492]                   }
[09:29:16.492]                 }, immediateCondition = function(cond) {
[09:29:16.492]                   save_rds <- function (object, pathname, ...) 
[09:29:16.492]                   {
[09:29:16.492]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.492]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.492]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.492]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.492]                         fi_tmp[["mtime"]])
[09:29:16.492]                     }
[09:29:16.492]                     tryCatch({
[09:29:16.492]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.492]                     }, error = function(ex) {
[09:29:16.492]                       msg <- conditionMessage(ex)
[09:29:16.492]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.492]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.492]                         fi_tmp[["mtime"]], msg)
[09:29:16.492]                       ex$message <- msg
[09:29:16.492]                       stop(ex)
[09:29:16.492]                     })
[09:29:16.492]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.492]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.492]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.492]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.492]                       fi <- file.info(pathname)
[09:29:16.492]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.492]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.492]                         fi[["size"]], fi[["mtime"]])
[09:29:16.492]                       stop(msg)
[09:29:16.492]                     }
[09:29:16.492]                     invisible(pathname)
[09:29:16.492]                   }
[09:29:16.492]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.492]                     rootPath = tempdir()) 
[09:29:16.492]                   {
[09:29:16.492]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.492]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.492]                       tmpdir = path, fileext = ".rds")
[09:29:16.492]                     save_rds(obj, file)
[09:29:16.492]                   }
[09:29:16.492]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.492]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.492]                   {
[09:29:16.492]                     inherits <- base::inherits
[09:29:16.492]                     invokeRestart <- base::invokeRestart
[09:29:16.492]                     is.null <- base::is.null
[09:29:16.492]                     muffled <- FALSE
[09:29:16.492]                     if (inherits(cond, "message")) {
[09:29:16.492]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.492]                       if (muffled) 
[09:29:16.492]                         invokeRestart("muffleMessage")
[09:29:16.492]                     }
[09:29:16.492]                     else if (inherits(cond, "warning")) {
[09:29:16.492]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.492]                       if (muffled) 
[09:29:16.492]                         invokeRestart("muffleWarning")
[09:29:16.492]                     }
[09:29:16.492]                     else if (inherits(cond, "condition")) {
[09:29:16.492]                       if (!is.null(pattern)) {
[09:29:16.492]                         computeRestarts <- base::computeRestarts
[09:29:16.492]                         grepl <- base::grepl
[09:29:16.492]                         restarts <- computeRestarts(cond)
[09:29:16.492]                         for (restart in restarts) {
[09:29:16.492]                           name <- restart$name
[09:29:16.492]                           if (is.null(name)) 
[09:29:16.492]                             next
[09:29:16.492]                           if (!grepl(pattern, name)) 
[09:29:16.492]                             next
[09:29:16.492]                           invokeRestart(restart)
[09:29:16.492]                           muffled <- TRUE
[09:29:16.492]                           break
[09:29:16.492]                         }
[09:29:16.492]                       }
[09:29:16.492]                     }
[09:29:16.492]                     invisible(muffled)
[09:29:16.492]                   }
[09:29:16.492]                   muffleCondition(cond)
[09:29:16.492]                 })
[09:29:16.492]             }))
[09:29:16.492]             future::FutureResult(value = ...future.value$value, 
[09:29:16.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.492]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.492]                     ...future.globalenv.names))
[09:29:16.492]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.492]         }, condition = base::local({
[09:29:16.492]             c <- base::c
[09:29:16.492]             inherits <- base::inherits
[09:29:16.492]             invokeRestart <- base::invokeRestart
[09:29:16.492]             length <- base::length
[09:29:16.492]             list <- base::list
[09:29:16.492]             seq.int <- base::seq.int
[09:29:16.492]             signalCondition <- base::signalCondition
[09:29:16.492]             sys.calls <- base::sys.calls
[09:29:16.492]             `[[` <- base::`[[`
[09:29:16.492]             `+` <- base::`+`
[09:29:16.492]             `<<-` <- base::`<<-`
[09:29:16.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.492]                   3L)]
[09:29:16.492]             }
[09:29:16.492]             function(cond) {
[09:29:16.492]                 is_error <- inherits(cond, "error")
[09:29:16.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.492]                   NULL)
[09:29:16.492]                 if (is_error) {
[09:29:16.492]                   sessionInformation <- function() {
[09:29:16.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.492]                       search = base::search(), system = base::Sys.info())
[09:29:16.492]                   }
[09:29:16.492]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.492]                     cond$call), session = sessionInformation(), 
[09:29:16.492]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.492]                   signalCondition(cond)
[09:29:16.492]                 }
[09:29:16.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.492]                 "immediateCondition"))) {
[09:29:16.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.492]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.492]                   if (TRUE && !signal) {
[09:29:16.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.492]                     {
[09:29:16.492]                       inherits <- base::inherits
[09:29:16.492]                       invokeRestart <- base::invokeRestart
[09:29:16.492]                       is.null <- base::is.null
[09:29:16.492]                       muffled <- FALSE
[09:29:16.492]                       if (inherits(cond, "message")) {
[09:29:16.492]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.492]                         if (muffled) 
[09:29:16.492]                           invokeRestart("muffleMessage")
[09:29:16.492]                       }
[09:29:16.492]                       else if (inherits(cond, "warning")) {
[09:29:16.492]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.492]                         if (muffled) 
[09:29:16.492]                           invokeRestart("muffleWarning")
[09:29:16.492]                       }
[09:29:16.492]                       else if (inherits(cond, "condition")) {
[09:29:16.492]                         if (!is.null(pattern)) {
[09:29:16.492]                           computeRestarts <- base::computeRestarts
[09:29:16.492]                           grepl <- base::grepl
[09:29:16.492]                           restarts <- computeRestarts(cond)
[09:29:16.492]                           for (restart in restarts) {
[09:29:16.492]                             name <- restart$name
[09:29:16.492]                             if (is.null(name)) 
[09:29:16.492]                               next
[09:29:16.492]                             if (!grepl(pattern, name)) 
[09:29:16.492]                               next
[09:29:16.492]                             invokeRestart(restart)
[09:29:16.492]                             muffled <- TRUE
[09:29:16.492]                             break
[09:29:16.492]                           }
[09:29:16.492]                         }
[09:29:16.492]                       }
[09:29:16.492]                       invisible(muffled)
[09:29:16.492]                     }
[09:29:16.492]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.492]                   }
[09:29:16.492]                 }
[09:29:16.492]                 else {
[09:29:16.492]                   if (TRUE) {
[09:29:16.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.492]                     {
[09:29:16.492]                       inherits <- base::inherits
[09:29:16.492]                       invokeRestart <- base::invokeRestart
[09:29:16.492]                       is.null <- base::is.null
[09:29:16.492]                       muffled <- FALSE
[09:29:16.492]                       if (inherits(cond, "message")) {
[09:29:16.492]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.492]                         if (muffled) 
[09:29:16.492]                           invokeRestart("muffleMessage")
[09:29:16.492]                       }
[09:29:16.492]                       else if (inherits(cond, "warning")) {
[09:29:16.492]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.492]                         if (muffled) 
[09:29:16.492]                           invokeRestart("muffleWarning")
[09:29:16.492]                       }
[09:29:16.492]                       else if (inherits(cond, "condition")) {
[09:29:16.492]                         if (!is.null(pattern)) {
[09:29:16.492]                           computeRestarts <- base::computeRestarts
[09:29:16.492]                           grepl <- base::grepl
[09:29:16.492]                           restarts <- computeRestarts(cond)
[09:29:16.492]                           for (restart in restarts) {
[09:29:16.492]                             name <- restart$name
[09:29:16.492]                             if (is.null(name)) 
[09:29:16.492]                               next
[09:29:16.492]                             if (!grepl(pattern, name)) 
[09:29:16.492]                               next
[09:29:16.492]                             invokeRestart(restart)
[09:29:16.492]                             muffled <- TRUE
[09:29:16.492]                             break
[09:29:16.492]                           }
[09:29:16.492]                         }
[09:29:16.492]                       }
[09:29:16.492]                       invisible(muffled)
[09:29:16.492]                     }
[09:29:16.492]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.492]                   }
[09:29:16.492]                 }
[09:29:16.492]             }
[09:29:16.492]         }))
[09:29:16.492]     }, error = function(ex) {
[09:29:16.492]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.492]                 ...future.rng), started = ...future.startTime, 
[09:29:16.492]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.492]             version = "1.8"), class = "FutureResult")
[09:29:16.492]     }, finally = {
[09:29:16.492]         if (!identical(...future.workdir, getwd())) 
[09:29:16.492]             setwd(...future.workdir)
[09:29:16.492]         {
[09:29:16.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.492]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.492]             }
[09:29:16.492]             base::options(...future.oldOptions)
[09:29:16.492]             if (.Platform$OS.type == "windows") {
[09:29:16.492]                 old_names <- names(...future.oldEnvVars)
[09:29:16.492]                 envs <- base::Sys.getenv()
[09:29:16.492]                 names <- names(envs)
[09:29:16.492]                 common <- intersect(names, old_names)
[09:29:16.492]                 added <- setdiff(names, old_names)
[09:29:16.492]                 removed <- setdiff(old_names, names)
[09:29:16.492]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.492]                   envs[common]]
[09:29:16.492]                 NAMES <- toupper(changed)
[09:29:16.492]                 args <- list()
[09:29:16.492]                 for (kk in seq_along(NAMES)) {
[09:29:16.492]                   name <- changed[[kk]]
[09:29:16.492]                   NAME <- NAMES[[kk]]
[09:29:16.492]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.492]                     next
[09:29:16.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.492]                 }
[09:29:16.492]                 NAMES <- toupper(added)
[09:29:16.492]                 for (kk in seq_along(NAMES)) {
[09:29:16.492]                   name <- added[[kk]]
[09:29:16.492]                   NAME <- NAMES[[kk]]
[09:29:16.492]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.492]                     next
[09:29:16.492]                   args[[name]] <- ""
[09:29:16.492]                 }
[09:29:16.492]                 NAMES <- toupper(removed)
[09:29:16.492]                 for (kk in seq_along(NAMES)) {
[09:29:16.492]                   name <- removed[[kk]]
[09:29:16.492]                   NAME <- NAMES[[kk]]
[09:29:16.492]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.492]                     next
[09:29:16.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.492]                 }
[09:29:16.492]                 if (length(args) > 0) 
[09:29:16.492]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.492]             }
[09:29:16.492]             else {
[09:29:16.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.492]             }
[09:29:16.492]             {
[09:29:16.492]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.492]                   0L) {
[09:29:16.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.492]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.492]                   base::options(opts)
[09:29:16.492]                 }
[09:29:16.492]                 {
[09:29:16.492]                   {
[09:29:16.492]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.492]                     NULL
[09:29:16.492]                   }
[09:29:16.492]                   options(future.plan = NULL)
[09:29:16.492]                   if (is.na(NA_character_)) 
[09:29:16.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.492]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.492]                     .init = FALSE)
[09:29:16.492]                 }
[09:29:16.492]             }
[09:29:16.492]         }
[09:29:16.492]     })
[09:29:16.492]     if (TRUE) {
[09:29:16.492]         base::sink(type = "output", split = FALSE)
[09:29:16.492]         if (TRUE) {
[09:29:16.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.492]         }
[09:29:16.492]         else {
[09:29:16.492]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.492]         }
[09:29:16.492]         base::close(...future.stdout)
[09:29:16.492]         ...future.stdout <- NULL
[09:29:16.492]     }
[09:29:16.492]     ...future.result$conditions <- ...future.conditions
[09:29:16.492]     ...future.result$finished <- base::Sys.time()
[09:29:16.492]     ...future.result
[09:29:16.492] }
[09:29:16.494] assign_globals() ...
[09:29:16.494] List of 5
[09:29:16.494]  $ ...future.FUN            :function (C, k)  
[09:29:16.494]  $ MoreArgs                 : NULL
[09:29:16.494]  $ ...future.elements_ii    :List of 2
[09:29:16.494]   ..$ :List of 2
[09:29:16.494]   .. ..$ : chr "E"
[09:29:16.494]   .. ..$ : chr "D"
[09:29:16.494]   ..$ :List of 2
[09:29:16.494]   .. ..$ : int 1
[09:29:16.494]   .. ..$ : int 2
[09:29:16.494]  $ ...future.seeds_ii       : NULL
[09:29:16.494]  $ ...future.globals.maxSize: NULL
[09:29:16.494]  - attr(*, "where")=List of 5
[09:29:16.494]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.494]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.494]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.494]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.494]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.494]  - attr(*, "resolved")= logi FALSE
[09:29:16.494]  - attr(*, "total_size")= num 3656
[09:29:16.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.494]  - attr(*, "already-done")= logi TRUE
[09:29:16.500] - reassign environment for ‘...future.FUN’
[09:29:16.500] - copied ‘...future.FUN’ to environment
[09:29:16.500] - copied ‘MoreArgs’ to environment
[09:29:16.500] - copied ‘...future.elements_ii’ to environment
[09:29:16.500] - copied ‘...future.seeds_ii’ to environment
[09:29:16.500] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.500] assign_globals() ... done
[09:29:16.500] requestCore(): workers = 2
[09:29:16.502] MulticoreFuture started
[09:29:16.503] - Launch lazy future ... done
[09:29:16.503] run() for ‘MulticoreFuture’ ... done
[09:29:16.503] Created future:
[09:29:16.503] plan(): Setting new future strategy stack:
[09:29:16.504] List of future strategies:
[09:29:16.504] 1. sequential:
[09:29:16.504]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.504]    - tweaked: FALSE
[09:29:16.504]    - call: NULL
[09:29:16.505] plan(): nbrOfWorkers() = 1
[09:29:16.507] plan(): Setting new future strategy stack:
[09:29:16.507] List of future strategies:
[09:29:16.507] 1. multicore:
[09:29:16.507]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.507]    - tweaked: FALSE
[09:29:16.507]    - call: plan(strategy)
[09:29:16.512] plan(): nbrOfWorkers() = 2
[09:29:16.503] MulticoreFuture:
[09:29:16.503] Label: ‘future_mapply-1’
[09:29:16.503] Expression:
[09:29:16.503] {
[09:29:16.503]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.503]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.503]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.503]         on.exit(options(oopts), add = TRUE)
[09:29:16.503]     }
[09:29:16.503]     {
[09:29:16.503]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.503]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.503]         do.call(mapply, args = args)
[09:29:16.503]     }
[09:29:16.503] }
[09:29:16.503] Lazy evaluation: FALSE
[09:29:16.503] Asynchronous evaluation: TRUE
[09:29:16.503] Local evaluation: TRUE
[09:29:16.503] Environment: R_GlobalEnv
[09:29:16.503] Capture standard output: TRUE
[09:29:16.503] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.503] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.503] Packages: <none>
[09:29:16.503] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.503] Resolved: TRUE
[09:29:16.503] Value: <not collected>
[09:29:16.503] Conditions captured: <none>
[09:29:16.503] Early signaling: FALSE
[09:29:16.503] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.503] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.513] Chunk #1 of 2 ... DONE
[09:29:16.513] Chunk #2 of 2 ...
[09:29:16.513]  - Finding globals in '...' for chunk #2 ...
[09:29:16.513] getGlobalsAndPackages() ...
[09:29:16.513] Searching for globals...
[09:29:16.514] 
[09:29:16.514] Searching for globals ... DONE
[09:29:16.514] - globals: [0] <none>
[09:29:16.514] getGlobalsAndPackages() ... DONE
[09:29:16.514]    + additional globals found: [n=0] 
[09:29:16.515]    + additional namespaces needed: [n=0] 
[09:29:16.515]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:16.515]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:16.515]  - seeds: <none>
[09:29:16.515]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.515] getGlobalsAndPackages() ...
[09:29:16.515] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.516] Resolving globals: FALSE
[09:29:16.517] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[09:29:16.517] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:16.517] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.518] 
[09:29:16.518] getGlobalsAndPackages() ... DONE
[09:29:16.518] run() for ‘Future’ ...
[09:29:16.518] - state: ‘created’
[09:29:16.519] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.523] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.524] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.524]   - Field: ‘label’
[09:29:16.524]   - Field: ‘local’
[09:29:16.524]   - Field: ‘owner’
[09:29:16.524]   - Field: ‘envir’
[09:29:16.524]   - Field: ‘workers’
[09:29:16.525]   - Field: ‘packages’
[09:29:16.525]   - Field: ‘gc’
[09:29:16.525]   - Field: ‘job’
[09:29:16.525]   - Field: ‘conditions’
[09:29:16.525]   - Field: ‘expr’
[09:29:16.525]   - Field: ‘uuid’
[09:29:16.525]   - Field: ‘seed’
[09:29:16.526]   - Field: ‘version’
[09:29:16.526]   - Field: ‘result’
[09:29:16.526]   - Field: ‘asynchronous’
[09:29:16.526]   - Field: ‘calls’
[09:29:16.526]   - Field: ‘globals’
[09:29:16.526]   - Field: ‘stdout’
[09:29:16.527]   - Field: ‘earlySignal’
[09:29:16.527]   - Field: ‘lazy’
[09:29:16.527]   - Field: ‘state’
[09:29:16.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.527] - Launch lazy future ...
[09:29:16.528] Packages needed by the future expression (n = 0): <none>
[09:29:16.528] Packages needed by future strategies (n = 0): <none>
[09:29:16.533] {
[09:29:16.533]     {
[09:29:16.533]         {
[09:29:16.533]             ...future.startTime <- base::Sys.time()
[09:29:16.533]             {
[09:29:16.533]                 {
[09:29:16.533]                   {
[09:29:16.533]                     {
[09:29:16.533]                       base::local({
[09:29:16.533]                         has_future <- base::requireNamespace("future", 
[09:29:16.533]                           quietly = TRUE)
[09:29:16.533]                         if (has_future) {
[09:29:16.533]                           ns <- base::getNamespace("future")
[09:29:16.533]                           version <- ns[[".package"]][["version"]]
[09:29:16.533]                           if (is.null(version)) 
[09:29:16.533]                             version <- utils::packageVersion("future")
[09:29:16.533]                         }
[09:29:16.533]                         else {
[09:29:16.533]                           version <- NULL
[09:29:16.533]                         }
[09:29:16.533]                         if (!has_future || version < "1.8.0") {
[09:29:16.533]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.533]                             "", base::R.version$version.string), 
[09:29:16.533]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.533]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.533]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.533]                               "release", "version")], collapse = " "), 
[09:29:16.533]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.533]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.533]                             info)
[09:29:16.533]                           info <- base::paste(info, collapse = "; ")
[09:29:16.533]                           if (!has_future) {
[09:29:16.533]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.533]                               info)
[09:29:16.533]                           }
[09:29:16.533]                           else {
[09:29:16.533]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.533]                               info, version)
[09:29:16.533]                           }
[09:29:16.533]                           base::stop(msg)
[09:29:16.533]                         }
[09:29:16.533]                       })
[09:29:16.533]                     }
[09:29:16.533]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.533]                     base::options(mc.cores = 1L)
[09:29:16.533]                   }
[09:29:16.533]                   ...future.strategy.old <- future::plan("list")
[09:29:16.533]                   options(future.plan = NULL)
[09:29:16.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.533]                 }
[09:29:16.533]                 ...future.workdir <- getwd()
[09:29:16.533]             }
[09:29:16.533]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.533]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.533]         }
[09:29:16.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.533]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:16.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.533]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.533]             base::names(...future.oldOptions))
[09:29:16.533]     }
[09:29:16.533]     if (FALSE) {
[09:29:16.533]     }
[09:29:16.533]     else {
[09:29:16.533]         if (TRUE) {
[09:29:16.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.533]                 open = "w")
[09:29:16.533]         }
[09:29:16.533]         else {
[09:29:16.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.533]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.533]         }
[09:29:16.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.533]             base::sink(type = "output", split = FALSE)
[09:29:16.533]             base::close(...future.stdout)
[09:29:16.533]         }, add = TRUE)
[09:29:16.533]     }
[09:29:16.533]     ...future.frame <- base::sys.nframe()
[09:29:16.533]     ...future.conditions <- base::list()
[09:29:16.533]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.533]     if (FALSE) {
[09:29:16.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.533]     }
[09:29:16.533]     ...future.result <- base::tryCatch({
[09:29:16.533]         base::withCallingHandlers({
[09:29:16.533]             ...future.value <- base::withVisible(base::local({
[09:29:16.533]                 withCallingHandlers({
[09:29:16.533]                   {
[09:29:16.533]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.533]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.533]                       ...future.globals.maxSize)) {
[09:29:16.533]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.533]                       on.exit(options(oopts), add = TRUE)
[09:29:16.533]                     }
[09:29:16.533]                     {
[09:29:16.533]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.533]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.533]                         USE.NAMES = FALSE)
[09:29:16.533]                       do.call(mapply, args = args)
[09:29:16.533]                     }
[09:29:16.533]                   }
[09:29:16.533]                 }, immediateCondition = function(cond) {
[09:29:16.533]                   save_rds <- function (object, pathname, ...) 
[09:29:16.533]                   {
[09:29:16.533]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.533]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.533]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.533]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.533]                         fi_tmp[["mtime"]])
[09:29:16.533]                     }
[09:29:16.533]                     tryCatch({
[09:29:16.533]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.533]                     }, error = function(ex) {
[09:29:16.533]                       msg <- conditionMessage(ex)
[09:29:16.533]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.533]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.533]                         fi_tmp[["mtime"]], msg)
[09:29:16.533]                       ex$message <- msg
[09:29:16.533]                       stop(ex)
[09:29:16.533]                     })
[09:29:16.533]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.533]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.533]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.533]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.533]                       fi <- file.info(pathname)
[09:29:16.533]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.533]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.533]                         fi[["size"]], fi[["mtime"]])
[09:29:16.533]                       stop(msg)
[09:29:16.533]                     }
[09:29:16.533]                     invisible(pathname)
[09:29:16.533]                   }
[09:29:16.533]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.533]                     rootPath = tempdir()) 
[09:29:16.533]                   {
[09:29:16.533]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.533]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.533]                       tmpdir = path, fileext = ".rds")
[09:29:16.533]                     save_rds(obj, file)
[09:29:16.533]                   }
[09:29:16.533]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.533]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.533]                   {
[09:29:16.533]                     inherits <- base::inherits
[09:29:16.533]                     invokeRestart <- base::invokeRestart
[09:29:16.533]                     is.null <- base::is.null
[09:29:16.533]                     muffled <- FALSE
[09:29:16.533]                     if (inherits(cond, "message")) {
[09:29:16.533]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.533]                       if (muffled) 
[09:29:16.533]                         invokeRestart("muffleMessage")
[09:29:16.533]                     }
[09:29:16.533]                     else if (inherits(cond, "warning")) {
[09:29:16.533]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.533]                       if (muffled) 
[09:29:16.533]                         invokeRestart("muffleWarning")
[09:29:16.533]                     }
[09:29:16.533]                     else if (inherits(cond, "condition")) {
[09:29:16.533]                       if (!is.null(pattern)) {
[09:29:16.533]                         computeRestarts <- base::computeRestarts
[09:29:16.533]                         grepl <- base::grepl
[09:29:16.533]                         restarts <- computeRestarts(cond)
[09:29:16.533]                         for (restart in restarts) {
[09:29:16.533]                           name <- restart$name
[09:29:16.533]                           if (is.null(name)) 
[09:29:16.533]                             next
[09:29:16.533]                           if (!grepl(pattern, name)) 
[09:29:16.533]                             next
[09:29:16.533]                           invokeRestart(restart)
[09:29:16.533]                           muffled <- TRUE
[09:29:16.533]                           break
[09:29:16.533]                         }
[09:29:16.533]                       }
[09:29:16.533]                     }
[09:29:16.533]                     invisible(muffled)
[09:29:16.533]                   }
[09:29:16.533]                   muffleCondition(cond)
[09:29:16.533]                 })
[09:29:16.533]             }))
[09:29:16.533]             future::FutureResult(value = ...future.value$value, 
[09:29:16.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.533]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.533]                     ...future.globalenv.names))
[09:29:16.533]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.533]         }, condition = base::local({
[09:29:16.533]             c <- base::c
[09:29:16.533]             inherits <- base::inherits
[09:29:16.533]             invokeRestart <- base::invokeRestart
[09:29:16.533]             length <- base::length
[09:29:16.533]             list <- base::list
[09:29:16.533]             seq.int <- base::seq.int
[09:29:16.533]             signalCondition <- base::signalCondition
[09:29:16.533]             sys.calls <- base::sys.calls
[09:29:16.533]             `[[` <- base::`[[`
[09:29:16.533]             `+` <- base::`+`
[09:29:16.533]             `<<-` <- base::`<<-`
[09:29:16.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.533]                   3L)]
[09:29:16.533]             }
[09:29:16.533]             function(cond) {
[09:29:16.533]                 is_error <- inherits(cond, "error")
[09:29:16.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.533]                   NULL)
[09:29:16.533]                 if (is_error) {
[09:29:16.533]                   sessionInformation <- function() {
[09:29:16.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.533]                       search = base::search(), system = base::Sys.info())
[09:29:16.533]                   }
[09:29:16.533]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.533]                     cond$call), session = sessionInformation(), 
[09:29:16.533]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.533]                   signalCondition(cond)
[09:29:16.533]                 }
[09:29:16.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.533]                 "immediateCondition"))) {
[09:29:16.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.533]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.533]                   if (TRUE && !signal) {
[09:29:16.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.533]                     {
[09:29:16.533]                       inherits <- base::inherits
[09:29:16.533]                       invokeRestart <- base::invokeRestart
[09:29:16.533]                       is.null <- base::is.null
[09:29:16.533]                       muffled <- FALSE
[09:29:16.533]                       if (inherits(cond, "message")) {
[09:29:16.533]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.533]                         if (muffled) 
[09:29:16.533]                           invokeRestart("muffleMessage")
[09:29:16.533]                       }
[09:29:16.533]                       else if (inherits(cond, "warning")) {
[09:29:16.533]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.533]                         if (muffled) 
[09:29:16.533]                           invokeRestart("muffleWarning")
[09:29:16.533]                       }
[09:29:16.533]                       else if (inherits(cond, "condition")) {
[09:29:16.533]                         if (!is.null(pattern)) {
[09:29:16.533]                           computeRestarts <- base::computeRestarts
[09:29:16.533]                           grepl <- base::grepl
[09:29:16.533]                           restarts <- computeRestarts(cond)
[09:29:16.533]                           for (restart in restarts) {
[09:29:16.533]                             name <- restart$name
[09:29:16.533]                             if (is.null(name)) 
[09:29:16.533]                               next
[09:29:16.533]                             if (!grepl(pattern, name)) 
[09:29:16.533]                               next
[09:29:16.533]                             invokeRestart(restart)
[09:29:16.533]                             muffled <- TRUE
[09:29:16.533]                             break
[09:29:16.533]                           }
[09:29:16.533]                         }
[09:29:16.533]                       }
[09:29:16.533]                       invisible(muffled)
[09:29:16.533]                     }
[09:29:16.533]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.533]                   }
[09:29:16.533]                 }
[09:29:16.533]                 else {
[09:29:16.533]                   if (TRUE) {
[09:29:16.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.533]                     {
[09:29:16.533]                       inherits <- base::inherits
[09:29:16.533]                       invokeRestart <- base::invokeRestart
[09:29:16.533]                       is.null <- base::is.null
[09:29:16.533]                       muffled <- FALSE
[09:29:16.533]                       if (inherits(cond, "message")) {
[09:29:16.533]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.533]                         if (muffled) 
[09:29:16.533]                           invokeRestart("muffleMessage")
[09:29:16.533]                       }
[09:29:16.533]                       else if (inherits(cond, "warning")) {
[09:29:16.533]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.533]                         if (muffled) 
[09:29:16.533]                           invokeRestart("muffleWarning")
[09:29:16.533]                       }
[09:29:16.533]                       else if (inherits(cond, "condition")) {
[09:29:16.533]                         if (!is.null(pattern)) {
[09:29:16.533]                           computeRestarts <- base::computeRestarts
[09:29:16.533]                           grepl <- base::grepl
[09:29:16.533]                           restarts <- computeRestarts(cond)
[09:29:16.533]                           for (restart in restarts) {
[09:29:16.533]                             name <- restart$name
[09:29:16.533]                             if (is.null(name)) 
[09:29:16.533]                               next
[09:29:16.533]                             if (!grepl(pattern, name)) 
[09:29:16.533]                               next
[09:29:16.533]                             invokeRestart(restart)
[09:29:16.533]                             muffled <- TRUE
[09:29:16.533]                             break
[09:29:16.533]                           }
[09:29:16.533]                         }
[09:29:16.533]                       }
[09:29:16.533]                       invisible(muffled)
[09:29:16.533]                     }
[09:29:16.533]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.533]                   }
[09:29:16.533]                 }
[09:29:16.533]             }
[09:29:16.533]         }))
[09:29:16.533]     }, error = function(ex) {
[09:29:16.533]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.533]                 ...future.rng), started = ...future.startTime, 
[09:29:16.533]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.533]             version = "1.8"), class = "FutureResult")
[09:29:16.533]     }, finally = {
[09:29:16.533]         if (!identical(...future.workdir, getwd())) 
[09:29:16.533]             setwd(...future.workdir)
[09:29:16.533]         {
[09:29:16.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.533]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.533]             }
[09:29:16.533]             base::options(...future.oldOptions)
[09:29:16.533]             if (.Platform$OS.type == "windows") {
[09:29:16.533]                 old_names <- names(...future.oldEnvVars)
[09:29:16.533]                 envs <- base::Sys.getenv()
[09:29:16.533]                 names <- names(envs)
[09:29:16.533]                 common <- intersect(names, old_names)
[09:29:16.533]                 added <- setdiff(names, old_names)
[09:29:16.533]                 removed <- setdiff(old_names, names)
[09:29:16.533]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.533]                   envs[common]]
[09:29:16.533]                 NAMES <- toupper(changed)
[09:29:16.533]                 args <- list()
[09:29:16.533]                 for (kk in seq_along(NAMES)) {
[09:29:16.533]                   name <- changed[[kk]]
[09:29:16.533]                   NAME <- NAMES[[kk]]
[09:29:16.533]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.533]                     next
[09:29:16.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.533]                 }
[09:29:16.533]                 NAMES <- toupper(added)
[09:29:16.533]                 for (kk in seq_along(NAMES)) {
[09:29:16.533]                   name <- added[[kk]]
[09:29:16.533]                   NAME <- NAMES[[kk]]
[09:29:16.533]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.533]                     next
[09:29:16.533]                   args[[name]] <- ""
[09:29:16.533]                 }
[09:29:16.533]                 NAMES <- toupper(removed)
[09:29:16.533]                 for (kk in seq_along(NAMES)) {
[09:29:16.533]                   name <- removed[[kk]]
[09:29:16.533]                   NAME <- NAMES[[kk]]
[09:29:16.533]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.533]                     next
[09:29:16.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.533]                 }
[09:29:16.533]                 if (length(args) > 0) 
[09:29:16.533]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.533]             }
[09:29:16.533]             else {
[09:29:16.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.533]             }
[09:29:16.533]             {
[09:29:16.533]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.533]                   0L) {
[09:29:16.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.533]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.533]                   base::options(opts)
[09:29:16.533]                 }
[09:29:16.533]                 {
[09:29:16.533]                   {
[09:29:16.533]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.533]                     NULL
[09:29:16.533]                   }
[09:29:16.533]                   options(future.plan = NULL)
[09:29:16.533]                   if (is.na(NA_character_)) 
[09:29:16.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.533]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.533]                     .init = FALSE)
[09:29:16.533]                 }
[09:29:16.533]             }
[09:29:16.533]         }
[09:29:16.533]     })
[09:29:16.533]     if (TRUE) {
[09:29:16.533]         base::sink(type = "output", split = FALSE)
[09:29:16.533]         if (TRUE) {
[09:29:16.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.533]         }
[09:29:16.533]         else {
[09:29:16.533]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.533]         }
[09:29:16.533]         base::close(...future.stdout)
[09:29:16.533]         ...future.stdout <- NULL
[09:29:16.533]     }
[09:29:16.533]     ...future.result$conditions <- ...future.conditions
[09:29:16.533]     ...future.result$finished <- base::Sys.time()
[09:29:16.533]     ...future.result
[09:29:16.533] }
[09:29:16.536] assign_globals() ...
[09:29:16.536] List of 5
[09:29:16.536]  $ ...future.FUN            :function (C, k)  
[09:29:16.536]  $ MoreArgs                 : NULL
[09:29:16.536]  $ ...future.elements_ii    :List of 2
[09:29:16.536]   ..$ :List of 3
[09:29:16.536]   .. ..$ : chr "C"
[09:29:16.536]   .. ..$ : chr "B"
[09:29:16.536]   .. ..$ : chr "A"
[09:29:16.536]   ..$ :List of 3
[09:29:16.536]   .. ..$ : int 3
[09:29:16.536]   .. ..$ : int 4
[09:29:16.536]   .. ..$ : int 5
[09:29:16.536]  $ ...future.seeds_ii       : NULL
[09:29:16.536]  $ ...future.globals.maxSize: NULL
[09:29:16.536]  - attr(*, "where")=List of 5
[09:29:16.536]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.536]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.536]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.536]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.536]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.536]  - attr(*, "resolved")= logi FALSE
[09:29:16.536]  - attr(*, "total_size")= num 3824
[09:29:16.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.536]  - attr(*, "already-done")= logi TRUE
[09:29:16.547] - reassign environment for ‘...future.FUN’
[09:29:16.547] - copied ‘...future.FUN’ to environment
[09:29:16.547] - copied ‘MoreArgs’ to environment
[09:29:16.548] - copied ‘...future.elements_ii’ to environment
[09:29:16.548] - copied ‘...future.seeds_ii’ to environment
[09:29:16.548] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.548] assign_globals() ... done
[09:29:16.548] requestCore(): workers = 2
[09:29:16.550] MulticoreFuture started
[09:29:16.550] - Launch lazy future ... done
[09:29:16.551] run() for ‘MulticoreFuture’ ... done
[09:29:16.551] Created future:
[09:29:16.551] plan(): Setting new future strategy stack:
[09:29:16.552] List of future strategies:
[09:29:16.552] 1. sequential:
[09:29:16.552]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.552]    - tweaked: FALSE
[09:29:16.552]    - call: NULL
[09:29:16.553] plan(): nbrOfWorkers() = 1
[09:29:16.555] plan(): Setting new future strategy stack:
[09:29:16.555] List of future strategies:
[09:29:16.555] 1. multicore:
[09:29:16.555]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.555]    - tweaked: FALSE
[09:29:16.555]    - call: plan(strategy)
[09:29:16.560] plan(): nbrOfWorkers() = 2
[09:29:16.551] MulticoreFuture:
[09:29:16.551] Label: ‘future_mapply-2’
[09:29:16.551] Expression:
[09:29:16.551] {
[09:29:16.551]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.551]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.551]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.551]         on.exit(options(oopts), add = TRUE)
[09:29:16.551]     }
[09:29:16.551]     {
[09:29:16.551]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.551]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.551]         do.call(mapply, args = args)
[09:29:16.551]     }
[09:29:16.551] }
[09:29:16.551] Lazy evaluation: FALSE
[09:29:16.551] Asynchronous evaluation: TRUE
[09:29:16.551] Local evaluation: TRUE
[09:29:16.551] Environment: R_GlobalEnv
[09:29:16.551] Capture standard output: TRUE
[09:29:16.551] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.551] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.551] Packages: <none>
[09:29:16.551] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.551] Resolved: TRUE
[09:29:16.551] Value: <not collected>
[09:29:16.551] Conditions captured: <none>
[09:29:16.551] Early signaling: FALSE
[09:29:16.551] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.551] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.561] Chunk #2 of 2 ... DONE
[09:29:16.561] Launching 2 futures (chunks) ... DONE
[09:29:16.561] Resolving 2 futures (chunks) ...
[09:29:16.562] resolve() on list ...
[09:29:16.562]  recursive: 0
[09:29:16.562]  length: 2
[09:29:16.562] 
[09:29:16.562] Future #1
[09:29:16.562] result() for MulticoreFuture ...
[09:29:16.563] result() for MulticoreFuture ...
[09:29:16.564] result() for MulticoreFuture ... done
[09:29:16.564] result() for MulticoreFuture ... done
[09:29:16.564] result() for MulticoreFuture ...
[09:29:16.564] result() for MulticoreFuture ... done
[09:29:16.564] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:16.564] - nx: 2
[09:29:16.564] - relay: TRUE
[09:29:16.565] - stdout: TRUE
[09:29:16.565] - signal: TRUE
[09:29:16.565] - resignal: FALSE
[09:29:16.565] - force: TRUE
[09:29:16.565] - relayed: [n=2] FALSE, FALSE
[09:29:16.565] - queued futures: [n=2] FALSE, FALSE
[09:29:16.565]  - until=1
[09:29:16.565]  - relaying element #1
[09:29:16.566] result() for MulticoreFuture ...
[09:29:16.566] result() for MulticoreFuture ... done
[09:29:16.566] result() for MulticoreFuture ...
[09:29:16.566] result() for MulticoreFuture ... done
[09:29:16.566] result() for MulticoreFuture ...
[09:29:16.566] result() for MulticoreFuture ... done
[09:29:16.567] result() for MulticoreFuture ...
[09:29:16.567] result() for MulticoreFuture ... done
[09:29:16.567] - relayed: [n=2] TRUE, FALSE
[09:29:16.567] - queued futures: [n=2] TRUE, FALSE
[09:29:16.567] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:16.567]  length: 1 (resolved future 1)
[09:29:16.568] Future #2
[09:29:16.568] result() for MulticoreFuture ...
[09:29:16.569] result() for MulticoreFuture ...
[09:29:16.569] result() for MulticoreFuture ... done
[09:29:16.569] result() for MulticoreFuture ... done
[09:29:16.569] result() for MulticoreFuture ...
[09:29:16.569] result() for MulticoreFuture ... done
[09:29:16.569] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:16.570] - nx: 2
[09:29:16.570] - relay: TRUE
[09:29:16.570] - stdout: TRUE
[09:29:16.570] - signal: TRUE
[09:29:16.570] - resignal: FALSE
[09:29:16.570] - force: TRUE
[09:29:16.570] - relayed: [n=2] TRUE, FALSE
[09:29:16.570] - queued futures: [n=2] TRUE, FALSE
[09:29:16.571]  - until=2
[09:29:16.571]  - relaying element #2
[09:29:16.571] result() for MulticoreFuture ...
[09:29:16.571] result() for MulticoreFuture ... done
[09:29:16.571] result() for MulticoreFuture ...
[09:29:16.571] result() for MulticoreFuture ... done
[09:29:16.571] result() for MulticoreFuture ...
[09:29:16.571] result() for MulticoreFuture ... done
[09:29:16.572] result() for MulticoreFuture ...
[09:29:16.572] result() for MulticoreFuture ... done
[09:29:16.572] - relayed: [n=2] TRUE, TRUE
[09:29:16.572] - queued futures: [n=2] TRUE, TRUE
[09:29:16.572] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:16.572]  length: 0 (resolved future 2)
[09:29:16.572] Relaying remaining futures
[09:29:16.572] signalConditionsASAP(NULL, pos=0) ...
[09:29:16.572] - nx: 2
[09:29:16.573] - relay: TRUE
[09:29:16.573] - stdout: TRUE
[09:29:16.573] - signal: TRUE
[09:29:16.573] - resignal: FALSE
[09:29:16.573] - force: TRUE
[09:29:16.573] - relayed: [n=2] TRUE, TRUE
[09:29:16.573] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:16.573] - relayed: [n=2] TRUE, TRUE
[09:29:16.574] - queued futures: [n=2] TRUE, TRUE
[09:29:16.574] signalConditionsASAP(NULL, pos=0) ... done
[09:29:16.574] resolve() on list ... DONE
[09:29:16.574] result() for MulticoreFuture ...
[09:29:16.574] result() for MulticoreFuture ... done
[09:29:16.574] result() for MulticoreFuture ...
[09:29:16.574] result() for MulticoreFuture ... done
[09:29:16.574] result() for MulticoreFuture ...
[09:29:16.574] result() for MulticoreFuture ... done
[09:29:16.575] result() for MulticoreFuture ...
[09:29:16.575] result() for MulticoreFuture ... done
[09:29:16.575]  - Number of value chunks collected: 2
[09:29:16.575] Resolving 2 futures (chunks) ... DONE
[09:29:16.578] Reducing values from 2 chunks ...
[09:29:16.578]  - Number of values collected after concatenation: 5
[09:29:16.578]  - Number of values expected: 5
[09:29:16.578] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[09:29:16.579] Reducing values from 2 chunks ... DONE
[09:29:16.579] future_mapply() ... DONE
[09:29:16.579] future_mapply() ...
[09:29:16.584] Number of chunks: 2
[09:29:16.584] getGlobalsAndPackagesXApply() ...
[09:29:16.584]  - future.globals: TRUE
[09:29:16.584] getGlobalsAndPackages() ...
[09:29:16.584] Searching for globals...
[09:29:16.586] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:16.586] Searching for globals ... DONE
[09:29:16.586] Resolving globals: FALSE
[09:29:16.587] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:16.587] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:16.587] - globals: [1] ‘FUN’
[09:29:16.588] 
[09:29:16.588] getGlobalsAndPackages() ... DONE
[09:29:16.588]  - globals found/used: [n=1] ‘FUN’
[09:29:16.588]  - needed namespaces: [n=0] 
[09:29:16.588] Finding globals ... DONE
[09:29:16.588] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:16.588] List of 2
[09:29:16.588]  $ ...future.FUN:function (C, k)  
[09:29:16.588]  $ MoreArgs     : list()
[09:29:16.588]  - attr(*, "where")=List of 2
[09:29:16.588]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:16.588]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:16.588]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.588]  - attr(*, "resolved")= logi FALSE
[09:29:16.588]  - attr(*, "total_size")= num NA
[09:29:16.591] Packages to be attached in all futures: [n=0] 
[09:29:16.591] getGlobalsAndPackagesXApply() ... DONE
[09:29:16.591] Number of futures (= number of chunks): 2
[09:29:16.592] Launching 2 futures (chunks) ...
[09:29:16.592] Chunk #1 of 2 ...
[09:29:16.592]  - Finding globals in '...' for chunk #1 ...
[09:29:16.592] getGlobalsAndPackages() ...
[09:29:16.592] Searching for globals...
[09:29:16.592] 
[09:29:16.592] Searching for globals ... DONE
[09:29:16.593] - globals: [0] <none>
[09:29:16.593] getGlobalsAndPackages() ... DONE
[09:29:16.593]    + additional globals found: [n=0] 
[09:29:16.593]    + additional namespaces needed: [n=0] 
[09:29:16.593]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:16.593]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:16.593]  - seeds: <none>
[09:29:16.593]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.593] getGlobalsAndPackages() ...
[09:29:16.593] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.594] Resolving globals: FALSE
[09:29:16.594] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:16.594] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:16.595] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.595] 
[09:29:16.595] getGlobalsAndPackages() ... DONE
[09:29:16.595] run() for ‘Future’ ...
[09:29:16.595] - state: ‘created’
[09:29:16.595] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.599] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.599] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.599]   - Field: ‘label’
[09:29:16.599]   - Field: ‘local’
[09:29:16.599]   - Field: ‘owner’
[09:29:16.599]   - Field: ‘envir’
[09:29:16.599]   - Field: ‘workers’
[09:29:16.600]   - Field: ‘packages’
[09:29:16.600]   - Field: ‘gc’
[09:29:16.600]   - Field: ‘job’
[09:29:16.600]   - Field: ‘conditions’
[09:29:16.600]   - Field: ‘expr’
[09:29:16.600]   - Field: ‘uuid’
[09:29:16.600]   - Field: ‘seed’
[09:29:16.600]   - Field: ‘version’
[09:29:16.600]   - Field: ‘result’
[09:29:16.600]   - Field: ‘asynchronous’
[09:29:16.601]   - Field: ‘calls’
[09:29:16.601]   - Field: ‘globals’
[09:29:16.601]   - Field: ‘stdout’
[09:29:16.601]   - Field: ‘earlySignal’
[09:29:16.601]   - Field: ‘lazy’
[09:29:16.601]   - Field: ‘state’
[09:29:16.601] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.601] - Launch lazy future ...
[09:29:16.601] Packages needed by the future expression (n = 0): <none>
[09:29:16.602] Packages needed by future strategies (n = 0): <none>
[09:29:16.602] {
[09:29:16.602]     {
[09:29:16.602]         {
[09:29:16.602]             ...future.startTime <- base::Sys.time()
[09:29:16.602]             {
[09:29:16.602]                 {
[09:29:16.602]                   {
[09:29:16.602]                     {
[09:29:16.602]                       base::local({
[09:29:16.602]                         has_future <- base::requireNamespace("future", 
[09:29:16.602]                           quietly = TRUE)
[09:29:16.602]                         if (has_future) {
[09:29:16.602]                           ns <- base::getNamespace("future")
[09:29:16.602]                           version <- ns[[".package"]][["version"]]
[09:29:16.602]                           if (is.null(version)) 
[09:29:16.602]                             version <- utils::packageVersion("future")
[09:29:16.602]                         }
[09:29:16.602]                         else {
[09:29:16.602]                           version <- NULL
[09:29:16.602]                         }
[09:29:16.602]                         if (!has_future || version < "1.8.0") {
[09:29:16.602]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.602]                             "", base::R.version$version.string), 
[09:29:16.602]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.602]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.602]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.602]                               "release", "version")], collapse = " "), 
[09:29:16.602]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.602]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.602]                             info)
[09:29:16.602]                           info <- base::paste(info, collapse = "; ")
[09:29:16.602]                           if (!has_future) {
[09:29:16.602]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.602]                               info)
[09:29:16.602]                           }
[09:29:16.602]                           else {
[09:29:16.602]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.602]                               info, version)
[09:29:16.602]                           }
[09:29:16.602]                           base::stop(msg)
[09:29:16.602]                         }
[09:29:16.602]                       })
[09:29:16.602]                     }
[09:29:16.602]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.602]                     base::options(mc.cores = 1L)
[09:29:16.602]                   }
[09:29:16.602]                   ...future.strategy.old <- future::plan("list")
[09:29:16.602]                   options(future.plan = NULL)
[09:29:16.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.602]                 }
[09:29:16.602]                 ...future.workdir <- getwd()
[09:29:16.602]             }
[09:29:16.602]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.602]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.602]         }
[09:29:16.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.602]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:16.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.602]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.602]             base::names(...future.oldOptions))
[09:29:16.602]     }
[09:29:16.602]     if (FALSE) {
[09:29:16.602]     }
[09:29:16.602]     else {
[09:29:16.602]         if (TRUE) {
[09:29:16.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.602]                 open = "w")
[09:29:16.602]         }
[09:29:16.602]         else {
[09:29:16.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.602]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.602]         }
[09:29:16.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.602]             base::sink(type = "output", split = FALSE)
[09:29:16.602]             base::close(...future.stdout)
[09:29:16.602]         }, add = TRUE)
[09:29:16.602]     }
[09:29:16.602]     ...future.frame <- base::sys.nframe()
[09:29:16.602]     ...future.conditions <- base::list()
[09:29:16.602]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.602]     if (FALSE) {
[09:29:16.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.602]     }
[09:29:16.602]     ...future.result <- base::tryCatch({
[09:29:16.602]         base::withCallingHandlers({
[09:29:16.602]             ...future.value <- base::withVisible(base::local({
[09:29:16.602]                 withCallingHandlers({
[09:29:16.602]                   {
[09:29:16.602]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.602]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.602]                       ...future.globals.maxSize)) {
[09:29:16.602]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.602]                       on.exit(options(oopts), add = TRUE)
[09:29:16.602]                     }
[09:29:16.602]                     {
[09:29:16.602]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.602]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.602]                         USE.NAMES = FALSE)
[09:29:16.602]                       do.call(mapply, args = args)
[09:29:16.602]                     }
[09:29:16.602]                   }
[09:29:16.602]                 }, immediateCondition = function(cond) {
[09:29:16.602]                   save_rds <- function (object, pathname, ...) 
[09:29:16.602]                   {
[09:29:16.602]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.602]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.602]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.602]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.602]                         fi_tmp[["mtime"]])
[09:29:16.602]                     }
[09:29:16.602]                     tryCatch({
[09:29:16.602]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.602]                     }, error = function(ex) {
[09:29:16.602]                       msg <- conditionMessage(ex)
[09:29:16.602]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.602]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.602]                         fi_tmp[["mtime"]], msg)
[09:29:16.602]                       ex$message <- msg
[09:29:16.602]                       stop(ex)
[09:29:16.602]                     })
[09:29:16.602]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.602]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.602]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.602]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.602]                       fi <- file.info(pathname)
[09:29:16.602]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.602]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.602]                         fi[["size"]], fi[["mtime"]])
[09:29:16.602]                       stop(msg)
[09:29:16.602]                     }
[09:29:16.602]                     invisible(pathname)
[09:29:16.602]                   }
[09:29:16.602]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.602]                     rootPath = tempdir()) 
[09:29:16.602]                   {
[09:29:16.602]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.602]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.602]                       tmpdir = path, fileext = ".rds")
[09:29:16.602]                     save_rds(obj, file)
[09:29:16.602]                   }
[09:29:16.602]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.602]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.602]                   {
[09:29:16.602]                     inherits <- base::inherits
[09:29:16.602]                     invokeRestart <- base::invokeRestart
[09:29:16.602]                     is.null <- base::is.null
[09:29:16.602]                     muffled <- FALSE
[09:29:16.602]                     if (inherits(cond, "message")) {
[09:29:16.602]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.602]                       if (muffled) 
[09:29:16.602]                         invokeRestart("muffleMessage")
[09:29:16.602]                     }
[09:29:16.602]                     else if (inherits(cond, "warning")) {
[09:29:16.602]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.602]                       if (muffled) 
[09:29:16.602]                         invokeRestart("muffleWarning")
[09:29:16.602]                     }
[09:29:16.602]                     else if (inherits(cond, "condition")) {
[09:29:16.602]                       if (!is.null(pattern)) {
[09:29:16.602]                         computeRestarts <- base::computeRestarts
[09:29:16.602]                         grepl <- base::grepl
[09:29:16.602]                         restarts <- computeRestarts(cond)
[09:29:16.602]                         for (restart in restarts) {
[09:29:16.602]                           name <- restart$name
[09:29:16.602]                           if (is.null(name)) 
[09:29:16.602]                             next
[09:29:16.602]                           if (!grepl(pattern, name)) 
[09:29:16.602]                             next
[09:29:16.602]                           invokeRestart(restart)
[09:29:16.602]                           muffled <- TRUE
[09:29:16.602]                           break
[09:29:16.602]                         }
[09:29:16.602]                       }
[09:29:16.602]                     }
[09:29:16.602]                     invisible(muffled)
[09:29:16.602]                   }
[09:29:16.602]                   muffleCondition(cond)
[09:29:16.602]                 })
[09:29:16.602]             }))
[09:29:16.602]             future::FutureResult(value = ...future.value$value, 
[09:29:16.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.602]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.602]                     ...future.globalenv.names))
[09:29:16.602]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.602]         }, condition = base::local({
[09:29:16.602]             c <- base::c
[09:29:16.602]             inherits <- base::inherits
[09:29:16.602]             invokeRestart <- base::invokeRestart
[09:29:16.602]             length <- base::length
[09:29:16.602]             list <- base::list
[09:29:16.602]             seq.int <- base::seq.int
[09:29:16.602]             signalCondition <- base::signalCondition
[09:29:16.602]             sys.calls <- base::sys.calls
[09:29:16.602]             `[[` <- base::`[[`
[09:29:16.602]             `+` <- base::`+`
[09:29:16.602]             `<<-` <- base::`<<-`
[09:29:16.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.602]                   3L)]
[09:29:16.602]             }
[09:29:16.602]             function(cond) {
[09:29:16.602]                 is_error <- inherits(cond, "error")
[09:29:16.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.602]                   NULL)
[09:29:16.602]                 if (is_error) {
[09:29:16.602]                   sessionInformation <- function() {
[09:29:16.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.602]                       search = base::search(), system = base::Sys.info())
[09:29:16.602]                   }
[09:29:16.602]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.602]                     cond$call), session = sessionInformation(), 
[09:29:16.602]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.602]                   signalCondition(cond)
[09:29:16.602]                 }
[09:29:16.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.602]                 "immediateCondition"))) {
[09:29:16.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.602]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.602]                   if (TRUE && !signal) {
[09:29:16.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.602]                     {
[09:29:16.602]                       inherits <- base::inherits
[09:29:16.602]                       invokeRestart <- base::invokeRestart
[09:29:16.602]                       is.null <- base::is.null
[09:29:16.602]                       muffled <- FALSE
[09:29:16.602]                       if (inherits(cond, "message")) {
[09:29:16.602]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.602]                         if (muffled) 
[09:29:16.602]                           invokeRestart("muffleMessage")
[09:29:16.602]                       }
[09:29:16.602]                       else if (inherits(cond, "warning")) {
[09:29:16.602]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.602]                         if (muffled) 
[09:29:16.602]                           invokeRestart("muffleWarning")
[09:29:16.602]                       }
[09:29:16.602]                       else if (inherits(cond, "condition")) {
[09:29:16.602]                         if (!is.null(pattern)) {
[09:29:16.602]                           computeRestarts <- base::computeRestarts
[09:29:16.602]                           grepl <- base::grepl
[09:29:16.602]                           restarts <- computeRestarts(cond)
[09:29:16.602]                           for (restart in restarts) {
[09:29:16.602]                             name <- restart$name
[09:29:16.602]                             if (is.null(name)) 
[09:29:16.602]                               next
[09:29:16.602]                             if (!grepl(pattern, name)) 
[09:29:16.602]                               next
[09:29:16.602]                             invokeRestart(restart)
[09:29:16.602]                             muffled <- TRUE
[09:29:16.602]                             break
[09:29:16.602]                           }
[09:29:16.602]                         }
[09:29:16.602]                       }
[09:29:16.602]                       invisible(muffled)
[09:29:16.602]                     }
[09:29:16.602]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.602]                   }
[09:29:16.602]                 }
[09:29:16.602]                 else {
[09:29:16.602]                   if (TRUE) {
[09:29:16.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.602]                     {
[09:29:16.602]                       inherits <- base::inherits
[09:29:16.602]                       invokeRestart <- base::invokeRestart
[09:29:16.602]                       is.null <- base::is.null
[09:29:16.602]                       muffled <- FALSE
[09:29:16.602]                       if (inherits(cond, "message")) {
[09:29:16.602]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.602]                         if (muffled) 
[09:29:16.602]                           invokeRestart("muffleMessage")
[09:29:16.602]                       }
[09:29:16.602]                       else if (inherits(cond, "warning")) {
[09:29:16.602]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.602]                         if (muffled) 
[09:29:16.602]                           invokeRestart("muffleWarning")
[09:29:16.602]                       }
[09:29:16.602]                       else if (inherits(cond, "condition")) {
[09:29:16.602]                         if (!is.null(pattern)) {
[09:29:16.602]                           computeRestarts <- base::computeRestarts
[09:29:16.602]                           grepl <- base::grepl
[09:29:16.602]                           restarts <- computeRestarts(cond)
[09:29:16.602]                           for (restart in restarts) {
[09:29:16.602]                             name <- restart$name
[09:29:16.602]                             if (is.null(name)) 
[09:29:16.602]                               next
[09:29:16.602]                             if (!grepl(pattern, name)) 
[09:29:16.602]                               next
[09:29:16.602]                             invokeRestart(restart)
[09:29:16.602]                             muffled <- TRUE
[09:29:16.602]                             break
[09:29:16.602]                           }
[09:29:16.602]                         }
[09:29:16.602]                       }
[09:29:16.602]                       invisible(muffled)
[09:29:16.602]                     }
[09:29:16.602]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.602]                   }
[09:29:16.602]                 }
[09:29:16.602]             }
[09:29:16.602]         }))
[09:29:16.602]     }, error = function(ex) {
[09:29:16.602]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.602]                 ...future.rng), started = ...future.startTime, 
[09:29:16.602]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.602]             version = "1.8"), class = "FutureResult")
[09:29:16.602]     }, finally = {
[09:29:16.602]         if (!identical(...future.workdir, getwd())) 
[09:29:16.602]             setwd(...future.workdir)
[09:29:16.602]         {
[09:29:16.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.602]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.602]             }
[09:29:16.602]             base::options(...future.oldOptions)
[09:29:16.602]             if (.Platform$OS.type == "windows") {
[09:29:16.602]                 old_names <- names(...future.oldEnvVars)
[09:29:16.602]                 envs <- base::Sys.getenv()
[09:29:16.602]                 names <- names(envs)
[09:29:16.602]                 common <- intersect(names, old_names)
[09:29:16.602]                 added <- setdiff(names, old_names)
[09:29:16.602]                 removed <- setdiff(old_names, names)
[09:29:16.602]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.602]                   envs[common]]
[09:29:16.602]                 NAMES <- toupper(changed)
[09:29:16.602]                 args <- list()
[09:29:16.602]                 for (kk in seq_along(NAMES)) {
[09:29:16.602]                   name <- changed[[kk]]
[09:29:16.602]                   NAME <- NAMES[[kk]]
[09:29:16.602]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.602]                     next
[09:29:16.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.602]                 }
[09:29:16.602]                 NAMES <- toupper(added)
[09:29:16.602]                 for (kk in seq_along(NAMES)) {
[09:29:16.602]                   name <- added[[kk]]
[09:29:16.602]                   NAME <- NAMES[[kk]]
[09:29:16.602]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.602]                     next
[09:29:16.602]                   args[[name]] <- ""
[09:29:16.602]                 }
[09:29:16.602]                 NAMES <- toupper(removed)
[09:29:16.602]                 for (kk in seq_along(NAMES)) {
[09:29:16.602]                   name <- removed[[kk]]
[09:29:16.602]                   NAME <- NAMES[[kk]]
[09:29:16.602]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.602]                     next
[09:29:16.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.602]                 }
[09:29:16.602]                 if (length(args) > 0) 
[09:29:16.602]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.602]             }
[09:29:16.602]             else {
[09:29:16.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.602]             }
[09:29:16.602]             {
[09:29:16.602]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.602]                   0L) {
[09:29:16.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.602]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.602]                   base::options(opts)
[09:29:16.602]                 }
[09:29:16.602]                 {
[09:29:16.602]                   {
[09:29:16.602]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.602]                     NULL
[09:29:16.602]                   }
[09:29:16.602]                   options(future.plan = NULL)
[09:29:16.602]                   if (is.na(NA_character_)) 
[09:29:16.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.602]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.602]                     .init = FALSE)
[09:29:16.602]                 }
[09:29:16.602]             }
[09:29:16.602]         }
[09:29:16.602]     })
[09:29:16.602]     if (TRUE) {
[09:29:16.602]         base::sink(type = "output", split = FALSE)
[09:29:16.602]         if (TRUE) {
[09:29:16.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.602]         }
[09:29:16.602]         else {
[09:29:16.602]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.602]         }
[09:29:16.602]         base::close(...future.stdout)
[09:29:16.602]         ...future.stdout <- NULL
[09:29:16.602]     }
[09:29:16.602]     ...future.result$conditions <- ...future.conditions
[09:29:16.602]     ...future.result$finished <- base::Sys.time()
[09:29:16.602]     ...future.result
[09:29:16.602] }
[09:29:16.604] assign_globals() ...
[09:29:16.604] List of 5
[09:29:16.604]  $ ...future.FUN            :function (C, k)  
[09:29:16.604]  $ MoreArgs                 : list()
[09:29:16.604]  $ ...future.elements_ii    :List of 2
[09:29:16.604]   ..$ :List of 2
[09:29:16.604]   .. ..$ : chr "A"
[09:29:16.604]   .. ..$ : chr "B"
[09:29:16.604]   ..$ :List of 2
[09:29:16.604]   .. ..$ : int 5
[09:29:16.604]   .. ..$ : int 4
[09:29:16.604]  $ ...future.seeds_ii       : NULL
[09:29:16.604]  $ ...future.globals.maxSize: NULL
[09:29:16.604]  - attr(*, "where")=List of 5
[09:29:16.604]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.604]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.604]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.604]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.604]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.604]  - attr(*, "resolved")= logi FALSE
[09:29:16.604]  - attr(*, "total_size")= num 3656
[09:29:16.604]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.604]  - attr(*, "already-done")= logi TRUE
[09:29:16.612] - reassign environment for ‘...future.FUN’
[09:29:16.613] - copied ‘...future.FUN’ to environment
[09:29:16.613] - copied ‘MoreArgs’ to environment
[09:29:16.613] - copied ‘...future.elements_ii’ to environment
[09:29:16.613] - copied ‘...future.seeds_ii’ to environment
[09:29:16.613] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.613] assign_globals() ... done
[09:29:16.613] requestCore(): workers = 2
[09:29:16.615] MulticoreFuture started
[09:29:16.616] - Launch lazy future ... done
[09:29:16.616] run() for ‘MulticoreFuture’ ... done
[09:29:16.616] plan(): Setting new future strategy stack:
[09:29:16.616] Created future:
[09:29:16.617] List of future strategies:
[09:29:16.617] 1. sequential:
[09:29:16.617]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.617]    - tweaked: FALSE
[09:29:16.617]    - call: NULL
[09:29:16.618] plan(): nbrOfWorkers() = 1
[09:29:16.620] plan(): Setting new future strategy stack:
[09:29:16.621] List of future strategies:
[09:29:16.621] 1. multicore:
[09:29:16.621]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.621]    - tweaked: FALSE
[09:29:16.621]    - call: plan(strategy)
[09:29:16.626] plan(): nbrOfWorkers() = 2
[09:29:16.617] MulticoreFuture:
[09:29:16.617] Label: ‘future_.mapply-1’
[09:29:16.617] Expression:
[09:29:16.617] {
[09:29:16.617]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.617]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.617]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.617]         on.exit(options(oopts), add = TRUE)
[09:29:16.617]     }
[09:29:16.617]     {
[09:29:16.617]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.617]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.617]         do.call(mapply, args = args)
[09:29:16.617]     }
[09:29:16.617] }
[09:29:16.617] Lazy evaluation: FALSE
[09:29:16.617] Asynchronous evaluation: TRUE
[09:29:16.617] Local evaluation: TRUE
[09:29:16.617] Environment: R_GlobalEnv
[09:29:16.617] Capture standard output: TRUE
[09:29:16.617] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.617] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.617] Packages: <none>
[09:29:16.617] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.617] Resolved: TRUE
[09:29:16.617] Value: <not collected>
[09:29:16.617] Conditions captured: <none>
[09:29:16.617] Early signaling: FALSE
[09:29:16.617] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.617] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.627] Chunk #1 of 2 ... DONE
[09:29:16.628] Chunk #2 of 2 ...
[09:29:16.628]  - Finding globals in '...' for chunk #2 ...
[09:29:16.628] getGlobalsAndPackages() ...
[09:29:16.628] Searching for globals...
[09:29:16.629] 
[09:29:16.629] Searching for globals ... DONE
[09:29:16.629] - globals: [0] <none>
[09:29:16.629] getGlobalsAndPackages() ... DONE
[09:29:16.630]    + additional globals found: [n=0] 
[09:29:16.630]    + additional namespaces needed: [n=0] 
[09:29:16.630]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:16.630]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:16.630]  - seeds: <none>
[09:29:16.630]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.630] getGlobalsAndPackages() ...
[09:29:16.631] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.631] Resolving globals: FALSE
[09:29:16.632] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[09:29:16.633] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:16.633] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.633] 
[09:29:16.633] getGlobalsAndPackages() ... DONE
[09:29:16.634] run() for ‘Future’ ...
[09:29:16.634] - state: ‘created’
[09:29:16.634] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.639] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.639] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.639]   - Field: ‘label’
[09:29:16.639]   - Field: ‘local’
[09:29:16.639]   - Field: ‘owner’
[09:29:16.639]   - Field: ‘envir’
[09:29:16.640]   - Field: ‘workers’
[09:29:16.640]   - Field: ‘packages’
[09:29:16.640]   - Field: ‘gc’
[09:29:16.640]   - Field: ‘job’
[09:29:16.640]   - Field: ‘conditions’
[09:29:16.640]   - Field: ‘expr’
[09:29:16.640]   - Field: ‘uuid’
[09:29:16.641]   - Field: ‘seed’
[09:29:16.641]   - Field: ‘version’
[09:29:16.641]   - Field: ‘result’
[09:29:16.641]   - Field: ‘asynchronous’
[09:29:16.641]   - Field: ‘calls’
[09:29:16.641]   - Field: ‘globals’
[09:29:16.641]   - Field: ‘stdout’
[09:29:16.641]   - Field: ‘earlySignal’
[09:29:16.642]   - Field: ‘lazy’
[09:29:16.642]   - Field: ‘state’
[09:29:16.642] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.642] - Launch lazy future ...
[09:29:16.642] Packages needed by the future expression (n = 0): <none>
[09:29:16.643] Packages needed by future strategies (n = 0): <none>
[09:29:16.643] {
[09:29:16.643]     {
[09:29:16.643]         {
[09:29:16.643]             ...future.startTime <- base::Sys.time()
[09:29:16.643]             {
[09:29:16.643]                 {
[09:29:16.643]                   {
[09:29:16.643]                     {
[09:29:16.643]                       base::local({
[09:29:16.643]                         has_future <- base::requireNamespace("future", 
[09:29:16.643]                           quietly = TRUE)
[09:29:16.643]                         if (has_future) {
[09:29:16.643]                           ns <- base::getNamespace("future")
[09:29:16.643]                           version <- ns[[".package"]][["version"]]
[09:29:16.643]                           if (is.null(version)) 
[09:29:16.643]                             version <- utils::packageVersion("future")
[09:29:16.643]                         }
[09:29:16.643]                         else {
[09:29:16.643]                           version <- NULL
[09:29:16.643]                         }
[09:29:16.643]                         if (!has_future || version < "1.8.0") {
[09:29:16.643]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.643]                             "", base::R.version$version.string), 
[09:29:16.643]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.643]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.643]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.643]                               "release", "version")], collapse = " "), 
[09:29:16.643]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.643]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.643]                             info)
[09:29:16.643]                           info <- base::paste(info, collapse = "; ")
[09:29:16.643]                           if (!has_future) {
[09:29:16.643]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.643]                               info)
[09:29:16.643]                           }
[09:29:16.643]                           else {
[09:29:16.643]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.643]                               info, version)
[09:29:16.643]                           }
[09:29:16.643]                           base::stop(msg)
[09:29:16.643]                         }
[09:29:16.643]                       })
[09:29:16.643]                     }
[09:29:16.643]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.643]                     base::options(mc.cores = 1L)
[09:29:16.643]                   }
[09:29:16.643]                   ...future.strategy.old <- future::plan("list")
[09:29:16.643]                   options(future.plan = NULL)
[09:29:16.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.643]                 }
[09:29:16.643]                 ...future.workdir <- getwd()
[09:29:16.643]             }
[09:29:16.643]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.643]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.643]         }
[09:29:16.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.643]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:16.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.643]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.643]             base::names(...future.oldOptions))
[09:29:16.643]     }
[09:29:16.643]     if (FALSE) {
[09:29:16.643]     }
[09:29:16.643]     else {
[09:29:16.643]         if (TRUE) {
[09:29:16.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.643]                 open = "w")
[09:29:16.643]         }
[09:29:16.643]         else {
[09:29:16.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.643]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.643]         }
[09:29:16.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.643]             base::sink(type = "output", split = FALSE)
[09:29:16.643]             base::close(...future.stdout)
[09:29:16.643]         }, add = TRUE)
[09:29:16.643]     }
[09:29:16.643]     ...future.frame <- base::sys.nframe()
[09:29:16.643]     ...future.conditions <- base::list()
[09:29:16.643]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.643]     if (FALSE) {
[09:29:16.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.643]     }
[09:29:16.643]     ...future.result <- base::tryCatch({
[09:29:16.643]         base::withCallingHandlers({
[09:29:16.643]             ...future.value <- base::withVisible(base::local({
[09:29:16.643]                 withCallingHandlers({
[09:29:16.643]                   {
[09:29:16.643]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.643]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.643]                       ...future.globals.maxSize)) {
[09:29:16.643]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.643]                       on.exit(options(oopts), add = TRUE)
[09:29:16.643]                     }
[09:29:16.643]                     {
[09:29:16.643]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.643]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.643]                         USE.NAMES = FALSE)
[09:29:16.643]                       do.call(mapply, args = args)
[09:29:16.643]                     }
[09:29:16.643]                   }
[09:29:16.643]                 }, immediateCondition = function(cond) {
[09:29:16.643]                   save_rds <- function (object, pathname, ...) 
[09:29:16.643]                   {
[09:29:16.643]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.643]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.643]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.643]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.643]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.643]                         fi_tmp[["mtime"]])
[09:29:16.643]                     }
[09:29:16.643]                     tryCatch({
[09:29:16.643]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.643]                     }, error = function(ex) {
[09:29:16.643]                       msg <- conditionMessage(ex)
[09:29:16.643]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.643]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.643]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.643]                         fi_tmp[["mtime"]], msg)
[09:29:16.643]                       ex$message <- msg
[09:29:16.643]                       stop(ex)
[09:29:16.643]                     })
[09:29:16.643]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.643]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.643]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.643]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.643]                       fi <- file.info(pathname)
[09:29:16.643]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.643]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.643]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.643]                         fi[["size"]], fi[["mtime"]])
[09:29:16.643]                       stop(msg)
[09:29:16.643]                     }
[09:29:16.643]                     invisible(pathname)
[09:29:16.643]                   }
[09:29:16.643]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.643]                     rootPath = tempdir()) 
[09:29:16.643]                   {
[09:29:16.643]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.643]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.643]                       tmpdir = path, fileext = ".rds")
[09:29:16.643]                     save_rds(obj, file)
[09:29:16.643]                   }
[09:29:16.643]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.643]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.643]                   {
[09:29:16.643]                     inherits <- base::inherits
[09:29:16.643]                     invokeRestart <- base::invokeRestart
[09:29:16.643]                     is.null <- base::is.null
[09:29:16.643]                     muffled <- FALSE
[09:29:16.643]                     if (inherits(cond, "message")) {
[09:29:16.643]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.643]                       if (muffled) 
[09:29:16.643]                         invokeRestart("muffleMessage")
[09:29:16.643]                     }
[09:29:16.643]                     else if (inherits(cond, "warning")) {
[09:29:16.643]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.643]                       if (muffled) 
[09:29:16.643]                         invokeRestart("muffleWarning")
[09:29:16.643]                     }
[09:29:16.643]                     else if (inherits(cond, "condition")) {
[09:29:16.643]                       if (!is.null(pattern)) {
[09:29:16.643]                         computeRestarts <- base::computeRestarts
[09:29:16.643]                         grepl <- base::grepl
[09:29:16.643]                         restarts <- computeRestarts(cond)
[09:29:16.643]                         for (restart in restarts) {
[09:29:16.643]                           name <- restart$name
[09:29:16.643]                           if (is.null(name)) 
[09:29:16.643]                             next
[09:29:16.643]                           if (!grepl(pattern, name)) 
[09:29:16.643]                             next
[09:29:16.643]                           invokeRestart(restart)
[09:29:16.643]                           muffled <- TRUE
[09:29:16.643]                           break
[09:29:16.643]                         }
[09:29:16.643]                       }
[09:29:16.643]                     }
[09:29:16.643]                     invisible(muffled)
[09:29:16.643]                   }
[09:29:16.643]                   muffleCondition(cond)
[09:29:16.643]                 })
[09:29:16.643]             }))
[09:29:16.643]             future::FutureResult(value = ...future.value$value, 
[09:29:16.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.643]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.643]                     ...future.globalenv.names))
[09:29:16.643]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.643]         }, condition = base::local({
[09:29:16.643]             c <- base::c
[09:29:16.643]             inherits <- base::inherits
[09:29:16.643]             invokeRestart <- base::invokeRestart
[09:29:16.643]             length <- base::length
[09:29:16.643]             list <- base::list
[09:29:16.643]             seq.int <- base::seq.int
[09:29:16.643]             signalCondition <- base::signalCondition
[09:29:16.643]             sys.calls <- base::sys.calls
[09:29:16.643]             `[[` <- base::`[[`
[09:29:16.643]             `+` <- base::`+`
[09:29:16.643]             `<<-` <- base::`<<-`
[09:29:16.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.643]                   3L)]
[09:29:16.643]             }
[09:29:16.643]             function(cond) {
[09:29:16.643]                 is_error <- inherits(cond, "error")
[09:29:16.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.643]                   NULL)
[09:29:16.643]                 if (is_error) {
[09:29:16.643]                   sessionInformation <- function() {
[09:29:16.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.643]                       search = base::search(), system = base::Sys.info())
[09:29:16.643]                   }
[09:29:16.643]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.643]                     cond$call), session = sessionInformation(), 
[09:29:16.643]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.643]                   signalCondition(cond)
[09:29:16.643]                 }
[09:29:16.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.643]                 "immediateCondition"))) {
[09:29:16.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.643]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.643]                   if (TRUE && !signal) {
[09:29:16.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.643]                     {
[09:29:16.643]                       inherits <- base::inherits
[09:29:16.643]                       invokeRestart <- base::invokeRestart
[09:29:16.643]                       is.null <- base::is.null
[09:29:16.643]                       muffled <- FALSE
[09:29:16.643]                       if (inherits(cond, "message")) {
[09:29:16.643]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.643]                         if (muffled) 
[09:29:16.643]                           invokeRestart("muffleMessage")
[09:29:16.643]                       }
[09:29:16.643]                       else if (inherits(cond, "warning")) {
[09:29:16.643]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.643]                         if (muffled) 
[09:29:16.643]                           invokeRestart("muffleWarning")
[09:29:16.643]                       }
[09:29:16.643]                       else if (inherits(cond, "condition")) {
[09:29:16.643]                         if (!is.null(pattern)) {
[09:29:16.643]                           computeRestarts <- base::computeRestarts
[09:29:16.643]                           grepl <- base::grepl
[09:29:16.643]                           restarts <- computeRestarts(cond)
[09:29:16.643]                           for (restart in restarts) {
[09:29:16.643]                             name <- restart$name
[09:29:16.643]                             if (is.null(name)) 
[09:29:16.643]                               next
[09:29:16.643]                             if (!grepl(pattern, name)) 
[09:29:16.643]                               next
[09:29:16.643]                             invokeRestart(restart)
[09:29:16.643]                             muffled <- TRUE
[09:29:16.643]                             break
[09:29:16.643]                           }
[09:29:16.643]                         }
[09:29:16.643]                       }
[09:29:16.643]                       invisible(muffled)
[09:29:16.643]                     }
[09:29:16.643]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.643]                   }
[09:29:16.643]                 }
[09:29:16.643]                 else {
[09:29:16.643]                   if (TRUE) {
[09:29:16.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.643]                     {
[09:29:16.643]                       inherits <- base::inherits
[09:29:16.643]                       invokeRestart <- base::invokeRestart
[09:29:16.643]                       is.null <- base::is.null
[09:29:16.643]                       muffled <- FALSE
[09:29:16.643]                       if (inherits(cond, "message")) {
[09:29:16.643]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.643]                         if (muffled) 
[09:29:16.643]                           invokeRestart("muffleMessage")
[09:29:16.643]                       }
[09:29:16.643]                       else if (inherits(cond, "warning")) {
[09:29:16.643]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.643]                         if (muffled) 
[09:29:16.643]                           invokeRestart("muffleWarning")
[09:29:16.643]                       }
[09:29:16.643]                       else if (inherits(cond, "condition")) {
[09:29:16.643]                         if (!is.null(pattern)) {
[09:29:16.643]                           computeRestarts <- base::computeRestarts
[09:29:16.643]                           grepl <- base::grepl
[09:29:16.643]                           restarts <- computeRestarts(cond)
[09:29:16.643]                           for (restart in restarts) {
[09:29:16.643]                             name <- restart$name
[09:29:16.643]                             if (is.null(name)) 
[09:29:16.643]                               next
[09:29:16.643]                             if (!grepl(pattern, name)) 
[09:29:16.643]                               next
[09:29:16.643]                             invokeRestart(restart)
[09:29:16.643]                             muffled <- TRUE
[09:29:16.643]                             break
[09:29:16.643]                           }
[09:29:16.643]                         }
[09:29:16.643]                       }
[09:29:16.643]                       invisible(muffled)
[09:29:16.643]                     }
[09:29:16.643]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.643]                   }
[09:29:16.643]                 }
[09:29:16.643]             }
[09:29:16.643]         }))
[09:29:16.643]     }, error = function(ex) {
[09:29:16.643]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.643]                 ...future.rng), started = ...future.startTime, 
[09:29:16.643]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.643]             version = "1.8"), class = "FutureResult")
[09:29:16.643]     }, finally = {
[09:29:16.643]         if (!identical(...future.workdir, getwd())) 
[09:29:16.643]             setwd(...future.workdir)
[09:29:16.643]         {
[09:29:16.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.643]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.643]             }
[09:29:16.643]             base::options(...future.oldOptions)
[09:29:16.643]             if (.Platform$OS.type == "windows") {
[09:29:16.643]                 old_names <- names(...future.oldEnvVars)
[09:29:16.643]                 envs <- base::Sys.getenv()
[09:29:16.643]                 names <- names(envs)
[09:29:16.643]                 common <- intersect(names, old_names)
[09:29:16.643]                 added <- setdiff(names, old_names)
[09:29:16.643]                 removed <- setdiff(old_names, names)
[09:29:16.643]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.643]                   envs[common]]
[09:29:16.643]                 NAMES <- toupper(changed)
[09:29:16.643]                 args <- list()
[09:29:16.643]                 for (kk in seq_along(NAMES)) {
[09:29:16.643]                   name <- changed[[kk]]
[09:29:16.643]                   NAME <- NAMES[[kk]]
[09:29:16.643]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.643]                     next
[09:29:16.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.643]                 }
[09:29:16.643]                 NAMES <- toupper(added)
[09:29:16.643]                 for (kk in seq_along(NAMES)) {
[09:29:16.643]                   name <- added[[kk]]
[09:29:16.643]                   NAME <- NAMES[[kk]]
[09:29:16.643]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.643]                     next
[09:29:16.643]                   args[[name]] <- ""
[09:29:16.643]                 }
[09:29:16.643]                 NAMES <- toupper(removed)
[09:29:16.643]                 for (kk in seq_along(NAMES)) {
[09:29:16.643]                   name <- removed[[kk]]
[09:29:16.643]                   NAME <- NAMES[[kk]]
[09:29:16.643]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.643]                     next
[09:29:16.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.643]                 }
[09:29:16.643]                 if (length(args) > 0) 
[09:29:16.643]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.643]             }
[09:29:16.643]             else {
[09:29:16.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.643]             }
[09:29:16.643]             {
[09:29:16.643]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.643]                   0L) {
[09:29:16.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.643]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.643]                   base::options(opts)
[09:29:16.643]                 }
[09:29:16.643]                 {
[09:29:16.643]                   {
[09:29:16.643]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.643]                     NULL
[09:29:16.643]                   }
[09:29:16.643]                   options(future.plan = NULL)
[09:29:16.643]                   if (is.na(NA_character_)) 
[09:29:16.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.643]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.643]                     .init = FALSE)
[09:29:16.643]                 }
[09:29:16.643]             }
[09:29:16.643]         }
[09:29:16.643]     })
[09:29:16.643]     if (TRUE) {
[09:29:16.643]         base::sink(type = "output", split = FALSE)
[09:29:16.643]         if (TRUE) {
[09:29:16.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.643]         }
[09:29:16.643]         else {
[09:29:16.643]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.643]         }
[09:29:16.643]         base::close(...future.stdout)
[09:29:16.643]         ...future.stdout <- NULL
[09:29:16.643]     }
[09:29:16.643]     ...future.result$conditions <- ...future.conditions
[09:29:16.643]     ...future.result$finished <- base::Sys.time()
[09:29:16.643]     ...future.result
[09:29:16.643] }
[09:29:16.647] assign_globals() ...
[09:29:16.647] List of 5
[09:29:16.647]  $ ...future.FUN            :function (C, k)  
[09:29:16.647]  $ MoreArgs                 : list()
[09:29:16.647]  $ ...future.elements_ii    :List of 2
[09:29:16.647]   ..$ :List of 3
[09:29:16.647]   .. ..$ : chr "C"
[09:29:16.647]   .. ..$ : chr "D"
[09:29:16.647]   .. ..$ : chr "E"
[09:29:16.647]   ..$ :List of 3
[09:29:16.647]   .. ..$ : int 3
[09:29:16.647]   .. ..$ : int 2
[09:29:16.647]   .. ..$ : int 1
[09:29:16.647]  $ ...future.seeds_ii       : NULL
[09:29:16.647]  $ ...future.globals.maxSize: NULL
[09:29:16.647]  - attr(*, "where")=List of 5
[09:29:16.647]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.647]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.647]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.647]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.647]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.647]  - attr(*, "resolved")= logi FALSE
[09:29:16.647]  - attr(*, "total_size")= num 3824
[09:29:16.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.647]  - attr(*, "already-done")= logi TRUE
[09:29:16.660] - reassign environment for ‘...future.FUN’
[09:29:16.660] - copied ‘...future.FUN’ to environment
[09:29:16.661] - copied ‘MoreArgs’ to environment
[09:29:16.661] - copied ‘...future.elements_ii’ to environment
[09:29:16.661] - copied ‘...future.seeds_ii’ to environment
[09:29:16.661] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.661] assign_globals() ... done
[09:29:16.661] requestCore(): workers = 2
[09:29:16.664] MulticoreFuture started
[09:29:16.665] - Launch lazy future ... done
[09:29:16.665] plan(): Setting new future strategy stack:
[09:29:16.665] run() for ‘MulticoreFuture’ ... done
[09:29:16.666] Created future:
[09:29:16.666] List of future strategies:
[09:29:16.666] 1. sequential:
[09:29:16.666]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.666]    - tweaked: FALSE
[09:29:16.666]    - call: NULL
[09:29:16.668] plan(): nbrOfWorkers() = 1
[09:29:16.670] plan(): Setting new future strategy stack:
[09:29:16.671] List of future strategies:
[09:29:16.671] 1. multicore:
[09:29:16.671]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.671]    - tweaked: FALSE
[09:29:16.671]    - call: plan(strategy)
[09:29:16.677] plan(): nbrOfWorkers() = 2
[09:29:16.666] MulticoreFuture:
[09:29:16.666] Label: ‘future_.mapply-2’
[09:29:16.666] Expression:
[09:29:16.666] {
[09:29:16.666]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.666]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.666]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.666]         on.exit(options(oopts), add = TRUE)
[09:29:16.666]     }
[09:29:16.666]     {
[09:29:16.666]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.666]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.666]         do.call(mapply, args = args)
[09:29:16.666]     }
[09:29:16.666] }
[09:29:16.666] Lazy evaluation: FALSE
[09:29:16.666] Asynchronous evaluation: TRUE
[09:29:16.666] Local evaluation: TRUE
[09:29:16.666] Environment: R_GlobalEnv
[09:29:16.666] Capture standard output: TRUE
[09:29:16.666] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.666] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.666] Packages: <none>
[09:29:16.666] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.666] Resolved: TRUE
[09:29:16.666] Value: <not collected>
[09:29:16.666] Conditions captured: <none>
[09:29:16.666] Early signaling: FALSE
[09:29:16.666] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.666] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.678] Chunk #2 of 2 ... DONE
[09:29:16.678] Launching 2 futures (chunks) ... DONE
[09:29:16.678] Resolving 2 futures (chunks) ...
[09:29:16.679] resolve() on list ...
[09:29:16.679]  recursive: 0
[09:29:16.679]  length: 2
[09:29:16.679] 
[09:29:16.679] Future #1
[09:29:16.680] result() for MulticoreFuture ...
[09:29:16.681] result() for MulticoreFuture ...
[09:29:16.681] result() for MulticoreFuture ... done
[09:29:16.681] result() for MulticoreFuture ... done
[09:29:16.681] result() for MulticoreFuture ...
[09:29:16.681] result() for MulticoreFuture ... done
[09:29:16.681] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:16.682] - nx: 2
[09:29:16.682] - relay: TRUE
[09:29:16.682] - stdout: TRUE
[09:29:16.682] - signal: TRUE
[09:29:16.682] - resignal: FALSE
[09:29:16.682] - force: TRUE
[09:29:16.682] - relayed: [n=2] FALSE, FALSE
[09:29:16.682] - queued futures: [n=2] FALSE, FALSE
[09:29:16.683]  - until=1
[09:29:16.683]  - relaying element #1
[09:29:16.683] result() for MulticoreFuture ...
[09:29:16.683] result() for MulticoreFuture ... done
[09:29:16.683] result() for MulticoreFuture ...
[09:29:16.684] result() for MulticoreFuture ... done
[09:29:16.684] result() for MulticoreFuture ...
[09:29:16.684] result() for MulticoreFuture ... done
[09:29:16.684] result() for MulticoreFuture ...
[09:29:16.684] result() for MulticoreFuture ... done
[09:29:16.685] - relayed: [n=2] TRUE, FALSE
[09:29:16.685] - queued futures: [n=2] TRUE, FALSE
[09:29:16.685] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:16.685]  length: 1 (resolved future 1)
[09:29:16.685] Future #2
[09:29:16.685] result() for MulticoreFuture ...
[09:29:16.686] result() for MulticoreFuture ...
[09:29:16.686] result() for MulticoreFuture ... done
[09:29:16.687] result() for MulticoreFuture ... done
[09:29:16.687] result() for MulticoreFuture ...
[09:29:16.687] result() for MulticoreFuture ... done
[09:29:16.687] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:16.687] - nx: 2
[09:29:16.687] - relay: TRUE
[09:29:16.687] - stdout: TRUE
[09:29:16.687] - signal: TRUE
[09:29:16.688] - resignal: FALSE
[09:29:16.688] - force: TRUE
[09:29:16.688] - relayed: [n=2] TRUE, FALSE
[09:29:16.688] - queued futures: [n=2] TRUE, FALSE
[09:29:16.688]  - until=2
[09:29:16.688]  - relaying element #2
[09:29:16.688] result() for MulticoreFuture ...
[09:29:16.688] result() for MulticoreFuture ... done
[09:29:16.689] result() for MulticoreFuture ...
[09:29:16.689] result() for MulticoreFuture ... done
[09:29:16.689] result() for MulticoreFuture ...
[09:29:16.689] result() for MulticoreFuture ... done
[09:29:16.689] result() for MulticoreFuture ...
[09:29:16.689] result() for MulticoreFuture ... done
[09:29:16.689] - relayed: [n=2] TRUE, TRUE
[09:29:16.689] - queued futures: [n=2] TRUE, TRUE
[09:29:16.690] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:16.690]  length: 0 (resolved future 2)
[09:29:16.690] Relaying remaining futures
[09:29:16.690] signalConditionsASAP(NULL, pos=0) ...
[09:29:16.690] - nx: 2
[09:29:16.690] - relay: TRUE
[09:29:16.690] - stdout: TRUE
[09:29:16.690] - signal: TRUE
[09:29:16.690] - resignal: FALSE
[09:29:16.690] - force: TRUE
[09:29:16.690] - relayed: [n=2] TRUE, TRUE
[09:29:16.691] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:16.691] - relayed: [n=2] TRUE, TRUE
[09:29:16.691] - queued futures: [n=2] TRUE, TRUE
[09:29:16.691] signalConditionsASAP(NULL, pos=0) ... done
[09:29:16.691] resolve() on list ... DONE
[09:29:16.691] result() for MulticoreFuture ...
[09:29:16.691] result() for MulticoreFuture ... done
[09:29:16.691] result() for MulticoreFuture ...
[09:29:16.691] result() for MulticoreFuture ... done
[09:29:16.692] result() for MulticoreFuture ...
[09:29:16.692] result() for MulticoreFuture ... done
[09:29:16.692] result() for MulticoreFuture ...
[09:29:16.692] result() for MulticoreFuture ... done
[09:29:16.692]  - Number of value chunks collected: 2
[09:29:16.692] Resolving 2 futures (chunks) ... DONE
[09:29:16.692] Reducing values from 2 chunks ...
[09:29:16.692]  - Number of values collected after concatenation: 5
[09:29:16.693]  - Number of values expected: 5
[09:29:16.693] Reducing values from 2 chunks ... DONE
[09:29:16.693] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[09:29:16.693] future_mapply() ...
[09:29:16.697] Number of chunks: 1
[09:29:16.697] getGlobalsAndPackagesXApply() ...
[09:29:16.697]  - future.globals: TRUE
[09:29:16.697] getGlobalsAndPackages() ...
[09:29:16.697] Searching for globals...
[09:29:16.699] - globals found: [1] ‘FUN’
[09:29:16.699] Searching for globals ... DONE
[09:29:16.699] Resolving globals: FALSE
[09:29:16.699] The total size of the 1 globals is 848 bytes (848 bytes)
[09:29:16.700] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:29:16.700] - globals: [1] ‘FUN’
[09:29:16.700] 
[09:29:16.700] getGlobalsAndPackages() ... DONE
[09:29:16.700]  - globals found/used: [n=1] ‘FUN’
[09:29:16.700]  - needed namespaces: [n=0] 
[09:29:16.700] Finding globals ... DONE
[09:29:16.701] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:16.703] List of 2
[09:29:16.703]  $ ...future.FUN:function (x)  
[09:29:16.703]  $ MoreArgs     : NULL
[09:29:16.703]  - attr(*, "where")=List of 2
[09:29:16.703]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:16.703]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:16.703]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.703]  - attr(*, "resolved")= logi FALSE
[09:29:16.703]  - attr(*, "total_size")= num NA
[09:29:16.707] Packages to be attached in all futures: [n=0] 
[09:29:16.707] getGlobalsAndPackagesXApply() ... DONE
[09:29:16.707] Number of futures (= number of chunks): 1
[09:29:16.707] Launching 1 futures (chunks) ...
[09:29:16.707] Chunk #1 of 1 ...
[09:29:16.707]  - Finding globals in '...' for chunk #1 ...
[09:29:16.707] getGlobalsAndPackages() ...
[09:29:16.708] Searching for globals...
[09:29:16.708] 
[09:29:16.708] Searching for globals ... DONE
[09:29:16.708] - globals: [0] <none>
[09:29:16.708] getGlobalsAndPackages() ... DONE
[09:29:16.708]    + additional globals found: [n=0] 
[09:29:16.708]    + additional namespaces needed: [n=0] 
[09:29:16.709]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:16.709]  - seeds: <none>
[09:29:16.709]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.709] getGlobalsAndPackages() ...
[09:29:16.709] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.709] Resolving globals: FALSE
[09:29:16.710] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[09:29:16.710] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:16.710] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.710] 
[09:29:16.710] getGlobalsAndPackages() ... DONE
[09:29:16.711] run() for ‘Future’ ...
[09:29:16.711] - state: ‘created’
[09:29:16.711] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.714] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.715] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.715]   - Field: ‘label’
[09:29:16.715]   - Field: ‘local’
[09:29:16.715]   - Field: ‘owner’
[09:29:16.715]   - Field: ‘envir’
[09:29:16.715]   - Field: ‘workers’
[09:29:16.715]   - Field: ‘packages’
[09:29:16.715]   - Field: ‘gc’
[09:29:16.715]   - Field: ‘job’
[09:29:16.715]   - Field: ‘conditions’
[09:29:16.716]   - Field: ‘expr’
[09:29:16.716]   - Field: ‘uuid’
[09:29:16.716]   - Field: ‘seed’
[09:29:16.716]   - Field: ‘version’
[09:29:16.716]   - Field: ‘result’
[09:29:16.716]   - Field: ‘asynchronous’
[09:29:16.716]   - Field: ‘calls’
[09:29:16.716]   - Field: ‘globals’
[09:29:16.716]   - Field: ‘stdout’
[09:29:16.716]   - Field: ‘earlySignal’
[09:29:16.717]   - Field: ‘lazy’
[09:29:16.717]   - Field: ‘state’
[09:29:16.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.717] - Launch lazy future ...
[09:29:16.717] Packages needed by the future expression (n = 0): <none>
[09:29:16.717] Packages needed by future strategies (n = 0): <none>
[09:29:16.718] {
[09:29:16.718]     {
[09:29:16.718]         {
[09:29:16.718]             ...future.startTime <- base::Sys.time()
[09:29:16.718]             {
[09:29:16.718]                 {
[09:29:16.718]                   {
[09:29:16.718]                     {
[09:29:16.718]                       base::local({
[09:29:16.718]                         has_future <- base::requireNamespace("future", 
[09:29:16.718]                           quietly = TRUE)
[09:29:16.718]                         if (has_future) {
[09:29:16.718]                           ns <- base::getNamespace("future")
[09:29:16.718]                           version <- ns[[".package"]][["version"]]
[09:29:16.718]                           if (is.null(version)) 
[09:29:16.718]                             version <- utils::packageVersion("future")
[09:29:16.718]                         }
[09:29:16.718]                         else {
[09:29:16.718]                           version <- NULL
[09:29:16.718]                         }
[09:29:16.718]                         if (!has_future || version < "1.8.0") {
[09:29:16.718]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.718]                             "", base::R.version$version.string), 
[09:29:16.718]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.718]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.718]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.718]                               "release", "version")], collapse = " "), 
[09:29:16.718]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.718]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.718]                             info)
[09:29:16.718]                           info <- base::paste(info, collapse = "; ")
[09:29:16.718]                           if (!has_future) {
[09:29:16.718]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.718]                               info)
[09:29:16.718]                           }
[09:29:16.718]                           else {
[09:29:16.718]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.718]                               info, version)
[09:29:16.718]                           }
[09:29:16.718]                           base::stop(msg)
[09:29:16.718]                         }
[09:29:16.718]                       })
[09:29:16.718]                     }
[09:29:16.718]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.718]                     base::options(mc.cores = 1L)
[09:29:16.718]                   }
[09:29:16.718]                   ...future.strategy.old <- future::plan("list")
[09:29:16.718]                   options(future.plan = NULL)
[09:29:16.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.718]                 }
[09:29:16.718]                 ...future.workdir <- getwd()
[09:29:16.718]             }
[09:29:16.718]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.718]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.718]         }
[09:29:16.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.718]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:16.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.718]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.718]             base::names(...future.oldOptions))
[09:29:16.718]     }
[09:29:16.718]     if (FALSE) {
[09:29:16.718]     }
[09:29:16.718]     else {
[09:29:16.718]         if (TRUE) {
[09:29:16.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.718]                 open = "w")
[09:29:16.718]         }
[09:29:16.718]         else {
[09:29:16.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.718]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.718]         }
[09:29:16.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.718]             base::sink(type = "output", split = FALSE)
[09:29:16.718]             base::close(...future.stdout)
[09:29:16.718]         }, add = TRUE)
[09:29:16.718]     }
[09:29:16.718]     ...future.frame <- base::sys.nframe()
[09:29:16.718]     ...future.conditions <- base::list()
[09:29:16.718]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.718]     if (FALSE) {
[09:29:16.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.718]     }
[09:29:16.718]     ...future.result <- base::tryCatch({
[09:29:16.718]         base::withCallingHandlers({
[09:29:16.718]             ...future.value <- base::withVisible(base::local({
[09:29:16.718]                 withCallingHandlers({
[09:29:16.718]                   {
[09:29:16.718]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.718]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.718]                       ...future.globals.maxSize)) {
[09:29:16.718]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.718]                       on.exit(options(oopts), add = TRUE)
[09:29:16.718]                     }
[09:29:16.718]                     {
[09:29:16.718]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.718]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.718]                         USE.NAMES = FALSE)
[09:29:16.718]                       do.call(mapply, args = args)
[09:29:16.718]                     }
[09:29:16.718]                   }
[09:29:16.718]                 }, immediateCondition = function(cond) {
[09:29:16.718]                   save_rds <- function (object, pathname, ...) 
[09:29:16.718]                   {
[09:29:16.718]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.718]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.718]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.718]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.718]                         fi_tmp[["mtime"]])
[09:29:16.718]                     }
[09:29:16.718]                     tryCatch({
[09:29:16.718]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.718]                     }, error = function(ex) {
[09:29:16.718]                       msg <- conditionMessage(ex)
[09:29:16.718]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.718]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.718]                         fi_tmp[["mtime"]], msg)
[09:29:16.718]                       ex$message <- msg
[09:29:16.718]                       stop(ex)
[09:29:16.718]                     })
[09:29:16.718]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.718]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.718]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.718]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.718]                       fi <- file.info(pathname)
[09:29:16.718]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.718]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.718]                         fi[["size"]], fi[["mtime"]])
[09:29:16.718]                       stop(msg)
[09:29:16.718]                     }
[09:29:16.718]                     invisible(pathname)
[09:29:16.718]                   }
[09:29:16.718]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.718]                     rootPath = tempdir()) 
[09:29:16.718]                   {
[09:29:16.718]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.718]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.718]                       tmpdir = path, fileext = ".rds")
[09:29:16.718]                     save_rds(obj, file)
[09:29:16.718]                   }
[09:29:16.718]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.718]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.718]                   {
[09:29:16.718]                     inherits <- base::inherits
[09:29:16.718]                     invokeRestart <- base::invokeRestart
[09:29:16.718]                     is.null <- base::is.null
[09:29:16.718]                     muffled <- FALSE
[09:29:16.718]                     if (inherits(cond, "message")) {
[09:29:16.718]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.718]                       if (muffled) 
[09:29:16.718]                         invokeRestart("muffleMessage")
[09:29:16.718]                     }
[09:29:16.718]                     else if (inherits(cond, "warning")) {
[09:29:16.718]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.718]                       if (muffled) 
[09:29:16.718]                         invokeRestart("muffleWarning")
[09:29:16.718]                     }
[09:29:16.718]                     else if (inherits(cond, "condition")) {
[09:29:16.718]                       if (!is.null(pattern)) {
[09:29:16.718]                         computeRestarts <- base::computeRestarts
[09:29:16.718]                         grepl <- base::grepl
[09:29:16.718]                         restarts <- computeRestarts(cond)
[09:29:16.718]                         for (restart in restarts) {
[09:29:16.718]                           name <- restart$name
[09:29:16.718]                           if (is.null(name)) 
[09:29:16.718]                             next
[09:29:16.718]                           if (!grepl(pattern, name)) 
[09:29:16.718]                             next
[09:29:16.718]                           invokeRestart(restart)
[09:29:16.718]                           muffled <- TRUE
[09:29:16.718]                           break
[09:29:16.718]                         }
[09:29:16.718]                       }
[09:29:16.718]                     }
[09:29:16.718]                     invisible(muffled)
[09:29:16.718]                   }
[09:29:16.718]                   muffleCondition(cond)
[09:29:16.718]                 })
[09:29:16.718]             }))
[09:29:16.718]             future::FutureResult(value = ...future.value$value, 
[09:29:16.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.718]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.718]                     ...future.globalenv.names))
[09:29:16.718]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.718]         }, condition = base::local({
[09:29:16.718]             c <- base::c
[09:29:16.718]             inherits <- base::inherits
[09:29:16.718]             invokeRestart <- base::invokeRestart
[09:29:16.718]             length <- base::length
[09:29:16.718]             list <- base::list
[09:29:16.718]             seq.int <- base::seq.int
[09:29:16.718]             signalCondition <- base::signalCondition
[09:29:16.718]             sys.calls <- base::sys.calls
[09:29:16.718]             `[[` <- base::`[[`
[09:29:16.718]             `+` <- base::`+`
[09:29:16.718]             `<<-` <- base::`<<-`
[09:29:16.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.718]                   3L)]
[09:29:16.718]             }
[09:29:16.718]             function(cond) {
[09:29:16.718]                 is_error <- inherits(cond, "error")
[09:29:16.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.718]                   NULL)
[09:29:16.718]                 if (is_error) {
[09:29:16.718]                   sessionInformation <- function() {
[09:29:16.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.718]                       search = base::search(), system = base::Sys.info())
[09:29:16.718]                   }
[09:29:16.718]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.718]                     cond$call), session = sessionInformation(), 
[09:29:16.718]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.718]                   signalCondition(cond)
[09:29:16.718]                 }
[09:29:16.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.718]                 "immediateCondition"))) {
[09:29:16.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.718]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.718]                   if (TRUE && !signal) {
[09:29:16.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.718]                     {
[09:29:16.718]                       inherits <- base::inherits
[09:29:16.718]                       invokeRestart <- base::invokeRestart
[09:29:16.718]                       is.null <- base::is.null
[09:29:16.718]                       muffled <- FALSE
[09:29:16.718]                       if (inherits(cond, "message")) {
[09:29:16.718]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.718]                         if (muffled) 
[09:29:16.718]                           invokeRestart("muffleMessage")
[09:29:16.718]                       }
[09:29:16.718]                       else if (inherits(cond, "warning")) {
[09:29:16.718]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.718]                         if (muffled) 
[09:29:16.718]                           invokeRestart("muffleWarning")
[09:29:16.718]                       }
[09:29:16.718]                       else if (inherits(cond, "condition")) {
[09:29:16.718]                         if (!is.null(pattern)) {
[09:29:16.718]                           computeRestarts <- base::computeRestarts
[09:29:16.718]                           grepl <- base::grepl
[09:29:16.718]                           restarts <- computeRestarts(cond)
[09:29:16.718]                           for (restart in restarts) {
[09:29:16.718]                             name <- restart$name
[09:29:16.718]                             if (is.null(name)) 
[09:29:16.718]                               next
[09:29:16.718]                             if (!grepl(pattern, name)) 
[09:29:16.718]                               next
[09:29:16.718]                             invokeRestart(restart)
[09:29:16.718]                             muffled <- TRUE
[09:29:16.718]                             break
[09:29:16.718]                           }
[09:29:16.718]                         }
[09:29:16.718]                       }
[09:29:16.718]                       invisible(muffled)
[09:29:16.718]                     }
[09:29:16.718]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.718]                   }
[09:29:16.718]                 }
[09:29:16.718]                 else {
[09:29:16.718]                   if (TRUE) {
[09:29:16.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.718]                     {
[09:29:16.718]                       inherits <- base::inherits
[09:29:16.718]                       invokeRestart <- base::invokeRestart
[09:29:16.718]                       is.null <- base::is.null
[09:29:16.718]                       muffled <- FALSE
[09:29:16.718]                       if (inherits(cond, "message")) {
[09:29:16.718]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.718]                         if (muffled) 
[09:29:16.718]                           invokeRestart("muffleMessage")
[09:29:16.718]                       }
[09:29:16.718]                       else if (inherits(cond, "warning")) {
[09:29:16.718]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.718]                         if (muffled) 
[09:29:16.718]                           invokeRestart("muffleWarning")
[09:29:16.718]                       }
[09:29:16.718]                       else if (inherits(cond, "condition")) {
[09:29:16.718]                         if (!is.null(pattern)) {
[09:29:16.718]                           computeRestarts <- base::computeRestarts
[09:29:16.718]                           grepl <- base::grepl
[09:29:16.718]                           restarts <- computeRestarts(cond)
[09:29:16.718]                           for (restart in restarts) {
[09:29:16.718]                             name <- restart$name
[09:29:16.718]                             if (is.null(name)) 
[09:29:16.718]                               next
[09:29:16.718]                             if (!grepl(pattern, name)) 
[09:29:16.718]                               next
[09:29:16.718]                             invokeRestart(restart)
[09:29:16.718]                             muffled <- TRUE
[09:29:16.718]                             break
[09:29:16.718]                           }
[09:29:16.718]                         }
[09:29:16.718]                       }
[09:29:16.718]                       invisible(muffled)
[09:29:16.718]                     }
[09:29:16.718]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.718]                   }
[09:29:16.718]                 }
[09:29:16.718]             }
[09:29:16.718]         }))
[09:29:16.718]     }, error = function(ex) {
[09:29:16.718]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.718]                 ...future.rng), started = ...future.startTime, 
[09:29:16.718]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.718]             version = "1.8"), class = "FutureResult")
[09:29:16.718]     }, finally = {
[09:29:16.718]         if (!identical(...future.workdir, getwd())) 
[09:29:16.718]             setwd(...future.workdir)
[09:29:16.718]         {
[09:29:16.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.718]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.718]             }
[09:29:16.718]             base::options(...future.oldOptions)
[09:29:16.718]             if (.Platform$OS.type == "windows") {
[09:29:16.718]                 old_names <- names(...future.oldEnvVars)
[09:29:16.718]                 envs <- base::Sys.getenv()
[09:29:16.718]                 names <- names(envs)
[09:29:16.718]                 common <- intersect(names, old_names)
[09:29:16.718]                 added <- setdiff(names, old_names)
[09:29:16.718]                 removed <- setdiff(old_names, names)
[09:29:16.718]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.718]                   envs[common]]
[09:29:16.718]                 NAMES <- toupper(changed)
[09:29:16.718]                 args <- list()
[09:29:16.718]                 for (kk in seq_along(NAMES)) {
[09:29:16.718]                   name <- changed[[kk]]
[09:29:16.718]                   NAME <- NAMES[[kk]]
[09:29:16.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.718]                     next
[09:29:16.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.718]                 }
[09:29:16.718]                 NAMES <- toupper(added)
[09:29:16.718]                 for (kk in seq_along(NAMES)) {
[09:29:16.718]                   name <- added[[kk]]
[09:29:16.718]                   NAME <- NAMES[[kk]]
[09:29:16.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.718]                     next
[09:29:16.718]                   args[[name]] <- ""
[09:29:16.718]                 }
[09:29:16.718]                 NAMES <- toupper(removed)
[09:29:16.718]                 for (kk in seq_along(NAMES)) {
[09:29:16.718]                   name <- removed[[kk]]
[09:29:16.718]                   NAME <- NAMES[[kk]]
[09:29:16.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.718]                     next
[09:29:16.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.718]                 }
[09:29:16.718]                 if (length(args) > 0) 
[09:29:16.718]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.718]             }
[09:29:16.718]             else {
[09:29:16.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.718]             }
[09:29:16.718]             {
[09:29:16.718]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.718]                   0L) {
[09:29:16.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.718]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.718]                   base::options(opts)
[09:29:16.718]                 }
[09:29:16.718]                 {
[09:29:16.718]                   {
[09:29:16.718]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.718]                     NULL
[09:29:16.718]                   }
[09:29:16.718]                   options(future.plan = NULL)
[09:29:16.718]                   if (is.na(NA_character_)) 
[09:29:16.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.718]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.718]                     .init = FALSE)
[09:29:16.718]                 }
[09:29:16.718]             }
[09:29:16.718]         }
[09:29:16.718]     })
[09:29:16.718]     if (TRUE) {
[09:29:16.718]         base::sink(type = "output", split = FALSE)
[09:29:16.718]         if (TRUE) {
[09:29:16.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.718]         }
[09:29:16.718]         else {
[09:29:16.718]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.718]         }
[09:29:16.718]         base::close(...future.stdout)
[09:29:16.718]         ...future.stdout <- NULL
[09:29:16.718]     }
[09:29:16.718]     ...future.result$conditions <- ...future.conditions
[09:29:16.718]     ...future.result$finished <- base::Sys.time()
[09:29:16.718]     ...future.result
[09:29:16.718] }
[09:29:16.720] assign_globals() ...
[09:29:16.720] List of 5
[09:29:16.720]  $ ...future.FUN            :function (x)  
[09:29:16.720]  $ MoreArgs                 : NULL
[09:29:16.720]  $ ...future.elements_ii    :List of 1
[09:29:16.720]   ..$ :List of 1
[09:29:16.720]   .. ..$ : Date[1:1], format: "2018-06-01"
[09:29:16.720]  $ ...future.seeds_ii       : NULL
[09:29:16.720]  $ ...future.globals.maxSize: NULL
[09:29:16.720]  - attr(*, "where")=List of 5
[09:29:16.720]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.720]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.720]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.720]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.720]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.720]  - attr(*, "resolved")= logi FALSE
[09:29:16.720]  - attr(*, "total_size")= num 1128
[09:29:16.720]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.720]  - attr(*, "already-done")= logi TRUE
[09:29:16.725] - copied ‘...future.FUN’ to environment
[09:29:16.725] - copied ‘MoreArgs’ to environment
[09:29:16.725] - copied ‘...future.elements_ii’ to environment
[09:29:16.725] - copied ‘...future.seeds_ii’ to environment
[09:29:16.725] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.725] assign_globals() ... done
[09:29:16.726] requestCore(): workers = 2
[09:29:16.728] MulticoreFuture started
[09:29:16.728] - Launch lazy future ... done
[09:29:16.728] run() for ‘MulticoreFuture’ ... done
[09:29:16.728] Created future:
[09:29:16.729] plan(): Setting new future strategy stack:
[09:29:16.729] List of future strategies:
[09:29:16.729] 1. sequential:
[09:29:16.729]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.729]    - tweaked: FALSE
[09:29:16.729]    - call: NULL
[09:29:16.730] plan(): nbrOfWorkers() = 1
[09:29:16.732] plan(): Setting new future strategy stack:
[09:29:16.732] List of future strategies:
[09:29:16.732] 1. multicore:
[09:29:16.732]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.732]    - tweaked: FALSE
[09:29:16.732]    - call: plan(strategy)
[09:29:16.729] MulticoreFuture:
[09:29:16.729] Label: ‘future_mapply-1’
[09:29:16.729] Expression:
[09:29:16.729] {
[09:29:16.729]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.729]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.729]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.729]         on.exit(options(oopts), add = TRUE)
[09:29:16.729]     }
[09:29:16.729]     {
[09:29:16.729]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.729]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.729]         do.call(mapply, args = args)
[09:29:16.729]     }
[09:29:16.729] }
[09:29:16.729] Lazy evaluation: FALSE
[09:29:16.729] Asynchronous evaluation: TRUE
[09:29:16.729] Local evaluation: TRUE
[09:29:16.729] Environment: R_GlobalEnv
[09:29:16.729] Capture standard output: TRUE
[09:29:16.729] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.729] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.729] Packages: <none>
[09:29:16.729] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.729] Resolved: FALSE
[09:29:16.729] Value: <not collected>
[09:29:16.729] Conditions captured: <none>
[09:29:16.729] Early signaling: FALSE
[09:29:16.729] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.729] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.741] Chunk #1 of 1 ... DONE
[09:29:16.741] Launching 1 futures (chunks) ... DONE
[09:29:16.741] Resolving 1 futures (chunks) ...
[09:29:16.744] plan(): nbrOfWorkers() = 2
[09:29:16.742] resolve() on list ...
[09:29:16.745]  recursive: 0
[09:29:16.745]  length: 1
[09:29:16.745] 
[09:29:16.746] Future #1
[09:29:16.746] result() for MulticoreFuture ...
[09:29:16.747] result() for MulticoreFuture ...
[09:29:16.747] result() for MulticoreFuture ... done
[09:29:16.748] result() for MulticoreFuture ... done
[09:29:16.748] result() for MulticoreFuture ...
[09:29:16.748] result() for MulticoreFuture ... done
[09:29:16.748] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:16.748] - nx: 1
[09:29:16.749] - relay: TRUE
[09:29:16.749] - stdout: TRUE
[09:29:16.749] - signal: TRUE
[09:29:16.749] - resignal: FALSE
[09:29:16.749] - force: TRUE
[09:29:16.749] - relayed: [n=1] FALSE
[09:29:16.750] - queued futures: [n=1] FALSE
[09:29:16.750]  - until=1
[09:29:16.750]  - relaying element #1
[09:29:16.750] result() for MulticoreFuture ...
[09:29:16.750] result() for MulticoreFuture ... done
[09:29:16.750] result() for MulticoreFuture ...
[09:29:16.751] result() for MulticoreFuture ... done
[09:29:16.751] result() for MulticoreFuture ...
[09:29:16.751] result() for MulticoreFuture ... done
[09:29:16.751] result() for MulticoreFuture ...
[09:29:16.751] result() for MulticoreFuture ... done
[09:29:16.751] - relayed: [n=1] TRUE
[09:29:16.752] - queued futures: [n=1] TRUE
[09:29:16.752] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:16.752]  length: 0 (resolved future 1)
[09:29:16.752] Relaying remaining futures
[09:29:16.752] signalConditionsASAP(NULL, pos=0) ...
[09:29:16.752] - nx: 1
[09:29:16.753] - relay: TRUE
[09:29:16.753] - stdout: TRUE
[09:29:16.753] - signal: TRUE
[09:29:16.753] - resignal: FALSE
[09:29:16.753] - force: TRUE
[09:29:16.753] - relayed: [n=1] TRUE
[09:29:16.753] - queued futures: [n=1] TRUE
 - flush all
[09:29:16.754] - relayed: [n=1] TRUE
[09:29:16.754] - queued futures: [n=1] TRUE
[09:29:16.754] signalConditionsASAP(NULL, pos=0) ... done
[09:29:16.754] resolve() on list ... DONE
[09:29:16.754] result() for MulticoreFuture ...
[09:29:16.754] result() for MulticoreFuture ... done
[09:29:16.754] result() for MulticoreFuture ...
[09:29:16.754] result() for MulticoreFuture ... done
[09:29:16.754]  - Number of value chunks collected: 1
[09:29:16.755] Resolving 1 futures (chunks) ... DONE
[09:29:16.755] Reducing values from 1 chunks ...
[09:29:16.755]  - Number of values collected after concatenation: 1
[09:29:16.755]  - Number of values expected: 1
[09:29:16.755] Reducing values from 1 chunks ... DONE
[09:29:16.755] future_mapply() ... DONE
[09:29:16.755] future_mapply() ...
[09:29:16.759] Number of chunks: 1
[09:29:16.759] getGlobalsAndPackagesXApply() ...
[09:29:16.759]  - future.globals: TRUE
[09:29:16.759] getGlobalsAndPackages() ...
[09:29:16.759] Searching for globals...
[09:29:16.761] - globals found: [1] ‘FUN’
[09:29:16.761] Searching for globals ... DONE
[09:29:16.761] Resolving globals: FALSE
[09:29:16.761] The total size of the 1 globals is 848 bytes (848 bytes)
[09:29:16.762] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:29:16.762] - globals: [1] ‘FUN’
[09:29:16.762] 
[09:29:16.762] getGlobalsAndPackages() ... DONE
[09:29:16.762]  - globals found/used: [n=1] ‘FUN’
[09:29:16.762]  - needed namespaces: [n=0] 
[09:29:16.762] Finding globals ... DONE
[09:29:16.762] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:16.763] List of 2
[09:29:16.763]  $ ...future.FUN:function (x)  
[09:29:16.763]  $ MoreArgs     : list()
[09:29:16.763]  - attr(*, "where")=List of 2
[09:29:16.763]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:16.763]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:16.763]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.763]  - attr(*, "resolved")= logi FALSE
[09:29:16.763]  - attr(*, "total_size")= num NA
[09:29:16.765] Packages to be attached in all futures: [n=0] 
[09:29:16.765] getGlobalsAndPackagesXApply() ... DONE
[09:29:16.766] Number of futures (= number of chunks): 1
[09:29:16.766] Launching 1 futures (chunks) ...
[09:29:16.766] Chunk #1 of 1 ...
[09:29:16.766]  - Finding globals in '...' for chunk #1 ...
[09:29:16.766] getGlobalsAndPackages() ...
[09:29:16.766] Searching for globals...
[09:29:16.766] 
[09:29:16.767] Searching for globals ... DONE
[09:29:16.767] - globals: [0] <none>
[09:29:16.767] getGlobalsAndPackages() ... DONE
[09:29:16.767]    + additional globals found: [n=0] 
[09:29:16.767]    + additional namespaces needed: [n=0] 
[09:29:16.767]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:16.767]  - seeds: <none>
[09:29:16.767]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.767] getGlobalsAndPackages() ...
[09:29:16.767] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.768] Resolving globals: FALSE
[09:29:16.768] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[09:29:16.769] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:16.769] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.769] 
[09:29:16.769] getGlobalsAndPackages() ... DONE
[09:29:16.769] run() for ‘Future’ ...
[09:29:16.769] - state: ‘created’
[09:29:16.769] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.773] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.773] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.773]   - Field: ‘label’
[09:29:16.773]   - Field: ‘local’
[09:29:16.774]   - Field: ‘owner’
[09:29:16.774]   - Field: ‘envir’
[09:29:16.774]   - Field: ‘workers’
[09:29:16.774]   - Field: ‘packages’
[09:29:16.776]   - Field: ‘gc’
[09:29:16.776]   - Field: ‘job’
[09:29:16.776]   - Field: ‘conditions’
[09:29:16.776]   - Field: ‘expr’
[09:29:16.777]   - Field: ‘uuid’
[09:29:16.777]   - Field: ‘seed’
[09:29:16.777]   - Field: ‘version’
[09:29:16.777]   - Field: ‘result’
[09:29:16.777]   - Field: ‘asynchronous’
[09:29:16.777]   - Field: ‘calls’
[09:29:16.777]   - Field: ‘globals’
[09:29:16.777]   - Field: ‘stdout’
[09:29:16.777]   - Field: ‘earlySignal’
[09:29:16.777]   - Field: ‘lazy’
[09:29:16.778]   - Field: ‘state’
[09:29:16.778] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.778] - Launch lazy future ...
[09:29:16.778] Packages needed by the future expression (n = 0): <none>
[09:29:16.778] Packages needed by future strategies (n = 0): <none>
[09:29:16.779] {
[09:29:16.779]     {
[09:29:16.779]         {
[09:29:16.779]             ...future.startTime <- base::Sys.time()
[09:29:16.779]             {
[09:29:16.779]                 {
[09:29:16.779]                   {
[09:29:16.779]                     {
[09:29:16.779]                       base::local({
[09:29:16.779]                         has_future <- base::requireNamespace("future", 
[09:29:16.779]                           quietly = TRUE)
[09:29:16.779]                         if (has_future) {
[09:29:16.779]                           ns <- base::getNamespace("future")
[09:29:16.779]                           version <- ns[[".package"]][["version"]]
[09:29:16.779]                           if (is.null(version)) 
[09:29:16.779]                             version <- utils::packageVersion("future")
[09:29:16.779]                         }
[09:29:16.779]                         else {
[09:29:16.779]                           version <- NULL
[09:29:16.779]                         }
[09:29:16.779]                         if (!has_future || version < "1.8.0") {
[09:29:16.779]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.779]                             "", base::R.version$version.string), 
[09:29:16.779]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.779]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.779]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.779]                               "release", "version")], collapse = " "), 
[09:29:16.779]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.779]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.779]                             info)
[09:29:16.779]                           info <- base::paste(info, collapse = "; ")
[09:29:16.779]                           if (!has_future) {
[09:29:16.779]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.779]                               info)
[09:29:16.779]                           }
[09:29:16.779]                           else {
[09:29:16.779]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.779]                               info, version)
[09:29:16.779]                           }
[09:29:16.779]                           base::stop(msg)
[09:29:16.779]                         }
[09:29:16.779]                       })
[09:29:16.779]                     }
[09:29:16.779]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.779]                     base::options(mc.cores = 1L)
[09:29:16.779]                   }
[09:29:16.779]                   ...future.strategy.old <- future::plan("list")
[09:29:16.779]                   options(future.plan = NULL)
[09:29:16.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.779]                 }
[09:29:16.779]                 ...future.workdir <- getwd()
[09:29:16.779]             }
[09:29:16.779]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.779]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.779]         }
[09:29:16.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.779]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:16.779]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.779]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.779]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.779]             base::names(...future.oldOptions))
[09:29:16.779]     }
[09:29:16.779]     if (FALSE) {
[09:29:16.779]     }
[09:29:16.779]     else {
[09:29:16.779]         if (TRUE) {
[09:29:16.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.779]                 open = "w")
[09:29:16.779]         }
[09:29:16.779]         else {
[09:29:16.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.779]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.779]         }
[09:29:16.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.779]             base::sink(type = "output", split = FALSE)
[09:29:16.779]             base::close(...future.stdout)
[09:29:16.779]         }, add = TRUE)
[09:29:16.779]     }
[09:29:16.779]     ...future.frame <- base::sys.nframe()
[09:29:16.779]     ...future.conditions <- base::list()
[09:29:16.779]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.779]     if (FALSE) {
[09:29:16.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.779]     }
[09:29:16.779]     ...future.result <- base::tryCatch({
[09:29:16.779]         base::withCallingHandlers({
[09:29:16.779]             ...future.value <- base::withVisible(base::local({
[09:29:16.779]                 withCallingHandlers({
[09:29:16.779]                   {
[09:29:16.779]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.779]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.779]                       ...future.globals.maxSize)) {
[09:29:16.779]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.779]                       on.exit(options(oopts), add = TRUE)
[09:29:16.779]                     }
[09:29:16.779]                     {
[09:29:16.779]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.779]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.779]                         USE.NAMES = FALSE)
[09:29:16.779]                       do.call(mapply, args = args)
[09:29:16.779]                     }
[09:29:16.779]                   }
[09:29:16.779]                 }, immediateCondition = function(cond) {
[09:29:16.779]                   save_rds <- function (object, pathname, ...) 
[09:29:16.779]                   {
[09:29:16.779]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.779]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.779]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.779]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.779]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.779]                         fi_tmp[["mtime"]])
[09:29:16.779]                     }
[09:29:16.779]                     tryCatch({
[09:29:16.779]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.779]                     }, error = function(ex) {
[09:29:16.779]                       msg <- conditionMessage(ex)
[09:29:16.779]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.779]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.779]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.779]                         fi_tmp[["mtime"]], msg)
[09:29:16.779]                       ex$message <- msg
[09:29:16.779]                       stop(ex)
[09:29:16.779]                     })
[09:29:16.779]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.779]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.779]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.779]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.779]                       fi <- file.info(pathname)
[09:29:16.779]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.779]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.779]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.779]                         fi[["size"]], fi[["mtime"]])
[09:29:16.779]                       stop(msg)
[09:29:16.779]                     }
[09:29:16.779]                     invisible(pathname)
[09:29:16.779]                   }
[09:29:16.779]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.779]                     rootPath = tempdir()) 
[09:29:16.779]                   {
[09:29:16.779]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.779]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.779]                       tmpdir = path, fileext = ".rds")
[09:29:16.779]                     save_rds(obj, file)
[09:29:16.779]                   }
[09:29:16.779]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.779]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.779]                   {
[09:29:16.779]                     inherits <- base::inherits
[09:29:16.779]                     invokeRestart <- base::invokeRestart
[09:29:16.779]                     is.null <- base::is.null
[09:29:16.779]                     muffled <- FALSE
[09:29:16.779]                     if (inherits(cond, "message")) {
[09:29:16.779]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.779]                       if (muffled) 
[09:29:16.779]                         invokeRestart("muffleMessage")
[09:29:16.779]                     }
[09:29:16.779]                     else if (inherits(cond, "warning")) {
[09:29:16.779]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.779]                       if (muffled) 
[09:29:16.779]                         invokeRestart("muffleWarning")
[09:29:16.779]                     }
[09:29:16.779]                     else if (inherits(cond, "condition")) {
[09:29:16.779]                       if (!is.null(pattern)) {
[09:29:16.779]                         computeRestarts <- base::computeRestarts
[09:29:16.779]                         grepl <- base::grepl
[09:29:16.779]                         restarts <- computeRestarts(cond)
[09:29:16.779]                         for (restart in restarts) {
[09:29:16.779]                           name <- restart$name
[09:29:16.779]                           if (is.null(name)) 
[09:29:16.779]                             next
[09:29:16.779]                           if (!grepl(pattern, name)) 
[09:29:16.779]                             next
[09:29:16.779]                           invokeRestart(restart)
[09:29:16.779]                           muffled <- TRUE
[09:29:16.779]                           break
[09:29:16.779]                         }
[09:29:16.779]                       }
[09:29:16.779]                     }
[09:29:16.779]                     invisible(muffled)
[09:29:16.779]                   }
[09:29:16.779]                   muffleCondition(cond)
[09:29:16.779]                 })
[09:29:16.779]             }))
[09:29:16.779]             future::FutureResult(value = ...future.value$value, 
[09:29:16.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.779]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.779]                     ...future.globalenv.names))
[09:29:16.779]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.779]         }, condition = base::local({
[09:29:16.779]             c <- base::c
[09:29:16.779]             inherits <- base::inherits
[09:29:16.779]             invokeRestart <- base::invokeRestart
[09:29:16.779]             length <- base::length
[09:29:16.779]             list <- base::list
[09:29:16.779]             seq.int <- base::seq.int
[09:29:16.779]             signalCondition <- base::signalCondition
[09:29:16.779]             sys.calls <- base::sys.calls
[09:29:16.779]             `[[` <- base::`[[`
[09:29:16.779]             `+` <- base::`+`
[09:29:16.779]             `<<-` <- base::`<<-`
[09:29:16.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.779]                   3L)]
[09:29:16.779]             }
[09:29:16.779]             function(cond) {
[09:29:16.779]                 is_error <- inherits(cond, "error")
[09:29:16.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.779]                   NULL)
[09:29:16.779]                 if (is_error) {
[09:29:16.779]                   sessionInformation <- function() {
[09:29:16.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.779]                       search = base::search(), system = base::Sys.info())
[09:29:16.779]                   }
[09:29:16.779]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.779]                     cond$call), session = sessionInformation(), 
[09:29:16.779]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.779]                   signalCondition(cond)
[09:29:16.779]                 }
[09:29:16.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.779]                 "immediateCondition"))) {
[09:29:16.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.779]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.779]                   if (TRUE && !signal) {
[09:29:16.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.779]                     {
[09:29:16.779]                       inherits <- base::inherits
[09:29:16.779]                       invokeRestart <- base::invokeRestart
[09:29:16.779]                       is.null <- base::is.null
[09:29:16.779]                       muffled <- FALSE
[09:29:16.779]                       if (inherits(cond, "message")) {
[09:29:16.779]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.779]                         if (muffled) 
[09:29:16.779]                           invokeRestart("muffleMessage")
[09:29:16.779]                       }
[09:29:16.779]                       else if (inherits(cond, "warning")) {
[09:29:16.779]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.779]                         if (muffled) 
[09:29:16.779]                           invokeRestart("muffleWarning")
[09:29:16.779]                       }
[09:29:16.779]                       else if (inherits(cond, "condition")) {
[09:29:16.779]                         if (!is.null(pattern)) {
[09:29:16.779]                           computeRestarts <- base::computeRestarts
[09:29:16.779]                           grepl <- base::grepl
[09:29:16.779]                           restarts <- computeRestarts(cond)
[09:29:16.779]                           for (restart in restarts) {
[09:29:16.779]                             name <- restart$name
[09:29:16.779]                             if (is.null(name)) 
[09:29:16.779]                               next
[09:29:16.779]                             if (!grepl(pattern, name)) 
[09:29:16.779]                               next
[09:29:16.779]                             invokeRestart(restart)
[09:29:16.779]                             muffled <- TRUE
[09:29:16.779]                             break
[09:29:16.779]                           }
[09:29:16.779]                         }
[09:29:16.779]                       }
[09:29:16.779]                       invisible(muffled)
[09:29:16.779]                     }
[09:29:16.779]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.779]                   }
[09:29:16.779]                 }
[09:29:16.779]                 else {
[09:29:16.779]                   if (TRUE) {
[09:29:16.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.779]                     {
[09:29:16.779]                       inherits <- base::inherits
[09:29:16.779]                       invokeRestart <- base::invokeRestart
[09:29:16.779]                       is.null <- base::is.null
[09:29:16.779]                       muffled <- FALSE
[09:29:16.779]                       if (inherits(cond, "message")) {
[09:29:16.779]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.779]                         if (muffled) 
[09:29:16.779]                           invokeRestart("muffleMessage")
[09:29:16.779]                       }
[09:29:16.779]                       else if (inherits(cond, "warning")) {
[09:29:16.779]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.779]                         if (muffled) 
[09:29:16.779]                           invokeRestart("muffleWarning")
[09:29:16.779]                       }
[09:29:16.779]                       else if (inherits(cond, "condition")) {
[09:29:16.779]                         if (!is.null(pattern)) {
[09:29:16.779]                           computeRestarts <- base::computeRestarts
[09:29:16.779]                           grepl <- base::grepl
[09:29:16.779]                           restarts <- computeRestarts(cond)
[09:29:16.779]                           for (restart in restarts) {
[09:29:16.779]                             name <- restart$name
[09:29:16.779]                             if (is.null(name)) 
[09:29:16.779]                               next
[09:29:16.779]                             if (!grepl(pattern, name)) 
[09:29:16.779]                               next
[09:29:16.779]                             invokeRestart(restart)
[09:29:16.779]                             muffled <- TRUE
[09:29:16.779]                             break
[09:29:16.779]                           }
[09:29:16.779]                         }
[09:29:16.779]                       }
[09:29:16.779]                       invisible(muffled)
[09:29:16.779]                     }
[09:29:16.779]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.779]                   }
[09:29:16.779]                 }
[09:29:16.779]             }
[09:29:16.779]         }))
[09:29:16.779]     }, error = function(ex) {
[09:29:16.779]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.779]                 ...future.rng), started = ...future.startTime, 
[09:29:16.779]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.779]             version = "1.8"), class = "FutureResult")
[09:29:16.779]     }, finally = {
[09:29:16.779]         if (!identical(...future.workdir, getwd())) 
[09:29:16.779]             setwd(...future.workdir)
[09:29:16.779]         {
[09:29:16.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.779]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.779]             }
[09:29:16.779]             base::options(...future.oldOptions)
[09:29:16.779]             if (.Platform$OS.type == "windows") {
[09:29:16.779]                 old_names <- names(...future.oldEnvVars)
[09:29:16.779]                 envs <- base::Sys.getenv()
[09:29:16.779]                 names <- names(envs)
[09:29:16.779]                 common <- intersect(names, old_names)
[09:29:16.779]                 added <- setdiff(names, old_names)
[09:29:16.779]                 removed <- setdiff(old_names, names)
[09:29:16.779]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.779]                   envs[common]]
[09:29:16.779]                 NAMES <- toupper(changed)
[09:29:16.779]                 args <- list()
[09:29:16.779]                 for (kk in seq_along(NAMES)) {
[09:29:16.779]                   name <- changed[[kk]]
[09:29:16.779]                   NAME <- NAMES[[kk]]
[09:29:16.779]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.779]                     next
[09:29:16.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.779]                 }
[09:29:16.779]                 NAMES <- toupper(added)
[09:29:16.779]                 for (kk in seq_along(NAMES)) {
[09:29:16.779]                   name <- added[[kk]]
[09:29:16.779]                   NAME <- NAMES[[kk]]
[09:29:16.779]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.779]                     next
[09:29:16.779]                   args[[name]] <- ""
[09:29:16.779]                 }
[09:29:16.779]                 NAMES <- toupper(removed)
[09:29:16.779]                 for (kk in seq_along(NAMES)) {
[09:29:16.779]                   name <- removed[[kk]]
[09:29:16.779]                   NAME <- NAMES[[kk]]
[09:29:16.779]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.779]                     next
[09:29:16.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.779]                 }
[09:29:16.779]                 if (length(args) > 0) 
[09:29:16.779]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.779]             }
[09:29:16.779]             else {
[09:29:16.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.779]             }
[09:29:16.779]             {
[09:29:16.779]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.779]                   0L) {
[09:29:16.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.779]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.779]                   base::options(opts)
[09:29:16.779]                 }
[09:29:16.779]                 {
[09:29:16.779]                   {
[09:29:16.779]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.779]                     NULL
[09:29:16.779]                   }
[09:29:16.779]                   options(future.plan = NULL)
[09:29:16.779]                   if (is.na(NA_character_)) 
[09:29:16.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.779]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.779]                     .init = FALSE)
[09:29:16.779]                 }
[09:29:16.779]             }
[09:29:16.779]         }
[09:29:16.779]     })
[09:29:16.779]     if (TRUE) {
[09:29:16.779]         base::sink(type = "output", split = FALSE)
[09:29:16.779]         if (TRUE) {
[09:29:16.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.779]         }
[09:29:16.779]         else {
[09:29:16.779]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.779]         }
[09:29:16.779]         base::close(...future.stdout)
[09:29:16.779]         ...future.stdout <- NULL
[09:29:16.779]     }
[09:29:16.779]     ...future.result$conditions <- ...future.conditions
[09:29:16.779]     ...future.result$finished <- base::Sys.time()
[09:29:16.779]     ...future.result
[09:29:16.779] }
[09:29:16.781] assign_globals() ...
[09:29:16.781] List of 5
[09:29:16.781]  $ ...future.FUN            :function (x)  
[09:29:16.781]  $ MoreArgs                 : list()
[09:29:16.781]  $ ...future.elements_ii    :List of 1
[09:29:16.781]   ..$ :List of 1
[09:29:16.781]   .. ..$ : Date[1:1], format: "2018-06-01"
[09:29:16.781]  $ ...future.seeds_ii       : NULL
[09:29:16.781]  $ ...future.globals.maxSize: NULL
[09:29:16.781]  - attr(*, "where")=List of 5
[09:29:16.781]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.781]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.781]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.781]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.781]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.781]  - attr(*, "resolved")= logi FALSE
[09:29:16.781]  - attr(*, "total_size")= num 1128
[09:29:16.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.781]  - attr(*, "already-done")= logi TRUE
[09:29:16.786] - copied ‘...future.FUN’ to environment
[09:29:16.786] - copied ‘MoreArgs’ to environment
[09:29:16.786] - copied ‘...future.elements_ii’ to environment
[09:29:16.786] - copied ‘...future.seeds_ii’ to environment
[09:29:16.786] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.787] assign_globals() ... done
[09:29:16.787] requestCore(): workers = 2
[09:29:16.789] MulticoreFuture started
[09:29:16.789] - Launch lazy future ... done
[09:29:16.789] run() for ‘MulticoreFuture’ ... done
[09:29:16.790] Created future:
[09:29:16.790] plan(): Setting new future strategy stack:
[09:29:16.790] List of future strategies:
[09:29:16.790] 1. sequential:
[09:29:16.790]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.790]    - tweaked: FALSE
[09:29:16.790]    - call: NULL
[09:29:16.791] plan(): nbrOfWorkers() = 1
[09:29:16.793] plan(): Setting new future strategy stack:
[09:29:16.793] List of future strategies:
[09:29:16.793] 1. multicore:
[09:29:16.793]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.793]    - tweaked: FALSE
[09:29:16.793]    - call: plan(strategy)
[09:29:16.798] plan(): nbrOfWorkers() = 2
[09:29:16.790] MulticoreFuture:
[09:29:16.790] Label: ‘future_.mapply-1’
[09:29:16.790] Expression:
[09:29:16.790] {
[09:29:16.790]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.790]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.790]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.790]         on.exit(options(oopts), add = TRUE)
[09:29:16.790]     }
[09:29:16.790]     {
[09:29:16.790]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.790]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.790]         do.call(mapply, args = args)
[09:29:16.790]     }
[09:29:16.790] }
[09:29:16.790] Lazy evaluation: FALSE
[09:29:16.790] Asynchronous evaluation: TRUE
[09:29:16.790] Local evaluation: TRUE
[09:29:16.790] Environment: R_GlobalEnv
[09:29:16.790] Capture standard output: TRUE
[09:29:16.790] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.790] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.790] Packages: <none>
[09:29:16.790] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.790] Resolved: TRUE
[09:29:16.790] Value: <not collected>
[09:29:16.790] Conditions captured: <none>
[09:29:16.790] Early signaling: FALSE
[09:29:16.790] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.790] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.799] Chunk #1 of 1 ... DONE
[09:29:16.799] Launching 1 futures (chunks) ... DONE
[09:29:16.799] Resolving 1 futures (chunks) ...
[09:29:16.800] resolve() on list ...
[09:29:16.800]  recursive: 0
[09:29:16.800]  length: 1
[09:29:16.800] 
[09:29:16.800] Future #1
[09:29:16.800] result() for MulticoreFuture ...
[09:29:16.801] result() for MulticoreFuture ...
[09:29:16.802] result() for MulticoreFuture ... done
[09:29:16.802] result() for MulticoreFuture ... done
[09:29:16.802] result() for MulticoreFuture ...
[09:29:16.802] result() for MulticoreFuture ... done
[09:29:16.802] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:16.802] - nx: 1
[09:29:16.803] - relay: TRUE
[09:29:16.803] - stdout: TRUE
[09:29:16.803] - signal: TRUE
[09:29:16.803] - resignal: FALSE
[09:29:16.803] - force: TRUE
[09:29:16.803] - relayed: [n=1] FALSE
[09:29:16.804] - queued futures: [n=1] FALSE
[09:29:16.804]  - until=1
[09:29:16.804]  - relaying element #1
[09:29:16.804] result() for MulticoreFuture ...
[09:29:16.804] result() for MulticoreFuture ... done
[09:29:16.804] result() for MulticoreFuture ...
[09:29:16.804] result() for MulticoreFuture ... done
[09:29:16.805] result() for MulticoreFuture ...
[09:29:16.805] result() for MulticoreFuture ... done
[09:29:16.805] result() for MulticoreFuture ...
[09:29:16.805] result() for MulticoreFuture ... done
[09:29:16.805] - relayed: [n=1] TRUE
[09:29:16.805] - queued futures: [n=1] TRUE
[09:29:16.805] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:16.805]  length: 0 (resolved future 1)
[09:29:16.806] Relaying remaining futures
[09:29:16.806] signalConditionsASAP(NULL, pos=0) ...
[09:29:16.806] - nx: 1
[09:29:16.806] - relay: TRUE
[09:29:16.806] - stdout: TRUE
[09:29:16.806] - signal: TRUE
[09:29:16.806] - resignal: FALSE
[09:29:16.806] - force: TRUE
[09:29:16.806] - relayed: [n=1] TRUE
[09:29:16.807] - queued futures: [n=1] TRUE
 - flush all
[09:29:16.807] - relayed: [n=1] TRUE
[09:29:16.807] - queued futures: [n=1] TRUE
[09:29:16.807] signalConditionsASAP(NULL, pos=0) ... done
[09:29:16.807] resolve() on list ... DONE
[09:29:16.807] result() for MulticoreFuture ...
[09:29:16.807] result() for MulticoreFuture ... done
[09:29:16.807] result() for MulticoreFuture ...
[09:29:16.807] result() for MulticoreFuture ... done
[09:29:16.808]  - Number of value chunks collected: 1
[09:29:16.808] Resolving 1 futures (chunks) ... DONE
[09:29:16.808] Reducing values from 1 chunks ...
[09:29:16.808]  - Number of values collected after concatenation: 1
[09:29:16.808]  - Number of values expected: 1
[09:29:16.808] Reducing values from 1 chunks ... DONE
[09:29:16.808] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[09:29:16.809] future_mapply() ...
[09:29:16.813] Number of chunks: 2
[09:29:16.813] getGlobalsAndPackagesXApply() ...
[09:29:16.813]  - future.globals: TRUE
[09:29:16.813] getGlobalsAndPackages() ...
[09:29:16.813] Searching for globals...
[09:29:16.818] - globals found: [1] ‘FUN’
[09:29:16.818] Searching for globals ... DONE
[09:29:16.818] Resolving globals: FALSE
[09:29:16.819] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[09:29:16.819] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[09:29:16.819] - globals: [1] ‘FUN’
[09:29:16.820] 
[09:29:16.820] getGlobalsAndPackages() ... DONE
[09:29:16.820]  - globals found/used: [n=1] ‘FUN’
[09:29:16.820]  - needed namespaces: [n=0] 
[09:29:16.820] Finding globals ... DONE
[09:29:16.820] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:16.821] List of 2
[09:29:16.821]  $ ...future.FUN:function (x, y)  
[09:29:16.821]  $ MoreArgs     :List of 1
[09:29:16.821]   ..$ y: int [1:2] 3 4
[09:29:16.821]  - attr(*, "where")=List of 2
[09:29:16.821]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:16.821]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:16.821]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.821]  - attr(*, "resolved")= logi FALSE
[09:29:16.821]  - attr(*, "total_size")= num NA
[09:29:16.825] Packages to be attached in all futures: [n=0] 
[09:29:16.825] getGlobalsAndPackagesXApply() ... DONE
[09:29:16.825] Number of futures (= number of chunks): 2
[09:29:16.825] Launching 2 futures (chunks) ...
[09:29:16.825] Chunk #1 of 2 ...
[09:29:16.825]  - Finding globals in '...' for chunk #1 ...
[09:29:16.826] getGlobalsAndPackages() ...
[09:29:16.826] Searching for globals...
[09:29:16.826] 
[09:29:16.826] Searching for globals ... DONE
[09:29:16.826] - globals: [0] <none>
[09:29:16.826] getGlobalsAndPackages() ... DONE
[09:29:16.826]    + additional globals found: [n=0] 
[09:29:16.827]    + additional namespaces needed: [n=0] 
[09:29:16.827]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:16.827]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:16.827]  - seeds: <none>
[09:29:16.827]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.827] getGlobalsAndPackages() ...
[09:29:16.827] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.827] Resolving globals: FALSE
[09:29:16.828] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[09:29:16.828] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[09:29:16.829] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.829] 
[09:29:16.829] getGlobalsAndPackages() ... DONE
[09:29:16.829] run() for ‘Future’ ...
[09:29:16.829] - state: ‘created’
[09:29:16.829] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.833] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.833] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.833]   - Field: ‘label’
[09:29:16.833]   - Field: ‘local’
[09:29:16.833]   - Field: ‘owner’
[09:29:16.833]   - Field: ‘envir’
[09:29:16.833]   - Field: ‘workers’
[09:29:16.834]   - Field: ‘packages’
[09:29:16.834]   - Field: ‘gc’
[09:29:16.834]   - Field: ‘job’
[09:29:16.834]   - Field: ‘conditions’
[09:29:16.834]   - Field: ‘expr’
[09:29:16.834]   - Field: ‘uuid’
[09:29:16.834]   - Field: ‘seed’
[09:29:16.834]   - Field: ‘version’
[09:29:16.834]   - Field: ‘result’
[09:29:16.834]   - Field: ‘asynchronous’
[09:29:16.834]   - Field: ‘calls’
[09:29:16.834]   - Field: ‘globals’
[09:29:16.835]   - Field: ‘stdout’
[09:29:16.835]   - Field: ‘earlySignal’
[09:29:16.835]   - Field: ‘lazy’
[09:29:16.835]   - Field: ‘state’
[09:29:16.835] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.835] - Launch lazy future ...
[09:29:16.835] Packages needed by the future expression (n = 0): <none>
[09:29:16.835] Packages needed by future strategies (n = 0): <none>
[09:29:16.836] {
[09:29:16.836]     {
[09:29:16.836]         {
[09:29:16.836]             ...future.startTime <- base::Sys.time()
[09:29:16.836]             {
[09:29:16.836]                 {
[09:29:16.836]                   {
[09:29:16.836]                     {
[09:29:16.836]                       base::local({
[09:29:16.836]                         has_future <- base::requireNamespace("future", 
[09:29:16.836]                           quietly = TRUE)
[09:29:16.836]                         if (has_future) {
[09:29:16.836]                           ns <- base::getNamespace("future")
[09:29:16.836]                           version <- ns[[".package"]][["version"]]
[09:29:16.836]                           if (is.null(version)) 
[09:29:16.836]                             version <- utils::packageVersion("future")
[09:29:16.836]                         }
[09:29:16.836]                         else {
[09:29:16.836]                           version <- NULL
[09:29:16.836]                         }
[09:29:16.836]                         if (!has_future || version < "1.8.0") {
[09:29:16.836]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.836]                             "", base::R.version$version.string), 
[09:29:16.836]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.836]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.836]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.836]                               "release", "version")], collapse = " "), 
[09:29:16.836]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.836]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.836]                             info)
[09:29:16.836]                           info <- base::paste(info, collapse = "; ")
[09:29:16.836]                           if (!has_future) {
[09:29:16.836]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.836]                               info)
[09:29:16.836]                           }
[09:29:16.836]                           else {
[09:29:16.836]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.836]                               info, version)
[09:29:16.836]                           }
[09:29:16.836]                           base::stop(msg)
[09:29:16.836]                         }
[09:29:16.836]                       })
[09:29:16.836]                     }
[09:29:16.836]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.836]                     base::options(mc.cores = 1L)
[09:29:16.836]                   }
[09:29:16.836]                   ...future.strategy.old <- future::plan("list")
[09:29:16.836]                   options(future.plan = NULL)
[09:29:16.836]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.836]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.836]                 }
[09:29:16.836]                 ...future.workdir <- getwd()
[09:29:16.836]             }
[09:29:16.836]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.836]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.836]         }
[09:29:16.836]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.836]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:16.836]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.836]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.836]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.836]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.836]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.836]             base::names(...future.oldOptions))
[09:29:16.836]     }
[09:29:16.836]     if (FALSE) {
[09:29:16.836]     }
[09:29:16.836]     else {
[09:29:16.836]         if (TRUE) {
[09:29:16.836]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.836]                 open = "w")
[09:29:16.836]         }
[09:29:16.836]         else {
[09:29:16.836]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.836]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.836]         }
[09:29:16.836]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.836]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.836]             base::sink(type = "output", split = FALSE)
[09:29:16.836]             base::close(...future.stdout)
[09:29:16.836]         }, add = TRUE)
[09:29:16.836]     }
[09:29:16.836]     ...future.frame <- base::sys.nframe()
[09:29:16.836]     ...future.conditions <- base::list()
[09:29:16.836]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.836]     if (FALSE) {
[09:29:16.836]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.836]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.836]     }
[09:29:16.836]     ...future.result <- base::tryCatch({
[09:29:16.836]         base::withCallingHandlers({
[09:29:16.836]             ...future.value <- base::withVisible(base::local({
[09:29:16.836]                 withCallingHandlers({
[09:29:16.836]                   {
[09:29:16.836]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.836]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.836]                       ...future.globals.maxSize)) {
[09:29:16.836]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.836]                       on.exit(options(oopts), add = TRUE)
[09:29:16.836]                     }
[09:29:16.836]                     {
[09:29:16.836]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.836]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.836]                         USE.NAMES = FALSE)
[09:29:16.836]                       do.call(mapply, args = args)
[09:29:16.836]                     }
[09:29:16.836]                   }
[09:29:16.836]                 }, immediateCondition = function(cond) {
[09:29:16.836]                   save_rds <- function (object, pathname, ...) 
[09:29:16.836]                   {
[09:29:16.836]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.836]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.836]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.836]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.836]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.836]                         fi_tmp[["mtime"]])
[09:29:16.836]                     }
[09:29:16.836]                     tryCatch({
[09:29:16.836]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.836]                     }, error = function(ex) {
[09:29:16.836]                       msg <- conditionMessage(ex)
[09:29:16.836]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.836]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.836]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.836]                         fi_tmp[["mtime"]], msg)
[09:29:16.836]                       ex$message <- msg
[09:29:16.836]                       stop(ex)
[09:29:16.836]                     })
[09:29:16.836]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.836]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.836]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.836]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.836]                       fi <- file.info(pathname)
[09:29:16.836]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.836]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.836]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.836]                         fi[["size"]], fi[["mtime"]])
[09:29:16.836]                       stop(msg)
[09:29:16.836]                     }
[09:29:16.836]                     invisible(pathname)
[09:29:16.836]                   }
[09:29:16.836]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.836]                     rootPath = tempdir()) 
[09:29:16.836]                   {
[09:29:16.836]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.836]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.836]                       tmpdir = path, fileext = ".rds")
[09:29:16.836]                     save_rds(obj, file)
[09:29:16.836]                   }
[09:29:16.836]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.836]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.836]                   {
[09:29:16.836]                     inherits <- base::inherits
[09:29:16.836]                     invokeRestart <- base::invokeRestart
[09:29:16.836]                     is.null <- base::is.null
[09:29:16.836]                     muffled <- FALSE
[09:29:16.836]                     if (inherits(cond, "message")) {
[09:29:16.836]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.836]                       if (muffled) 
[09:29:16.836]                         invokeRestart("muffleMessage")
[09:29:16.836]                     }
[09:29:16.836]                     else if (inherits(cond, "warning")) {
[09:29:16.836]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.836]                       if (muffled) 
[09:29:16.836]                         invokeRestart("muffleWarning")
[09:29:16.836]                     }
[09:29:16.836]                     else if (inherits(cond, "condition")) {
[09:29:16.836]                       if (!is.null(pattern)) {
[09:29:16.836]                         computeRestarts <- base::computeRestarts
[09:29:16.836]                         grepl <- base::grepl
[09:29:16.836]                         restarts <- computeRestarts(cond)
[09:29:16.836]                         for (restart in restarts) {
[09:29:16.836]                           name <- restart$name
[09:29:16.836]                           if (is.null(name)) 
[09:29:16.836]                             next
[09:29:16.836]                           if (!grepl(pattern, name)) 
[09:29:16.836]                             next
[09:29:16.836]                           invokeRestart(restart)
[09:29:16.836]                           muffled <- TRUE
[09:29:16.836]                           break
[09:29:16.836]                         }
[09:29:16.836]                       }
[09:29:16.836]                     }
[09:29:16.836]                     invisible(muffled)
[09:29:16.836]                   }
[09:29:16.836]                   muffleCondition(cond)
[09:29:16.836]                 })
[09:29:16.836]             }))
[09:29:16.836]             future::FutureResult(value = ...future.value$value, 
[09:29:16.836]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.836]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.836]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.836]                     ...future.globalenv.names))
[09:29:16.836]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.836]         }, condition = base::local({
[09:29:16.836]             c <- base::c
[09:29:16.836]             inherits <- base::inherits
[09:29:16.836]             invokeRestart <- base::invokeRestart
[09:29:16.836]             length <- base::length
[09:29:16.836]             list <- base::list
[09:29:16.836]             seq.int <- base::seq.int
[09:29:16.836]             signalCondition <- base::signalCondition
[09:29:16.836]             sys.calls <- base::sys.calls
[09:29:16.836]             `[[` <- base::`[[`
[09:29:16.836]             `+` <- base::`+`
[09:29:16.836]             `<<-` <- base::`<<-`
[09:29:16.836]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.836]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.836]                   3L)]
[09:29:16.836]             }
[09:29:16.836]             function(cond) {
[09:29:16.836]                 is_error <- inherits(cond, "error")
[09:29:16.836]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.836]                   NULL)
[09:29:16.836]                 if (is_error) {
[09:29:16.836]                   sessionInformation <- function() {
[09:29:16.836]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.836]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.836]                       search = base::search(), system = base::Sys.info())
[09:29:16.836]                   }
[09:29:16.836]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.836]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.836]                     cond$call), session = sessionInformation(), 
[09:29:16.836]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.836]                   signalCondition(cond)
[09:29:16.836]                 }
[09:29:16.836]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.836]                 "immediateCondition"))) {
[09:29:16.836]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.836]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.836]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.836]                   if (TRUE && !signal) {
[09:29:16.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.836]                     {
[09:29:16.836]                       inherits <- base::inherits
[09:29:16.836]                       invokeRestart <- base::invokeRestart
[09:29:16.836]                       is.null <- base::is.null
[09:29:16.836]                       muffled <- FALSE
[09:29:16.836]                       if (inherits(cond, "message")) {
[09:29:16.836]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.836]                         if (muffled) 
[09:29:16.836]                           invokeRestart("muffleMessage")
[09:29:16.836]                       }
[09:29:16.836]                       else if (inherits(cond, "warning")) {
[09:29:16.836]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.836]                         if (muffled) 
[09:29:16.836]                           invokeRestart("muffleWarning")
[09:29:16.836]                       }
[09:29:16.836]                       else if (inherits(cond, "condition")) {
[09:29:16.836]                         if (!is.null(pattern)) {
[09:29:16.836]                           computeRestarts <- base::computeRestarts
[09:29:16.836]                           grepl <- base::grepl
[09:29:16.836]                           restarts <- computeRestarts(cond)
[09:29:16.836]                           for (restart in restarts) {
[09:29:16.836]                             name <- restart$name
[09:29:16.836]                             if (is.null(name)) 
[09:29:16.836]                               next
[09:29:16.836]                             if (!grepl(pattern, name)) 
[09:29:16.836]                               next
[09:29:16.836]                             invokeRestart(restart)
[09:29:16.836]                             muffled <- TRUE
[09:29:16.836]                             break
[09:29:16.836]                           }
[09:29:16.836]                         }
[09:29:16.836]                       }
[09:29:16.836]                       invisible(muffled)
[09:29:16.836]                     }
[09:29:16.836]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.836]                   }
[09:29:16.836]                 }
[09:29:16.836]                 else {
[09:29:16.836]                   if (TRUE) {
[09:29:16.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.836]                     {
[09:29:16.836]                       inherits <- base::inherits
[09:29:16.836]                       invokeRestart <- base::invokeRestart
[09:29:16.836]                       is.null <- base::is.null
[09:29:16.836]                       muffled <- FALSE
[09:29:16.836]                       if (inherits(cond, "message")) {
[09:29:16.836]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.836]                         if (muffled) 
[09:29:16.836]                           invokeRestart("muffleMessage")
[09:29:16.836]                       }
[09:29:16.836]                       else if (inherits(cond, "warning")) {
[09:29:16.836]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.836]                         if (muffled) 
[09:29:16.836]                           invokeRestart("muffleWarning")
[09:29:16.836]                       }
[09:29:16.836]                       else if (inherits(cond, "condition")) {
[09:29:16.836]                         if (!is.null(pattern)) {
[09:29:16.836]                           computeRestarts <- base::computeRestarts
[09:29:16.836]                           grepl <- base::grepl
[09:29:16.836]                           restarts <- computeRestarts(cond)
[09:29:16.836]                           for (restart in restarts) {
[09:29:16.836]                             name <- restart$name
[09:29:16.836]                             if (is.null(name)) 
[09:29:16.836]                               next
[09:29:16.836]                             if (!grepl(pattern, name)) 
[09:29:16.836]                               next
[09:29:16.836]                             invokeRestart(restart)
[09:29:16.836]                             muffled <- TRUE
[09:29:16.836]                             break
[09:29:16.836]                           }
[09:29:16.836]                         }
[09:29:16.836]                       }
[09:29:16.836]                       invisible(muffled)
[09:29:16.836]                     }
[09:29:16.836]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.836]                   }
[09:29:16.836]                 }
[09:29:16.836]             }
[09:29:16.836]         }))
[09:29:16.836]     }, error = function(ex) {
[09:29:16.836]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.836]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.836]                 ...future.rng), started = ...future.startTime, 
[09:29:16.836]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.836]             version = "1.8"), class = "FutureResult")
[09:29:16.836]     }, finally = {
[09:29:16.836]         if (!identical(...future.workdir, getwd())) 
[09:29:16.836]             setwd(...future.workdir)
[09:29:16.836]         {
[09:29:16.836]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.836]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.836]             }
[09:29:16.836]             base::options(...future.oldOptions)
[09:29:16.836]             if (.Platform$OS.type == "windows") {
[09:29:16.836]                 old_names <- names(...future.oldEnvVars)
[09:29:16.836]                 envs <- base::Sys.getenv()
[09:29:16.836]                 names <- names(envs)
[09:29:16.836]                 common <- intersect(names, old_names)
[09:29:16.836]                 added <- setdiff(names, old_names)
[09:29:16.836]                 removed <- setdiff(old_names, names)
[09:29:16.836]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.836]                   envs[common]]
[09:29:16.836]                 NAMES <- toupper(changed)
[09:29:16.836]                 args <- list()
[09:29:16.836]                 for (kk in seq_along(NAMES)) {
[09:29:16.836]                   name <- changed[[kk]]
[09:29:16.836]                   NAME <- NAMES[[kk]]
[09:29:16.836]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.836]                     next
[09:29:16.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.836]                 }
[09:29:16.836]                 NAMES <- toupper(added)
[09:29:16.836]                 for (kk in seq_along(NAMES)) {
[09:29:16.836]                   name <- added[[kk]]
[09:29:16.836]                   NAME <- NAMES[[kk]]
[09:29:16.836]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.836]                     next
[09:29:16.836]                   args[[name]] <- ""
[09:29:16.836]                 }
[09:29:16.836]                 NAMES <- toupper(removed)
[09:29:16.836]                 for (kk in seq_along(NAMES)) {
[09:29:16.836]                   name <- removed[[kk]]
[09:29:16.836]                   NAME <- NAMES[[kk]]
[09:29:16.836]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.836]                     next
[09:29:16.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.836]                 }
[09:29:16.836]                 if (length(args) > 0) 
[09:29:16.836]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.836]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.836]             }
[09:29:16.836]             else {
[09:29:16.836]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.836]             }
[09:29:16.836]             {
[09:29:16.836]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.836]                   0L) {
[09:29:16.836]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.836]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.836]                   base::options(opts)
[09:29:16.836]                 }
[09:29:16.836]                 {
[09:29:16.836]                   {
[09:29:16.836]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.836]                     NULL
[09:29:16.836]                   }
[09:29:16.836]                   options(future.plan = NULL)
[09:29:16.836]                   if (is.na(NA_character_)) 
[09:29:16.836]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.836]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.836]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.836]                     .init = FALSE)
[09:29:16.836]                 }
[09:29:16.836]             }
[09:29:16.836]         }
[09:29:16.836]     })
[09:29:16.836]     if (TRUE) {
[09:29:16.836]         base::sink(type = "output", split = FALSE)
[09:29:16.836]         if (TRUE) {
[09:29:16.836]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.836]         }
[09:29:16.836]         else {
[09:29:16.836]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.836]         }
[09:29:16.836]         base::close(...future.stdout)
[09:29:16.836]         ...future.stdout <- NULL
[09:29:16.836]     }
[09:29:16.836]     ...future.result$conditions <- ...future.conditions
[09:29:16.836]     ...future.result$finished <- base::Sys.time()
[09:29:16.836]     ...future.result
[09:29:16.836] }
[09:29:16.838] assign_globals() ...
[09:29:16.838] List of 5
[09:29:16.838]  $ ...future.FUN            :function (x, y)  
[09:29:16.838]  $ MoreArgs                 :List of 1
[09:29:16.838]   ..$ y: int [1:2] 3 4
[09:29:16.838]  $ ...future.elements_ii    :List of 1
[09:29:16.838]   ..$ x:List of 1
[09:29:16.838]   .. ..$ : int 1
[09:29:16.838]  $ ...future.seeds_ii       : NULL
[09:29:16.838]  $ ...future.globals.maxSize: NULL
[09:29:16.838]  - attr(*, "where")=List of 5
[09:29:16.838]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.838]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.838]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.838]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.838]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.838]  - attr(*, "resolved")= logi FALSE
[09:29:16.838]  - attr(*, "total_size")= num 1816
[09:29:16.838]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.838]  - attr(*, "already-done")= logi TRUE
[09:29:16.846] - reassign environment for ‘...future.FUN’
[09:29:16.846] - copied ‘...future.FUN’ to environment
[09:29:16.846] - copied ‘MoreArgs’ to environment
[09:29:16.846] - copied ‘...future.elements_ii’ to environment
[09:29:16.846] - copied ‘...future.seeds_ii’ to environment
[09:29:16.846] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.846] assign_globals() ... done
[09:29:16.846] requestCore(): workers = 2
[09:29:16.849] MulticoreFuture started
[09:29:16.849] - Launch lazy future ... done
[09:29:16.850] plan(): Setting new future strategy stack:
[09:29:16.850] run() for ‘MulticoreFuture’ ... done
[09:29:16.851] Created future:
[09:29:16.850] List of future strategies:
[09:29:16.850] 1. sequential:
[09:29:16.850]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.850]    - tweaked: FALSE
[09:29:16.850]    - call: NULL
[09:29:16.852] plan(): nbrOfWorkers() = 1
[09:29:16.855] plan(): Setting new future strategy stack:
[09:29:16.855] List of future strategies:
[09:29:16.855] 1. multicore:
[09:29:16.855]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.855]    - tweaked: FALSE
[09:29:16.855]    - call: plan(strategy)
[09:29:16.862] plan(): nbrOfWorkers() = 2
[09:29:16.851] MulticoreFuture:
[09:29:16.851] Label: ‘future_mapply-1’
[09:29:16.851] Expression:
[09:29:16.851] {
[09:29:16.851]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.851]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.851]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.851]         on.exit(options(oopts), add = TRUE)
[09:29:16.851]     }
[09:29:16.851]     {
[09:29:16.851]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.851]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.851]         do.call(mapply, args = args)
[09:29:16.851]     }
[09:29:16.851] }
[09:29:16.851] Lazy evaluation: FALSE
[09:29:16.851] Asynchronous evaluation: TRUE
[09:29:16.851] Local evaluation: TRUE
[09:29:16.851] Environment: R_GlobalEnv
[09:29:16.851] Capture standard output: TRUE
[09:29:16.851] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.851] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.851] Packages: <none>
[09:29:16.851] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.851] Resolved: TRUE
[09:29:16.851] Value: <not collected>
[09:29:16.851] Conditions captured: <none>
[09:29:16.851] Early signaling: FALSE
[09:29:16.851] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.851] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.863] Chunk #1 of 2 ... DONE
[09:29:16.863] Chunk #2 of 2 ...
[09:29:16.864]  - Finding globals in '...' for chunk #2 ...
[09:29:16.864] getGlobalsAndPackages() ...
[09:29:16.864] Searching for globals...
[09:29:16.865] 
[09:29:16.865] Searching for globals ... DONE
[09:29:16.865] - globals: [0] <none>
[09:29:16.865] getGlobalsAndPackages() ... DONE
[09:29:16.866]    + additional globals found: [n=0] 
[09:29:16.866]    + additional namespaces needed: [n=0] 
[09:29:16.866]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:16.866]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:16.866]  - seeds: <none>
[09:29:16.866]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.867] getGlobalsAndPackages() ...
[09:29:16.867] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.867] Resolving globals: FALSE
[09:29:16.868] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[09:29:16.868] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[09:29:16.869] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.869] 
[09:29:16.869] getGlobalsAndPackages() ... DONE
[09:29:16.869] run() for ‘Future’ ...
[09:29:16.870] - state: ‘created’
[09:29:16.870] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.875] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.875] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.875]   - Field: ‘label’
[09:29:16.875]   - Field: ‘local’
[09:29:16.875]   - Field: ‘owner’
[09:29:16.875]   - Field: ‘envir’
[09:29:16.875]   - Field: ‘workers’
[09:29:16.876]   - Field: ‘packages’
[09:29:16.876]   - Field: ‘gc’
[09:29:16.876]   - Field: ‘job’
[09:29:16.876]   - Field: ‘conditions’
[09:29:16.876]   - Field: ‘expr’
[09:29:16.876]   - Field: ‘uuid’
[09:29:16.876]   - Field: ‘seed’
[09:29:16.876]   - Field: ‘version’
[09:29:16.877]   - Field: ‘result’
[09:29:16.877]   - Field: ‘asynchronous’
[09:29:16.877]   - Field: ‘calls’
[09:29:16.877]   - Field: ‘globals’
[09:29:16.877]   - Field: ‘stdout’
[09:29:16.877]   - Field: ‘earlySignal’
[09:29:16.877]   - Field: ‘lazy’
[09:29:16.878]   - Field: ‘state’
[09:29:16.878] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.878] - Launch lazy future ...
[09:29:16.878] Packages needed by the future expression (n = 0): <none>
[09:29:16.878] Packages needed by future strategies (n = 0): <none>
[09:29:16.879] {
[09:29:16.879]     {
[09:29:16.879]         {
[09:29:16.879]             ...future.startTime <- base::Sys.time()
[09:29:16.879]             {
[09:29:16.879]                 {
[09:29:16.879]                   {
[09:29:16.879]                     {
[09:29:16.879]                       base::local({
[09:29:16.879]                         has_future <- base::requireNamespace("future", 
[09:29:16.879]                           quietly = TRUE)
[09:29:16.879]                         if (has_future) {
[09:29:16.879]                           ns <- base::getNamespace("future")
[09:29:16.879]                           version <- ns[[".package"]][["version"]]
[09:29:16.879]                           if (is.null(version)) 
[09:29:16.879]                             version <- utils::packageVersion("future")
[09:29:16.879]                         }
[09:29:16.879]                         else {
[09:29:16.879]                           version <- NULL
[09:29:16.879]                         }
[09:29:16.879]                         if (!has_future || version < "1.8.0") {
[09:29:16.879]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.879]                             "", base::R.version$version.string), 
[09:29:16.879]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.879]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.879]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.879]                               "release", "version")], collapse = " "), 
[09:29:16.879]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.879]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.879]                             info)
[09:29:16.879]                           info <- base::paste(info, collapse = "; ")
[09:29:16.879]                           if (!has_future) {
[09:29:16.879]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.879]                               info)
[09:29:16.879]                           }
[09:29:16.879]                           else {
[09:29:16.879]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.879]                               info, version)
[09:29:16.879]                           }
[09:29:16.879]                           base::stop(msg)
[09:29:16.879]                         }
[09:29:16.879]                       })
[09:29:16.879]                     }
[09:29:16.879]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.879]                     base::options(mc.cores = 1L)
[09:29:16.879]                   }
[09:29:16.879]                   ...future.strategy.old <- future::plan("list")
[09:29:16.879]                   options(future.plan = NULL)
[09:29:16.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.879]                 }
[09:29:16.879]                 ...future.workdir <- getwd()
[09:29:16.879]             }
[09:29:16.879]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.879]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.879]         }
[09:29:16.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.879]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:16.879]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.879]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.879]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.879]             base::names(...future.oldOptions))
[09:29:16.879]     }
[09:29:16.879]     if (FALSE) {
[09:29:16.879]     }
[09:29:16.879]     else {
[09:29:16.879]         if (TRUE) {
[09:29:16.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.879]                 open = "w")
[09:29:16.879]         }
[09:29:16.879]         else {
[09:29:16.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.879]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.879]         }
[09:29:16.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.879]             base::sink(type = "output", split = FALSE)
[09:29:16.879]             base::close(...future.stdout)
[09:29:16.879]         }, add = TRUE)
[09:29:16.879]     }
[09:29:16.879]     ...future.frame <- base::sys.nframe()
[09:29:16.879]     ...future.conditions <- base::list()
[09:29:16.879]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.879]     if (FALSE) {
[09:29:16.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.879]     }
[09:29:16.879]     ...future.result <- base::tryCatch({
[09:29:16.879]         base::withCallingHandlers({
[09:29:16.879]             ...future.value <- base::withVisible(base::local({
[09:29:16.879]                 withCallingHandlers({
[09:29:16.879]                   {
[09:29:16.879]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.879]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.879]                       ...future.globals.maxSize)) {
[09:29:16.879]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.879]                       on.exit(options(oopts), add = TRUE)
[09:29:16.879]                     }
[09:29:16.879]                     {
[09:29:16.879]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.879]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.879]                         USE.NAMES = FALSE)
[09:29:16.879]                       do.call(mapply, args = args)
[09:29:16.879]                     }
[09:29:16.879]                   }
[09:29:16.879]                 }, immediateCondition = function(cond) {
[09:29:16.879]                   save_rds <- function (object, pathname, ...) 
[09:29:16.879]                   {
[09:29:16.879]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.879]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.879]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.879]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.879]                         fi_tmp[["mtime"]])
[09:29:16.879]                     }
[09:29:16.879]                     tryCatch({
[09:29:16.879]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.879]                     }, error = function(ex) {
[09:29:16.879]                       msg <- conditionMessage(ex)
[09:29:16.879]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.879]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.879]                         fi_tmp[["mtime"]], msg)
[09:29:16.879]                       ex$message <- msg
[09:29:16.879]                       stop(ex)
[09:29:16.879]                     })
[09:29:16.879]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.879]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.879]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.879]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.879]                       fi <- file.info(pathname)
[09:29:16.879]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.879]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.879]                         fi[["size"]], fi[["mtime"]])
[09:29:16.879]                       stop(msg)
[09:29:16.879]                     }
[09:29:16.879]                     invisible(pathname)
[09:29:16.879]                   }
[09:29:16.879]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.879]                     rootPath = tempdir()) 
[09:29:16.879]                   {
[09:29:16.879]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.879]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.879]                       tmpdir = path, fileext = ".rds")
[09:29:16.879]                     save_rds(obj, file)
[09:29:16.879]                   }
[09:29:16.879]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.879]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.879]                   {
[09:29:16.879]                     inherits <- base::inherits
[09:29:16.879]                     invokeRestart <- base::invokeRestart
[09:29:16.879]                     is.null <- base::is.null
[09:29:16.879]                     muffled <- FALSE
[09:29:16.879]                     if (inherits(cond, "message")) {
[09:29:16.879]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.879]                       if (muffled) 
[09:29:16.879]                         invokeRestart("muffleMessage")
[09:29:16.879]                     }
[09:29:16.879]                     else if (inherits(cond, "warning")) {
[09:29:16.879]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.879]                       if (muffled) 
[09:29:16.879]                         invokeRestart("muffleWarning")
[09:29:16.879]                     }
[09:29:16.879]                     else if (inherits(cond, "condition")) {
[09:29:16.879]                       if (!is.null(pattern)) {
[09:29:16.879]                         computeRestarts <- base::computeRestarts
[09:29:16.879]                         grepl <- base::grepl
[09:29:16.879]                         restarts <- computeRestarts(cond)
[09:29:16.879]                         for (restart in restarts) {
[09:29:16.879]                           name <- restart$name
[09:29:16.879]                           if (is.null(name)) 
[09:29:16.879]                             next
[09:29:16.879]                           if (!grepl(pattern, name)) 
[09:29:16.879]                             next
[09:29:16.879]                           invokeRestart(restart)
[09:29:16.879]                           muffled <- TRUE
[09:29:16.879]                           break
[09:29:16.879]                         }
[09:29:16.879]                       }
[09:29:16.879]                     }
[09:29:16.879]                     invisible(muffled)
[09:29:16.879]                   }
[09:29:16.879]                   muffleCondition(cond)
[09:29:16.879]                 })
[09:29:16.879]             }))
[09:29:16.879]             future::FutureResult(value = ...future.value$value, 
[09:29:16.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.879]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.879]                     ...future.globalenv.names))
[09:29:16.879]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.879]         }, condition = base::local({
[09:29:16.879]             c <- base::c
[09:29:16.879]             inherits <- base::inherits
[09:29:16.879]             invokeRestart <- base::invokeRestart
[09:29:16.879]             length <- base::length
[09:29:16.879]             list <- base::list
[09:29:16.879]             seq.int <- base::seq.int
[09:29:16.879]             signalCondition <- base::signalCondition
[09:29:16.879]             sys.calls <- base::sys.calls
[09:29:16.879]             `[[` <- base::`[[`
[09:29:16.879]             `+` <- base::`+`
[09:29:16.879]             `<<-` <- base::`<<-`
[09:29:16.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.879]                   3L)]
[09:29:16.879]             }
[09:29:16.879]             function(cond) {
[09:29:16.879]                 is_error <- inherits(cond, "error")
[09:29:16.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.879]                   NULL)
[09:29:16.879]                 if (is_error) {
[09:29:16.879]                   sessionInformation <- function() {
[09:29:16.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.879]                       search = base::search(), system = base::Sys.info())
[09:29:16.879]                   }
[09:29:16.879]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.879]                     cond$call), session = sessionInformation(), 
[09:29:16.879]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.879]                   signalCondition(cond)
[09:29:16.879]                 }
[09:29:16.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.879]                 "immediateCondition"))) {
[09:29:16.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.879]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.879]                   if (TRUE && !signal) {
[09:29:16.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.879]                     {
[09:29:16.879]                       inherits <- base::inherits
[09:29:16.879]                       invokeRestart <- base::invokeRestart
[09:29:16.879]                       is.null <- base::is.null
[09:29:16.879]                       muffled <- FALSE
[09:29:16.879]                       if (inherits(cond, "message")) {
[09:29:16.879]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.879]                         if (muffled) 
[09:29:16.879]                           invokeRestart("muffleMessage")
[09:29:16.879]                       }
[09:29:16.879]                       else if (inherits(cond, "warning")) {
[09:29:16.879]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.879]                         if (muffled) 
[09:29:16.879]                           invokeRestart("muffleWarning")
[09:29:16.879]                       }
[09:29:16.879]                       else if (inherits(cond, "condition")) {
[09:29:16.879]                         if (!is.null(pattern)) {
[09:29:16.879]                           computeRestarts <- base::computeRestarts
[09:29:16.879]                           grepl <- base::grepl
[09:29:16.879]                           restarts <- computeRestarts(cond)
[09:29:16.879]                           for (restart in restarts) {
[09:29:16.879]                             name <- restart$name
[09:29:16.879]                             if (is.null(name)) 
[09:29:16.879]                               next
[09:29:16.879]                             if (!grepl(pattern, name)) 
[09:29:16.879]                               next
[09:29:16.879]                             invokeRestart(restart)
[09:29:16.879]                             muffled <- TRUE
[09:29:16.879]                             break
[09:29:16.879]                           }
[09:29:16.879]                         }
[09:29:16.879]                       }
[09:29:16.879]                       invisible(muffled)
[09:29:16.879]                     }
[09:29:16.879]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.879]                   }
[09:29:16.879]                 }
[09:29:16.879]                 else {
[09:29:16.879]                   if (TRUE) {
[09:29:16.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.879]                     {
[09:29:16.879]                       inherits <- base::inherits
[09:29:16.879]                       invokeRestart <- base::invokeRestart
[09:29:16.879]                       is.null <- base::is.null
[09:29:16.879]                       muffled <- FALSE
[09:29:16.879]                       if (inherits(cond, "message")) {
[09:29:16.879]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.879]                         if (muffled) 
[09:29:16.879]                           invokeRestart("muffleMessage")
[09:29:16.879]                       }
[09:29:16.879]                       else if (inherits(cond, "warning")) {
[09:29:16.879]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.879]                         if (muffled) 
[09:29:16.879]                           invokeRestart("muffleWarning")
[09:29:16.879]                       }
[09:29:16.879]                       else if (inherits(cond, "condition")) {
[09:29:16.879]                         if (!is.null(pattern)) {
[09:29:16.879]                           computeRestarts <- base::computeRestarts
[09:29:16.879]                           grepl <- base::grepl
[09:29:16.879]                           restarts <- computeRestarts(cond)
[09:29:16.879]                           for (restart in restarts) {
[09:29:16.879]                             name <- restart$name
[09:29:16.879]                             if (is.null(name)) 
[09:29:16.879]                               next
[09:29:16.879]                             if (!grepl(pattern, name)) 
[09:29:16.879]                               next
[09:29:16.879]                             invokeRestart(restart)
[09:29:16.879]                             muffled <- TRUE
[09:29:16.879]                             break
[09:29:16.879]                           }
[09:29:16.879]                         }
[09:29:16.879]                       }
[09:29:16.879]                       invisible(muffled)
[09:29:16.879]                     }
[09:29:16.879]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.879]                   }
[09:29:16.879]                 }
[09:29:16.879]             }
[09:29:16.879]         }))
[09:29:16.879]     }, error = function(ex) {
[09:29:16.879]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.879]                 ...future.rng), started = ...future.startTime, 
[09:29:16.879]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.879]             version = "1.8"), class = "FutureResult")
[09:29:16.879]     }, finally = {
[09:29:16.879]         if (!identical(...future.workdir, getwd())) 
[09:29:16.879]             setwd(...future.workdir)
[09:29:16.879]         {
[09:29:16.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.879]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.879]             }
[09:29:16.879]             base::options(...future.oldOptions)
[09:29:16.879]             if (.Platform$OS.type == "windows") {
[09:29:16.879]                 old_names <- names(...future.oldEnvVars)
[09:29:16.879]                 envs <- base::Sys.getenv()
[09:29:16.879]                 names <- names(envs)
[09:29:16.879]                 common <- intersect(names, old_names)
[09:29:16.879]                 added <- setdiff(names, old_names)
[09:29:16.879]                 removed <- setdiff(old_names, names)
[09:29:16.879]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.879]                   envs[common]]
[09:29:16.879]                 NAMES <- toupper(changed)
[09:29:16.879]                 args <- list()
[09:29:16.879]                 for (kk in seq_along(NAMES)) {
[09:29:16.879]                   name <- changed[[kk]]
[09:29:16.879]                   NAME <- NAMES[[kk]]
[09:29:16.879]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.879]                     next
[09:29:16.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.879]                 }
[09:29:16.879]                 NAMES <- toupper(added)
[09:29:16.879]                 for (kk in seq_along(NAMES)) {
[09:29:16.879]                   name <- added[[kk]]
[09:29:16.879]                   NAME <- NAMES[[kk]]
[09:29:16.879]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.879]                     next
[09:29:16.879]                   args[[name]] <- ""
[09:29:16.879]                 }
[09:29:16.879]                 NAMES <- toupper(removed)
[09:29:16.879]                 for (kk in seq_along(NAMES)) {
[09:29:16.879]                   name <- removed[[kk]]
[09:29:16.879]                   NAME <- NAMES[[kk]]
[09:29:16.879]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.879]                     next
[09:29:16.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.879]                 }
[09:29:16.879]                 if (length(args) > 0) 
[09:29:16.879]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.879]             }
[09:29:16.879]             else {
[09:29:16.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.879]             }
[09:29:16.879]             {
[09:29:16.879]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.879]                   0L) {
[09:29:16.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.879]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.879]                   base::options(opts)
[09:29:16.879]                 }
[09:29:16.879]                 {
[09:29:16.879]                   {
[09:29:16.879]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.879]                     NULL
[09:29:16.879]                   }
[09:29:16.879]                   options(future.plan = NULL)
[09:29:16.879]                   if (is.na(NA_character_)) 
[09:29:16.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.879]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.879]                     .init = FALSE)
[09:29:16.879]                 }
[09:29:16.879]             }
[09:29:16.879]         }
[09:29:16.879]     })
[09:29:16.879]     if (TRUE) {
[09:29:16.879]         base::sink(type = "output", split = FALSE)
[09:29:16.879]         if (TRUE) {
[09:29:16.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.879]         }
[09:29:16.879]         else {
[09:29:16.879]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.879]         }
[09:29:16.879]         base::close(...future.stdout)
[09:29:16.879]         ...future.stdout <- NULL
[09:29:16.879]     }
[09:29:16.879]     ...future.result$conditions <- ...future.conditions
[09:29:16.879]     ...future.result$finished <- base::Sys.time()
[09:29:16.879]     ...future.result
[09:29:16.879] }
[09:29:16.882] assign_globals() ...
[09:29:16.882] List of 5
[09:29:16.882]  $ ...future.FUN            :function (x, y)  
[09:29:16.882]  $ MoreArgs                 :List of 1
[09:29:16.882]   ..$ y: int [1:2] 3 4
[09:29:16.882]  $ ...future.elements_ii    :List of 1
[09:29:16.882]   ..$ x:List of 1
[09:29:16.882]   .. ..$ : int 2
[09:29:16.882]  $ ...future.seeds_ii       : NULL
[09:29:16.882]  $ ...future.globals.maxSize: NULL
[09:29:16.882]  - attr(*, "where")=List of 5
[09:29:16.882]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.882]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.882]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.882]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.882]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.882]  - attr(*, "resolved")= logi FALSE
[09:29:16.882]  - attr(*, "total_size")= num 1816
[09:29:16.882]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.882]  - attr(*, "already-done")= logi TRUE
[09:29:16.889] - reassign environment for ‘...future.FUN’
[09:29:16.889] - copied ‘...future.FUN’ to environment
[09:29:16.889] - copied ‘MoreArgs’ to environment
[09:29:16.889] - copied ‘...future.elements_ii’ to environment
[09:29:16.890] - copied ‘...future.seeds_ii’ to environment
[09:29:16.890] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.890] assign_globals() ... done
[09:29:16.890] requestCore(): workers = 2
[09:29:16.892] MulticoreFuture started
[09:29:16.903] - Launch lazy future ... done
[09:29:16.904] run() for ‘MulticoreFuture’ ... done
[09:29:16.904] plan(): Setting new future strategy stack:
[09:29:16.904] Created future:
[09:29:16.904] List of future strategies:
[09:29:16.904] 1. sequential:
[09:29:16.904]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.904]    - tweaked: FALSE
[09:29:16.904]    - call: NULL
[09:29:16.905] plan(): nbrOfWorkers() = 1
[09:29:16.907] plan(): Setting new future strategy stack:
[09:29:16.907] List of future strategies:
[09:29:16.907] 1. multicore:
[09:29:16.907]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.907]    - tweaked: FALSE
[09:29:16.907]    - call: plan(strategy)
[09:29:16.913] plan(): nbrOfWorkers() = 2
[09:29:16.904] MulticoreFuture:
[09:29:16.904] Label: ‘future_mapply-2’
[09:29:16.904] Expression:
[09:29:16.904] {
[09:29:16.904]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.904]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.904]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.904]         on.exit(options(oopts), add = TRUE)
[09:29:16.904]     }
[09:29:16.904]     {
[09:29:16.904]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:16.904]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.904]         do.call(mapply, args = args)
[09:29:16.904]     }
[09:29:16.904] }
[09:29:16.904] Lazy evaluation: FALSE
[09:29:16.904] Asynchronous evaluation: TRUE
[09:29:16.904] Local evaluation: TRUE
[09:29:16.904] Environment: R_GlobalEnv
[09:29:16.904] Capture standard output: TRUE
[09:29:16.904] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.904] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.904] Packages: <none>
[09:29:16.904] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:16.904] Resolved: TRUE
[09:29:16.904] Value: <not collected>
[09:29:16.904] Conditions captured: <none>
[09:29:16.904] Early signaling: FALSE
[09:29:16.904] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.904] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.914] Chunk #2 of 2 ... DONE
[09:29:16.914] Launching 2 futures (chunks) ... DONE
[09:29:16.914] Resolving 2 futures (chunks) ...
[09:29:16.914] resolve() on list ...
[09:29:16.914]  recursive: 0
[09:29:16.914]  length: 2
[09:29:16.914] 
[09:29:16.915] Future #1
[09:29:16.915] result() for MulticoreFuture ...
[09:29:16.916] result() for MulticoreFuture ...
[09:29:16.916] result() for MulticoreFuture ... done
[09:29:16.916] result() for MulticoreFuture ... done
[09:29:16.917] result() for MulticoreFuture ...
[09:29:16.917] result() for MulticoreFuture ... done
[09:29:16.917] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:16.917] - nx: 2
[09:29:16.917] - relay: TRUE
[09:29:16.918] - stdout: TRUE
[09:29:16.918] - signal: TRUE
[09:29:16.918] - resignal: FALSE
[09:29:16.918] - force: TRUE
[09:29:16.918] - relayed: [n=2] FALSE, FALSE
[09:29:16.918] - queued futures: [n=2] FALSE, FALSE
[09:29:16.919]  - until=1
[09:29:16.919]  - relaying element #1
[09:29:16.919] result() for MulticoreFuture ...
[09:29:16.919] result() for MulticoreFuture ... done
[09:29:16.919] result() for MulticoreFuture ...
[09:29:16.919] result() for MulticoreFuture ... done
[09:29:16.920] result() for MulticoreFuture ...
[09:29:16.920] result() for MulticoreFuture ... done
[09:29:16.920] result() for MulticoreFuture ...
[09:29:16.920] result() for MulticoreFuture ... done
[09:29:16.920] - relayed: [n=2] TRUE, FALSE
[09:29:16.921] - queued futures: [n=2] TRUE, FALSE
[09:29:16.921] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:16.921]  length: 1 (resolved future 1)
[09:29:16.921] Future #2
[09:29:16.922] result() for MulticoreFuture ...
[09:29:16.922] result() for MulticoreFuture ...
[09:29:16.923] result() for MulticoreFuture ... done
[09:29:16.923] result() for MulticoreFuture ... done
[09:29:16.923] result() for MulticoreFuture ...
[09:29:16.923] result() for MulticoreFuture ... done
[09:29:16.923] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:16.923] - nx: 2
[09:29:16.924] - relay: TRUE
[09:29:16.924] - stdout: TRUE
[09:29:16.924] - signal: TRUE
[09:29:16.924] - resignal: FALSE
[09:29:16.924] - force: TRUE
[09:29:16.924] - relayed: [n=2] TRUE, FALSE
[09:29:16.924] - queued futures: [n=2] TRUE, FALSE
[09:29:16.924]  - until=2
[09:29:16.925]  - relaying element #2
[09:29:16.925] result() for MulticoreFuture ...
[09:29:16.925] result() for MulticoreFuture ... done
[09:29:16.925] result() for MulticoreFuture ...
[09:29:16.925] result() for MulticoreFuture ... done
[09:29:16.925] result() for MulticoreFuture ...
[09:29:16.925] result() for MulticoreFuture ... done
[09:29:16.925] result() for MulticoreFuture ...
[09:29:16.925] result() for MulticoreFuture ... done
[09:29:16.926] - relayed: [n=2] TRUE, TRUE
[09:29:16.926] - queued futures: [n=2] TRUE, TRUE
[09:29:16.926] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:16.926]  length: 0 (resolved future 2)
[09:29:16.926] Relaying remaining futures
[09:29:16.926] signalConditionsASAP(NULL, pos=0) ...
[09:29:16.926] - nx: 2
[09:29:16.926] - relay: TRUE
[09:29:16.926] - stdout: TRUE
[09:29:16.926] - signal: TRUE
[09:29:16.927] - resignal: FALSE
[09:29:16.927] - force: TRUE
[09:29:16.927] - relayed: [n=2] TRUE, TRUE
[09:29:16.927] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:16.927] - relayed: [n=2] TRUE, TRUE
[09:29:16.927] - queued futures: [n=2] TRUE, TRUE
[09:29:16.927] signalConditionsASAP(NULL, pos=0) ... done
[09:29:16.927] resolve() on list ... DONE
[09:29:16.927] result() for MulticoreFuture ...
[09:29:16.928] result() for MulticoreFuture ... done
[09:29:16.928] result() for MulticoreFuture ...
[09:29:16.928] result() for MulticoreFuture ... done
[09:29:16.928] result() for MulticoreFuture ...
[09:29:16.928] result() for MulticoreFuture ... done
[09:29:16.928] result() for MulticoreFuture ...
[09:29:16.928] result() for MulticoreFuture ... done
[09:29:16.928]  - Number of value chunks collected: 2
[09:29:16.928] Resolving 2 futures (chunks) ... DONE
[09:29:16.929] Reducing values from 2 chunks ...
[09:29:16.929]  - Number of values collected after concatenation: 2
[09:29:16.929]  - Number of values expected: 2
[09:29:16.929] Reducing values from 2 chunks ... DONE
[09:29:16.929] future_mapply() ... DONE
[09:29:16.929] future_mapply() ...
[09:29:16.929] Generating random seeds ...
[09:29:16.929] Generating random seed streams for 2 elements ...
[09:29:16.929] Generating random seed streams for 2 elements ... DONE
[09:29:16.930] Generating random seeds ... DONE
[09:29:16.930] Will set RNG state on exit: 10407, -512088055, 1353733528, -44194677, -1097230566, -599802538, -782412261
[09:29:16.934] Number of chunks: 2
[09:29:16.934] getGlobalsAndPackagesXApply() ...
[09:29:16.934]  - future.globals: TRUE
[09:29:16.934] getGlobalsAndPackages() ...
[09:29:16.934] Searching for globals...
[09:29:16.936] - globals found: [1] ‘FUN’
[09:29:16.936] Searching for globals ... DONE
[09:29:16.936] Resolving globals: FALSE
[09:29:16.936] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[09:29:16.937] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[09:29:16.937] - globals: [1] ‘FUN’
[09:29:16.937] 
[09:29:16.937] getGlobalsAndPackages() ... DONE
[09:29:16.937]  - globals found/used: [n=1] ‘FUN’
[09:29:16.937]  - needed namespaces: [n=0] 
[09:29:16.937] Finding globals ... DONE
[09:29:16.937] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:16.937] List of 2
[09:29:16.937]  $ ...future.FUN:function (x, y)  
[09:29:16.937]  $ MoreArgs     :List of 1
[09:29:16.937]   ..$ y: int [1:2] 3 4
[09:29:16.937]  - attr(*, "where")=List of 2
[09:29:16.937]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:16.937]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:16.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.937]  - attr(*, "resolved")= logi FALSE
[09:29:16.937]  - attr(*, "total_size")= num NA
[09:29:16.941] Packages to be attached in all futures: [n=0] 
[09:29:16.941] getGlobalsAndPackagesXApply() ... DONE
[09:29:16.941] Number of futures (= number of chunks): 2
[09:29:16.941] Launching 2 futures (chunks) ...
[09:29:16.941] Chunk #1 of 2 ...
[09:29:16.941]  - Finding globals in '...' for chunk #1 ...
[09:29:16.941] getGlobalsAndPackages() ...
[09:29:16.941] Searching for globals...
[09:29:16.944] 
[09:29:16.944] Searching for globals ... DONE
[09:29:16.944] - globals: [0] <none>
[09:29:16.944] getGlobalsAndPackages() ... DONE
[09:29:16.944]    + additional globals found: [n=0] 
[09:29:16.944]    + additional namespaces needed: [n=0] 
[09:29:16.944]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:16.944]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:16.945]  - seeds: [1] <seeds>
[09:29:16.945]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.945] getGlobalsAndPackages() ...
[09:29:16.945] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.945] Resolving globals: FALSE
[09:29:16.945] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[09:29:16.946] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[09:29:16.946] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.946] 
[09:29:16.946] getGlobalsAndPackages() ... DONE
[09:29:16.947] run() for ‘Future’ ...
[09:29:16.947] - state: ‘created’
[09:29:16.947] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.951] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.951] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.951]   - Field: ‘label’
[09:29:16.951]   - Field: ‘local’
[09:29:16.951]   - Field: ‘owner’
[09:29:16.951]   - Field: ‘envir’
[09:29:16.951]   - Field: ‘workers’
[09:29:16.951]   - Field: ‘packages’
[09:29:16.951]   - Field: ‘gc’
[09:29:16.952]   - Field: ‘job’
[09:29:16.952]   - Field: ‘conditions’
[09:29:16.952]   - Field: ‘expr’
[09:29:16.952]   - Field: ‘uuid’
[09:29:16.952]   - Field: ‘seed’
[09:29:16.952]   - Field: ‘version’
[09:29:16.952]   - Field: ‘result’
[09:29:16.952]   - Field: ‘asynchronous’
[09:29:16.952]   - Field: ‘calls’
[09:29:16.952]   - Field: ‘globals’
[09:29:16.953]   - Field: ‘stdout’
[09:29:16.953]   - Field: ‘earlySignal’
[09:29:16.953]   - Field: ‘lazy’
[09:29:16.953]   - Field: ‘state’
[09:29:16.953] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.953] - Launch lazy future ...
[09:29:16.953] Packages needed by the future expression (n = 0): <none>
[09:29:16.953] Packages needed by future strategies (n = 0): <none>
[09:29:16.954] {
[09:29:16.954]     {
[09:29:16.954]         {
[09:29:16.954]             ...future.startTime <- base::Sys.time()
[09:29:16.954]             {
[09:29:16.954]                 {
[09:29:16.954]                   {
[09:29:16.954]                     {
[09:29:16.954]                       base::local({
[09:29:16.954]                         has_future <- base::requireNamespace("future", 
[09:29:16.954]                           quietly = TRUE)
[09:29:16.954]                         if (has_future) {
[09:29:16.954]                           ns <- base::getNamespace("future")
[09:29:16.954]                           version <- ns[[".package"]][["version"]]
[09:29:16.954]                           if (is.null(version)) 
[09:29:16.954]                             version <- utils::packageVersion("future")
[09:29:16.954]                         }
[09:29:16.954]                         else {
[09:29:16.954]                           version <- NULL
[09:29:16.954]                         }
[09:29:16.954]                         if (!has_future || version < "1.8.0") {
[09:29:16.954]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.954]                             "", base::R.version$version.string), 
[09:29:16.954]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.954]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.954]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.954]                               "release", "version")], collapse = " "), 
[09:29:16.954]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.954]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.954]                             info)
[09:29:16.954]                           info <- base::paste(info, collapse = "; ")
[09:29:16.954]                           if (!has_future) {
[09:29:16.954]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.954]                               info)
[09:29:16.954]                           }
[09:29:16.954]                           else {
[09:29:16.954]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.954]                               info, version)
[09:29:16.954]                           }
[09:29:16.954]                           base::stop(msg)
[09:29:16.954]                         }
[09:29:16.954]                       })
[09:29:16.954]                     }
[09:29:16.954]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.954]                     base::options(mc.cores = 1L)
[09:29:16.954]                   }
[09:29:16.954]                   ...future.strategy.old <- future::plan("list")
[09:29:16.954]                   options(future.plan = NULL)
[09:29:16.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.954]                 }
[09:29:16.954]                 ...future.workdir <- getwd()
[09:29:16.954]             }
[09:29:16.954]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.954]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.954]         }
[09:29:16.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.954]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:16.954]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.954]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.954]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.954]             base::names(...future.oldOptions))
[09:29:16.954]     }
[09:29:16.954]     if (FALSE) {
[09:29:16.954]     }
[09:29:16.954]     else {
[09:29:16.954]         if (TRUE) {
[09:29:16.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.954]                 open = "w")
[09:29:16.954]         }
[09:29:16.954]         else {
[09:29:16.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.954]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.954]         }
[09:29:16.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.954]             base::sink(type = "output", split = FALSE)
[09:29:16.954]             base::close(...future.stdout)
[09:29:16.954]         }, add = TRUE)
[09:29:16.954]     }
[09:29:16.954]     ...future.frame <- base::sys.nframe()
[09:29:16.954]     ...future.conditions <- base::list()
[09:29:16.954]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.954]     if (FALSE) {
[09:29:16.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.954]     }
[09:29:16.954]     ...future.result <- base::tryCatch({
[09:29:16.954]         base::withCallingHandlers({
[09:29:16.954]             ...future.value <- base::withVisible(base::local({
[09:29:16.954]                 withCallingHandlers({
[09:29:16.954]                   {
[09:29:16.954]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.954]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.954]                       ...future.globals.maxSize)) {
[09:29:16.954]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.954]                       on.exit(options(oopts), add = TRUE)
[09:29:16.954]                     }
[09:29:16.954]                     {
[09:29:16.954]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:16.954]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[09:29:16.954]                           envir = globalenv(), inherits = FALSE)
[09:29:16.954]                         ...future.FUN(...)
[09:29:16.954]                       }
[09:29:16.954]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:16.954]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:16.954]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.954]                         USE.NAMES = FALSE)
[09:29:16.954]                       do.call(mapply, args = args)
[09:29:16.954]                     }
[09:29:16.954]                   }
[09:29:16.954]                 }, immediateCondition = function(cond) {
[09:29:16.954]                   save_rds <- function (object, pathname, ...) 
[09:29:16.954]                   {
[09:29:16.954]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.954]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.954]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.954]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.954]                         fi_tmp[["mtime"]])
[09:29:16.954]                     }
[09:29:16.954]                     tryCatch({
[09:29:16.954]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.954]                     }, error = function(ex) {
[09:29:16.954]                       msg <- conditionMessage(ex)
[09:29:16.954]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.954]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.954]                         fi_tmp[["mtime"]], msg)
[09:29:16.954]                       ex$message <- msg
[09:29:16.954]                       stop(ex)
[09:29:16.954]                     })
[09:29:16.954]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.954]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.954]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.954]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.954]                       fi <- file.info(pathname)
[09:29:16.954]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.954]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.954]                         fi[["size"]], fi[["mtime"]])
[09:29:16.954]                       stop(msg)
[09:29:16.954]                     }
[09:29:16.954]                     invisible(pathname)
[09:29:16.954]                   }
[09:29:16.954]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.954]                     rootPath = tempdir()) 
[09:29:16.954]                   {
[09:29:16.954]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.954]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.954]                       tmpdir = path, fileext = ".rds")
[09:29:16.954]                     save_rds(obj, file)
[09:29:16.954]                   }
[09:29:16.954]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.954]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.954]                   {
[09:29:16.954]                     inherits <- base::inherits
[09:29:16.954]                     invokeRestart <- base::invokeRestart
[09:29:16.954]                     is.null <- base::is.null
[09:29:16.954]                     muffled <- FALSE
[09:29:16.954]                     if (inherits(cond, "message")) {
[09:29:16.954]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.954]                       if (muffled) 
[09:29:16.954]                         invokeRestart("muffleMessage")
[09:29:16.954]                     }
[09:29:16.954]                     else if (inherits(cond, "warning")) {
[09:29:16.954]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.954]                       if (muffled) 
[09:29:16.954]                         invokeRestart("muffleWarning")
[09:29:16.954]                     }
[09:29:16.954]                     else if (inherits(cond, "condition")) {
[09:29:16.954]                       if (!is.null(pattern)) {
[09:29:16.954]                         computeRestarts <- base::computeRestarts
[09:29:16.954]                         grepl <- base::grepl
[09:29:16.954]                         restarts <- computeRestarts(cond)
[09:29:16.954]                         for (restart in restarts) {
[09:29:16.954]                           name <- restart$name
[09:29:16.954]                           if (is.null(name)) 
[09:29:16.954]                             next
[09:29:16.954]                           if (!grepl(pattern, name)) 
[09:29:16.954]                             next
[09:29:16.954]                           invokeRestart(restart)
[09:29:16.954]                           muffled <- TRUE
[09:29:16.954]                           break
[09:29:16.954]                         }
[09:29:16.954]                       }
[09:29:16.954]                     }
[09:29:16.954]                     invisible(muffled)
[09:29:16.954]                   }
[09:29:16.954]                   muffleCondition(cond)
[09:29:16.954]                 })
[09:29:16.954]             }))
[09:29:16.954]             future::FutureResult(value = ...future.value$value, 
[09:29:16.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.954]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.954]                     ...future.globalenv.names))
[09:29:16.954]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.954]         }, condition = base::local({
[09:29:16.954]             c <- base::c
[09:29:16.954]             inherits <- base::inherits
[09:29:16.954]             invokeRestart <- base::invokeRestart
[09:29:16.954]             length <- base::length
[09:29:16.954]             list <- base::list
[09:29:16.954]             seq.int <- base::seq.int
[09:29:16.954]             signalCondition <- base::signalCondition
[09:29:16.954]             sys.calls <- base::sys.calls
[09:29:16.954]             `[[` <- base::`[[`
[09:29:16.954]             `+` <- base::`+`
[09:29:16.954]             `<<-` <- base::`<<-`
[09:29:16.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.954]                   3L)]
[09:29:16.954]             }
[09:29:16.954]             function(cond) {
[09:29:16.954]                 is_error <- inherits(cond, "error")
[09:29:16.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.954]                   NULL)
[09:29:16.954]                 if (is_error) {
[09:29:16.954]                   sessionInformation <- function() {
[09:29:16.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.954]                       search = base::search(), system = base::Sys.info())
[09:29:16.954]                   }
[09:29:16.954]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.954]                     cond$call), session = sessionInformation(), 
[09:29:16.954]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.954]                   signalCondition(cond)
[09:29:16.954]                 }
[09:29:16.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.954]                 "immediateCondition"))) {
[09:29:16.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.954]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.954]                   if (TRUE && !signal) {
[09:29:16.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.954]                     {
[09:29:16.954]                       inherits <- base::inherits
[09:29:16.954]                       invokeRestart <- base::invokeRestart
[09:29:16.954]                       is.null <- base::is.null
[09:29:16.954]                       muffled <- FALSE
[09:29:16.954]                       if (inherits(cond, "message")) {
[09:29:16.954]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.954]                         if (muffled) 
[09:29:16.954]                           invokeRestart("muffleMessage")
[09:29:16.954]                       }
[09:29:16.954]                       else if (inherits(cond, "warning")) {
[09:29:16.954]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.954]                         if (muffled) 
[09:29:16.954]                           invokeRestart("muffleWarning")
[09:29:16.954]                       }
[09:29:16.954]                       else if (inherits(cond, "condition")) {
[09:29:16.954]                         if (!is.null(pattern)) {
[09:29:16.954]                           computeRestarts <- base::computeRestarts
[09:29:16.954]                           grepl <- base::grepl
[09:29:16.954]                           restarts <- computeRestarts(cond)
[09:29:16.954]                           for (restart in restarts) {
[09:29:16.954]                             name <- restart$name
[09:29:16.954]                             if (is.null(name)) 
[09:29:16.954]                               next
[09:29:16.954]                             if (!grepl(pattern, name)) 
[09:29:16.954]                               next
[09:29:16.954]                             invokeRestart(restart)
[09:29:16.954]                             muffled <- TRUE
[09:29:16.954]                             break
[09:29:16.954]                           }
[09:29:16.954]                         }
[09:29:16.954]                       }
[09:29:16.954]                       invisible(muffled)
[09:29:16.954]                     }
[09:29:16.954]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.954]                   }
[09:29:16.954]                 }
[09:29:16.954]                 else {
[09:29:16.954]                   if (TRUE) {
[09:29:16.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.954]                     {
[09:29:16.954]                       inherits <- base::inherits
[09:29:16.954]                       invokeRestart <- base::invokeRestart
[09:29:16.954]                       is.null <- base::is.null
[09:29:16.954]                       muffled <- FALSE
[09:29:16.954]                       if (inherits(cond, "message")) {
[09:29:16.954]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.954]                         if (muffled) 
[09:29:16.954]                           invokeRestart("muffleMessage")
[09:29:16.954]                       }
[09:29:16.954]                       else if (inherits(cond, "warning")) {
[09:29:16.954]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.954]                         if (muffled) 
[09:29:16.954]                           invokeRestart("muffleWarning")
[09:29:16.954]                       }
[09:29:16.954]                       else if (inherits(cond, "condition")) {
[09:29:16.954]                         if (!is.null(pattern)) {
[09:29:16.954]                           computeRestarts <- base::computeRestarts
[09:29:16.954]                           grepl <- base::grepl
[09:29:16.954]                           restarts <- computeRestarts(cond)
[09:29:16.954]                           for (restart in restarts) {
[09:29:16.954]                             name <- restart$name
[09:29:16.954]                             if (is.null(name)) 
[09:29:16.954]                               next
[09:29:16.954]                             if (!grepl(pattern, name)) 
[09:29:16.954]                               next
[09:29:16.954]                             invokeRestart(restart)
[09:29:16.954]                             muffled <- TRUE
[09:29:16.954]                             break
[09:29:16.954]                           }
[09:29:16.954]                         }
[09:29:16.954]                       }
[09:29:16.954]                       invisible(muffled)
[09:29:16.954]                     }
[09:29:16.954]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.954]                   }
[09:29:16.954]                 }
[09:29:16.954]             }
[09:29:16.954]         }))
[09:29:16.954]     }, error = function(ex) {
[09:29:16.954]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.954]                 ...future.rng), started = ...future.startTime, 
[09:29:16.954]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.954]             version = "1.8"), class = "FutureResult")
[09:29:16.954]     }, finally = {
[09:29:16.954]         if (!identical(...future.workdir, getwd())) 
[09:29:16.954]             setwd(...future.workdir)
[09:29:16.954]         {
[09:29:16.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.954]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.954]             }
[09:29:16.954]             base::options(...future.oldOptions)
[09:29:16.954]             if (.Platform$OS.type == "windows") {
[09:29:16.954]                 old_names <- names(...future.oldEnvVars)
[09:29:16.954]                 envs <- base::Sys.getenv()
[09:29:16.954]                 names <- names(envs)
[09:29:16.954]                 common <- intersect(names, old_names)
[09:29:16.954]                 added <- setdiff(names, old_names)
[09:29:16.954]                 removed <- setdiff(old_names, names)
[09:29:16.954]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.954]                   envs[common]]
[09:29:16.954]                 NAMES <- toupper(changed)
[09:29:16.954]                 args <- list()
[09:29:16.954]                 for (kk in seq_along(NAMES)) {
[09:29:16.954]                   name <- changed[[kk]]
[09:29:16.954]                   NAME <- NAMES[[kk]]
[09:29:16.954]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.954]                     next
[09:29:16.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.954]                 }
[09:29:16.954]                 NAMES <- toupper(added)
[09:29:16.954]                 for (kk in seq_along(NAMES)) {
[09:29:16.954]                   name <- added[[kk]]
[09:29:16.954]                   NAME <- NAMES[[kk]]
[09:29:16.954]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.954]                     next
[09:29:16.954]                   args[[name]] <- ""
[09:29:16.954]                 }
[09:29:16.954]                 NAMES <- toupper(removed)
[09:29:16.954]                 for (kk in seq_along(NAMES)) {
[09:29:16.954]                   name <- removed[[kk]]
[09:29:16.954]                   NAME <- NAMES[[kk]]
[09:29:16.954]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.954]                     next
[09:29:16.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.954]                 }
[09:29:16.954]                 if (length(args) > 0) 
[09:29:16.954]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.954]             }
[09:29:16.954]             else {
[09:29:16.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.954]             }
[09:29:16.954]             {
[09:29:16.954]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.954]                   0L) {
[09:29:16.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.954]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.954]                   base::options(opts)
[09:29:16.954]                 }
[09:29:16.954]                 {
[09:29:16.954]                   {
[09:29:16.954]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.954]                     NULL
[09:29:16.954]                   }
[09:29:16.954]                   options(future.plan = NULL)
[09:29:16.954]                   if (is.na(NA_character_)) 
[09:29:16.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.954]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.954]                     .init = FALSE)
[09:29:16.954]                 }
[09:29:16.954]             }
[09:29:16.954]         }
[09:29:16.954]     })
[09:29:16.954]     if (TRUE) {
[09:29:16.954]         base::sink(type = "output", split = FALSE)
[09:29:16.954]         if (TRUE) {
[09:29:16.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.954]         }
[09:29:16.954]         else {
[09:29:16.954]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.954]         }
[09:29:16.954]         base::close(...future.stdout)
[09:29:16.954]         ...future.stdout <- NULL
[09:29:16.954]     }
[09:29:16.954]     ...future.result$conditions <- ...future.conditions
[09:29:16.954]     ...future.result$finished <- base::Sys.time()
[09:29:16.954]     ...future.result
[09:29:16.954] }
[09:29:16.956] assign_globals() ...
[09:29:16.956] List of 5
[09:29:16.956]  $ ...future.FUN            :function (x, y)  
[09:29:16.956]  $ MoreArgs                 :List of 1
[09:29:16.956]   ..$ y: int [1:2] 3 4
[09:29:16.956]  $ ...future.elements_ii    :List of 1
[09:29:16.956]   ..$ x:List of 1
[09:29:16.956]   .. ..$ : int 1
[09:29:16.956]  $ ...future.seeds_ii       :List of 1
[09:29:16.956]   ..$ : int [1:7] 10407 -720363168 1515607135 -1635214233 -621667951 -142062423 1785651596
[09:29:16.956]  $ ...future.globals.maxSize: NULL
[09:29:16.956]  - attr(*, "where")=List of 5
[09:29:16.956]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:16.956]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:16.956]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:16.956]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:16.956]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:16.956]  - attr(*, "resolved")= logi FALSE
[09:29:16.956]  - attr(*, "total_size")= num 1896
[09:29:16.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:16.956]  - attr(*, "already-done")= logi TRUE
[09:29:16.961] - reassign environment for ‘...future.FUN’
[09:29:16.961] - copied ‘...future.FUN’ to environment
[09:29:16.962] - copied ‘MoreArgs’ to environment
[09:29:16.962] - copied ‘...future.elements_ii’ to environment
[09:29:16.962] - copied ‘...future.seeds_ii’ to environment
[09:29:16.962] - copied ‘...future.globals.maxSize’ to environment
[09:29:16.962] assign_globals() ... done
[09:29:16.962] requestCore(): workers = 2
[09:29:16.964] MulticoreFuture started
[09:29:16.964] - Launch lazy future ... done
[09:29:16.965] run() for ‘MulticoreFuture’ ... done
[09:29:16.965] Created future:
[09:29:16.965] plan(): Setting new future strategy stack:
[09:29:16.965] List of future strategies:
[09:29:16.965] 1. sequential:
[09:29:16.965]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:16.965]    - tweaked: FALSE
[09:29:16.965]    - call: NULL
[09:29:16.966] plan(): nbrOfWorkers() = 1
[09:29:16.969] plan(): Setting new future strategy stack:
[09:29:16.969] List of future strategies:
[09:29:16.969] 1. multicore:
[09:29:16.969]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:16.969]    - tweaked: FALSE
[09:29:16.969]    - call: plan(strategy)
[09:29:16.974] plan(): nbrOfWorkers() = 2
[09:29:16.965] MulticoreFuture:
[09:29:16.965] Label: ‘future_mapply-1’
[09:29:16.965] Expression:
[09:29:16.965] {
[09:29:16.965]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.965]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:16.965]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.965]         on.exit(options(oopts), add = TRUE)
[09:29:16.965]     }
[09:29:16.965]     {
[09:29:16.965]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:16.965]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[09:29:16.965]                 inherits = FALSE)
[09:29:16.965]             ...future.FUN(...)
[09:29:16.965]         }
[09:29:16.965]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:16.965]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:16.965]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:16.965]         do.call(mapply, args = args)
[09:29:16.965]     }
[09:29:16.965] }
[09:29:16.965] Lazy evaluation: FALSE
[09:29:16.965] Asynchronous evaluation: TRUE
[09:29:16.965] Local evaluation: TRUE
[09:29:16.965] Environment: R_GlobalEnv
[09:29:16.965] Capture standard output: TRUE
[09:29:16.965] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:16.965] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:16.965] Packages: <none>
[09:29:16.965] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:29:16.965] Resolved: TRUE
[09:29:16.965] Value: <not collected>
[09:29:16.965] Conditions captured: <none>
[09:29:16.965] Early signaling: FALSE
[09:29:16.965] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:16.965] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.975] Chunk #1 of 2 ... DONE
[09:29:16.975] Chunk #2 of 2 ...
[09:29:16.975]  - Finding globals in '...' for chunk #2 ...
[09:29:16.975] getGlobalsAndPackages() ...
[09:29:16.976] Searching for globals...
[09:29:16.976] 
[09:29:16.976] Searching for globals ... DONE
[09:29:16.976] - globals: [0] <none>
[09:29:16.976] getGlobalsAndPackages() ... DONE
[09:29:16.977]    + additional globals found: [n=0] 
[09:29:16.977]    + additional namespaces needed: [n=0] 
[09:29:16.977]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:16.977]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:16.977]  - seeds: [1] <seeds>
[09:29:16.977]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.977] getGlobalsAndPackages() ...
[09:29:16.978] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.978] Resolving globals: FALSE
[09:29:16.979] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[09:29:16.979] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[09:29:16.980] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:16.980] 
[09:29:16.980] getGlobalsAndPackages() ... DONE
[09:29:16.981] run() for ‘Future’ ...
[09:29:16.981] - state: ‘created’
[09:29:16.981] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:16.990] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:16.990] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:16.991]   - Field: ‘label’
[09:29:16.991]   - Field: ‘local’
[09:29:16.991]   - Field: ‘owner’
[09:29:16.991]   - Field: ‘envir’
[09:29:16.991]   - Field: ‘workers’
[09:29:16.992]   - Field: ‘packages’
[09:29:16.992]   - Field: ‘gc’
[09:29:16.992]   - Field: ‘job’
[09:29:16.992]   - Field: ‘conditions’
[09:29:16.993]   - Field: ‘expr’
[09:29:16.993]   - Field: ‘uuid’
[09:29:16.993]   - Field: ‘seed’
[09:29:16.993]   - Field: ‘version’
[09:29:16.993]   - Field: ‘result’
[09:29:16.994]   - Field: ‘asynchronous’
[09:29:16.994]   - Field: ‘calls’
[09:29:16.994]   - Field: ‘globals’
[09:29:16.994]   - Field: ‘stdout’
[09:29:16.994]   - Field: ‘earlySignal’
[09:29:16.995]   - Field: ‘lazy’
[09:29:16.995]   - Field: ‘state’
[09:29:16.995] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:16.995] - Launch lazy future ...
[09:29:16.996] Packages needed by the future expression (n = 0): <none>
[09:29:16.996] Packages needed by future strategies (n = 0): <none>
[09:29:16.997] {
[09:29:16.997]     {
[09:29:16.997]         {
[09:29:16.997]             ...future.startTime <- base::Sys.time()
[09:29:16.997]             {
[09:29:16.997]                 {
[09:29:16.997]                   {
[09:29:16.997]                     {
[09:29:16.997]                       base::local({
[09:29:16.997]                         has_future <- base::requireNamespace("future", 
[09:29:16.997]                           quietly = TRUE)
[09:29:16.997]                         if (has_future) {
[09:29:16.997]                           ns <- base::getNamespace("future")
[09:29:16.997]                           version <- ns[[".package"]][["version"]]
[09:29:16.997]                           if (is.null(version)) 
[09:29:16.997]                             version <- utils::packageVersion("future")
[09:29:16.997]                         }
[09:29:16.997]                         else {
[09:29:16.997]                           version <- NULL
[09:29:16.997]                         }
[09:29:16.997]                         if (!has_future || version < "1.8.0") {
[09:29:16.997]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:16.997]                             "", base::R.version$version.string), 
[09:29:16.997]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:16.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:16.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:16.997]                               "release", "version")], collapse = " "), 
[09:29:16.997]                             hostname = base::Sys.info()[["nodename"]])
[09:29:16.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:16.997]                             info)
[09:29:16.997]                           info <- base::paste(info, collapse = "; ")
[09:29:16.997]                           if (!has_future) {
[09:29:16.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:16.997]                               info)
[09:29:16.997]                           }
[09:29:16.997]                           else {
[09:29:16.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:16.997]                               info, version)
[09:29:16.997]                           }
[09:29:16.997]                           base::stop(msg)
[09:29:16.997]                         }
[09:29:16.997]                       })
[09:29:16.997]                     }
[09:29:16.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:16.997]                     base::options(mc.cores = 1L)
[09:29:16.997]                   }
[09:29:16.997]                   ...future.strategy.old <- future::plan("list")
[09:29:16.997]                   options(future.plan = NULL)
[09:29:16.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:16.997]                 }
[09:29:16.997]                 ...future.workdir <- getwd()
[09:29:16.997]             }
[09:29:16.997]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:16.997]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:16.997]         }
[09:29:16.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:16.997]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:16.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:16.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:16.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:16.997]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:16.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:16.997]             base::names(...future.oldOptions))
[09:29:16.997]     }
[09:29:16.997]     if (FALSE) {
[09:29:16.997]     }
[09:29:16.997]     else {
[09:29:16.997]         if (TRUE) {
[09:29:16.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:16.997]                 open = "w")
[09:29:16.997]         }
[09:29:16.997]         else {
[09:29:16.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:16.997]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:16.997]         }
[09:29:16.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:16.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:16.997]             base::sink(type = "output", split = FALSE)
[09:29:16.997]             base::close(...future.stdout)
[09:29:16.997]         }, add = TRUE)
[09:29:16.997]     }
[09:29:16.997]     ...future.frame <- base::sys.nframe()
[09:29:16.997]     ...future.conditions <- base::list()
[09:29:16.997]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:16.997]     if (FALSE) {
[09:29:16.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:16.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:16.997]     }
[09:29:16.997]     ...future.result <- base::tryCatch({
[09:29:16.997]         base::withCallingHandlers({
[09:29:16.997]             ...future.value <- base::withVisible(base::local({
[09:29:16.997]                 withCallingHandlers({
[09:29:16.997]                   {
[09:29:16.997]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:16.997]                     if (!identical(...future.globals.maxSize.org, 
[09:29:16.997]                       ...future.globals.maxSize)) {
[09:29:16.997]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:16.997]                       on.exit(options(oopts), add = TRUE)
[09:29:16.997]                     }
[09:29:16.997]                     {
[09:29:16.997]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:16.997]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[09:29:16.997]                           envir = globalenv(), inherits = FALSE)
[09:29:16.997]                         ...future.FUN(...)
[09:29:16.997]                       }
[09:29:16.997]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:16.997]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:16.997]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:16.997]                         USE.NAMES = FALSE)
[09:29:16.997]                       do.call(mapply, args = args)
[09:29:16.997]                     }
[09:29:16.997]                   }
[09:29:16.997]                 }, immediateCondition = function(cond) {
[09:29:16.997]                   save_rds <- function (object, pathname, ...) 
[09:29:16.997]                   {
[09:29:16.997]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:16.997]                     if (file_test("-f", pathname_tmp)) {
[09:29:16.997]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.997]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:16.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.997]                         fi_tmp[["mtime"]])
[09:29:16.997]                     }
[09:29:16.997]                     tryCatch({
[09:29:16.997]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:16.997]                     }, error = function(ex) {
[09:29:16.997]                       msg <- conditionMessage(ex)
[09:29:16.997]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.997]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:16.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.997]                         fi_tmp[["mtime"]], msg)
[09:29:16.997]                       ex$message <- msg
[09:29:16.997]                       stop(ex)
[09:29:16.997]                     })
[09:29:16.997]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:16.997]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:16.997]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:16.997]                       fi_tmp <- file.info(pathname_tmp)
[09:29:16.997]                       fi <- file.info(pathname)
[09:29:16.997]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:16.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:16.997]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:16.997]                         fi[["size"]], fi[["mtime"]])
[09:29:16.997]                       stop(msg)
[09:29:16.997]                     }
[09:29:16.997]                     invisible(pathname)
[09:29:16.997]                   }
[09:29:16.997]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:16.997]                     rootPath = tempdir()) 
[09:29:16.997]                   {
[09:29:16.997]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:16.997]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:16.997]                       tmpdir = path, fileext = ".rds")
[09:29:16.997]                     save_rds(obj, file)
[09:29:16.997]                   }
[09:29:16.997]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:16.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.997]                   {
[09:29:16.997]                     inherits <- base::inherits
[09:29:16.997]                     invokeRestart <- base::invokeRestart
[09:29:16.997]                     is.null <- base::is.null
[09:29:16.997]                     muffled <- FALSE
[09:29:16.997]                     if (inherits(cond, "message")) {
[09:29:16.997]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:16.997]                       if (muffled) 
[09:29:16.997]                         invokeRestart("muffleMessage")
[09:29:16.997]                     }
[09:29:16.997]                     else if (inherits(cond, "warning")) {
[09:29:16.997]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:16.997]                       if (muffled) 
[09:29:16.997]                         invokeRestart("muffleWarning")
[09:29:16.997]                     }
[09:29:16.997]                     else if (inherits(cond, "condition")) {
[09:29:16.997]                       if (!is.null(pattern)) {
[09:29:16.997]                         computeRestarts <- base::computeRestarts
[09:29:16.997]                         grepl <- base::grepl
[09:29:16.997]                         restarts <- computeRestarts(cond)
[09:29:16.997]                         for (restart in restarts) {
[09:29:16.997]                           name <- restart$name
[09:29:16.997]                           if (is.null(name)) 
[09:29:16.997]                             next
[09:29:16.997]                           if (!grepl(pattern, name)) 
[09:29:16.997]                             next
[09:29:16.997]                           invokeRestart(restart)
[09:29:16.997]                           muffled <- TRUE
[09:29:16.997]                           break
[09:29:16.997]                         }
[09:29:16.997]                       }
[09:29:16.997]                     }
[09:29:16.997]                     invisible(muffled)
[09:29:16.997]                   }
[09:29:16.997]                   muffleCondition(cond)
[09:29:16.997]                 })
[09:29:16.997]             }))
[09:29:16.997]             future::FutureResult(value = ...future.value$value, 
[09:29:16.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.997]                   ...future.rng), globalenv = if (FALSE) 
[09:29:16.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:16.997]                     ...future.globalenv.names))
[09:29:16.997]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:16.997]         }, condition = base::local({
[09:29:16.997]             c <- base::c
[09:29:16.997]             inherits <- base::inherits
[09:29:16.997]             invokeRestart <- base::invokeRestart
[09:29:16.997]             length <- base::length
[09:29:16.997]             list <- base::list
[09:29:16.997]             seq.int <- base::seq.int
[09:29:16.997]             signalCondition <- base::signalCondition
[09:29:16.997]             sys.calls <- base::sys.calls
[09:29:16.997]             `[[` <- base::`[[`
[09:29:16.997]             `+` <- base::`+`
[09:29:16.997]             `<<-` <- base::`<<-`
[09:29:16.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:16.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:16.997]                   3L)]
[09:29:16.997]             }
[09:29:16.997]             function(cond) {
[09:29:16.997]                 is_error <- inherits(cond, "error")
[09:29:16.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:16.997]                   NULL)
[09:29:16.997]                 if (is_error) {
[09:29:16.997]                   sessionInformation <- function() {
[09:29:16.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:16.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:16.997]                       search = base::search(), system = base::Sys.info())
[09:29:16.997]                   }
[09:29:16.997]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:16.997]                     cond$call), session = sessionInformation(), 
[09:29:16.997]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:16.997]                   signalCondition(cond)
[09:29:16.997]                 }
[09:29:16.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:16.997]                 "immediateCondition"))) {
[09:29:16.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:16.997]                   ...future.conditions[[length(...future.conditions) + 
[09:29:16.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:16.997]                   if (TRUE && !signal) {
[09:29:16.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.997]                     {
[09:29:16.997]                       inherits <- base::inherits
[09:29:16.997]                       invokeRestart <- base::invokeRestart
[09:29:16.997]                       is.null <- base::is.null
[09:29:16.997]                       muffled <- FALSE
[09:29:16.997]                       if (inherits(cond, "message")) {
[09:29:16.997]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.997]                         if (muffled) 
[09:29:16.997]                           invokeRestart("muffleMessage")
[09:29:16.997]                       }
[09:29:16.997]                       else if (inherits(cond, "warning")) {
[09:29:16.997]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.997]                         if (muffled) 
[09:29:16.997]                           invokeRestart("muffleWarning")
[09:29:16.997]                       }
[09:29:16.997]                       else if (inherits(cond, "condition")) {
[09:29:16.997]                         if (!is.null(pattern)) {
[09:29:16.997]                           computeRestarts <- base::computeRestarts
[09:29:16.997]                           grepl <- base::grepl
[09:29:16.997]                           restarts <- computeRestarts(cond)
[09:29:16.997]                           for (restart in restarts) {
[09:29:16.997]                             name <- restart$name
[09:29:16.997]                             if (is.null(name)) 
[09:29:16.997]                               next
[09:29:16.997]                             if (!grepl(pattern, name)) 
[09:29:16.997]                               next
[09:29:16.997]                             invokeRestart(restart)
[09:29:16.997]                             muffled <- TRUE
[09:29:16.997]                             break
[09:29:16.997]                           }
[09:29:16.997]                         }
[09:29:16.997]                       }
[09:29:16.997]                       invisible(muffled)
[09:29:16.997]                     }
[09:29:16.997]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.997]                   }
[09:29:16.997]                 }
[09:29:16.997]                 else {
[09:29:16.997]                   if (TRUE) {
[09:29:16.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:16.997]                     {
[09:29:16.997]                       inherits <- base::inherits
[09:29:16.997]                       invokeRestart <- base::invokeRestart
[09:29:16.997]                       is.null <- base::is.null
[09:29:16.997]                       muffled <- FALSE
[09:29:16.997]                       if (inherits(cond, "message")) {
[09:29:16.997]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:16.997]                         if (muffled) 
[09:29:16.997]                           invokeRestart("muffleMessage")
[09:29:16.997]                       }
[09:29:16.997]                       else if (inherits(cond, "warning")) {
[09:29:16.997]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:16.997]                         if (muffled) 
[09:29:16.997]                           invokeRestart("muffleWarning")
[09:29:16.997]                       }
[09:29:16.997]                       else if (inherits(cond, "condition")) {
[09:29:16.997]                         if (!is.null(pattern)) {
[09:29:16.997]                           computeRestarts <- base::computeRestarts
[09:29:16.997]                           grepl <- base::grepl
[09:29:16.997]                           restarts <- computeRestarts(cond)
[09:29:16.997]                           for (restart in restarts) {
[09:29:16.997]                             name <- restart$name
[09:29:16.997]                             if (is.null(name)) 
[09:29:16.997]                               next
[09:29:16.997]                             if (!grepl(pattern, name)) 
[09:29:16.997]                               next
[09:29:16.997]                             invokeRestart(restart)
[09:29:16.997]                             muffled <- TRUE
[09:29:16.997]                             break
[09:29:16.997]                           }
[09:29:16.997]                         }
[09:29:16.997]                       }
[09:29:16.997]                       invisible(muffled)
[09:29:16.997]                     }
[09:29:16.997]                     muffleCondition(cond, pattern = "^muffle")
[09:29:16.997]                   }
[09:29:16.997]                 }
[09:29:16.997]             }
[09:29:16.997]         }))
[09:29:16.997]     }, error = function(ex) {
[09:29:16.997]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:16.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:16.997]                 ...future.rng), started = ...future.startTime, 
[09:29:16.997]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:16.997]             version = "1.8"), class = "FutureResult")
[09:29:16.997]     }, finally = {
[09:29:16.997]         if (!identical(...future.workdir, getwd())) 
[09:29:16.997]             setwd(...future.workdir)
[09:29:16.997]         {
[09:29:16.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:16.997]                 ...future.oldOptions$nwarnings <- NULL
[09:29:16.997]             }
[09:29:16.997]             base::options(...future.oldOptions)
[09:29:16.997]             if (.Platform$OS.type == "windows") {
[09:29:16.997]                 old_names <- names(...future.oldEnvVars)
[09:29:16.997]                 envs <- base::Sys.getenv()
[09:29:16.997]                 names <- names(envs)
[09:29:16.997]                 common <- intersect(names, old_names)
[09:29:16.997]                 added <- setdiff(names, old_names)
[09:29:16.997]                 removed <- setdiff(old_names, names)
[09:29:16.997]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:16.997]                   envs[common]]
[09:29:16.997]                 NAMES <- toupper(changed)
[09:29:16.997]                 args <- list()
[09:29:16.997]                 for (kk in seq_along(NAMES)) {
[09:29:16.997]                   name <- changed[[kk]]
[09:29:16.997]                   NAME <- NAMES[[kk]]
[09:29:16.997]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.997]                     next
[09:29:16.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.997]                 }
[09:29:16.997]                 NAMES <- toupper(added)
[09:29:16.997]                 for (kk in seq_along(NAMES)) {
[09:29:16.997]                   name <- added[[kk]]
[09:29:16.997]                   NAME <- NAMES[[kk]]
[09:29:16.997]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.997]                     next
[09:29:16.997]                   args[[name]] <- ""
[09:29:16.997]                 }
[09:29:16.997]                 NAMES <- toupper(removed)
[09:29:16.997]                 for (kk in seq_along(NAMES)) {
[09:29:16.997]                   name <- removed[[kk]]
[09:29:16.997]                   NAME <- NAMES[[kk]]
[09:29:16.997]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:16.997]                     next
[09:29:16.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:16.997]                 }
[09:29:16.997]                 if (length(args) > 0) 
[09:29:16.997]                   base::do.call(base::Sys.setenv, args = args)
[09:29:16.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:16.997]             }
[09:29:16.997]             else {
[09:29:16.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:16.997]             }
[09:29:16.997]             {
[09:29:16.997]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:16.997]                   0L) {
[09:29:16.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:16.997]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:16.997]                   base::options(opts)
[09:29:16.997]                 }
[09:29:16.997]                 {
[09:29:16.997]                   {
[09:29:16.997]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:16.997]                     NULL
[09:29:16.997]                   }
[09:29:16.997]                   options(future.plan = NULL)
[09:29:16.997]                   if (is.na(NA_character_)) 
[09:29:16.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:16.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:16.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:16.997]                     .init = FALSE)
[09:29:16.997]                 }
[09:29:16.997]             }
[09:29:16.997]         }
[09:29:16.997]     })
[09:29:16.997]     if (TRUE) {
[09:29:16.997]         base::sink(type = "output", split = FALSE)
[09:29:16.997]         if (TRUE) {
[09:29:16.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:16.997]         }
[09:29:16.997]         else {
[09:29:16.997]             ...future.result["stdout"] <- base::list(NULL)
[09:29:16.997]         }
[09:29:16.997]         base::close(...future.stdout)
[09:29:16.997]         ...future.stdout <- NULL
[09:29:16.997]     }
[09:29:16.997]     ...future.result$conditions <- ...future.conditions
[09:29:16.997]     ...future.result$finished <- base::Sys.time()
[09:29:16.997]     ...future.result
[09:29:16.997] }
[09:29:17.000] assign_globals() ...
[09:29:17.000] List of 5
[09:29:17.000]  $ ...future.FUN            :function (x, y)  
[09:29:17.000]  $ MoreArgs                 :List of 1
[09:29:17.000]   ..$ y: int [1:2] 3 4
[09:29:17.000]  $ ...future.elements_ii    :List of 1
[09:29:17.000]   ..$ x:List of 1
[09:29:17.000]   .. ..$ : int 2
[09:29:17.000]  $ ...future.seeds_ii       :List of 1
[09:29:17.000]   ..$ : int [1:7] 10407 -350981368 -927654261 -40641433 -893838610 77850247 -474192421
[09:29:17.000]  $ ...future.globals.maxSize: NULL
[09:29:17.000]  - attr(*, "where")=List of 5
[09:29:17.000]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:17.000]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:17.000]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:17.000]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:17.000]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:17.000]  - attr(*, "resolved")= logi FALSE
[09:29:17.000]  - attr(*, "total_size")= num 1896
[09:29:17.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.000]  - attr(*, "already-done")= logi TRUE
[09:29:17.008] - reassign environment for ‘...future.FUN’
[09:29:17.008] - copied ‘...future.FUN’ to environment
[09:29:17.008] - copied ‘MoreArgs’ to environment
[09:29:17.008] - copied ‘...future.elements_ii’ to environment
[09:29:17.009] - copied ‘...future.seeds_ii’ to environment
[09:29:17.009] - copied ‘...future.globals.maxSize’ to environment
[09:29:17.009] assign_globals() ... done
[09:29:17.009] requestCore(): workers = 2
[09:29:17.011] MulticoreFuture started
[09:29:17.012] - Launch lazy future ... done
[09:29:17.012] run() for ‘MulticoreFuture’ ... done
[09:29:17.012] Created future:
[09:29:17.012] plan(): Setting new future strategy stack:
[09:29:17.013] List of future strategies:
[09:29:17.013] 1. sequential:
[09:29:17.013]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:17.013]    - tweaked: FALSE
[09:29:17.013]    - call: NULL
[09:29:17.014] plan(): nbrOfWorkers() = 1
[09:29:17.016] plan(): Setting new future strategy stack:
[09:29:17.016] List of future strategies:
[09:29:17.016] 1. multicore:
[09:29:17.016]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:17.016]    - tweaked: FALSE
[09:29:17.016]    - call: plan(strategy)
[09:29:17.021] plan(): nbrOfWorkers() = 2
[09:29:17.012] MulticoreFuture:
[09:29:17.012] Label: ‘future_mapply-2’
[09:29:17.012] Expression:
[09:29:17.012] {
[09:29:17.012]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.012]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:17.012]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.012]         on.exit(options(oopts), add = TRUE)
[09:29:17.012]     }
[09:29:17.012]     {
[09:29:17.012]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:17.012]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[09:29:17.012]                 inherits = FALSE)
[09:29:17.012]             ...future.FUN(...)
[09:29:17.012]         }
[09:29:17.012]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:17.012]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:17.012]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:17.012]         do.call(mapply, args = args)
[09:29:17.012]     }
[09:29:17.012] }
[09:29:17.012] Lazy evaluation: FALSE
[09:29:17.012] Asynchronous evaluation: TRUE
[09:29:17.012] Local evaluation: TRUE
[09:29:17.012] Environment: R_GlobalEnv
[09:29:17.012] Capture standard output: TRUE
[09:29:17.012] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:17.012] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:17.012] Packages: <none>
[09:29:17.012] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:29:17.012] Resolved: TRUE
[09:29:17.012] Value: <not collected>
[09:29:17.012] Conditions captured: <none>
[09:29:17.012] Early signaling: FALSE
[09:29:17.012] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:17.012] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.022] Chunk #2 of 2 ... DONE
[09:29:17.022] Launching 2 futures (chunks) ... DONE
[09:29:17.022] Resolving 2 futures (chunks) ...
[09:29:17.022] resolve() on list ...
[09:29:17.022]  recursive: 0
[09:29:17.023]  length: 2
[09:29:17.023] 
[09:29:17.023] Future #1
[09:29:17.023] result() for MulticoreFuture ...
[09:29:17.024] result() for MulticoreFuture ...
[09:29:17.024] result() for MulticoreFuture ... done
[09:29:17.024] result() for MulticoreFuture ... done
[09:29:17.024] result() for MulticoreFuture ...
[09:29:17.025] result() for MulticoreFuture ... done
[09:29:17.025] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:17.025] - nx: 2
[09:29:17.025] - relay: TRUE
[09:29:17.025] - stdout: TRUE
[09:29:17.025] - signal: TRUE
[09:29:17.026] - resignal: FALSE
[09:29:17.026] - force: TRUE
[09:29:17.026] - relayed: [n=2] FALSE, FALSE
[09:29:17.026] - queued futures: [n=2] FALSE, FALSE
[09:29:17.026]  - until=1
[09:29:17.026]  - relaying element #1
[09:29:17.027] result() for MulticoreFuture ...
[09:29:17.027] result() for MulticoreFuture ... done
[09:29:17.027] result() for MulticoreFuture ...
[09:29:17.027] result() for MulticoreFuture ... done
[09:29:17.027] result() for MulticoreFuture ...
[09:29:17.027] result() for MulticoreFuture ... done
[09:29:17.028] result() for MulticoreFuture ...
[09:29:17.028] result() for MulticoreFuture ... done
[09:29:17.028] - relayed: [n=2] TRUE, FALSE
[09:29:17.028] - queued futures: [n=2] TRUE, FALSE
[09:29:17.028] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:17.028]  length: 1 (resolved future 1)
[09:29:17.029] Future #2
[09:29:17.029] result() for MulticoreFuture ...
[09:29:17.030] result() for MulticoreFuture ...
[09:29:17.030] result() for MulticoreFuture ... done
[09:29:17.030] result() for MulticoreFuture ... done
[09:29:17.030] result() for MulticoreFuture ...
[09:29:17.030] result() for MulticoreFuture ... done
[09:29:17.030] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:17.030] - nx: 2
[09:29:17.031] - relay: TRUE
[09:29:17.031] - stdout: TRUE
[09:29:17.031] - signal: TRUE
[09:29:17.031] - resignal: FALSE
[09:29:17.031] - force: TRUE
[09:29:17.031] - relayed: [n=2] TRUE, FALSE
[09:29:17.031] - queued futures: [n=2] TRUE, FALSE
[09:29:17.031]  - until=2
[09:29:17.032]  - relaying element #2
[09:29:17.032] result() for MulticoreFuture ...
[09:29:17.032] result() for MulticoreFuture ... done
[09:29:17.032] result() for MulticoreFuture ...
[09:29:17.032] result() for MulticoreFuture ... done
[09:29:17.032] result() for MulticoreFuture ...
[09:29:17.032] result() for MulticoreFuture ... done
[09:29:17.032] result() for MulticoreFuture ...
[09:29:17.033] result() for MulticoreFuture ... done
[09:29:17.033] - relayed: [n=2] TRUE, TRUE
[09:29:17.033] - queued futures: [n=2] TRUE, TRUE
[09:29:17.033] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:17.036]  length: 0 (resolved future 2)
[09:29:17.036] Relaying remaining futures
[09:29:17.036] signalConditionsASAP(NULL, pos=0) ...
[09:29:17.036] - nx: 2
[09:29:17.037] - relay: TRUE
[09:29:17.037] - stdout: TRUE
[09:29:17.037] - signal: TRUE
[09:29:17.037] - resignal: FALSE
[09:29:17.037] - force: TRUE
[09:29:17.037] - relayed: [n=2] TRUE, TRUE
[09:29:17.037] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:17.038] - relayed: [n=2] TRUE, TRUE
[09:29:17.038] - queued futures: [n=2] TRUE, TRUE
[09:29:17.038] signalConditionsASAP(NULL, pos=0) ... done
[09:29:17.038] resolve() on list ... DONE
[09:29:17.038] result() for MulticoreFuture ...
[09:29:17.038] result() for MulticoreFuture ... done
[09:29:17.038] result() for MulticoreFuture ...
[09:29:17.039] result() for MulticoreFuture ... done
[09:29:17.039] result() for MulticoreFuture ...
[09:29:17.039] result() for MulticoreFuture ... done
[09:29:17.039] result() for MulticoreFuture ...
[09:29:17.039] result() for MulticoreFuture ... done
[09:29:17.039]  - Number of value chunks collected: 2
[09:29:17.039] Resolving 2 futures (chunks) ... DONE
[09:29:17.040] Reducing values from 2 chunks ...
[09:29:17.040]  - Number of values collected after concatenation: 2
[09:29:17.040]  - Number of values expected: 2
[09:29:17.040] Reducing values from 2 chunks ... DONE
[09:29:17.040] future_mapply() ... DONE
[09:29:17.040] future_mapply() ...
[09:29:17.045] Number of chunks: 2
[09:29:17.045] getGlobalsAndPackagesXApply() ...
[09:29:17.045]  - future.globals: TRUE
[09:29:17.045] getGlobalsAndPackages() ...
[09:29:17.045] Searching for globals...
[09:29:17.047] - globals found: [1] ‘FUN’
[09:29:17.047] Searching for globals ... DONE
[09:29:17.047] Resolving globals: FALSE
[09:29:17.047] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[09:29:17.048] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[09:29:17.048] - globals: [1] ‘FUN’
[09:29:17.048] 
[09:29:17.048] getGlobalsAndPackages() ... DONE
[09:29:17.048]  - globals found/used: [n=1] ‘FUN’
[09:29:17.048]  - needed namespaces: [n=0] 
[09:29:17.048] Finding globals ... DONE
[09:29:17.049] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:17.049] List of 2
[09:29:17.049]  $ ...future.FUN:function (x, y)  
[09:29:17.049]  $ MoreArgs     :List of 1
[09:29:17.049]   ..$ y: int [1:2] 3 4
[09:29:17.049]  - attr(*, "where")=List of 2
[09:29:17.049]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:17.049]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:17.049]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.049]  - attr(*, "resolved")= logi FALSE
[09:29:17.049]  - attr(*, "total_size")= num NA
[09:29:17.052] Packages to be attached in all futures: [n=0] 
[09:29:17.052] getGlobalsAndPackagesXApply() ... DONE
[09:29:17.052] Number of futures (= number of chunks): 2
[09:29:17.052] Launching 2 futures (chunks) ...
[09:29:17.053] Chunk #1 of 2 ...
[09:29:17.053]  - Finding globals in '...' for chunk #1 ...
[09:29:17.053] getGlobalsAndPackages() ...
[09:29:17.053] Searching for globals...
[09:29:17.053] 
[09:29:17.053] Searching for globals ... DONE
[09:29:17.053] - globals: [0] <none>
[09:29:17.053] getGlobalsAndPackages() ... DONE
[09:29:17.054]    + additional globals found: [n=0] 
[09:29:17.054]    + additional namespaces needed: [n=0] 
[09:29:17.054]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:17.054]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:17.054]  - seeds: <none>
[09:29:17.054]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.054] getGlobalsAndPackages() ...
[09:29:17.054] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.054] Resolving globals: FALSE
[09:29:17.055] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[09:29:17.055] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[09:29:17.055] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.055] 
[09:29:17.055] getGlobalsAndPackages() ... DONE
[09:29:17.056] run() for ‘Future’ ...
[09:29:17.056] - state: ‘created’
[09:29:17.056] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:17.059] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.060] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:17.060]   - Field: ‘label’
[09:29:17.060]   - Field: ‘local’
[09:29:17.060]   - Field: ‘owner’
[09:29:17.060]   - Field: ‘envir’
[09:29:17.060]   - Field: ‘workers’
[09:29:17.060]   - Field: ‘packages’
[09:29:17.060]   - Field: ‘gc’
[09:29:17.060]   - Field: ‘job’
[09:29:17.060]   - Field: ‘conditions’
[09:29:17.061]   - Field: ‘expr’
[09:29:17.061]   - Field: ‘uuid’
[09:29:17.061]   - Field: ‘seed’
[09:29:17.061]   - Field: ‘version’
[09:29:17.061]   - Field: ‘result’
[09:29:17.061]   - Field: ‘asynchronous’
[09:29:17.061]   - Field: ‘calls’
[09:29:17.061]   - Field: ‘globals’
[09:29:17.061]   - Field: ‘stdout’
[09:29:17.061]   - Field: ‘earlySignal’
[09:29:17.061]   - Field: ‘lazy’
[09:29:17.062]   - Field: ‘state’
[09:29:17.062] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:17.062] - Launch lazy future ...
[09:29:17.062] Packages needed by the future expression (n = 0): <none>
[09:29:17.062] Packages needed by future strategies (n = 0): <none>
[09:29:17.063] {
[09:29:17.063]     {
[09:29:17.063]         {
[09:29:17.063]             ...future.startTime <- base::Sys.time()
[09:29:17.063]             {
[09:29:17.063]                 {
[09:29:17.063]                   {
[09:29:17.063]                     {
[09:29:17.063]                       base::local({
[09:29:17.063]                         has_future <- base::requireNamespace("future", 
[09:29:17.063]                           quietly = TRUE)
[09:29:17.063]                         if (has_future) {
[09:29:17.063]                           ns <- base::getNamespace("future")
[09:29:17.063]                           version <- ns[[".package"]][["version"]]
[09:29:17.063]                           if (is.null(version)) 
[09:29:17.063]                             version <- utils::packageVersion("future")
[09:29:17.063]                         }
[09:29:17.063]                         else {
[09:29:17.063]                           version <- NULL
[09:29:17.063]                         }
[09:29:17.063]                         if (!has_future || version < "1.8.0") {
[09:29:17.063]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:17.063]                             "", base::R.version$version.string), 
[09:29:17.063]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:17.063]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:17.063]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:17.063]                               "release", "version")], collapse = " "), 
[09:29:17.063]                             hostname = base::Sys.info()[["nodename"]])
[09:29:17.063]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:17.063]                             info)
[09:29:17.063]                           info <- base::paste(info, collapse = "; ")
[09:29:17.063]                           if (!has_future) {
[09:29:17.063]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:17.063]                               info)
[09:29:17.063]                           }
[09:29:17.063]                           else {
[09:29:17.063]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:17.063]                               info, version)
[09:29:17.063]                           }
[09:29:17.063]                           base::stop(msg)
[09:29:17.063]                         }
[09:29:17.063]                       })
[09:29:17.063]                     }
[09:29:17.063]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:17.063]                     base::options(mc.cores = 1L)
[09:29:17.063]                   }
[09:29:17.063]                   ...future.strategy.old <- future::plan("list")
[09:29:17.063]                   options(future.plan = NULL)
[09:29:17.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:17.063]                 }
[09:29:17.063]                 ...future.workdir <- getwd()
[09:29:17.063]             }
[09:29:17.063]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:17.063]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:17.063]         }
[09:29:17.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:17.063]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:17.063]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:17.063]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:17.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:17.063]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:17.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:17.063]             base::names(...future.oldOptions))
[09:29:17.063]     }
[09:29:17.063]     if (FALSE) {
[09:29:17.063]     }
[09:29:17.063]     else {
[09:29:17.063]         if (TRUE) {
[09:29:17.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:17.063]                 open = "w")
[09:29:17.063]         }
[09:29:17.063]         else {
[09:29:17.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:17.063]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:17.063]         }
[09:29:17.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:17.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:17.063]             base::sink(type = "output", split = FALSE)
[09:29:17.063]             base::close(...future.stdout)
[09:29:17.063]         }, add = TRUE)
[09:29:17.063]     }
[09:29:17.063]     ...future.frame <- base::sys.nframe()
[09:29:17.063]     ...future.conditions <- base::list()
[09:29:17.063]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:17.063]     if (FALSE) {
[09:29:17.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:17.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:17.063]     }
[09:29:17.063]     ...future.result <- base::tryCatch({
[09:29:17.063]         base::withCallingHandlers({
[09:29:17.063]             ...future.value <- base::withVisible(base::local({
[09:29:17.063]                 withCallingHandlers({
[09:29:17.063]                   {
[09:29:17.063]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.063]                     if (!identical(...future.globals.maxSize.org, 
[09:29:17.063]                       ...future.globals.maxSize)) {
[09:29:17.063]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.063]                       on.exit(options(oopts), add = TRUE)
[09:29:17.063]                     }
[09:29:17.063]                     {
[09:29:17.063]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.063]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:17.063]                         USE.NAMES = FALSE)
[09:29:17.063]                       do.call(mapply, args = args)
[09:29:17.063]                     }
[09:29:17.063]                   }
[09:29:17.063]                 }, immediateCondition = function(cond) {
[09:29:17.063]                   save_rds <- function (object, pathname, ...) 
[09:29:17.063]                   {
[09:29:17.063]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:17.063]                     if (file_test("-f", pathname_tmp)) {
[09:29:17.063]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.063]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:17.063]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.063]                         fi_tmp[["mtime"]])
[09:29:17.063]                     }
[09:29:17.063]                     tryCatch({
[09:29:17.063]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:17.063]                     }, error = function(ex) {
[09:29:17.063]                       msg <- conditionMessage(ex)
[09:29:17.063]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.063]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:17.063]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.063]                         fi_tmp[["mtime"]], msg)
[09:29:17.063]                       ex$message <- msg
[09:29:17.063]                       stop(ex)
[09:29:17.063]                     })
[09:29:17.063]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:17.063]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:17.063]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:17.063]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.063]                       fi <- file.info(pathname)
[09:29:17.063]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:17.063]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.063]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:17.063]                         fi[["size"]], fi[["mtime"]])
[09:29:17.063]                       stop(msg)
[09:29:17.063]                     }
[09:29:17.063]                     invisible(pathname)
[09:29:17.063]                   }
[09:29:17.063]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:17.063]                     rootPath = tempdir()) 
[09:29:17.063]                   {
[09:29:17.063]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:17.063]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:17.063]                       tmpdir = path, fileext = ".rds")
[09:29:17.063]                     save_rds(obj, file)
[09:29:17.063]                   }
[09:29:17.063]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:17.063]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.063]                   {
[09:29:17.063]                     inherits <- base::inherits
[09:29:17.063]                     invokeRestart <- base::invokeRestart
[09:29:17.063]                     is.null <- base::is.null
[09:29:17.063]                     muffled <- FALSE
[09:29:17.063]                     if (inherits(cond, "message")) {
[09:29:17.063]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:17.063]                       if (muffled) 
[09:29:17.063]                         invokeRestart("muffleMessage")
[09:29:17.063]                     }
[09:29:17.063]                     else if (inherits(cond, "warning")) {
[09:29:17.063]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:17.063]                       if (muffled) 
[09:29:17.063]                         invokeRestart("muffleWarning")
[09:29:17.063]                     }
[09:29:17.063]                     else if (inherits(cond, "condition")) {
[09:29:17.063]                       if (!is.null(pattern)) {
[09:29:17.063]                         computeRestarts <- base::computeRestarts
[09:29:17.063]                         grepl <- base::grepl
[09:29:17.063]                         restarts <- computeRestarts(cond)
[09:29:17.063]                         for (restart in restarts) {
[09:29:17.063]                           name <- restart$name
[09:29:17.063]                           if (is.null(name)) 
[09:29:17.063]                             next
[09:29:17.063]                           if (!grepl(pattern, name)) 
[09:29:17.063]                             next
[09:29:17.063]                           invokeRestart(restart)
[09:29:17.063]                           muffled <- TRUE
[09:29:17.063]                           break
[09:29:17.063]                         }
[09:29:17.063]                       }
[09:29:17.063]                     }
[09:29:17.063]                     invisible(muffled)
[09:29:17.063]                   }
[09:29:17.063]                   muffleCondition(cond)
[09:29:17.063]                 })
[09:29:17.063]             }))
[09:29:17.063]             future::FutureResult(value = ...future.value$value, 
[09:29:17.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.063]                   ...future.rng), globalenv = if (FALSE) 
[09:29:17.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:17.063]                     ...future.globalenv.names))
[09:29:17.063]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:17.063]         }, condition = base::local({
[09:29:17.063]             c <- base::c
[09:29:17.063]             inherits <- base::inherits
[09:29:17.063]             invokeRestart <- base::invokeRestart
[09:29:17.063]             length <- base::length
[09:29:17.063]             list <- base::list
[09:29:17.063]             seq.int <- base::seq.int
[09:29:17.063]             signalCondition <- base::signalCondition
[09:29:17.063]             sys.calls <- base::sys.calls
[09:29:17.063]             `[[` <- base::`[[`
[09:29:17.063]             `+` <- base::`+`
[09:29:17.063]             `<<-` <- base::`<<-`
[09:29:17.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:17.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:17.063]                   3L)]
[09:29:17.063]             }
[09:29:17.063]             function(cond) {
[09:29:17.063]                 is_error <- inherits(cond, "error")
[09:29:17.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:17.063]                   NULL)
[09:29:17.063]                 if (is_error) {
[09:29:17.063]                   sessionInformation <- function() {
[09:29:17.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:17.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:17.063]                       search = base::search(), system = base::Sys.info())
[09:29:17.063]                   }
[09:29:17.063]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:17.063]                     cond$call), session = sessionInformation(), 
[09:29:17.063]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:17.063]                   signalCondition(cond)
[09:29:17.063]                 }
[09:29:17.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:17.063]                 "immediateCondition"))) {
[09:29:17.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:17.063]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:17.063]                   if (TRUE && !signal) {
[09:29:17.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.063]                     {
[09:29:17.063]                       inherits <- base::inherits
[09:29:17.063]                       invokeRestart <- base::invokeRestart
[09:29:17.063]                       is.null <- base::is.null
[09:29:17.063]                       muffled <- FALSE
[09:29:17.063]                       if (inherits(cond, "message")) {
[09:29:17.063]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.063]                         if (muffled) 
[09:29:17.063]                           invokeRestart("muffleMessage")
[09:29:17.063]                       }
[09:29:17.063]                       else if (inherits(cond, "warning")) {
[09:29:17.063]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.063]                         if (muffled) 
[09:29:17.063]                           invokeRestart("muffleWarning")
[09:29:17.063]                       }
[09:29:17.063]                       else if (inherits(cond, "condition")) {
[09:29:17.063]                         if (!is.null(pattern)) {
[09:29:17.063]                           computeRestarts <- base::computeRestarts
[09:29:17.063]                           grepl <- base::grepl
[09:29:17.063]                           restarts <- computeRestarts(cond)
[09:29:17.063]                           for (restart in restarts) {
[09:29:17.063]                             name <- restart$name
[09:29:17.063]                             if (is.null(name)) 
[09:29:17.063]                               next
[09:29:17.063]                             if (!grepl(pattern, name)) 
[09:29:17.063]                               next
[09:29:17.063]                             invokeRestart(restart)
[09:29:17.063]                             muffled <- TRUE
[09:29:17.063]                             break
[09:29:17.063]                           }
[09:29:17.063]                         }
[09:29:17.063]                       }
[09:29:17.063]                       invisible(muffled)
[09:29:17.063]                     }
[09:29:17.063]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.063]                   }
[09:29:17.063]                 }
[09:29:17.063]                 else {
[09:29:17.063]                   if (TRUE) {
[09:29:17.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.063]                     {
[09:29:17.063]                       inherits <- base::inherits
[09:29:17.063]                       invokeRestart <- base::invokeRestart
[09:29:17.063]                       is.null <- base::is.null
[09:29:17.063]                       muffled <- FALSE
[09:29:17.063]                       if (inherits(cond, "message")) {
[09:29:17.063]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.063]                         if (muffled) 
[09:29:17.063]                           invokeRestart("muffleMessage")
[09:29:17.063]                       }
[09:29:17.063]                       else if (inherits(cond, "warning")) {
[09:29:17.063]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.063]                         if (muffled) 
[09:29:17.063]                           invokeRestart("muffleWarning")
[09:29:17.063]                       }
[09:29:17.063]                       else if (inherits(cond, "condition")) {
[09:29:17.063]                         if (!is.null(pattern)) {
[09:29:17.063]                           computeRestarts <- base::computeRestarts
[09:29:17.063]                           grepl <- base::grepl
[09:29:17.063]                           restarts <- computeRestarts(cond)
[09:29:17.063]                           for (restart in restarts) {
[09:29:17.063]                             name <- restart$name
[09:29:17.063]                             if (is.null(name)) 
[09:29:17.063]                               next
[09:29:17.063]                             if (!grepl(pattern, name)) 
[09:29:17.063]                               next
[09:29:17.063]                             invokeRestart(restart)
[09:29:17.063]                             muffled <- TRUE
[09:29:17.063]                             break
[09:29:17.063]                           }
[09:29:17.063]                         }
[09:29:17.063]                       }
[09:29:17.063]                       invisible(muffled)
[09:29:17.063]                     }
[09:29:17.063]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.063]                   }
[09:29:17.063]                 }
[09:29:17.063]             }
[09:29:17.063]         }))
[09:29:17.063]     }, error = function(ex) {
[09:29:17.063]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:17.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.063]                 ...future.rng), started = ...future.startTime, 
[09:29:17.063]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:17.063]             version = "1.8"), class = "FutureResult")
[09:29:17.063]     }, finally = {
[09:29:17.063]         if (!identical(...future.workdir, getwd())) 
[09:29:17.063]             setwd(...future.workdir)
[09:29:17.063]         {
[09:29:17.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:17.063]                 ...future.oldOptions$nwarnings <- NULL
[09:29:17.063]             }
[09:29:17.063]             base::options(...future.oldOptions)
[09:29:17.063]             if (.Platform$OS.type == "windows") {
[09:29:17.063]                 old_names <- names(...future.oldEnvVars)
[09:29:17.063]                 envs <- base::Sys.getenv()
[09:29:17.063]                 names <- names(envs)
[09:29:17.063]                 common <- intersect(names, old_names)
[09:29:17.063]                 added <- setdiff(names, old_names)
[09:29:17.063]                 removed <- setdiff(old_names, names)
[09:29:17.063]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:17.063]                   envs[common]]
[09:29:17.063]                 NAMES <- toupper(changed)
[09:29:17.063]                 args <- list()
[09:29:17.063]                 for (kk in seq_along(NAMES)) {
[09:29:17.063]                   name <- changed[[kk]]
[09:29:17.063]                   NAME <- NAMES[[kk]]
[09:29:17.063]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.063]                     next
[09:29:17.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.063]                 }
[09:29:17.063]                 NAMES <- toupper(added)
[09:29:17.063]                 for (kk in seq_along(NAMES)) {
[09:29:17.063]                   name <- added[[kk]]
[09:29:17.063]                   NAME <- NAMES[[kk]]
[09:29:17.063]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.063]                     next
[09:29:17.063]                   args[[name]] <- ""
[09:29:17.063]                 }
[09:29:17.063]                 NAMES <- toupper(removed)
[09:29:17.063]                 for (kk in seq_along(NAMES)) {
[09:29:17.063]                   name <- removed[[kk]]
[09:29:17.063]                   NAME <- NAMES[[kk]]
[09:29:17.063]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.063]                     next
[09:29:17.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.063]                 }
[09:29:17.063]                 if (length(args) > 0) 
[09:29:17.063]                   base::do.call(base::Sys.setenv, args = args)
[09:29:17.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:17.063]             }
[09:29:17.063]             else {
[09:29:17.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:17.063]             }
[09:29:17.063]             {
[09:29:17.063]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:17.063]                   0L) {
[09:29:17.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:17.063]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:17.063]                   base::options(opts)
[09:29:17.063]                 }
[09:29:17.063]                 {
[09:29:17.063]                   {
[09:29:17.063]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:17.063]                     NULL
[09:29:17.063]                   }
[09:29:17.063]                   options(future.plan = NULL)
[09:29:17.063]                   if (is.na(NA_character_)) 
[09:29:17.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:17.063]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:17.063]                     .init = FALSE)
[09:29:17.063]                 }
[09:29:17.063]             }
[09:29:17.063]         }
[09:29:17.063]     })
[09:29:17.063]     if (TRUE) {
[09:29:17.063]         base::sink(type = "output", split = FALSE)
[09:29:17.063]         if (TRUE) {
[09:29:17.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:17.063]         }
[09:29:17.063]         else {
[09:29:17.063]             ...future.result["stdout"] <- base::list(NULL)
[09:29:17.063]         }
[09:29:17.063]         base::close(...future.stdout)
[09:29:17.063]         ...future.stdout <- NULL
[09:29:17.063]     }
[09:29:17.063]     ...future.result$conditions <- ...future.conditions
[09:29:17.063]     ...future.result$finished <- base::Sys.time()
[09:29:17.063]     ...future.result
[09:29:17.063] }
[09:29:17.065] assign_globals() ...
[09:29:17.065] List of 5
[09:29:17.065]  $ ...future.FUN            :function (x, y)  
[09:29:17.065]  $ MoreArgs                 :List of 1
[09:29:17.065]   ..$ y: int [1:2] 3 4
[09:29:17.065]  $ ...future.elements_ii    :List of 1
[09:29:17.065]   ..$ x:List of 1
[09:29:17.065]   .. ..$ : int 1
[09:29:17.065]  $ ...future.seeds_ii       : NULL
[09:29:17.065]  $ ...future.globals.maxSize: NULL
[09:29:17.065]  - attr(*, "where")=List of 5
[09:29:17.065]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:17.065]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:17.065]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:17.065]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:17.065]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:17.065]  - attr(*, "resolved")= logi FALSE
[09:29:17.065]  - attr(*, "total_size")= num 1816
[09:29:17.065]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.065]  - attr(*, "already-done")= logi TRUE
[09:29:17.073] - reassign environment for ‘...future.FUN’
[09:29:17.073] - copied ‘...future.FUN’ to environment
[09:29:17.073] - copied ‘MoreArgs’ to environment
[09:29:17.073] - copied ‘...future.elements_ii’ to environment
[09:29:17.073] - copied ‘...future.seeds_ii’ to environment
[09:29:17.073] - copied ‘...future.globals.maxSize’ to environment
[09:29:17.074] assign_globals() ... done
[09:29:17.074] requestCore(): workers = 2
[09:29:17.076] MulticoreFuture started
[09:29:17.077] - Launch lazy future ... done
[09:29:17.077] plan(): Setting new future strategy stack:
[09:29:17.077] run() for ‘MulticoreFuture’ ... done
[09:29:17.078] Created future:
[09:29:17.078] List of future strategies:
[09:29:17.078] 1. sequential:
[09:29:17.078]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:17.078]    - tweaked: FALSE
[09:29:17.078]    - call: NULL
[09:29:17.079] plan(): nbrOfWorkers() = 1
[09:29:17.082] plan(): Setting new future strategy stack:
[09:29:17.082] List of future strategies:
[09:29:17.082] 1. multicore:
[09:29:17.082]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:17.082]    - tweaked: FALSE
[09:29:17.082]    - call: plan(strategy)
[09:29:17.088] plan(): nbrOfWorkers() = 2
[09:29:17.078] MulticoreFuture:
[09:29:17.078] Label: ‘future_.mapply-1’
[09:29:17.078] Expression:
[09:29:17.078] {
[09:29:17.078]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.078]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:17.078]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.078]         on.exit(options(oopts), add = TRUE)
[09:29:17.078]     }
[09:29:17.078]     {
[09:29:17.078]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.078]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:17.078]         do.call(mapply, args = args)
[09:29:17.078]     }
[09:29:17.078] }
[09:29:17.078] Lazy evaluation: FALSE
[09:29:17.078] Asynchronous evaluation: TRUE
[09:29:17.078] Local evaluation: TRUE
[09:29:17.078] Environment: R_GlobalEnv
[09:29:17.078] Capture standard output: TRUE
[09:29:17.078] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:17.078] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:17.078] Packages: <none>
[09:29:17.078] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:17.078] Resolved: TRUE
[09:29:17.078] Value: <not collected>
[09:29:17.078] Conditions captured: <none>
[09:29:17.078] Early signaling: FALSE
[09:29:17.078] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:17.078] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.089] Chunk #1 of 2 ... DONE
[09:29:17.089] Chunk #2 of 2 ...
[09:29:17.090]  - Finding globals in '...' for chunk #2 ...
[09:29:17.090] getGlobalsAndPackages() ...
[09:29:17.090] Searching for globals...
[09:29:17.091] 
[09:29:17.091] Searching for globals ... DONE
[09:29:17.091] - globals: [0] <none>
[09:29:17.091] getGlobalsAndPackages() ... DONE
[09:29:17.091]    + additional globals found: [n=0] 
[09:29:17.091]    + additional namespaces needed: [n=0] 
[09:29:17.092]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:17.092]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:17.092]  - seeds: <none>
[09:29:17.092]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.092] getGlobalsAndPackages() ...
[09:29:17.092] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.093] Resolving globals: FALSE
[09:29:17.094] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[09:29:17.094] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[09:29:17.095] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.095] 
[09:29:17.095] getGlobalsAndPackages() ... DONE
[09:29:17.095] run() for ‘Future’ ...
[09:29:17.096] - state: ‘created’
[09:29:17.096] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:17.100] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.100] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:17.101]   - Field: ‘label’
[09:29:17.101]   - Field: ‘local’
[09:29:17.101]   - Field: ‘owner’
[09:29:17.101]   - Field: ‘envir’
[09:29:17.101]   - Field: ‘workers’
[09:29:17.101]   - Field: ‘packages’
[09:29:17.101]   - Field: ‘gc’
[09:29:17.101]   - Field: ‘job’
[09:29:17.102]   - Field: ‘conditions’
[09:29:17.102]   - Field: ‘expr’
[09:29:17.102]   - Field: ‘uuid’
[09:29:17.102]   - Field: ‘seed’
[09:29:17.102]   - Field: ‘version’
[09:29:17.102]   - Field: ‘result’
[09:29:17.102]   - Field: ‘asynchronous’
[09:29:17.103]   - Field: ‘calls’
[09:29:17.103]   - Field: ‘globals’
[09:29:17.103]   - Field: ‘stdout’
[09:29:17.103]   - Field: ‘earlySignal’
[09:29:17.103]   - Field: ‘lazy’
[09:29:17.103]   - Field: ‘state’
[09:29:17.103] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:17.103] - Launch lazy future ...
[09:29:17.104] Packages needed by the future expression (n = 0): <none>
[09:29:17.104] Packages needed by future strategies (n = 0): <none>
[09:29:17.105] {
[09:29:17.105]     {
[09:29:17.105]         {
[09:29:17.105]             ...future.startTime <- base::Sys.time()
[09:29:17.105]             {
[09:29:17.105]                 {
[09:29:17.105]                   {
[09:29:17.105]                     {
[09:29:17.105]                       base::local({
[09:29:17.105]                         has_future <- base::requireNamespace("future", 
[09:29:17.105]                           quietly = TRUE)
[09:29:17.105]                         if (has_future) {
[09:29:17.105]                           ns <- base::getNamespace("future")
[09:29:17.105]                           version <- ns[[".package"]][["version"]]
[09:29:17.105]                           if (is.null(version)) 
[09:29:17.105]                             version <- utils::packageVersion("future")
[09:29:17.105]                         }
[09:29:17.105]                         else {
[09:29:17.105]                           version <- NULL
[09:29:17.105]                         }
[09:29:17.105]                         if (!has_future || version < "1.8.0") {
[09:29:17.105]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:17.105]                             "", base::R.version$version.string), 
[09:29:17.105]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:17.105]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:17.105]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:17.105]                               "release", "version")], collapse = " "), 
[09:29:17.105]                             hostname = base::Sys.info()[["nodename"]])
[09:29:17.105]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:17.105]                             info)
[09:29:17.105]                           info <- base::paste(info, collapse = "; ")
[09:29:17.105]                           if (!has_future) {
[09:29:17.105]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:17.105]                               info)
[09:29:17.105]                           }
[09:29:17.105]                           else {
[09:29:17.105]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:17.105]                               info, version)
[09:29:17.105]                           }
[09:29:17.105]                           base::stop(msg)
[09:29:17.105]                         }
[09:29:17.105]                       })
[09:29:17.105]                     }
[09:29:17.105]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:17.105]                     base::options(mc.cores = 1L)
[09:29:17.105]                   }
[09:29:17.105]                   ...future.strategy.old <- future::plan("list")
[09:29:17.105]                   options(future.plan = NULL)
[09:29:17.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:17.105]                 }
[09:29:17.105]                 ...future.workdir <- getwd()
[09:29:17.105]             }
[09:29:17.105]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:17.105]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:17.105]         }
[09:29:17.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:17.105]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:17.105]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:17.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:17.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:17.105]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:17.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:17.105]             base::names(...future.oldOptions))
[09:29:17.105]     }
[09:29:17.105]     if (FALSE) {
[09:29:17.105]     }
[09:29:17.105]     else {
[09:29:17.105]         if (TRUE) {
[09:29:17.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:17.105]                 open = "w")
[09:29:17.105]         }
[09:29:17.105]         else {
[09:29:17.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:17.105]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:17.105]         }
[09:29:17.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:17.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:17.105]             base::sink(type = "output", split = FALSE)
[09:29:17.105]             base::close(...future.stdout)
[09:29:17.105]         }, add = TRUE)
[09:29:17.105]     }
[09:29:17.105]     ...future.frame <- base::sys.nframe()
[09:29:17.105]     ...future.conditions <- base::list()
[09:29:17.105]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:17.105]     if (FALSE) {
[09:29:17.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:17.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:17.105]     }
[09:29:17.105]     ...future.result <- base::tryCatch({
[09:29:17.105]         base::withCallingHandlers({
[09:29:17.105]             ...future.value <- base::withVisible(base::local({
[09:29:17.105]                 withCallingHandlers({
[09:29:17.105]                   {
[09:29:17.105]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.105]                     if (!identical(...future.globals.maxSize.org, 
[09:29:17.105]                       ...future.globals.maxSize)) {
[09:29:17.105]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.105]                       on.exit(options(oopts), add = TRUE)
[09:29:17.105]                     }
[09:29:17.105]                     {
[09:29:17.105]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.105]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:17.105]                         USE.NAMES = FALSE)
[09:29:17.105]                       do.call(mapply, args = args)
[09:29:17.105]                     }
[09:29:17.105]                   }
[09:29:17.105]                 }, immediateCondition = function(cond) {
[09:29:17.105]                   save_rds <- function (object, pathname, ...) 
[09:29:17.105]                   {
[09:29:17.105]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:17.105]                     if (file_test("-f", pathname_tmp)) {
[09:29:17.105]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.105]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:17.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.105]                         fi_tmp[["mtime"]])
[09:29:17.105]                     }
[09:29:17.105]                     tryCatch({
[09:29:17.105]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:17.105]                     }, error = function(ex) {
[09:29:17.105]                       msg <- conditionMessage(ex)
[09:29:17.105]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.105]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:17.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.105]                         fi_tmp[["mtime"]], msg)
[09:29:17.105]                       ex$message <- msg
[09:29:17.105]                       stop(ex)
[09:29:17.105]                     })
[09:29:17.105]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:17.105]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:17.105]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:17.105]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.105]                       fi <- file.info(pathname)
[09:29:17.105]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:17.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.105]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:17.105]                         fi[["size"]], fi[["mtime"]])
[09:29:17.105]                       stop(msg)
[09:29:17.105]                     }
[09:29:17.105]                     invisible(pathname)
[09:29:17.105]                   }
[09:29:17.105]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:17.105]                     rootPath = tempdir()) 
[09:29:17.105]                   {
[09:29:17.105]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:17.105]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:17.105]                       tmpdir = path, fileext = ".rds")
[09:29:17.105]                     save_rds(obj, file)
[09:29:17.105]                   }
[09:29:17.105]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:17.105]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.105]                   {
[09:29:17.105]                     inherits <- base::inherits
[09:29:17.105]                     invokeRestart <- base::invokeRestart
[09:29:17.105]                     is.null <- base::is.null
[09:29:17.105]                     muffled <- FALSE
[09:29:17.105]                     if (inherits(cond, "message")) {
[09:29:17.105]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:17.105]                       if (muffled) 
[09:29:17.105]                         invokeRestart("muffleMessage")
[09:29:17.105]                     }
[09:29:17.105]                     else if (inherits(cond, "warning")) {
[09:29:17.105]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:17.105]                       if (muffled) 
[09:29:17.105]                         invokeRestart("muffleWarning")
[09:29:17.105]                     }
[09:29:17.105]                     else if (inherits(cond, "condition")) {
[09:29:17.105]                       if (!is.null(pattern)) {
[09:29:17.105]                         computeRestarts <- base::computeRestarts
[09:29:17.105]                         grepl <- base::grepl
[09:29:17.105]                         restarts <- computeRestarts(cond)
[09:29:17.105]                         for (restart in restarts) {
[09:29:17.105]                           name <- restart$name
[09:29:17.105]                           if (is.null(name)) 
[09:29:17.105]                             next
[09:29:17.105]                           if (!grepl(pattern, name)) 
[09:29:17.105]                             next
[09:29:17.105]                           invokeRestart(restart)
[09:29:17.105]                           muffled <- TRUE
[09:29:17.105]                           break
[09:29:17.105]                         }
[09:29:17.105]                       }
[09:29:17.105]                     }
[09:29:17.105]                     invisible(muffled)
[09:29:17.105]                   }
[09:29:17.105]                   muffleCondition(cond)
[09:29:17.105]                 })
[09:29:17.105]             }))
[09:29:17.105]             future::FutureResult(value = ...future.value$value, 
[09:29:17.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.105]                   ...future.rng), globalenv = if (FALSE) 
[09:29:17.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:17.105]                     ...future.globalenv.names))
[09:29:17.105]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:17.105]         }, condition = base::local({
[09:29:17.105]             c <- base::c
[09:29:17.105]             inherits <- base::inherits
[09:29:17.105]             invokeRestart <- base::invokeRestart
[09:29:17.105]             length <- base::length
[09:29:17.105]             list <- base::list
[09:29:17.105]             seq.int <- base::seq.int
[09:29:17.105]             signalCondition <- base::signalCondition
[09:29:17.105]             sys.calls <- base::sys.calls
[09:29:17.105]             `[[` <- base::`[[`
[09:29:17.105]             `+` <- base::`+`
[09:29:17.105]             `<<-` <- base::`<<-`
[09:29:17.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:17.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:17.105]                   3L)]
[09:29:17.105]             }
[09:29:17.105]             function(cond) {
[09:29:17.105]                 is_error <- inherits(cond, "error")
[09:29:17.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:17.105]                   NULL)
[09:29:17.105]                 if (is_error) {
[09:29:17.105]                   sessionInformation <- function() {
[09:29:17.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:17.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:17.105]                       search = base::search(), system = base::Sys.info())
[09:29:17.105]                   }
[09:29:17.105]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:17.105]                     cond$call), session = sessionInformation(), 
[09:29:17.105]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:17.105]                   signalCondition(cond)
[09:29:17.105]                 }
[09:29:17.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:17.105]                 "immediateCondition"))) {
[09:29:17.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:17.105]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:17.105]                   if (TRUE && !signal) {
[09:29:17.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.105]                     {
[09:29:17.105]                       inherits <- base::inherits
[09:29:17.105]                       invokeRestart <- base::invokeRestart
[09:29:17.105]                       is.null <- base::is.null
[09:29:17.105]                       muffled <- FALSE
[09:29:17.105]                       if (inherits(cond, "message")) {
[09:29:17.105]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.105]                         if (muffled) 
[09:29:17.105]                           invokeRestart("muffleMessage")
[09:29:17.105]                       }
[09:29:17.105]                       else if (inherits(cond, "warning")) {
[09:29:17.105]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.105]                         if (muffled) 
[09:29:17.105]                           invokeRestart("muffleWarning")
[09:29:17.105]                       }
[09:29:17.105]                       else if (inherits(cond, "condition")) {
[09:29:17.105]                         if (!is.null(pattern)) {
[09:29:17.105]                           computeRestarts <- base::computeRestarts
[09:29:17.105]                           grepl <- base::grepl
[09:29:17.105]                           restarts <- computeRestarts(cond)
[09:29:17.105]                           for (restart in restarts) {
[09:29:17.105]                             name <- restart$name
[09:29:17.105]                             if (is.null(name)) 
[09:29:17.105]                               next
[09:29:17.105]                             if (!grepl(pattern, name)) 
[09:29:17.105]                               next
[09:29:17.105]                             invokeRestart(restart)
[09:29:17.105]                             muffled <- TRUE
[09:29:17.105]                             break
[09:29:17.105]                           }
[09:29:17.105]                         }
[09:29:17.105]                       }
[09:29:17.105]                       invisible(muffled)
[09:29:17.105]                     }
[09:29:17.105]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.105]                   }
[09:29:17.105]                 }
[09:29:17.105]                 else {
[09:29:17.105]                   if (TRUE) {
[09:29:17.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.105]                     {
[09:29:17.105]                       inherits <- base::inherits
[09:29:17.105]                       invokeRestart <- base::invokeRestart
[09:29:17.105]                       is.null <- base::is.null
[09:29:17.105]                       muffled <- FALSE
[09:29:17.105]                       if (inherits(cond, "message")) {
[09:29:17.105]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.105]                         if (muffled) 
[09:29:17.105]                           invokeRestart("muffleMessage")
[09:29:17.105]                       }
[09:29:17.105]                       else if (inherits(cond, "warning")) {
[09:29:17.105]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.105]                         if (muffled) 
[09:29:17.105]                           invokeRestart("muffleWarning")
[09:29:17.105]                       }
[09:29:17.105]                       else if (inherits(cond, "condition")) {
[09:29:17.105]                         if (!is.null(pattern)) {
[09:29:17.105]                           computeRestarts <- base::computeRestarts
[09:29:17.105]                           grepl <- base::grepl
[09:29:17.105]                           restarts <- computeRestarts(cond)
[09:29:17.105]                           for (restart in restarts) {
[09:29:17.105]                             name <- restart$name
[09:29:17.105]                             if (is.null(name)) 
[09:29:17.105]                               next
[09:29:17.105]                             if (!grepl(pattern, name)) 
[09:29:17.105]                               next
[09:29:17.105]                             invokeRestart(restart)
[09:29:17.105]                             muffled <- TRUE
[09:29:17.105]                             break
[09:29:17.105]                           }
[09:29:17.105]                         }
[09:29:17.105]                       }
[09:29:17.105]                       invisible(muffled)
[09:29:17.105]                     }
[09:29:17.105]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.105]                   }
[09:29:17.105]                 }
[09:29:17.105]             }
[09:29:17.105]         }))
[09:29:17.105]     }, error = function(ex) {
[09:29:17.105]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:17.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.105]                 ...future.rng), started = ...future.startTime, 
[09:29:17.105]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:17.105]             version = "1.8"), class = "FutureResult")
[09:29:17.105]     }, finally = {
[09:29:17.105]         if (!identical(...future.workdir, getwd())) 
[09:29:17.105]             setwd(...future.workdir)
[09:29:17.105]         {
[09:29:17.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:17.105]                 ...future.oldOptions$nwarnings <- NULL
[09:29:17.105]             }
[09:29:17.105]             base::options(...future.oldOptions)
[09:29:17.105]             if (.Platform$OS.type == "windows") {
[09:29:17.105]                 old_names <- names(...future.oldEnvVars)
[09:29:17.105]                 envs <- base::Sys.getenv()
[09:29:17.105]                 names <- names(envs)
[09:29:17.105]                 common <- intersect(names, old_names)
[09:29:17.105]                 added <- setdiff(names, old_names)
[09:29:17.105]                 removed <- setdiff(old_names, names)
[09:29:17.105]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:17.105]                   envs[common]]
[09:29:17.105]                 NAMES <- toupper(changed)
[09:29:17.105]                 args <- list()
[09:29:17.105]                 for (kk in seq_along(NAMES)) {
[09:29:17.105]                   name <- changed[[kk]]
[09:29:17.105]                   NAME <- NAMES[[kk]]
[09:29:17.105]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.105]                     next
[09:29:17.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.105]                 }
[09:29:17.105]                 NAMES <- toupper(added)
[09:29:17.105]                 for (kk in seq_along(NAMES)) {
[09:29:17.105]                   name <- added[[kk]]
[09:29:17.105]                   NAME <- NAMES[[kk]]
[09:29:17.105]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.105]                     next
[09:29:17.105]                   args[[name]] <- ""
[09:29:17.105]                 }
[09:29:17.105]                 NAMES <- toupper(removed)
[09:29:17.105]                 for (kk in seq_along(NAMES)) {
[09:29:17.105]                   name <- removed[[kk]]
[09:29:17.105]                   NAME <- NAMES[[kk]]
[09:29:17.105]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.105]                     next
[09:29:17.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.105]                 }
[09:29:17.105]                 if (length(args) > 0) 
[09:29:17.105]                   base::do.call(base::Sys.setenv, args = args)
[09:29:17.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:17.105]             }
[09:29:17.105]             else {
[09:29:17.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:17.105]             }
[09:29:17.105]             {
[09:29:17.105]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:17.105]                   0L) {
[09:29:17.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:17.105]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:17.105]                   base::options(opts)
[09:29:17.105]                 }
[09:29:17.105]                 {
[09:29:17.105]                   {
[09:29:17.105]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:17.105]                     NULL
[09:29:17.105]                   }
[09:29:17.105]                   options(future.plan = NULL)
[09:29:17.105]                   if (is.na(NA_character_)) 
[09:29:17.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:17.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:17.105]                     .init = FALSE)
[09:29:17.105]                 }
[09:29:17.105]             }
[09:29:17.105]         }
[09:29:17.105]     })
[09:29:17.105]     if (TRUE) {
[09:29:17.105]         base::sink(type = "output", split = FALSE)
[09:29:17.105]         if (TRUE) {
[09:29:17.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:17.105]         }
[09:29:17.105]         else {
[09:29:17.105]             ...future.result["stdout"] <- base::list(NULL)
[09:29:17.105]         }
[09:29:17.105]         base::close(...future.stdout)
[09:29:17.105]         ...future.stdout <- NULL
[09:29:17.105]     }
[09:29:17.105]     ...future.result$conditions <- ...future.conditions
[09:29:17.105]     ...future.result$finished <- base::Sys.time()
[09:29:17.105]     ...future.result
[09:29:17.105] }
[09:29:17.108] assign_globals() ...
[09:29:17.109] List of 5
[09:29:17.109]  $ ...future.FUN            :function (x, y)  
[09:29:17.109]  $ MoreArgs                 :List of 1
[09:29:17.109]   ..$ y: int [1:2] 3 4
[09:29:17.109]  $ ...future.elements_ii    :List of 1
[09:29:17.109]   ..$ x:List of 1
[09:29:17.109]   .. ..$ : int 2
[09:29:17.109]  $ ...future.seeds_ii       : NULL
[09:29:17.109]  $ ...future.globals.maxSize: NULL
[09:29:17.109]  - attr(*, "where")=List of 5
[09:29:17.109]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:17.109]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:17.109]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:17.109]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:17.109]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:17.109]  - attr(*, "resolved")= logi FALSE
[09:29:17.109]  - attr(*, "total_size")= num 1816
[09:29:17.109]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.109]  - attr(*, "already-done")= logi TRUE
[09:29:17.120] - reassign environment for ‘...future.FUN’
[09:29:17.120] - copied ‘...future.FUN’ to environment
[09:29:17.120] - copied ‘MoreArgs’ to environment
[09:29:17.120] - copied ‘...future.elements_ii’ to environment
[09:29:17.121] - copied ‘...future.seeds_ii’ to environment
[09:29:17.121] - copied ‘...future.globals.maxSize’ to environment
[09:29:17.121] assign_globals() ... done
[09:29:17.121] requestCore(): workers = 2
[09:29:17.124] MulticoreFuture started
[09:29:17.124] - Launch lazy future ... done
[09:29:17.125] plan(): Setting new future strategy stack:
[09:29:17.125] run() for ‘MulticoreFuture’ ... done
[09:29:17.126] Created future:
[09:29:17.125] List of future strategies:
[09:29:17.125] 1. sequential:
[09:29:17.125]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:17.125]    - tweaked: FALSE
[09:29:17.125]    - call: NULL
[09:29:17.127] plan(): nbrOfWorkers() = 1
[09:29:17.130] plan(): Setting new future strategy stack:
[09:29:17.131] List of future strategies:
[09:29:17.131] 1. multicore:
[09:29:17.131]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:17.131]    - tweaked: FALSE
[09:29:17.131]    - call: plan(strategy)
[09:29:17.137] plan(): nbrOfWorkers() = 2
[09:29:17.126] MulticoreFuture:
[09:29:17.126] Label: ‘future_.mapply-2’
[09:29:17.126] Expression:
[09:29:17.126] {
[09:29:17.126]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.126]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:17.126]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.126]         on.exit(options(oopts), add = TRUE)
[09:29:17.126]     }
[09:29:17.126]     {
[09:29:17.126]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.126]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:17.126]         do.call(mapply, args = args)
[09:29:17.126]     }
[09:29:17.126] }
[09:29:17.126] Lazy evaluation: FALSE
[09:29:17.126] Asynchronous evaluation: TRUE
[09:29:17.126] Local evaluation: TRUE
[09:29:17.126] Environment: R_GlobalEnv
[09:29:17.126] Capture standard output: TRUE
[09:29:17.126] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:17.126] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:17.126] Packages: <none>
[09:29:17.126] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:17.126] Resolved: TRUE
[09:29:17.126] Value: <not collected>
[09:29:17.126] Conditions captured: <none>
[09:29:17.126] Early signaling: FALSE
[09:29:17.126] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:17.126] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.138] Chunk #2 of 2 ... DONE
[09:29:17.139] Launching 2 futures (chunks) ... DONE
[09:29:17.139] Resolving 2 futures (chunks) ...
[09:29:17.139] resolve() on list ...
[09:29:17.139]  recursive: 0
[09:29:17.140]  length: 2
[09:29:17.140] 
[09:29:17.140] Future #1
[09:29:17.141] result() for MulticoreFuture ...
[09:29:17.142] result() for MulticoreFuture ...
[09:29:17.142] result() for MulticoreFuture ... done
[09:29:17.142] result() for MulticoreFuture ... done
[09:29:17.142] result() for MulticoreFuture ...
[09:29:17.142] result() for MulticoreFuture ... done
[09:29:17.143] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:17.143] - nx: 2
[09:29:17.143] - relay: TRUE
[09:29:17.143] - stdout: TRUE
[09:29:17.143] - signal: TRUE
[09:29:17.144] - resignal: FALSE
[09:29:17.144] - force: TRUE
[09:29:17.144] - relayed: [n=2] FALSE, FALSE
[09:29:17.144] - queued futures: [n=2] FALSE, FALSE
[09:29:17.144]  - until=1
[09:29:17.145]  - relaying element #1
[09:29:17.145] result() for MulticoreFuture ...
[09:29:17.145] result() for MulticoreFuture ... done
[09:29:17.145] result() for MulticoreFuture ...
[09:29:17.145] result() for MulticoreFuture ... done
[09:29:17.145] result() for MulticoreFuture ...
[09:29:17.146] result() for MulticoreFuture ... done
[09:29:17.146] result() for MulticoreFuture ...
[09:29:17.146] result() for MulticoreFuture ... done
[09:29:17.146] - relayed: [n=2] TRUE, FALSE
[09:29:17.146] - queued futures: [n=2] TRUE, FALSE
[09:29:17.146] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:17.146]  length: 1 (resolved future 1)
[09:29:17.147] Future #2
[09:29:17.147] result() for MulticoreFuture ...
[09:29:17.148] result() for MulticoreFuture ...
[09:29:17.148] result() for MulticoreFuture ... done
[09:29:17.148] result() for MulticoreFuture ... done
[09:29:17.149] result() for MulticoreFuture ...
[09:29:17.149] result() for MulticoreFuture ... done
[09:29:17.149] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:17.149] - nx: 2
[09:29:17.149] - relay: TRUE
[09:29:17.149] - stdout: TRUE
[09:29:17.150] - signal: TRUE
[09:29:17.150] - resignal: FALSE
[09:29:17.150] - force: TRUE
[09:29:17.150] - relayed: [n=2] TRUE, FALSE
[09:29:17.150] - queued futures: [n=2] TRUE, FALSE
[09:29:17.150]  - until=2
[09:29:17.150]  - relaying element #2
[09:29:17.151] result() for MulticoreFuture ...
[09:29:17.151] result() for MulticoreFuture ... done
[09:29:17.151] result() for MulticoreFuture ...
[09:29:17.151] result() for MulticoreFuture ... done
[09:29:17.151] result() for MulticoreFuture ...
[09:29:17.151] result() for MulticoreFuture ... done
[09:29:17.151] result() for MulticoreFuture ...
[09:29:17.151] result() for MulticoreFuture ... done
[09:29:17.152] - relayed: [n=2] TRUE, TRUE
[09:29:17.152] - queued futures: [n=2] TRUE, TRUE
[09:29:17.152] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:17.152]  length: 0 (resolved future 2)
[09:29:17.152] Relaying remaining futures
[09:29:17.152] signalConditionsASAP(NULL, pos=0) ...
[09:29:17.152] - nx: 2
[09:29:17.152] - relay: TRUE
[09:29:17.152] - stdout: TRUE
[09:29:17.153] - signal: TRUE
[09:29:17.153] - resignal: FALSE
[09:29:17.153] - force: TRUE
[09:29:17.153] - relayed: [n=2] TRUE, TRUE
[09:29:17.153] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:17.153] - relayed: [n=2] TRUE, TRUE
[09:29:17.153] - queued futures: [n=2] TRUE, TRUE
[09:29:17.153] signalConditionsASAP(NULL, pos=0) ... done
[09:29:17.153] resolve() on list ... DONE
[09:29:17.154] result() for MulticoreFuture ...
[09:29:17.154] result() for MulticoreFuture ... done
[09:29:17.154] result() for MulticoreFuture ...
[09:29:17.154] result() for MulticoreFuture ... done
[09:29:17.154] result() for MulticoreFuture ...
[09:29:17.154] result() for MulticoreFuture ... done
[09:29:17.154] result() for MulticoreFuture ...
[09:29:17.154] result() for MulticoreFuture ... done
[09:29:17.154]  - Number of value chunks collected: 2
[09:29:17.154] Resolving 2 futures (chunks) ... DONE
[09:29:17.155] Reducing values from 2 chunks ...
[09:29:17.155]  - Number of values collected after concatenation: 2
[09:29:17.155]  - Number of values expected: 2
[09:29:17.155] Reducing values from 2 chunks ... DONE
[09:29:17.155] future_mapply() ... DONE
- Recycle arguments to same length ...
[09:29:17.155] future_mapply() ...
[09:29:17.159] Number of chunks: 2
[09:29:17.159] getGlobalsAndPackagesXApply() ...
[09:29:17.159]  - future.globals: TRUE
[09:29:17.160] getGlobalsAndPackages() ...
[09:29:17.160] Searching for globals...
[09:29:17.160] - globals found: [1] ‘FUN’
[09:29:17.161] Searching for globals ... DONE
[09:29:17.161] Resolving globals: FALSE
[09:29:17.161] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:17.161] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:17.161] - globals: [1] ‘FUN’
[09:29:17.162] 
[09:29:17.162] getGlobalsAndPackages() ... DONE
[09:29:17.162]  - globals found/used: [n=1] ‘FUN’
[09:29:17.162]  - needed namespaces: [n=0] 
[09:29:17.162] Finding globals ... DONE
[09:29:17.162] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:17.162] List of 2
[09:29:17.162]  $ ...future.FUN:function (x, ...)  
[09:29:17.162]  $ MoreArgs     : NULL
[09:29:17.162]  - attr(*, "where")=List of 2
[09:29:17.162]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:17.162]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:17.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.162]  - attr(*, "resolved")= logi FALSE
[09:29:17.162]  - attr(*, "total_size")= num NA
[09:29:17.168] Packages to be attached in all futures: [n=0] 
[09:29:17.168] getGlobalsAndPackagesXApply() ... DONE
[09:29:17.168] Number of futures (= number of chunks): 2
[09:29:17.168] Launching 2 futures (chunks) ...
[09:29:17.169] Chunk #1 of 2 ...
[09:29:17.169]  - Finding globals in '...' for chunk #1 ...
[09:29:17.169] getGlobalsAndPackages() ...
[09:29:17.169] Searching for globals...
[09:29:17.169] 
[09:29:17.169] Searching for globals ... DONE
[09:29:17.170] - globals: [0] <none>
[09:29:17.170] getGlobalsAndPackages() ... DONE
[09:29:17.170]    + additional globals found: [n=0] 
[09:29:17.170]    + additional namespaces needed: [n=0] 
[09:29:17.170]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:17.170]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:17.170]  - seeds: <none>
[09:29:17.170]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.170] getGlobalsAndPackages() ...
[09:29:17.171] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.171] Resolving globals: FALSE
[09:29:17.171] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:17.172] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:17.172] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.172] 
[09:29:17.172] getGlobalsAndPackages() ... DONE
[09:29:17.172] run() for ‘Future’ ...
[09:29:17.173] - state: ‘created’
[09:29:17.173] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:17.176] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.176] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:17.177]   - Field: ‘label’
[09:29:17.177]   - Field: ‘local’
[09:29:17.177]   - Field: ‘owner’
[09:29:17.177]   - Field: ‘envir’
[09:29:17.177]   - Field: ‘workers’
[09:29:17.177]   - Field: ‘packages’
[09:29:17.177]   - Field: ‘gc’
[09:29:17.177]   - Field: ‘job’
[09:29:17.177]   - Field: ‘conditions’
[09:29:17.177]   - Field: ‘expr’
[09:29:17.177]   - Field: ‘uuid’
[09:29:17.178]   - Field: ‘seed’
[09:29:17.178]   - Field: ‘version’
[09:29:17.178]   - Field: ‘result’
[09:29:17.178]   - Field: ‘asynchronous’
[09:29:17.178]   - Field: ‘calls’
[09:29:17.178]   - Field: ‘globals’
[09:29:17.178]   - Field: ‘stdout’
[09:29:17.178]   - Field: ‘earlySignal’
[09:29:17.178]   - Field: ‘lazy’
[09:29:17.178]   - Field: ‘state’
[09:29:17.178] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:17.179] - Launch lazy future ...
[09:29:17.179] Packages needed by the future expression (n = 0): <none>
[09:29:17.179] Packages needed by future strategies (n = 0): <none>
[09:29:17.179] {
[09:29:17.179]     {
[09:29:17.179]         {
[09:29:17.179]             ...future.startTime <- base::Sys.time()
[09:29:17.179]             {
[09:29:17.179]                 {
[09:29:17.179]                   {
[09:29:17.179]                     {
[09:29:17.179]                       base::local({
[09:29:17.179]                         has_future <- base::requireNamespace("future", 
[09:29:17.179]                           quietly = TRUE)
[09:29:17.179]                         if (has_future) {
[09:29:17.179]                           ns <- base::getNamespace("future")
[09:29:17.179]                           version <- ns[[".package"]][["version"]]
[09:29:17.179]                           if (is.null(version)) 
[09:29:17.179]                             version <- utils::packageVersion("future")
[09:29:17.179]                         }
[09:29:17.179]                         else {
[09:29:17.179]                           version <- NULL
[09:29:17.179]                         }
[09:29:17.179]                         if (!has_future || version < "1.8.0") {
[09:29:17.179]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:17.179]                             "", base::R.version$version.string), 
[09:29:17.179]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:17.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:17.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:17.179]                               "release", "version")], collapse = " "), 
[09:29:17.179]                             hostname = base::Sys.info()[["nodename"]])
[09:29:17.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:17.179]                             info)
[09:29:17.179]                           info <- base::paste(info, collapse = "; ")
[09:29:17.179]                           if (!has_future) {
[09:29:17.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:17.179]                               info)
[09:29:17.179]                           }
[09:29:17.179]                           else {
[09:29:17.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:17.179]                               info, version)
[09:29:17.179]                           }
[09:29:17.179]                           base::stop(msg)
[09:29:17.179]                         }
[09:29:17.179]                       })
[09:29:17.179]                     }
[09:29:17.179]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:17.179]                     base::options(mc.cores = 1L)
[09:29:17.179]                   }
[09:29:17.179]                   ...future.strategy.old <- future::plan("list")
[09:29:17.179]                   options(future.plan = NULL)
[09:29:17.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:17.179]                 }
[09:29:17.179]                 ...future.workdir <- getwd()
[09:29:17.179]             }
[09:29:17.179]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:17.179]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:17.179]         }
[09:29:17.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:17.179]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:17.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:17.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:17.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:17.179]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:17.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:17.179]             base::names(...future.oldOptions))
[09:29:17.179]     }
[09:29:17.179]     if (FALSE) {
[09:29:17.179]     }
[09:29:17.179]     else {
[09:29:17.179]         if (TRUE) {
[09:29:17.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:17.179]                 open = "w")
[09:29:17.179]         }
[09:29:17.179]         else {
[09:29:17.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:17.179]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:17.179]         }
[09:29:17.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:17.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:17.179]             base::sink(type = "output", split = FALSE)
[09:29:17.179]             base::close(...future.stdout)
[09:29:17.179]         }, add = TRUE)
[09:29:17.179]     }
[09:29:17.179]     ...future.frame <- base::sys.nframe()
[09:29:17.179]     ...future.conditions <- base::list()
[09:29:17.179]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:17.179]     if (FALSE) {
[09:29:17.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:17.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:17.179]     }
[09:29:17.179]     ...future.result <- base::tryCatch({
[09:29:17.179]         base::withCallingHandlers({
[09:29:17.179]             ...future.value <- base::withVisible(base::local({
[09:29:17.179]                 withCallingHandlers({
[09:29:17.179]                   {
[09:29:17.179]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.179]                     if (!identical(...future.globals.maxSize.org, 
[09:29:17.179]                       ...future.globals.maxSize)) {
[09:29:17.179]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.179]                       on.exit(options(oopts), add = TRUE)
[09:29:17.179]                     }
[09:29:17.179]                     {
[09:29:17.179]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.179]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:17.179]                         USE.NAMES = FALSE)
[09:29:17.179]                       do.call(mapply, args = args)
[09:29:17.179]                     }
[09:29:17.179]                   }
[09:29:17.179]                 }, immediateCondition = function(cond) {
[09:29:17.179]                   save_rds <- function (object, pathname, ...) 
[09:29:17.179]                   {
[09:29:17.179]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:17.179]                     if (file_test("-f", pathname_tmp)) {
[09:29:17.179]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.179]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:17.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.179]                         fi_tmp[["mtime"]])
[09:29:17.179]                     }
[09:29:17.179]                     tryCatch({
[09:29:17.179]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:17.179]                     }, error = function(ex) {
[09:29:17.179]                       msg <- conditionMessage(ex)
[09:29:17.179]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.179]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:17.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.179]                         fi_tmp[["mtime"]], msg)
[09:29:17.179]                       ex$message <- msg
[09:29:17.179]                       stop(ex)
[09:29:17.179]                     })
[09:29:17.179]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:17.179]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:17.179]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:17.179]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.179]                       fi <- file.info(pathname)
[09:29:17.179]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:17.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.179]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:17.179]                         fi[["size"]], fi[["mtime"]])
[09:29:17.179]                       stop(msg)
[09:29:17.179]                     }
[09:29:17.179]                     invisible(pathname)
[09:29:17.179]                   }
[09:29:17.179]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:17.179]                     rootPath = tempdir()) 
[09:29:17.179]                   {
[09:29:17.179]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:17.179]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:17.179]                       tmpdir = path, fileext = ".rds")
[09:29:17.179]                     save_rds(obj, file)
[09:29:17.179]                   }
[09:29:17.179]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:17.179]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.179]                   {
[09:29:17.179]                     inherits <- base::inherits
[09:29:17.179]                     invokeRestart <- base::invokeRestart
[09:29:17.179]                     is.null <- base::is.null
[09:29:17.179]                     muffled <- FALSE
[09:29:17.179]                     if (inherits(cond, "message")) {
[09:29:17.179]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:17.179]                       if (muffled) 
[09:29:17.179]                         invokeRestart("muffleMessage")
[09:29:17.179]                     }
[09:29:17.179]                     else if (inherits(cond, "warning")) {
[09:29:17.179]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:17.179]                       if (muffled) 
[09:29:17.179]                         invokeRestart("muffleWarning")
[09:29:17.179]                     }
[09:29:17.179]                     else if (inherits(cond, "condition")) {
[09:29:17.179]                       if (!is.null(pattern)) {
[09:29:17.179]                         computeRestarts <- base::computeRestarts
[09:29:17.179]                         grepl <- base::grepl
[09:29:17.179]                         restarts <- computeRestarts(cond)
[09:29:17.179]                         for (restart in restarts) {
[09:29:17.179]                           name <- restart$name
[09:29:17.179]                           if (is.null(name)) 
[09:29:17.179]                             next
[09:29:17.179]                           if (!grepl(pattern, name)) 
[09:29:17.179]                             next
[09:29:17.179]                           invokeRestart(restart)
[09:29:17.179]                           muffled <- TRUE
[09:29:17.179]                           break
[09:29:17.179]                         }
[09:29:17.179]                       }
[09:29:17.179]                     }
[09:29:17.179]                     invisible(muffled)
[09:29:17.179]                   }
[09:29:17.179]                   muffleCondition(cond)
[09:29:17.179]                 })
[09:29:17.179]             }))
[09:29:17.179]             future::FutureResult(value = ...future.value$value, 
[09:29:17.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.179]                   ...future.rng), globalenv = if (FALSE) 
[09:29:17.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:17.179]                     ...future.globalenv.names))
[09:29:17.179]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:17.179]         }, condition = base::local({
[09:29:17.179]             c <- base::c
[09:29:17.179]             inherits <- base::inherits
[09:29:17.179]             invokeRestart <- base::invokeRestart
[09:29:17.179]             length <- base::length
[09:29:17.179]             list <- base::list
[09:29:17.179]             seq.int <- base::seq.int
[09:29:17.179]             signalCondition <- base::signalCondition
[09:29:17.179]             sys.calls <- base::sys.calls
[09:29:17.179]             `[[` <- base::`[[`
[09:29:17.179]             `+` <- base::`+`
[09:29:17.179]             `<<-` <- base::`<<-`
[09:29:17.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:17.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:17.179]                   3L)]
[09:29:17.179]             }
[09:29:17.179]             function(cond) {
[09:29:17.179]                 is_error <- inherits(cond, "error")
[09:29:17.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:17.179]                   NULL)
[09:29:17.179]                 if (is_error) {
[09:29:17.179]                   sessionInformation <- function() {
[09:29:17.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:17.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:17.179]                       search = base::search(), system = base::Sys.info())
[09:29:17.179]                   }
[09:29:17.179]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:17.179]                     cond$call), session = sessionInformation(), 
[09:29:17.179]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:17.179]                   signalCondition(cond)
[09:29:17.179]                 }
[09:29:17.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:17.179]                 "immediateCondition"))) {
[09:29:17.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:17.179]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:17.179]                   if (TRUE && !signal) {
[09:29:17.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.179]                     {
[09:29:17.179]                       inherits <- base::inherits
[09:29:17.179]                       invokeRestart <- base::invokeRestart
[09:29:17.179]                       is.null <- base::is.null
[09:29:17.179]                       muffled <- FALSE
[09:29:17.179]                       if (inherits(cond, "message")) {
[09:29:17.179]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.179]                         if (muffled) 
[09:29:17.179]                           invokeRestart("muffleMessage")
[09:29:17.179]                       }
[09:29:17.179]                       else if (inherits(cond, "warning")) {
[09:29:17.179]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.179]                         if (muffled) 
[09:29:17.179]                           invokeRestart("muffleWarning")
[09:29:17.179]                       }
[09:29:17.179]                       else if (inherits(cond, "condition")) {
[09:29:17.179]                         if (!is.null(pattern)) {
[09:29:17.179]                           computeRestarts <- base::computeRestarts
[09:29:17.179]                           grepl <- base::grepl
[09:29:17.179]                           restarts <- computeRestarts(cond)
[09:29:17.179]                           for (restart in restarts) {
[09:29:17.179]                             name <- restart$name
[09:29:17.179]                             if (is.null(name)) 
[09:29:17.179]                               next
[09:29:17.179]                             if (!grepl(pattern, name)) 
[09:29:17.179]                               next
[09:29:17.179]                             invokeRestart(restart)
[09:29:17.179]                             muffled <- TRUE
[09:29:17.179]                             break
[09:29:17.179]                           }
[09:29:17.179]                         }
[09:29:17.179]                       }
[09:29:17.179]                       invisible(muffled)
[09:29:17.179]                     }
[09:29:17.179]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.179]                   }
[09:29:17.179]                 }
[09:29:17.179]                 else {
[09:29:17.179]                   if (TRUE) {
[09:29:17.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.179]                     {
[09:29:17.179]                       inherits <- base::inherits
[09:29:17.179]                       invokeRestart <- base::invokeRestart
[09:29:17.179]                       is.null <- base::is.null
[09:29:17.179]                       muffled <- FALSE
[09:29:17.179]                       if (inherits(cond, "message")) {
[09:29:17.179]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.179]                         if (muffled) 
[09:29:17.179]                           invokeRestart("muffleMessage")
[09:29:17.179]                       }
[09:29:17.179]                       else if (inherits(cond, "warning")) {
[09:29:17.179]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.179]                         if (muffled) 
[09:29:17.179]                           invokeRestart("muffleWarning")
[09:29:17.179]                       }
[09:29:17.179]                       else if (inherits(cond, "condition")) {
[09:29:17.179]                         if (!is.null(pattern)) {
[09:29:17.179]                           computeRestarts <- base::computeRestarts
[09:29:17.179]                           grepl <- base::grepl
[09:29:17.179]                           restarts <- computeRestarts(cond)
[09:29:17.179]                           for (restart in restarts) {
[09:29:17.179]                             name <- restart$name
[09:29:17.179]                             if (is.null(name)) 
[09:29:17.179]                               next
[09:29:17.179]                             if (!grepl(pattern, name)) 
[09:29:17.179]                               next
[09:29:17.179]                             invokeRestart(restart)
[09:29:17.179]                             muffled <- TRUE
[09:29:17.179]                             break
[09:29:17.179]                           }
[09:29:17.179]                         }
[09:29:17.179]                       }
[09:29:17.179]                       invisible(muffled)
[09:29:17.179]                     }
[09:29:17.179]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.179]                   }
[09:29:17.179]                 }
[09:29:17.179]             }
[09:29:17.179]         }))
[09:29:17.179]     }, error = function(ex) {
[09:29:17.179]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:17.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.179]                 ...future.rng), started = ...future.startTime, 
[09:29:17.179]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:17.179]             version = "1.8"), class = "FutureResult")
[09:29:17.179]     }, finally = {
[09:29:17.179]         if (!identical(...future.workdir, getwd())) 
[09:29:17.179]             setwd(...future.workdir)
[09:29:17.179]         {
[09:29:17.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:17.179]                 ...future.oldOptions$nwarnings <- NULL
[09:29:17.179]             }
[09:29:17.179]             base::options(...future.oldOptions)
[09:29:17.179]             if (.Platform$OS.type == "windows") {
[09:29:17.179]                 old_names <- names(...future.oldEnvVars)
[09:29:17.179]                 envs <- base::Sys.getenv()
[09:29:17.179]                 names <- names(envs)
[09:29:17.179]                 common <- intersect(names, old_names)
[09:29:17.179]                 added <- setdiff(names, old_names)
[09:29:17.179]                 removed <- setdiff(old_names, names)
[09:29:17.179]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:17.179]                   envs[common]]
[09:29:17.179]                 NAMES <- toupper(changed)
[09:29:17.179]                 args <- list()
[09:29:17.179]                 for (kk in seq_along(NAMES)) {
[09:29:17.179]                   name <- changed[[kk]]
[09:29:17.179]                   NAME <- NAMES[[kk]]
[09:29:17.179]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.179]                     next
[09:29:17.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.179]                 }
[09:29:17.179]                 NAMES <- toupper(added)
[09:29:17.179]                 for (kk in seq_along(NAMES)) {
[09:29:17.179]                   name <- added[[kk]]
[09:29:17.179]                   NAME <- NAMES[[kk]]
[09:29:17.179]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.179]                     next
[09:29:17.179]                   args[[name]] <- ""
[09:29:17.179]                 }
[09:29:17.179]                 NAMES <- toupper(removed)
[09:29:17.179]                 for (kk in seq_along(NAMES)) {
[09:29:17.179]                   name <- removed[[kk]]
[09:29:17.179]                   NAME <- NAMES[[kk]]
[09:29:17.179]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.179]                     next
[09:29:17.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.179]                 }
[09:29:17.179]                 if (length(args) > 0) 
[09:29:17.179]                   base::do.call(base::Sys.setenv, args = args)
[09:29:17.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:17.179]             }
[09:29:17.179]             else {
[09:29:17.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:17.179]             }
[09:29:17.179]             {
[09:29:17.179]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:17.179]                   0L) {
[09:29:17.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:17.179]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:17.179]                   base::options(opts)
[09:29:17.179]                 }
[09:29:17.179]                 {
[09:29:17.179]                   {
[09:29:17.179]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:17.179]                     NULL
[09:29:17.179]                   }
[09:29:17.179]                   options(future.plan = NULL)
[09:29:17.179]                   if (is.na(NA_character_)) 
[09:29:17.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:17.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:17.179]                     .init = FALSE)
[09:29:17.179]                 }
[09:29:17.179]             }
[09:29:17.179]         }
[09:29:17.179]     })
[09:29:17.179]     if (TRUE) {
[09:29:17.179]         base::sink(type = "output", split = FALSE)
[09:29:17.179]         if (TRUE) {
[09:29:17.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:17.179]         }
[09:29:17.179]         else {
[09:29:17.179]             ...future.result["stdout"] <- base::list(NULL)
[09:29:17.179]         }
[09:29:17.179]         base::close(...future.stdout)
[09:29:17.179]         ...future.stdout <- NULL
[09:29:17.179]     }
[09:29:17.179]     ...future.result$conditions <- ...future.conditions
[09:29:17.179]     ...future.result$finished <- base::Sys.time()
[09:29:17.179]     ...future.result
[09:29:17.179] }
[09:29:17.182] assign_globals() ...
[09:29:17.182] List of 5
[09:29:17.182]  $ ...future.FUN            :function (x, ...)  
[09:29:17.182]  $ MoreArgs                 : NULL
[09:29:17.182]  $ ...future.elements_ii    :List of 2
[09:29:17.182]   ..$ :List of 2
[09:29:17.182]   .. ..$ : int 1
[09:29:17.182]   .. ..$ : int 2
[09:29:17.182]   ..$ :List of 2
[09:29:17.182]   .. ..$ : int 2
[09:29:17.182]   .. ..$ : int 1
[09:29:17.182]  $ ...future.seeds_ii       : NULL
[09:29:17.182]  $ ...future.globals.maxSize: NULL
[09:29:17.182]  - attr(*, "where")=List of 5
[09:29:17.182]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:17.182]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:17.182]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:17.182]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:17.182]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:17.182]  - attr(*, "resolved")= logi FALSE
[09:29:17.182]  - attr(*, "total_size")= num 280
[09:29:17.182]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.182]  - attr(*, "already-done")= logi TRUE
[09:29:17.189] - copied ‘...future.FUN’ to environment
[09:29:17.189] - copied ‘MoreArgs’ to environment
[09:29:17.189] - copied ‘...future.elements_ii’ to environment
[09:29:17.189] - copied ‘...future.seeds_ii’ to environment
[09:29:17.189] - copied ‘...future.globals.maxSize’ to environment
[09:29:17.189] assign_globals() ... done
[09:29:17.189] requestCore(): workers = 2
[09:29:17.191] MulticoreFuture started
[09:29:17.192] - Launch lazy future ... done
[09:29:17.192] run() for ‘MulticoreFuture’ ... done
[09:29:17.192] Created future:
[09:29:17.192] plan(): Setting new future strategy stack:
[09:29:17.193] List of future strategies:
[09:29:17.193] 1. sequential:
[09:29:17.193]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:17.193]    - tweaked: FALSE
[09:29:17.193]    - call: NULL
[09:29:17.194] plan(): nbrOfWorkers() = 1
[09:29:17.196] plan(): Setting new future strategy stack:
[09:29:17.196] List of future strategies:
[09:29:17.196] 1. multicore:
[09:29:17.196]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:17.196]    - tweaked: FALSE
[09:29:17.196]    - call: plan(strategy)
[09:29:17.192] MulticoreFuture:
[09:29:17.192] Label: ‘future_mapply-1’
[09:29:17.192] Expression:
[09:29:17.192] {
[09:29:17.192]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.192]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:17.192]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.192]         on.exit(options(oopts), add = TRUE)
[09:29:17.192]     }
[09:29:17.192]     {
[09:29:17.192]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.192]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:17.192]         do.call(mapply, args = args)
[09:29:17.192]     }
[09:29:17.192] }
[09:29:17.192] Lazy evaluation: FALSE
[09:29:17.192] Asynchronous evaluation: TRUE
[09:29:17.192] Local evaluation: TRUE
[09:29:17.192] Environment: R_GlobalEnv
[09:29:17.192] Capture standard output: TRUE
[09:29:17.192] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:17.192] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:17.192] Packages: <none>
[09:29:17.192] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:17.192] Resolved: FALSE
[09:29:17.192] Value: <not collected>
[09:29:17.192] Conditions captured: <none>
[09:29:17.192] Early signaling: FALSE
[09:29:17.192] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:17.192] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.205] Chunk #1 of 2 ... DONE
[09:29:17.205] Chunk #2 of 2 ...
[09:29:17.208] plan(): nbrOfWorkers() = 2
[09:29:17.209]  - Finding globals in '...' for chunk #2 ...
[09:29:17.209] getGlobalsAndPackages() ...
[09:29:17.209] Searching for globals...
[09:29:17.210] 
[09:29:17.210] Searching for globals ... DONE
[09:29:17.211] - globals: [0] <none>
[09:29:17.211] getGlobalsAndPackages() ... DONE
[09:29:17.211]    + additional globals found: [n=0] 
[09:29:17.211]    + additional namespaces needed: [n=0] 
[09:29:17.211]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:17.212]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:17.212]  - seeds: <none>
[09:29:17.212]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.212] getGlobalsAndPackages() ...
[09:29:17.213] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.213] Resolving globals: FALSE
[09:29:17.214] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:17.215] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:17.215] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.216] 
[09:29:17.216] getGlobalsAndPackages() ... DONE
[09:29:17.217] run() for ‘Future’ ...
[09:29:17.217] - state: ‘created’
[09:29:17.217] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:17.222] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.222] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:17.223]   - Field: ‘label’
[09:29:17.223]   - Field: ‘local’
[09:29:17.223]   - Field: ‘owner’
[09:29:17.223]   - Field: ‘envir’
[09:29:17.224]   - Field: ‘workers’
[09:29:17.224]   - Field: ‘packages’
[09:29:17.224]   - Field: ‘gc’
[09:29:17.224]   - Field: ‘job’
[09:29:17.224]   - Field: ‘conditions’
[09:29:17.224]   - Field: ‘expr’
[09:29:17.225]   - Field: ‘uuid’
[09:29:17.225]   - Field: ‘seed’
[09:29:17.225]   - Field: ‘version’
[09:29:17.225]   - Field: ‘result’
[09:29:17.225]   - Field: ‘asynchronous’
[09:29:17.226]   - Field: ‘calls’
[09:29:17.226]   - Field: ‘globals’
[09:29:17.226]   - Field: ‘stdout’
[09:29:17.226]   - Field: ‘earlySignal’
[09:29:17.226]   - Field: ‘lazy’
[09:29:17.226]   - Field: ‘state’
[09:29:17.226] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:17.226] - Launch lazy future ...
[09:29:17.227] Packages needed by the future expression (n = 0): <none>
[09:29:17.227] Packages needed by future strategies (n = 0): <none>
[09:29:17.227] {
[09:29:17.227]     {
[09:29:17.227]         {
[09:29:17.227]             ...future.startTime <- base::Sys.time()
[09:29:17.227]             {
[09:29:17.227]                 {
[09:29:17.227]                   {
[09:29:17.227]                     {
[09:29:17.227]                       base::local({
[09:29:17.227]                         has_future <- base::requireNamespace("future", 
[09:29:17.227]                           quietly = TRUE)
[09:29:17.227]                         if (has_future) {
[09:29:17.227]                           ns <- base::getNamespace("future")
[09:29:17.227]                           version <- ns[[".package"]][["version"]]
[09:29:17.227]                           if (is.null(version)) 
[09:29:17.227]                             version <- utils::packageVersion("future")
[09:29:17.227]                         }
[09:29:17.227]                         else {
[09:29:17.227]                           version <- NULL
[09:29:17.227]                         }
[09:29:17.227]                         if (!has_future || version < "1.8.0") {
[09:29:17.227]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:17.227]                             "", base::R.version$version.string), 
[09:29:17.227]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:17.227]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:17.227]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:17.227]                               "release", "version")], collapse = " "), 
[09:29:17.227]                             hostname = base::Sys.info()[["nodename"]])
[09:29:17.227]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:17.227]                             info)
[09:29:17.227]                           info <- base::paste(info, collapse = "; ")
[09:29:17.227]                           if (!has_future) {
[09:29:17.227]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:17.227]                               info)
[09:29:17.227]                           }
[09:29:17.227]                           else {
[09:29:17.227]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:17.227]                               info, version)
[09:29:17.227]                           }
[09:29:17.227]                           base::stop(msg)
[09:29:17.227]                         }
[09:29:17.227]                       })
[09:29:17.227]                     }
[09:29:17.227]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:17.227]                     base::options(mc.cores = 1L)
[09:29:17.227]                   }
[09:29:17.227]                   ...future.strategy.old <- future::plan("list")
[09:29:17.227]                   options(future.plan = NULL)
[09:29:17.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:17.227]                 }
[09:29:17.227]                 ...future.workdir <- getwd()
[09:29:17.227]             }
[09:29:17.227]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:17.227]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:17.227]         }
[09:29:17.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:17.227]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:17.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:17.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:17.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:17.227]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:17.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:17.227]             base::names(...future.oldOptions))
[09:29:17.227]     }
[09:29:17.227]     if (FALSE) {
[09:29:17.227]     }
[09:29:17.227]     else {
[09:29:17.227]         if (TRUE) {
[09:29:17.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:17.227]                 open = "w")
[09:29:17.227]         }
[09:29:17.227]         else {
[09:29:17.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:17.227]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:17.227]         }
[09:29:17.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:17.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:17.227]             base::sink(type = "output", split = FALSE)
[09:29:17.227]             base::close(...future.stdout)
[09:29:17.227]         }, add = TRUE)
[09:29:17.227]     }
[09:29:17.227]     ...future.frame <- base::sys.nframe()
[09:29:17.227]     ...future.conditions <- base::list()
[09:29:17.227]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:17.227]     if (FALSE) {
[09:29:17.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:17.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:17.227]     }
[09:29:17.227]     ...future.result <- base::tryCatch({
[09:29:17.227]         base::withCallingHandlers({
[09:29:17.227]             ...future.value <- base::withVisible(base::local({
[09:29:17.227]                 withCallingHandlers({
[09:29:17.227]                   {
[09:29:17.227]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.227]                     if (!identical(...future.globals.maxSize.org, 
[09:29:17.227]                       ...future.globals.maxSize)) {
[09:29:17.227]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.227]                       on.exit(options(oopts), add = TRUE)
[09:29:17.227]                     }
[09:29:17.227]                     {
[09:29:17.227]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.227]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:17.227]                         USE.NAMES = FALSE)
[09:29:17.227]                       do.call(mapply, args = args)
[09:29:17.227]                     }
[09:29:17.227]                   }
[09:29:17.227]                 }, immediateCondition = function(cond) {
[09:29:17.227]                   save_rds <- function (object, pathname, ...) 
[09:29:17.227]                   {
[09:29:17.227]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:17.227]                     if (file_test("-f", pathname_tmp)) {
[09:29:17.227]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.227]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:17.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.227]                         fi_tmp[["mtime"]])
[09:29:17.227]                     }
[09:29:17.227]                     tryCatch({
[09:29:17.227]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:17.227]                     }, error = function(ex) {
[09:29:17.227]                       msg <- conditionMessage(ex)
[09:29:17.227]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.227]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:17.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.227]                         fi_tmp[["mtime"]], msg)
[09:29:17.227]                       ex$message <- msg
[09:29:17.227]                       stop(ex)
[09:29:17.227]                     })
[09:29:17.227]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:17.227]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:17.227]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:17.227]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.227]                       fi <- file.info(pathname)
[09:29:17.227]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:17.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.227]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:17.227]                         fi[["size"]], fi[["mtime"]])
[09:29:17.227]                       stop(msg)
[09:29:17.227]                     }
[09:29:17.227]                     invisible(pathname)
[09:29:17.227]                   }
[09:29:17.227]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:17.227]                     rootPath = tempdir()) 
[09:29:17.227]                   {
[09:29:17.227]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:17.227]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:17.227]                       tmpdir = path, fileext = ".rds")
[09:29:17.227]                     save_rds(obj, file)
[09:29:17.227]                   }
[09:29:17.227]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:17.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.227]                   {
[09:29:17.227]                     inherits <- base::inherits
[09:29:17.227]                     invokeRestart <- base::invokeRestart
[09:29:17.227]                     is.null <- base::is.null
[09:29:17.227]                     muffled <- FALSE
[09:29:17.227]                     if (inherits(cond, "message")) {
[09:29:17.227]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:17.227]                       if (muffled) 
[09:29:17.227]                         invokeRestart("muffleMessage")
[09:29:17.227]                     }
[09:29:17.227]                     else if (inherits(cond, "warning")) {
[09:29:17.227]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:17.227]                       if (muffled) 
[09:29:17.227]                         invokeRestart("muffleWarning")
[09:29:17.227]                     }
[09:29:17.227]                     else if (inherits(cond, "condition")) {
[09:29:17.227]                       if (!is.null(pattern)) {
[09:29:17.227]                         computeRestarts <- base::computeRestarts
[09:29:17.227]                         grepl <- base::grepl
[09:29:17.227]                         restarts <- computeRestarts(cond)
[09:29:17.227]                         for (restart in restarts) {
[09:29:17.227]                           name <- restart$name
[09:29:17.227]                           if (is.null(name)) 
[09:29:17.227]                             next
[09:29:17.227]                           if (!grepl(pattern, name)) 
[09:29:17.227]                             next
[09:29:17.227]                           invokeRestart(restart)
[09:29:17.227]                           muffled <- TRUE
[09:29:17.227]                           break
[09:29:17.227]                         }
[09:29:17.227]                       }
[09:29:17.227]                     }
[09:29:17.227]                     invisible(muffled)
[09:29:17.227]                   }
[09:29:17.227]                   muffleCondition(cond)
[09:29:17.227]                 })
[09:29:17.227]             }))
[09:29:17.227]             future::FutureResult(value = ...future.value$value, 
[09:29:17.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.227]                   ...future.rng), globalenv = if (FALSE) 
[09:29:17.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:17.227]                     ...future.globalenv.names))
[09:29:17.227]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:17.227]         }, condition = base::local({
[09:29:17.227]             c <- base::c
[09:29:17.227]             inherits <- base::inherits
[09:29:17.227]             invokeRestart <- base::invokeRestart
[09:29:17.227]             length <- base::length
[09:29:17.227]             list <- base::list
[09:29:17.227]             seq.int <- base::seq.int
[09:29:17.227]             signalCondition <- base::signalCondition
[09:29:17.227]             sys.calls <- base::sys.calls
[09:29:17.227]             `[[` <- base::`[[`
[09:29:17.227]             `+` <- base::`+`
[09:29:17.227]             `<<-` <- base::`<<-`
[09:29:17.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:17.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:17.227]                   3L)]
[09:29:17.227]             }
[09:29:17.227]             function(cond) {
[09:29:17.227]                 is_error <- inherits(cond, "error")
[09:29:17.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:17.227]                   NULL)
[09:29:17.227]                 if (is_error) {
[09:29:17.227]                   sessionInformation <- function() {
[09:29:17.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:17.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:17.227]                       search = base::search(), system = base::Sys.info())
[09:29:17.227]                   }
[09:29:17.227]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:17.227]                     cond$call), session = sessionInformation(), 
[09:29:17.227]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:17.227]                   signalCondition(cond)
[09:29:17.227]                 }
[09:29:17.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:17.227]                 "immediateCondition"))) {
[09:29:17.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:17.227]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:17.227]                   if (TRUE && !signal) {
[09:29:17.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.227]                     {
[09:29:17.227]                       inherits <- base::inherits
[09:29:17.227]                       invokeRestart <- base::invokeRestart
[09:29:17.227]                       is.null <- base::is.null
[09:29:17.227]                       muffled <- FALSE
[09:29:17.227]                       if (inherits(cond, "message")) {
[09:29:17.227]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.227]                         if (muffled) 
[09:29:17.227]                           invokeRestart("muffleMessage")
[09:29:17.227]                       }
[09:29:17.227]                       else if (inherits(cond, "warning")) {
[09:29:17.227]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.227]                         if (muffled) 
[09:29:17.227]                           invokeRestart("muffleWarning")
[09:29:17.227]                       }
[09:29:17.227]                       else if (inherits(cond, "condition")) {
[09:29:17.227]                         if (!is.null(pattern)) {
[09:29:17.227]                           computeRestarts <- base::computeRestarts
[09:29:17.227]                           grepl <- base::grepl
[09:29:17.227]                           restarts <- computeRestarts(cond)
[09:29:17.227]                           for (restart in restarts) {
[09:29:17.227]                             name <- restart$name
[09:29:17.227]                             if (is.null(name)) 
[09:29:17.227]                               next
[09:29:17.227]                             if (!grepl(pattern, name)) 
[09:29:17.227]                               next
[09:29:17.227]                             invokeRestart(restart)
[09:29:17.227]                             muffled <- TRUE
[09:29:17.227]                             break
[09:29:17.227]                           }
[09:29:17.227]                         }
[09:29:17.227]                       }
[09:29:17.227]                       invisible(muffled)
[09:29:17.227]                     }
[09:29:17.227]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.227]                   }
[09:29:17.227]                 }
[09:29:17.227]                 else {
[09:29:17.227]                   if (TRUE) {
[09:29:17.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.227]                     {
[09:29:17.227]                       inherits <- base::inherits
[09:29:17.227]                       invokeRestart <- base::invokeRestart
[09:29:17.227]                       is.null <- base::is.null
[09:29:17.227]                       muffled <- FALSE
[09:29:17.227]                       if (inherits(cond, "message")) {
[09:29:17.227]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.227]                         if (muffled) 
[09:29:17.227]                           invokeRestart("muffleMessage")
[09:29:17.227]                       }
[09:29:17.227]                       else if (inherits(cond, "warning")) {
[09:29:17.227]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.227]                         if (muffled) 
[09:29:17.227]                           invokeRestart("muffleWarning")
[09:29:17.227]                       }
[09:29:17.227]                       else if (inherits(cond, "condition")) {
[09:29:17.227]                         if (!is.null(pattern)) {
[09:29:17.227]                           computeRestarts <- base::computeRestarts
[09:29:17.227]                           grepl <- base::grepl
[09:29:17.227]                           restarts <- computeRestarts(cond)
[09:29:17.227]                           for (restart in restarts) {
[09:29:17.227]                             name <- restart$name
[09:29:17.227]                             if (is.null(name)) 
[09:29:17.227]                               next
[09:29:17.227]                             if (!grepl(pattern, name)) 
[09:29:17.227]                               next
[09:29:17.227]                             invokeRestart(restart)
[09:29:17.227]                             muffled <- TRUE
[09:29:17.227]                             break
[09:29:17.227]                           }
[09:29:17.227]                         }
[09:29:17.227]                       }
[09:29:17.227]                       invisible(muffled)
[09:29:17.227]                     }
[09:29:17.227]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.227]                   }
[09:29:17.227]                 }
[09:29:17.227]             }
[09:29:17.227]         }))
[09:29:17.227]     }, error = function(ex) {
[09:29:17.227]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:17.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.227]                 ...future.rng), started = ...future.startTime, 
[09:29:17.227]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:17.227]             version = "1.8"), class = "FutureResult")
[09:29:17.227]     }, finally = {
[09:29:17.227]         if (!identical(...future.workdir, getwd())) 
[09:29:17.227]             setwd(...future.workdir)
[09:29:17.227]         {
[09:29:17.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:17.227]                 ...future.oldOptions$nwarnings <- NULL
[09:29:17.227]             }
[09:29:17.227]             base::options(...future.oldOptions)
[09:29:17.227]             if (.Platform$OS.type == "windows") {
[09:29:17.227]                 old_names <- names(...future.oldEnvVars)
[09:29:17.227]                 envs <- base::Sys.getenv()
[09:29:17.227]                 names <- names(envs)
[09:29:17.227]                 common <- intersect(names, old_names)
[09:29:17.227]                 added <- setdiff(names, old_names)
[09:29:17.227]                 removed <- setdiff(old_names, names)
[09:29:17.227]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:17.227]                   envs[common]]
[09:29:17.227]                 NAMES <- toupper(changed)
[09:29:17.227]                 args <- list()
[09:29:17.227]                 for (kk in seq_along(NAMES)) {
[09:29:17.227]                   name <- changed[[kk]]
[09:29:17.227]                   NAME <- NAMES[[kk]]
[09:29:17.227]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.227]                     next
[09:29:17.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.227]                 }
[09:29:17.227]                 NAMES <- toupper(added)
[09:29:17.227]                 for (kk in seq_along(NAMES)) {
[09:29:17.227]                   name <- added[[kk]]
[09:29:17.227]                   NAME <- NAMES[[kk]]
[09:29:17.227]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.227]                     next
[09:29:17.227]                   args[[name]] <- ""
[09:29:17.227]                 }
[09:29:17.227]                 NAMES <- toupper(removed)
[09:29:17.227]                 for (kk in seq_along(NAMES)) {
[09:29:17.227]                   name <- removed[[kk]]
[09:29:17.227]                   NAME <- NAMES[[kk]]
[09:29:17.227]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.227]                     next
[09:29:17.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.227]                 }
[09:29:17.227]                 if (length(args) > 0) 
[09:29:17.227]                   base::do.call(base::Sys.setenv, args = args)
[09:29:17.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:17.227]             }
[09:29:17.227]             else {
[09:29:17.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:17.227]             }
[09:29:17.227]             {
[09:29:17.227]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:17.227]                   0L) {
[09:29:17.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:17.227]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:17.227]                   base::options(opts)
[09:29:17.227]                 }
[09:29:17.227]                 {
[09:29:17.227]                   {
[09:29:17.227]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:17.227]                     NULL
[09:29:17.227]                   }
[09:29:17.227]                   options(future.plan = NULL)
[09:29:17.227]                   if (is.na(NA_character_)) 
[09:29:17.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:17.227]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:17.227]                     .init = FALSE)
[09:29:17.227]                 }
[09:29:17.227]             }
[09:29:17.227]         }
[09:29:17.227]     })
[09:29:17.227]     if (TRUE) {
[09:29:17.227]         base::sink(type = "output", split = FALSE)
[09:29:17.227]         if (TRUE) {
[09:29:17.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:17.227]         }
[09:29:17.227]         else {
[09:29:17.227]             ...future.result["stdout"] <- base::list(NULL)
[09:29:17.227]         }
[09:29:17.227]         base::close(...future.stdout)
[09:29:17.227]         ...future.stdout <- NULL
[09:29:17.227]     }
[09:29:17.227]     ...future.result$conditions <- ...future.conditions
[09:29:17.227]     ...future.result$finished <- base::Sys.time()
[09:29:17.227]     ...future.result
[09:29:17.227] }
[09:29:17.230] assign_globals() ...
[09:29:17.231] List of 5
[09:29:17.231]  $ ...future.FUN            :function (x, ...)  
[09:29:17.231]  $ MoreArgs                 : NULL
[09:29:17.231]  $ ...future.elements_ii    :List of 2
[09:29:17.231]   ..$ :List of 2
[09:29:17.231]   .. ..$ : int 3
[09:29:17.231]   .. ..$ : int 4
[09:29:17.231]   ..$ :List of 2
[09:29:17.231]   .. ..$ : int 2
[09:29:17.231]   .. ..$ : int 1
[09:29:17.231]  $ ...future.seeds_ii       : NULL
[09:29:17.231]  $ ...future.globals.maxSize: NULL
[09:29:17.231]  - attr(*, "where")=List of 5
[09:29:17.231]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:17.231]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:17.231]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:17.231]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:17.231]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:17.231]  - attr(*, "resolved")= logi FALSE
[09:29:17.231]  - attr(*, "total_size")= num 280
[09:29:17.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.231]  - attr(*, "already-done")= logi TRUE
[09:29:17.238] - copied ‘...future.FUN’ to environment
[09:29:17.238] - copied ‘MoreArgs’ to environment
[09:29:17.238] - copied ‘...future.elements_ii’ to environment
[09:29:17.238] - copied ‘...future.seeds_ii’ to environment
[09:29:17.238] - copied ‘...future.globals.maxSize’ to environment
[09:29:17.238] assign_globals() ... done
[09:29:17.238] requestCore(): workers = 2
[09:29:17.240] MulticoreFuture started
[09:29:17.241] - Launch lazy future ... done
[09:29:17.241] run() for ‘MulticoreFuture’ ... done
[09:29:17.241] Created future:
[09:29:17.241] plan(): Setting new future strategy stack:
[09:29:17.242] List of future strategies:
[09:29:17.242] 1. sequential:
[09:29:17.242]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:17.242]    - tweaked: FALSE
[09:29:17.242]    - call: NULL
[09:29:17.243] plan(): nbrOfWorkers() = 1
[09:29:17.245] plan(): Setting new future strategy stack:
[09:29:17.245] List of future strategies:
[09:29:17.245] 1. multicore:
[09:29:17.245]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:17.245]    - tweaked: FALSE
[09:29:17.245]    - call: plan(strategy)
[09:29:17.250] plan(): nbrOfWorkers() = 2
[09:29:17.241] MulticoreFuture:
[09:29:17.241] Label: ‘future_mapply-2’
[09:29:17.241] Expression:
[09:29:17.241] {
[09:29:17.241]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.241]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:17.241]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.241]         on.exit(options(oopts), add = TRUE)
[09:29:17.241]     }
[09:29:17.241]     {
[09:29:17.241]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.241]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:17.241]         do.call(mapply, args = args)
[09:29:17.241]     }
[09:29:17.241] }
[09:29:17.241] Lazy evaluation: FALSE
[09:29:17.241] Asynchronous evaluation: TRUE
[09:29:17.241] Local evaluation: TRUE
[09:29:17.241] Environment: R_GlobalEnv
[09:29:17.241] Capture standard output: TRUE
[09:29:17.241] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:17.241] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:17.241] Packages: <none>
[09:29:17.241] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:17.241] Resolved: TRUE
[09:29:17.241] Value: <not collected>
[09:29:17.241] Conditions captured: <none>
[09:29:17.241] Early signaling: FALSE
[09:29:17.241] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:17.241] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.251] Chunk #2 of 2 ... DONE
[09:29:17.251] Launching 2 futures (chunks) ... DONE
[09:29:17.251] Resolving 2 futures (chunks) ...
[09:29:17.252] resolve() on list ...
[09:29:17.252]  recursive: 0
[09:29:17.252]  length: 2
[09:29:17.252] 
[09:29:17.252] Future #1
[09:29:17.253] result() for MulticoreFuture ...
[09:29:17.253] result() for MulticoreFuture ...
[09:29:17.254] result() for MulticoreFuture ... done
[09:29:17.254] result() for MulticoreFuture ... done
[09:29:17.254] result() for MulticoreFuture ...
[09:29:17.254] result() for MulticoreFuture ... done
[09:29:17.254] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:17.254] - nx: 2
[09:29:17.255] - relay: TRUE
[09:29:17.255] - stdout: TRUE
[09:29:17.255] - signal: TRUE
[09:29:17.255] - resignal: FALSE
[09:29:17.259] - force: TRUE
[09:29:17.259] - relayed: [n=2] FALSE, FALSE
[09:29:17.260] - queued futures: [n=2] FALSE, FALSE
[09:29:17.260]  - until=1
[09:29:17.260]  - relaying element #1
[09:29:17.261] result() for MulticoreFuture ...
[09:29:17.261] result() for MulticoreFuture ... done
[09:29:17.261] result() for MulticoreFuture ...
[09:29:17.262] result() for MulticoreFuture ... done
[09:29:17.262] result() for MulticoreFuture ...
[09:29:17.262] result() for MulticoreFuture ... done
[09:29:17.263] result() for MulticoreFuture ...
[09:29:17.263] result() for MulticoreFuture ... done
[09:29:17.263] - relayed: [n=2] TRUE, FALSE
[09:29:17.263] - queued futures: [n=2] TRUE, FALSE
[09:29:17.264] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:17.264]  length: 1 (resolved future 1)
[09:29:17.264] Future #2
[09:29:17.265] result() for MulticoreFuture ...
[09:29:17.266] result() for MulticoreFuture ...
[09:29:17.266] result() for MulticoreFuture ... done
[09:29:17.266] result() for MulticoreFuture ... done
[09:29:17.266] result() for MulticoreFuture ...
[09:29:17.267] result() for MulticoreFuture ... done
[09:29:17.267] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:17.267] - nx: 2
[09:29:17.267] - relay: TRUE
[09:29:17.267] - stdout: TRUE
[09:29:17.267] - signal: TRUE
[09:29:17.268] - resignal: FALSE
[09:29:17.268] - force: TRUE
[09:29:17.268] - relayed: [n=2] TRUE, FALSE
[09:29:17.268] - queued futures: [n=2] TRUE, FALSE
[09:29:17.268]  - until=2
[09:29:17.268]  - relaying element #2
[09:29:17.269] result() for MulticoreFuture ...
[09:29:17.269] result() for MulticoreFuture ... done
[09:29:17.269] result() for MulticoreFuture ...
[09:29:17.269] result() for MulticoreFuture ... done
[09:29:17.269] result() for MulticoreFuture ...
[09:29:17.269] result() for MulticoreFuture ... done
[09:29:17.269] result() for MulticoreFuture ...
[09:29:17.270] result() for MulticoreFuture ... done
[09:29:17.270] - relayed: [n=2] TRUE, TRUE
[09:29:17.270] - queued futures: [n=2] TRUE, TRUE
[09:29:17.270] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:17.270]  length: 0 (resolved future 2)
[09:29:17.270] Relaying remaining futures
[09:29:17.270] signalConditionsASAP(NULL, pos=0) ...
[09:29:17.271] - nx: 2
[09:29:17.271] - relay: TRUE
[09:29:17.271] - stdout: TRUE
[09:29:17.271] - signal: TRUE
[09:29:17.271] - resignal: FALSE
[09:29:17.271] - force: TRUE
[09:29:17.271] - relayed: [n=2] TRUE, TRUE
[09:29:17.271] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:17.272] - relayed: [n=2] TRUE, TRUE
[09:29:17.272] - queued futures: [n=2] TRUE, TRUE
[09:29:17.272] signalConditionsASAP(NULL, pos=0) ... done
[09:29:17.272] resolve() on list ... DONE
[09:29:17.272] result() for MulticoreFuture ...
[09:29:17.272] result() for MulticoreFuture ... done
[09:29:17.272] result() for MulticoreFuture ...
[09:29:17.272] result() for MulticoreFuture ... done
[09:29:17.273] result() for MulticoreFuture ...
[09:29:17.273] result() for MulticoreFuture ... done
[09:29:17.273] result() for MulticoreFuture ...
[09:29:17.273] result() for MulticoreFuture ... done
[09:29:17.273]  - Number of value chunks collected: 2
[09:29:17.273] Resolving 2 futures (chunks) ... DONE
[09:29:17.273] Reducing values from 2 chunks ...
[09:29:17.273]  - Number of values collected after concatenation: 4
[09:29:17.273]  - Number of values expected: 4
[09:29:17.273] Reducing values from 2 chunks ... DONE
[09:29:17.274] future_mapply() ... DONE
- Parallel RNG ...
[09:29:17.274] future_mapply() ...
[09:29:17.274] Generating random seeds ...
[09:29:17.274] Generating random seed streams for 4 elements ...
[09:29:17.274] Generating random seed streams for 4 elements ... DONE
[09:29:17.274] Generating random seeds ... DONE
[09:29:17.275] Will set RNG state on exit: 10407, -44194677, 892458082, -2112804121, -782412261, -480336667, -1357845984
[09:29:17.278] Number of chunks: 2
[09:29:17.279] getGlobalsAndPackagesXApply() ...
[09:29:17.279]  - future.globals: TRUE
[09:29:17.279] getGlobalsAndPackages() ...
[09:29:17.279] Searching for globals...
[09:29:17.280] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[09:29:17.281] Searching for globals ... DONE
[09:29:17.281] Resolving globals: FALSE
[09:29:17.281] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[09:29:17.282] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[09:29:17.282] - globals: [1] ‘FUN’
[09:29:17.282] - packages: [1] ‘stats’
[09:29:17.282] getGlobalsAndPackages() ... DONE
[09:29:17.282]  - globals found/used: [n=1] ‘FUN’
[09:29:17.282]  - needed namespaces: [n=1] ‘stats’
[09:29:17.282] Finding globals ... DONE
[09:29:17.282] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:17.283] List of 2
[09:29:17.283]  $ ...future.FUN:function (n, min = 0, max = 1)  
[09:29:17.283]  $ MoreArgs     :List of 1
[09:29:17.283]   ..$ min: num 1
[09:29:17.283]  - attr(*, "where")=List of 2
[09:29:17.283]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:17.283]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:17.283]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.283]  - attr(*, "resolved")= logi FALSE
[09:29:17.283]  - attr(*, "total_size")= num NA
[09:29:17.286] Packages to be attached in all futures: [n=1] ‘stats’
[09:29:17.286] getGlobalsAndPackagesXApply() ... DONE
[09:29:17.286] Number of futures (= number of chunks): 2
[09:29:17.286] Launching 2 futures (chunks) ...
[09:29:17.286] Chunk #1 of 2 ...
[09:29:17.286]  - Finding globals in '...' for chunk #1 ...
[09:29:17.286] getGlobalsAndPackages() ...
[09:29:17.286] Searching for globals...
[09:29:17.287] 
[09:29:17.287] Searching for globals ... DONE
[09:29:17.287] - globals: [0] <none>
[09:29:17.287] getGlobalsAndPackages() ... DONE
[09:29:17.287]    + additional globals found: [n=0] 
[09:29:17.287]    + additional namespaces needed: [n=0] 
[09:29:17.287]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:17.287]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:17.287]  - seeds: [2] <seeds>
[09:29:17.288]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.288] getGlobalsAndPackages() ...
[09:29:17.288] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.290] Resolving globals: FALSE
[09:29:17.291] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[09:29:17.291] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[09:29:17.291] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.292] - packages: [1] ‘stats’
[09:29:17.292] getGlobalsAndPackages() ... DONE
[09:29:17.292] run() for ‘Future’ ...
[09:29:17.292] - state: ‘created’
[09:29:17.292] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:17.296] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.296] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:17.296]   - Field: ‘label’
[09:29:17.296]   - Field: ‘local’
[09:29:17.296]   - Field: ‘owner’
[09:29:17.296]   - Field: ‘envir’
[09:29:17.297]   - Field: ‘workers’
[09:29:17.297]   - Field: ‘packages’
[09:29:17.297]   - Field: ‘gc’
[09:29:17.297]   - Field: ‘job’
[09:29:17.297]   - Field: ‘conditions’
[09:29:17.297]   - Field: ‘expr’
[09:29:17.297]   - Field: ‘uuid’
[09:29:17.297]   - Field: ‘seed’
[09:29:17.297]   - Field: ‘version’
[09:29:17.297]   - Field: ‘result’
[09:29:17.298]   - Field: ‘asynchronous’
[09:29:17.298]   - Field: ‘calls’
[09:29:17.298]   - Field: ‘globals’
[09:29:17.298]   - Field: ‘stdout’
[09:29:17.298]   - Field: ‘earlySignal’
[09:29:17.298]   - Field: ‘lazy’
[09:29:17.298]   - Field: ‘state’
[09:29:17.298] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:17.298] - Launch lazy future ...
[09:29:17.299] Packages needed by the future expression (n = 1): ‘stats’
[09:29:17.299] Packages needed by future strategies (n = 0): <none>
[09:29:17.299] {
[09:29:17.299]     {
[09:29:17.299]         {
[09:29:17.299]             ...future.startTime <- base::Sys.time()
[09:29:17.299]             {
[09:29:17.299]                 {
[09:29:17.299]                   {
[09:29:17.299]                     {
[09:29:17.299]                       {
[09:29:17.299]                         base::local({
[09:29:17.299]                           has_future <- base::requireNamespace("future", 
[09:29:17.299]                             quietly = TRUE)
[09:29:17.299]                           if (has_future) {
[09:29:17.299]                             ns <- base::getNamespace("future")
[09:29:17.299]                             version <- ns[[".package"]][["version"]]
[09:29:17.299]                             if (is.null(version)) 
[09:29:17.299]                               version <- utils::packageVersion("future")
[09:29:17.299]                           }
[09:29:17.299]                           else {
[09:29:17.299]                             version <- NULL
[09:29:17.299]                           }
[09:29:17.299]                           if (!has_future || version < "1.8.0") {
[09:29:17.299]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:17.299]                               "", base::R.version$version.string), 
[09:29:17.299]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:17.299]                                 base::R.version$platform, 8 * 
[09:29:17.299]                                   base::.Machine$sizeof.pointer), 
[09:29:17.299]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:17.299]                                 "release", "version")], collapse = " "), 
[09:29:17.299]                               hostname = base::Sys.info()[["nodename"]])
[09:29:17.299]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:17.299]                               info)
[09:29:17.299]                             info <- base::paste(info, collapse = "; ")
[09:29:17.299]                             if (!has_future) {
[09:29:17.299]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:17.299]                                 info)
[09:29:17.299]                             }
[09:29:17.299]                             else {
[09:29:17.299]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:17.299]                                 info, version)
[09:29:17.299]                             }
[09:29:17.299]                             base::stop(msg)
[09:29:17.299]                           }
[09:29:17.299]                         })
[09:29:17.299]                       }
[09:29:17.299]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:17.299]                       base::options(mc.cores = 1L)
[09:29:17.299]                     }
[09:29:17.299]                     base::local({
[09:29:17.299]                       for (pkg in "stats") {
[09:29:17.299]                         base::loadNamespace(pkg)
[09:29:17.299]                         base::library(pkg, character.only = TRUE)
[09:29:17.299]                       }
[09:29:17.299]                     })
[09:29:17.299]                   }
[09:29:17.299]                   ...future.strategy.old <- future::plan("list")
[09:29:17.299]                   options(future.plan = NULL)
[09:29:17.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:17.299]                 }
[09:29:17.299]                 ...future.workdir <- getwd()
[09:29:17.299]             }
[09:29:17.299]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:17.299]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:17.299]         }
[09:29:17.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:17.299]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:17.299]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:17.299]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:17.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:17.299]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:17.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:17.299]             base::names(...future.oldOptions))
[09:29:17.299]     }
[09:29:17.299]     if (FALSE) {
[09:29:17.299]     }
[09:29:17.299]     else {
[09:29:17.299]         if (TRUE) {
[09:29:17.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:17.299]                 open = "w")
[09:29:17.299]         }
[09:29:17.299]         else {
[09:29:17.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:17.299]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:17.299]         }
[09:29:17.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:17.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:17.299]             base::sink(type = "output", split = FALSE)
[09:29:17.299]             base::close(...future.stdout)
[09:29:17.299]         }, add = TRUE)
[09:29:17.299]     }
[09:29:17.299]     ...future.frame <- base::sys.nframe()
[09:29:17.299]     ...future.conditions <- base::list()
[09:29:17.299]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:17.299]     if (FALSE) {
[09:29:17.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:17.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:17.299]     }
[09:29:17.299]     ...future.result <- base::tryCatch({
[09:29:17.299]         base::withCallingHandlers({
[09:29:17.299]             ...future.value <- base::withVisible(base::local({
[09:29:17.299]                 withCallingHandlers({
[09:29:17.299]                   {
[09:29:17.299]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.299]                     if (!identical(...future.globals.maxSize.org, 
[09:29:17.299]                       ...future.globals.maxSize)) {
[09:29:17.299]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.299]                       on.exit(options(oopts), add = TRUE)
[09:29:17.299]                     }
[09:29:17.299]                     {
[09:29:17.299]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:17.299]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[09:29:17.299]                           envir = globalenv(), inherits = FALSE)
[09:29:17.299]                         ...future.FUN(...)
[09:29:17.299]                       }
[09:29:17.299]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:17.299]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:17.299]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:17.299]                         USE.NAMES = FALSE)
[09:29:17.299]                       do.call(mapply, args = args)
[09:29:17.299]                     }
[09:29:17.299]                   }
[09:29:17.299]                 }, immediateCondition = function(cond) {
[09:29:17.299]                   save_rds <- function (object, pathname, ...) 
[09:29:17.299]                   {
[09:29:17.299]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:17.299]                     if (file_test("-f", pathname_tmp)) {
[09:29:17.299]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.299]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:17.299]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.299]                         fi_tmp[["mtime"]])
[09:29:17.299]                     }
[09:29:17.299]                     tryCatch({
[09:29:17.299]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:17.299]                     }, error = function(ex) {
[09:29:17.299]                       msg <- conditionMessage(ex)
[09:29:17.299]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.299]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:17.299]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.299]                         fi_tmp[["mtime"]], msg)
[09:29:17.299]                       ex$message <- msg
[09:29:17.299]                       stop(ex)
[09:29:17.299]                     })
[09:29:17.299]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:17.299]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:17.299]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:17.299]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.299]                       fi <- file.info(pathname)
[09:29:17.299]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:17.299]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.299]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:17.299]                         fi[["size"]], fi[["mtime"]])
[09:29:17.299]                       stop(msg)
[09:29:17.299]                     }
[09:29:17.299]                     invisible(pathname)
[09:29:17.299]                   }
[09:29:17.299]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:17.299]                     rootPath = tempdir()) 
[09:29:17.299]                   {
[09:29:17.299]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:17.299]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:17.299]                       tmpdir = path, fileext = ".rds")
[09:29:17.299]                     save_rds(obj, file)
[09:29:17.299]                   }
[09:29:17.299]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:17.299]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.299]                   {
[09:29:17.299]                     inherits <- base::inherits
[09:29:17.299]                     invokeRestart <- base::invokeRestart
[09:29:17.299]                     is.null <- base::is.null
[09:29:17.299]                     muffled <- FALSE
[09:29:17.299]                     if (inherits(cond, "message")) {
[09:29:17.299]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:17.299]                       if (muffled) 
[09:29:17.299]                         invokeRestart("muffleMessage")
[09:29:17.299]                     }
[09:29:17.299]                     else if (inherits(cond, "warning")) {
[09:29:17.299]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:17.299]                       if (muffled) 
[09:29:17.299]                         invokeRestart("muffleWarning")
[09:29:17.299]                     }
[09:29:17.299]                     else if (inherits(cond, "condition")) {
[09:29:17.299]                       if (!is.null(pattern)) {
[09:29:17.299]                         computeRestarts <- base::computeRestarts
[09:29:17.299]                         grepl <- base::grepl
[09:29:17.299]                         restarts <- computeRestarts(cond)
[09:29:17.299]                         for (restart in restarts) {
[09:29:17.299]                           name <- restart$name
[09:29:17.299]                           if (is.null(name)) 
[09:29:17.299]                             next
[09:29:17.299]                           if (!grepl(pattern, name)) 
[09:29:17.299]                             next
[09:29:17.299]                           invokeRestart(restart)
[09:29:17.299]                           muffled <- TRUE
[09:29:17.299]                           break
[09:29:17.299]                         }
[09:29:17.299]                       }
[09:29:17.299]                     }
[09:29:17.299]                     invisible(muffled)
[09:29:17.299]                   }
[09:29:17.299]                   muffleCondition(cond)
[09:29:17.299]                 })
[09:29:17.299]             }))
[09:29:17.299]             future::FutureResult(value = ...future.value$value, 
[09:29:17.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.299]                   ...future.rng), globalenv = if (FALSE) 
[09:29:17.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:17.299]                     ...future.globalenv.names))
[09:29:17.299]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:17.299]         }, condition = base::local({
[09:29:17.299]             c <- base::c
[09:29:17.299]             inherits <- base::inherits
[09:29:17.299]             invokeRestart <- base::invokeRestart
[09:29:17.299]             length <- base::length
[09:29:17.299]             list <- base::list
[09:29:17.299]             seq.int <- base::seq.int
[09:29:17.299]             signalCondition <- base::signalCondition
[09:29:17.299]             sys.calls <- base::sys.calls
[09:29:17.299]             `[[` <- base::`[[`
[09:29:17.299]             `+` <- base::`+`
[09:29:17.299]             `<<-` <- base::`<<-`
[09:29:17.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:17.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:17.299]                   3L)]
[09:29:17.299]             }
[09:29:17.299]             function(cond) {
[09:29:17.299]                 is_error <- inherits(cond, "error")
[09:29:17.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:17.299]                   NULL)
[09:29:17.299]                 if (is_error) {
[09:29:17.299]                   sessionInformation <- function() {
[09:29:17.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:17.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:17.299]                       search = base::search(), system = base::Sys.info())
[09:29:17.299]                   }
[09:29:17.299]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:17.299]                     cond$call), session = sessionInformation(), 
[09:29:17.299]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:17.299]                   signalCondition(cond)
[09:29:17.299]                 }
[09:29:17.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:17.299]                 "immediateCondition"))) {
[09:29:17.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:17.299]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:17.299]                   if (TRUE && !signal) {
[09:29:17.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.299]                     {
[09:29:17.299]                       inherits <- base::inherits
[09:29:17.299]                       invokeRestart <- base::invokeRestart
[09:29:17.299]                       is.null <- base::is.null
[09:29:17.299]                       muffled <- FALSE
[09:29:17.299]                       if (inherits(cond, "message")) {
[09:29:17.299]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.299]                         if (muffled) 
[09:29:17.299]                           invokeRestart("muffleMessage")
[09:29:17.299]                       }
[09:29:17.299]                       else if (inherits(cond, "warning")) {
[09:29:17.299]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.299]                         if (muffled) 
[09:29:17.299]                           invokeRestart("muffleWarning")
[09:29:17.299]                       }
[09:29:17.299]                       else if (inherits(cond, "condition")) {
[09:29:17.299]                         if (!is.null(pattern)) {
[09:29:17.299]                           computeRestarts <- base::computeRestarts
[09:29:17.299]                           grepl <- base::grepl
[09:29:17.299]                           restarts <- computeRestarts(cond)
[09:29:17.299]                           for (restart in restarts) {
[09:29:17.299]                             name <- restart$name
[09:29:17.299]                             if (is.null(name)) 
[09:29:17.299]                               next
[09:29:17.299]                             if (!grepl(pattern, name)) 
[09:29:17.299]                               next
[09:29:17.299]                             invokeRestart(restart)
[09:29:17.299]                             muffled <- TRUE
[09:29:17.299]                             break
[09:29:17.299]                           }
[09:29:17.299]                         }
[09:29:17.299]                       }
[09:29:17.299]                       invisible(muffled)
[09:29:17.299]                     }
[09:29:17.299]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.299]                   }
[09:29:17.299]                 }
[09:29:17.299]                 else {
[09:29:17.299]                   if (TRUE) {
[09:29:17.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.299]                     {
[09:29:17.299]                       inherits <- base::inherits
[09:29:17.299]                       invokeRestart <- base::invokeRestart
[09:29:17.299]                       is.null <- base::is.null
[09:29:17.299]                       muffled <- FALSE
[09:29:17.299]                       if (inherits(cond, "message")) {
[09:29:17.299]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.299]                         if (muffled) 
[09:29:17.299]                           invokeRestart("muffleMessage")
[09:29:17.299]                       }
[09:29:17.299]                       else if (inherits(cond, "warning")) {
[09:29:17.299]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.299]                         if (muffled) 
[09:29:17.299]                           invokeRestart("muffleWarning")
[09:29:17.299]                       }
[09:29:17.299]                       else if (inherits(cond, "condition")) {
[09:29:17.299]                         if (!is.null(pattern)) {
[09:29:17.299]                           computeRestarts <- base::computeRestarts
[09:29:17.299]                           grepl <- base::grepl
[09:29:17.299]                           restarts <- computeRestarts(cond)
[09:29:17.299]                           for (restart in restarts) {
[09:29:17.299]                             name <- restart$name
[09:29:17.299]                             if (is.null(name)) 
[09:29:17.299]                               next
[09:29:17.299]                             if (!grepl(pattern, name)) 
[09:29:17.299]                               next
[09:29:17.299]                             invokeRestart(restart)
[09:29:17.299]                             muffled <- TRUE
[09:29:17.299]                             break
[09:29:17.299]                           }
[09:29:17.299]                         }
[09:29:17.299]                       }
[09:29:17.299]                       invisible(muffled)
[09:29:17.299]                     }
[09:29:17.299]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.299]                   }
[09:29:17.299]                 }
[09:29:17.299]             }
[09:29:17.299]         }))
[09:29:17.299]     }, error = function(ex) {
[09:29:17.299]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:17.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.299]                 ...future.rng), started = ...future.startTime, 
[09:29:17.299]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:17.299]             version = "1.8"), class = "FutureResult")
[09:29:17.299]     }, finally = {
[09:29:17.299]         if (!identical(...future.workdir, getwd())) 
[09:29:17.299]             setwd(...future.workdir)
[09:29:17.299]         {
[09:29:17.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:17.299]                 ...future.oldOptions$nwarnings <- NULL
[09:29:17.299]             }
[09:29:17.299]             base::options(...future.oldOptions)
[09:29:17.299]             if (.Platform$OS.type == "windows") {
[09:29:17.299]                 old_names <- names(...future.oldEnvVars)
[09:29:17.299]                 envs <- base::Sys.getenv()
[09:29:17.299]                 names <- names(envs)
[09:29:17.299]                 common <- intersect(names, old_names)
[09:29:17.299]                 added <- setdiff(names, old_names)
[09:29:17.299]                 removed <- setdiff(old_names, names)
[09:29:17.299]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:17.299]                   envs[common]]
[09:29:17.299]                 NAMES <- toupper(changed)
[09:29:17.299]                 args <- list()
[09:29:17.299]                 for (kk in seq_along(NAMES)) {
[09:29:17.299]                   name <- changed[[kk]]
[09:29:17.299]                   NAME <- NAMES[[kk]]
[09:29:17.299]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.299]                     next
[09:29:17.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.299]                 }
[09:29:17.299]                 NAMES <- toupper(added)
[09:29:17.299]                 for (kk in seq_along(NAMES)) {
[09:29:17.299]                   name <- added[[kk]]
[09:29:17.299]                   NAME <- NAMES[[kk]]
[09:29:17.299]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.299]                     next
[09:29:17.299]                   args[[name]] <- ""
[09:29:17.299]                 }
[09:29:17.299]                 NAMES <- toupper(removed)
[09:29:17.299]                 for (kk in seq_along(NAMES)) {
[09:29:17.299]                   name <- removed[[kk]]
[09:29:17.299]                   NAME <- NAMES[[kk]]
[09:29:17.299]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.299]                     next
[09:29:17.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.299]                 }
[09:29:17.299]                 if (length(args) > 0) 
[09:29:17.299]                   base::do.call(base::Sys.setenv, args = args)
[09:29:17.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:17.299]             }
[09:29:17.299]             else {
[09:29:17.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:17.299]             }
[09:29:17.299]             {
[09:29:17.299]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:17.299]                   0L) {
[09:29:17.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:17.299]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:17.299]                   base::options(opts)
[09:29:17.299]                 }
[09:29:17.299]                 {
[09:29:17.299]                   {
[09:29:17.299]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:17.299]                     NULL
[09:29:17.299]                   }
[09:29:17.299]                   options(future.plan = NULL)
[09:29:17.299]                   if (is.na(NA_character_)) 
[09:29:17.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:17.299]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:17.299]                     .init = FALSE)
[09:29:17.299]                 }
[09:29:17.299]             }
[09:29:17.299]         }
[09:29:17.299]     })
[09:29:17.299]     if (TRUE) {
[09:29:17.299]         base::sink(type = "output", split = FALSE)
[09:29:17.299]         if (TRUE) {
[09:29:17.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:17.299]         }
[09:29:17.299]         else {
[09:29:17.299]             ...future.result["stdout"] <- base::list(NULL)
[09:29:17.299]         }
[09:29:17.299]         base::close(...future.stdout)
[09:29:17.299]         ...future.stdout <- NULL
[09:29:17.299]     }
[09:29:17.299]     ...future.result$conditions <- ...future.conditions
[09:29:17.299]     ...future.result$finished <- base::Sys.time()
[09:29:17.299]     ...future.result
[09:29:17.299] }
[09:29:17.302] assign_globals() ...
[09:29:17.302] List of 5
[09:29:17.302]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[09:29:17.302]  $ MoreArgs                 :List of 1
[09:29:17.302]   ..$ min: num 1
[09:29:17.302]  $ ...future.elements_ii    :List of 2
[09:29:17.302]   ..$ n  :List of 2
[09:29:17.302]   .. ..$ : int 1
[09:29:17.302]   .. ..$ : int 2
[09:29:17.302]   ..$ max:List of 2
[09:29:17.302]   .. ..$ : int 2
[09:29:17.302]   .. ..$ : int 3
[09:29:17.302]  $ ...future.seeds_ii       :List of 2
[09:29:17.302]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[09:29:17.302]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[09:29:17.302]  $ ...future.globals.maxSize: NULL
[09:29:17.302]  - attr(*, "where")=List of 5
[09:29:17.302]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:17.302]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:17.302]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:17.302]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:17.302]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:17.302]  - attr(*, "resolved")= logi FALSE
[09:29:17.302]  - attr(*, "total_size")= num 2528
[09:29:17.302]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.302]  - attr(*, "already-done")= logi TRUE
[09:29:17.308] - copied ‘...future.FUN’ to environment
[09:29:17.309] - copied ‘MoreArgs’ to environment
[09:29:17.309] - copied ‘...future.elements_ii’ to environment
[09:29:17.309] - copied ‘...future.seeds_ii’ to environment
[09:29:17.309] - copied ‘...future.globals.maxSize’ to environment
[09:29:17.309] assign_globals() ... done
[09:29:17.309] requestCore(): workers = 2
[09:29:17.311] MulticoreFuture started
[09:29:17.311] - Launch lazy future ... done
[09:29:17.312] run() for ‘MulticoreFuture’ ... done
[09:29:17.312] Created future:
[09:29:17.312] plan(): Setting new future strategy stack:
[09:29:17.313] List of future strategies:
[09:29:17.313] 1. sequential:
[09:29:17.313]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:17.313]    - tweaked: FALSE
[09:29:17.313]    - call: NULL
[09:29:17.314] plan(): nbrOfWorkers() = 1
[09:29:17.316] plan(): Setting new future strategy stack:
[09:29:17.316] List of future strategies:
[09:29:17.316] 1. multicore:
[09:29:17.316]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:17.316]    - tweaked: FALSE
[09:29:17.316]    - call: plan(strategy)
[09:29:17.321] plan(): nbrOfWorkers() = 2
[09:29:17.312] MulticoreFuture:
[09:29:17.312] Label: ‘future_mapply-1’
[09:29:17.312] Expression:
[09:29:17.312] {
[09:29:17.312]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.312]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:17.312]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.312]         on.exit(options(oopts), add = TRUE)
[09:29:17.312]     }
[09:29:17.312]     {
[09:29:17.312]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:17.312]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[09:29:17.312]                 inherits = FALSE)
[09:29:17.312]             ...future.FUN(...)
[09:29:17.312]         }
[09:29:17.312]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:17.312]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:17.312]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:17.312]         do.call(mapply, args = args)
[09:29:17.312]     }
[09:29:17.312] }
[09:29:17.312] Lazy evaluation: FALSE
[09:29:17.312] Asynchronous evaluation: TRUE
[09:29:17.312] Local evaluation: TRUE
[09:29:17.312] Environment: R_GlobalEnv
[09:29:17.312] Capture standard output: TRUE
[09:29:17.312] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:17.312] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:17.312] Packages: 1 packages (‘stats’)
[09:29:17.312] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:29:17.312] Resolved: TRUE
[09:29:17.312] Value: <not collected>
[09:29:17.312] Conditions captured: <none>
[09:29:17.312] Early signaling: FALSE
[09:29:17.312] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:17.312] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.322] Chunk #1 of 2 ... DONE
[09:29:17.322] Chunk #2 of 2 ...
[09:29:17.323]  - Finding globals in '...' for chunk #2 ...
[09:29:17.323] getGlobalsAndPackages() ...
[09:29:17.323] Searching for globals...
[09:29:17.323] 
[09:29:17.324] Searching for globals ... DONE
[09:29:17.324] - globals: [0] <none>
[09:29:17.324] getGlobalsAndPackages() ... DONE
[09:29:17.324]    + additional globals found: [n=0] 
[09:29:17.324]    + additional namespaces needed: [n=0] 
[09:29:17.324]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:17.325]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:17.325]  - seeds: [2] <seeds>
[09:29:17.325]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.325] getGlobalsAndPackages() ...
[09:29:17.325] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.325] Resolving globals: FALSE
[09:29:17.326] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[09:29:17.332] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[09:29:17.332] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.332] - packages: [1] ‘stats’
[09:29:17.333] getGlobalsAndPackages() ... DONE
[09:29:17.334] run() for ‘Future’ ...
[09:29:17.334] - state: ‘created’
[09:29:17.334] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:17.340] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.340] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:17.341]   - Field: ‘label’
[09:29:17.341]   - Field: ‘local’
[09:29:17.341]   - Field: ‘owner’
[09:29:17.341]   - Field: ‘envir’
[09:29:17.341]   - Field: ‘workers’
[09:29:17.342]   - Field: ‘packages’
[09:29:17.342]   - Field: ‘gc’
[09:29:17.342]   - Field: ‘job’
[09:29:17.342]   - Field: ‘conditions’
[09:29:17.342]   - Field: ‘expr’
[09:29:17.343]   - Field: ‘uuid’
[09:29:17.343]   - Field: ‘seed’
[09:29:17.343]   - Field: ‘version’
[09:29:17.343]   - Field: ‘result’
[09:29:17.343]   - Field: ‘asynchronous’
[09:29:17.344]   - Field: ‘calls’
[09:29:17.344]   - Field: ‘globals’
[09:29:17.344]   - Field: ‘stdout’
[09:29:17.344]   - Field: ‘earlySignal’
[09:29:17.344]   - Field: ‘lazy’
[09:29:17.345]   - Field: ‘state’
[09:29:17.345] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:17.345] - Launch lazy future ...
[09:29:17.345] Packages needed by the future expression (n = 1): ‘stats’
[09:29:17.346] Packages needed by future strategies (n = 0): <none>
[09:29:17.347] {
[09:29:17.347]     {
[09:29:17.347]         {
[09:29:17.347]             ...future.startTime <- base::Sys.time()
[09:29:17.347]             {
[09:29:17.347]                 {
[09:29:17.347]                   {
[09:29:17.347]                     {
[09:29:17.347]                       {
[09:29:17.347]                         base::local({
[09:29:17.347]                           has_future <- base::requireNamespace("future", 
[09:29:17.347]                             quietly = TRUE)
[09:29:17.347]                           if (has_future) {
[09:29:17.347]                             ns <- base::getNamespace("future")
[09:29:17.347]                             version <- ns[[".package"]][["version"]]
[09:29:17.347]                             if (is.null(version)) 
[09:29:17.347]                               version <- utils::packageVersion("future")
[09:29:17.347]                           }
[09:29:17.347]                           else {
[09:29:17.347]                             version <- NULL
[09:29:17.347]                           }
[09:29:17.347]                           if (!has_future || version < "1.8.0") {
[09:29:17.347]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:17.347]                               "", base::R.version$version.string), 
[09:29:17.347]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:17.347]                                 base::R.version$platform, 8 * 
[09:29:17.347]                                   base::.Machine$sizeof.pointer), 
[09:29:17.347]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:17.347]                                 "release", "version")], collapse = " "), 
[09:29:17.347]                               hostname = base::Sys.info()[["nodename"]])
[09:29:17.347]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:17.347]                               info)
[09:29:17.347]                             info <- base::paste(info, collapse = "; ")
[09:29:17.347]                             if (!has_future) {
[09:29:17.347]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:17.347]                                 info)
[09:29:17.347]                             }
[09:29:17.347]                             else {
[09:29:17.347]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:17.347]                                 info, version)
[09:29:17.347]                             }
[09:29:17.347]                             base::stop(msg)
[09:29:17.347]                           }
[09:29:17.347]                         })
[09:29:17.347]                       }
[09:29:17.347]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:17.347]                       base::options(mc.cores = 1L)
[09:29:17.347]                     }
[09:29:17.347]                     base::local({
[09:29:17.347]                       for (pkg in "stats") {
[09:29:17.347]                         base::loadNamespace(pkg)
[09:29:17.347]                         base::library(pkg, character.only = TRUE)
[09:29:17.347]                       }
[09:29:17.347]                     })
[09:29:17.347]                   }
[09:29:17.347]                   ...future.strategy.old <- future::plan("list")
[09:29:17.347]                   options(future.plan = NULL)
[09:29:17.347]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.347]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:17.347]                 }
[09:29:17.347]                 ...future.workdir <- getwd()
[09:29:17.347]             }
[09:29:17.347]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:17.347]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:17.347]         }
[09:29:17.347]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:17.347]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:17.347]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:17.347]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:17.347]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:17.347]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:17.347]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:17.347]             base::names(...future.oldOptions))
[09:29:17.347]     }
[09:29:17.347]     if (FALSE) {
[09:29:17.347]     }
[09:29:17.347]     else {
[09:29:17.347]         if (TRUE) {
[09:29:17.347]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:17.347]                 open = "w")
[09:29:17.347]         }
[09:29:17.347]         else {
[09:29:17.347]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:17.347]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:17.347]         }
[09:29:17.347]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:17.347]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:17.347]             base::sink(type = "output", split = FALSE)
[09:29:17.347]             base::close(...future.stdout)
[09:29:17.347]         }, add = TRUE)
[09:29:17.347]     }
[09:29:17.347]     ...future.frame <- base::sys.nframe()
[09:29:17.347]     ...future.conditions <- base::list()
[09:29:17.347]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:17.347]     if (FALSE) {
[09:29:17.347]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:17.347]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:17.347]     }
[09:29:17.347]     ...future.result <- base::tryCatch({
[09:29:17.347]         base::withCallingHandlers({
[09:29:17.347]             ...future.value <- base::withVisible(base::local({
[09:29:17.347]                 withCallingHandlers({
[09:29:17.347]                   {
[09:29:17.347]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.347]                     if (!identical(...future.globals.maxSize.org, 
[09:29:17.347]                       ...future.globals.maxSize)) {
[09:29:17.347]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.347]                       on.exit(options(oopts), add = TRUE)
[09:29:17.347]                     }
[09:29:17.347]                     {
[09:29:17.347]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:17.347]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[09:29:17.347]                           envir = globalenv(), inherits = FALSE)
[09:29:17.347]                         ...future.FUN(...)
[09:29:17.347]                       }
[09:29:17.347]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:17.347]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:17.347]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:17.347]                         USE.NAMES = FALSE)
[09:29:17.347]                       do.call(mapply, args = args)
[09:29:17.347]                     }
[09:29:17.347]                   }
[09:29:17.347]                 }, immediateCondition = function(cond) {
[09:29:17.347]                   save_rds <- function (object, pathname, ...) 
[09:29:17.347]                   {
[09:29:17.347]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:17.347]                     if (file_test("-f", pathname_tmp)) {
[09:29:17.347]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.347]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:17.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.347]                         fi_tmp[["mtime"]])
[09:29:17.347]                     }
[09:29:17.347]                     tryCatch({
[09:29:17.347]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:17.347]                     }, error = function(ex) {
[09:29:17.347]                       msg <- conditionMessage(ex)
[09:29:17.347]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.347]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:17.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.347]                         fi_tmp[["mtime"]], msg)
[09:29:17.347]                       ex$message <- msg
[09:29:17.347]                       stop(ex)
[09:29:17.347]                     })
[09:29:17.347]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:17.347]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:17.347]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:17.347]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.347]                       fi <- file.info(pathname)
[09:29:17.347]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:17.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.347]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:17.347]                         fi[["size"]], fi[["mtime"]])
[09:29:17.347]                       stop(msg)
[09:29:17.347]                     }
[09:29:17.347]                     invisible(pathname)
[09:29:17.347]                   }
[09:29:17.347]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:17.347]                     rootPath = tempdir()) 
[09:29:17.347]                   {
[09:29:17.347]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:17.347]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:17.347]                       tmpdir = path, fileext = ".rds")
[09:29:17.347]                     save_rds(obj, file)
[09:29:17.347]                   }
[09:29:17.347]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:17.347]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.347]                   {
[09:29:17.347]                     inherits <- base::inherits
[09:29:17.347]                     invokeRestart <- base::invokeRestart
[09:29:17.347]                     is.null <- base::is.null
[09:29:17.347]                     muffled <- FALSE
[09:29:17.347]                     if (inherits(cond, "message")) {
[09:29:17.347]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:17.347]                       if (muffled) 
[09:29:17.347]                         invokeRestart("muffleMessage")
[09:29:17.347]                     }
[09:29:17.347]                     else if (inherits(cond, "warning")) {
[09:29:17.347]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:17.347]                       if (muffled) 
[09:29:17.347]                         invokeRestart("muffleWarning")
[09:29:17.347]                     }
[09:29:17.347]                     else if (inherits(cond, "condition")) {
[09:29:17.347]                       if (!is.null(pattern)) {
[09:29:17.347]                         computeRestarts <- base::computeRestarts
[09:29:17.347]                         grepl <- base::grepl
[09:29:17.347]                         restarts <- computeRestarts(cond)
[09:29:17.347]                         for (restart in restarts) {
[09:29:17.347]                           name <- restart$name
[09:29:17.347]                           if (is.null(name)) 
[09:29:17.347]                             next
[09:29:17.347]                           if (!grepl(pattern, name)) 
[09:29:17.347]                             next
[09:29:17.347]                           invokeRestart(restart)
[09:29:17.347]                           muffled <- TRUE
[09:29:17.347]                           break
[09:29:17.347]                         }
[09:29:17.347]                       }
[09:29:17.347]                     }
[09:29:17.347]                     invisible(muffled)
[09:29:17.347]                   }
[09:29:17.347]                   muffleCondition(cond)
[09:29:17.347]                 })
[09:29:17.347]             }))
[09:29:17.347]             future::FutureResult(value = ...future.value$value, 
[09:29:17.347]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.347]                   ...future.rng), globalenv = if (FALSE) 
[09:29:17.347]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:17.347]                     ...future.globalenv.names))
[09:29:17.347]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:17.347]         }, condition = base::local({
[09:29:17.347]             c <- base::c
[09:29:17.347]             inherits <- base::inherits
[09:29:17.347]             invokeRestart <- base::invokeRestart
[09:29:17.347]             length <- base::length
[09:29:17.347]             list <- base::list
[09:29:17.347]             seq.int <- base::seq.int
[09:29:17.347]             signalCondition <- base::signalCondition
[09:29:17.347]             sys.calls <- base::sys.calls
[09:29:17.347]             `[[` <- base::`[[`
[09:29:17.347]             `+` <- base::`+`
[09:29:17.347]             `<<-` <- base::`<<-`
[09:29:17.347]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:17.347]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:17.347]                   3L)]
[09:29:17.347]             }
[09:29:17.347]             function(cond) {
[09:29:17.347]                 is_error <- inherits(cond, "error")
[09:29:17.347]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:17.347]                   NULL)
[09:29:17.347]                 if (is_error) {
[09:29:17.347]                   sessionInformation <- function() {
[09:29:17.347]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:17.347]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:17.347]                       search = base::search(), system = base::Sys.info())
[09:29:17.347]                   }
[09:29:17.347]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.347]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:17.347]                     cond$call), session = sessionInformation(), 
[09:29:17.347]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:17.347]                   signalCondition(cond)
[09:29:17.347]                 }
[09:29:17.347]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:17.347]                 "immediateCondition"))) {
[09:29:17.347]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:17.347]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.347]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:17.347]                   if (TRUE && !signal) {
[09:29:17.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.347]                     {
[09:29:17.347]                       inherits <- base::inherits
[09:29:17.347]                       invokeRestart <- base::invokeRestart
[09:29:17.347]                       is.null <- base::is.null
[09:29:17.347]                       muffled <- FALSE
[09:29:17.347]                       if (inherits(cond, "message")) {
[09:29:17.347]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.347]                         if (muffled) 
[09:29:17.347]                           invokeRestart("muffleMessage")
[09:29:17.347]                       }
[09:29:17.347]                       else if (inherits(cond, "warning")) {
[09:29:17.347]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.347]                         if (muffled) 
[09:29:17.347]                           invokeRestart("muffleWarning")
[09:29:17.347]                       }
[09:29:17.347]                       else if (inherits(cond, "condition")) {
[09:29:17.347]                         if (!is.null(pattern)) {
[09:29:17.347]                           computeRestarts <- base::computeRestarts
[09:29:17.347]                           grepl <- base::grepl
[09:29:17.347]                           restarts <- computeRestarts(cond)
[09:29:17.347]                           for (restart in restarts) {
[09:29:17.347]                             name <- restart$name
[09:29:17.347]                             if (is.null(name)) 
[09:29:17.347]                               next
[09:29:17.347]                             if (!grepl(pattern, name)) 
[09:29:17.347]                               next
[09:29:17.347]                             invokeRestart(restart)
[09:29:17.347]                             muffled <- TRUE
[09:29:17.347]                             break
[09:29:17.347]                           }
[09:29:17.347]                         }
[09:29:17.347]                       }
[09:29:17.347]                       invisible(muffled)
[09:29:17.347]                     }
[09:29:17.347]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.347]                   }
[09:29:17.347]                 }
[09:29:17.347]                 else {
[09:29:17.347]                   if (TRUE) {
[09:29:17.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.347]                     {
[09:29:17.347]                       inherits <- base::inherits
[09:29:17.347]                       invokeRestart <- base::invokeRestart
[09:29:17.347]                       is.null <- base::is.null
[09:29:17.347]                       muffled <- FALSE
[09:29:17.347]                       if (inherits(cond, "message")) {
[09:29:17.347]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.347]                         if (muffled) 
[09:29:17.347]                           invokeRestart("muffleMessage")
[09:29:17.347]                       }
[09:29:17.347]                       else if (inherits(cond, "warning")) {
[09:29:17.347]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.347]                         if (muffled) 
[09:29:17.347]                           invokeRestart("muffleWarning")
[09:29:17.347]                       }
[09:29:17.347]                       else if (inherits(cond, "condition")) {
[09:29:17.347]                         if (!is.null(pattern)) {
[09:29:17.347]                           computeRestarts <- base::computeRestarts
[09:29:17.347]                           grepl <- base::grepl
[09:29:17.347]                           restarts <- computeRestarts(cond)
[09:29:17.347]                           for (restart in restarts) {
[09:29:17.347]                             name <- restart$name
[09:29:17.347]                             if (is.null(name)) 
[09:29:17.347]                               next
[09:29:17.347]                             if (!grepl(pattern, name)) 
[09:29:17.347]                               next
[09:29:17.347]                             invokeRestart(restart)
[09:29:17.347]                             muffled <- TRUE
[09:29:17.347]                             break
[09:29:17.347]                           }
[09:29:17.347]                         }
[09:29:17.347]                       }
[09:29:17.347]                       invisible(muffled)
[09:29:17.347]                     }
[09:29:17.347]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.347]                   }
[09:29:17.347]                 }
[09:29:17.347]             }
[09:29:17.347]         }))
[09:29:17.347]     }, error = function(ex) {
[09:29:17.347]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:17.347]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.347]                 ...future.rng), started = ...future.startTime, 
[09:29:17.347]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:17.347]             version = "1.8"), class = "FutureResult")
[09:29:17.347]     }, finally = {
[09:29:17.347]         if (!identical(...future.workdir, getwd())) 
[09:29:17.347]             setwd(...future.workdir)
[09:29:17.347]         {
[09:29:17.347]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:17.347]                 ...future.oldOptions$nwarnings <- NULL
[09:29:17.347]             }
[09:29:17.347]             base::options(...future.oldOptions)
[09:29:17.347]             if (.Platform$OS.type == "windows") {
[09:29:17.347]                 old_names <- names(...future.oldEnvVars)
[09:29:17.347]                 envs <- base::Sys.getenv()
[09:29:17.347]                 names <- names(envs)
[09:29:17.347]                 common <- intersect(names, old_names)
[09:29:17.347]                 added <- setdiff(names, old_names)
[09:29:17.347]                 removed <- setdiff(old_names, names)
[09:29:17.347]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:17.347]                   envs[common]]
[09:29:17.347]                 NAMES <- toupper(changed)
[09:29:17.347]                 args <- list()
[09:29:17.347]                 for (kk in seq_along(NAMES)) {
[09:29:17.347]                   name <- changed[[kk]]
[09:29:17.347]                   NAME <- NAMES[[kk]]
[09:29:17.347]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.347]                     next
[09:29:17.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.347]                 }
[09:29:17.347]                 NAMES <- toupper(added)
[09:29:17.347]                 for (kk in seq_along(NAMES)) {
[09:29:17.347]                   name <- added[[kk]]
[09:29:17.347]                   NAME <- NAMES[[kk]]
[09:29:17.347]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.347]                     next
[09:29:17.347]                   args[[name]] <- ""
[09:29:17.347]                 }
[09:29:17.347]                 NAMES <- toupper(removed)
[09:29:17.347]                 for (kk in seq_along(NAMES)) {
[09:29:17.347]                   name <- removed[[kk]]
[09:29:17.347]                   NAME <- NAMES[[kk]]
[09:29:17.347]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.347]                     next
[09:29:17.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.347]                 }
[09:29:17.347]                 if (length(args) > 0) 
[09:29:17.347]                   base::do.call(base::Sys.setenv, args = args)
[09:29:17.347]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:17.347]             }
[09:29:17.347]             else {
[09:29:17.347]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:17.347]             }
[09:29:17.347]             {
[09:29:17.347]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:17.347]                   0L) {
[09:29:17.347]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:17.347]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:17.347]                   base::options(opts)
[09:29:17.347]                 }
[09:29:17.347]                 {
[09:29:17.347]                   {
[09:29:17.347]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:17.347]                     NULL
[09:29:17.347]                   }
[09:29:17.347]                   options(future.plan = NULL)
[09:29:17.347]                   if (is.na(NA_character_)) 
[09:29:17.347]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.347]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:17.347]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:17.347]                     .init = FALSE)
[09:29:17.347]                 }
[09:29:17.347]             }
[09:29:17.347]         }
[09:29:17.347]     })
[09:29:17.347]     if (TRUE) {
[09:29:17.347]         base::sink(type = "output", split = FALSE)
[09:29:17.347]         if (TRUE) {
[09:29:17.347]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:17.347]         }
[09:29:17.347]         else {
[09:29:17.347]             ...future.result["stdout"] <- base::list(NULL)
[09:29:17.347]         }
[09:29:17.347]         base::close(...future.stdout)
[09:29:17.347]         ...future.stdout <- NULL
[09:29:17.347]     }
[09:29:17.347]     ...future.result$conditions <- ...future.conditions
[09:29:17.347]     ...future.result$finished <- base::Sys.time()
[09:29:17.347]     ...future.result
[09:29:17.347] }
[09:29:17.350] assign_globals() ...
[09:29:17.350] List of 5
[09:29:17.350]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[09:29:17.350]  $ MoreArgs                 :List of 1
[09:29:17.350]   ..$ min: num 1
[09:29:17.350]  $ ...future.elements_ii    :List of 2
[09:29:17.350]   ..$ n  :List of 2
[09:29:17.350]   .. ..$ : int 3
[09:29:17.350]   .. ..$ : int 4
[09:29:17.350]   ..$ max:List of 2
[09:29:17.350]   .. ..$ : int 4
[09:29:17.350]   .. ..$ : int 5
[09:29:17.350]  $ ...future.seeds_ii       :List of 2
[09:29:17.350]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[09:29:17.350]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[09:29:17.350]  $ ...future.globals.maxSize: NULL
[09:29:17.350]  - attr(*, "where")=List of 5
[09:29:17.350]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:17.350]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:17.350]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:17.350]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:17.350]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:17.350]  - attr(*, "resolved")= logi FALSE
[09:29:17.350]  - attr(*, "total_size")= num 2528
[09:29:17.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.350]  - attr(*, "already-done")= logi TRUE
[09:29:17.358] - copied ‘...future.FUN’ to environment
[09:29:17.359] - copied ‘MoreArgs’ to environment
[09:29:17.359] - copied ‘...future.elements_ii’ to environment
[09:29:17.359] - copied ‘...future.seeds_ii’ to environment
[09:29:17.359] - copied ‘...future.globals.maxSize’ to environment
[09:29:17.359] assign_globals() ... done
[09:29:17.359] requestCore(): workers = 2
[09:29:17.362] MulticoreFuture started
[09:29:17.362] - Launch lazy future ... done
[09:29:17.362] run() for ‘MulticoreFuture’ ... done
[09:29:17.362] Created future:
[09:29:17.363] plan(): Setting new future strategy stack:
[09:29:17.363] List of future strategies:
[09:29:17.363] 1. sequential:
[09:29:17.363]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:17.363]    - tweaked: FALSE
[09:29:17.363]    - call: NULL
[09:29:17.364] plan(): nbrOfWorkers() = 1
[09:29:17.366] plan(): Setting new future strategy stack:
[09:29:17.366] List of future strategies:
[09:29:17.366] 1. multicore:
[09:29:17.366]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:17.366]    - tweaked: FALSE
[09:29:17.366]    - call: plan(strategy)
[09:29:17.371] plan(): nbrOfWorkers() = 2
[09:29:17.363] MulticoreFuture:
[09:29:17.363] Label: ‘future_mapply-2’
[09:29:17.363] Expression:
[09:29:17.363] {
[09:29:17.363]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.363]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:17.363]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.363]         on.exit(options(oopts), add = TRUE)
[09:29:17.363]     }
[09:29:17.363]     {
[09:29:17.363]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:17.363]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[09:29:17.363]                 inherits = FALSE)
[09:29:17.363]             ...future.FUN(...)
[09:29:17.363]         }
[09:29:17.363]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:17.363]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:17.363]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:17.363]         do.call(mapply, args = args)
[09:29:17.363]     }
[09:29:17.363] }
[09:29:17.363] Lazy evaluation: FALSE
[09:29:17.363] Asynchronous evaluation: TRUE
[09:29:17.363] Local evaluation: TRUE
[09:29:17.363] Environment: R_GlobalEnv
[09:29:17.363] Capture standard output: TRUE
[09:29:17.363] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:17.363] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:17.363] Packages: 1 packages (‘stats’)
[09:29:17.363] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:29:17.363] Resolved: TRUE
[09:29:17.363] Value: <not collected>
[09:29:17.363] Conditions captured: <none>
[09:29:17.363] Early signaling: FALSE
[09:29:17.363] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:17.363] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.372] Chunk #2 of 2 ... DONE
[09:29:17.373] Launching 2 futures (chunks) ... DONE
[09:29:17.373] Resolving 2 futures (chunks) ...
[09:29:17.373] resolve() on list ...
[09:29:17.373]  recursive: 0
[09:29:17.373]  length: 2
[09:29:17.373] 
[09:29:17.374] Future #1
[09:29:17.374] result() for MulticoreFuture ...
[09:29:17.375] result() for MulticoreFuture ...
[09:29:17.375] result() for MulticoreFuture ... done
[09:29:17.375] result() for MulticoreFuture ... done
[09:29:17.375] result() for MulticoreFuture ...
[09:29:17.375] result() for MulticoreFuture ... done
[09:29:17.376] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:17.376] - nx: 2
[09:29:17.376] - relay: TRUE
[09:29:17.376] - stdout: TRUE
[09:29:17.376] - signal: TRUE
[09:29:17.376] - resignal: FALSE
[09:29:17.377] - force: TRUE
[09:29:17.377] - relayed: [n=2] FALSE, FALSE
[09:29:17.377] - queued futures: [n=2] FALSE, FALSE
[09:29:17.377]  - until=1
[09:29:17.377]  - relaying element #1
[09:29:17.377] result() for MulticoreFuture ...
[09:29:17.381] result() for MulticoreFuture ... done
[09:29:17.382] result() for MulticoreFuture ...
[09:29:17.382] result() for MulticoreFuture ... done
[09:29:17.383] result() for MulticoreFuture ...
[09:29:17.383] result() for MulticoreFuture ... done
[09:29:17.383] result() for MulticoreFuture ...
[09:29:17.384] result() for MulticoreFuture ... done
[09:29:17.384] - relayed: [n=2] TRUE, FALSE
[09:29:17.384] - queued futures: [n=2] TRUE, FALSE
[09:29:17.385] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:17.385]  length: 1 (resolved future 1)
[09:29:17.385] Future #2
[09:29:17.386] result() for MulticoreFuture ...
[09:29:17.387] result() for MulticoreFuture ...
[09:29:17.387] result() for MulticoreFuture ... done
[09:29:17.387] result() for MulticoreFuture ... done
[09:29:17.387] result() for MulticoreFuture ...
[09:29:17.388] result() for MulticoreFuture ... done
[09:29:17.388] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:17.388] - nx: 2
[09:29:17.388] - relay: TRUE
[09:29:17.388] - stdout: TRUE
[09:29:17.389] - signal: TRUE
[09:29:17.389] - resignal: FALSE
[09:29:17.389] - force: TRUE
[09:29:17.389] - relayed: [n=2] TRUE, FALSE
[09:29:17.389] - queued futures: [n=2] TRUE, FALSE
[09:29:17.389]  - until=2
[09:29:17.389]  - relaying element #2
[09:29:17.390] result() for MulticoreFuture ...
[09:29:17.390] result() for MulticoreFuture ... done
[09:29:17.390] result() for MulticoreFuture ...
[09:29:17.390] result() for MulticoreFuture ... done
[09:29:17.390] result() for MulticoreFuture ...
[09:29:17.390] result() for MulticoreFuture ... done
[09:29:17.390] result() for MulticoreFuture ...
[09:29:17.391] result() for MulticoreFuture ... done
[09:29:17.391] - relayed: [n=2] TRUE, TRUE
[09:29:17.391] - queued futures: [n=2] TRUE, TRUE
[09:29:17.391] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:17.391]  length: 0 (resolved future 2)
[09:29:17.391] Relaying remaining futures
[09:29:17.391] signalConditionsASAP(NULL, pos=0) ...
[09:29:17.391] - nx: 2
[09:29:17.392] - relay: TRUE
[09:29:17.392] - stdout: TRUE
[09:29:17.392] - signal: TRUE
[09:29:17.392] - resignal: FALSE
[09:29:17.392] - force: TRUE
[09:29:17.392] - relayed: [n=2] TRUE, TRUE
[09:29:17.392] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:17.393] - relayed: [n=2] TRUE, TRUE
[09:29:17.393] - queued futures: [n=2] TRUE, TRUE
[09:29:17.393] signalConditionsASAP(NULL, pos=0) ... done
[09:29:17.393] resolve() on list ... DONE
[09:29:17.393] result() for MulticoreFuture ...
[09:29:17.393] result() for MulticoreFuture ... done
[09:29:17.393] result() for MulticoreFuture ...
[09:29:17.393] result() for MulticoreFuture ... done
[09:29:17.394] result() for MulticoreFuture ...
[09:29:17.394] result() for MulticoreFuture ... done
[09:29:17.394] result() for MulticoreFuture ...
[09:29:17.394] result() for MulticoreFuture ... done
[09:29:17.394]  - Number of value chunks collected: 2
[09:29:17.394] Resolving 2 futures (chunks) ... DONE
[09:29:17.394] Reducing values from 2 chunks ...
[09:29:17.394]  - Number of values collected after concatenation: 4
[09:29:17.394]  - Number of values expected: 4
[09:29:17.395] Reducing values from 2 chunks ... DONE
[09:29:17.395] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[09:29:17.395] future_mapply() ...
[09:29:17.399] Number of chunks: 2
[09:29:17.400] getGlobalsAndPackagesXApply() ...
[09:29:17.400]  - future.globals: TRUE
[09:29:17.400] getGlobalsAndPackages() ...
[09:29:17.400] Searching for globals...
[09:29:17.401] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:29:17.401] Searching for globals ... DONE
[09:29:17.401] Resolving globals: FALSE
[09:29:17.402] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[09:29:17.402] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[09:29:17.402] - globals: [1] ‘FUN’
[09:29:17.402] - packages: [1] ‘stats’
[09:29:17.403] getGlobalsAndPackages() ... DONE
[09:29:17.403]  - globals found/used: [n=1] ‘FUN’
[09:29:17.403]  - needed namespaces: [n=1] ‘stats’
[09:29:17.403] Finding globals ... DONE
[09:29:17.403] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:17.403] List of 2
[09:29:17.403]  $ ...future.FUN:function (x, w, ...)  
[09:29:17.403]  $ MoreArgs     : NULL
[09:29:17.403]  - attr(*, "where")=List of 2
[09:29:17.403]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:17.403]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:17.403]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.403]  - attr(*, "resolved")= logi FALSE
[09:29:17.403]  - attr(*, "total_size")= num NA
[09:29:17.406] Packages to be attached in all futures: [n=1] ‘stats’
[09:29:17.406] getGlobalsAndPackagesXApply() ... DONE
[09:29:17.406] Number of futures (= number of chunks): 2
[09:29:17.406] Launching 2 futures (chunks) ...
[09:29:17.406] Chunk #1 of 2 ...
[09:29:17.406]  - Finding globals in '...' for chunk #1 ...
[09:29:17.407] getGlobalsAndPackages() ...
[09:29:17.407] Searching for globals...
[09:29:17.407] 
[09:29:17.407] Searching for globals ... DONE
[09:29:17.407] - globals: [0] <none>
[09:29:17.407] getGlobalsAndPackages() ... DONE
[09:29:17.407]    + additional globals found: [n=0] 
[09:29:17.407]    + additional namespaces needed: [n=0] 
[09:29:17.407]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:17.408]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:17.408]  - seeds: <none>
[09:29:17.408]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.408] getGlobalsAndPackages() ...
[09:29:17.408] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.408] Resolving globals: FALSE
[09:29:17.409] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[09:29:17.409] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:17.409] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.409] - packages: [1] ‘stats’
[09:29:17.409] getGlobalsAndPackages() ... DONE
[09:29:17.412] run() for ‘Future’ ...
[09:29:17.412] - state: ‘created’
[09:29:17.412] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:17.416] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.416] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:17.416]   - Field: ‘label’
[09:29:17.416]   - Field: ‘local’
[09:29:17.416]   - Field: ‘owner’
[09:29:17.417]   - Field: ‘envir’
[09:29:17.417]   - Field: ‘workers’
[09:29:17.417]   - Field: ‘packages’
[09:29:17.417]   - Field: ‘gc’
[09:29:17.417]   - Field: ‘job’
[09:29:17.417]   - Field: ‘conditions’
[09:29:17.418]   - Field: ‘expr’
[09:29:17.418]   - Field: ‘uuid’
[09:29:17.418]   - Field: ‘seed’
[09:29:17.418]   - Field: ‘version’
[09:29:17.418]   - Field: ‘result’
[09:29:17.418]   - Field: ‘asynchronous’
[09:29:17.418]   - Field: ‘calls’
[09:29:17.418]   - Field: ‘globals’
[09:29:17.418]   - Field: ‘stdout’
[09:29:17.418]   - Field: ‘earlySignal’
[09:29:17.419]   - Field: ‘lazy’
[09:29:17.419]   - Field: ‘state’
[09:29:17.419] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:17.419] - Launch lazy future ...
[09:29:17.419] Packages needed by the future expression (n = 1): ‘stats’
[09:29:17.419] Packages needed by future strategies (n = 0): <none>
[09:29:17.420] {
[09:29:17.420]     {
[09:29:17.420]         {
[09:29:17.420]             ...future.startTime <- base::Sys.time()
[09:29:17.420]             {
[09:29:17.420]                 {
[09:29:17.420]                   {
[09:29:17.420]                     {
[09:29:17.420]                       {
[09:29:17.420]                         base::local({
[09:29:17.420]                           has_future <- base::requireNamespace("future", 
[09:29:17.420]                             quietly = TRUE)
[09:29:17.420]                           if (has_future) {
[09:29:17.420]                             ns <- base::getNamespace("future")
[09:29:17.420]                             version <- ns[[".package"]][["version"]]
[09:29:17.420]                             if (is.null(version)) 
[09:29:17.420]                               version <- utils::packageVersion("future")
[09:29:17.420]                           }
[09:29:17.420]                           else {
[09:29:17.420]                             version <- NULL
[09:29:17.420]                           }
[09:29:17.420]                           if (!has_future || version < "1.8.0") {
[09:29:17.420]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:17.420]                               "", base::R.version$version.string), 
[09:29:17.420]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:17.420]                                 base::R.version$platform, 8 * 
[09:29:17.420]                                   base::.Machine$sizeof.pointer), 
[09:29:17.420]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:17.420]                                 "release", "version")], collapse = " "), 
[09:29:17.420]                               hostname = base::Sys.info()[["nodename"]])
[09:29:17.420]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:17.420]                               info)
[09:29:17.420]                             info <- base::paste(info, collapse = "; ")
[09:29:17.420]                             if (!has_future) {
[09:29:17.420]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:17.420]                                 info)
[09:29:17.420]                             }
[09:29:17.420]                             else {
[09:29:17.420]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:17.420]                                 info, version)
[09:29:17.420]                             }
[09:29:17.420]                             base::stop(msg)
[09:29:17.420]                           }
[09:29:17.420]                         })
[09:29:17.420]                       }
[09:29:17.420]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:17.420]                       base::options(mc.cores = 1L)
[09:29:17.420]                     }
[09:29:17.420]                     base::local({
[09:29:17.420]                       for (pkg in "stats") {
[09:29:17.420]                         base::loadNamespace(pkg)
[09:29:17.420]                         base::library(pkg, character.only = TRUE)
[09:29:17.420]                       }
[09:29:17.420]                     })
[09:29:17.420]                   }
[09:29:17.420]                   ...future.strategy.old <- future::plan("list")
[09:29:17.420]                   options(future.plan = NULL)
[09:29:17.420]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.420]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:17.420]                 }
[09:29:17.420]                 ...future.workdir <- getwd()
[09:29:17.420]             }
[09:29:17.420]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:17.420]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:17.420]         }
[09:29:17.420]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:17.420]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:17.420]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:17.420]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:17.420]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:17.420]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:17.420]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:17.420]             base::names(...future.oldOptions))
[09:29:17.420]     }
[09:29:17.420]     if (FALSE) {
[09:29:17.420]     }
[09:29:17.420]     else {
[09:29:17.420]         if (TRUE) {
[09:29:17.420]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:17.420]                 open = "w")
[09:29:17.420]         }
[09:29:17.420]         else {
[09:29:17.420]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:17.420]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:17.420]         }
[09:29:17.420]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:17.420]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:17.420]             base::sink(type = "output", split = FALSE)
[09:29:17.420]             base::close(...future.stdout)
[09:29:17.420]         }, add = TRUE)
[09:29:17.420]     }
[09:29:17.420]     ...future.frame <- base::sys.nframe()
[09:29:17.420]     ...future.conditions <- base::list()
[09:29:17.420]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:17.420]     if (FALSE) {
[09:29:17.420]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:17.420]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:17.420]     }
[09:29:17.420]     ...future.result <- base::tryCatch({
[09:29:17.420]         base::withCallingHandlers({
[09:29:17.420]             ...future.value <- base::withVisible(base::local({
[09:29:17.420]                 withCallingHandlers({
[09:29:17.420]                   {
[09:29:17.420]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.420]                     if (!identical(...future.globals.maxSize.org, 
[09:29:17.420]                       ...future.globals.maxSize)) {
[09:29:17.420]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.420]                       on.exit(options(oopts), add = TRUE)
[09:29:17.420]                     }
[09:29:17.420]                     {
[09:29:17.420]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.420]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:17.420]                         USE.NAMES = FALSE)
[09:29:17.420]                       do.call(mapply, args = args)
[09:29:17.420]                     }
[09:29:17.420]                   }
[09:29:17.420]                 }, immediateCondition = function(cond) {
[09:29:17.420]                   save_rds <- function (object, pathname, ...) 
[09:29:17.420]                   {
[09:29:17.420]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:17.420]                     if (file_test("-f", pathname_tmp)) {
[09:29:17.420]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.420]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:17.420]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.420]                         fi_tmp[["mtime"]])
[09:29:17.420]                     }
[09:29:17.420]                     tryCatch({
[09:29:17.420]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:17.420]                     }, error = function(ex) {
[09:29:17.420]                       msg <- conditionMessage(ex)
[09:29:17.420]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.420]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:17.420]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.420]                         fi_tmp[["mtime"]], msg)
[09:29:17.420]                       ex$message <- msg
[09:29:17.420]                       stop(ex)
[09:29:17.420]                     })
[09:29:17.420]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:17.420]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:17.420]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:17.420]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.420]                       fi <- file.info(pathname)
[09:29:17.420]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:17.420]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.420]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:17.420]                         fi[["size"]], fi[["mtime"]])
[09:29:17.420]                       stop(msg)
[09:29:17.420]                     }
[09:29:17.420]                     invisible(pathname)
[09:29:17.420]                   }
[09:29:17.420]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:17.420]                     rootPath = tempdir()) 
[09:29:17.420]                   {
[09:29:17.420]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:17.420]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:17.420]                       tmpdir = path, fileext = ".rds")
[09:29:17.420]                     save_rds(obj, file)
[09:29:17.420]                   }
[09:29:17.420]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:17.420]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.420]                   {
[09:29:17.420]                     inherits <- base::inherits
[09:29:17.420]                     invokeRestart <- base::invokeRestart
[09:29:17.420]                     is.null <- base::is.null
[09:29:17.420]                     muffled <- FALSE
[09:29:17.420]                     if (inherits(cond, "message")) {
[09:29:17.420]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:17.420]                       if (muffled) 
[09:29:17.420]                         invokeRestart("muffleMessage")
[09:29:17.420]                     }
[09:29:17.420]                     else if (inherits(cond, "warning")) {
[09:29:17.420]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:17.420]                       if (muffled) 
[09:29:17.420]                         invokeRestart("muffleWarning")
[09:29:17.420]                     }
[09:29:17.420]                     else if (inherits(cond, "condition")) {
[09:29:17.420]                       if (!is.null(pattern)) {
[09:29:17.420]                         computeRestarts <- base::computeRestarts
[09:29:17.420]                         grepl <- base::grepl
[09:29:17.420]                         restarts <- computeRestarts(cond)
[09:29:17.420]                         for (restart in restarts) {
[09:29:17.420]                           name <- restart$name
[09:29:17.420]                           if (is.null(name)) 
[09:29:17.420]                             next
[09:29:17.420]                           if (!grepl(pattern, name)) 
[09:29:17.420]                             next
[09:29:17.420]                           invokeRestart(restart)
[09:29:17.420]                           muffled <- TRUE
[09:29:17.420]                           break
[09:29:17.420]                         }
[09:29:17.420]                       }
[09:29:17.420]                     }
[09:29:17.420]                     invisible(muffled)
[09:29:17.420]                   }
[09:29:17.420]                   muffleCondition(cond)
[09:29:17.420]                 })
[09:29:17.420]             }))
[09:29:17.420]             future::FutureResult(value = ...future.value$value, 
[09:29:17.420]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.420]                   ...future.rng), globalenv = if (FALSE) 
[09:29:17.420]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:17.420]                     ...future.globalenv.names))
[09:29:17.420]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:17.420]         }, condition = base::local({
[09:29:17.420]             c <- base::c
[09:29:17.420]             inherits <- base::inherits
[09:29:17.420]             invokeRestart <- base::invokeRestart
[09:29:17.420]             length <- base::length
[09:29:17.420]             list <- base::list
[09:29:17.420]             seq.int <- base::seq.int
[09:29:17.420]             signalCondition <- base::signalCondition
[09:29:17.420]             sys.calls <- base::sys.calls
[09:29:17.420]             `[[` <- base::`[[`
[09:29:17.420]             `+` <- base::`+`
[09:29:17.420]             `<<-` <- base::`<<-`
[09:29:17.420]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:17.420]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:17.420]                   3L)]
[09:29:17.420]             }
[09:29:17.420]             function(cond) {
[09:29:17.420]                 is_error <- inherits(cond, "error")
[09:29:17.420]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:17.420]                   NULL)
[09:29:17.420]                 if (is_error) {
[09:29:17.420]                   sessionInformation <- function() {
[09:29:17.420]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:17.420]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:17.420]                       search = base::search(), system = base::Sys.info())
[09:29:17.420]                   }
[09:29:17.420]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.420]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:17.420]                     cond$call), session = sessionInformation(), 
[09:29:17.420]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:17.420]                   signalCondition(cond)
[09:29:17.420]                 }
[09:29:17.420]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:17.420]                 "immediateCondition"))) {
[09:29:17.420]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:17.420]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.420]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:17.420]                   if (TRUE && !signal) {
[09:29:17.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.420]                     {
[09:29:17.420]                       inherits <- base::inherits
[09:29:17.420]                       invokeRestart <- base::invokeRestart
[09:29:17.420]                       is.null <- base::is.null
[09:29:17.420]                       muffled <- FALSE
[09:29:17.420]                       if (inherits(cond, "message")) {
[09:29:17.420]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.420]                         if (muffled) 
[09:29:17.420]                           invokeRestart("muffleMessage")
[09:29:17.420]                       }
[09:29:17.420]                       else if (inherits(cond, "warning")) {
[09:29:17.420]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.420]                         if (muffled) 
[09:29:17.420]                           invokeRestart("muffleWarning")
[09:29:17.420]                       }
[09:29:17.420]                       else if (inherits(cond, "condition")) {
[09:29:17.420]                         if (!is.null(pattern)) {
[09:29:17.420]                           computeRestarts <- base::computeRestarts
[09:29:17.420]                           grepl <- base::grepl
[09:29:17.420]                           restarts <- computeRestarts(cond)
[09:29:17.420]                           for (restart in restarts) {
[09:29:17.420]                             name <- restart$name
[09:29:17.420]                             if (is.null(name)) 
[09:29:17.420]                               next
[09:29:17.420]                             if (!grepl(pattern, name)) 
[09:29:17.420]                               next
[09:29:17.420]                             invokeRestart(restart)
[09:29:17.420]                             muffled <- TRUE
[09:29:17.420]                             break
[09:29:17.420]                           }
[09:29:17.420]                         }
[09:29:17.420]                       }
[09:29:17.420]                       invisible(muffled)
[09:29:17.420]                     }
[09:29:17.420]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.420]                   }
[09:29:17.420]                 }
[09:29:17.420]                 else {
[09:29:17.420]                   if (TRUE) {
[09:29:17.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.420]                     {
[09:29:17.420]                       inherits <- base::inherits
[09:29:17.420]                       invokeRestart <- base::invokeRestart
[09:29:17.420]                       is.null <- base::is.null
[09:29:17.420]                       muffled <- FALSE
[09:29:17.420]                       if (inherits(cond, "message")) {
[09:29:17.420]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.420]                         if (muffled) 
[09:29:17.420]                           invokeRestart("muffleMessage")
[09:29:17.420]                       }
[09:29:17.420]                       else if (inherits(cond, "warning")) {
[09:29:17.420]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.420]                         if (muffled) 
[09:29:17.420]                           invokeRestart("muffleWarning")
[09:29:17.420]                       }
[09:29:17.420]                       else if (inherits(cond, "condition")) {
[09:29:17.420]                         if (!is.null(pattern)) {
[09:29:17.420]                           computeRestarts <- base::computeRestarts
[09:29:17.420]                           grepl <- base::grepl
[09:29:17.420]                           restarts <- computeRestarts(cond)
[09:29:17.420]                           for (restart in restarts) {
[09:29:17.420]                             name <- restart$name
[09:29:17.420]                             if (is.null(name)) 
[09:29:17.420]                               next
[09:29:17.420]                             if (!grepl(pattern, name)) 
[09:29:17.420]                               next
[09:29:17.420]                             invokeRestart(restart)
[09:29:17.420]                             muffled <- TRUE
[09:29:17.420]                             break
[09:29:17.420]                           }
[09:29:17.420]                         }
[09:29:17.420]                       }
[09:29:17.420]                       invisible(muffled)
[09:29:17.420]                     }
[09:29:17.420]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.420]                   }
[09:29:17.420]                 }
[09:29:17.420]             }
[09:29:17.420]         }))
[09:29:17.420]     }, error = function(ex) {
[09:29:17.420]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:17.420]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.420]                 ...future.rng), started = ...future.startTime, 
[09:29:17.420]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:17.420]             version = "1.8"), class = "FutureResult")
[09:29:17.420]     }, finally = {
[09:29:17.420]         if (!identical(...future.workdir, getwd())) 
[09:29:17.420]             setwd(...future.workdir)
[09:29:17.420]         {
[09:29:17.420]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:17.420]                 ...future.oldOptions$nwarnings <- NULL
[09:29:17.420]             }
[09:29:17.420]             base::options(...future.oldOptions)
[09:29:17.420]             if (.Platform$OS.type == "windows") {
[09:29:17.420]                 old_names <- names(...future.oldEnvVars)
[09:29:17.420]                 envs <- base::Sys.getenv()
[09:29:17.420]                 names <- names(envs)
[09:29:17.420]                 common <- intersect(names, old_names)
[09:29:17.420]                 added <- setdiff(names, old_names)
[09:29:17.420]                 removed <- setdiff(old_names, names)
[09:29:17.420]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:17.420]                   envs[common]]
[09:29:17.420]                 NAMES <- toupper(changed)
[09:29:17.420]                 args <- list()
[09:29:17.420]                 for (kk in seq_along(NAMES)) {
[09:29:17.420]                   name <- changed[[kk]]
[09:29:17.420]                   NAME <- NAMES[[kk]]
[09:29:17.420]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.420]                     next
[09:29:17.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.420]                 }
[09:29:17.420]                 NAMES <- toupper(added)
[09:29:17.420]                 for (kk in seq_along(NAMES)) {
[09:29:17.420]                   name <- added[[kk]]
[09:29:17.420]                   NAME <- NAMES[[kk]]
[09:29:17.420]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.420]                     next
[09:29:17.420]                   args[[name]] <- ""
[09:29:17.420]                 }
[09:29:17.420]                 NAMES <- toupper(removed)
[09:29:17.420]                 for (kk in seq_along(NAMES)) {
[09:29:17.420]                   name <- removed[[kk]]
[09:29:17.420]                   NAME <- NAMES[[kk]]
[09:29:17.420]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.420]                     next
[09:29:17.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.420]                 }
[09:29:17.420]                 if (length(args) > 0) 
[09:29:17.420]                   base::do.call(base::Sys.setenv, args = args)
[09:29:17.420]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:17.420]             }
[09:29:17.420]             else {
[09:29:17.420]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:17.420]             }
[09:29:17.420]             {
[09:29:17.420]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:17.420]                   0L) {
[09:29:17.420]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:17.420]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:17.420]                   base::options(opts)
[09:29:17.420]                 }
[09:29:17.420]                 {
[09:29:17.420]                   {
[09:29:17.420]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:17.420]                     NULL
[09:29:17.420]                   }
[09:29:17.420]                   options(future.plan = NULL)
[09:29:17.420]                   if (is.na(NA_character_)) 
[09:29:17.420]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.420]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:17.420]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:17.420]                     .init = FALSE)
[09:29:17.420]                 }
[09:29:17.420]             }
[09:29:17.420]         }
[09:29:17.420]     })
[09:29:17.420]     if (TRUE) {
[09:29:17.420]         base::sink(type = "output", split = FALSE)
[09:29:17.420]         if (TRUE) {
[09:29:17.420]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:17.420]         }
[09:29:17.420]         else {
[09:29:17.420]             ...future.result["stdout"] <- base::list(NULL)
[09:29:17.420]         }
[09:29:17.420]         base::close(...future.stdout)
[09:29:17.420]         ...future.stdout <- NULL
[09:29:17.420]     }
[09:29:17.420]     ...future.result$conditions <- ...future.conditions
[09:29:17.420]     ...future.result$finished <- base::Sys.time()
[09:29:17.420]     ...future.result
[09:29:17.420] }
[09:29:17.422] assign_globals() ...
[09:29:17.423] List of 5
[09:29:17.423]  $ ...future.FUN            :function (x, w, ...)  
[09:29:17.423]  $ MoreArgs                 : NULL
[09:29:17.423]  $ ...future.elements_ii    :List of 2
[09:29:17.423]   ..$ :List of 2
[09:29:17.423]   .. ..$ : num [1:10] 0.407 0.712 0.293 0.479 0.489 ...
[09:29:17.423]   .. ..$ : num [1:10] 0.1238 0.5361 0.4688 0.2324 0.0174 ...
[09:29:17.423]   ..$ :List of 2
[09:29:17.423]   .. ..$ : num [1:10] 5 2 7 5 5 5 6 6 6 5
[09:29:17.423]   .. ..$ : num [1:10] 4 3 5 4 6 9 6 7 4 5
[09:29:17.423]  $ ...future.seeds_ii       : NULL
[09:29:17.423]  $ ...future.globals.maxSize: NULL
[09:29:17.423]  - attr(*, "where")=List of 5
[09:29:17.423]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:17.423]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:17.423]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:17.423]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:17.423]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:17.423]  - attr(*, "resolved")= logi FALSE
[09:29:17.423]  - attr(*, "total_size")= num 2120
[09:29:17.423]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.423]  - attr(*, "already-done")= logi TRUE
[09:29:17.428] - copied ‘...future.FUN’ to environment
[09:29:17.428] - copied ‘MoreArgs’ to environment
[09:29:17.429] - copied ‘...future.elements_ii’ to environment
[09:29:17.429] - copied ‘...future.seeds_ii’ to environment
[09:29:17.429] - copied ‘...future.globals.maxSize’ to environment
[09:29:17.429] assign_globals() ... done
[09:29:17.429] requestCore(): workers = 2
[09:29:17.431] MulticoreFuture started
[09:29:17.432] - Launch lazy future ... done
[09:29:17.432] run() for ‘MulticoreFuture’ ... done
[09:29:17.432] Created future:
[09:29:17.433] plan(): Setting new future strategy stack:
[09:29:17.433] List of future strategies:
[09:29:17.433] 1. sequential:
[09:29:17.433]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:17.433]    - tweaked: FALSE
[09:29:17.433]    - call: NULL
[09:29:17.434] plan(): nbrOfWorkers() = 1
[09:29:17.436] plan(): Setting new future strategy stack:
[09:29:17.436] List of future strategies:
[09:29:17.436] 1. multicore:
[09:29:17.436]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:17.436]    - tweaked: FALSE
[09:29:17.436]    - call: plan(strategy)
[09:29:17.442] plan(): nbrOfWorkers() = 2
[09:29:17.432] MulticoreFuture:
[09:29:17.432] Label: ‘future_Map-1’
[09:29:17.432] Expression:
[09:29:17.432] {
[09:29:17.432]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.432]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:17.432]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.432]         on.exit(options(oopts), add = TRUE)
[09:29:17.432]     }
[09:29:17.432]     {
[09:29:17.432]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.432]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:17.432]         do.call(mapply, args = args)
[09:29:17.432]     }
[09:29:17.432] }
[09:29:17.432] Lazy evaluation: FALSE
[09:29:17.432] Asynchronous evaluation: TRUE
[09:29:17.432] Local evaluation: TRUE
[09:29:17.432] Environment: R_GlobalEnv
[09:29:17.432] Capture standard output: TRUE
[09:29:17.432] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:17.432] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:17.432] Packages: 1 packages (‘stats’)
[09:29:17.432] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:17.432] Resolved: TRUE
[09:29:17.432] Value: <not collected>
[09:29:17.432] Conditions captured: <none>
[09:29:17.432] Early signaling: FALSE
[09:29:17.432] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:17.432] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.443] Chunk #1 of 2 ... DONE
[09:29:17.443] Chunk #2 of 2 ...
[09:29:17.443]  - Finding globals in '...' for chunk #2 ...
[09:29:17.443] getGlobalsAndPackages() ...
[09:29:17.443] Searching for globals...
[09:29:17.444] 
[09:29:17.444] Searching for globals ... DONE
[09:29:17.444] - globals: [0] <none>
[09:29:17.444] getGlobalsAndPackages() ... DONE
[09:29:17.445]    + additional globals found: [n=0] 
[09:29:17.445]    + additional namespaces needed: [n=0] 
[09:29:17.445]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:17.445]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:17.445]  - seeds: <none>
[09:29:17.445]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.445] getGlobalsAndPackages() ...
[09:29:17.446] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.446] Resolving globals: FALSE
[09:29:17.447] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[09:29:17.447] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:17.448] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.448] - packages: [1] ‘stats’
[09:29:17.448] getGlobalsAndPackages() ... DONE
[09:29:17.449] run() for ‘Future’ ...
[09:29:17.449] - state: ‘created’
[09:29:17.449] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:17.458] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.458] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:17.459]   - Field: ‘label’
[09:29:17.459]   - Field: ‘local’
[09:29:17.459]   - Field: ‘owner’
[09:29:17.460]   - Field: ‘envir’
[09:29:17.460]   - Field: ‘workers’
[09:29:17.460]   - Field: ‘packages’
[09:29:17.461]   - Field: ‘gc’
[09:29:17.461]   - Field: ‘job’
[09:29:17.461]   - Field: ‘conditions’
[09:29:17.461]   - Field: ‘expr’
[09:29:17.461]   - Field: ‘uuid’
[09:29:17.462]   - Field: ‘seed’
[09:29:17.462]   - Field: ‘version’
[09:29:17.462]   - Field: ‘result’
[09:29:17.462]   - Field: ‘asynchronous’
[09:29:17.463]   - Field: ‘calls’
[09:29:17.463]   - Field: ‘globals’
[09:29:17.463]   - Field: ‘stdout’
[09:29:17.463]   - Field: ‘earlySignal’
[09:29:17.463]   - Field: ‘lazy’
[09:29:17.464]   - Field: ‘state’
[09:29:17.464] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:17.464] - Launch lazy future ...
[09:29:17.465] Packages needed by the future expression (n = 1): ‘stats’
[09:29:17.465] Packages needed by future strategies (n = 0): <none>
[09:29:17.466] {
[09:29:17.466]     {
[09:29:17.466]         {
[09:29:17.466]             ...future.startTime <- base::Sys.time()
[09:29:17.466]             {
[09:29:17.466]                 {
[09:29:17.466]                   {
[09:29:17.466]                     {
[09:29:17.466]                       {
[09:29:17.466]                         base::local({
[09:29:17.466]                           has_future <- base::requireNamespace("future", 
[09:29:17.466]                             quietly = TRUE)
[09:29:17.466]                           if (has_future) {
[09:29:17.466]                             ns <- base::getNamespace("future")
[09:29:17.466]                             version <- ns[[".package"]][["version"]]
[09:29:17.466]                             if (is.null(version)) 
[09:29:17.466]                               version <- utils::packageVersion("future")
[09:29:17.466]                           }
[09:29:17.466]                           else {
[09:29:17.466]                             version <- NULL
[09:29:17.466]                           }
[09:29:17.466]                           if (!has_future || version < "1.8.0") {
[09:29:17.466]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:17.466]                               "", base::R.version$version.string), 
[09:29:17.466]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:17.466]                                 base::R.version$platform, 8 * 
[09:29:17.466]                                   base::.Machine$sizeof.pointer), 
[09:29:17.466]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:17.466]                                 "release", "version")], collapse = " "), 
[09:29:17.466]                               hostname = base::Sys.info()[["nodename"]])
[09:29:17.466]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:17.466]                               info)
[09:29:17.466]                             info <- base::paste(info, collapse = "; ")
[09:29:17.466]                             if (!has_future) {
[09:29:17.466]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:17.466]                                 info)
[09:29:17.466]                             }
[09:29:17.466]                             else {
[09:29:17.466]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:17.466]                                 info, version)
[09:29:17.466]                             }
[09:29:17.466]                             base::stop(msg)
[09:29:17.466]                           }
[09:29:17.466]                         })
[09:29:17.466]                       }
[09:29:17.466]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:17.466]                       base::options(mc.cores = 1L)
[09:29:17.466]                     }
[09:29:17.466]                     base::local({
[09:29:17.466]                       for (pkg in "stats") {
[09:29:17.466]                         base::loadNamespace(pkg)
[09:29:17.466]                         base::library(pkg, character.only = TRUE)
[09:29:17.466]                       }
[09:29:17.466]                     })
[09:29:17.466]                   }
[09:29:17.466]                   ...future.strategy.old <- future::plan("list")
[09:29:17.466]                   options(future.plan = NULL)
[09:29:17.466]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.466]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:17.466]                 }
[09:29:17.466]                 ...future.workdir <- getwd()
[09:29:17.466]             }
[09:29:17.466]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:17.466]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:17.466]         }
[09:29:17.466]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:17.466]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:17.466]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:17.466]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:17.466]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:17.466]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:17.466]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:17.466]             base::names(...future.oldOptions))
[09:29:17.466]     }
[09:29:17.466]     if (FALSE) {
[09:29:17.466]     }
[09:29:17.466]     else {
[09:29:17.466]         if (TRUE) {
[09:29:17.466]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:17.466]                 open = "w")
[09:29:17.466]         }
[09:29:17.466]         else {
[09:29:17.466]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:17.466]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:17.466]         }
[09:29:17.466]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:17.466]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:17.466]             base::sink(type = "output", split = FALSE)
[09:29:17.466]             base::close(...future.stdout)
[09:29:17.466]         }, add = TRUE)
[09:29:17.466]     }
[09:29:17.466]     ...future.frame <- base::sys.nframe()
[09:29:17.466]     ...future.conditions <- base::list()
[09:29:17.466]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:17.466]     if (FALSE) {
[09:29:17.466]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:17.466]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:17.466]     }
[09:29:17.466]     ...future.result <- base::tryCatch({
[09:29:17.466]         base::withCallingHandlers({
[09:29:17.466]             ...future.value <- base::withVisible(base::local({
[09:29:17.466]                 withCallingHandlers({
[09:29:17.466]                   {
[09:29:17.466]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.466]                     if (!identical(...future.globals.maxSize.org, 
[09:29:17.466]                       ...future.globals.maxSize)) {
[09:29:17.466]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.466]                       on.exit(options(oopts), add = TRUE)
[09:29:17.466]                     }
[09:29:17.466]                     {
[09:29:17.466]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.466]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:17.466]                         USE.NAMES = FALSE)
[09:29:17.466]                       do.call(mapply, args = args)
[09:29:17.466]                     }
[09:29:17.466]                   }
[09:29:17.466]                 }, immediateCondition = function(cond) {
[09:29:17.466]                   save_rds <- function (object, pathname, ...) 
[09:29:17.466]                   {
[09:29:17.466]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:17.466]                     if (file_test("-f", pathname_tmp)) {
[09:29:17.466]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.466]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:17.466]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.466]                         fi_tmp[["mtime"]])
[09:29:17.466]                     }
[09:29:17.466]                     tryCatch({
[09:29:17.466]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:17.466]                     }, error = function(ex) {
[09:29:17.466]                       msg <- conditionMessage(ex)
[09:29:17.466]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.466]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:17.466]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.466]                         fi_tmp[["mtime"]], msg)
[09:29:17.466]                       ex$message <- msg
[09:29:17.466]                       stop(ex)
[09:29:17.466]                     })
[09:29:17.466]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:17.466]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:17.466]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:17.466]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.466]                       fi <- file.info(pathname)
[09:29:17.466]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:17.466]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.466]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:17.466]                         fi[["size"]], fi[["mtime"]])
[09:29:17.466]                       stop(msg)
[09:29:17.466]                     }
[09:29:17.466]                     invisible(pathname)
[09:29:17.466]                   }
[09:29:17.466]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:17.466]                     rootPath = tempdir()) 
[09:29:17.466]                   {
[09:29:17.466]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:17.466]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:17.466]                       tmpdir = path, fileext = ".rds")
[09:29:17.466]                     save_rds(obj, file)
[09:29:17.466]                   }
[09:29:17.466]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:17.466]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.466]                   {
[09:29:17.466]                     inherits <- base::inherits
[09:29:17.466]                     invokeRestart <- base::invokeRestart
[09:29:17.466]                     is.null <- base::is.null
[09:29:17.466]                     muffled <- FALSE
[09:29:17.466]                     if (inherits(cond, "message")) {
[09:29:17.466]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:17.466]                       if (muffled) 
[09:29:17.466]                         invokeRestart("muffleMessage")
[09:29:17.466]                     }
[09:29:17.466]                     else if (inherits(cond, "warning")) {
[09:29:17.466]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:17.466]                       if (muffled) 
[09:29:17.466]                         invokeRestart("muffleWarning")
[09:29:17.466]                     }
[09:29:17.466]                     else if (inherits(cond, "condition")) {
[09:29:17.466]                       if (!is.null(pattern)) {
[09:29:17.466]                         computeRestarts <- base::computeRestarts
[09:29:17.466]                         grepl <- base::grepl
[09:29:17.466]                         restarts <- computeRestarts(cond)
[09:29:17.466]                         for (restart in restarts) {
[09:29:17.466]                           name <- restart$name
[09:29:17.466]                           if (is.null(name)) 
[09:29:17.466]                             next
[09:29:17.466]                           if (!grepl(pattern, name)) 
[09:29:17.466]                             next
[09:29:17.466]                           invokeRestart(restart)
[09:29:17.466]                           muffled <- TRUE
[09:29:17.466]                           break
[09:29:17.466]                         }
[09:29:17.466]                       }
[09:29:17.466]                     }
[09:29:17.466]                     invisible(muffled)
[09:29:17.466]                   }
[09:29:17.466]                   muffleCondition(cond)
[09:29:17.466]                 })
[09:29:17.466]             }))
[09:29:17.466]             future::FutureResult(value = ...future.value$value, 
[09:29:17.466]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.466]                   ...future.rng), globalenv = if (FALSE) 
[09:29:17.466]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:17.466]                     ...future.globalenv.names))
[09:29:17.466]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:17.466]         }, condition = base::local({
[09:29:17.466]             c <- base::c
[09:29:17.466]             inherits <- base::inherits
[09:29:17.466]             invokeRestart <- base::invokeRestart
[09:29:17.466]             length <- base::length
[09:29:17.466]             list <- base::list
[09:29:17.466]             seq.int <- base::seq.int
[09:29:17.466]             signalCondition <- base::signalCondition
[09:29:17.466]             sys.calls <- base::sys.calls
[09:29:17.466]             `[[` <- base::`[[`
[09:29:17.466]             `+` <- base::`+`
[09:29:17.466]             `<<-` <- base::`<<-`
[09:29:17.466]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:17.466]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:17.466]                   3L)]
[09:29:17.466]             }
[09:29:17.466]             function(cond) {
[09:29:17.466]                 is_error <- inherits(cond, "error")
[09:29:17.466]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:17.466]                   NULL)
[09:29:17.466]                 if (is_error) {
[09:29:17.466]                   sessionInformation <- function() {
[09:29:17.466]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:17.466]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:17.466]                       search = base::search(), system = base::Sys.info())
[09:29:17.466]                   }
[09:29:17.466]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.466]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:17.466]                     cond$call), session = sessionInformation(), 
[09:29:17.466]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:17.466]                   signalCondition(cond)
[09:29:17.466]                 }
[09:29:17.466]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:17.466]                 "immediateCondition"))) {
[09:29:17.466]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:17.466]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.466]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:17.466]                   if (TRUE && !signal) {
[09:29:17.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.466]                     {
[09:29:17.466]                       inherits <- base::inherits
[09:29:17.466]                       invokeRestart <- base::invokeRestart
[09:29:17.466]                       is.null <- base::is.null
[09:29:17.466]                       muffled <- FALSE
[09:29:17.466]                       if (inherits(cond, "message")) {
[09:29:17.466]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.466]                         if (muffled) 
[09:29:17.466]                           invokeRestart("muffleMessage")
[09:29:17.466]                       }
[09:29:17.466]                       else if (inherits(cond, "warning")) {
[09:29:17.466]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.466]                         if (muffled) 
[09:29:17.466]                           invokeRestart("muffleWarning")
[09:29:17.466]                       }
[09:29:17.466]                       else if (inherits(cond, "condition")) {
[09:29:17.466]                         if (!is.null(pattern)) {
[09:29:17.466]                           computeRestarts <- base::computeRestarts
[09:29:17.466]                           grepl <- base::grepl
[09:29:17.466]                           restarts <- computeRestarts(cond)
[09:29:17.466]                           for (restart in restarts) {
[09:29:17.466]                             name <- restart$name
[09:29:17.466]                             if (is.null(name)) 
[09:29:17.466]                               next
[09:29:17.466]                             if (!grepl(pattern, name)) 
[09:29:17.466]                               next
[09:29:17.466]                             invokeRestart(restart)
[09:29:17.466]                             muffled <- TRUE
[09:29:17.466]                             break
[09:29:17.466]                           }
[09:29:17.466]                         }
[09:29:17.466]                       }
[09:29:17.466]                       invisible(muffled)
[09:29:17.466]                     }
[09:29:17.466]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.466]                   }
[09:29:17.466]                 }
[09:29:17.466]                 else {
[09:29:17.466]                   if (TRUE) {
[09:29:17.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.466]                     {
[09:29:17.466]                       inherits <- base::inherits
[09:29:17.466]                       invokeRestart <- base::invokeRestart
[09:29:17.466]                       is.null <- base::is.null
[09:29:17.466]                       muffled <- FALSE
[09:29:17.466]                       if (inherits(cond, "message")) {
[09:29:17.466]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.466]                         if (muffled) 
[09:29:17.466]                           invokeRestart("muffleMessage")
[09:29:17.466]                       }
[09:29:17.466]                       else if (inherits(cond, "warning")) {
[09:29:17.466]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.466]                         if (muffled) 
[09:29:17.466]                           invokeRestart("muffleWarning")
[09:29:17.466]                       }
[09:29:17.466]                       else if (inherits(cond, "condition")) {
[09:29:17.466]                         if (!is.null(pattern)) {
[09:29:17.466]                           computeRestarts <- base::computeRestarts
[09:29:17.466]                           grepl <- base::grepl
[09:29:17.466]                           restarts <- computeRestarts(cond)
[09:29:17.466]                           for (restart in restarts) {
[09:29:17.466]                             name <- restart$name
[09:29:17.466]                             if (is.null(name)) 
[09:29:17.466]                               next
[09:29:17.466]                             if (!grepl(pattern, name)) 
[09:29:17.466]                               next
[09:29:17.466]                             invokeRestart(restart)
[09:29:17.466]                             muffled <- TRUE
[09:29:17.466]                             break
[09:29:17.466]                           }
[09:29:17.466]                         }
[09:29:17.466]                       }
[09:29:17.466]                       invisible(muffled)
[09:29:17.466]                     }
[09:29:17.466]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.466]                   }
[09:29:17.466]                 }
[09:29:17.466]             }
[09:29:17.466]         }))
[09:29:17.466]     }, error = function(ex) {
[09:29:17.466]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:17.466]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.466]                 ...future.rng), started = ...future.startTime, 
[09:29:17.466]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:17.466]             version = "1.8"), class = "FutureResult")
[09:29:17.466]     }, finally = {
[09:29:17.466]         if (!identical(...future.workdir, getwd())) 
[09:29:17.466]             setwd(...future.workdir)
[09:29:17.466]         {
[09:29:17.466]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:17.466]                 ...future.oldOptions$nwarnings <- NULL
[09:29:17.466]             }
[09:29:17.466]             base::options(...future.oldOptions)
[09:29:17.466]             if (.Platform$OS.type == "windows") {
[09:29:17.466]                 old_names <- names(...future.oldEnvVars)
[09:29:17.466]                 envs <- base::Sys.getenv()
[09:29:17.466]                 names <- names(envs)
[09:29:17.466]                 common <- intersect(names, old_names)
[09:29:17.466]                 added <- setdiff(names, old_names)
[09:29:17.466]                 removed <- setdiff(old_names, names)
[09:29:17.466]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:17.466]                   envs[common]]
[09:29:17.466]                 NAMES <- toupper(changed)
[09:29:17.466]                 args <- list()
[09:29:17.466]                 for (kk in seq_along(NAMES)) {
[09:29:17.466]                   name <- changed[[kk]]
[09:29:17.466]                   NAME <- NAMES[[kk]]
[09:29:17.466]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.466]                     next
[09:29:17.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.466]                 }
[09:29:17.466]                 NAMES <- toupper(added)
[09:29:17.466]                 for (kk in seq_along(NAMES)) {
[09:29:17.466]                   name <- added[[kk]]
[09:29:17.466]                   NAME <- NAMES[[kk]]
[09:29:17.466]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.466]                     next
[09:29:17.466]                   args[[name]] <- ""
[09:29:17.466]                 }
[09:29:17.466]                 NAMES <- toupper(removed)
[09:29:17.466]                 for (kk in seq_along(NAMES)) {
[09:29:17.466]                   name <- removed[[kk]]
[09:29:17.466]                   NAME <- NAMES[[kk]]
[09:29:17.466]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.466]                     next
[09:29:17.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.466]                 }
[09:29:17.466]                 if (length(args) > 0) 
[09:29:17.466]                   base::do.call(base::Sys.setenv, args = args)
[09:29:17.466]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:17.466]             }
[09:29:17.466]             else {
[09:29:17.466]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:17.466]             }
[09:29:17.466]             {
[09:29:17.466]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:17.466]                   0L) {
[09:29:17.466]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:17.466]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:17.466]                   base::options(opts)
[09:29:17.466]                 }
[09:29:17.466]                 {
[09:29:17.466]                   {
[09:29:17.466]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:17.466]                     NULL
[09:29:17.466]                   }
[09:29:17.466]                   options(future.plan = NULL)
[09:29:17.466]                   if (is.na(NA_character_)) 
[09:29:17.466]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.466]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:17.466]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:17.466]                     .init = FALSE)
[09:29:17.466]                 }
[09:29:17.466]             }
[09:29:17.466]         }
[09:29:17.466]     })
[09:29:17.466]     if (TRUE) {
[09:29:17.466]         base::sink(type = "output", split = FALSE)
[09:29:17.466]         if (TRUE) {
[09:29:17.466]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:17.466]         }
[09:29:17.466]         else {
[09:29:17.466]             ...future.result["stdout"] <- base::list(NULL)
[09:29:17.466]         }
[09:29:17.466]         base::close(...future.stdout)
[09:29:17.466]         ...future.stdout <- NULL
[09:29:17.466]     }
[09:29:17.466]     ...future.result$conditions <- ...future.conditions
[09:29:17.466]     ...future.result$finished <- base::Sys.time()
[09:29:17.466]     ...future.result
[09:29:17.466] }
[09:29:17.469] assign_globals() ...
[09:29:17.469] List of 5
[09:29:17.469]  $ ...future.FUN            :function (x, w, ...)  
[09:29:17.469]  $ MoreArgs                 : NULL
[09:29:17.469]  $ ...future.elements_ii    :List of 2
[09:29:17.469]   ..$ :List of 3
[09:29:17.469]   .. ..$ : num [1:10] 0.7683 0.1474 0.0996 0.4401 0.9013 ...
[09:29:17.469]   .. ..$ : num [1:10] 0.679 0.8843 0.0176 0.8344 0.8093 ...
[09:29:17.469]   .. ..$ : num [1:10] 0.2088 0.3703 0.8569 0.0665 0.8077 ...
[09:29:17.469]   ..$ :List of 3
[09:29:17.469]   .. ..$ : num [1:10] 10 9 7 6 6 7 6 9 9 5
[09:29:17.469]   .. ..$ : num [1:10] 4 5 6 4 12 5 6 2 9 3
[09:29:17.469]   .. ..$ : num [1:10] 3 7 7 5 9 4 8 8 3 5
[09:29:17.469]  $ ...future.seeds_ii       : NULL
[09:29:17.469]  $ ...future.globals.maxSize: NULL
[09:29:17.469]  - attr(*, "where")=List of 5
[09:29:17.469]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:17.469]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:17.469]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:17.469]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:17.469]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:17.469]  - attr(*, "resolved")= logi FALSE
[09:29:17.469]  - attr(*, "total_size")= num 2472
[09:29:17.469]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.469]  - attr(*, "already-done")= logi TRUE
[09:29:17.479] - copied ‘...future.FUN’ to environment
[09:29:17.479] - copied ‘MoreArgs’ to environment
[09:29:17.479] - copied ‘...future.elements_ii’ to environment
[09:29:17.479] - copied ‘...future.seeds_ii’ to environment
[09:29:17.479] - copied ‘...future.globals.maxSize’ to environment
[09:29:17.479] assign_globals() ... done
[09:29:17.479] requestCore(): workers = 2
[09:29:17.482] MulticoreFuture started
[09:29:17.482] - Launch lazy future ... done
[09:29:17.482] run() for ‘MulticoreFuture’ ... done
[09:29:17.482] Created future:
[09:29:17.483] plan(): Setting new future strategy stack:
[09:29:17.483] List of future strategies:
[09:29:17.483] 1. sequential:
[09:29:17.483]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:17.483]    - tweaked: FALSE
[09:29:17.483]    - call: NULL
[09:29:17.484] plan(): nbrOfWorkers() = 1
[09:29:17.486] plan(): Setting new future strategy stack:
[09:29:17.486] List of future strategies:
[09:29:17.486] 1. multicore:
[09:29:17.486]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:17.486]    - tweaked: FALSE
[09:29:17.486]    - call: plan(strategy)
[09:29:17.491] plan(): nbrOfWorkers() = 2
[09:29:17.483] MulticoreFuture:
[09:29:17.483] Label: ‘future_Map-2’
[09:29:17.483] Expression:
[09:29:17.483] {
[09:29:17.483]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.483]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:17.483]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.483]         on.exit(options(oopts), add = TRUE)
[09:29:17.483]     }
[09:29:17.483]     {
[09:29:17.483]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.483]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:17.483]         do.call(mapply, args = args)
[09:29:17.483]     }
[09:29:17.483] }
[09:29:17.483] Lazy evaluation: FALSE
[09:29:17.483] Asynchronous evaluation: TRUE
[09:29:17.483] Local evaluation: TRUE
[09:29:17.483] Environment: R_GlobalEnv
[09:29:17.483] Capture standard output: TRUE
[09:29:17.483] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:17.483] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:17.483] Packages: 1 packages (‘stats’)
[09:29:17.483] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:17.483] Resolved: TRUE
[09:29:17.483] Value: <not collected>
[09:29:17.483] Conditions captured: <none>
[09:29:17.483] Early signaling: FALSE
[09:29:17.483] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:17.483] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.492] Chunk #2 of 2 ... DONE
[09:29:17.493] Launching 2 futures (chunks) ... DONE
[09:29:17.493] Resolving 2 futures (chunks) ...
[09:29:17.493] resolve() on list ...
[09:29:17.493]  recursive: 0
[09:29:17.493]  length: 2
[09:29:17.493] 
[09:29:17.494] Future #1
[09:29:17.494] result() for MulticoreFuture ...
[09:29:17.495] result() for MulticoreFuture ...
[09:29:17.495] result() for MulticoreFuture ... done
[09:29:17.495] result() for MulticoreFuture ... done
[09:29:17.495] result() for MulticoreFuture ...
[09:29:17.495] result() for MulticoreFuture ... done
[09:29:17.495] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:17.496] - nx: 2
[09:29:17.496] - relay: TRUE
[09:29:17.496] - stdout: TRUE
[09:29:17.496] - signal: TRUE
[09:29:17.496] - resignal: FALSE
[09:29:17.496] - force: TRUE
[09:29:17.496] - relayed: [n=2] FALSE, FALSE
[09:29:17.497] - queued futures: [n=2] FALSE, FALSE
[09:29:17.497]  - until=1
[09:29:17.497]  - relaying element #1
[09:29:17.497] result() for MulticoreFuture ...
[09:29:17.497] result() for MulticoreFuture ... done
[09:29:17.497] result() for MulticoreFuture ...
[09:29:17.497] result() for MulticoreFuture ... done
[09:29:17.498] result() for MulticoreFuture ...
[09:29:17.498] result() for MulticoreFuture ... done
[09:29:17.498] result() for MulticoreFuture ...
[09:29:17.498] result() for MulticoreFuture ... done
[09:29:17.498] - relayed: [n=2] TRUE, FALSE
[09:29:17.498] - queued futures: [n=2] TRUE, FALSE
[09:29:17.499] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:17.499]  length: 1 (resolved future 1)
[09:29:17.499] Future #2
[09:29:17.499] result() for MulticoreFuture ...
[09:29:17.500] result() for MulticoreFuture ...
[09:29:17.500] result() for MulticoreFuture ... done
[09:29:17.501] result() for MulticoreFuture ... done
[09:29:17.501] result() for MulticoreFuture ...
[09:29:17.505] result() for MulticoreFuture ... done
[09:29:17.505] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:17.505] - nx: 2
[09:29:17.506] - relay: TRUE
[09:29:17.506] - stdout: TRUE
[09:29:17.506] - signal: TRUE
[09:29:17.506] - resignal: FALSE
[09:29:17.506] - force: TRUE
[09:29:17.506] - relayed: [n=2] TRUE, FALSE
[09:29:17.507] - queued futures: [n=2] TRUE, FALSE
[09:29:17.507]  - until=2
[09:29:17.507]  - relaying element #2
[09:29:17.507] result() for MulticoreFuture ...
[09:29:17.507] result() for MulticoreFuture ... done
[09:29:17.507] result() for MulticoreFuture ...
[09:29:17.508] result() for MulticoreFuture ... done
[09:29:17.508] result() for MulticoreFuture ...
[09:29:17.508] result() for MulticoreFuture ... done
[09:29:17.508] result() for MulticoreFuture ...
[09:29:17.508] result() for MulticoreFuture ... done
[09:29:17.508] - relayed: [n=2] TRUE, TRUE
[09:29:17.509] - queued futures: [n=2] TRUE, TRUE
[09:29:17.509] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:17.509]  length: 0 (resolved future 2)
[09:29:17.509] Relaying remaining futures
[09:29:17.509] signalConditionsASAP(NULL, pos=0) ...
[09:29:17.509] - nx: 2
[09:29:17.509] - relay: TRUE
[09:29:17.510] - stdout: TRUE
[09:29:17.510] - signal: TRUE
[09:29:17.510] - resignal: FALSE
[09:29:17.510] - force: TRUE
[09:29:17.510] - relayed: [n=2] TRUE, TRUE
[09:29:17.510] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:17.510] - relayed: [n=2] TRUE, TRUE
[09:29:17.511] - queued futures: [n=2] TRUE, TRUE
[09:29:17.511] signalConditionsASAP(NULL, pos=0) ... done
[09:29:17.511] resolve() on list ... DONE
[09:29:17.511] result() for MulticoreFuture ...
[09:29:17.511] result() for MulticoreFuture ... done
[09:29:17.511] result() for MulticoreFuture ...
[09:29:17.511] result() for MulticoreFuture ... done
[09:29:17.511] result() for MulticoreFuture ...
[09:29:17.512] result() for MulticoreFuture ... done
[09:29:17.512] result() for MulticoreFuture ...
[09:29:17.512] result() for MulticoreFuture ... done
[09:29:17.512]  - Number of value chunks collected: 2
[09:29:17.512] Resolving 2 futures (chunks) ... DONE
[09:29:17.512] Reducing values from 2 chunks ...
[09:29:17.512]  - Number of values collected after concatenation: 5
[09:29:17.513]  - Number of values expected: 5
[09:29:17.513] Reducing values from 2 chunks ... DONE
[09:29:17.513] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[09:29:17.515] future_mapply() ...
[09:29:17.519] Number of chunks: 2
[09:29:17.519] getGlobalsAndPackagesXApply() ...
[09:29:17.519]  - future.globals: TRUE
[09:29:17.519] getGlobalsAndPackages() ...
[09:29:17.520] Searching for globals...
[09:29:17.520] - globals found: [1] ‘FUN’
[09:29:17.520] Searching for globals ... DONE
[09:29:17.521] Resolving globals: FALSE
[09:29:17.521] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:17.521] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:17.521] - globals: [1] ‘FUN’
[09:29:17.521] 
[09:29:17.522] getGlobalsAndPackages() ... DONE
[09:29:17.522]  - globals found/used: [n=1] ‘FUN’
[09:29:17.522]  - needed namespaces: [n=0] 
[09:29:17.522] Finding globals ... DONE
[09:29:17.522] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:17.522] List of 2
[09:29:17.522]  $ ...future.FUN:function (e1, e2)  
[09:29:17.522]  $ MoreArgs     : NULL
[09:29:17.522]  - attr(*, "where")=List of 2
[09:29:17.522]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:17.522]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:17.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.522]  - attr(*, "resolved")= logi FALSE
[09:29:17.522]  - attr(*, "total_size")= num NA
[09:29:17.525] Packages to be attached in all futures: [n=0] 
[09:29:17.525] getGlobalsAndPackagesXApply() ... DONE
[09:29:17.525] Number of futures (= number of chunks): 2
[09:29:17.525] Launching 2 futures (chunks) ...
[09:29:17.525] Chunk #1 of 2 ...
[09:29:17.525]  - Finding globals in '...' for chunk #1 ...
[09:29:17.526] getGlobalsAndPackages() ...
[09:29:17.526] Searching for globals...
[09:29:17.526] 
[09:29:17.526] Searching for globals ... DONE
[09:29:17.526] - globals: [0] <none>
[09:29:17.526] getGlobalsAndPackages() ... DONE
[09:29:17.526]    + additional globals found: [n=0] 
[09:29:17.526]    + additional namespaces needed: [n=0] 
[09:29:17.527]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:17.527]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:17.527]  - seeds: <none>
[09:29:17.527]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.527] getGlobalsAndPackages() ...
[09:29:17.527] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.527] Resolving globals: FALSE
[09:29:17.528] The total size of the 5 globals is 168 bytes (168 bytes)
[09:29:17.528] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:17.528] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.528] 
[09:29:17.528] getGlobalsAndPackages() ... DONE
[09:29:17.529] run() for ‘Future’ ...
[09:29:17.529] - state: ‘created’
[09:29:17.529] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:17.535] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.535] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:17.535]   - Field: ‘label’
[09:29:17.535]   - Field: ‘local’
[09:29:17.535]   - Field: ‘owner’
[09:29:17.536]   - Field: ‘envir’
[09:29:17.536]   - Field: ‘workers’
[09:29:17.536]   - Field: ‘packages’
[09:29:17.536]   - Field: ‘gc’
[09:29:17.536]   - Field: ‘job’
[09:29:17.536]   - Field: ‘conditions’
[09:29:17.536]   - Field: ‘expr’
[09:29:17.536]   - Field: ‘uuid’
[09:29:17.536]   - Field: ‘seed’
[09:29:17.537]   - Field: ‘version’
[09:29:17.537]   - Field: ‘result’
[09:29:17.537]   - Field: ‘asynchronous’
[09:29:17.537]   - Field: ‘calls’
[09:29:17.537]   - Field: ‘globals’
[09:29:17.537]   - Field: ‘stdout’
[09:29:17.537]   - Field: ‘earlySignal’
[09:29:17.537]   - Field: ‘lazy’
[09:29:17.537]   - Field: ‘state’
[09:29:17.537] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:17.538] - Launch lazy future ...
[09:29:17.538] Packages needed by the future expression (n = 0): <none>
[09:29:17.538] Packages needed by future strategies (n = 0): <none>
[09:29:17.538] {
[09:29:17.538]     {
[09:29:17.538]         {
[09:29:17.538]             ...future.startTime <- base::Sys.time()
[09:29:17.538]             {
[09:29:17.538]                 {
[09:29:17.538]                   {
[09:29:17.538]                     {
[09:29:17.538]                       base::local({
[09:29:17.538]                         has_future <- base::requireNamespace("future", 
[09:29:17.538]                           quietly = TRUE)
[09:29:17.538]                         if (has_future) {
[09:29:17.538]                           ns <- base::getNamespace("future")
[09:29:17.538]                           version <- ns[[".package"]][["version"]]
[09:29:17.538]                           if (is.null(version)) 
[09:29:17.538]                             version <- utils::packageVersion("future")
[09:29:17.538]                         }
[09:29:17.538]                         else {
[09:29:17.538]                           version <- NULL
[09:29:17.538]                         }
[09:29:17.538]                         if (!has_future || version < "1.8.0") {
[09:29:17.538]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:17.538]                             "", base::R.version$version.string), 
[09:29:17.538]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:17.538]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:17.538]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:17.538]                               "release", "version")], collapse = " "), 
[09:29:17.538]                             hostname = base::Sys.info()[["nodename"]])
[09:29:17.538]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:17.538]                             info)
[09:29:17.538]                           info <- base::paste(info, collapse = "; ")
[09:29:17.538]                           if (!has_future) {
[09:29:17.538]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:17.538]                               info)
[09:29:17.538]                           }
[09:29:17.538]                           else {
[09:29:17.538]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:17.538]                               info, version)
[09:29:17.538]                           }
[09:29:17.538]                           base::stop(msg)
[09:29:17.538]                         }
[09:29:17.538]                       })
[09:29:17.538]                     }
[09:29:17.538]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:17.538]                     base::options(mc.cores = 1L)
[09:29:17.538]                   }
[09:29:17.538]                   ...future.strategy.old <- future::plan("list")
[09:29:17.538]                   options(future.plan = NULL)
[09:29:17.538]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.538]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:17.538]                 }
[09:29:17.538]                 ...future.workdir <- getwd()
[09:29:17.538]             }
[09:29:17.538]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:17.538]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:17.538]         }
[09:29:17.538]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:17.538]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:17.538]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:17.538]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:17.538]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:17.538]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:17.538]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:17.538]             base::names(...future.oldOptions))
[09:29:17.538]     }
[09:29:17.538]     if (FALSE) {
[09:29:17.538]     }
[09:29:17.538]     else {
[09:29:17.538]         if (TRUE) {
[09:29:17.538]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:17.538]                 open = "w")
[09:29:17.538]         }
[09:29:17.538]         else {
[09:29:17.538]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:17.538]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:17.538]         }
[09:29:17.538]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:17.538]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:17.538]             base::sink(type = "output", split = FALSE)
[09:29:17.538]             base::close(...future.stdout)
[09:29:17.538]         }, add = TRUE)
[09:29:17.538]     }
[09:29:17.538]     ...future.frame <- base::sys.nframe()
[09:29:17.538]     ...future.conditions <- base::list()
[09:29:17.538]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:17.538]     if (FALSE) {
[09:29:17.538]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:17.538]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:17.538]     }
[09:29:17.538]     ...future.result <- base::tryCatch({
[09:29:17.538]         base::withCallingHandlers({
[09:29:17.538]             ...future.value <- base::withVisible(base::local({
[09:29:17.538]                 withCallingHandlers({
[09:29:17.538]                   {
[09:29:17.538]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.538]                     if (!identical(...future.globals.maxSize.org, 
[09:29:17.538]                       ...future.globals.maxSize)) {
[09:29:17.538]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.538]                       on.exit(options(oopts), add = TRUE)
[09:29:17.538]                     }
[09:29:17.538]                     {
[09:29:17.538]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.538]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:17.538]                         USE.NAMES = FALSE)
[09:29:17.538]                       do.call(mapply, args = args)
[09:29:17.538]                     }
[09:29:17.538]                   }
[09:29:17.538]                 }, immediateCondition = function(cond) {
[09:29:17.538]                   save_rds <- function (object, pathname, ...) 
[09:29:17.538]                   {
[09:29:17.538]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:17.538]                     if (file_test("-f", pathname_tmp)) {
[09:29:17.538]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.538]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:17.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.538]                         fi_tmp[["mtime"]])
[09:29:17.538]                     }
[09:29:17.538]                     tryCatch({
[09:29:17.538]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:17.538]                     }, error = function(ex) {
[09:29:17.538]                       msg <- conditionMessage(ex)
[09:29:17.538]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.538]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:17.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.538]                         fi_tmp[["mtime"]], msg)
[09:29:17.538]                       ex$message <- msg
[09:29:17.538]                       stop(ex)
[09:29:17.538]                     })
[09:29:17.538]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:17.538]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:17.538]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:17.538]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.538]                       fi <- file.info(pathname)
[09:29:17.538]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:17.538]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.538]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:17.538]                         fi[["size"]], fi[["mtime"]])
[09:29:17.538]                       stop(msg)
[09:29:17.538]                     }
[09:29:17.538]                     invisible(pathname)
[09:29:17.538]                   }
[09:29:17.538]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:17.538]                     rootPath = tempdir()) 
[09:29:17.538]                   {
[09:29:17.538]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:17.538]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:17.538]                       tmpdir = path, fileext = ".rds")
[09:29:17.538]                     save_rds(obj, file)
[09:29:17.538]                   }
[09:29:17.538]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:17.538]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.538]                   {
[09:29:17.538]                     inherits <- base::inherits
[09:29:17.538]                     invokeRestart <- base::invokeRestart
[09:29:17.538]                     is.null <- base::is.null
[09:29:17.538]                     muffled <- FALSE
[09:29:17.538]                     if (inherits(cond, "message")) {
[09:29:17.538]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:17.538]                       if (muffled) 
[09:29:17.538]                         invokeRestart("muffleMessage")
[09:29:17.538]                     }
[09:29:17.538]                     else if (inherits(cond, "warning")) {
[09:29:17.538]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:17.538]                       if (muffled) 
[09:29:17.538]                         invokeRestart("muffleWarning")
[09:29:17.538]                     }
[09:29:17.538]                     else if (inherits(cond, "condition")) {
[09:29:17.538]                       if (!is.null(pattern)) {
[09:29:17.538]                         computeRestarts <- base::computeRestarts
[09:29:17.538]                         grepl <- base::grepl
[09:29:17.538]                         restarts <- computeRestarts(cond)
[09:29:17.538]                         for (restart in restarts) {
[09:29:17.538]                           name <- restart$name
[09:29:17.538]                           if (is.null(name)) 
[09:29:17.538]                             next
[09:29:17.538]                           if (!grepl(pattern, name)) 
[09:29:17.538]                             next
[09:29:17.538]                           invokeRestart(restart)
[09:29:17.538]                           muffled <- TRUE
[09:29:17.538]                           break
[09:29:17.538]                         }
[09:29:17.538]                       }
[09:29:17.538]                     }
[09:29:17.538]                     invisible(muffled)
[09:29:17.538]                   }
[09:29:17.538]                   muffleCondition(cond)
[09:29:17.538]                 })
[09:29:17.538]             }))
[09:29:17.538]             future::FutureResult(value = ...future.value$value, 
[09:29:17.538]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.538]                   ...future.rng), globalenv = if (FALSE) 
[09:29:17.538]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:17.538]                     ...future.globalenv.names))
[09:29:17.538]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:17.538]         }, condition = base::local({
[09:29:17.538]             c <- base::c
[09:29:17.538]             inherits <- base::inherits
[09:29:17.538]             invokeRestart <- base::invokeRestart
[09:29:17.538]             length <- base::length
[09:29:17.538]             list <- base::list
[09:29:17.538]             seq.int <- base::seq.int
[09:29:17.538]             signalCondition <- base::signalCondition
[09:29:17.538]             sys.calls <- base::sys.calls
[09:29:17.538]             `[[` <- base::`[[`
[09:29:17.538]             `+` <- base::`+`
[09:29:17.538]             `<<-` <- base::`<<-`
[09:29:17.538]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:17.538]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:17.538]                   3L)]
[09:29:17.538]             }
[09:29:17.538]             function(cond) {
[09:29:17.538]                 is_error <- inherits(cond, "error")
[09:29:17.538]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:17.538]                   NULL)
[09:29:17.538]                 if (is_error) {
[09:29:17.538]                   sessionInformation <- function() {
[09:29:17.538]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:17.538]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:17.538]                       search = base::search(), system = base::Sys.info())
[09:29:17.538]                   }
[09:29:17.538]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.538]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:17.538]                     cond$call), session = sessionInformation(), 
[09:29:17.538]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:17.538]                   signalCondition(cond)
[09:29:17.538]                 }
[09:29:17.538]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:17.538]                 "immediateCondition"))) {
[09:29:17.538]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:17.538]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.538]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:17.538]                   if (TRUE && !signal) {
[09:29:17.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.538]                     {
[09:29:17.538]                       inherits <- base::inherits
[09:29:17.538]                       invokeRestart <- base::invokeRestart
[09:29:17.538]                       is.null <- base::is.null
[09:29:17.538]                       muffled <- FALSE
[09:29:17.538]                       if (inherits(cond, "message")) {
[09:29:17.538]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.538]                         if (muffled) 
[09:29:17.538]                           invokeRestart("muffleMessage")
[09:29:17.538]                       }
[09:29:17.538]                       else if (inherits(cond, "warning")) {
[09:29:17.538]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.538]                         if (muffled) 
[09:29:17.538]                           invokeRestart("muffleWarning")
[09:29:17.538]                       }
[09:29:17.538]                       else if (inherits(cond, "condition")) {
[09:29:17.538]                         if (!is.null(pattern)) {
[09:29:17.538]                           computeRestarts <- base::computeRestarts
[09:29:17.538]                           grepl <- base::grepl
[09:29:17.538]                           restarts <- computeRestarts(cond)
[09:29:17.538]                           for (restart in restarts) {
[09:29:17.538]                             name <- restart$name
[09:29:17.538]                             if (is.null(name)) 
[09:29:17.538]                               next
[09:29:17.538]                             if (!grepl(pattern, name)) 
[09:29:17.538]                               next
[09:29:17.538]                             invokeRestart(restart)
[09:29:17.538]                             muffled <- TRUE
[09:29:17.538]                             break
[09:29:17.538]                           }
[09:29:17.538]                         }
[09:29:17.538]                       }
[09:29:17.538]                       invisible(muffled)
[09:29:17.538]                     }
[09:29:17.538]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.538]                   }
[09:29:17.538]                 }
[09:29:17.538]                 else {
[09:29:17.538]                   if (TRUE) {
[09:29:17.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.538]                     {
[09:29:17.538]                       inherits <- base::inherits
[09:29:17.538]                       invokeRestart <- base::invokeRestart
[09:29:17.538]                       is.null <- base::is.null
[09:29:17.538]                       muffled <- FALSE
[09:29:17.538]                       if (inherits(cond, "message")) {
[09:29:17.538]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.538]                         if (muffled) 
[09:29:17.538]                           invokeRestart("muffleMessage")
[09:29:17.538]                       }
[09:29:17.538]                       else if (inherits(cond, "warning")) {
[09:29:17.538]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.538]                         if (muffled) 
[09:29:17.538]                           invokeRestart("muffleWarning")
[09:29:17.538]                       }
[09:29:17.538]                       else if (inherits(cond, "condition")) {
[09:29:17.538]                         if (!is.null(pattern)) {
[09:29:17.538]                           computeRestarts <- base::computeRestarts
[09:29:17.538]                           grepl <- base::grepl
[09:29:17.538]                           restarts <- computeRestarts(cond)
[09:29:17.538]                           for (restart in restarts) {
[09:29:17.538]                             name <- restart$name
[09:29:17.538]                             if (is.null(name)) 
[09:29:17.538]                               next
[09:29:17.538]                             if (!grepl(pattern, name)) 
[09:29:17.538]                               next
[09:29:17.538]                             invokeRestart(restart)
[09:29:17.538]                             muffled <- TRUE
[09:29:17.538]                             break
[09:29:17.538]                           }
[09:29:17.538]                         }
[09:29:17.538]                       }
[09:29:17.538]                       invisible(muffled)
[09:29:17.538]                     }
[09:29:17.538]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.538]                   }
[09:29:17.538]                 }
[09:29:17.538]             }
[09:29:17.538]         }))
[09:29:17.538]     }, error = function(ex) {
[09:29:17.538]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:17.538]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.538]                 ...future.rng), started = ...future.startTime, 
[09:29:17.538]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:17.538]             version = "1.8"), class = "FutureResult")
[09:29:17.538]     }, finally = {
[09:29:17.538]         if (!identical(...future.workdir, getwd())) 
[09:29:17.538]             setwd(...future.workdir)
[09:29:17.538]         {
[09:29:17.538]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:17.538]                 ...future.oldOptions$nwarnings <- NULL
[09:29:17.538]             }
[09:29:17.538]             base::options(...future.oldOptions)
[09:29:17.538]             if (.Platform$OS.type == "windows") {
[09:29:17.538]                 old_names <- names(...future.oldEnvVars)
[09:29:17.538]                 envs <- base::Sys.getenv()
[09:29:17.538]                 names <- names(envs)
[09:29:17.538]                 common <- intersect(names, old_names)
[09:29:17.538]                 added <- setdiff(names, old_names)
[09:29:17.538]                 removed <- setdiff(old_names, names)
[09:29:17.538]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:17.538]                   envs[common]]
[09:29:17.538]                 NAMES <- toupper(changed)
[09:29:17.538]                 args <- list()
[09:29:17.538]                 for (kk in seq_along(NAMES)) {
[09:29:17.538]                   name <- changed[[kk]]
[09:29:17.538]                   NAME <- NAMES[[kk]]
[09:29:17.538]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.538]                     next
[09:29:17.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.538]                 }
[09:29:17.538]                 NAMES <- toupper(added)
[09:29:17.538]                 for (kk in seq_along(NAMES)) {
[09:29:17.538]                   name <- added[[kk]]
[09:29:17.538]                   NAME <- NAMES[[kk]]
[09:29:17.538]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.538]                     next
[09:29:17.538]                   args[[name]] <- ""
[09:29:17.538]                 }
[09:29:17.538]                 NAMES <- toupper(removed)
[09:29:17.538]                 for (kk in seq_along(NAMES)) {
[09:29:17.538]                   name <- removed[[kk]]
[09:29:17.538]                   NAME <- NAMES[[kk]]
[09:29:17.538]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.538]                     next
[09:29:17.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.538]                 }
[09:29:17.538]                 if (length(args) > 0) 
[09:29:17.538]                   base::do.call(base::Sys.setenv, args = args)
[09:29:17.538]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:17.538]             }
[09:29:17.538]             else {
[09:29:17.538]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:17.538]             }
[09:29:17.538]             {
[09:29:17.538]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:17.538]                   0L) {
[09:29:17.538]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:17.538]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:17.538]                   base::options(opts)
[09:29:17.538]                 }
[09:29:17.538]                 {
[09:29:17.538]                   {
[09:29:17.538]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:17.538]                     NULL
[09:29:17.538]                   }
[09:29:17.538]                   options(future.plan = NULL)
[09:29:17.538]                   if (is.na(NA_character_)) 
[09:29:17.538]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.538]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:17.538]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:17.538]                     .init = FALSE)
[09:29:17.538]                 }
[09:29:17.538]             }
[09:29:17.538]         }
[09:29:17.538]     })
[09:29:17.538]     if (TRUE) {
[09:29:17.538]         base::sink(type = "output", split = FALSE)
[09:29:17.538]         if (TRUE) {
[09:29:17.538]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:17.538]         }
[09:29:17.538]         else {
[09:29:17.538]             ...future.result["stdout"] <- base::list(NULL)
[09:29:17.538]         }
[09:29:17.538]         base::close(...future.stdout)
[09:29:17.538]         ...future.stdout <- NULL
[09:29:17.538]     }
[09:29:17.538]     ...future.result$conditions <- ...future.conditions
[09:29:17.538]     ...future.result$finished <- base::Sys.time()
[09:29:17.538]     ...future.result
[09:29:17.538] }
[09:29:17.541] assign_globals() ...
[09:29:17.541] List of 5
[09:29:17.541]  $ ...future.FUN            :function (e1, e2)  
[09:29:17.541]  $ MoreArgs                 : NULL
[09:29:17.541]  $ ...future.elements_ii    :List of 2
[09:29:17.541]   ..$ :List of 1
[09:29:17.541]   .. ..$ : num 1
[09:29:17.541]   ..$ :List of 1
[09:29:17.541]   .. ..$ : int 1
[09:29:17.541]  $ ...future.seeds_ii       : NULL
[09:29:17.541]  $ ...future.globals.maxSize: NULL
[09:29:17.541]  - attr(*, "where")=List of 5
[09:29:17.541]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:17.541]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:17.541]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:17.541]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:17.541]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:17.541]  - attr(*, "resolved")= logi FALSE
[09:29:17.541]  - attr(*, "total_size")= num 168
[09:29:17.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.541]  - attr(*, "already-done")= logi TRUE
[09:29:17.546] - copied ‘...future.FUN’ to environment
[09:29:17.546] - copied ‘MoreArgs’ to environment
[09:29:17.546] - copied ‘...future.elements_ii’ to environment
[09:29:17.546] - copied ‘...future.seeds_ii’ to environment
[09:29:17.547] - copied ‘...future.globals.maxSize’ to environment
[09:29:17.547] assign_globals() ... done
[09:29:17.547] requestCore(): workers = 2
[09:29:17.549] MulticoreFuture started
[09:29:17.549] - Launch lazy future ... done
[09:29:17.549] run() for ‘MulticoreFuture’ ... done
[09:29:17.550] Created future:
[09:29:17.550] plan(): Setting new future strategy stack:
[09:29:17.550] List of future strategies:
[09:29:17.550] 1. sequential:
[09:29:17.550]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:17.550]    - tweaked: FALSE
[09:29:17.550]    - call: NULL
[09:29:17.551] plan(): nbrOfWorkers() = 1
[09:29:17.553] plan(): Setting new future strategy stack:
[09:29:17.553] List of future strategies:
[09:29:17.553] 1. multicore:
[09:29:17.553]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:17.553]    - tweaked: FALSE
[09:29:17.553]    - call: plan(strategy)
[09:29:17.558] plan(): nbrOfWorkers() = 2
[09:29:17.550] MulticoreFuture:
[09:29:17.550] Label: ‘future_Map-1’
[09:29:17.550] Expression:
[09:29:17.550] {
[09:29:17.550]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.550]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:17.550]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.550]         on.exit(options(oopts), add = TRUE)
[09:29:17.550]     }
[09:29:17.550]     {
[09:29:17.550]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.550]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:17.550]         do.call(mapply, args = args)
[09:29:17.550]     }
[09:29:17.550] }
[09:29:17.550] Lazy evaluation: FALSE
[09:29:17.550] Asynchronous evaluation: TRUE
[09:29:17.550] Local evaluation: TRUE
[09:29:17.550] Environment: R_GlobalEnv
[09:29:17.550] Capture standard output: TRUE
[09:29:17.550] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:17.550] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:17.550] Packages: <none>
[09:29:17.550] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:17.550] Resolved: TRUE
[09:29:17.550] Value: <not collected>
[09:29:17.550] Conditions captured: <none>
[09:29:17.550] Early signaling: FALSE
[09:29:17.550] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:17.550] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.560] Chunk #1 of 2 ... DONE
[09:29:17.560] Chunk #2 of 2 ...
[09:29:17.560]  - Finding globals in '...' for chunk #2 ...
[09:29:17.560] getGlobalsAndPackages() ...
[09:29:17.560] Searching for globals...
[09:29:17.561] 
[09:29:17.561] Searching for globals ... DONE
[09:29:17.561] - globals: [0] <none>
[09:29:17.561] getGlobalsAndPackages() ... DONE
[09:29:17.561]    + additional globals found: [n=0] 
[09:29:17.562]    + additional namespaces needed: [n=0] 
[09:29:17.562]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:17.562]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:17.562]  - seeds: <none>
[09:29:17.562]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.562] getGlobalsAndPackages() ...
[09:29:17.562] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.563] Resolving globals: FALSE
[09:29:17.563] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:17.564] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:17.564] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.565] 
[09:29:17.565] getGlobalsAndPackages() ... DONE
[09:29:17.565] run() for ‘Future’ ...
[09:29:17.566] - state: ‘created’
[09:29:17.566] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:17.570] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.571] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:17.571]   - Field: ‘label’
[09:29:17.571]   - Field: ‘local’
[09:29:17.571]   - Field: ‘owner’
[09:29:17.571]   - Field: ‘envir’
[09:29:17.571]   - Field: ‘workers’
[09:29:17.572]   - Field: ‘packages’
[09:29:17.572]   - Field: ‘gc’
[09:29:17.572]   - Field: ‘job’
[09:29:17.572]   - Field: ‘conditions’
[09:29:17.572]   - Field: ‘expr’
[09:29:17.572]   - Field: ‘uuid’
[09:29:17.576]   - Field: ‘seed’
[09:29:17.576]   - Field: ‘version’
[09:29:17.577]   - Field: ‘result’
[09:29:17.577]   - Field: ‘asynchronous’
[09:29:17.577]   - Field: ‘calls’
[09:29:17.578]   - Field: ‘globals’
[09:29:17.578]   - Field: ‘stdout’
[09:29:17.578]   - Field: ‘earlySignal’
[09:29:17.578]   - Field: ‘lazy’
[09:29:17.579]   - Field: ‘state’
[09:29:17.579] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:17.579] - Launch lazy future ...
[09:29:17.580] Packages needed by the future expression (n = 0): <none>
[09:29:17.580] Packages needed by future strategies (n = 0): <none>
[09:29:17.581] {
[09:29:17.581]     {
[09:29:17.581]         {
[09:29:17.581]             ...future.startTime <- base::Sys.time()
[09:29:17.581]             {
[09:29:17.581]                 {
[09:29:17.581]                   {
[09:29:17.581]                     {
[09:29:17.581]                       base::local({
[09:29:17.581]                         has_future <- base::requireNamespace("future", 
[09:29:17.581]                           quietly = TRUE)
[09:29:17.581]                         if (has_future) {
[09:29:17.581]                           ns <- base::getNamespace("future")
[09:29:17.581]                           version <- ns[[".package"]][["version"]]
[09:29:17.581]                           if (is.null(version)) 
[09:29:17.581]                             version <- utils::packageVersion("future")
[09:29:17.581]                         }
[09:29:17.581]                         else {
[09:29:17.581]                           version <- NULL
[09:29:17.581]                         }
[09:29:17.581]                         if (!has_future || version < "1.8.0") {
[09:29:17.581]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:17.581]                             "", base::R.version$version.string), 
[09:29:17.581]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:17.581]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:17.581]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:17.581]                               "release", "version")], collapse = " "), 
[09:29:17.581]                             hostname = base::Sys.info()[["nodename"]])
[09:29:17.581]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:17.581]                             info)
[09:29:17.581]                           info <- base::paste(info, collapse = "; ")
[09:29:17.581]                           if (!has_future) {
[09:29:17.581]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:17.581]                               info)
[09:29:17.581]                           }
[09:29:17.581]                           else {
[09:29:17.581]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:17.581]                               info, version)
[09:29:17.581]                           }
[09:29:17.581]                           base::stop(msg)
[09:29:17.581]                         }
[09:29:17.581]                       })
[09:29:17.581]                     }
[09:29:17.581]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:17.581]                     base::options(mc.cores = 1L)
[09:29:17.581]                   }
[09:29:17.581]                   ...future.strategy.old <- future::plan("list")
[09:29:17.581]                   options(future.plan = NULL)
[09:29:17.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:17.581]                 }
[09:29:17.581]                 ...future.workdir <- getwd()
[09:29:17.581]             }
[09:29:17.581]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:17.581]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:17.581]         }
[09:29:17.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:17.581]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:17.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:17.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:17.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:17.581]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:17.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:17.581]             base::names(...future.oldOptions))
[09:29:17.581]     }
[09:29:17.581]     if (FALSE) {
[09:29:17.581]     }
[09:29:17.581]     else {
[09:29:17.581]         if (TRUE) {
[09:29:17.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:17.581]                 open = "w")
[09:29:17.581]         }
[09:29:17.581]         else {
[09:29:17.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:17.581]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:17.581]         }
[09:29:17.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:17.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:17.581]             base::sink(type = "output", split = FALSE)
[09:29:17.581]             base::close(...future.stdout)
[09:29:17.581]         }, add = TRUE)
[09:29:17.581]     }
[09:29:17.581]     ...future.frame <- base::sys.nframe()
[09:29:17.581]     ...future.conditions <- base::list()
[09:29:17.581]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:17.581]     if (FALSE) {
[09:29:17.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:17.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:17.581]     }
[09:29:17.581]     ...future.result <- base::tryCatch({
[09:29:17.581]         base::withCallingHandlers({
[09:29:17.581]             ...future.value <- base::withVisible(base::local({
[09:29:17.581]                 withCallingHandlers({
[09:29:17.581]                   {
[09:29:17.581]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.581]                     if (!identical(...future.globals.maxSize.org, 
[09:29:17.581]                       ...future.globals.maxSize)) {
[09:29:17.581]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.581]                       on.exit(options(oopts), add = TRUE)
[09:29:17.581]                     }
[09:29:17.581]                     {
[09:29:17.581]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.581]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:17.581]                         USE.NAMES = FALSE)
[09:29:17.581]                       do.call(mapply, args = args)
[09:29:17.581]                     }
[09:29:17.581]                   }
[09:29:17.581]                 }, immediateCondition = function(cond) {
[09:29:17.581]                   save_rds <- function (object, pathname, ...) 
[09:29:17.581]                   {
[09:29:17.581]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:17.581]                     if (file_test("-f", pathname_tmp)) {
[09:29:17.581]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.581]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:17.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.581]                         fi_tmp[["mtime"]])
[09:29:17.581]                     }
[09:29:17.581]                     tryCatch({
[09:29:17.581]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:17.581]                     }, error = function(ex) {
[09:29:17.581]                       msg <- conditionMessage(ex)
[09:29:17.581]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.581]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:17.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.581]                         fi_tmp[["mtime"]], msg)
[09:29:17.581]                       ex$message <- msg
[09:29:17.581]                       stop(ex)
[09:29:17.581]                     })
[09:29:17.581]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:17.581]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:17.581]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:17.581]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.581]                       fi <- file.info(pathname)
[09:29:17.581]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:17.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.581]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:17.581]                         fi[["size"]], fi[["mtime"]])
[09:29:17.581]                       stop(msg)
[09:29:17.581]                     }
[09:29:17.581]                     invisible(pathname)
[09:29:17.581]                   }
[09:29:17.581]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:17.581]                     rootPath = tempdir()) 
[09:29:17.581]                   {
[09:29:17.581]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:17.581]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:17.581]                       tmpdir = path, fileext = ".rds")
[09:29:17.581]                     save_rds(obj, file)
[09:29:17.581]                   }
[09:29:17.581]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:17.581]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.581]                   {
[09:29:17.581]                     inherits <- base::inherits
[09:29:17.581]                     invokeRestart <- base::invokeRestart
[09:29:17.581]                     is.null <- base::is.null
[09:29:17.581]                     muffled <- FALSE
[09:29:17.581]                     if (inherits(cond, "message")) {
[09:29:17.581]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:17.581]                       if (muffled) 
[09:29:17.581]                         invokeRestart("muffleMessage")
[09:29:17.581]                     }
[09:29:17.581]                     else if (inherits(cond, "warning")) {
[09:29:17.581]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:17.581]                       if (muffled) 
[09:29:17.581]                         invokeRestart("muffleWarning")
[09:29:17.581]                     }
[09:29:17.581]                     else if (inherits(cond, "condition")) {
[09:29:17.581]                       if (!is.null(pattern)) {
[09:29:17.581]                         computeRestarts <- base::computeRestarts
[09:29:17.581]                         grepl <- base::grepl
[09:29:17.581]                         restarts <- computeRestarts(cond)
[09:29:17.581]                         for (restart in restarts) {
[09:29:17.581]                           name <- restart$name
[09:29:17.581]                           if (is.null(name)) 
[09:29:17.581]                             next
[09:29:17.581]                           if (!grepl(pattern, name)) 
[09:29:17.581]                             next
[09:29:17.581]                           invokeRestart(restart)
[09:29:17.581]                           muffled <- TRUE
[09:29:17.581]                           break
[09:29:17.581]                         }
[09:29:17.581]                       }
[09:29:17.581]                     }
[09:29:17.581]                     invisible(muffled)
[09:29:17.581]                   }
[09:29:17.581]                   muffleCondition(cond)
[09:29:17.581]                 })
[09:29:17.581]             }))
[09:29:17.581]             future::FutureResult(value = ...future.value$value, 
[09:29:17.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.581]                   ...future.rng), globalenv = if (FALSE) 
[09:29:17.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:17.581]                     ...future.globalenv.names))
[09:29:17.581]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:17.581]         }, condition = base::local({
[09:29:17.581]             c <- base::c
[09:29:17.581]             inherits <- base::inherits
[09:29:17.581]             invokeRestart <- base::invokeRestart
[09:29:17.581]             length <- base::length
[09:29:17.581]             list <- base::list
[09:29:17.581]             seq.int <- base::seq.int
[09:29:17.581]             signalCondition <- base::signalCondition
[09:29:17.581]             sys.calls <- base::sys.calls
[09:29:17.581]             `[[` <- base::`[[`
[09:29:17.581]             `+` <- base::`+`
[09:29:17.581]             `<<-` <- base::`<<-`
[09:29:17.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:17.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:17.581]                   3L)]
[09:29:17.581]             }
[09:29:17.581]             function(cond) {
[09:29:17.581]                 is_error <- inherits(cond, "error")
[09:29:17.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:17.581]                   NULL)
[09:29:17.581]                 if (is_error) {
[09:29:17.581]                   sessionInformation <- function() {
[09:29:17.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:17.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:17.581]                       search = base::search(), system = base::Sys.info())
[09:29:17.581]                   }
[09:29:17.581]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:17.581]                     cond$call), session = sessionInformation(), 
[09:29:17.581]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:17.581]                   signalCondition(cond)
[09:29:17.581]                 }
[09:29:17.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:17.581]                 "immediateCondition"))) {
[09:29:17.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:17.581]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:17.581]                   if (TRUE && !signal) {
[09:29:17.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.581]                     {
[09:29:17.581]                       inherits <- base::inherits
[09:29:17.581]                       invokeRestart <- base::invokeRestart
[09:29:17.581]                       is.null <- base::is.null
[09:29:17.581]                       muffled <- FALSE
[09:29:17.581]                       if (inherits(cond, "message")) {
[09:29:17.581]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.581]                         if (muffled) 
[09:29:17.581]                           invokeRestart("muffleMessage")
[09:29:17.581]                       }
[09:29:17.581]                       else if (inherits(cond, "warning")) {
[09:29:17.581]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.581]                         if (muffled) 
[09:29:17.581]                           invokeRestart("muffleWarning")
[09:29:17.581]                       }
[09:29:17.581]                       else if (inherits(cond, "condition")) {
[09:29:17.581]                         if (!is.null(pattern)) {
[09:29:17.581]                           computeRestarts <- base::computeRestarts
[09:29:17.581]                           grepl <- base::grepl
[09:29:17.581]                           restarts <- computeRestarts(cond)
[09:29:17.581]                           for (restart in restarts) {
[09:29:17.581]                             name <- restart$name
[09:29:17.581]                             if (is.null(name)) 
[09:29:17.581]                               next
[09:29:17.581]                             if (!grepl(pattern, name)) 
[09:29:17.581]                               next
[09:29:17.581]                             invokeRestart(restart)
[09:29:17.581]                             muffled <- TRUE
[09:29:17.581]                             break
[09:29:17.581]                           }
[09:29:17.581]                         }
[09:29:17.581]                       }
[09:29:17.581]                       invisible(muffled)
[09:29:17.581]                     }
[09:29:17.581]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.581]                   }
[09:29:17.581]                 }
[09:29:17.581]                 else {
[09:29:17.581]                   if (TRUE) {
[09:29:17.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.581]                     {
[09:29:17.581]                       inherits <- base::inherits
[09:29:17.581]                       invokeRestart <- base::invokeRestart
[09:29:17.581]                       is.null <- base::is.null
[09:29:17.581]                       muffled <- FALSE
[09:29:17.581]                       if (inherits(cond, "message")) {
[09:29:17.581]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.581]                         if (muffled) 
[09:29:17.581]                           invokeRestart("muffleMessage")
[09:29:17.581]                       }
[09:29:17.581]                       else if (inherits(cond, "warning")) {
[09:29:17.581]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.581]                         if (muffled) 
[09:29:17.581]                           invokeRestart("muffleWarning")
[09:29:17.581]                       }
[09:29:17.581]                       else if (inherits(cond, "condition")) {
[09:29:17.581]                         if (!is.null(pattern)) {
[09:29:17.581]                           computeRestarts <- base::computeRestarts
[09:29:17.581]                           grepl <- base::grepl
[09:29:17.581]                           restarts <- computeRestarts(cond)
[09:29:17.581]                           for (restart in restarts) {
[09:29:17.581]                             name <- restart$name
[09:29:17.581]                             if (is.null(name)) 
[09:29:17.581]                               next
[09:29:17.581]                             if (!grepl(pattern, name)) 
[09:29:17.581]                               next
[09:29:17.581]                             invokeRestart(restart)
[09:29:17.581]                             muffled <- TRUE
[09:29:17.581]                             break
[09:29:17.581]                           }
[09:29:17.581]                         }
[09:29:17.581]                       }
[09:29:17.581]                       invisible(muffled)
[09:29:17.581]                     }
[09:29:17.581]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.581]                   }
[09:29:17.581]                 }
[09:29:17.581]             }
[09:29:17.581]         }))
[09:29:17.581]     }, error = function(ex) {
[09:29:17.581]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:17.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.581]                 ...future.rng), started = ...future.startTime, 
[09:29:17.581]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:17.581]             version = "1.8"), class = "FutureResult")
[09:29:17.581]     }, finally = {
[09:29:17.581]         if (!identical(...future.workdir, getwd())) 
[09:29:17.581]             setwd(...future.workdir)
[09:29:17.581]         {
[09:29:17.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:17.581]                 ...future.oldOptions$nwarnings <- NULL
[09:29:17.581]             }
[09:29:17.581]             base::options(...future.oldOptions)
[09:29:17.581]             if (.Platform$OS.type == "windows") {
[09:29:17.581]                 old_names <- names(...future.oldEnvVars)
[09:29:17.581]                 envs <- base::Sys.getenv()
[09:29:17.581]                 names <- names(envs)
[09:29:17.581]                 common <- intersect(names, old_names)
[09:29:17.581]                 added <- setdiff(names, old_names)
[09:29:17.581]                 removed <- setdiff(old_names, names)
[09:29:17.581]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:17.581]                   envs[common]]
[09:29:17.581]                 NAMES <- toupper(changed)
[09:29:17.581]                 args <- list()
[09:29:17.581]                 for (kk in seq_along(NAMES)) {
[09:29:17.581]                   name <- changed[[kk]]
[09:29:17.581]                   NAME <- NAMES[[kk]]
[09:29:17.581]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.581]                     next
[09:29:17.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.581]                 }
[09:29:17.581]                 NAMES <- toupper(added)
[09:29:17.581]                 for (kk in seq_along(NAMES)) {
[09:29:17.581]                   name <- added[[kk]]
[09:29:17.581]                   NAME <- NAMES[[kk]]
[09:29:17.581]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.581]                     next
[09:29:17.581]                   args[[name]] <- ""
[09:29:17.581]                 }
[09:29:17.581]                 NAMES <- toupper(removed)
[09:29:17.581]                 for (kk in seq_along(NAMES)) {
[09:29:17.581]                   name <- removed[[kk]]
[09:29:17.581]                   NAME <- NAMES[[kk]]
[09:29:17.581]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.581]                     next
[09:29:17.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.581]                 }
[09:29:17.581]                 if (length(args) > 0) 
[09:29:17.581]                   base::do.call(base::Sys.setenv, args = args)
[09:29:17.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:17.581]             }
[09:29:17.581]             else {
[09:29:17.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:17.581]             }
[09:29:17.581]             {
[09:29:17.581]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:17.581]                   0L) {
[09:29:17.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:17.581]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:17.581]                   base::options(opts)
[09:29:17.581]                 }
[09:29:17.581]                 {
[09:29:17.581]                   {
[09:29:17.581]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:17.581]                     NULL
[09:29:17.581]                   }
[09:29:17.581]                   options(future.plan = NULL)
[09:29:17.581]                   if (is.na(NA_character_)) 
[09:29:17.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:17.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:17.581]                     .init = FALSE)
[09:29:17.581]                 }
[09:29:17.581]             }
[09:29:17.581]         }
[09:29:17.581]     })
[09:29:17.581]     if (TRUE) {
[09:29:17.581]         base::sink(type = "output", split = FALSE)
[09:29:17.581]         if (TRUE) {
[09:29:17.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:17.581]         }
[09:29:17.581]         else {
[09:29:17.581]             ...future.result["stdout"] <- base::list(NULL)
[09:29:17.581]         }
[09:29:17.581]         base::close(...future.stdout)
[09:29:17.581]         ...future.stdout <- NULL
[09:29:17.581]     }
[09:29:17.581]     ...future.result$conditions <- ...future.conditions
[09:29:17.581]     ...future.result$finished <- base::Sys.time()
[09:29:17.581]     ...future.result
[09:29:17.581] }
[09:29:17.584] assign_globals() ...
[09:29:17.584] List of 5
[09:29:17.584]  $ ...future.FUN            :function (e1, e2)  
[09:29:17.584]  $ MoreArgs                 : NULL
[09:29:17.584]  $ ...future.elements_ii    :List of 2
[09:29:17.584]   ..$ :List of 2
[09:29:17.584]   .. ..$ : num 1
[09:29:17.584]   .. ..$ : num 1
[09:29:17.584]   ..$ :List of 2
[09:29:17.584]   .. ..$ : int 2
[09:29:17.584]   .. ..$ : int 3
[09:29:17.584]  $ ...future.seeds_ii       : NULL
[09:29:17.584]  $ ...future.globals.maxSize: NULL
[09:29:17.584]  - attr(*, "where")=List of 5
[09:29:17.584]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:17.584]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:17.584]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:17.584]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:17.584]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:17.584]  - attr(*, "resolved")= logi FALSE
[09:29:17.584]  - attr(*, "total_size")= num 280
[09:29:17.584]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.584]  - attr(*, "already-done")= logi TRUE
[09:29:17.594] - copied ‘...future.FUN’ to environment
[09:29:17.594] - copied ‘MoreArgs’ to environment
[09:29:17.594] - copied ‘...future.elements_ii’ to environment
[09:29:17.594] - copied ‘...future.seeds_ii’ to environment
[09:29:17.594] - copied ‘...future.globals.maxSize’ to environment
[09:29:17.594] assign_globals() ... done
[09:29:17.595] requestCore(): workers = 2
[09:29:17.597] MulticoreFuture started
[09:29:17.597] - Launch lazy future ... done
[09:29:17.597] run() for ‘MulticoreFuture’ ... done
[09:29:17.598] Created future:
[09:29:17.598] plan(): Setting new future strategy stack:
[09:29:17.598] List of future strategies:
[09:29:17.598] 1. sequential:
[09:29:17.598]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:17.598]    - tweaked: FALSE
[09:29:17.598]    - call: NULL
[09:29:17.599] plan(): nbrOfWorkers() = 1
[09:29:17.601] plan(): Setting new future strategy stack:
[09:29:17.602] List of future strategies:
[09:29:17.602] 1. multicore:
[09:29:17.602]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:17.602]    - tweaked: FALSE
[09:29:17.602]    - call: plan(strategy)
[09:29:17.607] plan(): nbrOfWorkers() = 2
[09:29:17.598] MulticoreFuture:
[09:29:17.598] Label: ‘future_Map-2’
[09:29:17.598] Expression:
[09:29:17.598] {
[09:29:17.598]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.598]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:17.598]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.598]         on.exit(options(oopts), add = TRUE)
[09:29:17.598]     }
[09:29:17.598]     {
[09:29:17.598]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.598]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:17.598]         do.call(mapply, args = args)
[09:29:17.598]     }
[09:29:17.598] }
[09:29:17.598] Lazy evaluation: FALSE
[09:29:17.598] Asynchronous evaluation: TRUE
[09:29:17.598] Local evaluation: TRUE
[09:29:17.598] Environment: R_GlobalEnv
[09:29:17.598] Capture standard output: TRUE
[09:29:17.598] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:17.598] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:17.598] Packages: <none>
[09:29:17.598] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:17.598] Resolved: TRUE
[09:29:17.598] Value: <not collected>
[09:29:17.598] Conditions captured: <none>
[09:29:17.598] Early signaling: FALSE
[09:29:17.598] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:17.598] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.608] Chunk #2 of 2 ... DONE
[09:29:17.608] Launching 2 futures (chunks) ... DONE
[09:29:17.608] Resolving 2 futures (chunks) ...
[09:29:17.608] resolve() on list ...
[09:29:17.608]  recursive: 0
[09:29:17.609]  length: 2
[09:29:17.609] 
[09:29:17.609] Future #1
[09:29:17.609] result() for MulticoreFuture ...
[09:29:17.610] result() for MulticoreFuture ...
[09:29:17.610] result() for MulticoreFuture ... done
[09:29:17.610] result() for MulticoreFuture ... done
[09:29:17.610] result() for MulticoreFuture ...
[09:29:17.611] result() for MulticoreFuture ... done
[09:29:17.611] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:17.611] - nx: 2
[09:29:17.611] - relay: TRUE
[09:29:17.611] - stdout: TRUE
[09:29:17.611] - signal: TRUE
[09:29:17.612] - resignal: FALSE
[09:29:17.612] - force: TRUE
[09:29:17.612] - relayed: [n=2] FALSE, FALSE
[09:29:17.612] - queued futures: [n=2] FALSE, FALSE
[09:29:17.612]  - until=1
[09:29:17.612]  - relaying element #1
[09:29:17.612] result() for MulticoreFuture ...
[09:29:17.613] result() for MulticoreFuture ... done
[09:29:17.613] result() for MulticoreFuture ...
[09:29:17.613] result() for MulticoreFuture ... done
[09:29:17.613] result() for MulticoreFuture ...
[09:29:17.613] result() for MulticoreFuture ... done
[09:29:17.613] result() for MulticoreFuture ...
[09:29:17.614] result() for MulticoreFuture ... done
[09:29:17.614] - relayed: [n=2] TRUE, FALSE
[09:29:17.614] - queued futures: [n=2] TRUE, FALSE
[09:29:17.614] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:17.614]  length: 1 (resolved future 1)
[09:29:17.615] Future #2
[09:29:17.615] result() for MulticoreFuture ...
[09:29:17.615] result() for MulticoreFuture ...
[09:29:17.616] result() for MulticoreFuture ... done
[09:29:17.616] result() for MulticoreFuture ... done
[09:29:17.616] result() for MulticoreFuture ...
[09:29:17.616] result() for MulticoreFuture ... done
[09:29:17.616] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:17.616] - nx: 2
[09:29:17.617] - relay: TRUE
[09:29:17.617] - stdout: TRUE
[09:29:17.617] - signal: TRUE
[09:29:17.617] - resignal: FALSE
[09:29:17.617] - force: TRUE
[09:29:17.617] - relayed: [n=2] TRUE, FALSE
[09:29:17.617] - queued futures: [n=2] TRUE, FALSE
[09:29:17.617]  - until=2
[09:29:17.618]  - relaying element #2
[09:29:17.618] result() for MulticoreFuture ...
[09:29:17.618] result() for MulticoreFuture ... done
[09:29:17.618] result() for MulticoreFuture ...
[09:29:17.618] result() for MulticoreFuture ... done
[09:29:17.618] result() for MulticoreFuture ...
[09:29:17.618] result() for MulticoreFuture ... done
[09:29:17.618] result() for MulticoreFuture ...
[09:29:17.619] result() for MulticoreFuture ... done
[09:29:17.619] - relayed: [n=2] TRUE, TRUE
[09:29:17.619] - queued futures: [n=2] TRUE, TRUE
[09:29:17.619] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:17.622]  length: 0 (resolved future 2)
[09:29:17.622] Relaying remaining futures
[09:29:17.622] signalConditionsASAP(NULL, pos=0) ...
[09:29:17.623] - nx: 2
[09:29:17.623] - relay: TRUE
[09:29:17.623] - stdout: TRUE
[09:29:17.623] - signal: TRUE
[09:29:17.623] - resignal: FALSE
[09:29:17.623] - force: TRUE
[09:29:17.624] - relayed: [n=2] TRUE, TRUE
[09:29:17.624] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:17.624] - relayed: [n=2] TRUE, TRUE
[09:29:17.624] - queued futures: [n=2] TRUE, TRUE
[09:29:17.624] signalConditionsASAP(NULL, pos=0) ... done
[09:29:17.624] resolve() on list ... DONE
[09:29:17.625] result() for MulticoreFuture ...
[09:29:17.625] result() for MulticoreFuture ... done
[09:29:17.625] result() for MulticoreFuture ...
[09:29:17.625] result() for MulticoreFuture ... done
[09:29:17.625] result() for MulticoreFuture ...
[09:29:17.625] result() for MulticoreFuture ... done
[09:29:17.626] result() for MulticoreFuture ...
[09:29:17.626] result() for MulticoreFuture ... done
[09:29:17.626]  - Number of value chunks collected: 2
[09:29:17.626] Resolving 2 futures (chunks) ... DONE
[09:29:17.626] Reducing values from 2 chunks ...
[09:29:17.626]  - Number of values collected after concatenation: 3
[09:29:17.626]  - Number of values expected: 3
[09:29:17.626] Reducing values from 2 chunks ... DONE
[09:29:17.627] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[09:29:17.627] future_mapply() ...
[09:29:17.631] Number of chunks: 2
[09:29:17.632] getGlobalsAndPackagesXApply() ...
[09:29:17.632]  - future.globals: TRUE
[09:29:17.632] getGlobalsAndPackages() ...
[09:29:17.632] Searching for globals...
[09:29:17.633] - globals found: [1] ‘FUN’
[09:29:17.634] Searching for globals ... DONE
[09:29:17.634] Resolving globals: FALSE
[09:29:17.634] The total size of the 1 globals is 848 bytes (848 bytes)
[09:29:17.634] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:29:17.634] - globals: [1] ‘FUN’
[09:29:17.635] 
[09:29:17.635] getGlobalsAndPackages() ... DONE
[09:29:17.635]  - globals found/used: [n=1] ‘FUN’
[09:29:17.635]  - needed namespaces: [n=0] 
[09:29:17.635] Finding globals ... DONE
[09:29:17.635] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:17.635] List of 2
[09:29:17.635]  $ ...future.FUN:function (x)  
[09:29:17.635]  $ MoreArgs     : NULL
[09:29:17.635]  - attr(*, "where")=List of 2
[09:29:17.635]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:17.635]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:17.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.635]  - attr(*, "resolved")= logi FALSE
[09:29:17.635]  - attr(*, "total_size")= num NA
[09:29:17.638] Packages to be attached in all futures: [n=0] 
[09:29:17.638] getGlobalsAndPackagesXApply() ... DONE
[09:29:17.638] Number of futures (= number of chunks): 2
[09:29:17.639] Launching 2 futures (chunks) ...
[09:29:17.639] Chunk #1 of 2 ...
[09:29:17.639]  - Finding globals in '...' for chunk #1 ...
[09:29:17.639] getGlobalsAndPackages() ...
[09:29:17.639] Searching for globals...
[09:29:17.639] 
[09:29:17.639] Searching for globals ... DONE
[09:29:17.639] - globals: [0] <none>
[09:29:17.639] getGlobalsAndPackages() ... DONE
[09:29:17.640]    + additional globals found: [n=0] 
[09:29:17.640]    + additional namespaces needed: [n=0] 
[09:29:17.640]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:17.640]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:17.640]  - seeds: <none>
[09:29:17.640]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.640] getGlobalsAndPackages() ...
[09:29:17.640] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.640] Resolving globals: FALSE
[09:29:17.641] The total size of the 5 globals is 904 bytes (904 bytes)
[09:29:17.641] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:17.641] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.641] 
[09:29:17.642] getGlobalsAndPackages() ... DONE
[09:29:17.642] run() for ‘Future’ ...
[09:29:17.642] - state: ‘created’
[09:29:17.642] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:17.646] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.646] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:17.646]   - Field: ‘label’
[09:29:17.646]   - Field: ‘local’
[09:29:17.646]   - Field: ‘owner’
[09:29:17.646]   - Field: ‘envir’
[09:29:17.646]   - Field: ‘workers’
[09:29:17.646]   - Field: ‘packages’
[09:29:17.647]   - Field: ‘gc’
[09:29:17.647]   - Field: ‘job’
[09:29:17.647]   - Field: ‘conditions’
[09:29:17.647]   - Field: ‘expr’
[09:29:17.647]   - Field: ‘uuid’
[09:29:17.647]   - Field: ‘seed’
[09:29:17.647]   - Field: ‘version’
[09:29:17.647]   - Field: ‘result’
[09:29:17.647]   - Field: ‘asynchronous’
[09:29:17.647]   - Field: ‘calls’
[09:29:17.647]   - Field: ‘globals’
[09:29:17.648]   - Field: ‘stdout’
[09:29:17.648]   - Field: ‘earlySignal’
[09:29:17.648]   - Field: ‘lazy’
[09:29:17.648]   - Field: ‘state’
[09:29:17.648] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:17.650] - Launch lazy future ...
[09:29:17.651] Packages needed by the future expression (n = 0): <none>
[09:29:17.651] Packages needed by future strategies (n = 0): <none>
[09:29:17.651] {
[09:29:17.651]     {
[09:29:17.651]         {
[09:29:17.651]             ...future.startTime <- base::Sys.time()
[09:29:17.651]             {
[09:29:17.651]                 {
[09:29:17.651]                   {
[09:29:17.651]                     {
[09:29:17.651]                       base::local({
[09:29:17.651]                         has_future <- base::requireNamespace("future", 
[09:29:17.651]                           quietly = TRUE)
[09:29:17.651]                         if (has_future) {
[09:29:17.651]                           ns <- base::getNamespace("future")
[09:29:17.651]                           version <- ns[[".package"]][["version"]]
[09:29:17.651]                           if (is.null(version)) 
[09:29:17.651]                             version <- utils::packageVersion("future")
[09:29:17.651]                         }
[09:29:17.651]                         else {
[09:29:17.651]                           version <- NULL
[09:29:17.651]                         }
[09:29:17.651]                         if (!has_future || version < "1.8.0") {
[09:29:17.651]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:17.651]                             "", base::R.version$version.string), 
[09:29:17.651]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:17.651]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:17.651]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:17.651]                               "release", "version")], collapse = " "), 
[09:29:17.651]                             hostname = base::Sys.info()[["nodename"]])
[09:29:17.651]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:17.651]                             info)
[09:29:17.651]                           info <- base::paste(info, collapse = "; ")
[09:29:17.651]                           if (!has_future) {
[09:29:17.651]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:17.651]                               info)
[09:29:17.651]                           }
[09:29:17.651]                           else {
[09:29:17.651]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:17.651]                               info, version)
[09:29:17.651]                           }
[09:29:17.651]                           base::stop(msg)
[09:29:17.651]                         }
[09:29:17.651]                       })
[09:29:17.651]                     }
[09:29:17.651]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:17.651]                     base::options(mc.cores = 1L)
[09:29:17.651]                   }
[09:29:17.651]                   ...future.strategy.old <- future::plan("list")
[09:29:17.651]                   options(future.plan = NULL)
[09:29:17.651]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.651]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:17.651]                 }
[09:29:17.651]                 ...future.workdir <- getwd()
[09:29:17.651]             }
[09:29:17.651]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:17.651]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:17.651]         }
[09:29:17.651]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:17.651]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:17.651]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:17.651]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:17.651]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:17.651]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:17.651]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:17.651]             base::names(...future.oldOptions))
[09:29:17.651]     }
[09:29:17.651]     if (FALSE) {
[09:29:17.651]     }
[09:29:17.651]     else {
[09:29:17.651]         if (TRUE) {
[09:29:17.651]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:17.651]                 open = "w")
[09:29:17.651]         }
[09:29:17.651]         else {
[09:29:17.651]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:17.651]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:17.651]         }
[09:29:17.651]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:17.651]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:17.651]             base::sink(type = "output", split = FALSE)
[09:29:17.651]             base::close(...future.stdout)
[09:29:17.651]         }, add = TRUE)
[09:29:17.651]     }
[09:29:17.651]     ...future.frame <- base::sys.nframe()
[09:29:17.651]     ...future.conditions <- base::list()
[09:29:17.651]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:17.651]     if (FALSE) {
[09:29:17.651]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:17.651]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:17.651]     }
[09:29:17.651]     ...future.result <- base::tryCatch({
[09:29:17.651]         base::withCallingHandlers({
[09:29:17.651]             ...future.value <- base::withVisible(base::local({
[09:29:17.651]                 withCallingHandlers({
[09:29:17.651]                   {
[09:29:17.651]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.651]                     if (!identical(...future.globals.maxSize.org, 
[09:29:17.651]                       ...future.globals.maxSize)) {
[09:29:17.651]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.651]                       on.exit(options(oopts), add = TRUE)
[09:29:17.651]                     }
[09:29:17.651]                     {
[09:29:17.651]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.651]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:17.651]                         USE.NAMES = FALSE)
[09:29:17.651]                       do.call(mapply, args = args)
[09:29:17.651]                     }
[09:29:17.651]                   }
[09:29:17.651]                 }, immediateCondition = function(cond) {
[09:29:17.651]                   save_rds <- function (object, pathname, ...) 
[09:29:17.651]                   {
[09:29:17.651]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:17.651]                     if (file_test("-f", pathname_tmp)) {
[09:29:17.651]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.651]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:17.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.651]                         fi_tmp[["mtime"]])
[09:29:17.651]                     }
[09:29:17.651]                     tryCatch({
[09:29:17.651]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:17.651]                     }, error = function(ex) {
[09:29:17.651]                       msg <- conditionMessage(ex)
[09:29:17.651]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.651]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:17.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.651]                         fi_tmp[["mtime"]], msg)
[09:29:17.651]                       ex$message <- msg
[09:29:17.651]                       stop(ex)
[09:29:17.651]                     })
[09:29:17.651]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:17.651]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:17.651]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:17.651]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.651]                       fi <- file.info(pathname)
[09:29:17.651]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:17.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.651]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:17.651]                         fi[["size"]], fi[["mtime"]])
[09:29:17.651]                       stop(msg)
[09:29:17.651]                     }
[09:29:17.651]                     invisible(pathname)
[09:29:17.651]                   }
[09:29:17.651]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:17.651]                     rootPath = tempdir()) 
[09:29:17.651]                   {
[09:29:17.651]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:17.651]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:17.651]                       tmpdir = path, fileext = ".rds")
[09:29:17.651]                     save_rds(obj, file)
[09:29:17.651]                   }
[09:29:17.651]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:17.651]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.651]                   {
[09:29:17.651]                     inherits <- base::inherits
[09:29:17.651]                     invokeRestart <- base::invokeRestart
[09:29:17.651]                     is.null <- base::is.null
[09:29:17.651]                     muffled <- FALSE
[09:29:17.651]                     if (inherits(cond, "message")) {
[09:29:17.651]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:17.651]                       if (muffled) 
[09:29:17.651]                         invokeRestart("muffleMessage")
[09:29:17.651]                     }
[09:29:17.651]                     else if (inherits(cond, "warning")) {
[09:29:17.651]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:17.651]                       if (muffled) 
[09:29:17.651]                         invokeRestart("muffleWarning")
[09:29:17.651]                     }
[09:29:17.651]                     else if (inherits(cond, "condition")) {
[09:29:17.651]                       if (!is.null(pattern)) {
[09:29:17.651]                         computeRestarts <- base::computeRestarts
[09:29:17.651]                         grepl <- base::grepl
[09:29:17.651]                         restarts <- computeRestarts(cond)
[09:29:17.651]                         for (restart in restarts) {
[09:29:17.651]                           name <- restart$name
[09:29:17.651]                           if (is.null(name)) 
[09:29:17.651]                             next
[09:29:17.651]                           if (!grepl(pattern, name)) 
[09:29:17.651]                             next
[09:29:17.651]                           invokeRestart(restart)
[09:29:17.651]                           muffled <- TRUE
[09:29:17.651]                           break
[09:29:17.651]                         }
[09:29:17.651]                       }
[09:29:17.651]                     }
[09:29:17.651]                     invisible(muffled)
[09:29:17.651]                   }
[09:29:17.651]                   muffleCondition(cond)
[09:29:17.651]                 })
[09:29:17.651]             }))
[09:29:17.651]             future::FutureResult(value = ...future.value$value, 
[09:29:17.651]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.651]                   ...future.rng), globalenv = if (FALSE) 
[09:29:17.651]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:17.651]                     ...future.globalenv.names))
[09:29:17.651]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:17.651]         }, condition = base::local({
[09:29:17.651]             c <- base::c
[09:29:17.651]             inherits <- base::inherits
[09:29:17.651]             invokeRestart <- base::invokeRestart
[09:29:17.651]             length <- base::length
[09:29:17.651]             list <- base::list
[09:29:17.651]             seq.int <- base::seq.int
[09:29:17.651]             signalCondition <- base::signalCondition
[09:29:17.651]             sys.calls <- base::sys.calls
[09:29:17.651]             `[[` <- base::`[[`
[09:29:17.651]             `+` <- base::`+`
[09:29:17.651]             `<<-` <- base::`<<-`
[09:29:17.651]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:17.651]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:17.651]                   3L)]
[09:29:17.651]             }
[09:29:17.651]             function(cond) {
[09:29:17.651]                 is_error <- inherits(cond, "error")
[09:29:17.651]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:17.651]                   NULL)
[09:29:17.651]                 if (is_error) {
[09:29:17.651]                   sessionInformation <- function() {
[09:29:17.651]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:17.651]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:17.651]                       search = base::search(), system = base::Sys.info())
[09:29:17.651]                   }
[09:29:17.651]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.651]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:17.651]                     cond$call), session = sessionInformation(), 
[09:29:17.651]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:17.651]                   signalCondition(cond)
[09:29:17.651]                 }
[09:29:17.651]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:17.651]                 "immediateCondition"))) {
[09:29:17.651]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:17.651]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.651]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:17.651]                   if (TRUE && !signal) {
[09:29:17.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.651]                     {
[09:29:17.651]                       inherits <- base::inherits
[09:29:17.651]                       invokeRestart <- base::invokeRestart
[09:29:17.651]                       is.null <- base::is.null
[09:29:17.651]                       muffled <- FALSE
[09:29:17.651]                       if (inherits(cond, "message")) {
[09:29:17.651]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.651]                         if (muffled) 
[09:29:17.651]                           invokeRestart("muffleMessage")
[09:29:17.651]                       }
[09:29:17.651]                       else if (inherits(cond, "warning")) {
[09:29:17.651]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.651]                         if (muffled) 
[09:29:17.651]                           invokeRestart("muffleWarning")
[09:29:17.651]                       }
[09:29:17.651]                       else if (inherits(cond, "condition")) {
[09:29:17.651]                         if (!is.null(pattern)) {
[09:29:17.651]                           computeRestarts <- base::computeRestarts
[09:29:17.651]                           grepl <- base::grepl
[09:29:17.651]                           restarts <- computeRestarts(cond)
[09:29:17.651]                           for (restart in restarts) {
[09:29:17.651]                             name <- restart$name
[09:29:17.651]                             if (is.null(name)) 
[09:29:17.651]                               next
[09:29:17.651]                             if (!grepl(pattern, name)) 
[09:29:17.651]                               next
[09:29:17.651]                             invokeRestart(restart)
[09:29:17.651]                             muffled <- TRUE
[09:29:17.651]                             break
[09:29:17.651]                           }
[09:29:17.651]                         }
[09:29:17.651]                       }
[09:29:17.651]                       invisible(muffled)
[09:29:17.651]                     }
[09:29:17.651]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.651]                   }
[09:29:17.651]                 }
[09:29:17.651]                 else {
[09:29:17.651]                   if (TRUE) {
[09:29:17.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.651]                     {
[09:29:17.651]                       inherits <- base::inherits
[09:29:17.651]                       invokeRestart <- base::invokeRestart
[09:29:17.651]                       is.null <- base::is.null
[09:29:17.651]                       muffled <- FALSE
[09:29:17.651]                       if (inherits(cond, "message")) {
[09:29:17.651]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.651]                         if (muffled) 
[09:29:17.651]                           invokeRestart("muffleMessage")
[09:29:17.651]                       }
[09:29:17.651]                       else if (inherits(cond, "warning")) {
[09:29:17.651]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.651]                         if (muffled) 
[09:29:17.651]                           invokeRestart("muffleWarning")
[09:29:17.651]                       }
[09:29:17.651]                       else if (inherits(cond, "condition")) {
[09:29:17.651]                         if (!is.null(pattern)) {
[09:29:17.651]                           computeRestarts <- base::computeRestarts
[09:29:17.651]                           grepl <- base::grepl
[09:29:17.651]                           restarts <- computeRestarts(cond)
[09:29:17.651]                           for (restart in restarts) {
[09:29:17.651]                             name <- restart$name
[09:29:17.651]                             if (is.null(name)) 
[09:29:17.651]                               next
[09:29:17.651]                             if (!grepl(pattern, name)) 
[09:29:17.651]                               next
[09:29:17.651]                             invokeRestart(restart)
[09:29:17.651]                             muffled <- TRUE
[09:29:17.651]                             break
[09:29:17.651]                           }
[09:29:17.651]                         }
[09:29:17.651]                       }
[09:29:17.651]                       invisible(muffled)
[09:29:17.651]                     }
[09:29:17.651]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.651]                   }
[09:29:17.651]                 }
[09:29:17.651]             }
[09:29:17.651]         }))
[09:29:17.651]     }, error = function(ex) {
[09:29:17.651]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:17.651]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.651]                 ...future.rng), started = ...future.startTime, 
[09:29:17.651]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:17.651]             version = "1.8"), class = "FutureResult")
[09:29:17.651]     }, finally = {
[09:29:17.651]         if (!identical(...future.workdir, getwd())) 
[09:29:17.651]             setwd(...future.workdir)
[09:29:17.651]         {
[09:29:17.651]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:17.651]                 ...future.oldOptions$nwarnings <- NULL
[09:29:17.651]             }
[09:29:17.651]             base::options(...future.oldOptions)
[09:29:17.651]             if (.Platform$OS.type == "windows") {
[09:29:17.651]                 old_names <- names(...future.oldEnvVars)
[09:29:17.651]                 envs <- base::Sys.getenv()
[09:29:17.651]                 names <- names(envs)
[09:29:17.651]                 common <- intersect(names, old_names)
[09:29:17.651]                 added <- setdiff(names, old_names)
[09:29:17.651]                 removed <- setdiff(old_names, names)
[09:29:17.651]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:17.651]                   envs[common]]
[09:29:17.651]                 NAMES <- toupper(changed)
[09:29:17.651]                 args <- list()
[09:29:17.651]                 for (kk in seq_along(NAMES)) {
[09:29:17.651]                   name <- changed[[kk]]
[09:29:17.651]                   NAME <- NAMES[[kk]]
[09:29:17.651]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.651]                     next
[09:29:17.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.651]                 }
[09:29:17.651]                 NAMES <- toupper(added)
[09:29:17.651]                 for (kk in seq_along(NAMES)) {
[09:29:17.651]                   name <- added[[kk]]
[09:29:17.651]                   NAME <- NAMES[[kk]]
[09:29:17.651]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.651]                     next
[09:29:17.651]                   args[[name]] <- ""
[09:29:17.651]                 }
[09:29:17.651]                 NAMES <- toupper(removed)
[09:29:17.651]                 for (kk in seq_along(NAMES)) {
[09:29:17.651]                   name <- removed[[kk]]
[09:29:17.651]                   NAME <- NAMES[[kk]]
[09:29:17.651]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.651]                     next
[09:29:17.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.651]                 }
[09:29:17.651]                 if (length(args) > 0) 
[09:29:17.651]                   base::do.call(base::Sys.setenv, args = args)
[09:29:17.651]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:17.651]             }
[09:29:17.651]             else {
[09:29:17.651]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:17.651]             }
[09:29:17.651]             {
[09:29:17.651]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:17.651]                   0L) {
[09:29:17.651]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:17.651]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:17.651]                   base::options(opts)
[09:29:17.651]                 }
[09:29:17.651]                 {
[09:29:17.651]                   {
[09:29:17.651]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:17.651]                     NULL
[09:29:17.651]                   }
[09:29:17.651]                   options(future.plan = NULL)
[09:29:17.651]                   if (is.na(NA_character_)) 
[09:29:17.651]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.651]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:17.651]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:17.651]                     .init = FALSE)
[09:29:17.651]                 }
[09:29:17.651]             }
[09:29:17.651]         }
[09:29:17.651]     })
[09:29:17.651]     if (TRUE) {
[09:29:17.651]         base::sink(type = "output", split = FALSE)
[09:29:17.651]         if (TRUE) {
[09:29:17.651]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:17.651]         }
[09:29:17.651]         else {
[09:29:17.651]             ...future.result["stdout"] <- base::list(NULL)
[09:29:17.651]         }
[09:29:17.651]         base::close(...future.stdout)
[09:29:17.651]         ...future.stdout <- NULL
[09:29:17.651]     }
[09:29:17.651]     ...future.result$conditions <- ...future.conditions
[09:29:17.651]     ...future.result$finished <- base::Sys.time()
[09:29:17.651]     ...future.result
[09:29:17.651] }
[09:29:17.654] assign_globals() ...
[09:29:17.654] List of 5
[09:29:17.654]  $ ...future.FUN            :function (x)  
[09:29:17.654]  $ MoreArgs                 : NULL
[09:29:17.654]  $ ...future.elements_ii    :List of 1
[09:29:17.654]   ..$ :List of 1
[09:29:17.654]   .. ..$ a: num 0
[09:29:17.654]  $ ...future.seeds_ii       : NULL
[09:29:17.654]  $ ...future.globals.maxSize: NULL
[09:29:17.654]  - attr(*, "where")=List of 5
[09:29:17.654]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:17.654]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:17.654]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:17.654]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:17.654]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:17.654]  - attr(*, "resolved")= logi FALSE
[09:29:17.654]  - attr(*, "total_size")= num 904
[09:29:17.654]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.654]  - attr(*, "already-done")= logi TRUE
[09:29:17.659] - copied ‘...future.FUN’ to environment
[09:29:17.659] - copied ‘MoreArgs’ to environment
[09:29:17.659] - copied ‘...future.elements_ii’ to environment
[09:29:17.659] - copied ‘...future.seeds_ii’ to environment
[09:29:17.659] - copied ‘...future.globals.maxSize’ to environment
[09:29:17.659] assign_globals() ... done
[09:29:17.660] requestCore(): workers = 2
[09:29:17.662] MulticoreFuture started
[09:29:17.662] - Launch lazy future ... done
[09:29:17.663] run() for ‘MulticoreFuture’ ... done
[09:29:17.663] plan(): Setting new future strategy stack:
[09:29:17.663] Created future:
[09:29:17.663] List of future strategies:
[09:29:17.663] 1. sequential:
[09:29:17.663]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:17.663]    - tweaked: FALSE
[09:29:17.663]    - call: NULL
[09:29:17.664] plan(): nbrOfWorkers() = 1
[09:29:17.667] plan(): Setting new future strategy stack:
[09:29:17.667] List of future strategies:
[09:29:17.667] 1. multicore:
[09:29:17.667]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:17.667]    - tweaked: FALSE
[09:29:17.667]    - call: plan(strategy)
[09:29:17.672] plan(): nbrOfWorkers() = 2
[09:29:17.663] MulticoreFuture:
[09:29:17.663] Label: ‘future_mapply-1’
[09:29:17.663] Expression:
[09:29:17.663] {
[09:29:17.663]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.663]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:17.663]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.663]         on.exit(options(oopts), add = TRUE)
[09:29:17.663]     }
[09:29:17.663]     {
[09:29:17.663]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.663]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:17.663]         do.call(mapply, args = args)
[09:29:17.663]     }
[09:29:17.663] }
[09:29:17.663] Lazy evaluation: FALSE
[09:29:17.663] Asynchronous evaluation: TRUE
[09:29:17.663] Local evaluation: TRUE
[09:29:17.663] Environment: R_GlobalEnv
[09:29:17.663] Capture standard output: TRUE
[09:29:17.663] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:17.663] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:17.663] Packages: <none>
[09:29:17.663] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:17.663] Resolved: TRUE
[09:29:17.663] Value: <not collected>
[09:29:17.663] Conditions captured: <none>
[09:29:17.663] Early signaling: FALSE
[09:29:17.663] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:17.663] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.673] Chunk #1 of 2 ... DONE
[09:29:17.673] Chunk #2 of 2 ...
[09:29:17.674]  - Finding globals in '...' for chunk #2 ...
[09:29:17.674] getGlobalsAndPackages() ...
[09:29:17.674] Searching for globals...
[09:29:17.675] 
[09:29:17.675] Searching for globals ... DONE
[09:29:17.675] - globals: [0] <none>
[09:29:17.675] getGlobalsAndPackages() ... DONE
[09:29:17.675]    + additional globals found: [n=0] 
[09:29:17.675]    + additional namespaces needed: [n=0] 
[09:29:17.675]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:17.676]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:17.676]  - seeds: <none>
[09:29:17.676]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.676] getGlobalsAndPackages() ...
[09:29:17.676] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.677] Resolving globals: FALSE
[09:29:17.677] The total size of the 5 globals is 904 bytes (904 bytes)
[09:29:17.678] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:17.678] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:17.678] 
[09:29:17.679] getGlobalsAndPackages() ... DONE
[09:29:17.679] run() for ‘Future’ ...
[09:29:17.679] - state: ‘created’
[09:29:17.680] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:17.684] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.684] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:17.684]   - Field: ‘label’
[09:29:17.685]   - Field: ‘local’
[09:29:17.685]   - Field: ‘owner’
[09:29:17.685]   - Field: ‘envir’
[09:29:17.685]   - Field: ‘workers’
[09:29:17.685]   - Field: ‘packages’
[09:29:17.685]   - Field: ‘gc’
[09:29:17.685]   - Field: ‘job’
[09:29:17.686]   - Field: ‘conditions’
[09:29:17.686]   - Field: ‘expr’
[09:29:17.686]   - Field: ‘uuid’
[09:29:17.686]   - Field: ‘seed’
[09:29:17.686]   - Field: ‘version’
[09:29:17.686]   - Field: ‘result’
[09:29:17.686]   - Field: ‘asynchronous’
[09:29:17.687]   - Field: ‘calls’
[09:29:17.687]   - Field: ‘globals’
[09:29:17.687]   - Field: ‘stdout’
[09:29:17.687]   - Field: ‘earlySignal’
[09:29:17.687]   - Field: ‘lazy’
[09:29:17.687]   - Field: ‘state’
[09:29:17.687] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:17.688] - Launch lazy future ...
[09:29:17.688] Packages needed by the future expression (n = 0): <none>
[09:29:17.688] Packages needed by future strategies (n = 0): <none>
[09:29:17.689] {
[09:29:17.689]     {
[09:29:17.689]         {
[09:29:17.689]             ...future.startTime <- base::Sys.time()
[09:29:17.689]             {
[09:29:17.689]                 {
[09:29:17.689]                   {
[09:29:17.689]                     {
[09:29:17.689]                       base::local({
[09:29:17.689]                         has_future <- base::requireNamespace("future", 
[09:29:17.689]                           quietly = TRUE)
[09:29:17.689]                         if (has_future) {
[09:29:17.689]                           ns <- base::getNamespace("future")
[09:29:17.689]                           version <- ns[[".package"]][["version"]]
[09:29:17.689]                           if (is.null(version)) 
[09:29:17.689]                             version <- utils::packageVersion("future")
[09:29:17.689]                         }
[09:29:17.689]                         else {
[09:29:17.689]                           version <- NULL
[09:29:17.689]                         }
[09:29:17.689]                         if (!has_future || version < "1.8.0") {
[09:29:17.689]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:17.689]                             "", base::R.version$version.string), 
[09:29:17.689]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:17.689]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:17.689]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:17.689]                               "release", "version")], collapse = " "), 
[09:29:17.689]                             hostname = base::Sys.info()[["nodename"]])
[09:29:17.689]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:17.689]                             info)
[09:29:17.689]                           info <- base::paste(info, collapse = "; ")
[09:29:17.689]                           if (!has_future) {
[09:29:17.689]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:17.689]                               info)
[09:29:17.689]                           }
[09:29:17.689]                           else {
[09:29:17.689]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:17.689]                               info, version)
[09:29:17.689]                           }
[09:29:17.689]                           base::stop(msg)
[09:29:17.689]                         }
[09:29:17.689]                       })
[09:29:17.689]                     }
[09:29:17.689]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:17.689]                     base::options(mc.cores = 1L)
[09:29:17.689]                   }
[09:29:17.689]                   ...future.strategy.old <- future::plan("list")
[09:29:17.689]                   options(future.plan = NULL)
[09:29:17.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:17.689]                 }
[09:29:17.689]                 ...future.workdir <- getwd()
[09:29:17.689]             }
[09:29:17.689]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:17.689]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:17.689]         }
[09:29:17.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:17.689]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:17.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:17.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:17.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:17.689]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:17.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:17.689]             base::names(...future.oldOptions))
[09:29:17.689]     }
[09:29:17.689]     if (FALSE) {
[09:29:17.689]     }
[09:29:17.689]     else {
[09:29:17.689]         if (TRUE) {
[09:29:17.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:17.689]                 open = "w")
[09:29:17.689]         }
[09:29:17.689]         else {
[09:29:17.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:17.689]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:17.689]         }
[09:29:17.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:17.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:17.689]             base::sink(type = "output", split = FALSE)
[09:29:17.689]             base::close(...future.stdout)
[09:29:17.689]         }, add = TRUE)
[09:29:17.689]     }
[09:29:17.689]     ...future.frame <- base::sys.nframe()
[09:29:17.689]     ...future.conditions <- base::list()
[09:29:17.689]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:17.689]     if (FALSE) {
[09:29:17.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:17.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:17.689]     }
[09:29:17.689]     ...future.result <- base::tryCatch({
[09:29:17.689]         base::withCallingHandlers({
[09:29:17.689]             ...future.value <- base::withVisible(base::local({
[09:29:17.689]                 withCallingHandlers({
[09:29:17.689]                   {
[09:29:17.689]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.689]                     if (!identical(...future.globals.maxSize.org, 
[09:29:17.689]                       ...future.globals.maxSize)) {
[09:29:17.689]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.689]                       on.exit(options(oopts), add = TRUE)
[09:29:17.689]                     }
[09:29:17.689]                     {
[09:29:17.689]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.689]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:17.689]                         USE.NAMES = FALSE)
[09:29:17.689]                       do.call(mapply, args = args)
[09:29:17.689]                     }
[09:29:17.689]                   }
[09:29:17.689]                 }, immediateCondition = function(cond) {
[09:29:17.689]                   save_rds <- function (object, pathname, ...) 
[09:29:17.689]                   {
[09:29:17.689]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:17.689]                     if (file_test("-f", pathname_tmp)) {
[09:29:17.689]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.689]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:17.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.689]                         fi_tmp[["mtime"]])
[09:29:17.689]                     }
[09:29:17.689]                     tryCatch({
[09:29:17.689]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:17.689]                     }, error = function(ex) {
[09:29:17.689]                       msg <- conditionMessage(ex)
[09:29:17.689]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.689]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:17.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.689]                         fi_tmp[["mtime"]], msg)
[09:29:17.689]                       ex$message <- msg
[09:29:17.689]                       stop(ex)
[09:29:17.689]                     })
[09:29:17.689]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:17.689]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:17.689]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:17.689]                       fi_tmp <- file.info(pathname_tmp)
[09:29:17.689]                       fi <- file.info(pathname)
[09:29:17.689]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:17.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:17.689]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:17.689]                         fi[["size"]], fi[["mtime"]])
[09:29:17.689]                       stop(msg)
[09:29:17.689]                     }
[09:29:17.689]                     invisible(pathname)
[09:29:17.689]                   }
[09:29:17.689]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:17.689]                     rootPath = tempdir()) 
[09:29:17.689]                   {
[09:29:17.689]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:17.689]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:17.689]                       tmpdir = path, fileext = ".rds")
[09:29:17.689]                     save_rds(obj, file)
[09:29:17.689]                   }
[09:29:17.689]                   saveImmediateCondition(cond, path = "/tmp/RtmppvkRPO/.future/immediateConditions")
[09:29:17.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.689]                   {
[09:29:17.689]                     inherits <- base::inherits
[09:29:17.689]                     invokeRestart <- base::invokeRestart
[09:29:17.689]                     is.null <- base::is.null
[09:29:17.689]                     muffled <- FALSE
[09:29:17.689]                     if (inherits(cond, "message")) {
[09:29:17.689]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:17.689]                       if (muffled) 
[09:29:17.689]                         invokeRestart("muffleMessage")
[09:29:17.689]                     }
[09:29:17.689]                     else if (inherits(cond, "warning")) {
[09:29:17.689]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:17.689]                       if (muffled) 
[09:29:17.689]                         invokeRestart("muffleWarning")
[09:29:17.689]                     }
[09:29:17.689]                     else if (inherits(cond, "condition")) {
[09:29:17.689]                       if (!is.null(pattern)) {
[09:29:17.689]                         computeRestarts <- base::computeRestarts
[09:29:17.689]                         grepl <- base::grepl
[09:29:17.689]                         restarts <- computeRestarts(cond)
[09:29:17.689]                         for (restart in restarts) {
[09:29:17.689]                           name <- restart$name
[09:29:17.689]                           if (is.null(name)) 
[09:29:17.689]                             next
[09:29:17.689]                           if (!grepl(pattern, name)) 
[09:29:17.689]                             next
[09:29:17.689]                           invokeRestart(restart)
[09:29:17.689]                           muffled <- TRUE
[09:29:17.689]                           break
[09:29:17.689]                         }
[09:29:17.689]                       }
[09:29:17.689]                     }
[09:29:17.689]                     invisible(muffled)
[09:29:17.689]                   }
[09:29:17.689]                   muffleCondition(cond)
[09:29:17.689]                 })
[09:29:17.689]             }))
[09:29:17.689]             future::FutureResult(value = ...future.value$value, 
[09:29:17.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.689]                   ...future.rng), globalenv = if (FALSE) 
[09:29:17.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:17.689]                     ...future.globalenv.names))
[09:29:17.689]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:17.689]         }, condition = base::local({
[09:29:17.689]             c <- base::c
[09:29:17.689]             inherits <- base::inherits
[09:29:17.689]             invokeRestart <- base::invokeRestart
[09:29:17.689]             length <- base::length
[09:29:17.689]             list <- base::list
[09:29:17.689]             seq.int <- base::seq.int
[09:29:17.689]             signalCondition <- base::signalCondition
[09:29:17.689]             sys.calls <- base::sys.calls
[09:29:17.689]             `[[` <- base::`[[`
[09:29:17.689]             `+` <- base::`+`
[09:29:17.689]             `<<-` <- base::`<<-`
[09:29:17.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:17.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:17.689]                   3L)]
[09:29:17.689]             }
[09:29:17.689]             function(cond) {
[09:29:17.689]                 is_error <- inherits(cond, "error")
[09:29:17.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:17.689]                   NULL)
[09:29:17.689]                 if (is_error) {
[09:29:17.689]                   sessionInformation <- function() {
[09:29:17.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:17.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:17.689]                       search = base::search(), system = base::Sys.info())
[09:29:17.689]                   }
[09:29:17.689]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:17.689]                     cond$call), session = sessionInformation(), 
[09:29:17.689]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:17.689]                   signalCondition(cond)
[09:29:17.689]                 }
[09:29:17.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:17.689]                 "immediateCondition"))) {
[09:29:17.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:17.689]                   ...future.conditions[[length(...future.conditions) + 
[09:29:17.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:17.689]                   if (TRUE && !signal) {
[09:29:17.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.689]                     {
[09:29:17.689]                       inherits <- base::inherits
[09:29:17.689]                       invokeRestart <- base::invokeRestart
[09:29:17.689]                       is.null <- base::is.null
[09:29:17.689]                       muffled <- FALSE
[09:29:17.689]                       if (inherits(cond, "message")) {
[09:29:17.689]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.689]                         if (muffled) 
[09:29:17.689]                           invokeRestart("muffleMessage")
[09:29:17.689]                       }
[09:29:17.689]                       else if (inherits(cond, "warning")) {
[09:29:17.689]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.689]                         if (muffled) 
[09:29:17.689]                           invokeRestart("muffleWarning")
[09:29:17.689]                       }
[09:29:17.689]                       else if (inherits(cond, "condition")) {
[09:29:17.689]                         if (!is.null(pattern)) {
[09:29:17.689]                           computeRestarts <- base::computeRestarts
[09:29:17.689]                           grepl <- base::grepl
[09:29:17.689]                           restarts <- computeRestarts(cond)
[09:29:17.689]                           for (restart in restarts) {
[09:29:17.689]                             name <- restart$name
[09:29:17.689]                             if (is.null(name)) 
[09:29:17.689]                               next
[09:29:17.689]                             if (!grepl(pattern, name)) 
[09:29:17.689]                               next
[09:29:17.689]                             invokeRestart(restart)
[09:29:17.689]                             muffled <- TRUE
[09:29:17.689]                             break
[09:29:17.689]                           }
[09:29:17.689]                         }
[09:29:17.689]                       }
[09:29:17.689]                       invisible(muffled)
[09:29:17.689]                     }
[09:29:17.689]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.689]                   }
[09:29:17.689]                 }
[09:29:17.689]                 else {
[09:29:17.689]                   if (TRUE) {
[09:29:17.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:17.689]                     {
[09:29:17.689]                       inherits <- base::inherits
[09:29:17.689]                       invokeRestart <- base::invokeRestart
[09:29:17.689]                       is.null <- base::is.null
[09:29:17.689]                       muffled <- FALSE
[09:29:17.689]                       if (inherits(cond, "message")) {
[09:29:17.689]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:17.689]                         if (muffled) 
[09:29:17.689]                           invokeRestart("muffleMessage")
[09:29:17.689]                       }
[09:29:17.689]                       else if (inherits(cond, "warning")) {
[09:29:17.689]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:17.689]                         if (muffled) 
[09:29:17.689]                           invokeRestart("muffleWarning")
[09:29:17.689]                       }
[09:29:17.689]                       else if (inherits(cond, "condition")) {
[09:29:17.689]                         if (!is.null(pattern)) {
[09:29:17.689]                           computeRestarts <- base::computeRestarts
[09:29:17.689]                           grepl <- base::grepl
[09:29:17.689]                           restarts <- computeRestarts(cond)
[09:29:17.689]                           for (restart in restarts) {
[09:29:17.689]                             name <- restart$name
[09:29:17.689]                             if (is.null(name)) 
[09:29:17.689]                               next
[09:29:17.689]                             if (!grepl(pattern, name)) 
[09:29:17.689]                               next
[09:29:17.689]                             invokeRestart(restart)
[09:29:17.689]                             muffled <- TRUE
[09:29:17.689]                             break
[09:29:17.689]                           }
[09:29:17.689]                         }
[09:29:17.689]                       }
[09:29:17.689]                       invisible(muffled)
[09:29:17.689]                     }
[09:29:17.689]                     muffleCondition(cond, pattern = "^muffle")
[09:29:17.689]                   }
[09:29:17.689]                 }
[09:29:17.689]             }
[09:29:17.689]         }))
[09:29:17.689]     }, error = function(ex) {
[09:29:17.689]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:17.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:17.689]                 ...future.rng), started = ...future.startTime, 
[09:29:17.689]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:17.689]             version = "1.8"), class = "FutureResult")
[09:29:17.689]     }, finally = {
[09:29:17.689]         if (!identical(...future.workdir, getwd())) 
[09:29:17.689]             setwd(...future.workdir)
[09:29:17.689]         {
[09:29:17.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:17.689]                 ...future.oldOptions$nwarnings <- NULL
[09:29:17.689]             }
[09:29:17.689]             base::options(...future.oldOptions)
[09:29:17.689]             if (.Platform$OS.type == "windows") {
[09:29:17.689]                 old_names <- names(...future.oldEnvVars)
[09:29:17.689]                 envs <- base::Sys.getenv()
[09:29:17.689]                 names <- names(envs)
[09:29:17.689]                 common <- intersect(names, old_names)
[09:29:17.689]                 added <- setdiff(names, old_names)
[09:29:17.689]                 removed <- setdiff(old_names, names)
[09:29:17.689]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:17.689]                   envs[common]]
[09:29:17.689]                 NAMES <- toupper(changed)
[09:29:17.689]                 args <- list()
[09:29:17.689]                 for (kk in seq_along(NAMES)) {
[09:29:17.689]                   name <- changed[[kk]]
[09:29:17.689]                   NAME <- NAMES[[kk]]
[09:29:17.689]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.689]                     next
[09:29:17.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.689]                 }
[09:29:17.689]                 NAMES <- toupper(added)
[09:29:17.689]                 for (kk in seq_along(NAMES)) {
[09:29:17.689]                   name <- added[[kk]]
[09:29:17.689]                   NAME <- NAMES[[kk]]
[09:29:17.689]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.689]                     next
[09:29:17.689]                   args[[name]] <- ""
[09:29:17.689]                 }
[09:29:17.689]                 NAMES <- toupper(removed)
[09:29:17.689]                 for (kk in seq_along(NAMES)) {
[09:29:17.689]                   name <- removed[[kk]]
[09:29:17.689]                   NAME <- NAMES[[kk]]
[09:29:17.689]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:17.689]                     next
[09:29:17.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:17.689]                 }
[09:29:17.689]                 if (length(args) > 0) 
[09:29:17.689]                   base::do.call(base::Sys.setenv, args = args)
[09:29:17.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:17.689]             }
[09:29:17.689]             else {
[09:29:17.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:17.689]             }
[09:29:17.689]             {
[09:29:17.689]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:17.689]                   0L) {
[09:29:17.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:17.689]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:17.689]                   base::options(opts)
[09:29:17.689]                 }
[09:29:17.689]                 {
[09:29:17.689]                   {
[09:29:17.689]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:17.689]                     NULL
[09:29:17.689]                   }
[09:29:17.689]                   options(future.plan = NULL)
[09:29:17.689]                   if (is.na(NA_character_)) 
[09:29:17.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:17.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:17.689]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:17.689]                     .init = FALSE)
[09:29:17.689]                 }
[09:29:17.689]             }
[09:29:17.689]         }
[09:29:17.689]     })
[09:29:17.689]     if (TRUE) {
[09:29:17.689]         base::sink(type = "output", split = FALSE)
[09:29:17.689]         if (TRUE) {
[09:29:17.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:17.689]         }
[09:29:17.689]         else {
[09:29:17.689]             ...future.result["stdout"] <- base::list(NULL)
[09:29:17.689]         }
[09:29:17.689]         base::close(...future.stdout)
[09:29:17.689]         ...future.stdout <- NULL
[09:29:17.689]     }
[09:29:17.689]     ...future.result$conditions <- ...future.conditions
[09:29:17.689]     ...future.result$finished <- base::Sys.time()
[09:29:17.689]     ...future.result
[09:29:17.689] }
[09:29:17.692] assign_globals() ...
[09:29:17.692] List of 5
[09:29:17.692]  $ ...future.FUN            :function (x)  
[09:29:17.692]  $ MoreArgs                 : NULL
[09:29:17.692]  $ ...future.elements_ii    :List of 1
[09:29:17.692]   ..$ :List of 1
[09:29:17.692]   .. ..$ b: num 0
[09:29:17.692]  $ ...future.seeds_ii       : NULL
[09:29:17.692]  $ ...future.globals.maxSize: NULL
[09:29:17.692]  - attr(*, "where")=List of 5
[09:29:17.692]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:17.692]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[09:29:17.692]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:17.692]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:17.692]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:17.692]  - attr(*, "resolved")= logi FALSE
[09:29:17.692]  - attr(*, "total_size")= num 904
[09:29:17.692]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:17.692]  - attr(*, "already-done")= logi TRUE
[09:29:17.705] - copied ‘...future.FUN’ to environment
[09:29:17.705] - copied ‘MoreArgs’ to environment
[09:29:17.706] - copied ‘...future.elements_ii’ to environment
[09:29:17.706] - copied ‘...future.seeds_ii’ to environment
[09:29:17.706] - copied ‘...future.globals.maxSize’ to environment
[09:29:17.706] assign_globals() ... done
[09:29:17.706] requestCore(): workers = 2
[09:29:17.709] MulticoreFuture started
[09:29:17.709] - Launch lazy future ... done
[09:29:17.710] run() for ‘MulticoreFuture’ ... done
[09:29:17.710] plan(): Setting new future strategy stack:
[09:29:17.710] Created future:
[09:29:17.710] List of future strategies:
[09:29:17.710] 1. sequential:
[09:29:17.710]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:17.710]    - tweaked: FALSE
[09:29:17.710]    - call: NULL
[09:29:17.712] plan(): nbrOfWorkers() = 1
[09:29:17.715] plan(): Setting new future strategy stack:
[09:29:17.715] List of future strategies:
[09:29:17.715] 1. multicore:
[09:29:17.715]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:17.715]    - tweaked: FALSE
[09:29:17.715]    - call: plan(strategy)
[09:29:17.720] plan(): nbrOfWorkers() = 2
[09:29:17.711] MulticoreFuture:
[09:29:17.711] Label: ‘future_mapply-2’
[09:29:17.711] Expression:
[09:29:17.711] {
[09:29:17.711]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:17.711]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:17.711]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:17.711]         on.exit(options(oopts), add = TRUE)
[09:29:17.711]     }
[09:29:17.711]     {
[09:29:17.711]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:17.711]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:17.711]         do.call(mapply, args = args)
[09:29:17.711]     }
[09:29:17.711] }
[09:29:17.711] Lazy evaluation: FALSE
[09:29:17.711] Asynchronous evaluation: TRUE
[09:29:17.711] Local evaluation: TRUE
[09:29:17.711] Environment: R_GlobalEnv
[09:29:17.711] Capture standard output: TRUE
[09:29:17.711] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:17.711] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:17.711] Packages: <none>
[09:29:17.711] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:17.711] Resolved: TRUE
[09:29:17.711] Value: <not collected>
[09:29:17.711] Conditions captured: <none>
[09:29:17.711] Early signaling: FALSE
[09:29:17.711] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:17.711] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:17.722] Chunk #2 of 2 ... DONE
[09:29:17.722] Launching 2 futures (chunks) ... DONE
[09:29:17.722] Resolving 2 futures (chunks) ...
[09:29:17.722] resolve() on list ...
[09:29:17.722]  recursive: 0
[09:29:17.722]  length: 2
[09:29:17.723] 
[09:29:17.723] Future #1
[09:29:17.723] result() for MulticoreFuture ...
[09:29:17.724] result() for MulticoreFuture ...
[09:29:17.724] result() for MulticoreFuture ... done
[09:29:17.724] result() for MulticoreFuture ... done
[09:29:17.725] result() for MulticoreFuture ...
[09:29:17.725] result() for MulticoreFuture ... done
[09:29:17.725] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:17.725] - nx: 2
[09:29:17.725] - relay: TRUE
[09:29:17.725] - stdout: TRUE
[09:29:17.725] - signal: TRUE
[09:29:17.726] - resignal: FALSE
[09:29:17.726] - force: TRUE
[09:29:17.726] - relayed: [n=2] FALSE, FALSE
[09:29:17.726] - queued futures: [n=2] FALSE, FALSE
[09:29:17.726]  - until=1
[09:29:17.726]  - relaying element #1
[09:29:17.727] result() for MulticoreFuture ...
[09:29:17.727] result() for MulticoreFuture ... done
[09:29:17.727] result() for MulticoreFuture ...
[09:29:17.727] result() for MulticoreFuture ... done
[09:29:17.727] result() for MulticoreFuture ...
[09:29:17.728] result() for MulticoreFuture ... done
[09:29:17.728] result() for MulticoreFuture ...
[09:29:17.728] result() for MulticoreFuture ... done
[09:29:17.728] - relayed: [n=2] TRUE, FALSE
[09:29:17.728] - queued futures: [n=2] TRUE, FALSE
[09:29:17.728] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:17.729]  length: 1 (resolved future 1)
[09:29:17.729] Future #2
[09:29:17.729] result() for MulticoreFuture ...
[09:29:17.730] result() for MulticoreFuture ...
[09:29:17.730] result() for MulticoreFuture ... done
[09:29:17.730] result() for MulticoreFuture ... done
[09:29:17.730] result() for MulticoreFuture ...
[09:29:17.730] result() for MulticoreFuture ... done
[09:29:17.731] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:17.731] - nx: 2
[09:29:17.731] - relay: TRUE
[09:29:17.731] - stdout: TRUE
[09:29:17.731] - signal: TRUE
[09:29:17.731] - resignal: FALSE
[09:29:17.731] - force: TRUE
[09:29:17.731] - relayed: [n=2] TRUE, FALSE
[09:29:17.731] - queued futures: [n=2] TRUE, FALSE
[09:29:17.732]  - until=2
[09:29:17.732]  - relaying element #2
[09:29:17.732] result() for MulticoreFuture ...
[09:29:17.732] result() for MulticoreFuture ... done
[09:29:17.732] result() for MulticoreFuture ...
[09:29:17.732] result() for MulticoreFuture ... done
[09:29:17.732] result() for MulticoreFuture ...
[09:29:17.732] result() for MulticoreFuture ... done
[09:29:17.733] result() for MulticoreFuture ...
[09:29:17.733] result() for MulticoreFuture ... done
[09:29:17.733] - relayed: [n=2] TRUE, TRUE
[09:29:17.733] - queued futures: [n=2] TRUE, TRUE
[09:29:17.733] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:17.733]  length: 0 (resolved future 2)
[09:29:17.733] Relaying remaining futures
[09:29:17.733] signalConditionsASAP(NULL, pos=0) ...
[09:29:17.733] - nx: 2
[09:29:17.733] - relay: TRUE
[09:29:17.734] - stdout: TRUE
[09:29:17.734] - signal: TRUE
[09:29:17.734] - resignal: FALSE
[09:29:17.734] - force: TRUE
[09:29:17.734] - relayed: [n=2] TRUE, TRUE
[09:29:17.734] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:17.734] - relayed: [n=2] TRUE, TRUE
[09:29:17.734] - queued futures: [n=2] TRUE, TRUE
[09:29:17.734] signalConditionsASAP(NULL, pos=0) ... done
[09:29:17.734] resolve() on list ... DONE
[09:29:17.735] result() for MulticoreFuture ...
[09:29:17.735] result() for MulticoreFuture ... done
[09:29:17.735] result() for MulticoreFuture ...
[09:29:17.735] result() for MulticoreFuture ... done
[09:29:17.735] result() for MulticoreFuture ...
[09:29:17.735] result() for MulticoreFuture ... done
[09:29:17.735] result() for MulticoreFuture ...
[09:29:17.735] result() for MulticoreFuture ... done
[09:29:17.736]  - Number of value chunks collected: 2
[09:29:17.736] Resolving 2 futures (chunks) ... DONE
[09:29:17.736] Reducing values from 2 chunks ...
[09:29:17.736]  - Number of values collected after concatenation: 2
[09:29:17.736]  - Number of values expected: 2
[09:29:17.736] Reducing values from 2 chunks ... DONE
[09:29:17.736] future_mapply() ... DONE
[09:29:17.736] plan(): Setting new future strategy stack:
[09:29:17.737] List of future strategies:
[09:29:17.737] 1. sequential:
[09:29:17.737]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:17.737]    - tweaked: FALSE
[09:29:17.737]    - call: plan(sequential)
[09:29:17.737] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[09:29:17.738] plan(): Setting new future strategy stack:
[09:29:17.741] List of future strategies:
[09:29:17.741] 1. multisession:
[09:29:17.741]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:29:17.741]    - tweaked: FALSE
[09:29:17.741]    - call: plan(strategy)
[09:29:17.741] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:29:17.741] multisession:
[09:29:17.741] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:29:17.741] - tweaked: FALSE
[09:29:17.741] - call: plan(strategy)
[09:29:17.748] getGlobalsAndPackages() ...
[09:29:17.748] Not searching for globals
[09:29:17.749] - globals: [0] <none>
[09:29:17.749] getGlobalsAndPackages() ... DONE
[09:29:17.749] [local output] makeClusterPSOCK() ...
[09:29:17.796] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:29:17.797] [local output] Base port: 11190
[09:29:17.797] [local output] Getting setup options for 2 cluster nodes ...
[09:29:17.797] [local output]  - Node 1 of 2 ...
[09:29:17.797] [local output] localMachine=TRUE => revtunnel=FALSE

[09:29:17.798] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmppvkRPO/worker.rank=1.parallelly.parent=34422.8676fb65d66.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmppvkRPO/worker.rank=1.parallelly.parent=34422.8676fb65d66.pid")'’
[09:29:17.985] - Possible to infer worker's PID: TRUE
[09:29:17.986] [local output] Rscript port: 11190

[09:29:17.986] [local output]  - Node 2 of 2 ...
[09:29:17.986] [local output] localMachine=TRUE => revtunnel=FALSE

[09:29:17.987] [local output] Rscript port: 11190

[09:29:17.987] [local output] Getting setup options for 2 cluster nodes ... done
[09:29:17.987] [local output]  - Parallel setup requested for some PSOCK nodes
[09:29:17.988] [local output] Setting up PSOCK nodes in parallel
[09:29:17.988] List of 36
[09:29:17.988]  $ worker          : chr "localhost"
[09:29:17.988]   ..- attr(*, "localhost")= logi TRUE
[09:29:17.988]  $ master          : chr "localhost"
[09:29:17.988]  $ port            : int 11190
[09:29:17.988]  $ connectTimeout  : num 120
[09:29:17.988]  $ timeout         : num 2592000
[09:29:17.988]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:29:17.988]  $ homogeneous     : logi TRUE
[09:29:17.988]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:29:17.988]  $ rscript_envs    : NULL
[09:29:17.988]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:29:17.988]  $ rscript_startup : NULL
[09:29:17.988]  $ rscript_sh      : chr "sh"
[09:29:17.988]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:29:17.988]  $ methods         : logi TRUE
[09:29:17.988]  $ socketOptions   : chr "no-delay"
[09:29:17.988]  $ useXDR          : logi FALSE
[09:29:17.988]  $ outfile         : chr "/dev/null"
[09:29:17.988]  $ renice          : int NA
[09:29:17.988]  $ rshcmd          : NULL
[09:29:17.988]  $ user            : chr(0) 
[09:29:17.988]  $ revtunnel       : logi FALSE
[09:29:17.988]  $ rshlogfile      : NULL
[09:29:17.988]  $ rshopts         : chr(0) 
[09:29:17.988]  $ rank            : int 1
[09:29:17.988]  $ manual          : logi FALSE
[09:29:17.988]  $ dryrun          : logi FALSE
[09:29:17.988]  $ quiet           : logi FALSE
[09:29:17.988]  $ setup_strategy  : chr "parallel"
[09:29:17.988]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:29:17.988]  $ pidfile         : chr "/tmp/RtmppvkRPO/worker.rank=1.parallelly.parent=34422.8676fb65d66.pid"
[09:29:17.988]  $ rshcmd_label    : NULL
[09:29:17.988]  $ rsh_call        : NULL
[09:29:17.988]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:29:17.988]  $ localMachine    : logi TRUE
[09:29:17.988]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:29:17.988]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:29:17.988]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:29:17.988]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:29:17.988]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:29:17.988]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:29:17.988]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:29:17.988]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:29:17.988]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:29:17.988]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:29:17.988]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:29:17.988]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:29:17.988]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:29:17.988]  $ arguments       :List of 28
[09:29:17.988]   ..$ worker          : chr "localhost"
[09:29:17.988]   ..$ master          : NULL
[09:29:17.988]   ..$ port            : int 11190
[09:29:17.988]   ..$ connectTimeout  : num 120
[09:29:17.988]   ..$ timeout         : num 2592000
[09:29:17.988]   ..$ rscript         : NULL
[09:29:17.988]   ..$ homogeneous     : NULL
[09:29:17.988]   ..$ rscript_args    : NULL
[09:29:17.988]   ..$ rscript_envs    : NULL
[09:29:17.988]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:29:17.988]   ..$ rscript_startup : NULL
[09:29:17.988]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:29:17.988]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:29:17.988]   ..$ methods         : logi TRUE
[09:29:17.988]   ..$ socketOptions   : chr "no-delay"
[09:29:17.988]   ..$ useXDR          : logi FALSE
[09:29:17.988]   ..$ outfile         : chr "/dev/null"
[09:29:17.988]   ..$ renice          : int NA
[09:29:17.988]   ..$ rshcmd          : NULL
[09:29:17.988]   ..$ user            : NULL
[09:29:17.988]   ..$ revtunnel       : logi NA
[09:29:17.988]   ..$ rshlogfile      : NULL
[09:29:17.988]   ..$ rshopts         : NULL
[09:29:17.988]   ..$ rank            : int 1
[09:29:17.988]   ..$ manual          : logi FALSE
[09:29:17.988]   ..$ dryrun          : logi FALSE
[09:29:17.988]   ..$ quiet           : logi FALSE
[09:29:17.988]   ..$ setup_strategy  : chr "parallel"
[09:29:17.988]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:29:18.005] [local output] System call to launch all workers:
[09:29:18.005] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmppvkRPO/worker.rank=1.parallelly.parent=34422.8676fb65d66.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11190 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:29:18.005] [local output] Starting PSOCK main server
[09:29:18.010] [local output] Workers launched
[09:29:18.010] [local output] Waiting for workers to connect back
[09:29:18.011]  - [local output] 0 workers out of 2 ready
[09:29:18.249]  - [local output] 0 workers out of 2 ready
[09:29:18.250]  - [local output] 1 workers out of 2 ready
[09:29:18.251]  - [local output] 1 workers out of 2 ready
[09:29:18.252]  - [local output] 2 workers out of 2 ready
[09:29:18.252] [local output] Launching of workers completed
[09:29:18.252] [local output] Collecting session information from workers
[09:29:18.253] [local output]  - Worker #1 of 2
[09:29:18.253] [local output]  - Worker #2 of 2
[09:29:18.253] [local output] makeClusterPSOCK() ... done
[09:29:18.265] Packages needed by the future expression (n = 0): <none>
[09:29:18.265] Packages needed by future strategies (n = 0): <none>
[09:29:18.265] {
[09:29:18.265]     {
[09:29:18.265]         {
[09:29:18.265]             ...future.startTime <- base::Sys.time()
[09:29:18.265]             {
[09:29:18.265]                 {
[09:29:18.265]                   {
[09:29:18.265]                     {
[09:29:18.265]                       base::local({
[09:29:18.265]                         has_future <- base::requireNamespace("future", 
[09:29:18.265]                           quietly = TRUE)
[09:29:18.265]                         if (has_future) {
[09:29:18.265]                           ns <- base::getNamespace("future")
[09:29:18.265]                           version <- ns[[".package"]][["version"]]
[09:29:18.265]                           if (is.null(version)) 
[09:29:18.265]                             version <- utils::packageVersion("future")
[09:29:18.265]                         }
[09:29:18.265]                         else {
[09:29:18.265]                           version <- NULL
[09:29:18.265]                         }
[09:29:18.265]                         if (!has_future || version < "1.8.0") {
[09:29:18.265]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:18.265]                             "", base::R.version$version.string), 
[09:29:18.265]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:18.265]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:18.265]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:18.265]                               "release", "version")], collapse = " "), 
[09:29:18.265]                             hostname = base::Sys.info()[["nodename"]])
[09:29:18.265]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:18.265]                             info)
[09:29:18.265]                           info <- base::paste(info, collapse = "; ")
[09:29:18.265]                           if (!has_future) {
[09:29:18.265]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:18.265]                               info)
[09:29:18.265]                           }
[09:29:18.265]                           else {
[09:29:18.265]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:18.265]                               info, version)
[09:29:18.265]                           }
[09:29:18.265]                           base::stop(msg)
[09:29:18.265]                         }
[09:29:18.265]                       })
[09:29:18.265]                     }
[09:29:18.265]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:18.265]                     base::options(mc.cores = 1L)
[09:29:18.265]                   }
[09:29:18.265]                   ...future.strategy.old <- future::plan("list")
[09:29:18.265]                   options(future.plan = NULL)
[09:29:18.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:18.265]                 }
[09:29:18.265]                 ...future.workdir <- getwd()
[09:29:18.265]             }
[09:29:18.265]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:18.265]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:18.265]         }
[09:29:18.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:18.265]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:18.265]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:18.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:18.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:18.265]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:18.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:18.265]             base::names(...future.oldOptions))
[09:29:18.265]     }
[09:29:18.265]     if (FALSE) {
[09:29:18.265]     }
[09:29:18.265]     else {
[09:29:18.265]         if (TRUE) {
[09:29:18.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:18.265]                 open = "w")
[09:29:18.265]         }
[09:29:18.265]         else {
[09:29:18.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:18.265]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:18.265]         }
[09:29:18.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:18.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:18.265]             base::sink(type = "output", split = FALSE)
[09:29:18.265]             base::close(...future.stdout)
[09:29:18.265]         }, add = TRUE)
[09:29:18.265]     }
[09:29:18.265]     ...future.frame <- base::sys.nframe()
[09:29:18.265]     ...future.conditions <- base::list()
[09:29:18.265]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:18.265]     if (FALSE) {
[09:29:18.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:18.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:18.265]     }
[09:29:18.265]     ...future.result <- base::tryCatch({
[09:29:18.265]         base::withCallingHandlers({
[09:29:18.265]             ...future.value <- base::withVisible(base::local({
[09:29:18.265]                 ...future.makeSendCondition <- base::local({
[09:29:18.265]                   sendCondition <- NULL
[09:29:18.265]                   function(frame = 1L) {
[09:29:18.265]                     if (is.function(sendCondition)) 
[09:29:18.265]                       return(sendCondition)
[09:29:18.265]                     ns <- getNamespace("parallel")
[09:29:18.265]                     if (exists("sendData", mode = "function", 
[09:29:18.265]                       envir = ns)) {
[09:29:18.265]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:18.265]                         envir = ns)
[09:29:18.265]                       envir <- sys.frame(frame)
[09:29:18.265]                       master <- NULL
[09:29:18.265]                       while (!identical(envir, .GlobalEnv) && 
[09:29:18.265]                         !identical(envir, emptyenv())) {
[09:29:18.265]                         if (exists("master", mode = "list", envir = envir, 
[09:29:18.265]                           inherits = FALSE)) {
[09:29:18.265]                           master <- get("master", mode = "list", 
[09:29:18.265]                             envir = envir, inherits = FALSE)
[09:29:18.265]                           if (inherits(master, c("SOCKnode", 
[09:29:18.265]                             "SOCK0node"))) {
[09:29:18.265]                             sendCondition <<- function(cond) {
[09:29:18.265]                               data <- list(type = "VALUE", value = cond, 
[09:29:18.265]                                 success = TRUE)
[09:29:18.265]                               parallel_sendData(master, data)
[09:29:18.265]                             }
[09:29:18.265]                             return(sendCondition)
[09:29:18.265]                           }
[09:29:18.265]                         }
[09:29:18.265]                         frame <- frame + 1L
[09:29:18.265]                         envir <- sys.frame(frame)
[09:29:18.265]                       }
[09:29:18.265]                     }
[09:29:18.265]                     sendCondition <<- function(cond) NULL
[09:29:18.265]                   }
[09:29:18.265]                 })
[09:29:18.265]                 withCallingHandlers({
[09:29:18.265]                   NA
[09:29:18.265]                 }, immediateCondition = function(cond) {
[09:29:18.265]                   sendCondition <- ...future.makeSendCondition()
[09:29:18.265]                   sendCondition(cond)
[09:29:18.265]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.265]                   {
[09:29:18.265]                     inherits <- base::inherits
[09:29:18.265]                     invokeRestart <- base::invokeRestart
[09:29:18.265]                     is.null <- base::is.null
[09:29:18.265]                     muffled <- FALSE
[09:29:18.265]                     if (inherits(cond, "message")) {
[09:29:18.265]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:18.265]                       if (muffled) 
[09:29:18.265]                         invokeRestart("muffleMessage")
[09:29:18.265]                     }
[09:29:18.265]                     else if (inherits(cond, "warning")) {
[09:29:18.265]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:18.265]                       if (muffled) 
[09:29:18.265]                         invokeRestart("muffleWarning")
[09:29:18.265]                     }
[09:29:18.265]                     else if (inherits(cond, "condition")) {
[09:29:18.265]                       if (!is.null(pattern)) {
[09:29:18.265]                         computeRestarts <- base::computeRestarts
[09:29:18.265]                         grepl <- base::grepl
[09:29:18.265]                         restarts <- computeRestarts(cond)
[09:29:18.265]                         for (restart in restarts) {
[09:29:18.265]                           name <- restart$name
[09:29:18.265]                           if (is.null(name)) 
[09:29:18.265]                             next
[09:29:18.265]                           if (!grepl(pattern, name)) 
[09:29:18.265]                             next
[09:29:18.265]                           invokeRestart(restart)
[09:29:18.265]                           muffled <- TRUE
[09:29:18.265]                           break
[09:29:18.265]                         }
[09:29:18.265]                       }
[09:29:18.265]                     }
[09:29:18.265]                     invisible(muffled)
[09:29:18.265]                   }
[09:29:18.265]                   muffleCondition(cond)
[09:29:18.265]                 })
[09:29:18.265]             }))
[09:29:18.265]             future::FutureResult(value = ...future.value$value, 
[09:29:18.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.265]                   ...future.rng), globalenv = if (FALSE) 
[09:29:18.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:18.265]                     ...future.globalenv.names))
[09:29:18.265]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:18.265]         }, condition = base::local({
[09:29:18.265]             c <- base::c
[09:29:18.265]             inherits <- base::inherits
[09:29:18.265]             invokeRestart <- base::invokeRestart
[09:29:18.265]             length <- base::length
[09:29:18.265]             list <- base::list
[09:29:18.265]             seq.int <- base::seq.int
[09:29:18.265]             signalCondition <- base::signalCondition
[09:29:18.265]             sys.calls <- base::sys.calls
[09:29:18.265]             `[[` <- base::`[[`
[09:29:18.265]             `+` <- base::`+`
[09:29:18.265]             `<<-` <- base::`<<-`
[09:29:18.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:18.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:18.265]                   3L)]
[09:29:18.265]             }
[09:29:18.265]             function(cond) {
[09:29:18.265]                 is_error <- inherits(cond, "error")
[09:29:18.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:18.265]                   NULL)
[09:29:18.265]                 if (is_error) {
[09:29:18.265]                   sessionInformation <- function() {
[09:29:18.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:18.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:18.265]                       search = base::search(), system = base::Sys.info())
[09:29:18.265]                   }
[09:29:18.265]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:18.265]                     cond$call), session = sessionInformation(), 
[09:29:18.265]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:18.265]                   signalCondition(cond)
[09:29:18.265]                 }
[09:29:18.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:18.265]                 "immediateCondition"))) {
[09:29:18.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:18.265]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:18.265]                   if (TRUE && !signal) {
[09:29:18.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.265]                     {
[09:29:18.265]                       inherits <- base::inherits
[09:29:18.265]                       invokeRestart <- base::invokeRestart
[09:29:18.265]                       is.null <- base::is.null
[09:29:18.265]                       muffled <- FALSE
[09:29:18.265]                       if (inherits(cond, "message")) {
[09:29:18.265]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.265]                         if (muffled) 
[09:29:18.265]                           invokeRestart("muffleMessage")
[09:29:18.265]                       }
[09:29:18.265]                       else if (inherits(cond, "warning")) {
[09:29:18.265]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.265]                         if (muffled) 
[09:29:18.265]                           invokeRestart("muffleWarning")
[09:29:18.265]                       }
[09:29:18.265]                       else if (inherits(cond, "condition")) {
[09:29:18.265]                         if (!is.null(pattern)) {
[09:29:18.265]                           computeRestarts <- base::computeRestarts
[09:29:18.265]                           grepl <- base::grepl
[09:29:18.265]                           restarts <- computeRestarts(cond)
[09:29:18.265]                           for (restart in restarts) {
[09:29:18.265]                             name <- restart$name
[09:29:18.265]                             if (is.null(name)) 
[09:29:18.265]                               next
[09:29:18.265]                             if (!grepl(pattern, name)) 
[09:29:18.265]                               next
[09:29:18.265]                             invokeRestart(restart)
[09:29:18.265]                             muffled <- TRUE
[09:29:18.265]                             break
[09:29:18.265]                           }
[09:29:18.265]                         }
[09:29:18.265]                       }
[09:29:18.265]                       invisible(muffled)
[09:29:18.265]                     }
[09:29:18.265]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.265]                   }
[09:29:18.265]                 }
[09:29:18.265]                 else {
[09:29:18.265]                   if (TRUE) {
[09:29:18.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.265]                     {
[09:29:18.265]                       inherits <- base::inherits
[09:29:18.265]                       invokeRestart <- base::invokeRestart
[09:29:18.265]                       is.null <- base::is.null
[09:29:18.265]                       muffled <- FALSE
[09:29:18.265]                       if (inherits(cond, "message")) {
[09:29:18.265]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.265]                         if (muffled) 
[09:29:18.265]                           invokeRestart("muffleMessage")
[09:29:18.265]                       }
[09:29:18.265]                       else if (inherits(cond, "warning")) {
[09:29:18.265]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.265]                         if (muffled) 
[09:29:18.265]                           invokeRestart("muffleWarning")
[09:29:18.265]                       }
[09:29:18.265]                       else if (inherits(cond, "condition")) {
[09:29:18.265]                         if (!is.null(pattern)) {
[09:29:18.265]                           computeRestarts <- base::computeRestarts
[09:29:18.265]                           grepl <- base::grepl
[09:29:18.265]                           restarts <- computeRestarts(cond)
[09:29:18.265]                           for (restart in restarts) {
[09:29:18.265]                             name <- restart$name
[09:29:18.265]                             if (is.null(name)) 
[09:29:18.265]                               next
[09:29:18.265]                             if (!grepl(pattern, name)) 
[09:29:18.265]                               next
[09:29:18.265]                             invokeRestart(restart)
[09:29:18.265]                             muffled <- TRUE
[09:29:18.265]                             break
[09:29:18.265]                           }
[09:29:18.265]                         }
[09:29:18.265]                       }
[09:29:18.265]                       invisible(muffled)
[09:29:18.265]                     }
[09:29:18.265]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.265]                   }
[09:29:18.265]                 }
[09:29:18.265]             }
[09:29:18.265]         }))
[09:29:18.265]     }, error = function(ex) {
[09:29:18.265]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:18.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.265]                 ...future.rng), started = ...future.startTime, 
[09:29:18.265]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:18.265]             version = "1.8"), class = "FutureResult")
[09:29:18.265]     }, finally = {
[09:29:18.265]         if (!identical(...future.workdir, getwd())) 
[09:29:18.265]             setwd(...future.workdir)
[09:29:18.265]         {
[09:29:18.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:18.265]                 ...future.oldOptions$nwarnings <- NULL
[09:29:18.265]             }
[09:29:18.265]             base::options(...future.oldOptions)
[09:29:18.265]             if (.Platform$OS.type == "windows") {
[09:29:18.265]                 old_names <- names(...future.oldEnvVars)
[09:29:18.265]                 envs <- base::Sys.getenv()
[09:29:18.265]                 names <- names(envs)
[09:29:18.265]                 common <- intersect(names, old_names)
[09:29:18.265]                 added <- setdiff(names, old_names)
[09:29:18.265]                 removed <- setdiff(old_names, names)
[09:29:18.265]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:18.265]                   envs[common]]
[09:29:18.265]                 NAMES <- toupper(changed)
[09:29:18.265]                 args <- list()
[09:29:18.265]                 for (kk in seq_along(NAMES)) {
[09:29:18.265]                   name <- changed[[kk]]
[09:29:18.265]                   NAME <- NAMES[[kk]]
[09:29:18.265]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.265]                     next
[09:29:18.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.265]                 }
[09:29:18.265]                 NAMES <- toupper(added)
[09:29:18.265]                 for (kk in seq_along(NAMES)) {
[09:29:18.265]                   name <- added[[kk]]
[09:29:18.265]                   NAME <- NAMES[[kk]]
[09:29:18.265]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.265]                     next
[09:29:18.265]                   args[[name]] <- ""
[09:29:18.265]                 }
[09:29:18.265]                 NAMES <- toupper(removed)
[09:29:18.265]                 for (kk in seq_along(NAMES)) {
[09:29:18.265]                   name <- removed[[kk]]
[09:29:18.265]                   NAME <- NAMES[[kk]]
[09:29:18.265]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.265]                     next
[09:29:18.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.265]                 }
[09:29:18.265]                 if (length(args) > 0) 
[09:29:18.265]                   base::do.call(base::Sys.setenv, args = args)
[09:29:18.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:18.265]             }
[09:29:18.265]             else {
[09:29:18.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:18.265]             }
[09:29:18.265]             {
[09:29:18.265]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:18.265]                   0L) {
[09:29:18.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:18.265]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:18.265]                   base::options(opts)
[09:29:18.265]                 }
[09:29:18.265]                 {
[09:29:18.265]                   {
[09:29:18.265]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:18.265]                     NULL
[09:29:18.265]                   }
[09:29:18.265]                   options(future.plan = NULL)
[09:29:18.265]                   if (is.na(NA_character_)) 
[09:29:18.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:18.265]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:18.265]                     .init = FALSE)
[09:29:18.265]                 }
[09:29:18.265]             }
[09:29:18.265]         }
[09:29:18.265]     })
[09:29:18.265]     if (TRUE) {
[09:29:18.265]         base::sink(type = "output", split = FALSE)
[09:29:18.265]         if (TRUE) {
[09:29:18.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:18.265]         }
[09:29:18.265]         else {
[09:29:18.265]             ...future.result["stdout"] <- base::list(NULL)
[09:29:18.265]         }
[09:29:18.265]         base::close(...future.stdout)
[09:29:18.265]         ...future.stdout <- NULL
[09:29:18.265]     }
[09:29:18.265]     ...future.result$conditions <- ...future.conditions
[09:29:18.265]     ...future.result$finished <- base::Sys.time()
[09:29:18.265]     ...future.result
[09:29:18.265] }
[09:29:18.316] MultisessionFuture started
[09:29:18.317] result() for ClusterFuture ...
[09:29:18.317] receiveMessageFromWorker() for ClusterFuture ...
[09:29:18.318] - Validating connection of MultisessionFuture
[09:29:18.348] - received message: FutureResult
[09:29:18.349] - Received FutureResult
[09:29:18.349] - Erased future from FutureRegistry
[09:29:18.349] result() for ClusterFuture ...
[09:29:18.349] - result already collected: FutureResult
[09:29:18.349] result() for ClusterFuture ... done
[09:29:18.349] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:18.349] result() for ClusterFuture ... done
[09:29:18.350] result() for ClusterFuture ...
[09:29:18.350] - result already collected: FutureResult
[09:29:18.350] result() for ClusterFuture ... done
[09:29:18.350] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:29:18.354] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[09:29:18.354] future_mapply() ...
[09:29:18.358] Number of chunks: 2
[09:29:18.358] getGlobalsAndPackagesXApply() ...
[09:29:18.358]  - future.globals: TRUE
[09:29:18.358] getGlobalsAndPackages() ...
[09:29:18.358] Searching for globals...
[09:29:18.359] - globals found: [1] ‘FUN’
[09:29:18.359] Searching for globals ... DONE
[09:29:18.359] Resolving globals: FALSE
[09:29:18.360] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:18.360] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:18.360] - globals: [1] ‘FUN’
[09:29:18.360] 
[09:29:18.360] getGlobalsAndPackages() ... DONE
[09:29:18.361]  - globals found/used: [n=1] ‘FUN’
[09:29:18.361]  - needed namespaces: [n=0] 
[09:29:18.361] Finding globals ... DONE
[09:29:18.361] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:18.361] List of 2
[09:29:18.361]  $ ...future.FUN:function (x, ...)  
[09:29:18.361]  $ MoreArgs     : NULL
[09:29:18.361]  - attr(*, "where")=List of 2
[09:29:18.361]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:18.361]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:18.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:18.361]  - attr(*, "resolved")= logi FALSE
[09:29:18.361]  - attr(*, "total_size")= num NA
[09:29:18.364] Packages to be attached in all futures: [n=0] 
[09:29:18.364] getGlobalsAndPackagesXApply() ... DONE
[09:29:18.365] Number of futures (= number of chunks): 2
[09:29:18.365] Launching 2 futures (chunks) ...
[09:29:18.365] Chunk #1 of 2 ...
[09:29:18.365]  - Finding globals in '...' for chunk #1 ...
[09:29:18.365] getGlobalsAndPackages() ...
[09:29:18.365] Searching for globals...
[09:29:18.366] 
[09:29:18.366] Searching for globals ... DONE
[09:29:18.366] - globals: [0] <none>
[09:29:18.366] getGlobalsAndPackages() ... DONE
[09:29:18.366]    + additional globals found: [n=0] 
[09:29:18.366]    + additional namespaces needed: [n=0] 
[09:29:18.366]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:18.366]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:18.367]  - seeds: <none>
[09:29:18.367]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.367] getGlobalsAndPackages() ...
[09:29:18.367] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.367] Resolving globals: FALSE
[09:29:18.368] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:18.368] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:18.368] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.368] 
[09:29:18.369] getGlobalsAndPackages() ... DONE
[09:29:18.369] run() for ‘Future’ ...
[09:29:18.369] - state: ‘created’
[09:29:18.369] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:18.384] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.384] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:18.384]   - Field: ‘node’
[09:29:18.384]   - Field: ‘label’
[09:29:18.384]   - Field: ‘local’
[09:29:18.384]   - Field: ‘owner’
[09:29:18.384]   - Field: ‘envir’
[09:29:18.385]   - Field: ‘workers’
[09:29:18.385]   - Field: ‘packages’
[09:29:18.385]   - Field: ‘gc’
[09:29:18.385]   - Field: ‘conditions’
[09:29:18.385]   - Field: ‘persistent’
[09:29:18.385]   - Field: ‘expr’
[09:29:18.385]   - Field: ‘uuid’
[09:29:18.385]   - Field: ‘seed’
[09:29:18.385]   - Field: ‘version’
[09:29:18.386]   - Field: ‘result’
[09:29:18.386]   - Field: ‘asynchronous’
[09:29:18.386]   - Field: ‘calls’
[09:29:18.386]   - Field: ‘globals’
[09:29:18.386]   - Field: ‘stdout’
[09:29:18.386]   - Field: ‘earlySignal’
[09:29:18.386]   - Field: ‘lazy’
[09:29:18.386]   - Field: ‘state’
[09:29:18.386] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:18.387] - Launch lazy future ...
[09:29:18.387] Packages needed by the future expression (n = 0): <none>
[09:29:18.387] Packages needed by future strategies (n = 0): <none>
[09:29:18.388] {
[09:29:18.388]     {
[09:29:18.388]         {
[09:29:18.388]             ...future.startTime <- base::Sys.time()
[09:29:18.388]             {
[09:29:18.388]                 {
[09:29:18.388]                   {
[09:29:18.388]                     {
[09:29:18.388]                       base::local({
[09:29:18.388]                         has_future <- base::requireNamespace("future", 
[09:29:18.388]                           quietly = TRUE)
[09:29:18.388]                         if (has_future) {
[09:29:18.388]                           ns <- base::getNamespace("future")
[09:29:18.388]                           version <- ns[[".package"]][["version"]]
[09:29:18.388]                           if (is.null(version)) 
[09:29:18.388]                             version <- utils::packageVersion("future")
[09:29:18.388]                         }
[09:29:18.388]                         else {
[09:29:18.388]                           version <- NULL
[09:29:18.388]                         }
[09:29:18.388]                         if (!has_future || version < "1.8.0") {
[09:29:18.388]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:18.388]                             "", base::R.version$version.string), 
[09:29:18.388]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:18.388]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:18.388]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:18.388]                               "release", "version")], collapse = " "), 
[09:29:18.388]                             hostname = base::Sys.info()[["nodename"]])
[09:29:18.388]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:18.388]                             info)
[09:29:18.388]                           info <- base::paste(info, collapse = "; ")
[09:29:18.388]                           if (!has_future) {
[09:29:18.388]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:18.388]                               info)
[09:29:18.388]                           }
[09:29:18.388]                           else {
[09:29:18.388]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:18.388]                               info, version)
[09:29:18.388]                           }
[09:29:18.388]                           base::stop(msg)
[09:29:18.388]                         }
[09:29:18.388]                       })
[09:29:18.388]                     }
[09:29:18.388]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:18.388]                     base::options(mc.cores = 1L)
[09:29:18.388]                   }
[09:29:18.388]                   ...future.strategy.old <- future::plan("list")
[09:29:18.388]                   options(future.plan = NULL)
[09:29:18.388]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.388]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:18.388]                 }
[09:29:18.388]                 ...future.workdir <- getwd()
[09:29:18.388]             }
[09:29:18.388]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:18.388]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:18.388]         }
[09:29:18.388]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:18.388]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:18.388]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:18.388]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:18.388]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:18.388]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:18.388]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:18.388]             base::names(...future.oldOptions))
[09:29:18.388]     }
[09:29:18.388]     if (FALSE) {
[09:29:18.388]     }
[09:29:18.388]     else {
[09:29:18.388]         if (TRUE) {
[09:29:18.388]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:18.388]                 open = "w")
[09:29:18.388]         }
[09:29:18.388]         else {
[09:29:18.388]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:18.388]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:18.388]         }
[09:29:18.388]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:18.388]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:18.388]             base::sink(type = "output", split = FALSE)
[09:29:18.388]             base::close(...future.stdout)
[09:29:18.388]         }, add = TRUE)
[09:29:18.388]     }
[09:29:18.388]     ...future.frame <- base::sys.nframe()
[09:29:18.388]     ...future.conditions <- base::list()
[09:29:18.388]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:18.388]     if (FALSE) {
[09:29:18.388]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:18.388]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:18.388]     }
[09:29:18.388]     ...future.result <- base::tryCatch({
[09:29:18.388]         base::withCallingHandlers({
[09:29:18.388]             ...future.value <- base::withVisible(base::local({
[09:29:18.388]                 ...future.makeSendCondition <- base::local({
[09:29:18.388]                   sendCondition <- NULL
[09:29:18.388]                   function(frame = 1L) {
[09:29:18.388]                     if (is.function(sendCondition)) 
[09:29:18.388]                       return(sendCondition)
[09:29:18.388]                     ns <- getNamespace("parallel")
[09:29:18.388]                     if (exists("sendData", mode = "function", 
[09:29:18.388]                       envir = ns)) {
[09:29:18.388]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:18.388]                         envir = ns)
[09:29:18.388]                       envir <- sys.frame(frame)
[09:29:18.388]                       master <- NULL
[09:29:18.388]                       while (!identical(envir, .GlobalEnv) && 
[09:29:18.388]                         !identical(envir, emptyenv())) {
[09:29:18.388]                         if (exists("master", mode = "list", envir = envir, 
[09:29:18.388]                           inherits = FALSE)) {
[09:29:18.388]                           master <- get("master", mode = "list", 
[09:29:18.388]                             envir = envir, inherits = FALSE)
[09:29:18.388]                           if (inherits(master, c("SOCKnode", 
[09:29:18.388]                             "SOCK0node"))) {
[09:29:18.388]                             sendCondition <<- function(cond) {
[09:29:18.388]                               data <- list(type = "VALUE", value = cond, 
[09:29:18.388]                                 success = TRUE)
[09:29:18.388]                               parallel_sendData(master, data)
[09:29:18.388]                             }
[09:29:18.388]                             return(sendCondition)
[09:29:18.388]                           }
[09:29:18.388]                         }
[09:29:18.388]                         frame <- frame + 1L
[09:29:18.388]                         envir <- sys.frame(frame)
[09:29:18.388]                       }
[09:29:18.388]                     }
[09:29:18.388]                     sendCondition <<- function(cond) NULL
[09:29:18.388]                   }
[09:29:18.388]                 })
[09:29:18.388]                 withCallingHandlers({
[09:29:18.388]                   {
[09:29:18.388]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.388]                     if (!identical(...future.globals.maxSize.org, 
[09:29:18.388]                       ...future.globals.maxSize)) {
[09:29:18.388]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.388]                       on.exit(options(oopts), add = TRUE)
[09:29:18.388]                     }
[09:29:18.388]                     {
[09:29:18.388]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.388]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:18.388]                         USE.NAMES = FALSE)
[09:29:18.388]                       do.call(mapply, args = args)
[09:29:18.388]                     }
[09:29:18.388]                   }
[09:29:18.388]                 }, immediateCondition = function(cond) {
[09:29:18.388]                   sendCondition <- ...future.makeSendCondition()
[09:29:18.388]                   sendCondition(cond)
[09:29:18.388]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.388]                   {
[09:29:18.388]                     inherits <- base::inherits
[09:29:18.388]                     invokeRestart <- base::invokeRestart
[09:29:18.388]                     is.null <- base::is.null
[09:29:18.388]                     muffled <- FALSE
[09:29:18.388]                     if (inherits(cond, "message")) {
[09:29:18.388]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:18.388]                       if (muffled) 
[09:29:18.388]                         invokeRestart("muffleMessage")
[09:29:18.388]                     }
[09:29:18.388]                     else if (inherits(cond, "warning")) {
[09:29:18.388]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:18.388]                       if (muffled) 
[09:29:18.388]                         invokeRestart("muffleWarning")
[09:29:18.388]                     }
[09:29:18.388]                     else if (inherits(cond, "condition")) {
[09:29:18.388]                       if (!is.null(pattern)) {
[09:29:18.388]                         computeRestarts <- base::computeRestarts
[09:29:18.388]                         grepl <- base::grepl
[09:29:18.388]                         restarts <- computeRestarts(cond)
[09:29:18.388]                         for (restart in restarts) {
[09:29:18.388]                           name <- restart$name
[09:29:18.388]                           if (is.null(name)) 
[09:29:18.388]                             next
[09:29:18.388]                           if (!grepl(pattern, name)) 
[09:29:18.388]                             next
[09:29:18.388]                           invokeRestart(restart)
[09:29:18.388]                           muffled <- TRUE
[09:29:18.388]                           break
[09:29:18.388]                         }
[09:29:18.388]                       }
[09:29:18.388]                     }
[09:29:18.388]                     invisible(muffled)
[09:29:18.388]                   }
[09:29:18.388]                   muffleCondition(cond)
[09:29:18.388]                 })
[09:29:18.388]             }))
[09:29:18.388]             future::FutureResult(value = ...future.value$value, 
[09:29:18.388]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.388]                   ...future.rng), globalenv = if (FALSE) 
[09:29:18.388]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:18.388]                     ...future.globalenv.names))
[09:29:18.388]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:18.388]         }, condition = base::local({
[09:29:18.388]             c <- base::c
[09:29:18.388]             inherits <- base::inherits
[09:29:18.388]             invokeRestart <- base::invokeRestart
[09:29:18.388]             length <- base::length
[09:29:18.388]             list <- base::list
[09:29:18.388]             seq.int <- base::seq.int
[09:29:18.388]             signalCondition <- base::signalCondition
[09:29:18.388]             sys.calls <- base::sys.calls
[09:29:18.388]             `[[` <- base::`[[`
[09:29:18.388]             `+` <- base::`+`
[09:29:18.388]             `<<-` <- base::`<<-`
[09:29:18.388]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:18.388]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:18.388]                   3L)]
[09:29:18.388]             }
[09:29:18.388]             function(cond) {
[09:29:18.388]                 is_error <- inherits(cond, "error")
[09:29:18.388]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:18.388]                   NULL)
[09:29:18.388]                 if (is_error) {
[09:29:18.388]                   sessionInformation <- function() {
[09:29:18.388]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:18.388]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:18.388]                       search = base::search(), system = base::Sys.info())
[09:29:18.388]                   }
[09:29:18.388]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.388]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:18.388]                     cond$call), session = sessionInformation(), 
[09:29:18.388]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:18.388]                   signalCondition(cond)
[09:29:18.388]                 }
[09:29:18.388]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:18.388]                 "immediateCondition"))) {
[09:29:18.388]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:18.388]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.388]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:18.388]                   if (TRUE && !signal) {
[09:29:18.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.388]                     {
[09:29:18.388]                       inherits <- base::inherits
[09:29:18.388]                       invokeRestart <- base::invokeRestart
[09:29:18.388]                       is.null <- base::is.null
[09:29:18.388]                       muffled <- FALSE
[09:29:18.388]                       if (inherits(cond, "message")) {
[09:29:18.388]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.388]                         if (muffled) 
[09:29:18.388]                           invokeRestart("muffleMessage")
[09:29:18.388]                       }
[09:29:18.388]                       else if (inherits(cond, "warning")) {
[09:29:18.388]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.388]                         if (muffled) 
[09:29:18.388]                           invokeRestart("muffleWarning")
[09:29:18.388]                       }
[09:29:18.388]                       else if (inherits(cond, "condition")) {
[09:29:18.388]                         if (!is.null(pattern)) {
[09:29:18.388]                           computeRestarts <- base::computeRestarts
[09:29:18.388]                           grepl <- base::grepl
[09:29:18.388]                           restarts <- computeRestarts(cond)
[09:29:18.388]                           for (restart in restarts) {
[09:29:18.388]                             name <- restart$name
[09:29:18.388]                             if (is.null(name)) 
[09:29:18.388]                               next
[09:29:18.388]                             if (!grepl(pattern, name)) 
[09:29:18.388]                               next
[09:29:18.388]                             invokeRestart(restart)
[09:29:18.388]                             muffled <- TRUE
[09:29:18.388]                             break
[09:29:18.388]                           }
[09:29:18.388]                         }
[09:29:18.388]                       }
[09:29:18.388]                       invisible(muffled)
[09:29:18.388]                     }
[09:29:18.388]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.388]                   }
[09:29:18.388]                 }
[09:29:18.388]                 else {
[09:29:18.388]                   if (TRUE) {
[09:29:18.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.388]                     {
[09:29:18.388]                       inherits <- base::inherits
[09:29:18.388]                       invokeRestart <- base::invokeRestart
[09:29:18.388]                       is.null <- base::is.null
[09:29:18.388]                       muffled <- FALSE
[09:29:18.388]                       if (inherits(cond, "message")) {
[09:29:18.388]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.388]                         if (muffled) 
[09:29:18.388]                           invokeRestart("muffleMessage")
[09:29:18.388]                       }
[09:29:18.388]                       else if (inherits(cond, "warning")) {
[09:29:18.388]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.388]                         if (muffled) 
[09:29:18.388]                           invokeRestart("muffleWarning")
[09:29:18.388]                       }
[09:29:18.388]                       else if (inherits(cond, "condition")) {
[09:29:18.388]                         if (!is.null(pattern)) {
[09:29:18.388]                           computeRestarts <- base::computeRestarts
[09:29:18.388]                           grepl <- base::grepl
[09:29:18.388]                           restarts <- computeRestarts(cond)
[09:29:18.388]                           for (restart in restarts) {
[09:29:18.388]                             name <- restart$name
[09:29:18.388]                             if (is.null(name)) 
[09:29:18.388]                               next
[09:29:18.388]                             if (!grepl(pattern, name)) 
[09:29:18.388]                               next
[09:29:18.388]                             invokeRestart(restart)
[09:29:18.388]                             muffled <- TRUE
[09:29:18.388]                             break
[09:29:18.388]                           }
[09:29:18.388]                         }
[09:29:18.388]                       }
[09:29:18.388]                       invisible(muffled)
[09:29:18.388]                     }
[09:29:18.388]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.388]                   }
[09:29:18.388]                 }
[09:29:18.388]             }
[09:29:18.388]         }))
[09:29:18.388]     }, error = function(ex) {
[09:29:18.388]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:18.388]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.388]                 ...future.rng), started = ...future.startTime, 
[09:29:18.388]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:18.388]             version = "1.8"), class = "FutureResult")
[09:29:18.388]     }, finally = {
[09:29:18.388]         if (!identical(...future.workdir, getwd())) 
[09:29:18.388]             setwd(...future.workdir)
[09:29:18.388]         {
[09:29:18.388]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:18.388]                 ...future.oldOptions$nwarnings <- NULL
[09:29:18.388]             }
[09:29:18.388]             base::options(...future.oldOptions)
[09:29:18.388]             if (.Platform$OS.type == "windows") {
[09:29:18.388]                 old_names <- names(...future.oldEnvVars)
[09:29:18.388]                 envs <- base::Sys.getenv()
[09:29:18.388]                 names <- names(envs)
[09:29:18.388]                 common <- intersect(names, old_names)
[09:29:18.388]                 added <- setdiff(names, old_names)
[09:29:18.388]                 removed <- setdiff(old_names, names)
[09:29:18.388]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:18.388]                   envs[common]]
[09:29:18.388]                 NAMES <- toupper(changed)
[09:29:18.388]                 args <- list()
[09:29:18.388]                 for (kk in seq_along(NAMES)) {
[09:29:18.388]                   name <- changed[[kk]]
[09:29:18.388]                   NAME <- NAMES[[kk]]
[09:29:18.388]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.388]                     next
[09:29:18.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.388]                 }
[09:29:18.388]                 NAMES <- toupper(added)
[09:29:18.388]                 for (kk in seq_along(NAMES)) {
[09:29:18.388]                   name <- added[[kk]]
[09:29:18.388]                   NAME <- NAMES[[kk]]
[09:29:18.388]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.388]                     next
[09:29:18.388]                   args[[name]] <- ""
[09:29:18.388]                 }
[09:29:18.388]                 NAMES <- toupper(removed)
[09:29:18.388]                 for (kk in seq_along(NAMES)) {
[09:29:18.388]                   name <- removed[[kk]]
[09:29:18.388]                   NAME <- NAMES[[kk]]
[09:29:18.388]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.388]                     next
[09:29:18.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.388]                 }
[09:29:18.388]                 if (length(args) > 0) 
[09:29:18.388]                   base::do.call(base::Sys.setenv, args = args)
[09:29:18.388]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:18.388]             }
[09:29:18.388]             else {
[09:29:18.388]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:18.388]             }
[09:29:18.388]             {
[09:29:18.388]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:18.388]                   0L) {
[09:29:18.388]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:18.388]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:18.388]                   base::options(opts)
[09:29:18.388]                 }
[09:29:18.388]                 {
[09:29:18.388]                   {
[09:29:18.388]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:18.388]                     NULL
[09:29:18.388]                   }
[09:29:18.388]                   options(future.plan = NULL)
[09:29:18.388]                   if (is.na(NA_character_)) 
[09:29:18.388]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.388]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:18.388]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:18.388]                     .init = FALSE)
[09:29:18.388]                 }
[09:29:18.388]             }
[09:29:18.388]         }
[09:29:18.388]     })
[09:29:18.388]     if (TRUE) {
[09:29:18.388]         base::sink(type = "output", split = FALSE)
[09:29:18.388]         if (TRUE) {
[09:29:18.388]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:18.388]         }
[09:29:18.388]         else {
[09:29:18.388]             ...future.result["stdout"] <- base::list(NULL)
[09:29:18.388]         }
[09:29:18.388]         base::close(...future.stdout)
[09:29:18.388]         ...future.stdout <- NULL
[09:29:18.388]     }
[09:29:18.388]     ...future.result$conditions <- ...future.conditions
[09:29:18.388]     ...future.result$finished <- base::Sys.time()
[09:29:18.388]     ...future.result
[09:29:18.388] }
[09:29:18.390] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[09:29:18.391] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[09:29:18.391] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[09:29:18.391] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:18.392] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:18.392] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[09:29:18.392] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[09:29:18.392] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:18.393] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:18.393] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:18.393] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:18.393] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[09:29:18.394] MultisessionFuture started
[09:29:18.394] - Launch lazy future ... done
[09:29:18.394] run() for ‘MultisessionFuture’ ... done
[09:29:18.394] Created future:
[09:29:18.394] MultisessionFuture:
[09:29:18.394] Label: ‘future_mapply-1’
[09:29:18.394] Expression:
[09:29:18.394] {
[09:29:18.394]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.394]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:18.394]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.394]         on.exit(options(oopts), add = TRUE)
[09:29:18.394]     }
[09:29:18.394]     {
[09:29:18.394]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.394]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:18.394]         do.call(mapply, args = args)
[09:29:18.394]     }
[09:29:18.394] }
[09:29:18.394] Lazy evaluation: FALSE
[09:29:18.394] Asynchronous evaluation: TRUE
[09:29:18.394] Local evaluation: TRUE
[09:29:18.394] Environment: R_GlobalEnv
[09:29:18.394] Capture standard output: TRUE
[09:29:18.394] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:18.394] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:18.394] Packages: <none>
[09:29:18.394] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:18.394] Resolved: FALSE
[09:29:18.394] Value: <not collected>
[09:29:18.394] Conditions captured: <none>
[09:29:18.394] Early signaling: FALSE
[09:29:18.394] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:18.394] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.406] Chunk #1 of 2 ... DONE
[09:29:18.406] Chunk #2 of 2 ...
[09:29:18.407]  - Finding globals in '...' for chunk #2 ...
[09:29:18.407] getGlobalsAndPackages() ...
[09:29:18.407] Searching for globals...
[09:29:18.407] 
[09:29:18.407] Searching for globals ... DONE
[09:29:18.407] - globals: [0] <none>
[09:29:18.408] getGlobalsAndPackages() ... DONE
[09:29:18.408]    + additional globals found: [n=0] 
[09:29:18.408]    + additional namespaces needed: [n=0] 
[09:29:18.408]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:18.408]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:18.408]  - seeds: <none>
[09:29:18.408]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.408] getGlobalsAndPackages() ...
[09:29:18.409] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.409] Resolving globals: FALSE
[09:29:18.409] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:18.410] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:18.410] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.410] 
[09:29:18.410] getGlobalsAndPackages() ... DONE
[09:29:18.411] run() for ‘Future’ ...
[09:29:18.411] - state: ‘created’
[09:29:18.411] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:18.426] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:18.427]   - Field: ‘node’
[09:29:18.427]   - Field: ‘label’
[09:29:18.427]   - Field: ‘local’
[09:29:18.427]   - Field: ‘owner’
[09:29:18.427]   - Field: ‘envir’
[09:29:18.427]   - Field: ‘workers’
[09:29:18.427]   - Field: ‘packages’
[09:29:18.427]   - Field: ‘gc’
[09:29:18.428]   - Field: ‘conditions’
[09:29:18.428]   - Field: ‘persistent’
[09:29:18.428]   - Field: ‘expr’
[09:29:18.428]   - Field: ‘uuid’
[09:29:18.428]   - Field: ‘seed’
[09:29:18.428]   - Field: ‘version’
[09:29:18.428]   - Field: ‘result’
[09:29:18.428]   - Field: ‘asynchronous’
[09:29:18.429]   - Field: ‘calls’
[09:29:18.429]   - Field: ‘globals’
[09:29:18.429]   - Field: ‘stdout’
[09:29:18.429]   - Field: ‘earlySignal’
[09:29:18.429]   - Field: ‘lazy’
[09:29:18.429]   - Field: ‘state’
[09:29:18.429] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:18.429] - Launch lazy future ...
[09:29:18.430] Packages needed by the future expression (n = 0): <none>
[09:29:18.430] Packages needed by future strategies (n = 0): <none>
[09:29:18.430] {
[09:29:18.430]     {
[09:29:18.430]         {
[09:29:18.430]             ...future.startTime <- base::Sys.time()
[09:29:18.430]             {
[09:29:18.430]                 {
[09:29:18.430]                   {
[09:29:18.430]                     {
[09:29:18.430]                       base::local({
[09:29:18.430]                         has_future <- base::requireNamespace("future", 
[09:29:18.430]                           quietly = TRUE)
[09:29:18.430]                         if (has_future) {
[09:29:18.430]                           ns <- base::getNamespace("future")
[09:29:18.430]                           version <- ns[[".package"]][["version"]]
[09:29:18.430]                           if (is.null(version)) 
[09:29:18.430]                             version <- utils::packageVersion("future")
[09:29:18.430]                         }
[09:29:18.430]                         else {
[09:29:18.430]                           version <- NULL
[09:29:18.430]                         }
[09:29:18.430]                         if (!has_future || version < "1.8.0") {
[09:29:18.430]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:18.430]                             "", base::R.version$version.string), 
[09:29:18.430]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:18.430]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:18.430]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:18.430]                               "release", "version")], collapse = " "), 
[09:29:18.430]                             hostname = base::Sys.info()[["nodename"]])
[09:29:18.430]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:18.430]                             info)
[09:29:18.430]                           info <- base::paste(info, collapse = "; ")
[09:29:18.430]                           if (!has_future) {
[09:29:18.430]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:18.430]                               info)
[09:29:18.430]                           }
[09:29:18.430]                           else {
[09:29:18.430]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:18.430]                               info, version)
[09:29:18.430]                           }
[09:29:18.430]                           base::stop(msg)
[09:29:18.430]                         }
[09:29:18.430]                       })
[09:29:18.430]                     }
[09:29:18.430]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:18.430]                     base::options(mc.cores = 1L)
[09:29:18.430]                   }
[09:29:18.430]                   ...future.strategy.old <- future::plan("list")
[09:29:18.430]                   options(future.plan = NULL)
[09:29:18.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:18.430]                 }
[09:29:18.430]                 ...future.workdir <- getwd()
[09:29:18.430]             }
[09:29:18.430]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:18.430]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:18.430]         }
[09:29:18.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:18.430]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:18.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:18.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:18.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:18.430]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:18.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:18.430]             base::names(...future.oldOptions))
[09:29:18.430]     }
[09:29:18.430]     if (FALSE) {
[09:29:18.430]     }
[09:29:18.430]     else {
[09:29:18.430]         if (TRUE) {
[09:29:18.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:18.430]                 open = "w")
[09:29:18.430]         }
[09:29:18.430]         else {
[09:29:18.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:18.430]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:18.430]         }
[09:29:18.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:18.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:18.430]             base::sink(type = "output", split = FALSE)
[09:29:18.430]             base::close(...future.stdout)
[09:29:18.430]         }, add = TRUE)
[09:29:18.430]     }
[09:29:18.430]     ...future.frame <- base::sys.nframe()
[09:29:18.430]     ...future.conditions <- base::list()
[09:29:18.430]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:18.430]     if (FALSE) {
[09:29:18.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:18.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:18.430]     }
[09:29:18.430]     ...future.result <- base::tryCatch({
[09:29:18.430]         base::withCallingHandlers({
[09:29:18.430]             ...future.value <- base::withVisible(base::local({
[09:29:18.430]                 ...future.makeSendCondition <- base::local({
[09:29:18.430]                   sendCondition <- NULL
[09:29:18.430]                   function(frame = 1L) {
[09:29:18.430]                     if (is.function(sendCondition)) 
[09:29:18.430]                       return(sendCondition)
[09:29:18.430]                     ns <- getNamespace("parallel")
[09:29:18.430]                     if (exists("sendData", mode = "function", 
[09:29:18.430]                       envir = ns)) {
[09:29:18.430]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:18.430]                         envir = ns)
[09:29:18.430]                       envir <- sys.frame(frame)
[09:29:18.430]                       master <- NULL
[09:29:18.430]                       while (!identical(envir, .GlobalEnv) && 
[09:29:18.430]                         !identical(envir, emptyenv())) {
[09:29:18.430]                         if (exists("master", mode = "list", envir = envir, 
[09:29:18.430]                           inherits = FALSE)) {
[09:29:18.430]                           master <- get("master", mode = "list", 
[09:29:18.430]                             envir = envir, inherits = FALSE)
[09:29:18.430]                           if (inherits(master, c("SOCKnode", 
[09:29:18.430]                             "SOCK0node"))) {
[09:29:18.430]                             sendCondition <<- function(cond) {
[09:29:18.430]                               data <- list(type = "VALUE", value = cond, 
[09:29:18.430]                                 success = TRUE)
[09:29:18.430]                               parallel_sendData(master, data)
[09:29:18.430]                             }
[09:29:18.430]                             return(sendCondition)
[09:29:18.430]                           }
[09:29:18.430]                         }
[09:29:18.430]                         frame <- frame + 1L
[09:29:18.430]                         envir <- sys.frame(frame)
[09:29:18.430]                       }
[09:29:18.430]                     }
[09:29:18.430]                     sendCondition <<- function(cond) NULL
[09:29:18.430]                   }
[09:29:18.430]                 })
[09:29:18.430]                 withCallingHandlers({
[09:29:18.430]                   {
[09:29:18.430]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.430]                     if (!identical(...future.globals.maxSize.org, 
[09:29:18.430]                       ...future.globals.maxSize)) {
[09:29:18.430]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.430]                       on.exit(options(oopts), add = TRUE)
[09:29:18.430]                     }
[09:29:18.430]                     {
[09:29:18.430]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.430]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:18.430]                         USE.NAMES = FALSE)
[09:29:18.430]                       do.call(mapply, args = args)
[09:29:18.430]                     }
[09:29:18.430]                   }
[09:29:18.430]                 }, immediateCondition = function(cond) {
[09:29:18.430]                   sendCondition <- ...future.makeSendCondition()
[09:29:18.430]                   sendCondition(cond)
[09:29:18.430]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.430]                   {
[09:29:18.430]                     inherits <- base::inherits
[09:29:18.430]                     invokeRestart <- base::invokeRestart
[09:29:18.430]                     is.null <- base::is.null
[09:29:18.430]                     muffled <- FALSE
[09:29:18.430]                     if (inherits(cond, "message")) {
[09:29:18.430]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:18.430]                       if (muffled) 
[09:29:18.430]                         invokeRestart("muffleMessage")
[09:29:18.430]                     }
[09:29:18.430]                     else if (inherits(cond, "warning")) {
[09:29:18.430]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:18.430]                       if (muffled) 
[09:29:18.430]                         invokeRestart("muffleWarning")
[09:29:18.430]                     }
[09:29:18.430]                     else if (inherits(cond, "condition")) {
[09:29:18.430]                       if (!is.null(pattern)) {
[09:29:18.430]                         computeRestarts <- base::computeRestarts
[09:29:18.430]                         grepl <- base::grepl
[09:29:18.430]                         restarts <- computeRestarts(cond)
[09:29:18.430]                         for (restart in restarts) {
[09:29:18.430]                           name <- restart$name
[09:29:18.430]                           if (is.null(name)) 
[09:29:18.430]                             next
[09:29:18.430]                           if (!grepl(pattern, name)) 
[09:29:18.430]                             next
[09:29:18.430]                           invokeRestart(restart)
[09:29:18.430]                           muffled <- TRUE
[09:29:18.430]                           break
[09:29:18.430]                         }
[09:29:18.430]                       }
[09:29:18.430]                     }
[09:29:18.430]                     invisible(muffled)
[09:29:18.430]                   }
[09:29:18.430]                   muffleCondition(cond)
[09:29:18.430]                 })
[09:29:18.430]             }))
[09:29:18.430]             future::FutureResult(value = ...future.value$value, 
[09:29:18.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.430]                   ...future.rng), globalenv = if (FALSE) 
[09:29:18.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:18.430]                     ...future.globalenv.names))
[09:29:18.430]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:18.430]         }, condition = base::local({
[09:29:18.430]             c <- base::c
[09:29:18.430]             inherits <- base::inherits
[09:29:18.430]             invokeRestart <- base::invokeRestart
[09:29:18.430]             length <- base::length
[09:29:18.430]             list <- base::list
[09:29:18.430]             seq.int <- base::seq.int
[09:29:18.430]             signalCondition <- base::signalCondition
[09:29:18.430]             sys.calls <- base::sys.calls
[09:29:18.430]             `[[` <- base::`[[`
[09:29:18.430]             `+` <- base::`+`
[09:29:18.430]             `<<-` <- base::`<<-`
[09:29:18.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:18.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:18.430]                   3L)]
[09:29:18.430]             }
[09:29:18.430]             function(cond) {
[09:29:18.430]                 is_error <- inherits(cond, "error")
[09:29:18.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:18.430]                   NULL)
[09:29:18.430]                 if (is_error) {
[09:29:18.430]                   sessionInformation <- function() {
[09:29:18.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:18.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:18.430]                       search = base::search(), system = base::Sys.info())
[09:29:18.430]                   }
[09:29:18.430]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:18.430]                     cond$call), session = sessionInformation(), 
[09:29:18.430]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:18.430]                   signalCondition(cond)
[09:29:18.430]                 }
[09:29:18.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:18.430]                 "immediateCondition"))) {
[09:29:18.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:18.430]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:18.430]                   if (TRUE && !signal) {
[09:29:18.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.430]                     {
[09:29:18.430]                       inherits <- base::inherits
[09:29:18.430]                       invokeRestart <- base::invokeRestart
[09:29:18.430]                       is.null <- base::is.null
[09:29:18.430]                       muffled <- FALSE
[09:29:18.430]                       if (inherits(cond, "message")) {
[09:29:18.430]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.430]                         if (muffled) 
[09:29:18.430]                           invokeRestart("muffleMessage")
[09:29:18.430]                       }
[09:29:18.430]                       else if (inherits(cond, "warning")) {
[09:29:18.430]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.430]                         if (muffled) 
[09:29:18.430]                           invokeRestart("muffleWarning")
[09:29:18.430]                       }
[09:29:18.430]                       else if (inherits(cond, "condition")) {
[09:29:18.430]                         if (!is.null(pattern)) {
[09:29:18.430]                           computeRestarts <- base::computeRestarts
[09:29:18.430]                           grepl <- base::grepl
[09:29:18.430]                           restarts <- computeRestarts(cond)
[09:29:18.430]                           for (restart in restarts) {
[09:29:18.430]                             name <- restart$name
[09:29:18.430]                             if (is.null(name)) 
[09:29:18.430]                               next
[09:29:18.430]                             if (!grepl(pattern, name)) 
[09:29:18.430]                               next
[09:29:18.430]                             invokeRestart(restart)
[09:29:18.430]                             muffled <- TRUE
[09:29:18.430]                             break
[09:29:18.430]                           }
[09:29:18.430]                         }
[09:29:18.430]                       }
[09:29:18.430]                       invisible(muffled)
[09:29:18.430]                     }
[09:29:18.430]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.430]                   }
[09:29:18.430]                 }
[09:29:18.430]                 else {
[09:29:18.430]                   if (TRUE) {
[09:29:18.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.430]                     {
[09:29:18.430]                       inherits <- base::inherits
[09:29:18.430]                       invokeRestart <- base::invokeRestart
[09:29:18.430]                       is.null <- base::is.null
[09:29:18.430]                       muffled <- FALSE
[09:29:18.430]                       if (inherits(cond, "message")) {
[09:29:18.430]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.430]                         if (muffled) 
[09:29:18.430]                           invokeRestart("muffleMessage")
[09:29:18.430]                       }
[09:29:18.430]                       else if (inherits(cond, "warning")) {
[09:29:18.430]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.430]                         if (muffled) 
[09:29:18.430]                           invokeRestart("muffleWarning")
[09:29:18.430]                       }
[09:29:18.430]                       else if (inherits(cond, "condition")) {
[09:29:18.430]                         if (!is.null(pattern)) {
[09:29:18.430]                           computeRestarts <- base::computeRestarts
[09:29:18.430]                           grepl <- base::grepl
[09:29:18.430]                           restarts <- computeRestarts(cond)
[09:29:18.430]                           for (restart in restarts) {
[09:29:18.430]                             name <- restart$name
[09:29:18.430]                             if (is.null(name)) 
[09:29:18.430]                               next
[09:29:18.430]                             if (!grepl(pattern, name)) 
[09:29:18.430]                               next
[09:29:18.430]                             invokeRestart(restart)
[09:29:18.430]                             muffled <- TRUE
[09:29:18.430]                             break
[09:29:18.430]                           }
[09:29:18.430]                         }
[09:29:18.430]                       }
[09:29:18.430]                       invisible(muffled)
[09:29:18.430]                     }
[09:29:18.430]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.430]                   }
[09:29:18.430]                 }
[09:29:18.430]             }
[09:29:18.430]         }))
[09:29:18.430]     }, error = function(ex) {
[09:29:18.430]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:18.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.430]                 ...future.rng), started = ...future.startTime, 
[09:29:18.430]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:18.430]             version = "1.8"), class = "FutureResult")
[09:29:18.430]     }, finally = {
[09:29:18.430]         if (!identical(...future.workdir, getwd())) 
[09:29:18.430]             setwd(...future.workdir)
[09:29:18.430]         {
[09:29:18.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:18.430]                 ...future.oldOptions$nwarnings <- NULL
[09:29:18.430]             }
[09:29:18.430]             base::options(...future.oldOptions)
[09:29:18.430]             if (.Platform$OS.type == "windows") {
[09:29:18.430]                 old_names <- names(...future.oldEnvVars)
[09:29:18.430]                 envs <- base::Sys.getenv()
[09:29:18.430]                 names <- names(envs)
[09:29:18.430]                 common <- intersect(names, old_names)
[09:29:18.430]                 added <- setdiff(names, old_names)
[09:29:18.430]                 removed <- setdiff(old_names, names)
[09:29:18.430]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:18.430]                   envs[common]]
[09:29:18.430]                 NAMES <- toupper(changed)
[09:29:18.430]                 args <- list()
[09:29:18.430]                 for (kk in seq_along(NAMES)) {
[09:29:18.430]                   name <- changed[[kk]]
[09:29:18.430]                   NAME <- NAMES[[kk]]
[09:29:18.430]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.430]                     next
[09:29:18.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.430]                 }
[09:29:18.430]                 NAMES <- toupper(added)
[09:29:18.430]                 for (kk in seq_along(NAMES)) {
[09:29:18.430]                   name <- added[[kk]]
[09:29:18.430]                   NAME <- NAMES[[kk]]
[09:29:18.430]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.430]                     next
[09:29:18.430]                   args[[name]] <- ""
[09:29:18.430]                 }
[09:29:18.430]                 NAMES <- toupper(removed)
[09:29:18.430]                 for (kk in seq_along(NAMES)) {
[09:29:18.430]                   name <- removed[[kk]]
[09:29:18.430]                   NAME <- NAMES[[kk]]
[09:29:18.430]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.430]                     next
[09:29:18.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.430]                 }
[09:29:18.430]                 if (length(args) > 0) 
[09:29:18.430]                   base::do.call(base::Sys.setenv, args = args)
[09:29:18.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:18.430]             }
[09:29:18.430]             else {
[09:29:18.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:18.430]             }
[09:29:18.430]             {
[09:29:18.430]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:18.430]                   0L) {
[09:29:18.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:18.430]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:18.430]                   base::options(opts)
[09:29:18.430]                 }
[09:29:18.430]                 {
[09:29:18.430]                   {
[09:29:18.430]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:18.430]                     NULL
[09:29:18.430]                   }
[09:29:18.430]                   options(future.plan = NULL)
[09:29:18.430]                   if (is.na(NA_character_)) 
[09:29:18.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:18.430]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:18.430]                     .init = FALSE)
[09:29:18.430]                 }
[09:29:18.430]             }
[09:29:18.430]         }
[09:29:18.430]     })
[09:29:18.430]     if (TRUE) {
[09:29:18.430]         base::sink(type = "output", split = FALSE)
[09:29:18.430]         if (TRUE) {
[09:29:18.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:18.430]         }
[09:29:18.430]         else {
[09:29:18.430]             ...future.result["stdout"] <- base::list(NULL)
[09:29:18.430]         }
[09:29:18.430]         base::close(...future.stdout)
[09:29:18.430]         ...future.stdout <- NULL
[09:29:18.430]     }
[09:29:18.430]     ...future.result$conditions <- ...future.conditions
[09:29:18.430]     ...future.result$finished <- base::Sys.time()
[09:29:18.430]     ...future.result
[09:29:18.430] }
[09:29:18.483] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[09:29:18.483] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[09:29:18.484] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[09:29:18.484] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:18.484] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:18.484] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[09:29:18.485] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[09:29:18.485] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:18.485] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:18.486] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:18.486] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:18.486] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[09:29:18.487] MultisessionFuture started
[09:29:18.487] - Launch lazy future ... done
[09:29:18.487] run() for ‘MultisessionFuture’ ... done
[09:29:18.487] Created future:
[09:29:18.487] MultisessionFuture:
[09:29:18.487] Label: ‘future_mapply-2’
[09:29:18.487] Expression:
[09:29:18.487] {
[09:29:18.487]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.487]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:18.487]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.487]         on.exit(options(oopts), add = TRUE)
[09:29:18.487]     }
[09:29:18.487]     {
[09:29:18.487]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.487]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:18.487]         do.call(mapply, args = args)
[09:29:18.487]     }
[09:29:18.487] }
[09:29:18.487] Lazy evaluation: FALSE
[09:29:18.487] Asynchronous evaluation: TRUE
[09:29:18.487] Local evaluation: TRUE
[09:29:18.487] Environment: R_GlobalEnv
[09:29:18.487] Capture standard output: TRUE
[09:29:18.487] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:18.487] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:18.487] Packages: <none>
[09:29:18.487] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:18.487] Resolved: FALSE
[09:29:18.487] Value: <not collected>
[09:29:18.487] Conditions captured: <none>
[09:29:18.487] Early signaling: FALSE
[09:29:18.487] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:18.487] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.499] Chunk #2 of 2 ... DONE
[09:29:18.499] Launching 2 futures (chunks) ... DONE
[09:29:18.499] Resolving 2 futures (chunks) ...
[09:29:18.500] resolve() on list ...
[09:29:18.500]  recursive: 0
[09:29:18.500]  length: 2
[09:29:18.500] 
[09:29:18.501] receiveMessageFromWorker() for ClusterFuture ...
[09:29:18.501] - Validating connection of MultisessionFuture
[09:29:18.501] - received message: FutureResult
[09:29:18.501] - Received FutureResult
[09:29:18.501] - Erased future from FutureRegistry
[09:29:18.501] result() for ClusterFuture ...
[09:29:18.501] - result already collected: FutureResult
[09:29:18.502] result() for ClusterFuture ... done
[09:29:18.502] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:18.502] Future #1
[09:29:18.502] result() for ClusterFuture ...
[09:29:18.502] - result already collected: FutureResult
[09:29:18.502] result() for ClusterFuture ... done
[09:29:18.502] result() for ClusterFuture ...
[09:29:18.502] - result already collected: FutureResult
[09:29:18.502] result() for ClusterFuture ... done
[09:29:18.503] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:18.503] - nx: 2
[09:29:18.503] - relay: TRUE
[09:29:18.503] - stdout: TRUE
[09:29:18.503] - signal: TRUE
[09:29:18.503] - resignal: FALSE
[09:29:18.503] - force: TRUE
[09:29:18.503] - relayed: [n=2] FALSE, FALSE
[09:29:18.503] - queued futures: [n=2] FALSE, FALSE
[09:29:18.503]  - until=1
[09:29:18.504]  - relaying element #1
[09:29:18.504] result() for ClusterFuture ...
[09:29:18.504] - result already collected: FutureResult
[09:29:18.504] result() for ClusterFuture ... done
[09:29:18.504] result() for ClusterFuture ...
[09:29:18.504] - result already collected: FutureResult
[09:29:18.504] result() for ClusterFuture ... done
[09:29:18.504] result() for ClusterFuture ...
[09:29:18.505] - result already collected: FutureResult
[09:29:18.505] result() for ClusterFuture ... done
[09:29:18.505] result() for ClusterFuture ...
[09:29:18.505] - result already collected: FutureResult
[09:29:18.505] result() for ClusterFuture ... done
[09:29:18.505] - relayed: [n=2] TRUE, FALSE
[09:29:18.505] - queued futures: [n=2] TRUE, FALSE
[09:29:18.505] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:18.505]  length: 1 (resolved future 1)
[09:29:18.568] receiveMessageFromWorker() for ClusterFuture ...
[09:29:18.569] - Validating connection of MultisessionFuture
[09:29:18.569] - received message: FutureResult
[09:29:18.569] - Received FutureResult
[09:29:18.569] - Erased future from FutureRegistry
[09:29:18.569] result() for ClusterFuture ...
[09:29:18.569] - result already collected: FutureResult
[09:29:18.569] result() for ClusterFuture ... done
[09:29:18.569] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:18.570] Future #2
[09:29:18.570] result() for ClusterFuture ...
[09:29:18.570] - result already collected: FutureResult
[09:29:18.570] result() for ClusterFuture ... done
[09:29:18.570] result() for ClusterFuture ...
[09:29:18.570] - result already collected: FutureResult
[09:29:18.570] result() for ClusterFuture ... done
[09:29:18.570] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:18.571] - nx: 2
[09:29:18.571] - relay: TRUE
[09:29:18.571] - stdout: TRUE
[09:29:18.571] - signal: TRUE
[09:29:18.571] - resignal: FALSE
[09:29:18.571] - force: TRUE
[09:29:18.571] - relayed: [n=2] TRUE, FALSE
[09:29:18.576] - queued futures: [n=2] TRUE, FALSE
[09:29:18.576]  - until=2
[09:29:18.576]  - relaying element #2
[09:29:18.576] result() for ClusterFuture ...
[09:29:18.576] - result already collected: FutureResult
[09:29:18.576] result() for ClusterFuture ... done
[09:29:18.576] result() for ClusterFuture ...
[09:29:18.576] - result already collected: FutureResult
[09:29:18.576] result() for ClusterFuture ... done
[09:29:18.577] result() for ClusterFuture ...
[09:29:18.577] - result already collected: FutureResult
[09:29:18.577] result() for ClusterFuture ... done
[09:29:18.577] result() for ClusterFuture ...
[09:29:18.577] - result already collected: FutureResult
[09:29:18.577] result() for ClusterFuture ... done
[09:29:18.577] - relayed: [n=2] TRUE, TRUE
[09:29:18.577] - queued futures: [n=2] TRUE, TRUE
[09:29:18.577] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:18.577]  length: 0 (resolved future 2)
[09:29:18.578] Relaying remaining futures
[09:29:18.578] signalConditionsASAP(NULL, pos=0) ...
[09:29:18.578] - nx: 2
[09:29:18.578] - relay: TRUE
[09:29:18.578] - stdout: TRUE
[09:29:18.578] - signal: TRUE
[09:29:18.578] - resignal: FALSE
[09:29:18.578] - force: TRUE
[09:29:18.578] - relayed: [n=2] TRUE, TRUE
[09:29:18.578] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:18.578] - relayed: [n=2] TRUE, TRUE
[09:29:18.579] - queued futures: [n=2] TRUE, TRUE
[09:29:18.579] signalConditionsASAP(NULL, pos=0) ... done
[09:29:18.579] resolve() on list ... DONE
[09:29:18.579] result() for ClusterFuture ...
[09:29:18.579] - result already collected: FutureResult
[09:29:18.579] result() for ClusterFuture ... done
[09:29:18.579] result() for ClusterFuture ...
[09:29:18.579] - result already collected: FutureResult
[09:29:18.579] result() for ClusterFuture ... done
[09:29:18.579] result() for ClusterFuture ...
[09:29:18.579] - result already collected: FutureResult
[09:29:18.579] result() for ClusterFuture ... done
[09:29:18.580] result() for ClusterFuture ...
[09:29:18.580] - result already collected: FutureResult
[09:29:18.580] result() for ClusterFuture ... done
[09:29:18.580]  - Number of value chunks collected: 2
[09:29:18.580] Resolving 2 futures (chunks) ... DONE
[09:29:18.580] Reducing values from 2 chunks ...
[09:29:18.580]  - Number of values collected after concatenation: 4
[09:29:18.580]  - Number of values expected: 4
[09:29:18.580] Reducing values from 2 chunks ... DONE
[09:29:18.580] future_mapply() ... DONE
[09:29:18.580] future_mapply() ...
[09:29:18.584] Number of chunks: 2
[09:29:18.584] getGlobalsAndPackagesXApply() ...
[09:29:18.584]  - future.globals: TRUE
[09:29:18.584] getGlobalsAndPackages() ...
[09:29:18.585] Searching for globals...
[09:29:18.585] - globals found: [1] ‘FUN’
[09:29:18.585] Searching for globals ... DONE
[09:29:18.585] Resolving globals: FALSE
[09:29:18.586] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:18.586] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:18.586] - globals: [1] ‘FUN’
[09:29:18.586] 
[09:29:18.586] getGlobalsAndPackages() ... DONE
[09:29:18.586]  - globals found/used: [n=1] ‘FUN’
[09:29:18.586]  - needed namespaces: [n=0] 
[09:29:18.587] Finding globals ... DONE
[09:29:18.587] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:18.587] List of 2
[09:29:18.587]  $ ...future.FUN:function (x, ...)  
[09:29:18.587]  $ MoreArgs     : NULL
[09:29:18.587]  - attr(*, "where")=List of 2
[09:29:18.587]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:18.587]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:18.587]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:18.587]  - attr(*, "resolved")= logi FALSE
[09:29:18.587]  - attr(*, "total_size")= num NA
[09:29:18.589] Packages to be attached in all futures: [n=0] 
[09:29:18.589] getGlobalsAndPackagesXApply() ... DONE
[09:29:18.589] Number of futures (= number of chunks): 2
[09:29:18.590] Launching 2 futures (chunks) ...
[09:29:18.590] Chunk #1 of 2 ...
[09:29:18.590]  - Finding globals in '...' for chunk #1 ...
[09:29:18.590] getGlobalsAndPackages() ...
[09:29:18.590] Searching for globals...
[09:29:18.590] 
[09:29:18.590] Searching for globals ... DONE
[09:29:18.590] - globals: [0] <none>
[09:29:18.591] getGlobalsAndPackages() ... DONE
[09:29:18.591]    + additional globals found: [n=0] 
[09:29:18.591]    + additional namespaces needed: [n=0] 
[09:29:18.591]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:18.591]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:18.591]  - seeds: <none>
[09:29:18.591]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.591] getGlobalsAndPackages() ...
[09:29:18.591] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.591] Resolving globals: FALSE
[09:29:18.592] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:18.592] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:18.592] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.592] 
[09:29:18.593] getGlobalsAndPackages() ... DONE
[09:29:18.593] run() for ‘Future’ ...
[09:29:18.593] - state: ‘created’
[09:29:18.593] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:18.607] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:18.608]   - Field: ‘node’
[09:29:18.608]   - Field: ‘label’
[09:29:18.608]   - Field: ‘local’
[09:29:18.608]   - Field: ‘owner’
[09:29:18.608]   - Field: ‘envir’
[09:29:18.608]   - Field: ‘workers’
[09:29:18.608]   - Field: ‘packages’
[09:29:18.608]   - Field: ‘gc’
[09:29:18.609]   - Field: ‘conditions’
[09:29:18.609]   - Field: ‘persistent’
[09:29:18.609]   - Field: ‘expr’
[09:29:18.609]   - Field: ‘uuid’
[09:29:18.609]   - Field: ‘seed’
[09:29:18.609]   - Field: ‘version’
[09:29:18.609]   - Field: ‘result’
[09:29:18.609]   - Field: ‘asynchronous’
[09:29:18.609]   - Field: ‘calls’
[09:29:18.609]   - Field: ‘globals’
[09:29:18.609]   - Field: ‘stdout’
[09:29:18.609]   - Field: ‘earlySignal’
[09:29:18.610]   - Field: ‘lazy’
[09:29:18.610]   - Field: ‘state’
[09:29:18.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:18.610] - Launch lazy future ...
[09:29:18.610] Packages needed by the future expression (n = 0): <none>
[09:29:18.610] Packages needed by future strategies (n = 0): <none>
[09:29:18.611] {
[09:29:18.611]     {
[09:29:18.611]         {
[09:29:18.611]             ...future.startTime <- base::Sys.time()
[09:29:18.611]             {
[09:29:18.611]                 {
[09:29:18.611]                   {
[09:29:18.611]                     {
[09:29:18.611]                       base::local({
[09:29:18.611]                         has_future <- base::requireNamespace("future", 
[09:29:18.611]                           quietly = TRUE)
[09:29:18.611]                         if (has_future) {
[09:29:18.611]                           ns <- base::getNamespace("future")
[09:29:18.611]                           version <- ns[[".package"]][["version"]]
[09:29:18.611]                           if (is.null(version)) 
[09:29:18.611]                             version <- utils::packageVersion("future")
[09:29:18.611]                         }
[09:29:18.611]                         else {
[09:29:18.611]                           version <- NULL
[09:29:18.611]                         }
[09:29:18.611]                         if (!has_future || version < "1.8.0") {
[09:29:18.611]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:18.611]                             "", base::R.version$version.string), 
[09:29:18.611]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:18.611]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:18.611]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:18.611]                               "release", "version")], collapse = " "), 
[09:29:18.611]                             hostname = base::Sys.info()[["nodename"]])
[09:29:18.611]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:18.611]                             info)
[09:29:18.611]                           info <- base::paste(info, collapse = "; ")
[09:29:18.611]                           if (!has_future) {
[09:29:18.611]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:18.611]                               info)
[09:29:18.611]                           }
[09:29:18.611]                           else {
[09:29:18.611]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:18.611]                               info, version)
[09:29:18.611]                           }
[09:29:18.611]                           base::stop(msg)
[09:29:18.611]                         }
[09:29:18.611]                       })
[09:29:18.611]                     }
[09:29:18.611]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:18.611]                     base::options(mc.cores = 1L)
[09:29:18.611]                   }
[09:29:18.611]                   ...future.strategy.old <- future::plan("list")
[09:29:18.611]                   options(future.plan = NULL)
[09:29:18.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:18.611]                 }
[09:29:18.611]                 ...future.workdir <- getwd()
[09:29:18.611]             }
[09:29:18.611]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:18.611]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:18.611]         }
[09:29:18.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:18.611]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:18.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:18.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:18.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:18.611]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:18.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:18.611]             base::names(...future.oldOptions))
[09:29:18.611]     }
[09:29:18.611]     if (FALSE) {
[09:29:18.611]     }
[09:29:18.611]     else {
[09:29:18.611]         if (TRUE) {
[09:29:18.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:18.611]                 open = "w")
[09:29:18.611]         }
[09:29:18.611]         else {
[09:29:18.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:18.611]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:18.611]         }
[09:29:18.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:18.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:18.611]             base::sink(type = "output", split = FALSE)
[09:29:18.611]             base::close(...future.stdout)
[09:29:18.611]         }, add = TRUE)
[09:29:18.611]     }
[09:29:18.611]     ...future.frame <- base::sys.nframe()
[09:29:18.611]     ...future.conditions <- base::list()
[09:29:18.611]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:18.611]     if (FALSE) {
[09:29:18.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:18.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:18.611]     }
[09:29:18.611]     ...future.result <- base::tryCatch({
[09:29:18.611]         base::withCallingHandlers({
[09:29:18.611]             ...future.value <- base::withVisible(base::local({
[09:29:18.611]                 ...future.makeSendCondition <- base::local({
[09:29:18.611]                   sendCondition <- NULL
[09:29:18.611]                   function(frame = 1L) {
[09:29:18.611]                     if (is.function(sendCondition)) 
[09:29:18.611]                       return(sendCondition)
[09:29:18.611]                     ns <- getNamespace("parallel")
[09:29:18.611]                     if (exists("sendData", mode = "function", 
[09:29:18.611]                       envir = ns)) {
[09:29:18.611]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:18.611]                         envir = ns)
[09:29:18.611]                       envir <- sys.frame(frame)
[09:29:18.611]                       master <- NULL
[09:29:18.611]                       while (!identical(envir, .GlobalEnv) && 
[09:29:18.611]                         !identical(envir, emptyenv())) {
[09:29:18.611]                         if (exists("master", mode = "list", envir = envir, 
[09:29:18.611]                           inherits = FALSE)) {
[09:29:18.611]                           master <- get("master", mode = "list", 
[09:29:18.611]                             envir = envir, inherits = FALSE)
[09:29:18.611]                           if (inherits(master, c("SOCKnode", 
[09:29:18.611]                             "SOCK0node"))) {
[09:29:18.611]                             sendCondition <<- function(cond) {
[09:29:18.611]                               data <- list(type = "VALUE", value = cond, 
[09:29:18.611]                                 success = TRUE)
[09:29:18.611]                               parallel_sendData(master, data)
[09:29:18.611]                             }
[09:29:18.611]                             return(sendCondition)
[09:29:18.611]                           }
[09:29:18.611]                         }
[09:29:18.611]                         frame <- frame + 1L
[09:29:18.611]                         envir <- sys.frame(frame)
[09:29:18.611]                       }
[09:29:18.611]                     }
[09:29:18.611]                     sendCondition <<- function(cond) NULL
[09:29:18.611]                   }
[09:29:18.611]                 })
[09:29:18.611]                 withCallingHandlers({
[09:29:18.611]                   {
[09:29:18.611]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.611]                     if (!identical(...future.globals.maxSize.org, 
[09:29:18.611]                       ...future.globals.maxSize)) {
[09:29:18.611]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.611]                       on.exit(options(oopts), add = TRUE)
[09:29:18.611]                     }
[09:29:18.611]                     {
[09:29:18.611]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.611]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:18.611]                         USE.NAMES = FALSE)
[09:29:18.611]                       do.call(mapply, args = args)
[09:29:18.611]                     }
[09:29:18.611]                   }
[09:29:18.611]                 }, immediateCondition = function(cond) {
[09:29:18.611]                   sendCondition <- ...future.makeSendCondition()
[09:29:18.611]                   sendCondition(cond)
[09:29:18.611]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.611]                   {
[09:29:18.611]                     inherits <- base::inherits
[09:29:18.611]                     invokeRestart <- base::invokeRestart
[09:29:18.611]                     is.null <- base::is.null
[09:29:18.611]                     muffled <- FALSE
[09:29:18.611]                     if (inherits(cond, "message")) {
[09:29:18.611]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:18.611]                       if (muffled) 
[09:29:18.611]                         invokeRestart("muffleMessage")
[09:29:18.611]                     }
[09:29:18.611]                     else if (inherits(cond, "warning")) {
[09:29:18.611]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:18.611]                       if (muffled) 
[09:29:18.611]                         invokeRestart("muffleWarning")
[09:29:18.611]                     }
[09:29:18.611]                     else if (inherits(cond, "condition")) {
[09:29:18.611]                       if (!is.null(pattern)) {
[09:29:18.611]                         computeRestarts <- base::computeRestarts
[09:29:18.611]                         grepl <- base::grepl
[09:29:18.611]                         restarts <- computeRestarts(cond)
[09:29:18.611]                         for (restart in restarts) {
[09:29:18.611]                           name <- restart$name
[09:29:18.611]                           if (is.null(name)) 
[09:29:18.611]                             next
[09:29:18.611]                           if (!grepl(pattern, name)) 
[09:29:18.611]                             next
[09:29:18.611]                           invokeRestart(restart)
[09:29:18.611]                           muffled <- TRUE
[09:29:18.611]                           break
[09:29:18.611]                         }
[09:29:18.611]                       }
[09:29:18.611]                     }
[09:29:18.611]                     invisible(muffled)
[09:29:18.611]                   }
[09:29:18.611]                   muffleCondition(cond)
[09:29:18.611]                 })
[09:29:18.611]             }))
[09:29:18.611]             future::FutureResult(value = ...future.value$value, 
[09:29:18.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.611]                   ...future.rng), globalenv = if (FALSE) 
[09:29:18.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:18.611]                     ...future.globalenv.names))
[09:29:18.611]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:18.611]         }, condition = base::local({
[09:29:18.611]             c <- base::c
[09:29:18.611]             inherits <- base::inherits
[09:29:18.611]             invokeRestart <- base::invokeRestart
[09:29:18.611]             length <- base::length
[09:29:18.611]             list <- base::list
[09:29:18.611]             seq.int <- base::seq.int
[09:29:18.611]             signalCondition <- base::signalCondition
[09:29:18.611]             sys.calls <- base::sys.calls
[09:29:18.611]             `[[` <- base::`[[`
[09:29:18.611]             `+` <- base::`+`
[09:29:18.611]             `<<-` <- base::`<<-`
[09:29:18.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:18.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:18.611]                   3L)]
[09:29:18.611]             }
[09:29:18.611]             function(cond) {
[09:29:18.611]                 is_error <- inherits(cond, "error")
[09:29:18.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:18.611]                   NULL)
[09:29:18.611]                 if (is_error) {
[09:29:18.611]                   sessionInformation <- function() {
[09:29:18.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:18.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:18.611]                       search = base::search(), system = base::Sys.info())
[09:29:18.611]                   }
[09:29:18.611]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:18.611]                     cond$call), session = sessionInformation(), 
[09:29:18.611]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:18.611]                   signalCondition(cond)
[09:29:18.611]                 }
[09:29:18.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:18.611]                 "immediateCondition"))) {
[09:29:18.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:18.611]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:18.611]                   if (TRUE && !signal) {
[09:29:18.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.611]                     {
[09:29:18.611]                       inherits <- base::inherits
[09:29:18.611]                       invokeRestart <- base::invokeRestart
[09:29:18.611]                       is.null <- base::is.null
[09:29:18.611]                       muffled <- FALSE
[09:29:18.611]                       if (inherits(cond, "message")) {
[09:29:18.611]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.611]                         if (muffled) 
[09:29:18.611]                           invokeRestart("muffleMessage")
[09:29:18.611]                       }
[09:29:18.611]                       else if (inherits(cond, "warning")) {
[09:29:18.611]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.611]                         if (muffled) 
[09:29:18.611]                           invokeRestart("muffleWarning")
[09:29:18.611]                       }
[09:29:18.611]                       else if (inherits(cond, "condition")) {
[09:29:18.611]                         if (!is.null(pattern)) {
[09:29:18.611]                           computeRestarts <- base::computeRestarts
[09:29:18.611]                           grepl <- base::grepl
[09:29:18.611]                           restarts <- computeRestarts(cond)
[09:29:18.611]                           for (restart in restarts) {
[09:29:18.611]                             name <- restart$name
[09:29:18.611]                             if (is.null(name)) 
[09:29:18.611]                               next
[09:29:18.611]                             if (!grepl(pattern, name)) 
[09:29:18.611]                               next
[09:29:18.611]                             invokeRestart(restart)
[09:29:18.611]                             muffled <- TRUE
[09:29:18.611]                             break
[09:29:18.611]                           }
[09:29:18.611]                         }
[09:29:18.611]                       }
[09:29:18.611]                       invisible(muffled)
[09:29:18.611]                     }
[09:29:18.611]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.611]                   }
[09:29:18.611]                 }
[09:29:18.611]                 else {
[09:29:18.611]                   if (TRUE) {
[09:29:18.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.611]                     {
[09:29:18.611]                       inherits <- base::inherits
[09:29:18.611]                       invokeRestart <- base::invokeRestart
[09:29:18.611]                       is.null <- base::is.null
[09:29:18.611]                       muffled <- FALSE
[09:29:18.611]                       if (inherits(cond, "message")) {
[09:29:18.611]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.611]                         if (muffled) 
[09:29:18.611]                           invokeRestart("muffleMessage")
[09:29:18.611]                       }
[09:29:18.611]                       else if (inherits(cond, "warning")) {
[09:29:18.611]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.611]                         if (muffled) 
[09:29:18.611]                           invokeRestart("muffleWarning")
[09:29:18.611]                       }
[09:29:18.611]                       else if (inherits(cond, "condition")) {
[09:29:18.611]                         if (!is.null(pattern)) {
[09:29:18.611]                           computeRestarts <- base::computeRestarts
[09:29:18.611]                           grepl <- base::grepl
[09:29:18.611]                           restarts <- computeRestarts(cond)
[09:29:18.611]                           for (restart in restarts) {
[09:29:18.611]                             name <- restart$name
[09:29:18.611]                             if (is.null(name)) 
[09:29:18.611]                               next
[09:29:18.611]                             if (!grepl(pattern, name)) 
[09:29:18.611]                               next
[09:29:18.611]                             invokeRestart(restart)
[09:29:18.611]                             muffled <- TRUE
[09:29:18.611]                             break
[09:29:18.611]                           }
[09:29:18.611]                         }
[09:29:18.611]                       }
[09:29:18.611]                       invisible(muffled)
[09:29:18.611]                     }
[09:29:18.611]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.611]                   }
[09:29:18.611]                 }
[09:29:18.611]             }
[09:29:18.611]         }))
[09:29:18.611]     }, error = function(ex) {
[09:29:18.611]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:18.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.611]                 ...future.rng), started = ...future.startTime, 
[09:29:18.611]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:18.611]             version = "1.8"), class = "FutureResult")
[09:29:18.611]     }, finally = {
[09:29:18.611]         if (!identical(...future.workdir, getwd())) 
[09:29:18.611]             setwd(...future.workdir)
[09:29:18.611]         {
[09:29:18.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:18.611]                 ...future.oldOptions$nwarnings <- NULL
[09:29:18.611]             }
[09:29:18.611]             base::options(...future.oldOptions)
[09:29:18.611]             if (.Platform$OS.type == "windows") {
[09:29:18.611]                 old_names <- names(...future.oldEnvVars)
[09:29:18.611]                 envs <- base::Sys.getenv()
[09:29:18.611]                 names <- names(envs)
[09:29:18.611]                 common <- intersect(names, old_names)
[09:29:18.611]                 added <- setdiff(names, old_names)
[09:29:18.611]                 removed <- setdiff(old_names, names)
[09:29:18.611]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:18.611]                   envs[common]]
[09:29:18.611]                 NAMES <- toupper(changed)
[09:29:18.611]                 args <- list()
[09:29:18.611]                 for (kk in seq_along(NAMES)) {
[09:29:18.611]                   name <- changed[[kk]]
[09:29:18.611]                   NAME <- NAMES[[kk]]
[09:29:18.611]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.611]                     next
[09:29:18.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.611]                 }
[09:29:18.611]                 NAMES <- toupper(added)
[09:29:18.611]                 for (kk in seq_along(NAMES)) {
[09:29:18.611]                   name <- added[[kk]]
[09:29:18.611]                   NAME <- NAMES[[kk]]
[09:29:18.611]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.611]                     next
[09:29:18.611]                   args[[name]] <- ""
[09:29:18.611]                 }
[09:29:18.611]                 NAMES <- toupper(removed)
[09:29:18.611]                 for (kk in seq_along(NAMES)) {
[09:29:18.611]                   name <- removed[[kk]]
[09:29:18.611]                   NAME <- NAMES[[kk]]
[09:29:18.611]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.611]                     next
[09:29:18.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.611]                 }
[09:29:18.611]                 if (length(args) > 0) 
[09:29:18.611]                   base::do.call(base::Sys.setenv, args = args)
[09:29:18.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:18.611]             }
[09:29:18.611]             else {
[09:29:18.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:18.611]             }
[09:29:18.611]             {
[09:29:18.611]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:18.611]                   0L) {
[09:29:18.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:18.611]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:18.611]                   base::options(opts)
[09:29:18.611]                 }
[09:29:18.611]                 {
[09:29:18.611]                   {
[09:29:18.611]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:18.611]                     NULL
[09:29:18.611]                   }
[09:29:18.611]                   options(future.plan = NULL)
[09:29:18.611]                   if (is.na(NA_character_)) 
[09:29:18.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:18.611]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:18.611]                     .init = FALSE)
[09:29:18.611]                 }
[09:29:18.611]             }
[09:29:18.611]         }
[09:29:18.611]     })
[09:29:18.611]     if (TRUE) {
[09:29:18.611]         base::sink(type = "output", split = FALSE)
[09:29:18.611]         if (TRUE) {
[09:29:18.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:18.611]         }
[09:29:18.611]         else {
[09:29:18.611]             ...future.result["stdout"] <- base::list(NULL)
[09:29:18.611]         }
[09:29:18.611]         base::close(...future.stdout)
[09:29:18.611]         ...future.stdout <- NULL
[09:29:18.611]     }
[09:29:18.611]     ...future.result$conditions <- ...future.conditions
[09:29:18.611]     ...future.result$finished <- base::Sys.time()
[09:29:18.611]     ...future.result
[09:29:18.611] }
[09:29:18.613] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[09:29:18.614] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[09:29:18.614] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[09:29:18.614] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:18.614] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:18.615] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[09:29:18.615] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[09:29:18.615] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:18.615] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:18.616] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:18.616] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:18.616] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[09:29:18.617] MultisessionFuture started
[09:29:18.617] - Launch lazy future ... done
[09:29:18.617] run() for ‘MultisessionFuture’ ... done
[09:29:18.617] Created future:
[09:29:18.617] MultisessionFuture:
[09:29:18.617] Label: ‘future_mapply-1’
[09:29:18.617] Expression:
[09:29:18.617] {
[09:29:18.617]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.617]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:18.617]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.617]         on.exit(options(oopts), add = TRUE)
[09:29:18.617]     }
[09:29:18.617]     {
[09:29:18.617]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.617]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:18.617]         do.call(mapply, args = args)
[09:29:18.617]     }
[09:29:18.617] }
[09:29:18.617] Lazy evaluation: FALSE
[09:29:18.617] Asynchronous evaluation: TRUE
[09:29:18.617] Local evaluation: TRUE
[09:29:18.617] Environment: R_GlobalEnv
[09:29:18.617] Capture standard output: TRUE
[09:29:18.617] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:18.617] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:18.617] Packages: <none>
[09:29:18.617] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:18.617] Resolved: FALSE
[09:29:18.617] Value: <not collected>
[09:29:18.617] Conditions captured: <none>
[09:29:18.617] Early signaling: FALSE
[09:29:18.617] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:18.617] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.629] Chunk #1 of 2 ... DONE
[09:29:18.629] Chunk #2 of 2 ...
[09:29:18.629]  - Finding globals in '...' for chunk #2 ...
[09:29:18.629] getGlobalsAndPackages() ...
[09:29:18.629] Searching for globals...
[09:29:18.630] 
[09:29:18.630] Searching for globals ... DONE
[09:29:18.630] - globals: [0] <none>
[09:29:18.630] getGlobalsAndPackages() ... DONE
[09:29:18.630]    + additional globals found: [n=0] 
[09:29:18.630]    + additional namespaces needed: [n=0] 
[09:29:18.630]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:18.630]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:18.630]  - seeds: <none>
[09:29:18.630]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.631] getGlobalsAndPackages() ...
[09:29:18.631] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.631] Resolving globals: FALSE
[09:29:18.631] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:18.632] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:18.632] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.632] 
[09:29:18.632] getGlobalsAndPackages() ... DONE
[09:29:18.632] run() for ‘Future’ ...
[09:29:18.632] - state: ‘created’
[09:29:18.633] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:18.646] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.646] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:18.646]   - Field: ‘node’
[09:29:18.646]   - Field: ‘label’
[09:29:18.646]   - Field: ‘local’
[09:29:18.646]   - Field: ‘owner’
[09:29:18.647]   - Field: ‘envir’
[09:29:18.647]   - Field: ‘workers’
[09:29:18.647]   - Field: ‘packages’
[09:29:18.647]   - Field: ‘gc’
[09:29:18.647]   - Field: ‘conditions’
[09:29:18.647]   - Field: ‘persistent’
[09:29:18.647]   - Field: ‘expr’
[09:29:18.647]   - Field: ‘uuid’
[09:29:18.647]   - Field: ‘seed’
[09:29:18.647]   - Field: ‘version’
[09:29:18.647]   - Field: ‘result’
[09:29:18.648]   - Field: ‘asynchronous’
[09:29:18.648]   - Field: ‘calls’
[09:29:18.648]   - Field: ‘globals’
[09:29:18.648]   - Field: ‘stdout’
[09:29:18.648]   - Field: ‘earlySignal’
[09:29:18.648]   - Field: ‘lazy’
[09:29:18.648]   - Field: ‘state’
[09:29:18.648] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:18.648] - Launch lazy future ...
[09:29:18.649] Packages needed by the future expression (n = 0): <none>
[09:29:18.649] Packages needed by future strategies (n = 0): <none>
[09:29:18.649] {
[09:29:18.649]     {
[09:29:18.649]         {
[09:29:18.649]             ...future.startTime <- base::Sys.time()
[09:29:18.649]             {
[09:29:18.649]                 {
[09:29:18.649]                   {
[09:29:18.649]                     {
[09:29:18.649]                       base::local({
[09:29:18.649]                         has_future <- base::requireNamespace("future", 
[09:29:18.649]                           quietly = TRUE)
[09:29:18.649]                         if (has_future) {
[09:29:18.649]                           ns <- base::getNamespace("future")
[09:29:18.649]                           version <- ns[[".package"]][["version"]]
[09:29:18.649]                           if (is.null(version)) 
[09:29:18.649]                             version <- utils::packageVersion("future")
[09:29:18.649]                         }
[09:29:18.649]                         else {
[09:29:18.649]                           version <- NULL
[09:29:18.649]                         }
[09:29:18.649]                         if (!has_future || version < "1.8.0") {
[09:29:18.649]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:18.649]                             "", base::R.version$version.string), 
[09:29:18.649]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:18.649]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:18.649]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:18.649]                               "release", "version")], collapse = " "), 
[09:29:18.649]                             hostname = base::Sys.info()[["nodename"]])
[09:29:18.649]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:18.649]                             info)
[09:29:18.649]                           info <- base::paste(info, collapse = "; ")
[09:29:18.649]                           if (!has_future) {
[09:29:18.649]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:18.649]                               info)
[09:29:18.649]                           }
[09:29:18.649]                           else {
[09:29:18.649]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:18.649]                               info, version)
[09:29:18.649]                           }
[09:29:18.649]                           base::stop(msg)
[09:29:18.649]                         }
[09:29:18.649]                       })
[09:29:18.649]                     }
[09:29:18.649]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:18.649]                     base::options(mc.cores = 1L)
[09:29:18.649]                   }
[09:29:18.649]                   ...future.strategy.old <- future::plan("list")
[09:29:18.649]                   options(future.plan = NULL)
[09:29:18.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:18.649]                 }
[09:29:18.649]                 ...future.workdir <- getwd()
[09:29:18.649]             }
[09:29:18.649]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:18.649]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:18.649]         }
[09:29:18.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:18.649]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:18.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:18.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:18.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:18.649]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:18.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:18.649]             base::names(...future.oldOptions))
[09:29:18.649]     }
[09:29:18.649]     if (FALSE) {
[09:29:18.649]     }
[09:29:18.649]     else {
[09:29:18.649]         if (TRUE) {
[09:29:18.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:18.649]                 open = "w")
[09:29:18.649]         }
[09:29:18.649]         else {
[09:29:18.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:18.649]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:18.649]         }
[09:29:18.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:18.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:18.649]             base::sink(type = "output", split = FALSE)
[09:29:18.649]             base::close(...future.stdout)
[09:29:18.649]         }, add = TRUE)
[09:29:18.649]     }
[09:29:18.649]     ...future.frame <- base::sys.nframe()
[09:29:18.649]     ...future.conditions <- base::list()
[09:29:18.649]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:18.649]     if (FALSE) {
[09:29:18.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:18.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:18.649]     }
[09:29:18.649]     ...future.result <- base::tryCatch({
[09:29:18.649]         base::withCallingHandlers({
[09:29:18.649]             ...future.value <- base::withVisible(base::local({
[09:29:18.649]                 ...future.makeSendCondition <- base::local({
[09:29:18.649]                   sendCondition <- NULL
[09:29:18.649]                   function(frame = 1L) {
[09:29:18.649]                     if (is.function(sendCondition)) 
[09:29:18.649]                       return(sendCondition)
[09:29:18.649]                     ns <- getNamespace("parallel")
[09:29:18.649]                     if (exists("sendData", mode = "function", 
[09:29:18.649]                       envir = ns)) {
[09:29:18.649]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:18.649]                         envir = ns)
[09:29:18.649]                       envir <- sys.frame(frame)
[09:29:18.649]                       master <- NULL
[09:29:18.649]                       while (!identical(envir, .GlobalEnv) && 
[09:29:18.649]                         !identical(envir, emptyenv())) {
[09:29:18.649]                         if (exists("master", mode = "list", envir = envir, 
[09:29:18.649]                           inherits = FALSE)) {
[09:29:18.649]                           master <- get("master", mode = "list", 
[09:29:18.649]                             envir = envir, inherits = FALSE)
[09:29:18.649]                           if (inherits(master, c("SOCKnode", 
[09:29:18.649]                             "SOCK0node"))) {
[09:29:18.649]                             sendCondition <<- function(cond) {
[09:29:18.649]                               data <- list(type = "VALUE", value = cond, 
[09:29:18.649]                                 success = TRUE)
[09:29:18.649]                               parallel_sendData(master, data)
[09:29:18.649]                             }
[09:29:18.649]                             return(sendCondition)
[09:29:18.649]                           }
[09:29:18.649]                         }
[09:29:18.649]                         frame <- frame + 1L
[09:29:18.649]                         envir <- sys.frame(frame)
[09:29:18.649]                       }
[09:29:18.649]                     }
[09:29:18.649]                     sendCondition <<- function(cond) NULL
[09:29:18.649]                   }
[09:29:18.649]                 })
[09:29:18.649]                 withCallingHandlers({
[09:29:18.649]                   {
[09:29:18.649]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.649]                     if (!identical(...future.globals.maxSize.org, 
[09:29:18.649]                       ...future.globals.maxSize)) {
[09:29:18.649]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.649]                       on.exit(options(oopts), add = TRUE)
[09:29:18.649]                     }
[09:29:18.649]                     {
[09:29:18.649]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.649]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:18.649]                         USE.NAMES = FALSE)
[09:29:18.649]                       do.call(mapply, args = args)
[09:29:18.649]                     }
[09:29:18.649]                   }
[09:29:18.649]                 }, immediateCondition = function(cond) {
[09:29:18.649]                   sendCondition <- ...future.makeSendCondition()
[09:29:18.649]                   sendCondition(cond)
[09:29:18.649]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.649]                   {
[09:29:18.649]                     inherits <- base::inherits
[09:29:18.649]                     invokeRestart <- base::invokeRestart
[09:29:18.649]                     is.null <- base::is.null
[09:29:18.649]                     muffled <- FALSE
[09:29:18.649]                     if (inherits(cond, "message")) {
[09:29:18.649]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:18.649]                       if (muffled) 
[09:29:18.649]                         invokeRestart("muffleMessage")
[09:29:18.649]                     }
[09:29:18.649]                     else if (inherits(cond, "warning")) {
[09:29:18.649]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:18.649]                       if (muffled) 
[09:29:18.649]                         invokeRestart("muffleWarning")
[09:29:18.649]                     }
[09:29:18.649]                     else if (inherits(cond, "condition")) {
[09:29:18.649]                       if (!is.null(pattern)) {
[09:29:18.649]                         computeRestarts <- base::computeRestarts
[09:29:18.649]                         grepl <- base::grepl
[09:29:18.649]                         restarts <- computeRestarts(cond)
[09:29:18.649]                         for (restart in restarts) {
[09:29:18.649]                           name <- restart$name
[09:29:18.649]                           if (is.null(name)) 
[09:29:18.649]                             next
[09:29:18.649]                           if (!grepl(pattern, name)) 
[09:29:18.649]                             next
[09:29:18.649]                           invokeRestart(restart)
[09:29:18.649]                           muffled <- TRUE
[09:29:18.649]                           break
[09:29:18.649]                         }
[09:29:18.649]                       }
[09:29:18.649]                     }
[09:29:18.649]                     invisible(muffled)
[09:29:18.649]                   }
[09:29:18.649]                   muffleCondition(cond)
[09:29:18.649]                 })
[09:29:18.649]             }))
[09:29:18.649]             future::FutureResult(value = ...future.value$value, 
[09:29:18.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.649]                   ...future.rng), globalenv = if (FALSE) 
[09:29:18.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:18.649]                     ...future.globalenv.names))
[09:29:18.649]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:18.649]         }, condition = base::local({
[09:29:18.649]             c <- base::c
[09:29:18.649]             inherits <- base::inherits
[09:29:18.649]             invokeRestart <- base::invokeRestart
[09:29:18.649]             length <- base::length
[09:29:18.649]             list <- base::list
[09:29:18.649]             seq.int <- base::seq.int
[09:29:18.649]             signalCondition <- base::signalCondition
[09:29:18.649]             sys.calls <- base::sys.calls
[09:29:18.649]             `[[` <- base::`[[`
[09:29:18.649]             `+` <- base::`+`
[09:29:18.649]             `<<-` <- base::`<<-`
[09:29:18.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:18.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:18.649]                   3L)]
[09:29:18.649]             }
[09:29:18.649]             function(cond) {
[09:29:18.649]                 is_error <- inherits(cond, "error")
[09:29:18.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:18.649]                   NULL)
[09:29:18.649]                 if (is_error) {
[09:29:18.649]                   sessionInformation <- function() {
[09:29:18.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:18.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:18.649]                       search = base::search(), system = base::Sys.info())
[09:29:18.649]                   }
[09:29:18.649]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:18.649]                     cond$call), session = sessionInformation(), 
[09:29:18.649]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:18.649]                   signalCondition(cond)
[09:29:18.649]                 }
[09:29:18.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:18.649]                 "immediateCondition"))) {
[09:29:18.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:18.649]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:18.649]                   if (TRUE && !signal) {
[09:29:18.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.649]                     {
[09:29:18.649]                       inherits <- base::inherits
[09:29:18.649]                       invokeRestart <- base::invokeRestart
[09:29:18.649]                       is.null <- base::is.null
[09:29:18.649]                       muffled <- FALSE
[09:29:18.649]                       if (inherits(cond, "message")) {
[09:29:18.649]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.649]                         if (muffled) 
[09:29:18.649]                           invokeRestart("muffleMessage")
[09:29:18.649]                       }
[09:29:18.649]                       else if (inherits(cond, "warning")) {
[09:29:18.649]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.649]                         if (muffled) 
[09:29:18.649]                           invokeRestart("muffleWarning")
[09:29:18.649]                       }
[09:29:18.649]                       else if (inherits(cond, "condition")) {
[09:29:18.649]                         if (!is.null(pattern)) {
[09:29:18.649]                           computeRestarts <- base::computeRestarts
[09:29:18.649]                           grepl <- base::grepl
[09:29:18.649]                           restarts <- computeRestarts(cond)
[09:29:18.649]                           for (restart in restarts) {
[09:29:18.649]                             name <- restart$name
[09:29:18.649]                             if (is.null(name)) 
[09:29:18.649]                               next
[09:29:18.649]                             if (!grepl(pattern, name)) 
[09:29:18.649]                               next
[09:29:18.649]                             invokeRestart(restart)
[09:29:18.649]                             muffled <- TRUE
[09:29:18.649]                             break
[09:29:18.649]                           }
[09:29:18.649]                         }
[09:29:18.649]                       }
[09:29:18.649]                       invisible(muffled)
[09:29:18.649]                     }
[09:29:18.649]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.649]                   }
[09:29:18.649]                 }
[09:29:18.649]                 else {
[09:29:18.649]                   if (TRUE) {
[09:29:18.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.649]                     {
[09:29:18.649]                       inherits <- base::inherits
[09:29:18.649]                       invokeRestart <- base::invokeRestart
[09:29:18.649]                       is.null <- base::is.null
[09:29:18.649]                       muffled <- FALSE
[09:29:18.649]                       if (inherits(cond, "message")) {
[09:29:18.649]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.649]                         if (muffled) 
[09:29:18.649]                           invokeRestart("muffleMessage")
[09:29:18.649]                       }
[09:29:18.649]                       else if (inherits(cond, "warning")) {
[09:29:18.649]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.649]                         if (muffled) 
[09:29:18.649]                           invokeRestart("muffleWarning")
[09:29:18.649]                       }
[09:29:18.649]                       else if (inherits(cond, "condition")) {
[09:29:18.649]                         if (!is.null(pattern)) {
[09:29:18.649]                           computeRestarts <- base::computeRestarts
[09:29:18.649]                           grepl <- base::grepl
[09:29:18.649]                           restarts <- computeRestarts(cond)
[09:29:18.649]                           for (restart in restarts) {
[09:29:18.649]                             name <- restart$name
[09:29:18.649]                             if (is.null(name)) 
[09:29:18.649]                               next
[09:29:18.649]                             if (!grepl(pattern, name)) 
[09:29:18.649]                               next
[09:29:18.649]                             invokeRestart(restart)
[09:29:18.649]                             muffled <- TRUE
[09:29:18.649]                             break
[09:29:18.649]                           }
[09:29:18.649]                         }
[09:29:18.649]                       }
[09:29:18.649]                       invisible(muffled)
[09:29:18.649]                     }
[09:29:18.649]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.649]                   }
[09:29:18.649]                 }
[09:29:18.649]             }
[09:29:18.649]         }))
[09:29:18.649]     }, error = function(ex) {
[09:29:18.649]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:18.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.649]                 ...future.rng), started = ...future.startTime, 
[09:29:18.649]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:18.649]             version = "1.8"), class = "FutureResult")
[09:29:18.649]     }, finally = {
[09:29:18.649]         if (!identical(...future.workdir, getwd())) 
[09:29:18.649]             setwd(...future.workdir)
[09:29:18.649]         {
[09:29:18.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:18.649]                 ...future.oldOptions$nwarnings <- NULL
[09:29:18.649]             }
[09:29:18.649]             base::options(...future.oldOptions)
[09:29:18.649]             if (.Platform$OS.type == "windows") {
[09:29:18.649]                 old_names <- names(...future.oldEnvVars)
[09:29:18.649]                 envs <- base::Sys.getenv()
[09:29:18.649]                 names <- names(envs)
[09:29:18.649]                 common <- intersect(names, old_names)
[09:29:18.649]                 added <- setdiff(names, old_names)
[09:29:18.649]                 removed <- setdiff(old_names, names)
[09:29:18.649]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:18.649]                   envs[common]]
[09:29:18.649]                 NAMES <- toupper(changed)
[09:29:18.649]                 args <- list()
[09:29:18.649]                 for (kk in seq_along(NAMES)) {
[09:29:18.649]                   name <- changed[[kk]]
[09:29:18.649]                   NAME <- NAMES[[kk]]
[09:29:18.649]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.649]                     next
[09:29:18.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.649]                 }
[09:29:18.649]                 NAMES <- toupper(added)
[09:29:18.649]                 for (kk in seq_along(NAMES)) {
[09:29:18.649]                   name <- added[[kk]]
[09:29:18.649]                   NAME <- NAMES[[kk]]
[09:29:18.649]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.649]                     next
[09:29:18.649]                   args[[name]] <- ""
[09:29:18.649]                 }
[09:29:18.649]                 NAMES <- toupper(removed)
[09:29:18.649]                 for (kk in seq_along(NAMES)) {
[09:29:18.649]                   name <- removed[[kk]]
[09:29:18.649]                   NAME <- NAMES[[kk]]
[09:29:18.649]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.649]                     next
[09:29:18.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.649]                 }
[09:29:18.649]                 if (length(args) > 0) 
[09:29:18.649]                   base::do.call(base::Sys.setenv, args = args)
[09:29:18.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:18.649]             }
[09:29:18.649]             else {
[09:29:18.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:18.649]             }
[09:29:18.649]             {
[09:29:18.649]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:18.649]                   0L) {
[09:29:18.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:18.649]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:18.649]                   base::options(opts)
[09:29:18.649]                 }
[09:29:18.649]                 {
[09:29:18.649]                   {
[09:29:18.649]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:18.649]                     NULL
[09:29:18.649]                   }
[09:29:18.649]                   options(future.plan = NULL)
[09:29:18.649]                   if (is.na(NA_character_)) 
[09:29:18.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:18.649]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:18.649]                     .init = FALSE)
[09:29:18.649]                 }
[09:29:18.649]             }
[09:29:18.649]         }
[09:29:18.649]     })
[09:29:18.649]     if (TRUE) {
[09:29:18.649]         base::sink(type = "output", split = FALSE)
[09:29:18.649]         if (TRUE) {
[09:29:18.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:18.649]         }
[09:29:18.649]         else {
[09:29:18.649]             ...future.result["stdout"] <- base::list(NULL)
[09:29:18.649]         }
[09:29:18.649]         base::close(...future.stdout)
[09:29:18.649]         ...future.stdout <- NULL
[09:29:18.649]     }
[09:29:18.649]     ...future.result$conditions <- ...future.conditions
[09:29:18.649]     ...future.result$finished <- base::Sys.time()
[09:29:18.649]     ...future.result
[09:29:18.649] }
[09:29:18.652] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[09:29:18.652] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[09:29:18.652] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[09:29:18.652] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:18.653] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:18.653] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[09:29:18.653] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[09:29:18.653] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:18.654] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:18.654] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:18.654] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:18.654] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[09:29:18.654] MultisessionFuture started
[09:29:18.655] - Launch lazy future ... done
[09:29:18.655] run() for ‘MultisessionFuture’ ... done
[09:29:18.655] Created future:
[09:29:18.655] MultisessionFuture:
[09:29:18.655] Label: ‘future_mapply-2’
[09:29:18.655] Expression:
[09:29:18.655] {
[09:29:18.655]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.655]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:18.655]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.655]         on.exit(options(oopts), add = TRUE)
[09:29:18.655]     }
[09:29:18.655]     {
[09:29:18.655]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.655]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:18.655]         do.call(mapply, args = args)
[09:29:18.655]     }
[09:29:18.655] }
[09:29:18.655] Lazy evaluation: FALSE
[09:29:18.655] Asynchronous evaluation: TRUE
[09:29:18.655] Local evaluation: TRUE
[09:29:18.655] Environment: R_GlobalEnv
[09:29:18.655] Capture standard output: TRUE
[09:29:18.655] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:18.655] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:18.655] Packages: <none>
[09:29:18.655] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:18.655] Resolved: FALSE
[09:29:18.655] Value: <not collected>
[09:29:18.655] Conditions captured: <none>
[09:29:18.655] Early signaling: FALSE
[09:29:18.655] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:18.655] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.666] Chunk #2 of 2 ... DONE
[09:29:18.666] Launching 2 futures (chunks) ... DONE
[09:29:18.666] Resolving 2 futures (chunks) ...
[09:29:18.667] resolve() on list ...
[09:29:18.667]  recursive: 0
[09:29:18.667]  length: 2
[09:29:18.667] 
[09:29:18.667] receiveMessageFromWorker() for ClusterFuture ...
[09:29:18.667] - Validating connection of MultisessionFuture
[09:29:18.668] - received message: FutureResult
[09:29:18.668] - Received FutureResult
[09:29:18.668] - Erased future from FutureRegistry
[09:29:18.668] result() for ClusterFuture ...
[09:29:18.668] - result already collected: FutureResult
[09:29:18.668] result() for ClusterFuture ... done
[09:29:18.668] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:18.668] Future #1
[09:29:18.668] result() for ClusterFuture ...
[09:29:18.669] - result already collected: FutureResult
[09:29:18.669] result() for ClusterFuture ... done
[09:29:18.669] result() for ClusterFuture ...
[09:29:18.669] - result already collected: FutureResult
[09:29:18.669] result() for ClusterFuture ... done
[09:29:18.669] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:18.669] - nx: 2
[09:29:18.669] - relay: TRUE
[09:29:18.669] - stdout: TRUE
[09:29:18.669] - signal: TRUE
[09:29:18.669] - resignal: FALSE
[09:29:18.669] - force: TRUE
[09:29:18.670] - relayed: [n=2] FALSE, FALSE
[09:29:18.670] - queued futures: [n=2] FALSE, FALSE
[09:29:18.670]  - until=1
[09:29:18.670]  - relaying element #1
[09:29:18.670] result() for ClusterFuture ...
[09:29:18.670] - result already collected: FutureResult
[09:29:18.670] result() for ClusterFuture ... done
[09:29:18.670] result() for ClusterFuture ...
[09:29:18.670] - result already collected: FutureResult
[09:29:18.670] result() for ClusterFuture ... done
[09:29:18.670] result() for ClusterFuture ...
[09:29:18.671] - result already collected: FutureResult
[09:29:18.671] result() for ClusterFuture ... done
[09:29:18.671] result() for ClusterFuture ...
[09:29:18.671] - result already collected: FutureResult
[09:29:18.671] result() for ClusterFuture ... done
[09:29:18.671] - relayed: [n=2] TRUE, FALSE
[09:29:18.671] - queued futures: [n=2] TRUE, FALSE
[09:29:18.671] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:18.671]  length: 1 (resolved future 1)
[09:29:18.697] receiveMessageFromWorker() for ClusterFuture ...
[09:29:18.697] - Validating connection of MultisessionFuture
[09:29:18.698] - received message: FutureResult
[09:29:18.698] - Received FutureResult
[09:29:18.698] - Erased future from FutureRegistry
[09:29:18.698] result() for ClusterFuture ...
[09:29:18.698] - result already collected: FutureResult
[09:29:18.698] result() for ClusterFuture ... done
[09:29:18.698] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:18.698] Future #2
[09:29:18.698] result() for ClusterFuture ...
[09:29:18.698] - result already collected: FutureResult
[09:29:18.699] result() for ClusterFuture ... done
[09:29:18.699] result() for ClusterFuture ...
[09:29:18.699] - result already collected: FutureResult
[09:29:18.699] result() for ClusterFuture ... done
[09:29:18.699] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:18.699] - nx: 2
[09:29:18.699] - relay: TRUE
[09:29:18.699] - stdout: TRUE
[09:29:18.699] - signal: TRUE
[09:29:18.699] - resignal: FALSE
[09:29:18.699] - force: TRUE
[09:29:18.699] - relayed: [n=2] TRUE, FALSE
[09:29:18.700] - queued futures: [n=2] TRUE, FALSE
[09:29:18.700]  - until=2
[09:29:18.700]  - relaying element #2
[09:29:18.700] result() for ClusterFuture ...
[09:29:18.700] - result already collected: FutureResult
[09:29:18.700] result() for ClusterFuture ... done
[09:29:18.700] result() for ClusterFuture ...
[09:29:18.700] - result already collected: FutureResult
[09:29:18.700] result() for ClusterFuture ... done
[09:29:18.700] result() for ClusterFuture ...
[09:29:18.701] - result already collected: FutureResult
[09:29:18.701] result() for ClusterFuture ... done
[09:29:18.701] result() for ClusterFuture ...
[09:29:18.701] - result already collected: FutureResult
[09:29:18.701] result() for ClusterFuture ... done
[09:29:18.701] - relayed: [n=2] TRUE, TRUE
[09:29:18.701] - queued futures: [n=2] TRUE, TRUE
[09:29:18.701] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:18.701]  length: 0 (resolved future 2)
[09:29:18.701] Relaying remaining futures
[09:29:18.701] signalConditionsASAP(NULL, pos=0) ...
[09:29:18.701] - nx: 2
[09:29:18.702] - relay: TRUE
[09:29:18.702] - stdout: TRUE
[09:29:18.702] - signal: TRUE
[09:29:18.702] - resignal: FALSE
[09:29:18.702] - force: TRUE
[09:29:18.702] - relayed: [n=2] TRUE, TRUE
[09:29:18.702] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:18.702] - relayed: [n=2] TRUE, TRUE
[09:29:18.702] - queued futures: [n=2] TRUE, TRUE
[09:29:18.702] signalConditionsASAP(NULL, pos=0) ... done
[09:29:18.702] resolve() on list ... DONE
[09:29:18.702] result() for ClusterFuture ...
[09:29:18.703] - result already collected: FutureResult
[09:29:18.703] result() for ClusterFuture ... done
[09:29:18.703] result() for ClusterFuture ...
[09:29:18.703] - result already collected: FutureResult
[09:29:18.703] result() for ClusterFuture ... done
[09:29:18.703] result() for ClusterFuture ...
[09:29:18.703] - result already collected: FutureResult
[09:29:18.703] result() for ClusterFuture ... done
[09:29:18.703] result() for ClusterFuture ...
[09:29:18.703] - result already collected: FutureResult
[09:29:18.703] result() for ClusterFuture ... done
[09:29:18.704]  - Number of value chunks collected: 2
[09:29:18.704] Resolving 2 futures (chunks) ... DONE
[09:29:18.704] Reducing values from 2 chunks ...
[09:29:18.704]  - Number of values collected after concatenation: 4
[09:29:18.704]  - Number of values expected: 4
[09:29:18.704] Reducing values from 2 chunks ... DONE
[09:29:18.704] future_mapply() ... DONE
[09:29:18.704] future_mapply() ...
[09:29:18.708] Number of chunks: 2
[09:29:18.708] getGlobalsAndPackagesXApply() ...
[09:29:18.708]  - future.globals: TRUE
[09:29:18.708] getGlobalsAndPackages() ...
[09:29:18.708] Searching for globals...
[09:29:18.709] - globals found: [1] ‘FUN’
[09:29:18.709] Searching for globals ... DONE
[09:29:18.709] Resolving globals: FALSE
[09:29:18.709] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:18.709] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:18.710] - globals: [1] ‘FUN’
[09:29:18.710] 
[09:29:18.710] getGlobalsAndPackages() ... DONE
[09:29:18.710]  - globals found/used: [n=1] ‘FUN’
[09:29:18.710]  - needed namespaces: [n=0] 
[09:29:18.710] Finding globals ... DONE
[09:29:18.710] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:18.710] List of 2
[09:29:18.710]  $ ...future.FUN:function (x, ...)  
[09:29:18.710]  $ MoreArgs     : NULL
[09:29:18.710]  - attr(*, "where")=List of 2
[09:29:18.710]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:18.710]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:18.710]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:18.710]  - attr(*, "resolved")= logi FALSE
[09:29:18.710]  - attr(*, "total_size")= num NA
[09:29:18.713] Packages to be attached in all futures: [n=0] 
[09:29:18.713] getGlobalsAndPackagesXApply() ... DONE
[09:29:18.713] Number of futures (= number of chunks): 2
[09:29:18.713] Launching 2 futures (chunks) ...
[09:29:18.713] Chunk #1 of 2 ...
[09:29:18.714]  - Finding globals in '...' for chunk #1 ...
[09:29:18.714] getGlobalsAndPackages() ...
[09:29:18.714] Searching for globals...
[09:29:18.714] 
[09:29:18.714] Searching for globals ... DONE
[09:29:18.714] - globals: [0] <none>
[09:29:18.714] getGlobalsAndPackages() ... DONE
[09:29:18.714]    + additional globals found: [n=0] 
[09:29:18.715]    + additional namespaces needed: [n=0] 
[09:29:18.715]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:18.715]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:18.715]  - seeds: <none>
[09:29:18.715]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.715] getGlobalsAndPackages() ...
[09:29:18.715] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.715] Resolving globals: FALSE
[09:29:18.716] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:18.716] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:18.716] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.716] 
[09:29:18.716] getGlobalsAndPackages() ... DONE
[09:29:18.717] run() for ‘Future’ ...
[09:29:18.717] - state: ‘created’
[09:29:18.717] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:18.730] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.731] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:18.731]   - Field: ‘node’
[09:29:18.731]   - Field: ‘label’
[09:29:18.731]   - Field: ‘local’
[09:29:18.731]   - Field: ‘owner’
[09:29:18.731]   - Field: ‘envir’
[09:29:18.731]   - Field: ‘workers’
[09:29:18.731]   - Field: ‘packages’
[09:29:18.731]   - Field: ‘gc’
[09:29:18.731]   - Field: ‘conditions’
[09:29:18.732]   - Field: ‘persistent’
[09:29:18.732]   - Field: ‘expr’
[09:29:18.732]   - Field: ‘uuid’
[09:29:18.732]   - Field: ‘seed’
[09:29:18.732]   - Field: ‘version’
[09:29:18.732]   - Field: ‘result’
[09:29:18.732]   - Field: ‘asynchronous’
[09:29:18.732]   - Field: ‘calls’
[09:29:18.732]   - Field: ‘globals’
[09:29:18.732]   - Field: ‘stdout’
[09:29:18.733]   - Field: ‘earlySignal’
[09:29:18.733]   - Field: ‘lazy’
[09:29:18.733]   - Field: ‘state’
[09:29:18.733] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:18.733] - Launch lazy future ...
[09:29:18.733] Packages needed by the future expression (n = 0): <none>
[09:29:18.733] Packages needed by future strategies (n = 0): <none>
[09:29:18.734] {
[09:29:18.734]     {
[09:29:18.734]         {
[09:29:18.734]             ...future.startTime <- base::Sys.time()
[09:29:18.734]             {
[09:29:18.734]                 {
[09:29:18.734]                   {
[09:29:18.734]                     {
[09:29:18.734]                       base::local({
[09:29:18.734]                         has_future <- base::requireNamespace("future", 
[09:29:18.734]                           quietly = TRUE)
[09:29:18.734]                         if (has_future) {
[09:29:18.734]                           ns <- base::getNamespace("future")
[09:29:18.734]                           version <- ns[[".package"]][["version"]]
[09:29:18.734]                           if (is.null(version)) 
[09:29:18.734]                             version <- utils::packageVersion("future")
[09:29:18.734]                         }
[09:29:18.734]                         else {
[09:29:18.734]                           version <- NULL
[09:29:18.734]                         }
[09:29:18.734]                         if (!has_future || version < "1.8.0") {
[09:29:18.734]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:18.734]                             "", base::R.version$version.string), 
[09:29:18.734]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:18.734]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:18.734]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:18.734]                               "release", "version")], collapse = " "), 
[09:29:18.734]                             hostname = base::Sys.info()[["nodename"]])
[09:29:18.734]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:18.734]                             info)
[09:29:18.734]                           info <- base::paste(info, collapse = "; ")
[09:29:18.734]                           if (!has_future) {
[09:29:18.734]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:18.734]                               info)
[09:29:18.734]                           }
[09:29:18.734]                           else {
[09:29:18.734]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:18.734]                               info, version)
[09:29:18.734]                           }
[09:29:18.734]                           base::stop(msg)
[09:29:18.734]                         }
[09:29:18.734]                       })
[09:29:18.734]                     }
[09:29:18.734]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:18.734]                     base::options(mc.cores = 1L)
[09:29:18.734]                   }
[09:29:18.734]                   ...future.strategy.old <- future::plan("list")
[09:29:18.734]                   options(future.plan = NULL)
[09:29:18.734]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.734]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:18.734]                 }
[09:29:18.734]                 ...future.workdir <- getwd()
[09:29:18.734]             }
[09:29:18.734]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:18.734]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:18.734]         }
[09:29:18.734]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:18.734]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:18.734]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:18.734]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:18.734]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:18.734]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:18.734]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:18.734]             base::names(...future.oldOptions))
[09:29:18.734]     }
[09:29:18.734]     if (FALSE) {
[09:29:18.734]     }
[09:29:18.734]     else {
[09:29:18.734]         if (TRUE) {
[09:29:18.734]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:18.734]                 open = "w")
[09:29:18.734]         }
[09:29:18.734]         else {
[09:29:18.734]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:18.734]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:18.734]         }
[09:29:18.734]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:18.734]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:18.734]             base::sink(type = "output", split = FALSE)
[09:29:18.734]             base::close(...future.stdout)
[09:29:18.734]         }, add = TRUE)
[09:29:18.734]     }
[09:29:18.734]     ...future.frame <- base::sys.nframe()
[09:29:18.734]     ...future.conditions <- base::list()
[09:29:18.734]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:18.734]     if (FALSE) {
[09:29:18.734]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:18.734]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:18.734]     }
[09:29:18.734]     ...future.result <- base::tryCatch({
[09:29:18.734]         base::withCallingHandlers({
[09:29:18.734]             ...future.value <- base::withVisible(base::local({
[09:29:18.734]                 ...future.makeSendCondition <- base::local({
[09:29:18.734]                   sendCondition <- NULL
[09:29:18.734]                   function(frame = 1L) {
[09:29:18.734]                     if (is.function(sendCondition)) 
[09:29:18.734]                       return(sendCondition)
[09:29:18.734]                     ns <- getNamespace("parallel")
[09:29:18.734]                     if (exists("sendData", mode = "function", 
[09:29:18.734]                       envir = ns)) {
[09:29:18.734]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:18.734]                         envir = ns)
[09:29:18.734]                       envir <- sys.frame(frame)
[09:29:18.734]                       master <- NULL
[09:29:18.734]                       while (!identical(envir, .GlobalEnv) && 
[09:29:18.734]                         !identical(envir, emptyenv())) {
[09:29:18.734]                         if (exists("master", mode = "list", envir = envir, 
[09:29:18.734]                           inherits = FALSE)) {
[09:29:18.734]                           master <- get("master", mode = "list", 
[09:29:18.734]                             envir = envir, inherits = FALSE)
[09:29:18.734]                           if (inherits(master, c("SOCKnode", 
[09:29:18.734]                             "SOCK0node"))) {
[09:29:18.734]                             sendCondition <<- function(cond) {
[09:29:18.734]                               data <- list(type = "VALUE", value = cond, 
[09:29:18.734]                                 success = TRUE)
[09:29:18.734]                               parallel_sendData(master, data)
[09:29:18.734]                             }
[09:29:18.734]                             return(sendCondition)
[09:29:18.734]                           }
[09:29:18.734]                         }
[09:29:18.734]                         frame <- frame + 1L
[09:29:18.734]                         envir <- sys.frame(frame)
[09:29:18.734]                       }
[09:29:18.734]                     }
[09:29:18.734]                     sendCondition <<- function(cond) NULL
[09:29:18.734]                   }
[09:29:18.734]                 })
[09:29:18.734]                 withCallingHandlers({
[09:29:18.734]                   {
[09:29:18.734]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.734]                     if (!identical(...future.globals.maxSize.org, 
[09:29:18.734]                       ...future.globals.maxSize)) {
[09:29:18.734]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.734]                       on.exit(options(oopts), add = TRUE)
[09:29:18.734]                     }
[09:29:18.734]                     {
[09:29:18.734]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.734]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:18.734]                         USE.NAMES = FALSE)
[09:29:18.734]                       do.call(mapply, args = args)
[09:29:18.734]                     }
[09:29:18.734]                   }
[09:29:18.734]                 }, immediateCondition = function(cond) {
[09:29:18.734]                   sendCondition <- ...future.makeSendCondition()
[09:29:18.734]                   sendCondition(cond)
[09:29:18.734]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.734]                   {
[09:29:18.734]                     inherits <- base::inherits
[09:29:18.734]                     invokeRestart <- base::invokeRestart
[09:29:18.734]                     is.null <- base::is.null
[09:29:18.734]                     muffled <- FALSE
[09:29:18.734]                     if (inherits(cond, "message")) {
[09:29:18.734]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:18.734]                       if (muffled) 
[09:29:18.734]                         invokeRestart("muffleMessage")
[09:29:18.734]                     }
[09:29:18.734]                     else if (inherits(cond, "warning")) {
[09:29:18.734]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:18.734]                       if (muffled) 
[09:29:18.734]                         invokeRestart("muffleWarning")
[09:29:18.734]                     }
[09:29:18.734]                     else if (inherits(cond, "condition")) {
[09:29:18.734]                       if (!is.null(pattern)) {
[09:29:18.734]                         computeRestarts <- base::computeRestarts
[09:29:18.734]                         grepl <- base::grepl
[09:29:18.734]                         restarts <- computeRestarts(cond)
[09:29:18.734]                         for (restart in restarts) {
[09:29:18.734]                           name <- restart$name
[09:29:18.734]                           if (is.null(name)) 
[09:29:18.734]                             next
[09:29:18.734]                           if (!grepl(pattern, name)) 
[09:29:18.734]                             next
[09:29:18.734]                           invokeRestart(restart)
[09:29:18.734]                           muffled <- TRUE
[09:29:18.734]                           break
[09:29:18.734]                         }
[09:29:18.734]                       }
[09:29:18.734]                     }
[09:29:18.734]                     invisible(muffled)
[09:29:18.734]                   }
[09:29:18.734]                   muffleCondition(cond)
[09:29:18.734]                 })
[09:29:18.734]             }))
[09:29:18.734]             future::FutureResult(value = ...future.value$value, 
[09:29:18.734]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.734]                   ...future.rng), globalenv = if (FALSE) 
[09:29:18.734]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:18.734]                     ...future.globalenv.names))
[09:29:18.734]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:18.734]         }, condition = base::local({
[09:29:18.734]             c <- base::c
[09:29:18.734]             inherits <- base::inherits
[09:29:18.734]             invokeRestart <- base::invokeRestart
[09:29:18.734]             length <- base::length
[09:29:18.734]             list <- base::list
[09:29:18.734]             seq.int <- base::seq.int
[09:29:18.734]             signalCondition <- base::signalCondition
[09:29:18.734]             sys.calls <- base::sys.calls
[09:29:18.734]             `[[` <- base::`[[`
[09:29:18.734]             `+` <- base::`+`
[09:29:18.734]             `<<-` <- base::`<<-`
[09:29:18.734]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:18.734]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:18.734]                   3L)]
[09:29:18.734]             }
[09:29:18.734]             function(cond) {
[09:29:18.734]                 is_error <- inherits(cond, "error")
[09:29:18.734]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:18.734]                   NULL)
[09:29:18.734]                 if (is_error) {
[09:29:18.734]                   sessionInformation <- function() {
[09:29:18.734]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:18.734]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:18.734]                       search = base::search(), system = base::Sys.info())
[09:29:18.734]                   }
[09:29:18.734]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.734]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:18.734]                     cond$call), session = sessionInformation(), 
[09:29:18.734]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:18.734]                   signalCondition(cond)
[09:29:18.734]                 }
[09:29:18.734]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:18.734]                 "immediateCondition"))) {
[09:29:18.734]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:18.734]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.734]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:18.734]                   if (TRUE && !signal) {
[09:29:18.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.734]                     {
[09:29:18.734]                       inherits <- base::inherits
[09:29:18.734]                       invokeRestart <- base::invokeRestart
[09:29:18.734]                       is.null <- base::is.null
[09:29:18.734]                       muffled <- FALSE
[09:29:18.734]                       if (inherits(cond, "message")) {
[09:29:18.734]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.734]                         if (muffled) 
[09:29:18.734]                           invokeRestart("muffleMessage")
[09:29:18.734]                       }
[09:29:18.734]                       else if (inherits(cond, "warning")) {
[09:29:18.734]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.734]                         if (muffled) 
[09:29:18.734]                           invokeRestart("muffleWarning")
[09:29:18.734]                       }
[09:29:18.734]                       else if (inherits(cond, "condition")) {
[09:29:18.734]                         if (!is.null(pattern)) {
[09:29:18.734]                           computeRestarts <- base::computeRestarts
[09:29:18.734]                           grepl <- base::grepl
[09:29:18.734]                           restarts <- computeRestarts(cond)
[09:29:18.734]                           for (restart in restarts) {
[09:29:18.734]                             name <- restart$name
[09:29:18.734]                             if (is.null(name)) 
[09:29:18.734]                               next
[09:29:18.734]                             if (!grepl(pattern, name)) 
[09:29:18.734]                               next
[09:29:18.734]                             invokeRestart(restart)
[09:29:18.734]                             muffled <- TRUE
[09:29:18.734]                             break
[09:29:18.734]                           }
[09:29:18.734]                         }
[09:29:18.734]                       }
[09:29:18.734]                       invisible(muffled)
[09:29:18.734]                     }
[09:29:18.734]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.734]                   }
[09:29:18.734]                 }
[09:29:18.734]                 else {
[09:29:18.734]                   if (TRUE) {
[09:29:18.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.734]                     {
[09:29:18.734]                       inherits <- base::inherits
[09:29:18.734]                       invokeRestart <- base::invokeRestart
[09:29:18.734]                       is.null <- base::is.null
[09:29:18.734]                       muffled <- FALSE
[09:29:18.734]                       if (inherits(cond, "message")) {
[09:29:18.734]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.734]                         if (muffled) 
[09:29:18.734]                           invokeRestart("muffleMessage")
[09:29:18.734]                       }
[09:29:18.734]                       else if (inherits(cond, "warning")) {
[09:29:18.734]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.734]                         if (muffled) 
[09:29:18.734]                           invokeRestart("muffleWarning")
[09:29:18.734]                       }
[09:29:18.734]                       else if (inherits(cond, "condition")) {
[09:29:18.734]                         if (!is.null(pattern)) {
[09:29:18.734]                           computeRestarts <- base::computeRestarts
[09:29:18.734]                           grepl <- base::grepl
[09:29:18.734]                           restarts <- computeRestarts(cond)
[09:29:18.734]                           for (restart in restarts) {
[09:29:18.734]                             name <- restart$name
[09:29:18.734]                             if (is.null(name)) 
[09:29:18.734]                               next
[09:29:18.734]                             if (!grepl(pattern, name)) 
[09:29:18.734]                               next
[09:29:18.734]                             invokeRestart(restart)
[09:29:18.734]                             muffled <- TRUE
[09:29:18.734]                             break
[09:29:18.734]                           }
[09:29:18.734]                         }
[09:29:18.734]                       }
[09:29:18.734]                       invisible(muffled)
[09:29:18.734]                     }
[09:29:18.734]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.734]                   }
[09:29:18.734]                 }
[09:29:18.734]             }
[09:29:18.734]         }))
[09:29:18.734]     }, error = function(ex) {
[09:29:18.734]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:18.734]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.734]                 ...future.rng), started = ...future.startTime, 
[09:29:18.734]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:18.734]             version = "1.8"), class = "FutureResult")
[09:29:18.734]     }, finally = {
[09:29:18.734]         if (!identical(...future.workdir, getwd())) 
[09:29:18.734]             setwd(...future.workdir)
[09:29:18.734]         {
[09:29:18.734]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:18.734]                 ...future.oldOptions$nwarnings <- NULL
[09:29:18.734]             }
[09:29:18.734]             base::options(...future.oldOptions)
[09:29:18.734]             if (.Platform$OS.type == "windows") {
[09:29:18.734]                 old_names <- names(...future.oldEnvVars)
[09:29:18.734]                 envs <- base::Sys.getenv()
[09:29:18.734]                 names <- names(envs)
[09:29:18.734]                 common <- intersect(names, old_names)
[09:29:18.734]                 added <- setdiff(names, old_names)
[09:29:18.734]                 removed <- setdiff(old_names, names)
[09:29:18.734]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:18.734]                   envs[common]]
[09:29:18.734]                 NAMES <- toupper(changed)
[09:29:18.734]                 args <- list()
[09:29:18.734]                 for (kk in seq_along(NAMES)) {
[09:29:18.734]                   name <- changed[[kk]]
[09:29:18.734]                   NAME <- NAMES[[kk]]
[09:29:18.734]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.734]                     next
[09:29:18.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.734]                 }
[09:29:18.734]                 NAMES <- toupper(added)
[09:29:18.734]                 for (kk in seq_along(NAMES)) {
[09:29:18.734]                   name <- added[[kk]]
[09:29:18.734]                   NAME <- NAMES[[kk]]
[09:29:18.734]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.734]                     next
[09:29:18.734]                   args[[name]] <- ""
[09:29:18.734]                 }
[09:29:18.734]                 NAMES <- toupper(removed)
[09:29:18.734]                 for (kk in seq_along(NAMES)) {
[09:29:18.734]                   name <- removed[[kk]]
[09:29:18.734]                   NAME <- NAMES[[kk]]
[09:29:18.734]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.734]                     next
[09:29:18.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.734]                 }
[09:29:18.734]                 if (length(args) > 0) 
[09:29:18.734]                   base::do.call(base::Sys.setenv, args = args)
[09:29:18.734]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:18.734]             }
[09:29:18.734]             else {
[09:29:18.734]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:18.734]             }
[09:29:18.734]             {
[09:29:18.734]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:18.734]                   0L) {
[09:29:18.734]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:18.734]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:18.734]                   base::options(opts)
[09:29:18.734]                 }
[09:29:18.734]                 {
[09:29:18.734]                   {
[09:29:18.734]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:18.734]                     NULL
[09:29:18.734]                   }
[09:29:18.734]                   options(future.plan = NULL)
[09:29:18.734]                   if (is.na(NA_character_)) 
[09:29:18.734]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.734]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:18.734]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:18.734]                     .init = FALSE)
[09:29:18.734]                 }
[09:29:18.734]             }
[09:29:18.734]         }
[09:29:18.734]     })
[09:29:18.734]     if (TRUE) {
[09:29:18.734]         base::sink(type = "output", split = FALSE)
[09:29:18.734]         if (TRUE) {
[09:29:18.734]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:18.734]         }
[09:29:18.734]         else {
[09:29:18.734]             ...future.result["stdout"] <- base::list(NULL)
[09:29:18.734]         }
[09:29:18.734]         base::close(...future.stdout)
[09:29:18.734]         ...future.stdout <- NULL
[09:29:18.734]     }
[09:29:18.734]     ...future.result$conditions <- ...future.conditions
[09:29:18.734]     ...future.result$finished <- base::Sys.time()
[09:29:18.734]     ...future.result
[09:29:18.734] }
[09:29:18.736] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[09:29:18.736] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[09:29:18.737] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[09:29:18.737] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:18.737] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:18.737] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[09:29:18.738] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[09:29:18.738] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:18.738] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:18.738] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:18.739] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:18.739] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[09:29:18.739] MultisessionFuture started
[09:29:18.739] - Launch lazy future ... done
[09:29:18.740] run() for ‘MultisessionFuture’ ... done
[09:29:18.740] Created future:
[09:29:18.740] MultisessionFuture:
[09:29:18.740] Label: ‘future_mapply-1’
[09:29:18.740] Expression:
[09:29:18.740] {
[09:29:18.740]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.740]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:18.740]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.740]         on.exit(options(oopts), add = TRUE)
[09:29:18.740]     }
[09:29:18.740]     {
[09:29:18.740]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.740]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:18.740]         do.call(mapply, args = args)
[09:29:18.740]     }
[09:29:18.740] }
[09:29:18.740] Lazy evaluation: FALSE
[09:29:18.740] Asynchronous evaluation: TRUE
[09:29:18.740] Local evaluation: TRUE
[09:29:18.740] Environment: R_GlobalEnv
[09:29:18.740] Capture standard output: TRUE
[09:29:18.740] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:18.740] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:18.740] Packages: <none>
[09:29:18.740] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:18.740] Resolved: FALSE
[09:29:18.740] Value: <not collected>
[09:29:18.740] Conditions captured: <none>
[09:29:18.740] Early signaling: FALSE
[09:29:18.740] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:18.740] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.751] Chunk #1 of 2 ... DONE
[09:29:18.751] Chunk #2 of 2 ...
[09:29:18.752]  - Finding globals in '...' for chunk #2 ...
[09:29:18.752] getGlobalsAndPackages() ...
[09:29:18.752] Searching for globals...
[09:29:18.752] 
[09:29:18.752] Searching for globals ... DONE
[09:29:18.752] - globals: [0] <none>
[09:29:18.752] getGlobalsAndPackages() ... DONE
[09:29:18.753]    + additional globals found: [n=0] 
[09:29:18.753]    + additional namespaces needed: [n=0] 
[09:29:18.753]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:18.753]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:18.753]  - seeds: <none>
[09:29:18.753]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.753] getGlobalsAndPackages() ...
[09:29:18.753] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.753] Resolving globals: FALSE
[09:29:18.754] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:18.754] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:18.756] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.756] 
[09:29:18.756] getGlobalsAndPackages() ... DONE
[09:29:18.757] run() for ‘Future’ ...
[09:29:18.757] - state: ‘created’
[09:29:18.757] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:18.771] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.771] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:18.771]   - Field: ‘node’
[09:29:18.771]   - Field: ‘label’
[09:29:18.771]   - Field: ‘local’
[09:29:18.771]   - Field: ‘owner’
[09:29:18.771]   - Field: ‘envir’
[09:29:18.772]   - Field: ‘workers’
[09:29:18.772]   - Field: ‘packages’
[09:29:18.772]   - Field: ‘gc’
[09:29:18.772]   - Field: ‘conditions’
[09:29:18.772]   - Field: ‘persistent’
[09:29:18.772]   - Field: ‘expr’
[09:29:18.772]   - Field: ‘uuid’
[09:29:18.772]   - Field: ‘seed’
[09:29:18.772]   - Field: ‘version’
[09:29:18.772]   - Field: ‘result’
[09:29:18.772]   - Field: ‘asynchronous’
[09:29:18.773]   - Field: ‘calls’
[09:29:18.773]   - Field: ‘globals’
[09:29:18.773]   - Field: ‘stdout’
[09:29:18.773]   - Field: ‘earlySignal’
[09:29:18.773]   - Field: ‘lazy’
[09:29:18.773]   - Field: ‘state’
[09:29:18.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:18.773] - Launch lazy future ...
[09:29:18.773] Packages needed by the future expression (n = 0): <none>
[09:29:18.774] Packages needed by future strategies (n = 0): <none>
[09:29:18.774] {
[09:29:18.774]     {
[09:29:18.774]         {
[09:29:18.774]             ...future.startTime <- base::Sys.time()
[09:29:18.774]             {
[09:29:18.774]                 {
[09:29:18.774]                   {
[09:29:18.774]                     {
[09:29:18.774]                       base::local({
[09:29:18.774]                         has_future <- base::requireNamespace("future", 
[09:29:18.774]                           quietly = TRUE)
[09:29:18.774]                         if (has_future) {
[09:29:18.774]                           ns <- base::getNamespace("future")
[09:29:18.774]                           version <- ns[[".package"]][["version"]]
[09:29:18.774]                           if (is.null(version)) 
[09:29:18.774]                             version <- utils::packageVersion("future")
[09:29:18.774]                         }
[09:29:18.774]                         else {
[09:29:18.774]                           version <- NULL
[09:29:18.774]                         }
[09:29:18.774]                         if (!has_future || version < "1.8.0") {
[09:29:18.774]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:18.774]                             "", base::R.version$version.string), 
[09:29:18.774]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:18.774]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:18.774]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:18.774]                               "release", "version")], collapse = " "), 
[09:29:18.774]                             hostname = base::Sys.info()[["nodename"]])
[09:29:18.774]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:18.774]                             info)
[09:29:18.774]                           info <- base::paste(info, collapse = "; ")
[09:29:18.774]                           if (!has_future) {
[09:29:18.774]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:18.774]                               info)
[09:29:18.774]                           }
[09:29:18.774]                           else {
[09:29:18.774]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:18.774]                               info, version)
[09:29:18.774]                           }
[09:29:18.774]                           base::stop(msg)
[09:29:18.774]                         }
[09:29:18.774]                       })
[09:29:18.774]                     }
[09:29:18.774]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:18.774]                     base::options(mc.cores = 1L)
[09:29:18.774]                   }
[09:29:18.774]                   ...future.strategy.old <- future::plan("list")
[09:29:18.774]                   options(future.plan = NULL)
[09:29:18.774]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.774]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:18.774]                 }
[09:29:18.774]                 ...future.workdir <- getwd()
[09:29:18.774]             }
[09:29:18.774]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:18.774]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:18.774]         }
[09:29:18.774]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:18.774]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:18.774]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:18.774]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:18.774]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:18.774]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:18.774]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:18.774]             base::names(...future.oldOptions))
[09:29:18.774]     }
[09:29:18.774]     if (FALSE) {
[09:29:18.774]     }
[09:29:18.774]     else {
[09:29:18.774]         if (TRUE) {
[09:29:18.774]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:18.774]                 open = "w")
[09:29:18.774]         }
[09:29:18.774]         else {
[09:29:18.774]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:18.774]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:18.774]         }
[09:29:18.774]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:18.774]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:18.774]             base::sink(type = "output", split = FALSE)
[09:29:18.774]             base::close(...future.stdout)
[09:29:18.774]         }, add = TRUE)
[09:29:18.774]     }
[09:29:18.774]     ...future.frame <- base::sys.nframe()
[09:29:18.774]     ...future.conditions <- base::list()
[09:29:18.774]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:18.774]     if (FALSE) {
[09:29:18.774]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:18.774]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:18.774]     }
[09:29:18.774]     ...future.result <- base::tryCatch({
[09:29:18.774]         base::withCallingHandlers({
[09:29:18.774]             ...future.value <- base::withVisible(base::local({
[09:29:18.774]                 ...future.makeSendCondition <- base::local({
[09:29:18.774]                   sendCondition <- NULL
[09:29:18.774]                   function(frame = 1L) {
[09:29:18.774]                     if (is.function(sendCondition)) 
[09:29:18.774]                       return(sendCondition)
[09:29:18.774]                     ns <- getNamespace("parallel")
[09:29:18.774]                     if (exists("sendData", mode = "function", 
[09:29:18.774]                       envir = ns)) {
[09:29:18.774]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:18.774]                         envir = ns)
[09:29:18.774]                       envir <- sys.frame(frame)
[09:29:18.774]                       master <- NULL
[09:29:18.774]                       while (!identical(envir, .GlobalEnv) && 
[09:29:18.774]                         !identical(envir, emptyenv())) {
[09:29:18.774]                         if (exists("master", mode = "list", envir = envir, 
[09:29:18.774]                           inherits = FALSE)) {
[09:29:18.774]                           master <- get("master", mode = "list", 
[09:29:18.774]                             envir = envir, inherits = FALSE)
[09:29:18.774]                           if (inherits(master, c("SOCKnode", 
[09:29:18.774]                             "SOCK0node"))) {
[09:29:18.774]                             sendCondition <<- function(cond) {
[09:29:18.774]                               data <- list(type = "VALUE", value = cond, 
[09:29:18.774]                                 success = TRUE)
[09:29:18.774]                               parallel_sendData(master, data)
[09:29:18.774]                             }
[09:29:18.774]                             return(sendCondition)
[09:29:18.774]                           }
[09:29:18.774]                         }
[09:29:18.774]                         frame <- frame + 1L
[09:29:18.774]                         envir <- sys.frame(frame)
[09:29:18.774]                       }
[09:29:18.774]                     }
[09:29:18.774]                     sendCondition <<- function(cond) NULL
[09:29:18.774]                   }
[09:29:18.774]                 })
[09:29:18.774]                 withCallingHandlers({
[09:29:18.774]                   {
[09:29:18.774]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.774]                     if (!identical(...future.globals.maxSize.org, 
[09:29:18.774]                       ...future.globals.maxSize)) {
[09:29:18.774]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.774]                       on.exit(options(oopts), add = TRUE)
[09:29:18.774]                     }
[09:29:18.774]                     {
[09:29:18.774]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.774]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:18.774]                         USE.NAMES = FALSE)
[09:29:18.774]                       do.call(mapply, args = args)
[09:29:18.774]                     }
[09:29:18.774]                   }
[09:29:18.774]                 }, immediateCondition = function(cond) {
[09:29:18.774]                   sendCondition <- ...future.makeSendCondition()
[09:29:18.774]                   sendCondition(cond)
[09:29:18.774]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.774]                   {
[09:29:18.774]                     inherits <- base::inherits
[09:29:18.774]                     invokeRestart <- base::invokeRestart
[09:29:18.774]                     is.null <- base::is.null
[09:29:18.774]                     muffled <- FALSE
[09:29:18.774]                     if (inherits(cond, "message")) {
[09:29:18.774]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:18.774]                       if (muffled) 
[09:29:18.774]                         invokeRestart("muffleMessage")
[09:29:18.774]                     }
[09:29:18.774]                     else if (inherits(cond, "warning")) {
[09:29:18.774]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:18.774]                       if (muffled) 
[09:29:18.774]                         invokeRestart("muffleWarning")
[09:29:18.774]                     }
[09:29:18.774]                     else if (inherits(cond, "condition")) {
[09:29:18.774]                       if (!is.null(pattern)) {
[09:29:18.774]                         computeRestarts <- base::computeRestarts
[09:29:18.774]                         grepl <- base::grepl
[09:29:18.774]                         restarts <- computeRestarts(cond)
[09:29:18.774]                         for (restart in restarts) {
[09:29:18.774]                           name <- restart$name
[09:29:18.774]                           if (is.null(name)) 
[09:29:18.774]                             next
[09:29:18.774]                           if (!grepl(pattern, name)) 
[09:29:18.774]                             next
[09:29:18.774]                           invokeRestart(restart)
[09:29:18.774]                           muffled <- TRUE
[09:29:18.774]                           break
[09:29:18.774]                         }
[09:29:18.774]                       }
[09:29:18.774]                     }
[09:29:18.774]                     invisible(muffled)
[09:29:18.774]                   }
[09:29:18.774]                   muffleCondition(cond)
[09:29:18.774]                 })
[09:29:18.774]             }))
[09:29:18.774]             future::FutureResult(value = ...future.value$value, 
[09:29:18.774]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.774]                   ...future.rng), globalenv = if (FALSE) 
[09:29:18.774]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:18.774]                     ...future.globalenv.names))
[09:29:18.774]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:18.774]         }, condition = base::local({
[09:29:18.774]             c <- base::c
[09:29:18.774]             inherits <- base::inherits
[09:29:18.774]             invokeRestart <- base::invokeRestart
[09:29:18.774]             length <- base::length
[09:29:18.774]             list <- base::list
[09:29:18.774]             seq.int <- base::seq.int
[09:29:18.774]             signalCondition <- base::signalCondition
[09:29:18.774]             sys.calls <- base::sys.calls
[09:29:18.774]             `[[` <- base::`[[`
[09:29:18.774]             `+` <- base::`+`
[09:29:18.774]             `<<-` <- base::`<<-`
[09:29:18.774]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:18.774]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:18.774]                   3L)]
[09:29:18.774]             }
[09:29:18.774]             function(cond) {
[09:29:18.774]                 is_error <- inherits(cond, "error")
[09:29:18.774]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:18.774]                   NULL)
[09:29:18.774]                 if (is_error) {
[09:29:18.774]                   sessionInformation <- function() {
[09:29:18.774]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:18.774]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:18.774]                       search = base::search(), system = base::Sys.info())
[09:29:18.774]                   }
[09:29:18.774]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.774]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:18.774]                     cond$call), session = sessionInformation(), 
[09:29:18.774]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:18.774]                   signalCondition(cond)
[09:29:18.774]                 }
[09:29:18.774]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:18.774]                 "immediateCondition"))) {
[09:29:18.774]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:18.774]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.774]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:18.774]                   if (TRUE && !signal) {
[09:29:18.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.774]                     {
[09:29:18.774]                       inherits <- base::inherits
[09:29:18.774]                       invokeRestart <- base::invokeRestart
[09:29:18.774]                       is.null <- base::is.null
[09:29:18.774]                       muffled <- FALSE
[09:29:18.774]                       if (inherits(cond, "message")) {
[09:29:18.774]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.774]                         if (muffled) 
[09:29:18.774]                           invokeRestart("muffleMessage")
[09:29:18.774]                       }
[09:29:18.774]                       else if (inherits(cond, "warning")) {
[09:29:18.774]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.774]                         if (muffled) 
[09:29:18.774]                           invokeRestart("muffleWarning")
[09:29:18.774]                       }
[09:29:18.774]                       else if (inherits(cond, "condition")) {
[09:29:18.774]                         if (!is.null(pattern)) {
[09:29:18.774]                           computeRestarts <- base::computeRestarts
[09:29:18.774]                           grepl <- base::grepl
[09:29:18.774]                           restarts <- computeRestarts(cond)
[09:29:18.774]                           for (restart in restarts) {
[09:29:18.774]                             name <- restart$name
[09:29:18.774]                             if (is.null(name)) 
[09:29:18.774]                               next
[09:29:18.774]                             if (!grepl(pattern, name)) 
[09:29:18.774]                               next
[09:29:18.774]                             invokeRestart(restart)
[09:29:18.774]                             muffled <- TRUE
[09:29:18.774]                             break
[09:29:18.774]                           }
[09:29:18.774]                         }
[09:29:18.774]                       }
[09:29:18.774]                       invisible(muffled)
[09:29:18.774]                     }
[09:29:18.774]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.774]                   }
[09:29:18.774]                 }
[09:29:18.774]                 else {
[09:29:18.774]                   if (TRUE) {
[09:29:18.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.774]                     {
[09:29:18.774]                       inherits <- base::inherits
[09:29:18.774]                       invokeRestart <- base::invokeRestart
[09:29:18.774]                       is.null <- base::is.null
[09:29:18.774]                       muffled <- FALSE
[09:29:18.774]                       if (inherits(cond, "message")) {
[09:29:18.774]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.774]                         if (muffled) 
[09:29:18.774]                           invokeRestart("muffleMessage")
[09:29:18.774]                       }
[09:29:18.774]                       else if (inherits(cond, "warning")) {
[09:29:18.774]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.774]                         if (muffled) 
[09:29:18.774]                           invokeRestart("muffleWarning")
[09:29:18.774]                       }
[09:29:18.774]                       else if (inherits(cond, "condition")) {
[09:29:18.774]                         if (!is.null(pattern)) {
[09:29:18.774]                           computeRestarts <- base::computeRestarts
[09:29:18.774]                           grepl <- base::grepl
[09:29:18.774]                           restarts <- computeRestarts(cond)
[09:29:18.774]                           for (restart in restarts) {
[09:29:18.774]                             name <- restart$name
[09:29:18.774]                             if (is.null(name)) 
[09:29:18.774]                               next
[09:29:18.774]                             if (!grepl(pattern, name)) 
[09:29:18.774]                               next
[09:29:18.774]                             invokeRestart(restart)
[09:29:18.774]                             muffled <- TRUE
[09:29:18.774]                             break
[09:29:18.774]                           }
[09:29:18.774]                         }
[09:29:18.774]                       }
[09:29:18.774]                       invisible(muffled)
[09:29:18.774]                     }
[09:29:18.774]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.774]                   }
[09:29:18.774]                 }
[09:29:18.774]             }
[09:29:18.774]         }))
[09:29:18.774]     }, error = function(ex) {
[09:29:18.774]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:18.774]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.774]                 ...future.rng), started = ...future.startTime, 
[09:29:18.774]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:18.774]             version = "1.8"), class = "FutureResult")
[09:29:18.774]     }, finally = {
[09:29:18.774]         if (!identical(...future.workdir, getwd())) 
[09:29:18.774]             setwd(...future.workdir)
[09:29:18.774]         {
[09:29:18.774]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:18.774]                 ...future.oldOptions$nwarnings <- NULL
[09:29:18.774]             }
[09:29:18.774]             base::options(...future.oldOptions)
[09:29:18.774]             if (.Platform$OS.type == "windows") {
[09:29:18.774]                 old_names <- names(...future.oldEnvVars)
[09:29:18.774]                 envs <- base::Sys.getenv()
[09:29:18.774]                 names <- names(envs)
[09:29:18.774]                 common <- intersect(names, old_names)
[09:29:18.774]                 added <- setdiff(names, old_names)
[09:29:18.774]                 removed <- setdiff(old_names, names)
[09:29:18.774]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:18.774]                   envs[common]]
[09:29:18.774]                 NAMES <- toupper(changed)
[09:29:18.774]                 args <- list()
[09:29:18.774]                 for (kk in seq_along(NAMES)) {
[09:29:18.774]                   name <- changed[[kk]]
[09:29:18.774]                   NAME <- NAMES[[kk]]
[09:29:18.774]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.774]                     next
[09:29:18.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.774]                 }
[09:29:18.774]                 NAMES <- toupper(added)
[09:29:18.774]                 for (kk in seq_along(NAMES)) {
[09:29:18.774]                   name <- added[[kk]]
[09:29:18.774]                   NAME <- NAMES[[kk]]
[09:29:18.774]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.774]                     next
[09:29:18.774]                   args[[name]] <- ""
[09:29:18.774]                 }
[09:29:18.774]                 NAMES <- toupper(removed)
[09:29:18.774]                 for (kk in seq_along(NAMES)) {
[09:29:18.774]                   name <- removed[[kk]]
[09:29:18.774]                   NAME <- NAMES[[kk]]
[09:29:18.774]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.774]                     next
[09:29:18.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.774]                 }
[09:29:18.774]                 if (length(args) > 0) 
[09:29:18.774]                   base::do.call(base::Sys.setenv, args = args)
[09:29:18.774]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:18.774]             }
[09:29:18.774]             else {
[09:29:18.774]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:18.774]             }
[09:29:18.774]             {
[09:29:18.774]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:18.774]                   0L) {
[09:29:18.774]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:18.774]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:18.774]                   base::options(opts)
[09:29:18.774]                 }
[09:29:18.774]                 {
[09:29:18.774]                   {
[09:29:18.774]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:18.774]                     NULL
[09:29:18.774]                   }
[09:29:18.774]                   options(future.plan = NULL)
[09:29:18.774]                   if (is.na(NA_character_)) 
[09:29:18.774]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.774]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:18.774]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:18.774]                     .init = FALSE)
[09:29:18.774]                 }
[09:29:18.774]             }
[09:29:18.774]         }
[09:29:18.774]     })
[09:29:18.774]     if (TRUE) {
[09:29:18.774]         base::sink(type = "output", split = FALSE)
[09:29:18.774]         if (TRUE) {
[09:29:18.774]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:18.774]         }
[09:29:18.774]         else {
[09:29:18.774]             ...future.result["stdout"] <- base::list(NULL)
[09:29:18.774]         }
[09:29:18.774]         base::close(...future.stdout)
[09:29:18.774]         ...future.stdout <- NULL
[09:29:18.774]     }
[09:29:18.774]     ...future.result$conditions <- ...future.conditions
[09:29:18.774]     ...future.result$finished <- base::Sys.time()
[09:29:18.774]     ...future.result
[09:29:18.774] }
[09:29:18.776] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[09:29:18.777] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[09:29:18.777] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[09:29:18.777] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:18.781] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:18.781] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[09:29:18.781] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[09:29:18.782] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:18.782] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:18.782] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:18.782] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:18.782] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[09:29:18.783] MultisessionFuture started
[09:29:18.783] - Launch lazy future ... done
[09:29:18.783] run() for ‘MultisessionFuture’ ... done
[09:29:18.783] Created future:
[09:29:18.783] MultisessionFuture:
[09:29:18.783] Label: ‘future_mapply-2’
[09:29:18.783] Expression:
[09:29:18.783] {
[09:29:18.783]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.783]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:18.783]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.783]         on.exit(options(oopts), add = TRUE)
[09:29:18.783]     }
[09:29:18.783]     {
[09:29:18.783]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.783]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:18.783]         do.call(mapply, args = args)
[09:29:18.783]     }
[09:29:18.783] }
[09:29:18.783] Lazy evaluation: FALSE
[09:29:18.783] Asynchronous evaluation: TRUE
[09:29:18.783] Local evaluation: TRUE
[09:29:18.783] Environment: R_GlobalEnv
[09:29:18.783] Capture standard output: TRUE
[09:29:18.783] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:18.783] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:18.783] Packages: <none>
[09:29:18.783] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:18.783] Resolved: FALSE
[09:29:18.783] Value: <not collected>
[09:29:18.783] Conditions captured: <none>
[09:29:18.783] Early signaling: FALSE
[09:29:18.783] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:18.783] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.795] Chunk #2 of 2 ... DONE
[09:29:18.795] Launching 2 futures (chunks) ... DONE
[09:29:18.795] Resolving 2 futures (chunks) ...
[09:29:18.795] resolve() on list ...
[09:29:18.795]  recursive: 0
[09:29:18.795]  length: 2
[09:29:18.795] 
[09:29:18.796] receiveMessageFromWorker() for ClusterFuture ...
[09:29:18.796] - Validating connection of MultisessionFuture
[09:29:18.796] - received message: FutureResult
[09:29:18.796] - Received FutureResult
[09:29:18.796] - Erased future from FutureRegistry
[09:29:18.796] result() for ClusterFuture ...
[09:29:18.796] - result already collected: FutureResult
[09:29:18.797] result() for ClusterFuture ... done
[09:29:18.797] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:18.797] Future #1
[09:29:18.797] result() for ClusterFuture ...
[09:29:18.797] - result already collected: FutureResult
[09:29:18.797] result() for ClusterFuture ... done
[09:29:18.797] result() for ClusterFuture ...
[09:29:18.797] - result already collected: FutureResult
[09:29:18.797] result() for ClusterFuture ... done
[09:29:18.797] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:18.797] - nx: 2
[09:29:18.797] - relay: TRUE
[09:29:18.798] - stdout: TRUE
[09:29:18.798] - signal: TRUE
[09:29:18.798] - resignal: FALSE
[09:29:18.798] - force: TRUE
[09:29:18.798] - relayed: [n=2] FALSE, FALSE
[09:29:18.798] - queued futures: [n=2] FALSE, FALSE
[09:29:18.798]  - until=1
[09:29:18.798]  - relaying element #1
[09:29:18.798] result() for ClusterFuture ...
[09:29:18.798] - result already collected: FutureResult
[09:29:18.798] result() for ClusterFuture ... done
[09:29:18.798] result() for ClusterFuture ...
[09:29:18.799] - result already collected: FutureResult
[09:29:18.799] result() for ClusterFuture ... done
[09:29:18.799] result() for ClusterFuture ...
[09:29:18.799] - result already collected: FutureResult
[09:29:18.799] result() for ClusterFuture ... done
[09:29:18.799] result() for ClusterFuture ...
[09:29:18.799] - result already collected: FutureResult
[09:29:18.799] result() for ClusterFuture ... done
[09:29:18.799] - relayed: [n=2] TRUE, FALSE
[09:29:18.799] - queued futures: [n=2] TRUE, FALSE
[09:29:18.799] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:18.800]  length: 1 (resolved future 1)
[09:29:18.825] receiveMessageFromWorker() for ClusterFuture ...
[09:29:18.825] - Validating connection of MultisessionFuture
[09:29:18.825] - received message: FutureResult
[09:29:18.826] - Received FutureResult
[09:29:18.826] - Erased future from FutureRegistry
[09:29:18.826] result() for ClusterFuture ...
[09:29:18.826] - result already collected: FutureResult
[09:29:18.826] result() for ClusterFuture ... done
[09:29:18.826] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:18.826] Future #2
[09:29:18.826] result() for ClusterFuture ...
[09:29:18.826] - result already collected: FutureResult
[09:29:18.826] result() for ClusterFuture ... done
[09:29:18.826] result() for ClusterFuture ...
[09:29:18.826] - result already collected: FutureResult
[09:29:18.827] result() for ClusterFuture ... done
[09:29:18.827] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:18.827] - nx: 2
[09:29:18.827] - relay: TRUE
[09:29:18.827] - stdout: TRUE
[09:29:18.827] - signal: TRUE
[09:29:18.827] - resignal: FALSE
[09:29:18.827] - force: TRUE
[09:29:18.827] - relayed: [n=2] TRUE, FALSE
[09:29:18.827] - queued futures: [n=2] TRUE, FALSE
[09:29:18.827]  - until=2
[09:29:18.827]  - relaying element #2
[09:29:18.828] result() for ClusterFuture ...
[09:29:18.828] - result already collected: FutureResult
[09:29:18.828] result() for ClusterFuture ... done
[09:29:18.828] result() for ClusterFuture ...
[09:29:18.828] - result already collected: FutureResult
[09:29:18.828] result() for ClusterFuture ... done
[09:29:18.828] result() for ClusterFuture ...
[09:29:18.828] - result already collected: FutureResult
[09:29:18.828] result() for ClusterFuture ... done
[09:29:18.828] result() for ClusterFuture ...
[09:29:18.828] - result already collected: FutureResult
[09:29:18.829] result() for ClusterFuture ... done
[09:29:18.829] - relayed: [n=2] TRUE, TRUE
[09:29:18.829] - queued futures: [n=2] TRUE, TRUE
[09:29:18.829] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:18.829]  length: 0 (resolved future 2)
[09:29:18.829] Relaying remaining futures
[09:29:18.829] signalConditionsASAP(NULL, pos=0) ...
[09:29:18.829] - nx: 2
[09:29:18.829] - relay: TRUE
[09:29:18.829] - stdout: TRUE
[09:29:18.829] - signal: TRUE
[09:29:18.829] - resignal: FALSE
[09:29:18.830] - force: TRUE
[09:29:18.830] - relayed: [n=2] TRUE, TRUE
[09:29:18.830] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:18.830] - relayed: [n=2] TRUE, TRUE
[09:29:18.830] - queued futures: [n=2] TRUE, TRUE
[09:29:18.830] signalConditionsASAP(NULL, pos=0) ... done
[09:29:18.830] resolve() on list ... DONE
[09:29:18.830] result() for ClusterFuture ...
[09:29:18.830] - result already collected: FutureResult
[09:29:18.830] result() for ClusterFuture ... done
[09:29:18.830] result() for ClusterFuture ...
[09:29:18.831] - result already collected: FutureResult
[09:29:18.831] result() for ClusterFuture ... done
[09:29:18.831] result() for ClusterFuture ...
[09:29:18.831] - result already collected: FutureResult
[09:29:18.831] result() for ClusterFuture ... done
[09:29:18.831] result() for ClusterFuture ...
[09:29:18.831] - result already collected: FutureResult
[09:29:18.831] result() for ClusterFuture ... done
[09:29:18.831]  - Number of value chunks collected: 2
[09:29:18.831] Resolving 2 futures (chunks) ... DONE
[09:29:18.831] Reducing values from 2 chunks ...
[09:29:18.832]  - Number of values collected after concatenation: 4
[09:29:18.832]  - Number of values expected: 4
[09:29:18.832] Reducing values from 2 chunks ... DONE
[09:29:18.832] future_mapply() ... DONE
[09:29:18.832] future_mapply() ...
[09:29:18.835] Number of chunks: 2
[09:29:18.835] getGlobalsAndPackagesXApply() ...
[09:29:18.836]  - future.globals: TRUE
[09:29:18.836] getGlobalsAndPackages() ...
[09:29:18.836] Searching for globals...
[09:29:18.836] - globals found: [1] ‘FUN’
[09:29:18.836] Searching for globals ... DONE
[09:29:18.837] Resolving globals: FALSE
[09:29:18.837] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:18.837] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:18.837] - globals: [1] ‘FUN’
[09:29:18.837] 
[09:29:18.837] getGlobalsAndPackages() ... DONE
[09:29:18.838]  - globals found/used: [n=1] ‘FUN’
[09:29:18.838]  - needed namespaces: [n=0] 
[09:29:18.838] Finding globals ... DONE
[09:29:18.838] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:18.838] List of 2
[09:29:18.838]  $ ...future.FUN:function (x, ...)  
[09:29:18.838]  $ MoreArgs     :List of 1
[09:29:18.838]   ..$ x: num 42
[09:29:18.838]  - attr(*, "where")=List of 2
[09:29:18.838]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:18.838]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:18.838]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:18.838]  - attr(*, "resolved")= logi FALSE
[09:29:18.838]  - attr(*, "total_size")= num NA
[09:29:18.841] Packages to be attached in all futures: [n=0] 
[09:29:18.841] getGlobalsAndPackagesXApply() ... DONE
[09:29:18.841] Number of futures (= number of chunks): 2
[09:29:18.841] Launching 2 futures (chunks) ...
[09:29:18.841] Chunk #1 of 2 ...
[09:29:18.841]  - Finding globals in '...' for chunk #1 ...
[09:29:18.841] getGlobalsAndPackages() ...
[09:29:18.842] Searching for globals...
[09:29:18.842] 
[09:29:18.842] Searching for globals ... DONE
[09:29:18.842] - globals: [0] <none>
[09:29:18.842] getGlobalsAndPackages() ... DONE
[09:29:18.842]    + additional globals found: [n=0] 
[09:29:18.842]    + additional namespaces needed: [n=0] 
[09:29:18.842]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:18.842]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:18.842]  - seeds: <none>
[09:29:18.843]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.843] getGlobalsAndPackages() ...
[09:29:18.843] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.843] Resolving globals: FALSE
[09:29:18.843] The total size of the 5 globals is 224 bytes (224 bytes)
[09:29:18.844] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[09:29:18.844] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.844] 
[09:29:18.844] getGlobalsAndPackages() ... DONE
[09:29:18.844] run() for ‘Future’ ...
[09:29:18.844] - state: ‘created’
[09:29:18.845] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:18.858] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.858] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:18.858]   - Field: ‘node’
[09:29:18.858]   - Field: ‘label’
[09:29:18.859]   - Field: ‘local’
[09:29:18.859]   - Field: ‘owner’
[09:29:18.859]   - Field: ‘envir’
[09:29:18.859]   - Field: ‘workers’
[09:29:18.859]   - Field: ‘packages’
[09:29:18.859]   - Field: ‘gc’
[09:29:18.859]   - Field: ‘conditions’
[09:29:18.859]   - Field: ‘persistent’
[09:29:18.859]   - Field: ‘expr’
[09:29:18.859]   - Field: ‘uuid’
[09:29:18.859]   - Field: ‘seed’
[09:29:18.859]   - Field: ‘version’
[09:29:18.860]   - Field: ‘result’
[09:29:18.860]   - Field: ‘asynchronous’
[09:29:18.860]   - Field: ‘calls’
[09:29:18.860]   - Field: ‘globals’
[09:29:18.860]   - Field: ‘stdout’
[09:29:18.860]   - Field: ‘earlySignal’
[09:29:18.860]   - Field: ‘lazy’
[09:29:18.860]   - Field: ‘state’
[09:29:18.860] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:18.860] - Launch lazy future ...
[09:29:18.861] Packages needed by the future expression (n = 0): <none>
[09:29:18.861] Packages needed by future strategies (n = 0): <none>
[09:29:18.861] {
[09:29:18.861]     {
[09:29:18.861]         {
[09:29:18.861]             ...future.startTime <- base::Sys.time()
[09:29:18.861]             {
[09:29:18.861]                 {
[09:29:18.861]                   {
[09:29:18.861]                     {
[09:29:18.861]                       base::local({
[09:29:18.861]                         has_future <- base::requireNamespace("future", 
[09:29:18.861]                           quietly = TRUE)
[09:29:18.861]                         if (has_future) {
[09:29:18.861]                           ns <- base::getNamespace("future")
[09:29:18.861]                           version <- ns[[".package"]][["version"]]
[09:29:18.861]                           if (is.null(version)) 
[09:29:18.861]                             version <- utils::packageVersion("future")
[09:29:18.861]                         }
[09:29:18.861]                         else {
[09:29:18.861]                           version <- NULL
[09:29:18.861]                         }
[09:29:18.861]                         if (!has_future || version < "1.8.0") {
[09:29:18.861]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:18.861]                             "", base::R.version$version.string), 
[09:29:18.861]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:18.861]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:18.861]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:18.861]                               "release", "version")], collapse = " "), 
[09:29:18.861]                             hostname = base::Sys.info()[["nodename"]])
[09:29:18.861]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:18.861]                             info)
[09:29:18.861]                           info <- base::paste(info, collapse = "; ")
[09:29:18.861]                           if (!has_future) {
[09:29:18.861]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:18.861]                               info)
[09:29:18.861]                           }
[09:29:18.861]                           else {
[09:29:18.861]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:18.861]                               info, version)
[09:29:18.861]                           }
[09:29:18.861]                           base::stop(msg)
[09:29:18.861]                         }
[09:29:18.861]                       })
[09:29:18.861]                     }
[09:29:18.861]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:18.861]                     base::options(mc.cores = 1L)
[09:29:18.861]                   }
[09:29:18.861]                   ...future.strategy.old <- future::plan("list")
[09:29:18.861]                   options(future.plan = NULL)
[09:29:18.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:18.861]                 }
[09:29:18.861]                 ...future.workdir <- getwd()
[09:29:18.861]             }
[09:29:18.861]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:18.861]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:18.861]         }
[09:29:18.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:18.861]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:18.861]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:18.861]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:18.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:18.861]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:18.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:18.861]             base::names(...future.oldOptions))
[09:29:18.861]     }
[09:29:18.861]     if (FALSE) {
[09:29:18.861]     }
[09:29:18.861]     else {
[09:29:18.861]         if (TRUE) {
[09:29:18.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:18.861]                 open = "w")
[09:29:18.861]         }
[09:29:18.861]         else {
[09:29:18.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:18.861]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:18.861]         }
[09:29:18.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:18.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:18.861]             base::sink(type = "output", split = FALSE)
[09:29:18.861]             base::close(...future.stdout)
[09:29:18.861]         }, add = TRUE)
[09:29:18.861]     }
[09:29:18.861]     ...future.frame <- base::sys.nframe()
[09:29:18.861]     ...future.conditions <- base::list()
[09:29:18.861]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:18.861]     if (FALSE) {
[09:29:18.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:18.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:18.861]     }
[09:29:18.861]     ...future.result <- base::tryCatch({
[09:29:18.861]         base::withCallingHandlers({
[09:29:18.861]             ...future.value <- base::withVisible(base::local({
[09:29:18.861]                 ...future.makeSendCondition <- base::local({
[09:29:18.861]                   sendCondition <- NULL
[09:29:18.861]                   function(frame = 1L) {
[09:29:18.861]                     if (is.function(sendCondition)) 
[09:29:18.861]                       return(sendCondition)
[09:29:18.861]                     ns <- getNamespace("parallel")
[09:29:18.861]                     if (exists("sendData", mode = "function", 
[09:29:18.861]                       envir = ns)) {
[09:29:18.861]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:18.861]                         envir = ns)
[09:29:18.861]                       envir <- sys.frame(frame)
[09:29:18.861]                       master <- NULL
[09:29:18.861]                       while (!identical(envir, .GlobalEnv) && 
[09:29:18.861]                         !identical(envir, emptyenv())) {
[09:29:18.861]                         if (exists("master", mode = "list", envir = envir, 
[09:29:18.861]                           inherits = FALSE)) {
[09:29:18.861]                           master <- get("master", mode = "list", 
[09:29:18.861]                             envir = envir, inherits = FALSE)
[09:29:18.861]                           if (inherits(master, c("SOCKnode", 
[09:29:18.861]                             "SOCK0node"))) {
[09:29:18.861]                             sendCondition <<- function(cond) {
[09:29:18.861]                               data <- list(type = "VALUE", value = cond, 
[09:29:18.861]                                 success = TRUE)
[09:29:18.861]                               parallel_sendData(master, data)
[09:29:18.861]                             }
[09:29:18.861]                             return(sendCondition)
[09:29:18.861]                           }
[09:29:18.861]                         }
[09:29:18.861]                         frame <- frame + 1L
[09:29:18.861]                         envir <- sys.frame(frame)
[09:29:18.861]                       }
[09:29:18.861]                     }
[09:29:18.861]                     sendCondition <<- function(cond) NULL
[09:29:18.861]                   }
[09:29:18.861]                 })
[09:29:18.861]                 withCallingHandlers({
[09:29:18.861]                   {
[09:29:18.861]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.861]                     if (!identical(...future.globals.maxSize.org, 
[09:29:18.861]                       ...future.globals.maxSize)) {
[09:29:18.861]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.861]                       on.exit(options(oopts), add = TRUE)
[09:29:18.861]                     }
[09:29:18.861]                     {
[09:29:18.861]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.861]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:18.861]                         USE.NAMES = FALSE)
[09:29:18.861]                       do.call(mapply, args = args)
[09:29:18.861]                     }
[09:29:18.861]                   }
[09:29:18.861]                 }, immediateCondition = function(cond) {
[09:29:18.861]                   sendCondition <- ...future.makeSendCondition()
[09:29:18.861]                   sendCondition(cond)
[09:29:18.861]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.861]                   {
[09:29:18.861]                     inherits <- base::inherits
[09:29:18.861]                     invokeRestart <- base::invokeRestart
[09:29:18.861]                     is.null <- base::is.null
[09:29:18.861]                     muffled <- FALSE
[09:29:18.861]                     if (inherits(cond, "message")) {
[09:29:18.861]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:18.861]                       if (muffled) 
[09:29:18.861]                         invokeRestart("muffleMessage")
[09:29:18.861]                     }
[09:29:18.861]                     else if (inherits(cond, "warning")) {
[09:29:18.861]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:18.861]                       if (muffled) 
[09:29:18.861]                         invokeRestart("muffleWarning")
[09:29:18.861]                     }
[09:29:18.861]                     else if (inherits(cond, "condition")) {
[09:29:18.861]                       if (!is.null(pattern)) {
[09:29:18.861]                         computeRestarts <- base::computeRestarts
[09:29:18.861]                         grepl <- base::grepl
[09:29:18.861]                         restarts <- computeRestarts(cond)
[09:29:18.861]                         for (restart in restarts) {
[09:29:18.861]                           name <- restart$name
[09:29:18.861]                           if (is.null(name)) 
[09:29:18.861]                             next
[09:29:18.861]                           if (!grepl(pattern, name)) 
[09:29:18.861]                             next
[09:29:18.861]                           invokeRestart(restart)
[09:29:18.861]                           muffled <- TRUE
[09:29:18.861]                           break
[09:29:18.861]                         }
[09:29:18.861]                       }
[09:29:18.861]                     }
[09:29:18.861]                     invisible(muffled)
[09:29:18.861]                   }
[09:29:18.861]                   muffleCondition(cond)
[09:29:18.861]                 })
[09:29:18.861]             }))
[09:29:18.861]             future::FutureResult(value = ...future.value$value, 
[09:29:18.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.861]                   ...future.rng), globalenv = if (FALSE) 
[09:29:18.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:18.861]                     ...future.globalenv.names))
[09:29:18.861]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:18.861]         }, condition = base::local({
[09:29:18.861]             c <- base::c
[09:29:18.861]             inherits <- base::inherits
[09:29:18.861]             invokeRestart <- base::invokeRestart
[09:29:18.861]             length <- base::length
[09:29:18.861]             list <- base::list
[09:29:18.861]             seq.int <- base::seq.int
[09:29:18.861]             signalCondition <- base::signalCondition
[09:29:18.861]             sys.calls <- base::sys.calls
[09:29:18.861]             `[[` <- base::`[[`
[09:29:18.861]             `+` <- base::`+`
[09:29:18.861]             `<<-` <- base::`<<-`
[09:29:18.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:18.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:18.861]                   3L)]
[09:29:18.861]             }
[09:29:18.861]             function(cond) {
[09:29:18.861]                 is_error <- inherits(cond, "error")
[09:29:18.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:18.861]                   NULL)
[09:29:18.861]                 if (is_error) {
[09:29:18.861]                   sessionInformation <- function() {
[09:29:18.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:18.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:18.861]                       search = base::search(), system = base::Sys.info())
[09:29:18.861]                   }
[09:29:18.861]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:18.861]                     cond$call), session = sessionInformation(), 
[09:29:18.861]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:18.861]                   signalCondition(cond)
[09:29:18.861]                 }
[09:29:18.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:18.861]                 "immediateCondition"))) {
[09:29:18.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:18.861]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:18.861]                   if (TRUE && !signal) {
[09:29:18.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.861]                     {
[09:29:18.861]                       inherits <- base::inherits
[09:29:18.861]                       invokeRestart <- base::invokeRestart
[09:29:18.861]                       is.null <- base::is.null
[09:29:18.861]                       muffled <- FALSE
[09:29:18.861]                       if (inherits(cond, "message")) {
[09:29:18.861]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.861]                         if (muffled) 
[09:29:18.861]                           invokeRestart("muffleMessage")
[09:29:18.861]                       }
[09:29:18.861]                       else if (inherits(cond, "warning")) {
[09:29:18.861]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.861]                         if (muffled) 
[09:29:18.861]                           invokeRestart("muffleWarning")
[09:29:18.861]                       }
[09:29:18.861]                       else if (inherits(cond, "condition")) {
[09:29:18.861]                         if (!is.null(pattern)) {
[09:29:18.861]                           computeRestarts <- base::computeRestarts
[09:29:18.861]                           grepl <- base::grepl
[09:29:18.861]                           restarts <- computeRestarts(cond)
[09:29:18.861]                           for (restart in restarts) {
[09:29:18.861]                             name <- restart$name
[09:29:18.861]                             if (is.null(name)) 
[09:29:18.861]                               next
[09:29:18.861]                             if (!grepl(pattern, name)) 
[09:29:18.861]                               next
[09:29:18.861]                             invokeRestart(restart)
[09:29:18.861]                             muffled <- TRUE
[09:29:18.861]                             break
[09:29:18.861]                           }
[09:29:18.861]                         }
[09:29:18.861]                       }
[09:29:18.861]                       invisible(muffled)
[09:29:18.861]                     }
[09:29:18.861]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.861]                   }
[09:29:18.861]                 }
[09:29:18.861]                 else {
[09:29:18.861]                   if (TRUE) {
[09:29:18.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.861]                     {
[09:29:18.861]                       inherits <- base::inherits
[09:29:18.861]                       invokeRestart <- base::invokeRestart
[09:29:18.861]                       is.null <- base::is.null
[09:29:18.861]                       muffled <- FALSE
[09:29:18.861]                       if (inherits(cond, "message")) {
[09:29:18.861]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.861]                         if (muffled) 
[09:29:18.861]                           invokeRestart("muffleMessage")
[09:29:18.861]                       }
[09:29:18.861]                       else if (inherits(cond, "warning")) {
[09:29:18.861]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.861]                         if (muffled) 
[09:29:18.861]                           invokeRestart("muffleWarning")
[09:29:18.861]                       }
[09:29:18.861]                       else if (inherits(cond, "condition")) {
[09:29:18.861]                         if (!is.null(pattern)) {
[09:29:18.861]                           computeRestarts <- base::computeRestarts
[09:29:18.861]                           grepl <- base::grepl
[09:29:18.861]                           restarts <- computeRestarts(cond)
[09:29:18.861]                           for (restart in restarts) {
[09:29:18.861]                             name <- restart$name
[09:29:18.861]                             if (is.null(name)) 
[09:29:18.861]                               next
[09:29:18.861]                             if (!grepl(pattern, name)) 
[09:29:18.861]                               next
[09:29:18.861]                             invokeRestart(restart)
[09:29:18.861]                             muffled <- TRUE
[09:29:18.861]                             break
[09:29:18.861]                           }
[09:29:18.861]                         }
[09:29:18.861]                       }
[09:29:18.861]                       invisible(muffled)
[09:29:18.861]                     }
[09:29:18.861]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.861]                   }
[09:29:18.861]                 }
[09:29:18.861]             }
[09:29:18.861]         }))
[09:29:18.861]     }, error = function(ex) {
[09:29:18.861]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:18.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.861]                 ...future.rng), started = ...future.startTime, 
[09:29:18.861]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:18.861]             version = "1.8"), class = "FutureResult")
[09:29:18.861]     }, finally = {
[09:29:18.861]         if (!identical(...future.workdir, getwd())) 
[09:29:18.861]             setwd(...future.workdir)
[09:29:18.861]         {
[09:29:18.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:18.861]                 ...future.oldOptions$nwarnings <- NULL
[09:29:18.861]             }
[09:29:18.861]             base::options(...future.oldOptions)
[09:29:18.861]             if (.Platform$OS.type == "windows") {
[09:29:18.861]                 old_names <- names(...future.oldEnvVars)
[09:29:18.861]                 envs <- base::Sys.getenv()
[09:29:18.861]                 names <- names(envs)
[09:29:18.861]                 common <- intersect(names, old_names)
[09:29:18.861]                 added <- setdiff(names, old_names)
[09:29:18.861]                 removed <- setdiff(old_names, names)
[09:29:18.861]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:18.861]                   envs[common]]
[09:29:18.861]                 NAMES <- toupper(changed)
[09:29:18.861]                 args <- list()
[09:29:18.861]                 for (kk in seq_along(NAMES)) {
[09:29:18.861]                   name <- changed[[kk]]
[09:29:18.861]                   NAME <- NAMES[[kk]]
[09:29:18.861]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.861]                     next
[09:29:18.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.861]                 }
[09:29:18.861]                 NAMES <- toupper(added)
[09:29:18.861]                 for (kk in seq_along(NAMES)) {
[09:29:18.861]                   name <- added[[kk]]
[09:29:18.861]                   NAME <- NAMES[[kk]]
[09:29:18.861]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.861]                     next
[09:29:18.861]                   args[[name]] <- ""
[09:29:18.861]                 }
[09:29:18.861]                 NAMES <- toupper(removed)
[09:29:18.861]                 for (kk in seq_along(NAMES)) {
[09:29:18.861]                   name <- removed[[kk]]
[09:29:18.861]                   NAME <- NAMES[[kk]]
[09:29:18.861]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.861]                     next
[09:29:18.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.861]                 }
[09:29:18.861]                 if (length(args) > 0) 
[09:29:18.861]                   base::do.call(base::Sys.setenv, args = args)
[09:29:18.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:18.861]             }
[09:29:18.861]             else {
[09:29:18.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:18.861]             }
[09:29:18.861]             {
[09:29:18.861]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:18.861]                   0L) {
[09:29:18.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:18.861]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:18.861]                   base::options(opts)
[09:29:18.861]                 }
[09:29:18.861]                 {
[09:29:18.861]                   {
[09:29:18.861]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:18.861]                     NULL
[09:29:18.861]                   }
[09:29:18.861]                   options(future.plan = NULL)
[09:29:18.861]                   if (is.na(NA_character_)) 
[09:29:18.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:18.861]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:18.861]                     .init = FALSE)
[09:29:18.861]                 }
[09:29:18.861]             }
[09:29:18.861]         }
[09:29:18.861]     })
[09:29:18.861]     if (TRUE) {
[09:29:18.861]         base::sink(type = "output", split = FALSE)
[09:29:18.861]         if (TRUE) {
[09:29:18.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:18.861]         }
[09:29:18.861]         else {
[09:29:18.861]             ...future.result["stdout"] <- base::list(NULL)
[09:29:18.861]         }
[09:29:18.861]         base::close(...future.stdout)
[09:29:18.861]         ...future.stdout <- NULL
[09:29:18.861]     }
[09:29:18.861]     ...future.result$conditions <- ...future.conditions
[09:29:18.861]     ...future.result$finished <- base::Sys.time()
[09:29:18.861]     ...future.result
[09:29:18.861] }
[09:29:18.864] Exporting 5 global objects (224 bytes) to cluster node #1 ...
[09:29:18.864] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[09:29:18.864] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[09:29:18.864] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[09:29:18.865] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[09:29:18.865] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[09:29:18.865] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[09:29:18.865] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:18.865] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:18.866] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:18.866] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:18.866] Exporting 5 global objects (224 bytes) to cluster node #1 ... DONE
[09:29:18.866] MultisessionFuture started
[09:29:18.867] - Launch lazy future ... done
[09:29:18.867] run() for ‘MultisessionFuture’ ... done
[09:29:18.867] Created future:
[09:29:18.867] MultisessionFuture:
[09:29:18.867] Label: ‘future_mapply-1’
[09:29:18.867] Expression:
[09:29:18.867] {
[09:29:18.867]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.867]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:18.867]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.867]         on.exit(options(oopts), add = TRUE)
[09:29:18.867]     }
[09:29:18.867]     {
[09:29:18.867]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.867]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:18.867]         do.call(mapply, args = args)
[09:29:18.867]     }
[09:29:18.867] }
[09:29:18.867] Lazy evaluation: FALSE
[09:29:18.867] Asynchronous evaluation: TRUE
[09:29:18.867] Local evaluation: TRUE
[09:29:18.867] Environment: R_GlobalEnv
[09:29:18.867] Capture standard output: TRUE
[09:29:18.867] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:18.867] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:18.867] Packages: <none>
[09:29:18.867] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:18.867] Resolved: FALSE
[09:29:18.867] Value: <not collected>
[09:29:18.867] Conditions captured: <none>
[09:29:18.867] Early signaling: FALSE
[09:29:18.867] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:18.867] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.878] Chunk #1 of 2 ... DONE
[09:29:18.878] Chunk #2 of 2 ...
[09:29:18.878]  - Finding globals in '...' for chunk #2 ...
[09:29:18.878] getGlobalsAndPackages() ...
[09:29:18.879] Searching for globals...
[09:29:18.879] 
[09:29:18.879] Searching for globals ... DONE
[09:29:18.879] - globals: [0] <none>
[09:29:18.879] getGlobalsAndPackages() ... DONE
[09:29:18.879]    + additional globals found: [n=0] 
[09:29:18.879]    + additional namespaces needed: [n=0] 
[09:29:18.879]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:18.879]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:18.880]  - seeds: <none>
[09:29:18.880]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.880] getGlobalsAndPackages() ...
[09:29:18.880] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.880] Resolving globals: FALSE
[09:29:18.880] The total size of the 5 globals is 224 bytes (224 bytes)
[09:29:18.881] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[09:29:18.881] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.881] 
[09:29:18.881] getGlobalsAndPackages() ... DONE
[09:29:18.881] run() for ‘Future’ ...
[09:29:18.881] - state: ‘created’
[09:29:18.882] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:18.895] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.895] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:18.895]   - Field: ‘node’
[09:29:18.895]   - Field: ‘label’
[09:29:18.895]   - Field: ‘local’
[09:29:18.895]   - Field: ‘owner’
[09:29:18.896]   - Field: ‘envir’
[09:29:18.896]   - Field: ‘workers’
[09:29:18.896]   - Field: ‘packages’
[09:29:18.896]   - Field: ‘gc’
[09:29:18.896]   - Field: ‘conditions’
[09:29:18.896]   - Field: ‘persistent’
[09:29:18.896]   - Field: ‘expr’
[09:29:18.896]   - Field: ‘uuid’
[09:29:18.896]   - Field: ‘seed’
[09:29:18.896]   - Field: ‘version’
[09:29:18.896]   - Field: ‘result’
[09:29:18.897]   - Field: ‘asynchronous’
[09:29:18.897]   - Field: ‘calls’
[09:29:18.897]   - Field: ‘globals’
[09:29:18.897]   - Field: ‘stdout’
[09:29:18.897]   - Field: ‘earlySignal’
[09:29:18.897]   - Field: ‘lazy’
[09:29:18.897]   - Field: ‘state’
[09:29:18.897] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:18.897] - Launch lazy future ...
[09:29:18.897] Packages needed by the future expression (n = 0): <none>
[09:29:18.898] Packages needed by future strategies (n = 0): <none>
[09:29:18.898] {
[09:29:18.898]     {
[09:29:18.898]         {
[09:29:18.898]             ...future.startTime <- base::Sys.time()
[09:29:18.898]             {
[09:29:18.898]                 {
[09:29:18.898]                   {
[09:29:18.898]                     {
[09:29:18.898]                       base::local({
[09:29:18.898]                         has_future <- base::requireNamespace("future", 
[09:29:18.898]                           quietly = TRUE)
[09:29:18.898]                         if (has_future) {
[09:29:18.898]                           ns <- base::getNamespace("future")
[09:29:18.898]                           version <- ns[[".package"]][["version"]]
[09:29:18.898]                           if (is.null(version)) 
[09:29:18.898]                             version <- utils::packageVersion("future")
[09:29:18.898]                         }
[09:29:18.898]                         else {
[09:29:18.898]                           version <- NULL
[09:29:18.898]                         }
[09:29:18.898]                         if (!has_future || version < "1.8.0") {
[09:29:18.898]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:18.898]                             "", base::R.version$version.string), 
[09:29:18.898]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:18.898]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:18.898]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:18.898]                               "release", "version")], collapse = " "), 
[09:29:18.898]                             hostname = base::Sys.info()[["nodename"]])
[09:29:18.898]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:18.898]                             info)
[09:29:18.898]                           info <- base::paste(info, collapse = "; ")
[09:29:18.898]                           if (!has_future) {
[09:29:18.898]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:18.898]                               info)
[09:29:18.898]                           }
[09:29:18.898]                           else {
[09:29:18.898]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:18.898]                               info, version)
[09:29:18.898]                           }
[09:29:18.898]                           base::stop(msg)
[09:29:18.898]                         }
[09:29:18.898]                       })
[09:29:18.898]                     }
[09:29:18.898]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:18.898]                     base::options(mc.cores = 1L)
[09:29:18.898]                   }
[09:29:18.898]                   ...future.strategy.old <- future::plan("list")
[09:29:18.898]                   options(future.plan = NULL)
[09:29:18.898]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.898]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:18.898]                 }
[09:29:18.898]                 ...future.workdir <- getwd()
[09:29:18.898]             }
[09:29:18.898]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:18.898]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:18.898]         }
[09:29:18.898]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:18.898]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:18.898]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:18.898]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:18.898]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:18.898]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:18.898]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:18.898]             base::names(...future.oldOptions))
[09:29:18.898]     }
[09:29:18.898]     if (FALSE) {
[09:29:18.898]     }
[09:29:18.898]     else {
[09:29:18.898]         if (TRUE) {
[09:29:18.898]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:18.898]                 open = "w")
[09:29:18.898]         }
[09:29:18.898]         else {
[09:29:18.898]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:18.898]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:18.898]         }
[09:29:18.898]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:18.898]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:18.898]             base::sink(type = "output", split = FALSE)
[09:29:18.898]             base::close(...future.stdout)
[09:29:18.898]         }, add = TRUE)
[09:29:18.898]     }
[09:29:18.898]     ...future.frame <- base::sys.nframe()
[09:29:18.898]     ...future.conditions <- base::list()
[09:29:18.898]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:18.898]     if (FALSE) {
[09:29:18.898]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:18.898]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:18.898]     }
[09:29:18.898]     ...future.result <- base::tryCatch({
[09:29:18.898]         base::withCallingHandlers({
[09:29:18.898]             ...future.value <- base::withVisible(base::local({
[09:29:18.898]                 ...future.makeSendCondition <- base::local({
[09:29:18.898]                   sendCondition <- NULL
[09:29:18.898]                   function(frame = 1L) {
[09:29:18.898]                     if (is.function(sendCondition)) 
[09:29:18.898]                       return(sendCondition)
[09:29:18.898]                     ns <- getNamespace("parallel")
[09:29:18.898]                     if (exists("sendData", mode = "function", 
[09:29:18.898]                       envir = ns)) {
[09:29:18.898]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:18.898]                         envir = ns)
[09:29:18.898]                       envir <- sys.frame(frame)
[09:29:18.898]                       master <- NULL
[09:29:18.898]                       while (!identical(envir, .GlobalEnv) && 
[09:29:18.898]                         !identical(envir, emptyenv())) {
[09:29:18.898]                         if (exists("master", mode = "list", envir = envir, 
[09:29:18.898]                           inherits = FALSE)) {
[09:29:18.898]                           master <- get("master", mode = "list", 
[09:29:18.898]                             envir = envir, inherits = FALSE)
[09:29:18.898]                           if (inherits(master, c("SOCKnode", 
[09:29:18.898]                             "SOCK0node"))) {
[09:29:18.898]                             sendCondition <<- function(cond) {
[09:29:18.898]                               data <- list(type = "VALUE", value = cond, 
[09:29:18.898]                                 success = TRUE)
[09:29:18.898]                               parallel_sendData(master, data)
[09:29:18.898]                             }
[09:29:18.898]                             return(sendCondition)
[09:29:18.898]                           }
[09:29:18.898]                         }
[09:29:18.898]                         frame <- frame + 1L
[09:29:18.898]                         envir <- sys.frame(frame)
[09:29:18.898]                       }
[09:29:18.898]                     }
[09:29:18.898]                     sendCondition <<- function(cond) NULL
[09:29:18.898]                   }
[09:29:18.898]                 })
[09:29:18.898]                 withCallingHandlers({
[09:29:18.898]                   {
[09:29:18.898]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.898]                     if (!identical(...future.globals.maxSize.org, 
[09:29:18.898]                       ...future.globals.maxSize)) {
[09:29:18.898]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.898]                       on.exit(options(oopts), add = TRUE)
[09:29:18.898]                     }
[09:29:18.898]                     {
[09:29:18.898]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.898]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:18.898]                         USE.NAMES = FALSE)
[09:29:18.898]                       do.call(mapply, args = args)
[09:29:18.898]                     }
[09:29:18.898]                   }
[09:29:18.898]                 }, immediateCondition = function(cond) {
[09:29:18.898]                   sendCondition <- ...future.makeSendCondition()
[09:29:18.898]                   sendCondition(cond)
[09:29:18.898]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.898]                   {
[09:29:18.898]                     inherits <- base::inherits
[09:29:18.898]                     invokeRestart <- base::invokeRestart
[09:29:18.898]                     is.null <- base::is.null
[09:29:18.898]                     muffled <- FALSE
[09:29:18.898]                     if (inherits(cond, "message")) {
[09:29:18.898]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:18.898]                       if (muffled) 
[09:29:18.898]                         invokeRestart("muffleMessage")
[09:29:18.898]                     }
[09:29:18.898]                     else if (inherits(cond, "warning")) {
[09:29:18.898]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:18.898]                       if (muffled) 
[09:29:18.898]                         invokeRestart("muffleWarning")
[09:29:18.898]                     }
[09:29:18.898]                     else if (inherits(cond, "condition")) {
[09:29:18.898]                       if (!is.null(pattern)) {
[09:29:18.898]                         computeRestarts <- base::computeRestarts
[09:29:18.898]                         grepl <- base::grepl
[09:29:18.898]                         restarts <- computeRestarts(cond)
[09:29:18.898]                         for (restart in restarts) {
[09:29:18.898]                           name <- restart$name
[09:29:18.898]                           if (is.null(name)) 
[09:29:18.898]                             next
[09:29:18.898]                           if (!grepl(pattern, name)) 
[09:29:18.898]                             next
[09:29:18.898]                           invokeRestart(restart)
[09:29:18.898]                           muffled <- TRUE
[09:29:18.898]                           break
[09:29:18.898]                         }
[09:29:18.898]                       }
[09:29:18.898]                     }
[09:29:18.898]                     invisible(muffled)
[09:29:18.898]                   }
[09:29:18.898]                   muffleCondition(cond)
[09:29:18.898]                 })
[09:29:18.898]             }))
[09:29:18.898]             future::FutureResult(value = ...future.value$value, 
[09:29:18.898]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.898]                   ...future.rng), globalenv = if (FALSE) 
[09:29:18.898]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:18.898]                     ...future.globalenv.names))
[09:29:18.898]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:18.898]         }, condition = base::local({
[09:29:18.898]             c <- base::c
[09:29:18.898]             inherits <- base::inherits
[09:29:18.898]             invokeRestart <- base::invokeRestart
[09:29:18.898]             length <- base::length
[09:29:18.898]             list <- base::list
[09:29:18.898]             seq.int <- base::seq.int
[09:29:18.898]             signalCondition <- base::signalCondition
[09:29:18.898]             sys.calls <- base::sys.calls
[09:29:18.898]             `[[` <- base::`[[`
[09:29:18.898]             `+` <- base::`+`
[09:29:18.898]             `<<-` <- base::`<<-`
[09:29:18.898]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:18.898]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:18.898]                   3L)]
[09:29:18.898]             }
[09:29:18.898]             function(cond) {
[09:29:18.898]                 is_error <- inherits(cond, "error")
[09:29:18.898]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:18.898]                   NULL)
[09:29:18.898]                 if (is_error) {
[09:29:18.898]                   sessionInformation <- function() {
[09:29:18.898]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:18.898]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:18.898]                       search = base::search(), system = base::Sys.info())
[09:29:18.898]                   }
[09:29:18.898]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.898]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:18.898]                     cond$call), session = sessionInformation(), 
[09:29:18.898]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:18.898]                   signalCondition(cond)
[09:29:18.898]                 }
[09:29:18.898]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:18.898]                 "immediateCondition"))) {
[09:29:18.898]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:18.898]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.898]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:18.898]                   if (TRUE && !signal) {
[09:29:18.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.898]                     {
[09:29:18.898]                       inherits <- base::inherits
[09:29:18.898]                       invokeRestart <- base::invokeRestart
[09:29:18.898]                       is.null <- base::is.null
[09:29:18.898]                       muffled <- FALSE
[09:29:18.898]                       if (inherits(cond, "message")) {
[09:29:18.898]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.898]                         if (muffled) 
[09:29:18.898]                           invokeRestart("muffleMessage")
[09:29:18.898]                       }
[09:29:18.898]                       else if (inherits(cond, "warning")) {
[09:29:18.898]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.898]                         if (muffled) 
[09:29:18.898]                           invokeRestart("muffleWarning")
[09:29:18.898]                       }
[09:29:18.898]                       else if (inherits(cond, "condition")) {
[09:29:18.898]                         if (!is.null(pattern)) {
[09:29:18.898]                           computeRestarts <- base::computeRestarts
[09:29:18.898]                           grepl <- base::grepl
[09:29:18.898]                           restarts <- computeRestarts(cond)
[09:29:18.898]                           for (restart in restarts) {
[09:29:18.898]                             name <- restart$name
[09:29:18.898]                             if (is.null(name)) 
[09:29:18.898]                               next
[09:29:18.898]                             if (!grepl(pattern, name)) 
[09:29:18.898]                               next
[09:29:18.898]                             invokeRestart(restart)
[09:29:18.898]                             muffled <- TRUE
[09:29:18.898]                             break
[09:29:18.898]                           }
[09:29:18.898]                         }
[09:29:18.898]                       }
[09:29:18.898]                       invisible(muffled)
[09:29:18.898]                     }
[09:29:18.898]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.898]                   }
[09:29:18.898]                 }
[09:29:18.898]                 else {
[09:29:18.898]                   if (TRUE) {
[09:29:18.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.898]                     {
[09:29:18.898]                       inherits <- base::inherits
[09:29:18.898]                       invokeRestart <- base::invokeRestart
[09:29:18.898]                       is.null <- base::is.null
[09:29:18.898]                       muffled <- FALSE
[09:29:18.898]                       if (inherits(cond, "message")) {
[09:29:18.898]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.898]                         if (muffled) 
[09:29:18.898]                           invokeRestart("muffleMessage")
[09:29:18.898]                       }
[09:29:18.898]                       else if (inherits(cond, "warning")) {
[09:29:18.898]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.898]                         if (muffled) 
[09:29:18.898]                           invokeRestart("muffleWarning")
[09:29:18.898]                       }
[09:29:18.898]                       else if (inherits(cond, "condition")) {
[09:29:18.898]                         if (!is.null(pattern)) {
[09:29:18.898]                           computeRestarts <- base::computeRestarts
[09:29:18.898]                           grepl <- base::grepl
[09:29:18.898]                           restarts <- computeRestarts(cond)
[09:29:18.898]                           for (restart in restarts) {
[09:29:18.898]                             name <- restart$name
[09:29:18.898]                             if (is.null(name)) 
[09:29:18.898]                               next
[09:29:18.898]                             if (!grepl(pattern, name)) 
[09:29:18.898]                               next
[09:29:18.898]                             invokeRestart(restart)
[09:29:18.898]                             muffled <- TRUE
[09:29:18.898]                             break
[09:29:18.898]                           }
[09:29:18.898]                         }
[09:29:18.898]                       }
[09:29:18.898]                       invisible(muffled)
[09:29:18.898]                     }
[09:29:18.898]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.898]                   }
[09:29:18.898]                 }
[09:29:18.898]             }
[09:29:18.898]         }))
[09:29:18.898]     }, error = function(ex) {
[09:29:18.898]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:18.898]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.898]                 ...future.rng), started = ...future.startTime, 
[09:29:18.898]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:18.898]             version = "1.8"), class = "FutureResult")
[09:29:18.898]     }, finally = {
[09:29:18.898]         if (!identical(...future.workdir, getwd())) 
[09:29:18.898]             setwd(...future.workdir)
[09:29:18.898]         {
[09:29:18.898]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:18.898]                 ...future.oldOptions$nwarnings <- NULL
[09:29:18.898]             }
[09:29:18.898]             base::options(...future.oldOptions)
[09:29:18.898]             if (.Platform$OS.type == "windows") {
[09:29:18.898]                 old_names <- names(...future.oldEnvVars)
[09:29:18.898]                 envs <- base::Sys.getenv()
[09:29:18.898]                 names <- names(envs)
[09:29:18.898]                 common <- intersect(names, old_names)
[09:29:18.898]                 added <- setdiff(names, old_names)
[09:29:18.898]                 removed <- setdiff(old_names, names)
[09:29:18.898]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:18.898]                   envs[common]]
[09:29:18.898]                 NAMES <- toupper(changed)
[09:29:18.898]                 args <- list()
[09:29:18.898]                 for (kk in seq_along(NAMES)) {
[09:29:18.898]                   name <- changed[[kk]]
[09:29:18.898]                   NAME <- NAMES[[kk]]
[09:29:18.898]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.898]                     next
[09:29:18.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.898]                 }
[09:29:18.898]                 NAMES <- toupper(added)
[09:29:18.898]                 for (kk in seq_along(NAMES)) {
[09:29:18.898]                   name <- added[[kk]]
[09:29:18.898]                   NAME <- NAMES[[kk]]
[09:29:18.898]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.898]                     next
[09:29:18.898]                   args[[name]] <- ""
[09:29:18.898]                 }
[09:29:18.898]                 NAMES <- toupper(removed)
[09:29:18.898]                 for (kk in seq_along(NAMES)) {
[09:29:18.898]                   name <- removed[[kk]]
[09:29:18.898]                   NAME <- NAMES[[kk]]
[09:29:18.898]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.898]                     next
[09:29:18.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.898]                 }
[09:29:18.898]                 if (length(args) > 0) 
[09:29:18.898]                   base::do.call(base::Sys.setenv, args = args)
[09:29:18.898]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:18.898]             }
[09:29:18.898]             else {
[09:29:18.898]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:18.898]             }
[09:29:18.898]             {
[09:29:18.898]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:18.898]                   0L) {
[09:29:18.898]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:18.898]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:18.898]                   base::options(opts)
[09:29:18.898]                 }
[09:29:18.898]                 {
[09:29:18.898]                   {
[09:29:18.898]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:18.898]                     NULL
[09:29:18.898]                   }
[09:29:18.898]                   options(future.plan = NULL)
[09:29:18.898]                   if (is.na(NA_character_)) 
[09:29:18.898]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.898]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:18.898]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:18.898]                     .init = FALSE)
[09:29:18.898]                 }
[09:29:18.898]             }
[09:29:18.898]         }
[09:29:18.898]     })
[09:29:18.898]     if (TRUE) {
[09:29:18.898]         base::sink(type = "output", split = FALSE)
[09:29:18.898]         if (TRUE) {
[09:29:18.898]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:18.898]         }
[09:29:18.898]         else {
[09:29:18.898]             ...future.result["stdout"] <- base::list(NULL)
[09:29:18.898]         }
[09:29:18.898]         base::close(...future.stdout)
[09:29:18.898]         ...future.stdout <- NULL
[09:29:18.898]     }
[09:29:18.898]     ...future.result$conditions <- ...future.conditions
[09:29:18.898]     ...future.result$finished <- base::Sys.time()
[09:29:18.898]     ...future.result
[09:29:18.898] }
[09:29:18.900] Exporting 5 global objects (224 bytes) to cluster node #2 ...
[09:29:18.901] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[09:29:18.901] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[09:29:18.901] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[09:29:18.901] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[09:29:18.901] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[09:29:18.902] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[09:29:18.902] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:18.902] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:18.902] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:18.903] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:18.903] Exporting 5 global objects (224 bytes) to cluster node #2 ... DONE
[09:29:18.903] MultisessionFuture started
[09:29:18.903] - Launch lazy future ... done
[09:29:18.903] run() for ‘MultisessionFuture’ ... done
[09:29:18.903] Created future:
[09:29:18.903] MultisessionFuture:
[09:29:18.903] Label: ‘future_mapply-2’
[09:29:18.903] Expression:
[09:29:18.903] {
[09:29:18.903]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.903]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:18.903]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.903]         on.exit(options(oopts), add = TRUE)
[09:29:18.903]     }
[09:29:18.903]     {
[09:29:18.903]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.903]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:18.903]         do.call(mapply, args = args)
[09:29:18.903]     }
[09:29:18.903] }
[09:29:18.903] Lazy evaluation: FALSE
[09:29:18.903] Asynchronous evaluation: TRUE
[09:29:18.903] Local evaluation: TRUE
[09:29:18.903] Environment: R_GlobalEnv
[09:29:18.903] Capture standard output: TRUE
[09:29:18.903] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:18.903] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:18.903] Packages: <none>
[09:29:18.903] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:18.903] Resolved: FALSE
[09:29:18.903] Value: <not collected>
[09:29:18.903] Conditions captured: <none>
[09:29:18.903] Early signaling: FALSE
[09:29:18.903] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:18.903] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.915] Chunk #2 of 2 ... DONE
[09:29:18.915] Launching 2 futures (chunks) ... DONE
[09:29:18.915] Resolving 2 futures (chunks) ...
[09:29:18.915] resolve() on list ...
[09:29:18.915]  recursive: 0
[09:29:18.915]  length: 2
[09:29:18.915] 
[09:29:18.916] receiveMessageFromWorker() for ClusterFuture ...
[09:29:18.916] - Validating connection of MultisessionFuture
[09:29:18.916] - received message: FutureResult
[09:29:18.916] - Received FutureResult
[09:29:18.916] - Erased future from FutureRegistry
[09:29:18.916] result() for ClusterFuture ...
[09:29:18.917] - result already collected: FutureResult
[09:29:18.917] result() for ClusterFuture ... done
[09:29:18.917] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:18.917] Future #1
[09:29:18.917] result() for ClusterFuture ...
[09:29:18.917] - result already collected: FutureResult
[09:29:18.917] result() for ClusterFuture ... done
[09:29:18.917] result() for ClusterFuture ...
[09:29:18.917] - result already collected: FutureResult
[09:29:18.917] result() for ClusterFuture ... done
[09:29:18.917] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:18.918] - nx: 2
[09:29:18.918] - relay: TRUE
[09:29:18.918] - stdout: TRUE
[09:29:18.918] - signal: TRUE
[09:29:18.918] - resignal: FALSE
[09:29:18.918] - force: TRUE
[09:29:18.918] - relayed: [n=2] FALSE, FALSE
[09:29:18.918] - queued futures: [n=2] FALSE, FALSE
[09:29:18.918]  - until=1
[09:29:18.918]  - relaying element #1
[09:29:18.918] result() for ClusterFuture ...
[09:29:18.918] - result already collected: FutureResult
[09:29:18.919] result() for ClusterFuture ... done
[09:29:18.919] result() for ClusterFuture ...
[09:29:18.919] - result already collected: FutureResult
[09:29:18.919] result() for ClusterFuture ... done
[09:29:18.919] result() for ClusterFuture ...
[09:29:18.919] - result already collected: FutureResult
[09:29:18.919] result() for ClusterFuture ... done
[09:29:18.919] result() for ClusterFuture ...
[09:29:18.919] - result already collected: FutureResult
[09:29:18.919] result() for ClusterFuture ... done
[09:29:18.919] - relayed: [n=2] TRUE, FALSE
[09:29:18.919] - queued futures: [n=2] TRUE, FALSE
[09:29:18.920] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:18.920]  length: 1 (resolved future 1)
[09:29:18.945] receiveMessageFromWorker() for ClusterFuture ...
[09:29:18.945] - Validating connection of MultisessionFuture
[09:29:18.945] - received message: FutureResult
[09:29:18.946] - Received FutureResult
[09:29:18.946] - Erased future from FutureRegistry
[09:29:18.946] result() for ClusterFuture ...
[09:29:18.946] - result already collected: FutureResult
[09:29:18.946] result() for ClusterFuture ... done
[09:29:18.946] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:18.946] Future #2
[09:29:18.946] result() for ClusterFuture ...
[09:29:18.946] - result already collected: FutureResult
[09:29:18.946] result() for ClusterFuture ... done
[09:29:18.947] result() for ClusterFuture ...
[09:29:18.947] - result already collected: FutureResult
[09:29:18.947] result() for ClusterFuture ... done
[09:29:18.947] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:18.947] - nx: 2
[09:29:18.947] - relay: TRUE
[09:29:18.947] - stdout: TRUE
[09:29:18.947] - signal: TRUE
[09:29:18.947] - resignal: FALSE
[09:29:18.947] - force: TRUE
[09:29:18.947] - relayed: [n=2] TRUE, FALSE
[09:29:18.947] - queued futures: [n=2] TRUE, FALSE
[09:29:18.948]  - until=2
[09:29:18.948]  - relaying element #2
[09:29:18.948] result() for ClusterFuture ...
[09:29:18.948] - result already collected: FutureResult
[09:29:18.948] result() for ClusterFuture ... done
[09:29:18.948] result() for ClusterFuture ...
[09:29:18.948] - result already collected: FutureResult
[09:29:18.948] result() for ClusterFuture ... done
[09:29:18.948] result() for ClusterFuture ...
[09:29:18.948] - result already collected: FutureResult
[09:29:18.948] result() for ClusterFuture ... done
[09:29:18.949] result() for ClusterFuture ...
[09:29:18.949] - result already collected: FutureResult
[09:29:18.949] result() for ClusterFuture ... done
[09:29:18.949] - relayed: [n=2] TRUE, TRUE
[09:29:18.949] - queued futures: [n=2] TRUE, TRUE
[09:29:18.949] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:18.949]  length: 0 (resolved future 2)
[09:29:18.949] Relaying remaining futures
[09:29:18.949] signalConditionsASAP(NULL, pos=0) ...
[09:29:18.949] - nx: 2
[09:29:18.949] - relay: TRUE
[09:29:18.949] - stdout: TRUE
[09:29:18.950] - signal: TRUE
[09:29:18.950] - resignal: FALSE
[09:29:18.950] - force: TRUE
[09:29:18.950] - relayed: [n=2] TRUE, TRUE
[09:29:18.950] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:18.950] - relayed: [n=2] TRUE, TRUE
[09:29:18.950] - queued futures: [n=2] TRUE, TRUE
[09:29:18.950] signalConditionsASAP(NULL, pos=0) ... done
[09:29:18.950] resolve() on list ... DONE
[09:29:18.950] result() for ClusterFuture ...
[09:29:18.950] - result already collected: FutureResult
[09:29:18.950] result() for ClusterFuture ... done
[09:29:18.951] result() for ClusterFuture ...
[09:29:18.951] - result already collected: FutureResult
[09:29:18.951] result() for ClusterFuture ... done
[09:29:18.951] result() for ClusterFuture ...
[09:29:18.951] - result already collected: FutureResult
[09:29:18.951] result() for ClusterFuture ... done
[09:29:18.951] result() for ClusterFuture ...
[09:29:18.951] - result already collected: FutureResult
[09:29:18.951] result() for ClusterFuture ... done
[09:29:18.951]  - Number of value chunks collected: 2
[09:29:18.951] Resolving 2 futures (chunks) ... DONE
[09:29:18.952] Reducing values from 2 chunks ...
[09:29:18.952]  - Number of values collected after concatenation: 4
[09:29:18.952]  - Number of values expected: 4
[09:29:18.952] Reducing values from 2 chunks ... DONE
[09:29:18.952] future_mapply() ... DONE
[09:29:18.952] future_mapply() ...
[09:29:18.955] Number of chunks: 2
[09:29:18.955] getGlobalsAndPackagesXApply() ...
[09:29:18.955]  - future.globals: TRUE
[09:29:18.956] getGlobalsAndPackages() ...
[09:29:18.956] Searching for globals...
[09:29:18.957] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[09:29:18.957] Searching for globals ... DONE
[09:29:18.957] Resolving globals: FALSE
[09:29:18.957] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[09:29:18.958] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[09:29:18.960] - globals: [1] ‘FUN’
[09:29:18.960] 
[09:29:18.960] getGlobalsAndPackages() ... DONE
[09:29:18.960]  - globals found/used: [n=1] ‘FUN’
[09:29:18.960]  - needed namespaces: [n=0] 
[09:29:18.960] Finding globals ... DONE
[09:29:18.960] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:18.961] List of 2
[09:29:18.961]  $ ...future.FUN:function (x, y)  
[09:29:18.961]  $ MoreArgs     : NULL
[09:29:18.961]  - attr(*, "where")=List of 2
[09:29:18.961]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:18.961]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:18.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:18.961]  - attr(*, "resolved")= logi FALSE
[09:29:18.961]  - attr(*, "total_size")= num NA
[09:29:18.963] Packages to be attached in all futures: [n=0] 
[09:29:18.963] getGlobalsAndPackagesXApply() ... DONE
[09:29:18.963] Number of futures (= number of chunks): 2
[09:29:18.963] Launching 2 futures (chunks) ...
[09:29:18.963] Chunk #1 of 2 ...
[09:29:18.964]  - Finding globals in '...' for chunk #1 ...
[09:29:18.964] getGlobalsAndPackages() ...
[09:29:18.964] Searching for globals...
[09:29:18.964] 
[09:29:18.964] Searching for globals ... DONE
[09:29:18.964] - globals: [0] <none>
[09:29:18.964] getGlobalsAndPackages() ... DONE
[09:29:18.964]    + additional globals found: [n=0] 
[09:29:18.964]    + additional namespaces needed: [n=0] 
[09:29:18.965]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:18.965]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:18.965]  - seeds: <none>
[09:29:18.965]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.965] getGlobalsAndPackages() ...
[09:29:18.965] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.965] Resolving globals: FALSE
[09:29:18.966] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[09:29:18.966] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:18.966] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:18.966] 
[09:29:18.966] getGlobalsAndPackages() ... DONE
[09:29:18.967] run() for ‘Future’ ...
[09:29:18.967] - state: ‘created’
[09:29:18.967] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:18.981] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:18.981] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:18.981]   - Field: ‘node’
[09:29:18.981]   - Field: ‘label’
[09:29:18.981]   - Field: ‘local’
[09:29:18.981]   - Field: ‘owner’
[09:29:18.982]   - Field: ‘envir’
[09:29:18.982]   - Field: ‘workers’
[09:29:18.982]   - Field: ‘packages’
[09:29:18.982]   - Field: ‘gc’
[09:29:18.982]   - Field: ‘conditions’
[09:29:18.982]   - Field: ‘persistent’
[09:29:18.982]   - Field: ‘expr’
[09:29:18.982]   - Field: ‘uuid’
[09:29:18.982]   - Field: ‘seed’
[09:29:18.982]   - Field: ‘version’
[09:29:18.982]   - Field: ‘result’
[09:29:18.983]   - Field: ‘asynchronous’
[09:29:18.983]   - Field: ‘calls’
[09:29:18.983]   - Field: ‘globals’
[09:29:18.983]   - Field: ‘stdout’
[09:29:18.983]   - Field: ‘earlySignal’
[09:29:18.983]   - Field: ‘lazy’
[09:29:18.983]   - Field: ‘state’
[09:29:18.983] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:18.983] - Launch lazy future ...
[09:29:18.983] Packages needed by the future expression (n = 0): <none>
[09:29:18.984] Packages needed by future strategies (n = 0): <none>
[09:29:18.984] {
[09:29:18.984]     {
[09:29:18.984]         {
[09:29:18.984]             ...future.startTime <- base::Sys.time()
[09:29:18.984]             {
[09:29:18.984]                 {
[09:29:18.984]                   {
[09:29:18.984]                     {
[09:29:18.984]                       base::local({
[09:29:18.984]                         has_future <- base::requireNamespace("future", 
[09:29:18.984]                           quietly = TRUE)
[09:29:18.984]                         if (has_future) {
[09:29:18.984]                           ns <- base::getNamespace("future")
[09:29:18.984]                           version <- ns[[".package"]][["version"]]
[09:29:18.984]                           if (is.null(version)) 
[09:29:18.984]                             version <- utils::packageVersion("future")
[09:29:18.984]                         }
[09:29:18.984]                         else {
[09:29:18.984]                           version <- NULL
[09:29:18.984]                         }
[09:29:18.984]                         if (!has_future || version < "1.8.0") {
[09:29:18.984]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:18.984]                             "", base::R.version$version.string), 
[09:29:18.984]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:18.984]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:18.984]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:18.984]                               "release", "version")], collapse = " "), 
[09:29:18.984]                             hostname = base::Sys.info()[["nodename"]])
[09:29:18.984]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:18.984]                             info)
[09:29:18.984]                           info <- base::paste(info, collapse = "; ")
[09:29:18.984]                           if (!has_future) {
[09:29:18.984]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:18.984]                               info)
[09:29:18.984]                           }
[09:29:18.984]                           else {
[09:29:18.984]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:18.984]                               info, version)
[09:29:18.984]                           }
[09:29:18.984]                           base::stop(msg)
[09:29:18.984]                         }
[09:29:18.984]                       })
[09:29:18.984]                     }
[09:29:18.984]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:18.984]                     base::options(mc.cores = 1L)
[09:29:18.984]                   }
[09:29:18.984]                   ...future.strategy.old <- future::plan("list")
[09:29:18.984]                   options(future.plan = NULL)
[09:29:18.984]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.984]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:18.984]                 }
[09:29:18.984]                 ...future.workdir <- getwd()
[09:29:18.984]             }
[09:29:18.984]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:18.984]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:18.984]         }
[09:29:18.984]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:18.984]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:18.984]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:18.984]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:18.984]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:18.984]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:18.984]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:18.984]             base::names(...future.oldOptions))
[09:29:18.984]     }
[09:29:18.984]     if (FALSE) {
[09:29:18.984]     }
[09:29:18.984]     else {
[09:29:18.984]         if (TRUE) {
[09:29:18.984]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:18.984]                 open = "w")
[09:29:18.984]         }
[09:29:18.984]         else {
[09:29:18.984]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:18.984]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:18.984]         }
[09:29:18.984]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:18.984]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:18.984]             base::sink(type = "output", split = FALSE)
[09:29:18.984]             base::close(...future.stdout)
[09:29:18.984]         }, add = TRUE)
[09:29:18.984]     }
[09:29:18.984]     ...future.frame <- base::sys.nframe()
[09:29:18.984]     ...future.conditions <- base::list()
[09:29:18.984]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:18.984]     if (FALSE) {
[09:29:18.984]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:18.984]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:18.984]     }
[09:29:18.984]     ...future.result <- base::tryCatch({
[09:29:18.984]         base::withCallingHandlers({
[09:29:18.984]             ...future.value <- base::withVisible(base::local({
[09:29:18.984]                 ...future.makeSendCondition <- base::local({
[09:29:18.984]                   sendCondition <- NULL
[09:29:18.984]                   function(frame = 1L) {
[09:29:18.984]                     if (is.function(sendCondition)) 
[09:29:18.984]                       return(sendCondition)
[09:29:18.984]                     ns <- getNamespace("parallel")
[09:29:18.984]                     if (exists("sendData", mode = "function", 
[09:29:18.984]                       envir = ns)) {
[09:29:18.984]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:18.984]                         envir = ns)
[09:29:18.984]                       envir <- sys.frame(frame)
[09:29:18.984]                       master <- NULL
[09:29:18.984]                       while (!identical(envir, .GlobalEnv) && 
[09:29:18.984]                         !identical(envir, emptyenv())) {
[09:29:18.984]                         if (exists("master", mode = "list", envir = envir, 
[09:29:18.984]                           inherits = FALSE)) {
[09:29:18.984]                           master <- get("master", mode = "list", 
[09:29:18.984]                             envir = envir, inherits = FALSE)
[09:29:18.984]                           if (inherits(master, c("SOCKnode", 
[09:29:18.984]                             "SOCK0node"))) {
[09:29:18.984]                             sendCondition <<- function(cond) {
[09:29:18.984]                               data <- list(type = "VALUE", value = cond, 
[09:29:18.984]                                 success = TRUE)
[09:29:18.984]                               parallel_sendData(master, data)
[09:29:18.984]                             }
[09:29:18.984]                             return(sendCondition)
[09:29:18.984]                           }
[09:29:18.984]                         }
[09:29:18.984]                         frame <- frame + 1L
[09:29:18.984]                         envir <- sys.frame(frame)
[09:29:18.984]                       }
[09:29:18.984]                     }
[09:29:18.984]                     sendCondition <<- function(cond) NULL
[09:29:18.984]                   }
[09:29:18.984]                 })
[09:29:18.984]                 withCallingHandlers({
[09:29:18.984]                   {
[09:29:18.984]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.984]                     if (!identical(...future.globals.maxSize.org, 
[09:29:18.984]                       ...future.globals.maxSize)) {
[09:29:18.984]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.984]                       on.exit(options(oopts), add = TRUE)
[09:29:18.984]                     }
[09:29:18.984]                     {
[09:29:18.984]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.984]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:18.984]                         USE.NAMES = FALSE)
[09:29:18.984]                       do.call(mapply, args = args)
[09:29:18.984]                     }
[09:29:18.984]                   }
[09:29:18.984]                 }, immediateCondition = function(cond) {
[09:29:18.984]                   sendCondition <- ...future.makeSendCondition()
[09:29:18.984]                   sendCondition(cond)
[09:29:18.984]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.984]                   {
[09:29:18.984]                     inherits <- base::inherits
[09:29:18.984]                     invokeRestart <- base::invokeRestart
[09:29:18.984]                     is.null <- base::is.null
[09:29:18.984]                     muffled <- FALSE
[09:29:18.984]                     if (inherits(cond, "message")) {
[09:29:18.984]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:18.984]                       if (muffled) 
[09:29:18.984]                         invokeRestart("muffleMessage")
[09:29:18.984]                     }
[09:29:18.984]                     else if (inherits(cond, "warning")) {
[09:29:18.984]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:18.984]                       if (muffled) 
[09:29:18.984]                         invokeRestart("muffleWarning")
[09:29:18.984]                     }
[09:29:18.984]                     else if (inherits(cond, "condition")) {
[09:29:18.984]                       if (!is.null(pattern)) {
[09:29:18.984]                         computeRestarts <- base::computeRestarts
[09:29:18.984]                         grepl <- base::grepl
[09:29:18.984]                         restarts <- computeRestarts(cond)
[09:29:18.984]                         for (restart in restarts) {
[09:29:18.984]                           name <- restart$name
[09:29:18.984]                           if (is.null(name)) 
[09:29:18.984]                             next
[09:29:18.984]                           if (!grepl(pattern, name)) 
[09:29:18.984]                             next
[09:29:18.984]                           invokeRestart(restart)
[09:29:18.984]                           muffled <- TRUE
[09:29:18.984]                           break
[09:29:18.984]                         }
[09:29:18.984]                       }
[09:29:18.984]                     }
[09:29:18.984]                     invisible(muffled)
[09:29:18.984]                   }
[09:29:18.984]                   muffleCondition(cond)
[09:29:18.984]                 })
[09:29:18.984]             }))
[09:29:18.984]             future::FutureResult(value = ...future.value$value, 
[09:29:18.984]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.984]                   ...future.rng), globalenv = if (FALSE) 
[09:29:18.984]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:18.984]                     ...future.globalenv.names))
[09:29:18.984]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:18.984]         }, condition = base::local({
[09:29:18.984]             c <- base::c
[09:29:18.984]             inherits <- base::inherits
[09:29:18.984]             invokeRestart <- base::invokeRestart
[09:29:18.984]             length <- base::length
[09:29:18.984]             list <- base::list
[09:29:18.984]             seq.int <- base::seq.int
[09:29:18.984]             signalCondition <- base::signalCondition
[09:29:18.984]             sys.calls <- base::sys.calls
[09:29:18.984]             `[[` <- base::`[[`
[09:29:18.984]             `+` <- base::`+`
[09:29:18.984]             `<<-` <- base::`<<-`
[09:29:18.984]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:18.984]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:18.984]                   3L)]
[09:29:18.984]             }
[09:29:18.984]             function(cond) {
[09:29:18.984]                 is_error <- inherits(cond, "error")
[09:29:18.984]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:18.984]                   NULL)
[09:29:18.984]                 if (is_error) {
[09:29:18.984]                   sessionInformation <- function() {
[09:29:18.984]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:18.984]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:18.984]                       search = base::search(), system = base::Sys.info())
[09:29:18.984]                   }
[09:29:18.984]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.984]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:18.984]                     cond$call), session = sessionInformation(), 
[09:29:18.984]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:18.984]                   signalCondition(cond)
[09:29:18.984]                 }
[09:29:18.984]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:18.984]                 "immediateCondition"))) {
[09:29:18.984]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:18.984]                   ...future.conditions[[length(...future.conditions) + 
[09:29:18.984]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:18.984]                   if (TRUE && !signal) {
[09:29:18.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.984]                     {
[09:29:18.984]                       inherits <- base::inherits
[09:29:18.984]                       invokeRestart <- base::invokeRestart
[09:29:18.984]                       is.null <- base::is.null
[09:29:18.984]                       muffled <- FALSE
[09:29:18.984]                       if (inherits(cond, "message")) {
[09:29:18.984]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.984]                         if (muffled) 
[09:29:18.984]                           invokeRestart("muffleMessage")
[09:29:18.984]                       }
[09:29:18.984]                       else if (inherits(cond, "warning")) {
[09:29:18.984]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.984]                         if (muffled) 
[09:29:18.984]                           invokeRestart("muffleWarning")
[09:29:18.984]                       }
[09:29:18.984]                       else if (inherits(cond, "condition")) {
[09:29:18.984]                         if (!is.null(pattern)) {
[09:29:18.984]                           computeRestarts <- base::computeRestarts
[09:29:18.984]                           grepl <- base::grepl
[09:29:18.984]                           restarts <- computeRestarts(cond)
[09:29:18.984]                           for (restart in restarts) {
[09:29:18.984]                             name <- restart$name
[09:29:18.984]                             if (is.null(name)) 
[09:29:18.984]                               next
[09:29:18.984]                             if (!grepl(pattern, name)) 
[09:29:18.984]                               next
[09:29:18.984]                             invokeRestart(restart)
[09:29:18.984]                             muffled <- TRUE
[09:29:18.984]                             break
[09:29:18.984]                           }
[09:29:18.984]                         }
[09:29:18.984]                       }
[09:29:18.984]                       invisible(muffled)
[09:29:18.984]                     }
[09:29:18.984]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.984]                   }
[09:29:18.984]                 }
[09:29:18.984]                 else {
[09:29:18.984]                   if (TRUE) {
[09:29:18.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:18.984]                     {
[09:29:18.984]                       inherits <- base::inherits
[09:29:18.984]                       invokeRestart <- base::invokeRestart
[09:29:18.984]                       is.null <- base::is.null
[09:29:18.984]                       muffled <- FALSE
[09:29:18.984]                       if (inherits(cond, "message")) {
[09:29:18.984]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:18.984]                         if (muffled) 
[09:29:18.984]                           invokeRestart("muffleMessage")
[09:29:18.984]                       }
[09:29:18.984]                       else if (inherits(cond, "warning")) {
[09:29:18.984]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:18.984]                         if (muffled) 
[09:29:18.984]                           invokeRestart("muffleWarning")
[09:29:18.984]                       }
[09:29:18.984]                       else if (inherits(cond, "condition")) {
[09:29:18.984]                         if (!is.null(pattern)) {
[09:29:18.984]                           computeRestarts <- base::computeRestarts
[09:29:18.984]                           grepl <- base::grepl
[09:29:18.984]                           restarts <- computeRestarts(cond)
[09:29:18.984]                           for (restart in restarts) {
[09:29:18.984]                             name <- restart$name
[09:29:18.984]                             if (is.null(name)) 
[09:29:18.984]                               next
[09:29:18.984]                             if (!grepl(pattern, name)) 
[09:29:18.984]                               next
[09:29:18.984]                             invokeRestart(restart)
[09:29:18.984]                             muffled <- TRUE
[09:29:18.984]                             break
[09:29:18.984]                           }
[09:29:18.984]                         }
[09:29:18.984]                       }
[09:29:18.984]                       invisible(muffled)
[09:29:18.984]                     }
[09:29:18.984]                     muffleCondition(cond, pattern = "^muffle")
[09:29:18.984]                   }
[09:29:18.984]                 }
[09:29:18.984]             }
[09:29:18.984]         }))
[09:29:18.984]     }, error = function(ex) {
[09:29:18.984]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:18.984]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:18.984]                 ...future.rng), started = ...future.startTime, 
[09:29:18.984]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:18.984]             version = "1.8"), class = "FutureResult")
[09:29:18.984]     }, finally = {
[09:29:18.984]         if (!identical(...future.workdir, getwd())) 
[09:29:18.984]             setwd(...future.workdir)
[09:29:18.984]         {
[09:29:18.984]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:18.984]                 ...future.oldOptions$nwarnings <- NULL
[09:29:18.984]             }
[09:29:18.984]             base::options(...future.oldOptions)
[09:29:18.984]             if (.Platform$OS.type == "windows") {
[09:29:18.984]                 old_names <- names(...future.oldEnvVars)
[09:29:18.984]                 envs <- base::Sys.getenv()
[09:29:18.984]                 names <- names(envs)
[09:29:18.984]                 common <- intersect(names, old_names)
[09:29:18.984]                 added <- setdiff(names, old_names)
[09:29:18.984]                 removed <- setdiff(old_names, names)
[09:29:18.984]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:18.984]                   envs[common]]
[09:29:18.984]                 NAMES <- toupper(changed)
[09:29:18.984]                 args <- list()
[09:29:18.984]                 for (kk in seq_along(NAMES)) {
[09:29:18.984]                   name <- changed[[kk]]
[09:29:18.984]                   NAME <- NAMES[[kk]]
[09:29:18.984]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.984]                     next
[09:29:18.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.984]                 }
[09:29:18.984]                 NAMES <- toupper(added)
[09:29:18.984]                 for (kk in seq_along(NAMES)) {
[09:29:18.984]                   name <- added[[kk]]
[09:29:18.984]                   NAME <- NAMES[[kk]]
[09:29:18.984]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.984]                     next
[09:29:18.984]                   args[[name]] <- ""
[09:29:18.984]                 }
[09:29:18.984]                 NAMES <- toupper(removed)
[09:29:18.984]                 for (kk in seq_along(NAMES)) {
[09:29:18.984]                   name <- removed[[kk]]
[09:29:18.984]                   NAME <- NAMES[[kk]]
[09:29:18.984]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:18.984]                     next
[09:29:18.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:18.984]                 }
[09:29:18.984]                 if (length(args) > 0) 
[09:29:18.984]                   base::do.call(base::Sys.setenv, args = args)
[09:29:18.984]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:18.984]             }
[09:29:18.984]             else {
[09:29:18.984]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:18.984]             }
[09:29:18.984]             {
[09:29:18.984]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:18.984]                   0L) {
[09:29:18.984]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:18.984]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:18.984]                   base::options(opts)
[09:29:18.984]                 }
[09:29:18.984]                 {
[09:29:18.984]                   {
[09:29:18.984]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:18.984]                     NULL
[09:29:18.984]                   }
[09:29:18.984]                   options(future.plan = NULL)
[09:29:18.984]                   if (is.na(NA_character_)) 
[09:29:18.984]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:18.984]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:18.984]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:18.984]                     .init = FALSE)
[09:29:18.984]                 }
[09:29:18.984]             }
[09:29:18.984]         }
[09:29:18.984]     })
[09:29:18.984]     if (TRUE) {
[09:29:18.984]         base::sink(type = "output", split = FALSE)
[09:29:18.984]         if (TRUE) {
[09:29:18.984]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:18.984]         }
[09:29:18.984]         else {
[09:29:18.984]             ...future.result["stdout"] <- base::list(NULL)
[09:29:18.984]         }
[09:29:18.984]         base::close(...future.stdout)
[09:29:18.984]         ...future.stdout <- NULL
[09:29:18.984]     }
[09:29:18.984]     ...future.result$conditions <- ...future.conditions
[09:29:18.984]     ...future.result$finished <- base::Sys.time()
[09:29:18.984]     ...future.result
[09:29:18.984] }
[09:29:18.986] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[09:29:18.987] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[09:29:18.987] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[09:29:18.987] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:18.987] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:18.988] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[09:29:18.988] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[09:29:18.988] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:18.988] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:18.988] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:18.989] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:18.989] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[09:29:18.989] MultisessionFuture started
[09:29:18.989] - Launch lazy future ... done
[09:29:18.989] run() for ‘MultisessionFuture’ ... done
[09:29:18.989] Created future:
[09:29:18.990] MultisessionFuture:
[09:29:18.990] Label: ‘future_mapply-1’
[09:29:18.990] Expression:
[09:29:18.990] {
[09:29:18.990]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:18.990]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:18.990]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:18.990]         on.exit(options(oopts), add = TRUE)
[09:29:18.990]     }
[09:29:18.990]     {
[09:29:18.990]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:18.990]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:18.990]         do.call(mapply, args = args)
[09:29:18.990]     }
[09:29:18.990] }
[09:29:18.990] Lazy evaluation: FALSE
[09:29:18.990] Asynchronous evaluation: TRUE
[09:29:18.990] Local evaluation: TRUE
[09:29:18.990] Environment: R_GlobalEnv
[09:29:18.990] Capture standard output: TRUE
[09:29:18.990] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:18.990] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:18.990] Packages: <none>
[09:29:18.990] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:18.990] Resolved: FALSE
[09:29:18.990] Value: <not collected>
[09:29:18.990] Conditions captured: <none>
[09:29:18.990] Early signaling: FALSE
[09:29:18.990] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:18.990] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.001] Chunk #1 of 2 ... DONE
[09:29:19.001] Chunk #2 of 2 ...
[09:29:19.001]  - Finding globals in '...' for chunk #2 ...
[09:29:19.001] getGlobalsAndPackages() ...
[09:29:19.001] Searching for globals...
[09:29:19.001] 
[09:29:19.002] Searching for globals ... DONE
[09:29:19.002] - globals: [0] <none>
[09:29:19.002] getGlobalsAndPackages() ... DONE
[09:29:19.002]    + additional globals found: [n=0] 
[09:29:19.002]    + additional namespaces needed: [n=0] 
[09:29:19.002]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:19.002]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:19.002]  - seeds: <none>
[09:29:19.002]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.002] getGlobalsAndPackages() ...
[09:29:19.002] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.003] Resolving globals: FALSE
[09:29:19.003] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[09:29:19.003] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:19.004] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.004] 
[09:29:19.004] getGlobalsAndPackages() ... DONE
[09:29:19.004] run() for ‘Future’ ...
[09:29:19.004] - state: ‘created’
[09:29:19.004] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.018] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.019] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.019]   - Field: ‘node’
[09:29:19.019]   - Field: ‘label’
[09:29:19.019]   - Field: ‘local’
[09:29:19.019]   - Field: ‘owner’
[09:29:19.019]   - Field: ‘envir’
[09:29:19.019]   - Field: ‘workers’
[09:29:19.019]   - Field: ‘packages’
[09:29:19.019]   - Field: ‘gc’
[09:29:19.020]   - Field: ‘conditions’
[09:29:19.020]   - Field: ‘persistent’
[09:29:19.020]   - Field: ‘expr’
[09:29:19.020]   - Field: ‘uuid’
[09:29:19.020]   - Field: ‘seed’
[09:29:19.020]   - Field: ‘version’
[09:29:19.020]   - Field: ‘result’
[09:29:19.020]   - Field: ‘asynchronous’
[09:29:19.020]   - Field: ‘calls’
[09:29:19.020]   - Field: ‘globals’
[09:29:19.021]   - Field: ‘stdout’
[09:29:19.021]   - Field: ‘earlySignal’
[09:29:19.021]   - Field: ‘lazy’
[09:29:19.021]   - Field: ‘state’
[09:29:19.021] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.021] - Launch lazy future ...
[09:29:19.021] Packages needed by the future expression (n = 0): <none>
[09:29:19.021] Packages needed by future strategies (n = 0): <none>
[09:29:19.022] {
[09:29:19.022]     {
[09:29:19.022]         {
[09:29:19.022]             ...future.startTime <- base::Sys.time()
[09:29:19.022]             {
[09:29:19.022]                 {
[09:29:19.022]                   {
[09:29:19.022]                     {
[09:29:19.022]                       base::local({
[09:29:19.022]                         has_future <- base::requireNamespace("future", 
[09:29:19.022]                           quietly = TRUE)
[09:29:19.022]                         if (has_future) {
[09:29:19.022]                           ns <- base::getNamespace("future")
[09:29:19.022]                           version <- ns[[".package"]][["version"]]
[09:29:19.022]                           if (is.null(version)) 
[09:29:19.022]                             version <- utils::packageVersion("future")
[09:29:19.022]                         }
[09:29:19.022]                         else {
[09:29:19.022]                           version <- NULL
[09:29:19.022]                         }
[09:29:19.022]                         if (!has_future || version < "1.8.0") {
[09:29:19.022]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.022]                             "", base::R.version$version.string), 
[09:29:19.022]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.022]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.022]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.022]                               "release", "version")], collapse = " "), 
[09:29:19.022]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.022]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.022]                             info)
[09:29:19.022]                           info <- base::paste(info, collapse = "; ")
[09:29:19.022]                           if (!has_future) {
[09:29:19.022]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.022]                               info)
[09:29:19.022]                           }
[09:29:19.022]                           else {
[09:29:19.022]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.022]                               info, version)
[09:29:19.022]                           }
[09:29:19.022]                           base::stop(msg)
[09:29:19.022]                         }
[09:29:19.022]                       })
[09:29:19.022]                     }
[09:29:19.022]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.022]                     base::options(mc.cores = 1L)
[09:29:19.022]                   }
[09:29:19.022]                   ...future.strategy.old <- future::plan("list")
[09:29:19.022]                   options(future.plan = NULL)
[09:29:19.022]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.022]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.022]                 }
[09:29:19.022]                 ...future.workdir <- getwd()
[09:29:19.022]             }
[09:29:19.022]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.022]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.022]         }
[09:29:19.022]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.022]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:19.022]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.022]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.022]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.022]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.022]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.022]             base::names(...future.oldOptions))
[09:29:19.022]     }
[09:29:19.022]     if (FALSE) {
[09:29:19.022]     }
[09:29:19.022]     else {
[09:29:19.022]         if (TRUE) {
[09:29:19.022]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.022]                 open = "w")
[09:29:19.022]         }
[09:29:19.022]         else {
[09:29:19.022]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.022]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.022]         }
[09:29:19.022]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.022]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.022]             base::sink(type = "output", split = FALSE)
[09:29:19.022]             base::close(...future.stdout)
[09:29:19.022]         }, add = TRUE)
[09:29:19.022]     }
[09:29:19.022]     ...future.frame <- base::sys.nframe()
[09:29:19.022]     ...future.conditions <- base::list()
[09:29:19.022]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.022]     if (FALSE) {
[09:29:19.022]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.022]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.022]     }
[09:29:19.022]     ...future.result <- base::tryCatch({
[09:29:19.022]         base::withCallingHandlers({
[09:29:19.022]             ...future.value <- base::withVisible(base::local({
[09:29:19.022]                 ...future.makeSendCondition <- base::local({
[09:29:19.022]                   sendCondition <- NULL
[09:29:19.022]                   function(frame = 1L) {
[09:29:19.022]                     if (is.function(sendCondition)) 
[09:29:19.022]                       return(sendCondition)
[09:29:19.022]                     ns <- getNamespace("parallel")
[09:29:19.022]                     if (exists("sendData", mode = "function", 
[09:29:19.022]                       envir = ns)) {
[09:29:19.022]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.022]                         envir = ns)
[09:29:19.022]                       envir <- sys.frame(frame)
[09:29:19.022]                       master <- NULL
[09:29:19.022]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.022]                         !identical(envir, emptyenv())) {
[09:29:19.022]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.022]                           inherits = FALSE)) {
[09:29:19.022]                           master <- get("master", mode = "list", 
[09:29:19.022]                             envir = envir, inherits = FALSE)
[09:29:19.022]                           if (inherits(master, c("SOCKnode", 
[09:29:19.022]                             "SOCK0node"))) {
[09:29:19.022]                             sendCondition <<- function(cond) {
[09:29:19.022]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.022]                                 success = TRUE)
[09:29:19.022]                               parallel_sendData(master, data)
[09:29:19.022]                             }
[09:29:19.022]                             return(sendCondition)
[09:29:19.022]                           }
[09:29:19.022]                         }
[09:29:19.022]                         frame <- frame + 1L
[09:29:19.022]                         envir <- sys.frame(frame)
[09:29:19.022]                       }
[09:29:19.022]                     }
[09:29:19.022]                     sendCondition <<- function(cond) NULL
[09:29:19.022]                   }
[09:29:19.022]                 })
[09:29:19.022]                 withCallingHandlers({
[09:29:19.022]                   {
[09:29:19.022]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.022]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.022]                       ...future.globals.maxSize)) {
[09:29:19.022]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.022]                       on.exit(options(oopts), add = TRUE)
[09:29:19.022]                     }
[09:29:19.022]                     {
[09:29:19.022]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.022]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.022]                         USE.NAMES = FALSE)
[09:29:19.022]                       do.call(mapply, args = args)
[09:29:19.022]                     }
[09:29:19.022]                   }
[09:29:19.022]                 }, immediateCondition = function(cond) {
[09:29:19.022]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.022]                   sendCondition(cond)
[09:29:19.022]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.022]                   {
[09:29:19.022]                     inherits <- base::inherits
[09:29:19.022]                     invokeRestart <- base::invokeRestart
[09:29:19.022]                     is.null <- base::is.null
[09:29:19.022]                     muffled <- FALSE
[09:29:19.022]                     if (inherits(cond, "message")) {
[09:29:19.022]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.022]                       if (muffled) 
[09:29:19.022]                         invokeRestart("muffleMessage")
[09:29:19.022]                     }
[09:29:19.022]                     else if (inherits(cond, "warning")) {
[09:29:19.022]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.022]                       if (muffled) 
[09:29:19.022]                         invokeRestart("muffleWarning")
[09:29:19.022]                     }
[09:29:19.022]                     else if (inherits(cond, "condition")) {
[09:29:19.022]                       if (!is.null(pattern)) {
[09:29:19.022]                         computeRestarts <- base::computeRestarts
[09:29:19.022]                         grepl <- base::grepl
[09:29:19.022]                         restarts <- computeRestarts(cond)
[09:29:19.022]                         for (restart in restarts) {
[09:29:19.022]                           name <- restart$name
[09:29:19.022]                           if (is.null(name)) 
[09:29:19.022]                             next
[09:29:19.022]                           if (!grepl(pattern, name)) 
[09:29:19.022]                             next
[09:29:19.022]                           invokeRestart(restart)
[09:29:19.022]                           muffled <- TRUE
[09:29:19.022]                           break
[09:29:19.022]                         }
[09:29:19.022]                       }
[09:29:19.022]                     }
[09:29:19.022]                     invisible(muffled)
[09:29:19.022]                   }
[09:29:19.022]                   muffleCondition(cond)
[09:29:19.022]                 })
[09:29:19.022]             }))
[09:29:19.022]             future::FutureResult(value = ...future.value$value, 
[09:29:19.022]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.022]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.022]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.022]                     ...future.globalenv.names))
[09:29:19.022]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.022]         }, condition = base::local({
[09:29:19.022]             c <- base::c
[09:29:19.022]             inherits <- base::inherits
[09:29:19.022]             invokeRestart <- base::invokeRestart
[09:29:19.022]             length <- base::length
[09:29:19.022]             list <- base::list
[09:29:19.022]             seq.int <- base::seq.int
[09:29:19.022]             signalCondition <- base::signalCondition
[09:29:19.022]             sys.calls <- base::sys.calls
[09:29:19.022]             `[[` <- base::`[[`
[09:29:19.022]             `+` <- base::`+`
[09:29:19.022]             `<<-` <- base::`<<-`
[09:29:19.022]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.022]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.022]                   3L)]
[09:29:19.022]             }
[09:29:19.022]             function(cond) {
[09:29:19.022]                 is_error <- inherits(cond, "error")
[09:29:19.022]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.022]                   NULL)
[09:29:19.022]                 if (is_error) {
[09:29:19.022]                   sessionInformation <- function() {
[09:29:19.022]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.022]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.022]                       search = base::search(), system = base::Sys.info())
[09:29:19.022]                   }
[09:29:19.022]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.022]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.022]                     cond$call), session = sessionInformation(), 
[09:29:19.022]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.022]                   signalCondition(cond)
[09:29:19.022]                 }
[09:29:19.022]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.022]                 "immediateCondition"))) {
[09:29:19.022]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.022]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.022]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.022]                   if (TRUE && !signal) {
[09:29:19.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.022]                     {
[09:29:19.022]                       inherits <- base::inherits
[09:29:19.022]                       invokeRestart <- base::invokeRestart
[09:29:19.022]                       is.null <- base::is.null
[09:29:19.022]                       muffled <- FALSE
[09:29:19.022]                       if (inherits(cond, "message")) {
[09:29:19.022]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.022]                         if (muffled) 
[09:29:19.022]                           invokeRestart("muffleMessage")
[09:29:19.022]                       }
[09:29:19.022]                       else if (inherits(cond, "warning")) {
[09:29:19.022]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.022]                         if (muffled) 
[09:29:19.022]                           invokeRestart("muffleWarning")
[09:29:19.022]                       }
[09:29:19.022]                       else if (inherits(cond, "condition")) {
[09:29:19.022]                         if (!is.null(pattern)) {
[09:29:19.022]                           computeRestarts <- base::computeRestarts
[09:29:19.022]                           grepl <- base::grepl
[09:29:19.022]                           restarts <- computeRestarts(cond)
[09:29:19.022]                           for (restart in restarts) {
[09:29:19.022]                             name <- restart$name
[09:29:19.022]                             if (is.null(name)) 
[09:29:19.022]                               next
[09:29:19.022]                             if (!grepl(pattern, name)) 
[09:29:19.022]                               next
[09:29:19.022]                             invokeRestart(restart)
[09:29:19.022]                             muffled <- TRUE
[09:29:19.022]                             break
[09:29:19.022]                           }
[09:29:19.022]                         }
[09:29:19.022]                       }
[09:29:19.022]                       invisible(muffled)
[09:29:19.022]                     }
[09:29:19.022]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.022]                   }
[09:29:19.022]                 }
[09:29:19.022]                 else {
[09:29:19.022]                   if (TRUE) {
[09:29:19.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.022]                     {
[09:29:19.022]                       inherits <- base::inherits
[09:29:19.022]                       invokeRestart <- base::invokeRestart
[09:29:19.022]                       is.null <- base::is.null
[09:29:19.022]                       muffled <- FALSE
[09:29:19.022]                       if (inherits(cond, "message")) {
[09:29:19.022]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.022]                         if (muffled) 
[09:29:19.022]                           invokeRestart("muffleMessage")
[09:29:19.022]                       }
[09:29:19.022]                       else if (inherits(cond, "warning")) {
[09:29:19.022]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.022]                         if (muffled) 
[09:29:19.022]                           invokeRestart("muffleWarning")
[09:29:19.022]                       }
[09:29:19.022]                       else if (inherits(cond, "condition")) {
[09:29:19.022]                         if (!is.null(pattern)) {
[09:29:19.022]                           computeRestarts <- base::computeRestarts
[09:29:19.022]                           grepl <- base::grepl
[09:29:19.022]                           restarts <- computeRestarts(cond)
[09:29:19.022]                           for (restart in restarts) {
[09:29:19.022]                             name <- restart$name
[09:29:19.022]                             if (is.null(name)) 
[09:29:19.022]                               next
[09:29:19.022]                             if (!grepl(pattern, name)) 
[09:29:19.022]                               next
[09:29:19.022]                             invokeRestart(restart)
[09:29:19.022]                             muffled <- TRUE
[09:29:19.022]                             break
[09:29:19.022]                           }
[09:29:19.022]                         }
[09:29:19.022]                       }
[09:29:19.022]                       invisible(muffled)
[09:29:19.022]                     }
[09:29:19.022]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.022]                   }
[09:29:19.022]                 }
[09:29:19.022]             }
[09:29:19.022]         }))
[09:29:19.022]     }, error = function(ex) {
[09:29:19.022]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.022]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.022]                 ...future.rng), started = ...future.startTime, 
[09:29:19.022]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.022]             version = "1.8"), class = "FutureResult")
[09:29:19.022]     }, finally = {
[09:29:19.022]         if (!identical(...future.workdir, getwd())) 
[09:29:19.022]             setwd(...future.workdir)
[09:29:19.022]         {
[09:29:19.022]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.022]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.022]             }
[09:29:19.022]             base::options(...future.oldOptions)
[09:29:19.022]             if (.Platform$OS.type == "windows") {
[09:29:19.022]                 old_names <- names(...future.oldEnvVars)
[09:29:19.022]                 envs <- base::Sys.getenv()
[09:29:19.022]                 names <- names(envs)
[09:29:19.022]                 common <- intersect(names, old_names)
[09:29:19.022]                 added <- setdiff(names, old_names)
[09:29:19.022]                 removed <- setdiff(old_names, names)
[09:29:19.022]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.022]                   envs[common]]
[09:29:19.022]                 NAMES <- toupper(changed)
[09:29:19.022]                 args <- list()
[09:29:19.022]                 for (kk in seq_along(NAMES)) {
[09:29:19.022]                   name <- changed[[kk]]
[09:29:19.022]                   NAME <- NAMES[[kk]]
[09:29:19.022]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.022]                     next
[09:29:19.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.022]                 }
[09:29:19.022]                 NAMES <- toupper(added)
[09:29:19.022]                 for (kk in seq_along(NAMES)) {
[09:29:19.022]                   name <- added[[kk]]
[09:29:19.022]                   NAME <- NAMES[[kk]]
[09:29:19.022]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.022]                     next
[09:29:19.022]                   args[[name]] <- ""
[09:29:19.022]                 }
[09:29:19.022]                 NAMES <- toupper(removed)
[09:29:19.022]                 for (kk in seq_along(NAMES)) {
[09:29:19.022]                   name <- removed[[kk]]
[09:29:19.022]                   NAME <- NAMES[[kk]]
[09:29:19.022]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.022]                     next
[09:29:19.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.022]                 }
[09:29:19.022]                 if (length(args) > 0) 
[09:29:19.022]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.022]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.022]             }
[09:29:19.022]             else {
[09:29:19.022]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.022]             }
[09:29:19.022]             {
[09:29:19.022]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.022]                   0L) {
[09:29:19.022]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.022]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.022]                   base::options(opts)
[09:29:19.022]                 }
[09:29:19.022]                 {
[09:29:19.022]                   {
[09:29:19.022]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.022]                     NULL
[09:29:19.022]                   }
[09:29:19.022]                   options(future.plan = NULL)
[09:29:19.022]                   if (is.na(NA_character_)) 
[09:29:19.022]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.022]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.022]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.022]                     .init = FALSE)
[09:29:19.022]                 }
[09:29:19.022]             }
[09:29:19.022]         }
[09:29:19.022]     })
[09:29:19.022]     if (TRUE) {
[09:29:19.022]         base::sink(type = "output", split = FALSE)
[09:29:19.022]         if (TRUE) {
[09:29:19.022]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.022]         }
[09:29:19.022]         else {
[09:29:19.022]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.022]         }
[09:29:19.022]         base::close(...future.stdout)
[09:29:19.022]         ...future.stdout <- NULL
[09:29:19.022]     }
[09:29:19.022]     ...future.result$conditions <- ...future.conditions
[09:29:19.022]     ...future.result$finished <- base::Sys.time()
[09:29:19.022]     ...future.result
[09:29:19.022] }
[09:29:19.024] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[09:29:19.024] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[09:29:19.025] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[09:29:19.025] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:19.025] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.025] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[09:29:19.026] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[09:29:19.026] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:19.026] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.026] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:19.026] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.026] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[09:29:19.027] MultisessionFuture started
[09:29:19.027] - Launch lazy future ... done
[09:29:19.027] run() for ‘MultisessionFuture’ ... done
[09:29:19.027] Created future:
[09:29:19.027] MultisessionFuture:
[09:29:19.027] Label: ‘future_mapply-2’
[09:29:19.027] Expression:
[09:29:19.027] {
[09:29:19.027]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.027]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.027]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.027]         on.exit(options(oopts), add = TRUE)
[09:29:19.027]     }
[09:29:19.027]     {
[09:29:19.027]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.027]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.027]         do.call(mapply, args = args)
[09:29:19.027]     }
[09:29:19.027] }
[09:29:19.027] Lazy evaluation: FALSE
[09:29:19.027] Asynchronous evaluation: TRUE
[09:29:19.027] Local evaluation: TRUE
[09:29:19.027] Environment: R_GlobalEnv
[09:29:19.027] Capture standard output: TRUE
[09:29:19.027] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.027] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.027] Packages: <none>
[09:29:19.027] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.027] Resolved: FALSE
[09:29:19.027] Value: <not collected>
[09:29:19.027] Conditions captured: <none>
[09:29:19.027] Early signaling: FALSE
[09:29:19.027] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.027] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.039] Chunk #2 of 2 ... DONE
[09:29:19.039] Launching 2 futures (chunks) ... DONE
[09:29:19.039] Resolving 2 futures (chunks) ...
[09:29:19.039] resolve() on list ...
[09:29:19.039]  recursive: 0
[09:29:19.039]  length: 2
[09:29:19.039] 
[09:29:19.040] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.040] - Validating connection of MultisessionFuture
[09:29:19.040] - received message: FutureResult
[09:29:19.040] - Received FutureResult
[09:29:19.040] - Erased future from FutureRegistry
[09:29:19.040] result() for ClusterFuture ...
[09:29:19.041] - result already collected: FutureResult
[09:29:19.041] result() for ClusterFuture ... done
[09:29:19.041] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.041] Future #1
[09:29:19.041] result() for ClusterFuture ...
[09:29:19.041] - result already collected: FutureResult
[09:29:19.041] result() for ClusterFuture ... done
[09:29:19.041] result() for ClusterFuture ...
[09:29:19.041] - result already collected: FutureResult
[09:29:19.041] result() for ClusterFuture ... done
[09:29:19.041] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:19.041] - nx: 2
[09:29:19.042] - relay: TRUE
[09:29:19.042] - stdout: TRUE
[09:29:19.042] - signal: TRUE
[09:29:19.042] - resignal: FALSE
[09:29:19.042] - force: TRUE
[09:29:19.042] - relayed: [n=2] FALSE, FALSE
[09:29:19.042] - queued futures: [n=2] FALSE, FALSE
[09:29:19.042]  - until=1
[09:29:19.042]  - relaying element #1
[09:29:19.042] result() for ClusterFuture ...
[09:29:19.042] - result already collected: FutureResult
[09:29:19.042] result() for ClusterFuture ... done
[09:29:19.043] result() for ClusterFuture ...
[09:29:19.043] - result already collected: FutureResult
[09:29:19.043] result() for ClusterFuture ... done
[09:29:19.043] result() for ClusterFuture ...
[09:29:19.043] - result already collected: FutureResult
[09:29:19.043] result() for ClusterFuture ... done
[09:29:19.043] result() for ClusterFuture ...
[09:29:19.043] - result already collected: FutureResult
[09:29:19.043] result() for ClusterFuture ... done
[09:29:19.043] - relayed: [n=2] TRUE, FALSE
[09:29:19.043] - queued futures: [n=2] TRUE, FALSE
[09:29:19.043] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:19.044]  length: 1 (resolved future 1)
[09:29:19.069] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.069] - Validating connection of MultisessionFuture
[09:29:19.069] - received message: FutureResult
[09:29:19.070] - Received FutureResult
[09:29:19.070] - Erased future from FutureRegistry
[09:29:19.070] result() for ClusterFuture ...
[09:29:19.070] - result already collected: FutureResult
[09:29:19.070] result() for ClusterFuture ... done
[09:29:19.070] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.070] Future #2
[09:29:19.070] result() for ClusterFuture ...
[09:29:19.070] - result already collected: FutureResult
[09:29:19.070] result() for ClusterFuture ... done
[09:29:19.070] result() for ClusterFuture ...
[09:29:19.071] - result already collected: FutureResult
[09:29:19.071] result() for ClusterFuture ... done
[09:29:19.071] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:19.071] - nx: 2
[09:29:19.071] - relay: TRUE
[09:29:19.071] - stdout: TRUE
[09:29:19.071] - signal: TRUE
[09:29:19.071] - resignal: FALSE
[09:29:19.071] - force: TRUE
[09:29:19.071] - relayed: [n=2] TRUE, FALSE
[09:29:19.071] - queued futures: [n=2] TRUE, FALSE
[09:29:19.071]  - until=2
[09:29:19.072]  - relaying element #2
[09:29:19.072] result() for ClusterFuture ...
[09:29:19.072] - result already collected: FutureResult
[09:29:19.072] result() for ClusterFuture ... done
[09:29:19.072] result() for ClusterFuture ...
[09:29:19.072] - result already collected: FutureResult
[09:29:19.072] result() for ClusterFuture ... done
[09:29:19.072] result() for ClusterFuture ...
[09:29:19.072] - result already collected: FutureResult
[09:29:19.072] result() for ClusterFuture ... done
[09:29:19.072] result() for ClusterFuture ...
[09:29:19.072] - result already collected: FutureResult
[09:29:19.073] result() for ClusterFuture ... done
[09:29:19.073] - relayed: [n=2] TRUE, TRUE
[09:29:19.073] - queued futures: [n=2] TRUE, TRUE
[09:29:19.073] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:19.073]  length: 0 (resolved future 2)
[09:29:19.073] Relaying remaining futures
[09:29:19.073] signalConditionsASAP(NULL, pos=0) ...
[09:29:19.073] - nx: 2
[09:29:19.073] - relay: TRUE
[09:29:19.073] - stdout: TRUE
[09:29:19.073] - signal: TRUE
[09:29:19.073] - resignal: FALSE
[09:29:19.074] - force: TRUE
[09:29:19.074] - relayed: [n=2] TRUE, TRUE
[09:29:19.074] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:19.074] - relayed: [n=2] TRUE, TRUE
[09:29:19.074] - queued futures: [n=2] TRUE, TRUE
[09:29:19.074] signalConditionsASAP(NULL, pos=0) ... done
[09:29:19.074] resolve() on list ... DONE
[09:29:19.074] result() for ClusterFuture ...
[09:29:19.074] - result already collected: FutureResult
[09:29:19.074] result() for ClusterFuture ... done
[09:29:19.074] result() for ClusterFuture ...
[09:29:19.075] - result already collected: FutureResult
[09:29:19.075] result() for ClusterFuture ... done
[09:29:19.075] result() for ClusterFuture ...
[09:29:19.075] - result already collected: FutureResult
[09:29:19.075] result() for ClusterFuture ... done
[09:29:19.075] result() for ClusterFuture ...
[09:29:19.075] - result already collected: FutureResult
[09:29:19.075] result() for ClusterFuture ... done
[09:29:19.075]  - Number of value chunks collected: 2
[09:29:19.075] Resolving 2 futures (chunks) ... DONE
[09:29:19.075] Reducing values from 2 chunks ...
[09:29:19.075]  - Number of values collected after concatenation: 3
[09:29:19.076]  - Number of values expected: 3
[09:29:19.076] Reducing values from 2 chunks ... DONE
[09:29:19.076] future_mapply() ... DONE
- future_.mapply()
[09:29:19.076] future_mapply() ...
[09:29:19.079] Number of chunks: 2
[09:29:19.079] getGlobalsAndPackagesXApply() ...
[09:29:19.079]  - future.globals: TRUE
[09:29:19.080] getGlobalsAndPackages() ...
[09:29:19.080] Searching for globals...
[09:29:19.081] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[09:29:19.081] Searching for globals ... DONE
[09:29:19.081] Resolving globals: FALSE
[09:29:19.081] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[09:29:19.082] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[09:29:19.082] - globals: [1] ‘FUN’
[09:29:19.082] 
[09:29:19.082] getGlobalsAndPackages() ... DONE
[09:29:19.082]  - globals found/used: [n=1] ‘FUN’
[09:29:19.082]  - needed namespaces: [n=0] 
[09:29:19.082] Finding globals ... DONE
[09:29:19.082] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:19.083] List of 2
[09:29:19.083]  $ ...future.FUN:function (x, y)  
[09:29:19.083]  $ MoreArgs     : list()
[09:29:19.083]  - attr(*, "where")=List of 2
[09:29:19.083]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:19.083]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:19.083]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:19.083]  - attr(*, "resolved")= logi FALSE
[09:29:19.083]  - attr(*, "total_size")= num NA
[09:29:19.085] Packages to be attached in all futures: [n=0] 
[09:29:19.085] getGlobalsAndPackagesXApply() ... DONE
[09:29:19.085] Number of futures (= number of chunks): 2
[09:29:19.085] Launching 2 futures (chunks) ...
[09:29:19.085] Chunk #1 of 2 ...
[09:29:19.085]  - Finding globals in '...' for chunk #1 ...
[09:29:19.086] getGlobalsAndPackages() ...
[09:29:19.086] Searching for globals...
[09:29:19.086] 
[09:29:19.086] Searching for globals ... DONE
[09:29:19.086] - globals: [0] <none>
[09:29:19.086] getGlobalsAndPackages() ... DONE
[09:29:19.086]    + additional globals found: [n=0] 
[09:29:19.086]    + additional namespaces needed: [n=0] 
[09:29:19.086]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:19.087]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:19.087]  - seeds: <none>
[09:29:19.087]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.087] getGlobalsAndPackages() ...
[09:29:19.087] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.087] Resolving globals: FALSE
[09:29:19.087] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[09:29:19.088] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:19.088] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.088] 
[09:29:19.088] getGlobalsAndPackages() ... DONE
[09:29:19.089] run() for ‘Future’ ...
[09:29:19.089] - state: ‘created’
[09:29:19.089] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.102] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.102]   - Field: ‘node’
[09:29:19.102]   - Field: ‘label’
[09:29:19.103]   - Field: ‘local’
[09:29:19.103]   - Field: ‘owner’
[09:29:19.103]   - Field: ‘envir’
[09:29:19.103]   - Field: ‘workers’
[09:29:19.103]   - Field: ‘packages’
[09:29:19.103]   - Field: ‘gc’
[09:29:19.103]   - Field: ‘conditions’
[09:29:19.103]   - Field: ‘persistent’
[09:29:19.103]   - Field: ‘expr’
[09:29:19.103]   - Field: ‘uuid’
[09:29:19.103]   - Field: ‘seed’
[09:29:19.104]   - Field: ‘version’
[09:29:19.104]   - Field: ‘result’
[09:29:19.104]   - Field: ‘asynchronous’
[09:29:19.104]   - Field: ‘calls’
[09:29:19.104]   - Field: ‘globals’
[09:29:19.104]   - Field: ‘stdout’
[09:29:19.104]   - Field: ‘earlySignal’
[09:29:19.104]   - Field: ‘lazy’
[09:29:19.104]   - Field: ‘state’
[09:29:19.104] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.104] - Launch lazy future ...
[09:29:19.105] Packages needed by the future expression (n = 0): <none>
[09:29:19.105] Packages needed by future strategies (n = 0): <none>
[09:29:19.105] {
[09:29:19.105]     {
[09:29:19.105]         {
[09:29:19.105]             ...future.startTime <- base::Sys.time()
[09:29:19.105]             {
[09:29:19.105]                 {
[09:29:19.105]                   {
[09:29:19.105]                     {
[09:29:19.105]                       base::local({
[09:29:19.105]                         has_future <- base::requireNamespace("future", 
[09:29:19.105]                           quietly = TRUE)
[09:29:19.105]                         if (has_future) {
[09:29:19.105]                           ns <- base::getNamespace("future")
[09:29:19.105]                           version <- ns[[".package"]][["version"]]
[09:29:19.105]                           if (is.null(version)) 
[09:29:19.105]                             version <- utils::packageVersion("future")
[09:29:19.105]                         }
[09:29:19.105]                         else {
[09:29:19.105]                           version <- NULL
[09:29:19.105]                         }
[09:29:19.105]                         if (!has_future || version < "1.8.0") {
[09:29:19.105]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.105]                             "", base::R.version$version.string), 
[09:29:19.105]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.105]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.105]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.105]                               "release", "version")], collapse = " "), 
[09:29:19.105]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.105]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.105]                             info)
[09:29:19.105]                           info <- base::paste(info, collapse = "; ")
[09:29:19.105]                           if (!has_future) {
[09:29:19.105]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.105]                               info)
[09:29:19.105]                           }
[09:29:19.105]                           else {
[09:29:19.105]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.105]                               info, version)
[09:29:19.105]                           }
[09:29:19.105]                           base::stop(msg)
[09:29:19.105]                         }
[09:29:19.105]                       })
[09:29:19.105]                     }
[09:29:19.105]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.105]                     base::options(mc.cores = 1L)
[09:29:19.105]                   }
[09:29:19.105]                   ...future.strategy.old <- future::plan("list")
[09:29:19.105]                   options(future.plan = NULL)
[09:29:19.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.105]                 }
[09:29:19.105]                 ...future.workdir <- getwd()
[09:29:19.105]             }
[09:29:19.105]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.105]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.105]         }
[09:29:19.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.105]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:19.105]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.105]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.105]             base::names(...future.oldOptions))
[09:29:19.105]     }
[09:29:19.105]     if (FALSE) {
[09:29:19.105]     }
[09:29:19.105]     else {
[09:29:19.105]         if (TRUE) {
[09:29:19.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.105]                 open = "w")
[09:29:19.105]         }
[09:29:19.105]         else {
[09:29:19.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.105]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.105]         }
[09:29:19.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.105]             base::sink(type = "output", split = FALSE)
[09:29:19.105]             base::close(...future.stdout)
[09:29:19.105]         }, add = TRUE)
[09:29:19.105]     }
[09:29:19.105]     ...future.frame <- base::sys.nframe()
[09:29:19.105]     ...future.conditions <- base::list()
[09:29:19.105]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.105]     if (FALSE) {
[09:29:19.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.105]     }
[09:29:19.105]     ...future.result <- base::tryCatch({
[09:29:19.105]         base::withCallingHandlers({
[09:29:19.105]             ...future.value <- base::withVisible(base::local({
[09:29:19.105]                 ...future.makeSendCondition <- base::local({
[09:29:19.105]                   sendCondition <- NULL
[09:29:19.105]                   function(frame = 1L) {
[09:29:19.105]                     if (is.function(sendCondition)) 
[09:29:19.105]                       return(sendCondition)
[09:29:19.105]                     ns <- getNamespace("parallel")
[09:29:19.105]                     if (exists("sendData", mode = "function", 
[09:29:19.105]                       envir = ns)) {
[09:29:19.105]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.105]                         envir = ns)
[09:29:19.105]                       envir <- sys.frame(frame)
[09:29:19.105]                       master <- NULL
[09:29:19.105]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.105]                         !identical(envir, emptyenv())) {
[09:29:19.105]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.105]                           inherits = FALSE)) {
[09:29:19.105]                           master <- get("master", mode = "list", 
[09:29:19.105]                             envir = envir, inherits = FALSE)
[09:29:19.105]                           if (inherits(master, c("SOCKnode", 
[09:29:19.105]                             "SOCK0node"))) {
[09:29:19.105]                             sendCondition <<- function(cond) {
[09:29:19.105]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.105]                                 success = TRUE)
[09:29:19.105]                               parallel_sendData(master, data)
[09:29:19.105]                             }
[09:29:19.105]                             return(sendCondition)
[09:29:19.105]                           }
[09:29:19.105]                         }
[09:29:19.105]                         frame <- frame + 1L
[09:29:19.105]                         envir <- sys.frame(frame)
[09:29:19.105]                       }
[09:29:19.105]                     }
[09:29:19.105]                     sendCondition <<- function(cond) NULL
[09:29:19.105]                   }
[09:29:19.105]                 })
[09:29:19.105]                 withCallingHandlers({
[09:29:19.105]                   {
[09:29:19.105]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.105]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.105]                       ...future.globals.maxSize)) {
[09:29:19.105]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.105]                       on.exit(options(oopts), add = TRUE)
[09:29:19.105]                     }
[09:29:19.105]                     {
[09:29:19.105]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.105]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.105]                         USE.NAMES = FALSE)
[09:29:19.105]                       do.call(mapply, args = args)
[09:29:19.105]                     }
[09:29:19.105]                   }
[09:29:19.105]                 }, immediateCondition = function(cond) {
[09:29:19.105]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.105]                   sendCondition(cond)
[09:29:19.105]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.105]                   {
[09:29:19.105]                     inherits <- base::inherits
[09:29:19.105]                     invokeRestart <- base::invokeRestart
[09:29:19.105]                     is.null <- base::is.null
[09:29:19.105]                     muffled <- FALSE
[09:29:19.105]                     if (inherits(cond, "message")) {
[09:29:19.105]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.105]                       if (muffled) 
[09:29:19.105]                         invokeRestart("muffleMessage")
[09:29:19.105]                     }
[09:29:19.105]                     else if (inherits(cond, "warning")) {
[09:29:19.105]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.105]                       if (muffled) 
[09:29:19.105]                         invokeRestart("muffleWarning")
[09:29:19.105]                     }
[09:29:19.105]                     else if (inherits(cond, "condition")) {
[09:29:19.105]                       if (!is.null(pattern)) {
[09:29:19.105]                         computeRestarts <- base::computeRestarts
[09:29:19.105]                         grepl <- base::grepl
[09:29:19.105]                         restarts <- computeRestarts(cond)
[09:29:19.105]                         for (restart in restarts) {
[09:29:19.105]                           name <- restart$name
[09:29:19.105]                           if (is.null(name)) 
[09:29:19.105]                             next
[09:29:19.105]                           if (!grepl(pattern, name)) 
[09:29:19.105]                             next
[09:29:19.105]                           invokeRestart(restart)
[09:29:19.105]                           muffled <- TRUE
[09:29:19.105]                           break
[09:29:19.105]                         }
[09:29:19.105]                       }
[09:29:19.105]                     }
[09:29:19.105]                     invisible(muffled)
[09:29:19.105]                   }
[09:29:19.105]                   muffleCondition(cond)
[09:29:19.105]                 })
[09:29:19.105]             }))
[09:29:19.105]             future::FutureResult(value = ...future.value$value, 
[09:29:19.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.105]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.105]                     ...future.globalenv.names))
[09:29:19.105]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.105]         }, condition = base::local({
[09:29:19.105]             c <- base::c
[09:29:19.105]             inherits <- base::inherits
[09:29:19.105]             invokeRestart <- base::invokeRestart
[09:29:19.105]             length <- base::length
[09:29:19.105]             list <- base::list
[09:29:19.105]             seq.int <- base::seq.int
[09:29:19.105]             signalCondition <- base::signalCondition
[09:29:19.105]             sys.calls <- base::sys.calls
[09:29:19.105]             `[[` <- base::`[[`
[09:29:19.105]             `+` <- base::`+`
[09:29:19.105]             `<<-` <- base::`<<-`
[09:29:19.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.105]                   3L)]
[09:29:19.105]             }
[09:29:19.105]             function(cond) {
[09:29:19.105]                 is_error <- inherits(cond, "error")
[09:29:19.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.105]                   NULL)
[09:29:19.105]                 if (is_error) {
[09:29:19.105]                   sessionInformation <- function() {
[09:29:19.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.105]                       search = base::search(), system = base::Sys.info())
[09:29:19.105]                   }
[09:29:19.105]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.105]                     cond$call), session = sessionInformation(), 
[09:29:19.105]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.105]                   signalCondition(cond)
[09:29:19.105]                 }
[09:29:19.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.105]                 "immediateCondition"))) {
[09:29:19.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.105]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.105]                   if (TRUE && !signal) {
[09:29:19.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.105]                     {
[09:29:19.105]                       inherits <- base::inherits
[09:29:19.105]                       invokeRestart <- base::invokeRestart
[09:29:19.105]                       is.null <- base::is.null
[09:29:19.105]                       muffled <- FALSE
[09:29:19.105]                       if (inherits(cond, "message")) {
[09:29:19.105]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.105]                         if (muffled) 
[09:29:19.105]                           invokeRestart("muffleMessage")
[09:29:19.105]                       }
[09:29:19.105]                       else if (inherits(cond, "warning")) {
[09:29:19.105]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.105]                         if (muffled) 
[09:29:19.105]                           invokeRestart("muffleWarning")
[09:29:19.105]                       }
[09:29:19.105]                       else if (inherits(cond, "condition")) {
[09:29:19.105]                         if (!is.null(pattern)) {
[09:29:19.105]                           computeRestarts <- base::computeRestarts
[09:29:19.105]                           grepl <- base::grepl
[09:29:19.105]                           restarts <- computeRestarts(cond)
[09:29:19.105]                           for (restart in restarts) {
[09:29:19.105]                             name <- restart$name
[09:29:19.105]                             if (is.null(name)) 
[09:29:19.105]                               next
[09:29:19.105]                             if (!grepl(pattern, name)) 
[09:29:19.105]                               next
[09:29:19.105]                             invokeRestart(restart)
[09:29:19.105]                             muffled <- TRUE
[09:29:19.105]                             break
[09:29:19.105]                           }
[09:29:19.105]                         }
[09:29:19.105]                       }
[09:29:19.105]                       invisible(muffled)
[09:29:19.105]                     }
[09:29:19.105]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.105]                   }
[09:29:19.105]                 }
[09:29:19.105]                 else {
[09:29:19.105]                   if (TRUE) {
[09:29:19.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.105]                     {
[09:29:19.105]                       inherits <- base::inherits
[09:29:19.105]                       invokeRestart <- base::invokeRestart
[09:29:19.105]                       is.null <- base::is.null
[09:29:19.105]                       muffled <- FALSE
[09:29:19.105]                       if (inherits(cond, "message")) {
[09:29:19.105]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.105]                         if (muffled) 
[09:29:19.105]                           invokeRestart("muffleMessage")
[09:29:19.105]                       }
[09:29:19.105]                       else if (inherits(cond, "warning")) {
[09:29:19.105]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.105]                         if (muffled) 
[09:29:19.105]                           invokeRestart("muffleWarning")
[09:29:19.105]                       }
[09:29:19.105]                       else if (inherits(cond, "condition")) {
[09:29:19.105]                         if (!is.null(pattern)) {
[09:29:19.105]                           computeRestarts <- base::computeRestarts
[09:29:19.105]                           grepl <- base::grepl
[09:29:19.105]                           restarts <- computeRestarts(cond)
[09:29:19.105]                           for (restart in restarts) {
[09:29:19.105]                             name <- restart$name
[09:29:19.105]                             if (is.null(name)) 
[09:29:19.105]                               next
[09:29:19.105]                             if (!grepl(pattern, name)) 
[09:29:19.105]                               next
[09:29:19.105]                             invokeRestart(restart)
[09:29:19.105]                             muffled <- TRUE
[09:29:19.105]                             break
[09:29:19.105]                           }
[09:29:19.105]                         }
[09:29:19.105]                       }
[09:29:19.105]                       invisible(muffled)
[09:29:19.105]                     }
[09:29:19.105]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.105]                   }
[09:29:19.105]                 }
[09:29:19.105]             }
[09:29:19.105]         }))
[09:29:19.105]     }, error = function(ex) {
[09:29:19.105]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.105]                 ...future.rng), started = ...future.startTime, 
[09:29:19.105]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.105]             version = "1.8"), class = "FutureResult")
[09:29:19.105]     }, finally = {
[09:29:19.105]         if (!identical(...future.workdir, getwd())) 
[09:29:19.105]             setwd(...future.workdir)
[09:29:19.105]         {
[09:29:19.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.105]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.105]             }
[09:29:19.105]             base::options(...future.oldOptions)
[09:29:19.105]             if (.Platform$OS.type == "windows") {
[09:29:19.105]                 old_names <- names(...future.oldEnvVars)
[09:29:19.105]                 envs <- base::Sys.getenv()
[09:29:19.105]                 names <- names(envs)
[09:29:19.105]                 common <- intersect(names, old_names)
[09:29:19.105]                 added <- setdiff(names, old_names)
[09:29:19.105]                 removed <- setdiff(old_names, names)
[09:29:19.105]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.105]                   envs[common]]
[09:29:19.105]                 NAMES <- toupper(changed)
[09:29:19.105]                 args <- list()
[09:29:19.105]                 for (kk in seq_along(NAMES)) {
[09:29:19.105]                   name <- changed[[kk]]
[09:29:19.105]                   NAME <- NAMES[[kk]]
[09:29:19.105]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.105]                     next
[09:29:19.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.105]                 }
[09:29:19.105]                 NAMES <- toupper(added)
[09:29:19.105]                 for (kk in seq_along(NAMES)) {
[09:29:19.105]                   name <- added[[kk]]
[09:29:19.105]                   NAME <- NAMES[[kk]]
[09:29:19.105]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.105]                     next
[09:29:19.105]                   args[[name]] <- ""
[09:29:19.105]                 }
[09:29:19.105]                 NAMES <- toupper(removed)
[09:29:19.105]                 for (kk in seq_along(NAMES)) {
[09:29:19.105]                   name <- removed[[kk]]
[09:29:19.105]                   NAME <- NAMES[[kk]]
[09:29:19.105]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.105]                     next
[09:29:19.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.105]                 }
[09:29:19.105]                 if (length(args) > 0) 
[09:29:19.105]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.105]             }
[09:29:19.105]             else {
[09:29:19.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.105]             }
[09:29:19.105]             {
[09:29:19.105]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.105]                   0L) {
[09:29:19.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.105]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.105]                   base::options(opts)
[09:29:19.105]                 }
[09:29:19.105]                 {
[09:29:19.105]                   {
[09:29:19.105]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.105]                     NULL
[09:29:19.105]                   }
[09:29:19.105]                   options(future.plan = NULL)
[09:29:19.105]                   if (is.na(NA_character_)) 
[09:29:19.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.105]                     .init = FALSE)
[09:29:19.105]                 }
[09:29:19.105]             }
[09:29:19.105]         }
[09:29:19.105]     })
[09:29:19.105]     if (TRUE) {
[09:29:19.105]         base::sink(type = "output", split = FALSE)
[09:29:19.105]         if (TRUE) {
[09:29:19.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.105]         }
[09:29:19.105]         else {
[09:29:19.105]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.105]         }
[09:29:19.105]         base::close(...future.stdout)
[09:29:19.105]         ...future.stdout <- NULL
[09:29:19.105]     }
[09:29:19.105]     ...future.result$conditions <- ...future.conditions
[09:29:19.105]     ...future.result$finished <- base::Sys.time()
[09:29:19.105]     ...future.result
[09:29:19.105] }
[09:29:19.108] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[09:29:19.108] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[09:29:19.108] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[09:29:19.109] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:19.109] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.109] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[09:29:19.109] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[09:29:19.109] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:19.110] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.110] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:19.110] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.110] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[09:29:19.111] MultisessionFuture started
[09:29:19.111] - Launch lazy future ... done
[09:29:19.111] run() for ‘MultisessionFuture’ ... done
[09:29:19.111] Created future:
[09:29:19.111] MultisessionFuture:
[09:29:19.111] Label: ‘future_.mapply-1’
[09:29:19.111] Expression:
[09:29:19.111] {
[09:29:19.111]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.111]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.111]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.111]         on.exit(options(oopts), add = TRUE)
[09:29:19.111]     }
[09:29:19.111]     {
[09:29:19.111]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.111]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.111]         do.call(mapply, args = args)
[09:29:19.111]     }
[09:29:19.111] }
[09:29:19.111] Lazy evaluation: FALSE
[09:29:19.111] Asynchronous evaluation: TRUE
[09:29:19.111] Local evaluation: TRUE
[09:29:19.111] Environment: R_GlobalEnv
[09:29:19.111] Capture standard output: TRUE
[09:29:19.111] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.111] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.111] Packages: <none>
[09:29:19.111] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.111] Resolved: FALSE
[09:29:19.111] Value: <not collected>
[09:29:19.111] Conditions captured: <none>
[09:29:19.111] Early signaling: FALSE
[09:29:19.111] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.111] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.122] Chunk #1 of 2 ... DONE
[09:29:19.123] Chunk #2 of 2 ...
[09:29:19.123]  - Finding globals in '...' for chunk #2 ...
[09:29:19.123] getGlobalsAndPackages() ...
[09:29:19.123] Searching for globals...
[09:29:19.123] 
[09:29:19.123] Searching for globals ... DONE
[09:29:19.123] - globals: [0] <none>
[09:29:19.123] getGlobalsAndPackages() ... DONE
[09:29:19.124]    + additional globals found: [n=0] 
[09:29:19.124]    + additional namespaces needed: [n=0] 
[09:29:19.124]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:19.124]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:19.124]  - seeds: <none>
[09:29:19.124]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.124] getGlobalsAndPackages() ...
[09:29:19.124] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.124] Resolving globals: FALSE
[09:29:19.125] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[09:29:19.125] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:19.125] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.125] 
[09:29:19.126] getGlobalsAndPackages() ... DONE
[09:29:19.126] run() for ‘Future’ ...
[09:29:19.126] - state: ‘created’
[09:29:19.126] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.139] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.139] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.140]   - Field: ‘node’
[09:29:19.140]   - Field: ‘label’
[09:29:19.140]   - Field: ‘local’
[09:29:19.140]   - Field: ‘owner’
[09:29:19.140]   - Field: ‘envir’
[09:29:19.140]   - Field: ‘workers’
[09:29:19.140]   - Field: ‘packages’
[09:29:19.140]   - Field: ‘gc’
[09:29:19.140]   - Field: ‘conditions’
[09:29:19.140]   - Field: ‘persistent’
[09:29:19.141]   - Field: ‘expr’
[09:29:19.141]   - Field: ‘uuid’
[09:29:19.141]   - Field: ‘seed’
[09:29:19.141]   - Field: ‘version’
[09:29:19.141]   - Field: ‘result’
[09:29:19.141]   - Field: ‘asynchronous’
[09:29:19.141]   - Field: ‘calls’
[09:29:19.141]   - Field: ‘globals’
[09:29:19.141]   - Field: ‘stdout’
[09:29:19.141]   - Field: ‘earlySignal’
[09:29:19.141]   - Field: ‘lazy’
[09:29:19.141]   - Field: ‘state’
[09:29:19.142] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.142] - Launch lazy future ...
[09:29:19.142] Packages needed by the future expression (n = 0): <none>
[09:29:19.142] Packages needed by future strategies (n = 0): <none>
[09:29:19.144] {
[09:29:19.144]     {
[09:29:19.144]         {
[09:29:19.144]             ...future.startTime <- base::Sys.time()
[09:29:19.144]             {
[09:29:19.144]                 {
[09:29:19.144]                   {
[09:29:19.144]                     {
[09:29:19.144]                       base::local({
[09:29:19.144]                         has_future <- base::requireNamespace("future", 
[09:29:19.144]                           quietly = TRUE)
[09:29:19.144]                         if (has_future) {
[09:29:19.144]                           ns <- base::getNamespace("future")
[09:29:19.144]                           version <- ns[[".package"]][["version"]]
[09:29:19.144]                           if (is.null(version)) 
[09:29:19.144]                             version <- utils::packageVersion("future")
[09:29:19.144]                         }
[09:29:19.144]                         else {
[09:29:19.144]                           version <- NULL
[09:29:19.144]                         }
[09:29:19.144]                         if (!has_future || version < "1.8.0") {
[09:29:19.144]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.144]                             "", base::R.version$version.string), 
[09:29:19.144]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.144]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.144]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.144]                               "release", "version")], collapse = " "), 
[09:29:19.144]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.144]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.144]                             info)
[09:29:19.144]                           info <- base::paste(info, collapse = "; ")
[09:29:19.144]                           if (!has_future) {
[09:29:19.144]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.144]                               info)
[09:29:19.144]                           }
[09:29:19.144]                           else {
[09:29:19.144]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.144]                               info, version)
[09:29:19.144]                           }
[09:29:19.144]                           base::stop(msg)
[09:29:19.144]                         }
[09:29:19.144]                       })
[09:29:19.144]                     }
[09:29:19.144]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.144]                     base::options(mc.cores = 1L)
[09:29:19.144]                   }
[09:29:19.144]                   ...future.strategy.old <- future::plan("list")
[09:29:19.144]                   options(future.plan = NULL)
[09:29:19.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.144]                 }
[09:29:19.144]                 ...future.workdir <- getwd()
[09:29:19.144]             }
[09:29:19.144]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.144]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.144]         }
[09:29:19.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.144]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:19.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.144]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.144]             base::names(...future.oldOptions))
[09:29:19.144]     }
[09:29:19.144]     if (FALSE) {
[09:29:19.144]     }
[09:29:19.144]     else {
[09:29:19.144]         if (TRUE) {
[09:29:19.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.144]                 open = "w")
[09:29:19.144]         }
[09:29:19.144]         else {
[09:29:19.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.144]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.144]         }
[09:29:19.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.144]             base::sink(type = "output", split = FALSE)
[09:29:19.144]             base::close(...future.stdout)
[09:29:19.144]         }, add = TRUE)
[09:29:19.144]     }
[09:29:19.144]     ...future.frame <- base::sys.nframe()
[09:29:19.144]     ...future.conditions <- base::list()
[09:29:19.144]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.144]     if (FALSE) {
[09:29:19.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.144]     }
[09:29:19.144]     ...future.result <- base::tryCatch({
[09:29:19.144]         base::withCallingHandlers({
[09:29:19.144]             ...future.value <- base::withVisible(base::local({
[09:29:19.144]                 ...future.makeSendCondition <- base::local({
[09:29:19.144]                   sendCondition <- NULL
[09:29:19.144]                   function(frame = 1L) {
[09:29:19.144]                     if (is.function(sendCondition)) 
[09:29:19.144]                       return(sendCondition)
[09:29:19.144]                     ns <- getNamespace("parallel")
[09:29:19.144]                     if (exists("sendData", mode = "function", 
[09:29:19.144]                       envir = ns)) {
[09:29:19.144]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.144]                         envir = ns)
[09:29:19.144]                       envir <- sys.frame(frame)
[09:29:19.144]                       master <- NULL
[09:29:19.144]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.144]                         !identical(envir, emptyenv())) {
[09:29:19.144]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.144]                           inherits = FALSE)) {
[09:29:19.144]                           master <- get("master", mode = "list", 
[09:29:19.144]                             envir = envir, inherits = FALSE)
[09:29:19.144]                           if (inherits(master, c("SOCKnode", 
[09:29:19.144]                             "SOCK0node"))) {
[09:29:19.144]                             sendCondition <<- function(cond) {
[09:29:19.144]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.144]                                 success = TRUE)
[09:29:19.144]                               parallel_sendData(master, data)
[09:29:19.144]                             }
[09:29:19.144]                             return(sendCondition)
[09:29:19.144]                           }
[09:29:19.144]                         }
[09:29:19.144]                         frame <- frame + 1L
[09:29:19.144]                         envir <- sys.frame(frame)
[09:29:19.144]                       }
[09:29:19.144]                     }
[09:29:19.144]                     sendCondition <<- function(cond) NULL
[09:29:19.144]                   }
[09:29:19.144]                 })
[09:29:19.144]                 withCallingHandlers({
[09:29:19.144]                   {
[09:29:19.144]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.144]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.144]                       ...future.globals.maxSize)) {
[09:29:19.144]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.144]                       on.exit(options(oopts), add = TRUE)
[09:29:19.144]                     }
[09:29:19.144]                     {
[09:29:19.144]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.144]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.144]                         USE.NAMES = FALSE)
[09:29:19.144]                       do.call(mapply, args = args)
[09:29:19.144]                     }
[09:29:19.144]                   }
[09:29:19.144]                 }, immediateCondition = function(cond) {
[09:29:19.144]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.144]                   sendCondition(cond)
[09:29:19.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.144]                   {
[09:29:19.144]                     inherits <- base::inherits
[09:29:19.144]                     invokeRestart <- base::invokeRestart
[09:29:19.144]                     is.null <- base::is.null
[09:29:19.144]                     muffled <- FALSE
[09:29:19.144]                     if (inherits(cond, "message")) {
[09:29:19.144]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.144]                       if (muffled) 
[09:29:19.144]                         invokeRestart("muffleMessage")
[09:29:19.144]                     }
[09:29:19.144]                     else if (inherits(cond, "warning")) {
[09:29:19.144]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.144]                       if (muffled) 
[09:29:19.144]                         invokeRestart("muffleWarning")
[09:29:19.144]                     }
[09:29:19.144]                     else if (inherits(cond, "condition")) {
[09:29:19.144]                       if (!is.null(pattern)) {
[09:29:19.144]                         computeRestarts <- base::computeRestarts
[09:29:19.144]                         grepl <- base::grepl
[09:29:19.144]                         restarts <- computeRestarts(cond)
[09:29:19.144]                         for (restart in restarts) {
[09:29:19.144]                           name <- restart$name
[09:29:19.144]                           if (is.null(name)) 
[09:29:19.144]                             next
[09:29:19.144]                           if (!grepl(pattern, name)) 
[09:29:19.144]                             next
[09:29:19.144]                           invokeRestart(restart)
[09:29:19.144]                           muffled <- TRUE
[09:29:19.144]                           break
[09:29:19.144]                         }
[09:29:19.144]                       }
[09:29:19.144]                     }
[09:29:19.144]                     invisible(muffled)
[09:29:19.144]                   }
[09:29:19.144]                   muffleCondition(cond)
[09:29:19.144]                 })
[09:29:19.144]             }))
[09:29:19.144]             future::FutureResult(value = ...future.value$value, 
[09:29:19.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.144]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.144]                     ...future.globalenv.names))
[09:29:19.144]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.144]         }, condition = base::local({
[09:29:19.144]             c <- base::c
[09:29:19.144]             inherits <- base::inherits
[09:29:19.144]             invokeRestart <- base::invokeRestart
[09:29:19.144]             length <- base::length
[09:29:19.144]             list <- base::list
[09:29:19.144]             seq.int <- base::seq.int
[09:29:19.144]             signalCondition <- base::signalCondition
[09:29:19.144]             sys.calls <- base::sys.calls
[09:29:19.144]             `[[` <- base::`[[`
[09:29:19.144]             `+` <- base::`+`
[09:29:19.144]             `<<-` <- base::`<<-`
[09:29:19.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.144]                   3L)]
[09:29:19.144]             }
[09:29:19.144]             function(cond) {
[09:29:19.144]                 is_error <- inherits(cond, "error")
[09:29:19.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.144]                   NULL)
[09:29:19.144]                 if (is_error) {
[09:29:19.144]                   sessionInformation <- function() {
[09:29:19.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.144]                       search = base::search(), system = base::Sys.info())
[09:29:19.144]                   }
[09:29:19.144]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.144]                     cond$call), session = sessionInformation(), 
[09:29:19.144]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.144]                   signalCondition(cond)
[09:29:19.144]                 }
[09:29:19.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.144]                 "immediateCondition"))) {
[09:29:19.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.144]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.144]                   if (TRUE && !signal) {
[09:29:19.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.144]                     {
[09:29:19.144]                       inherits <- base::inherits
[09:29:19.144]                       invokeRestart <- base::invokeRestart
[09:29:19.144]                       is.null <- base::is.null
[09:29:19.144]                       muffled <- FALSE
[09:29:19.144]                       if (inherits(cond, "message")) {
[09:29:19.144]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.144]                         if (muffled) 
[09:29:19.144]                           invokeRestart("muffleMessage")
[09:29:19.144]                       }
[09:29:19.144]                       else if (inherits(cond, "warning")) {
[09:29:19.144]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.144]                         if (muffled) 
[09:29:19.144]                           invokeRestart("muffleWarning")
[09:29:19.144]                       }
[09:29:19.144]                       else if (inherits(cond, "condition")) {
[09:29:19.144]                         if (!is.null(pattern)) {
[09:29:19.144]                           computeRestarts <- base::computeRestarts
[09:29:19.144]                           grepl <- base::grepl
[09:29:19.144]                           restarts <- computeRestarts(cond)
[09:29:19.144]                           for (restart in restarts) {
[09:29:19.144]                             name <- restart$name
[09:29:19.144]                             if (is.null(name)) 
[09:29:19.144]                               next
[09:29:19.144]                             if (!grepl(pattern, name)) 
[09:29:19.144]                               next
[09:29:19.144]                             invokeRestart(restart)
[09:29:19.144]                             muffled <- TRUE
[09:29:19.144]                             break
[09:29:19.144]                           }
[09:29:19.144]                         }
[09:29:19.144]                       }
[09:29:19.144]                       invisible(muffled)
[09:29:19.144]                     }
[09:29:19.144]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.144]                   }
[09:29:19.144]                 }
[09:29:19.144]                 else {
[09:29:19.144]                   if (TRUE) {
[09:29:19.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.144]                     {
[09:29:19.144]                       inherits <- base::inherits
[09:29:19.144]                       invokeRestart <- base::invokeRestart
[09:29:19.144]                       is.null <- base::is.null
[09:29:19.144]                       muffled <- FALSE
[09:29:19.144]                       if (inherits(cond, "message")) {
[09:29:19.144]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.144]                         if (muffled) 
[09:29:19.144]                           invokeRestart("muffleMessage")
[09:29:19.144]                       }
[09:29:19.144]                       else if (inherits(cond, "warning")) {
[09:29:19.144]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.144]                         if (muffled) 
[09:29:19.144]                           invokeRestart("muffleWarning")
[09:29:19.144]                       }
[09:29:19.144]                       else if (inherits(cond, "condition")) {
[09:29:19.144]                         if (!is.null(pattern)) {
[09:29:19.144]                           computeRestarts <- base::computeRestarts
[09:29:19.144]                           grepl <- base::grepl
[09:29:19.144]                           restarts <- computeRestarts(cond)
[09:29:19.144]                           for (restart in restarts) {
[09:29:19.144]                             name <- restart$name
[09:29:19.144]                             if (is.null(name)) 
[09:29:19.144]                               next
[09:29:19.144]                             if (!grepl(pattern, name)) 
[09:29:19.144]                               next
[09:29:19.144]                             invokeRestart(restart)
[09:29:19.144]                             muffled <- TRUE
[09:29:19.144]                             break
[09:29:19.144]                           }
[09:29:19.144]                         }
[09:29:19.144]                       }
[09:29:19.144]                       invisible(muffled)
[09:29:19.144]                     }
[09:29:19.144]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.144]                   }
[09:29:19.144]                 }
[09:29:19.144]             }
[09:29:19.144]         }))
[09:29:19.144]     }, error = function(ex) {
[09:29:19.144]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.144]                 ...future.rng), started = ...future.startTime, 
[09:29:19.144]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.144]             version = "1.8"), class = "FutureResult")
[09:29:19.144]     }, finally = {
[09:29:19.144]         if (!identical(...future.workdir, getwd())) 
[09:29:19.144]             setwd(...future.workdir)
[09:29:19.144]         {
[09:29:19.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.144]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.144]             }
[09:29:19.144]             base::options(...future.oldOptions)
[09:29:19.144]             if (.Platform$OS.type == "windows") {
[09:29:19.144]                 old_names <- names(...future.oldEnvVars)
[09:29:19.144]                 envs <- base::Sys.getenv()
[09:29:19.144]                 names <- names(envs)
[09:29:19.144]                 common <- intersect(names, old_names)
[09:29:19.144]                 added <- setdiff(names, old_names)
[09:29:19.144]                 removed <- setdiff(old_names, names)
[09:29:19.144]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.144]                   envs[common]]
[09:29:19.144]                 NAMES <- toupper(changed)
[09:29:19.144]                 args <- list()
[09:29:19.144]                 for (kk in seq_along(NAMES)) {
[09:29:19.144]                   name <- changed[[kk]]
[09:29:19.144]                   NAME <- NAMES[[kk]]
[09:29:19.144]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.144]                     next
[09:29:19.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.144]                 }
[09:29:19.144]                 NAMES <- toupper(added)
[09:29:19.144]                 for (kk in seq_along(NAMES)) {
[09:29:19.144]                   name <- added[[kk]]
[09:29:19.144]                   NAME <- NAMES[[kk]]
[09:29:19.144]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.144]                     next
[09:29:19.144]                   args[[name]] <- ""
[09:29:19.144]                 }
[09:29:19.144]                 NAMES <- toupper(removed)
[09:29:19.144]                 for (kk in seq_along(NAMES)) {
[09:29:19.144]                   name <- removed[[kk]]
[09:29:19.144]                   NAME <- NAMES[[kk]]
[09:29:19.144]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.144]                     next
[09:29:19.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.144]                 }
[09:29:19.144]                 if (length(args) > 0) 
[09:29:19.144]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.144]             }
[09:29:19.144]             else {
[09:29:19.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.144]             }
[09:29:19.144]             {
[09:29:19.144]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.144]                   0L) {
[09:29:19.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.144]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.144]                   base::options(opts)
[09:29:19.144]                 }
[09:29:19.144]                 {
[09:29:19.144]                   {
[09:29:19.144]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.144]                     NULL
[09:29:19.144]                   }
[09:29:19.144]                   options(future.plan = NULL)
[09:29:19.144]                   if (is.na(NA_character_)) 
[09:29:19.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.144]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.144]                     .init = FALSE)
[09:29:19.144]                 }
[09:29:19.144]             }
[09:29:19.144]         }
[09:29:19.144]     })
[09:29:19.144]     if (TRUE) {
[09:29:19.144]         base::sink(type = "output", split = FALSE)
[09:29:19.144]         if (TRUE) {
[09:29:19.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.144]         }
[09:29:19.144]         else {
[09:29:19.144]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.144]         }
[09:29:19.144]         base::close(...future.stdout)
[09:29:19.144]         ...future.stdout <- NULL
[09:29:19.144]     }
[09:29:19.144]     ...future.result$conditions <- ...future.conditions
[09:29:19.144]     ...future.result$finished <- base::Sys.time()
[09:29:19.144]     ...future.result
[09:29:19.144] }
[09:29:19.147] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[09:29:19.147] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[09:29:19.148] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[09:29:19.148] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:19.148] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.148] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[09:29:19.149] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[09:29:19.149] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:19.149] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.149] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:19.149] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.150] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[09:29:19.150] MultisessionFuture started
[09:29:19.150] - Launch lazy future ... done
[09:29:19.150] run() for ‘MultisessionFuture’ ... done
[09:29:19.150] Created future:
[09:29:19.150] MultisessionFuture:
[09:29:19.150] Label: ‘future_.mapply-2’
[09:29:19.150] Expression:
[09:29:19.150] {
[09:29:19.150]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.150]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.150]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.150]         on.exit(options(oopts), add = TRUE)
[09:29:19.150]     }
[09:29:19.150]     {
[09:29:19.150]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.150]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.150]         do.call(mapply, args = args)
[09:29:19.150]     }
[09:29:19.150] }
[09:29:19.150] Lazy evaluation: FALSE
[09:29:19.150] Asynchronous evaluation: TRUE
[09:29:19.150] Local evaluation: TRUE
[09:29:19.150] Environment: R_GlobalEnv
[09:29:19.150] Capture standard output: TRUE
[09:29:19.150] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.150] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.150] Packages: <none>
[09:29:19.150] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.150] Resolved: FALSE
[09:29:19.150] Value: <not collected>
[09:29:19.150] Conditions captured: <none>
[09:29:19.150] Early signaling: FALSE
[09:29:19.150] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.150] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.162] Chunk #2 of 2 ... DONE
[09:29:19.162] Launching 2 futures (chunks) ... DONE
[09:29:19.162] Resolving 2 futures (chunks) ...
[09:29:19.162] resolve() on list ...
[09:29:19.162]  recursive: 0
[09:29:19.162]  length: 2
[09:29:19.162] 
[09:29:19.163] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.163] - Validating connection of MultisessionFuture
[09:29:19.163] - received message: FutureResult
[09:29:19.163] - Received FutureResult
[09:29:19.163] - Erased future from FutureRegistry
[09:29:19.163] result() for ClusterFuture ...
[09:29:19.164] - result already collected: FutureResult
[09:29:19.164] result() for ClusterFuture ... done
[09:29:19.164] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.164] Future #1
[09:29:19.164] result() for ClusterFuture ...
[09:29:19.164] - result already collected: FutureResult
[09:29:19.164] result() for ClusterFuture ... done
[09:29:19.164] result() for ClusterFuture ...
[09:29:19.164] - result already collected: FutureResult
[09:29:19.164] result() for ClusterFuture ... done
[09:29:19.164] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:19.165] - nx: 2
[09:29:19.165] - relay: TRUE
[09:29:19.165] - stdout: TRUE
[09:29:19.165] - signal: TRUE
[09:29:19.165] - resignal: FALSE
[09:29:19.165] - force: TRUE
[09:29:19.165] - relayed: [n=2] FALSE, FALSE
[09:29:19.165] - queued futures: [n=2] FALSE, FALSE
[09:29:19.165]  - until=1
[09:29:19.165]  - relaying element #1
[09:29:19.165] result() for ClusterFuture ...
[09:29:19.165] - result already collected: FutureResult
[09:29:19.166] result() for ClusterFuture ... done
[09:29:19.166] result() for ClusterFuture ...
[09:29:19.166] - result already collected: FutureResult
[09:29:19.166] result() for ClusterFuture ... done
[09:29:19.166] result() for ClusterFuture ...
[09:29:19.166] - result already collected: FutureResult
[09:29:19.166] result() for ClusterFuture ... done
[09:29:19.166] result() for ClusterFuture ...
[09:29:19.166] - result already collected: FutureResult
[09:29:19.166] result() for ClusterFuture ... done
[09:29:19.166] - relayed: [n=2] TRUE, FALSE
[09:29:19.166] - queued futures: [n=2] TRUE, FALSE
[09:29:19.167] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:19.167]  length: 1 (resolved future 1)
[09:29:19.193] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.194] - Validating connection of MultisessionFuture
[09:29:19.194] - received message: FutureResult
[09:29:19.194] - Received FutureResult
[09:29:19.194] - Erased future from FutureRegistry
[09:29:19.194] result() for ClusterFuture ...
[09:29:19.194] - result already collected: FutureResult
[09:29:19.194] result() for ClusterFuture ... done
[09:29:19.194] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.194] Future #2
[09:29:19.194] result() for ClusterFuture ...
[09:29:19.194] - result already collected: FutureResult
[09:29:19.195] result() for ClusterFuture ... done
[09:29:19.195] result() for ClusterFuture ...
[09:29:19.195] - result already collected: FutureResult
[09:29:19.195] result() for ClusterFuture ... done
[09:29:19.195] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:19.195] - nx: 2
[09:29:19.195] - relay: TRUE
[09:29:19.195] - stdout: TRUE
[09:29:19.195] - signal: TRUE
[09:29:19.195] - resignal: FALSE
[09:29:19.195] - force: TRUE
[09:29:19.195] - relayed: [n=2] TRUE, FALSE
[09:29:19.196] - queued futures: [n=2] TRUE, FALSE
[09:29:19.196]  - until=2
[09:29:19.196]  - relaying element #2
[09:29:19.196] result() for ClusterFuture ...
[09:29:19.196] - result already collected: FutureResult
[09:29:19.196] result() for ClusterFuture ... done
[09:29:19.196] result() for ClusterFuture ...
[09:29:19.196] - result already collected: FutureResult
[09:29:19.196] result() for ClusterFuture ... done
[09:29:19.196] result() for ClusterFuture ...
[09:29:19.196] - result already collected: FutureResult
[09:29:19.197] result() for ClusterFuture ... done
[09:29:19.197] result() for ClusterFuture ...
[09:29:19.197] - result already collected: FutureResult
[09:29:19.197] result() for ClusterFuture ... done
[09:29:19.197] - relayed: [n=2] TRUE, TRUE
[09:29:19.197] - queued futures: [n=2] TRUE, TRUE
[09:29:19.197] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:19.197]  length: 0 (resolved future 2)
[09:29:19.197] Relaying remaining futures
[09:29:19.197] signalConditionsASAP(NULL, pos=0) ...
[09:29:19.197] - nx: 2
[09:29:19.197] - relay: TRUE
[09:29:19.198] - stdout: TRUE
[09:29:19.198] - signal: TRUE
[09:29:19.198] - resignal: FALSE
[09:29:19.198] - force: TRUE
[09:29:19.198] - relayed: [n=2] TRUE, TRUE
[09:29:19.198] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:19.198] - relayed: [n=2] TRUE, TRUE
[09:29:19.198] - queued futures: [n=2] TRUE, TRUE
[09:29:19.198] signalConditionsASAP(NULL, pos=0) ... done
[09:29:19.198] resolve() on list ... DONE
[09:29:19.198] result() for ClusterFuture ...
[09:29:19.198] - result already collected: FutureResult
[09:29:19.199] result() for ClusterFuture ... done
[09:29:19.199] result() for ClusterFuture ...
[09:29:19.199] - result already collected: FutureResult
[09:29:19.199] result() for ClusterFuture ... done
[09:29:19.199] result() for ClusterFuture ...
[09:29:19.199] - result already collected: FutureResult
[09:29:19.199] result() for ClusterFuture ... done
[09:29:19.199] result() for ClusterFuture ...
[09:29:19.199] - result already collected: FutureResult
[09:29:19.199] result() for ClusterFuture ... done
[09:29:19.199]  - Number of value chunks collected: 2
[09:29:19.200] Resolving 2 futures (chunks) ... DONE
[09:29:19.200] Reducing values from 2 chunks ...
[09:29:19.200]  - Number of values collected after concatenation: 3
[09:29:19.200]  - Number of values expected: 3
[09:29:19.200] Reducing values from 2 chunks ... DONE
[09:29:19.200] future_mapply() ... DONE
[09:29:19.200] future_mapply() ...
[09:29:19.204] Number of chunks: 5
[09:29:19.204] getGlobalsAndPackagesXApply() ...
[09:29:19.204]  - future.globals: TRUE
[09:29:19.204] getGlobalsAndPackages() ...
[09:29:19.204] Searching for globals...
[09:29:19.205] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:19.205] Searching for globals ... DONE
[09:29:19.205] Resolving globals: FALSE
[09:29:19.206] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:19.206] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:19.206] - globals: [1] ‘FUN’
[09:29:19.206] 
[09:29:19.206] getGlobalsAndPackages() ... DONE
[09:29:19.206]  - globals found/used: [n=1] ‘FUN’
[09:29:19.207]  - needed namespaces: [n=0] 
[09:29:19.207] Finding globals ... DONE
[09:29:19.207] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:19.207] List of 2
[09:29:19.207]  $ ...future.FUN:function (C, k)  
[09:29:19.207]  $ MoreArgs     : NULL
[09:29:19.207]  - attr(*, "where")=List of 2
[09:29:19.207]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:19.207]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:19.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:19.207]  - attr(*, "resolved")= logi FALSE
[09:29:19.207]  - attr(*, "total_size")= num NA
[09:29:19.209] Packages to be attached in all futures: [n=0] 
[09:29:19.209] getGlobalsAndPackagesXApply() ... DONE
[09:29:19.210] Number of futures (= number of chunks): 5
[09:29:19.210] Launching 5 futures (chunks) ...
[09:29:19.210] Chunk #1 of 5 ...
[09:29:19.210]  - Finding globals in '...' for chunk #1 ...
[09:29:19.210] getGlobalsAndPackages() ...
[09:29:19.210] Searching for globals...
[09:29:19.210] 
[09:29:19.211] Searching for globals ... DONE
[09:29:19.211] - globals: [0] <none>
[09:29:19.211] getGlobalsAndPackages() ... DONE
[09:29:19.211]    + additional globals found: [n=0] 
[09:29:19.211]    + additional namespaces needed: [n=0] 
[09:29:19.211]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:19.211]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:19.211]  - seeds: <none>
[09:29:19.211]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.211] getGlobalsAndPackages() ...
[09:29:19.211] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.212] Resolving globals: FALSE
[09:29:19.212] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:19.212] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:19.213] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.213] 
[09:29:19.213] getGlobalsAndPackages() ... DONE
[09:29:19.213] run() for ‘Future’ ...
[09:29:19.213] - state: ‘created’
[09:29:19.213] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.227] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.227] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.227]   - Field: ‘node’
[09:29:19.227]   - Field: ‘label’
[09:29:19.227]   - Field: ‘local’
[09:29:19.227]   - Field: ‘owner’
[09:29:19.227]   - Field: ‘envir’
[09:29:19.227]   - Field: ‘workers’
[09:29:19.227]   - Field: ‘packages’
[09:29:19.228]   - Field: ‘gc’
[09:29:19.228]   - Field: ‘conditions’
[09:29:19.228]   - Field: ‘persistent’
[09:29:19.228]   - Field: ‘expr’
[09:29:19.228]   - Field: ‘uuid’
[09:29:19.228]   - Field: ‘seed’
[09:29:19.228]   - Field: ‘version’
[09:29:19.228]   - Field: ‘result’
[09:29:19.228]   - Field: ‘asynchronous’
[09:29:19.228]   - Field: ‘calls’
[09:29:19.228]   - Field: ‘globals’
[09:29:19.229]   - Field: ‘stdout’
[09:29:19.229]   - Field: ‘earlySignal’
[09:29:19.229]   - Field: ‘lazy’
[09:29:19.229]   - Field: ‘state’
[09:29:19.229] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.229] - Launch lazy future ...
[09:29:19.229] Packages needed by the future expression (n = 0): <none>
[09:29:19.229] Packages needed by future strategies (n = 0): <none>
[09:29:19.230] {
[09:29:19.230]     {
[09:29:19.230]         {
[09:29:19.230]             ...future.startTime <- base::Sys.time()
[09:29:19.230]             {
[09:29:19.230]                 {
[09:29:19.230]                   {
[09:29:19.230]                     {
[09:29:19.230]                       base::local({
[09:29:19.230]                         has_future <- base::requireNamespace("future", 
[09:29:19.230]                           quietly = TRUE)
[09:29:19.230]                         if (has_future) {
[09:29:19.230]                           ns <- base::getNamespace("future")
[09:29:19.230]                           version <- ns[[".package"]][["version"]]
[09:29:19.230]                           if (is.null(version)) 
[09:29:19.230]                             version <- utils::packageVersion("future")
[09:29:19.230]                         }
[09:29:19.230]                         else {
[09:29:19.230]                           version <- NULL
[09:29:19.230]                         }
[09:29:19.230]                         if (!has_future || version < "1.8.0") {
[09:29:19.230]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.230]                             "", base::R.version$version.string), 
[09:29:19.230]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.230]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.230]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.230]                               "release", "version")], collapse = " "), 
[09:29:19.230]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.230]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.230]                             info)
[09:29:19.230]                           info <- base::paste(info, collapse = "; ")
[09:29:19.230]                           if (!has_future) {
[09:29:19.230]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.230]                               info)
[09:29:19.230]                           }
[09:29:19.230]                           else {
[09:29:19.230]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.230]                               info, version)
[09:29:19.230]                           }
[09:29:19.230]                           base::stop(msg)
[09:29:19.230]                         }
[09:29:19.230]                       })
[09:29:19.230]                     }
[09:29:19.230]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.230]                     base::options(mc.cores = 1L)
[09:29:19.230]                   }
[09:29:19.230]                   ...future.strategy.old <- future::plan("list")
[09:29:19.230]                   options(future.plan = NULL)
[09:29:19.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.230]                 }
[09:29:19.230]                 ...future.workdir <- getwd()
[09:29:19.230]             }
[09:29:19.230]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.230]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.230]         }
[09:29:19.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.230]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:19.230]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.230]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.230]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.230]             base::names(...future.oldOptions))
[09:29:19.230]     }
[09:29:19.230]     if (FALSE) {
[09:29:19.230]     }
[09:29:19.230]     else {
[09:29:19.230]         if (TRUE) {
[09:29:19.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.230]                 open = "w")
[09:29:19.230]         }
[09:29:19.230]         else {
[09:29:19.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.230]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.230]         }
[09:29:19.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.230]             base::sink(type = "output", split = FALSE)
[09:29:19.230]             base::close(...future.stdout)
[09:29:19.230]         }, add = TRUE)
[09:29:19.230]     }
[09:29:19.230]     ...future.frame <- base::sys.nframe()
[09:29:19.230]     ...future.conditions <- base::list()
[09:29:19.230]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.230]     if (FALSE) {
[09:29:19.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.230]     }
[09:29:19.230]     ...future.result <- base::tryCatch({
[09:29:19.230]         base::withCallingHandlers({
[09:29:19.230]             ...future.value <- base::withVisible(base::local({
[09:29:19.230]                 ...future.makeSendCondition <- base::local({
[09:29:19.230]                   sendCondition <- NULL
[09:29:19.230]                   function(frame = 1L) {
[09:29:19.230]                     if (is.function(sendCondition)) 
[09:29:19.230]                       return(sendCondition)
[09:29:19.230]                     ns <- getNamespace("parallel")
[09:29:19.230]                     if (exists("sendData", mode = "function", 
[09:29:19.230]                       envir = ns)) {
[09:29:19.230]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.230]                         envir = ns)
[09:29:19.230]                       envir <- sys.frame(frame)
[09:29:19.230]                       master <- NULL
[09:29:19.230]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.230]                         !identical(envir, emptyenv())) {
[09:29:19.230]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.230]                           inherits = FALSE)) {
[09:29:19.230]                           master <- get("master", mode = "list", 
[09:29:19.230]                             envir = envir, inherits = FALSE)
[09:29:19.230]                           if (inherits(master, c("SOCKnode", 
[09:29:19.230]                             "SOCK0node"))) {
[09:29:19.230]                             sendCondition <<- function(cond) {
[09:29:19.230]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.230]                                 success = TRUE)
[09:29:19.230]                               parallel_sendData(master, data)
[09:29:19.230]                             }
[09:29:19.230]                             return(sendCondition)
[09:29:19.230]                           }
[09:29:19.230]                         }
[09:29:19.230]                         frame <- frame + 1L
[09:29:19.230]                         envir <- sys.frame(frame)
[09:29:19.230]                       }
[09:29:19.230]                     }
[09:29:19.230]                     sendCondition <<- function(cond) NULL
[09:29:19.230]                   }
[09:29:19.230]                 })
[09:29:19.230]                 withCallingHandlers({
[09:29:19.230]                   {
[09:29:19.230]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.230]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.230]                       ...future.globals.maxSize)) {
[09:29:19.230]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.230]                       on.exit(options(oopts), add = TRUE)
[09:29:19.230]                     }
[09:29:19.230]                     {
[09:29:19.230]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.230]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.230]                         USE.NAMES = FALSE)
[09:29:19.230]                       do.call(mapply, args = args)
[09:29:19.230]                     }
[09:29:19.230]                   }
[09:29:19.230]                 }, immediateCondition = function(cond) {
[09:29:19.230]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.230]                   sendCondition(cond)
[09:29:19.230]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.230]                   {
[09:29:19.230]                     inherits <- base::inherits
[09:29:19.230]                     invokeRestart <- base::invokeRestart
[09:29:19.230]                     is.null <- base::is.null
[09:29:19.230]                     muffled <- FALSE
[09:29:19.230]                     if (inherits(cond, "message")) {
[09:29:19.230]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.230]                       if (muffled) 
[09:29:19.230]                         invokeRestart("muffleMessage")
[09:29:19.230]                     }
[09:29:19.230]                     else if (inherits(cond, "warning")) {
[09:29:19.230]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.230]                       if (muffled) 
[09:29:19.230]                         invokeRestart("muffleWarning")
[09:29:19.230]                     }
[09:29:19.230]                     else if (inherits(cond, "condition")) {
[09:29:19.230]                       if (!is.null(pattern)) {
[09:29:19.230]                         computeRestarts <- base::computeRestarts
[09:29:19.230]                         grepl <- base::grepl
[09:29:19.230]                         restarts <- computeRestarts(cond)
[09:29:19.230]                         for (restart in restarts) {
[09:29:19.230]                           name <- restart$name
[09:29:19.230]                           if (is.null(name)) 
[09:29:19.230]                             next
[09:29:19.230]                           if (!grepl(pattern, name)) 
[09:29:19.230]                             next
[09:29:19.230]                           invokeRestart(restart)
[09:29:19.230]                           muffled <- TRUE
[09:29:19.230]                           break
[09:29:19.230]                         }
[09:29:19.230]                       }
[09:29:19.230]                     }
[09:29:19.230]                     invisible(muffled)
[09:29:19.230]                   }
[09:29:19.230]                   muffleCondition(cond)
[09:29:19.230]                 })
[09:29:19.230]             }))
[09:29:19.230]             future::FutureResult(value = ...future.value$value, 
[09:29:19.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.230]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.230]                     ...future.globalenv.names))
[09:29:19.230]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.230]         }, condition = base::local({
[09:29:19.230]             c <- base::c
[09:29:19.230]             inherits <- base::inherits
[09:29:19.230]             invokeRestart <- base::invokeRestart
[09:29:19.230]             length <- base::length
[09:29:19.230]             list <- base::list
[09:29:19.230]             seq.int <- base::seq.int
[09:29:19.230]             signalCondition <- base::signalCondition
[09:29:19.230]             sys.calls <- base::sys.calls
[09:29:19.230]             `[[` <- base::`[[`
[09:29:19.230]             `+` <- base::`+`
[09:29:19.230]             `<<-` <- base::`<<-`
[09:29:19.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.230]                   3L)]
[09:29:19.230]             }
[09:29:19.230]             function(cond) {
[09:29:19.230]                 is_error <- inherits(cond, "error")
[09:29:19.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.230]                   NULL)
[09:29:19.230]                 if (is_error) {
[09:29:19.230]                   sessionInformation <- function() {
[09:29:19.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.230]                       search = base::search(), system = base::Sys.info())
[09:29:19.230]                   }
[09:29:19.230]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.230]                     cond$call), session = sessionInformation(), 
[09:29:19.230]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.230]                   signalCondition(cond)
[09:29:19.230]                 }
[09:29:19.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.230]                 "immediateCondition"))) {
[09:29:19.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.230]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.230]                   if (TRUE && !signal) {
[09:29:19.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.230]                     {
[09:29:19.230]                       inherits <- base::inherits
[09:29:19.230]                       invokeRestart <- base::invokeRestart
[09:29:19.230]                       is.null <- base::is.null
[09:29:19.230]                       muffled <- FALSE
[09:29:19.230]                       if (inherits(cond, "message")) {
[09:29:19.230]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.230]                         if (muffled) 
[09:29:19.230]                           invokeRestart("muffleMessage")
[09:29:19.230]                       }
[09:29:19.230]                       else if (inherits(cond, "warning")) {
[09:29:19.230]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.230]                         if (muffled) 
[09:29:19.230]                           invokeRestart("muffleWarning")
[09:29:19.230]                       }
[09:29:19.230]                       else if (inherits(cond, "condition")) {
[09:29:19.230]                         if (!is.null(pattern)) {
[09:29:19.230]                           computeRestarts <- base::computeRestarts
[09:29:19.230]                           grepl <- base::grepl
[09:29:19.230]                           restarts <- computeRestarts(cond)
[09:29:19.230]                           for (restart in restarts) {
[09:29:19.230]                             name <- restart$name
[09:29:19.230]                             if (is.null(name)) 
[09:29:19.230]                               next
[09:29:19.230]                             if (!grepl(pattern, name)) 
[09:29:19.230]                               next
[09:29:19.230]                             invokeRestart(restart)
[09:29:19.230]                             muffled <- TRUE
[09:29:19.230]                             break
[09:29:19.230]                           }
[09:29:19.230]                         }
[09:29:19.230]                       }
[09:29:19.230]                       invisible(muffled)
[09:29:19.230]                     }
[09:29:19.230]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.230]                   }
[09:29:19.230]                 }
[09:29:19.230]                 else {
[09:29:19.230]                   if (TRUE) {
[09:29:19.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.230]                     {
[09:29:19.230]                       inherits <- base::inherits
[09:29:19.230]                       invokeRestart <- base::invokeRestart
[09:29:19.230]                       is.null <- base::is.null
[09:29:19.230]                       muffled <- FALSE
[09:29:19.230]                       if (inherits(cond, "message")) {
[09:29:19.230]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.230]                         if (muffled) 
[09:29:19.230]                           invokeRestart("muffleMessage")
[09:29:19.230]                       }
[09:29:19.230]                       else if (inherits(cond, "warning")) {
[09:29:19.230]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.230]                         if (muffled) 
[09:29:19.230]                           invokeRestart("muffleWarning")
[09:29:19.230]                       }
[09:29:19.230]                       else if (inherits(cond, "condition")) {
[09:29:19.230]                         if (!is.null(pattern)) {
[09:29:19.230]                           computeRestarts <- base::computeRestarts
[09:29:19.230]                           grepl <- base::grepl
[09:29:19.230]                           restarts <- computeRestarts(cond)
[09:29:19.230]                           for (restart in restarts) {
[09:29:19.230]                             name <- restart$name
[09:29:19.230]                             if (is.null(name)) 
[09:29:19.230]                               next
[09:29:19.230]                             if (!grepl(pattern, name)) 
[09:29:19.230]                               next
[09:29:19.230]                             invokeRestart(restart)
[09:29:19.230]                             muffled <- TRUE
[09:29:19.230]                             break
[09:29:19.230]                           }
[09:29:19.230]                         }
[09:29:19.230]                       }
[09:29:19.230]                       invisible(muffled)
[09:29:19.230]                     }
[09:29:19.230]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.230]                   }
[09:29:19.230]                 }
[09:29:19.230]             }
[09:29:19.230]         }))
[09:29:19.230]     }, error = function(ex) {
[09:29:19.230]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.230]                 ...future.rng), started = ...future.startTime, 
[09:29:19.230]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.230]             version = "1.8"), class = "FutureResult")
[09:29:19.230]     }, finally = {
[09:29:19.230]         if (!identical(...future.workdir, getwd())) 
[09:29:19.230]             setwd(...future.workdir)
[09:29:19.230]         {
[09:29:19.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.230]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.230]             }
[09:29:19.230]             base::options(...future.oldOptions)
[09:29:19.230]             if (.Platform$OS.type == "windows") {
[09:29:19.230]                 old_names <- names(...future.oldEnvVars)
[09:29:19.230]                 envs <- base::Sys.getenv()
[09:29:19.230]                 names <- names(envs)
[09:29:19.230]                 common <- intersect(names, old_names)
[09:29:19.230]                 added <- setdiff(names, old_names)
[09:29:19.230]                 removed <- setdiff(old_names, names)
[09:29:19.230]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.230]                   envs[common]]
[09:29:19.230]                 NAMES <- toupper(changed)
[09:29:19.230]                 args <- list()
[09:29:19.230]                 for (kk in seq_along(NAMES)) {
[09:29:19.230]                   name <- changed[[kk]]
[09:29:19.230]                   NAME <- NAMES[[kk]]
[09:29:19.230]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.230]                     next
[09:29:19.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.230]                 }
[09:29:19.230]                 NAMES <- toupper(added)
[09:29:19.230]                 for (kk in seq_along(NAMES)) {
[09:29:19.230]                   name <- added[[kk]]
[09:29:19.230]                   NAME <- NAMES[[kk]]
[09:29:19.230]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.230]                     next
[09:29:19.230]                   args[[name]] <- ""
[09:29:19.230]                 }
[09:29:19.230]                 NAMES <- toupper(removed)
[09:29:19.230]                 for (kk in seq_along(NAMES)) {
[09:29:19.230]                   name <- removed[[kk]]
[09:29:19.230]                   NAME <- NAMES[[kk]]
[09:29:19.230]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.230]                     next
[09:29:19.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.230]                 }
[09:29:19.230]                 if (length(args) > 0) 
[09:29:19.230]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.230]             }
[09:29:19.230]             else {
[09:29:19.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.230]             }
[09:29:19.230]             {
[09:29:19.230]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.230]                   0L) {
[09:29:19.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.230]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.230]                   base::options(opts)
[09:29:19.230]                 }
[09:29:19.230]                 {
[09:29:19.230]                   {
[09:29:19.230]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.230]                     NULL
[09:29:19.230]                   }
[09:29:19.230]                   options(future.plan = NULL)
[09:29:19.230]                   if (is.na(NA_character_)) 
[09:29:19.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.230]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.230]                     .init = FALSE)
[09:29:19.230]                 }
[09:29:19.230]             }
[09:29:19.230]         }
[09:29:19.230]     })
[09:29:19.230]     if (TRUE) {
[09:29:19.230]         base::sink(type = "output", split = FALSE)
[09:29:19.230]         if (TRUE) {
[09:29:19.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.230]         }
[09:29:19.230]         else {
[09:29:19.230]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.230]         }
[09:29:19.230]         base::close(...future.stdout)
[09:29:19.230]         ...future.stdout <- NULL
[09:29:19.230]     }
[09:29:19.230]     ...future.result$conditions <- ...future.conditions
[09:29:19.230]     ...future.result$finished <- base::Sys.time()
[09:29:19.230]     ...future.result
[09:29:19.230] }
[09:29:19.232] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[09:29:19.233] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[09:29:19.233] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[09:29:19.233] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:19.233] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.233] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[09:29:19.234] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[09:29:19.234] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:19.234] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.234] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:19.235] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.235] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[09:29:19.235] MultisessionFuture started
[09:29:19.235] - Launch lazy future ... done
[09:29:19.235] run() for ‘MultisessionFuture’ ... done
[09:29:19.235] Created future:
[09:29:19.235] MultisessionFuture:
[09:29:19.235] Label: ‘future_mapply-1’
[09:29:19.235] Expression:
[09:29:19.235] {
[09:29:19.235]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.235]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.235]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.235]         on.exit(options(oopts), add = TRUE)
[09:29:19.235]     }
[09:29:19.235]     {
[09:29:19.235]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.235]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.235]         do.call(mapply, args = args)
[09:29:19.235]     }
[09:29:19.235] }
[09:29:19.235] Lazy evaluation: FALSE
[09:29:19.235] Asynchronous evaluation: TRUE
[09:29:19.235] Local evaluation: TRUE
[09:29:19.235] Environment: R_GlobalEnv
[09:29:19.235] Capture standard output: TRUE
[09:29:19.235] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.235] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.235] Packages: <none>
[09:29:19.235] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.235] Resolved: FALSE
[09:29:19.235] Value: <not collected>
[09:29:19.235] Conditions captured: <none>
[09:29:19.235] Early signaling: FALSE
[09:29:19.235] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.235] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.247] Chunk #1 of 5 ... DONE
[09:29:19.247] Chunk #2 of 5 ...
[09:29:19.247]  - Finding globals in '...' for chunk #2 ...
[09:29:19.247] getGlobalsAndPackages() ...
[09:29:19.247] Searching for globals...
[09:29:19.248] 
[09:29:19.248] Searching for globals ... DONE
[09:29:19.248] - globals: [0] <none>
[09:29:19.248] getGlobalsAndPackages() ... DONE
[09:29:19.248]    + additional globals found: [n=0] 
[09:29:19.248]    + additional namespaces needed: [n=0] 
[09:29:19.248]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:19.248]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:19.248]  - seeds: <none>
[09:29:19.248]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.249] getGlobalsAndPackages() ...
[09:29:19.249] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.249] Resolving globals: FALSE
[09:29:19.249] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:19.250] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:19.250] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.250] 
[09:29:19.250] getGlobalsAndPackages() ... DONE
[09:29:19.250] run() for ‘Future’ ...
[09:29:19.250] - state: ‘created’
[09:29:19.250] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.264] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.264]   - Field: ‘node’
[09:29:19.264]   - Field: ‘label’
[09:29:19.264]   - Field: ‘local’
[09:29:19.264]   - Field: ‘owner’
[09:29:19.264]   - Field: ‘envir’
[09:29:19.264]   - Field: ‘workers’
[09:29:19.264]   - Field: ‘packages’
[09:29:19.265]   - Field: ‘gc’
[09:29:19.265]   - Field: ‘conditions’
[09:29:19.265]   - Field: ‘persistent’
[09:29:19.265]   - Field: ‘expr’
[09:29:19.265]   - Field: ‘uuid’
[09:29:19.265]   - Field: ‘seed’
[09:29:19.265]   - Field: ‘version’
[09:29:19.265]   - Field: ‘result’
[09:29:19.265]   - Field: ‘asynchronous’
[09:29:19.265]   - Field: ‘calls’
[09:29:19.265]   - Field: ‘globals’
[09:29:19.265]   - Field: ‘stdout’
[09:29:19.266]   - Field: ‘earlySignal’
[09:29:19.266]   - Field: ‘lazy’
[09:29:19.266]   - Field: ‘state’
[09:29:19.266] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.266] - Launch lazy future ...
[09:29:19.266] Packages needed by the future expression (n = 0): <none>
[09:29:19.266] Packages needed by future strategies (n = 0): <none>
[09:29:19.267] {
[09:29:19.267]     {
[09:29:19.267]         {
[09:29:19.267]             ...future.startTime <- base::Sys.time()
[09:29:19.267]             {
[09:29:19.267]                 {
[09:29:19.267]                   {
[09:29:19.267]                     {
[09:29:19.267]                       base::local({
[09:29:19.267]                         has_future <- base::requireNamespace("future", 
[09:29:19.267]                           quietly = TRUE)
[09:29:19.267]                         if (has_future) {
[09:29:19.267]                           ns <- base::getNamespace("future")
[09:29:19.267]                           version <- ns[[".package"]][["version"]]
[09:29:19.267]                           if (is.null(version)) 
[09:29:19.267]                             version <- utils::packageVersion("future")
[09:29:19.267]                         }
[09:29:19.267]                         else {
[09:29:19.267]                           version <- NULL
[09:29:19.267]                         }
[09:29:19.267]                         if (!has_future || version < "1.8.0") {
[09:29:19.267]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.267]                             "", base::R.version$version.string), 
[09:29:19.267]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.267]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.267]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.267]                               "release", "version")], collapse = " "), 
[09:29:19.267]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.267]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.267]                             info)
[09:29:19.267]                           info <- base::paste(info, collapse = "; ")
[09:29:19.267]                           if (!has_future) {
[09:29:19.267]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.267]                               info)
[09:29:19.267]                           }
[09:29:19.267]                           else {
[09:29:19.267]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.267]                               info, version)
[09:29:19.267]                           }
[09:29:19.267]                           base::stop(msg)
[09:29:19.267]                         }
[09:29:19.267]                       })
[09:29:19.267]                     }
[09:29:19.267]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.267]                     base::options(mc.cores = 1L)
[09:29:19.267]                   }
[09:29:19.267]                   ...future.strategy.old <- future::plan("list")
[09:29:19.267]                   options(future.plan = NULL)
[09:29:19.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.267]                 }
[09:29:19.267]                 ...future.workdir <- getwd()
[09:29:19.267]             }
[09:29:19.267]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.267]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.267]         }
[09:29:19.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.267]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:19.267]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.267]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.267]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.267]             base::names(...future.oldOptions))
[09:29:19.267]     }
[09:29:19.267]     if (FALSE) {
[09:29:19.267]     }
[09:29:19.267]     else {
[09:29:19.267]         if (TRUE) {
[09:29:19.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.267]                 open = "w")
[09:29:19.267]         }
[09:29:19.267]         else {
[09:29:19.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.267]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.267]         }
[09:29:19.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.267]             base::sink(type = "output", split = FALSE)
[09:29:19.267]             base::close(...future.stdout)
[09:29:19.267]         }, add = TRUE)
[09:29:19.267]     }
[09:29:19.267]     ...future.frame <- base::sys.nframe()
[09:29:19.267]     ...future.conditions <- base::list()
[09:29:19.267]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.267]     if (FALSE) {
[09:29:19.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.267]     }
[09:29:19.267]     ...future.result <- base::tryCatch({
[09:29:19.267]         base::withCallingHandlers({
[09:29:19.267]             ...future.value <- base::withVisible(base::local({
[09:29:19.267]                 ...future.makeSendCondition <- base::local({
[09:29:19.267]                   sendCondition <- NULL
[09:29:19.267]                   function(frame = 1L) {
[09:29:19.267]                     if (is.function(sendCondition)) 
[09:29:19.267]                       return(sendCondition)
[09:29:19.267]                     ns <- getNamespace("parallel")
[09:29:19.267]                     if (exists("sendData", mode = "function", 
[09:29:19.267]                       envir = ns)) {
[09:29:19.267]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.267]                         envir = ns)
[09:29:19.267]                       envir <- sys.frame(frame)
[09:29:19.267]                       master <- NULL
[09:29:19.267]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.267]                         !identical(envir, emptyenv())) {
[09:29:19.267]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.267]                           inherits = FALSE)) {
[09:29:19.267]                           master <- get("master", mode = "list", 
[09:29:19.267]                             envir = envir, inherits = FALSE)
[09:29:19.267]                           if (inherits(master, c("SOCKnode", 
[09:29:19.267]                             "SOCK0node"))) {
[09:29:19.267]                             sendCondition <<- function(cond) {
[09:29:19.267]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.267]                                 success = TRUE)
[09:29:19.267]                               parallel_sendData(master, data)
[09:29:19.267]                             }
[09:29:19.267]                             return(sendCondition)
[09:29:19.267]                           }
[09:29:19.267]                         }
[09:29:19.267]                         frame <- frame + 1L
[09:29:19.267]                         envir <- sys.frame(frame)
[09:29:19.267]                       }
[09:29:19.267]                     }
[09:29:19.267]                     sendCondition <<- function(cond) NULL
[09:29:19.267]                   }
[09:29:19.267]                 })
[09:29:19.267]                 withCallingHandlers({
[09:29:19.267]                   {
[09:29:19.267]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.267]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.267]                       ...future.globals.maxSize)) {
[09:29:19.267]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.267]                       on.exit(options(oopts), add = TRUE)
[09:29:19.267]                     }
[09:29:19.267]                     {
[09:29:19.267]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.267]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.267]                         USE.NAMES = FALSE)
[09:29:19.267]                       do.call(mapply, args = args)
[09:29:19.267]                     }
[09:29:19.267]                   }
[09:29:19.267]                 }, immediateCondition = function(cond) {
[09:29:19.267]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.267]                   sendCondition(cond)
[09:29:19.267]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.267]                   {
[09:29:19.267]                     inherits <- base::inherits
[09:29:19.267]                     invokeRestart <- base::invokeRestart
[09:29:19.267]                     is.null <- base::is.null
[09:29:19.267]                     muffled <- FALSE
[09:29:19.267]                     if (inherits(cond, "message")) {
[09:29:19.267]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.267]                       if (muffled) 
[09:29:19.267]                         invokeRestart("muffleMessage")
[09:29:19.267]                     }
[09:29:19.267]                     else if (inherits(cond, "warning")) {
[09:29:19.267]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.267]                       if (muffled) 
[09:29:19.267]                         invokeRestart("muffleWarning")
[09:29:19.267]                     }
[09:29:19.267]                     else if (inherits(cond, "condition")) {
[09:29:19.267]                       if (!is.null(pattern)) {
[09:29:19.267]                         computeRestarts <- base::computeRestarts
[09:29:19.267]                         grepl <- base::grepl
[09:29:19.267]                         restarts <- computeRestarts(cond)
[09:29:19.267]                         for (restart in restarts) {
[09:29:19.267]                           name <- restart$name
[09:29:19.267]                           if (is.null(name)) 
[09:29:19.267]                             next
[09:29:19.267]                           if (!grepl(pattern, name)) 
[09:29:19.267]                             next
[09:29:19.267]                           invokeRestart(restart)
[09:29:19.267]                           muffled <- TRUE
[09:29:19.267]                           break
[09:29:19.267]                         }
[09:29:19.267]                       }
[09:29:19.267]                     }
[09:29:19.267]                     invisible(muffled)
[09:29:19.267]                   }
[09:29:19.267]                   muffleCondition(cond)
[09:29:19.267]                 })
[09:29:19.267]             }))
[09:29:19.267]             future::FutureResult(value = ...future.value$value, 
[09:29:19.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.267]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.267]                     ...future.globalenv.names))
[09:29:19.267]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.267]         }, condition = base::local({
[09:29:19.267]             c <- base::c
[09:29:19.267]             inherits <- base::inherits
[09:29:19.267]             invokeRestart <- base::invokeRestart
[09:29:19.267]             length <- base::length
[09:29:19.267]             list <- base::list
[09:29:19.267]             seq.int <- base::seq.int
[09:29:19.267]             signalCondition <- base::signalCondition
[09:29:19.267]             sys.calls <- base::sys.calls
[09:29:19.267]             `[[` <- base::`[[`
[09:29:19.267]             `+` <- base::`+`
[09:29:19.267]             `<<-` <- base::`<<-`
[09:29:19.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.267]                   3L)]
[09:29:19.267]             }
[09:29:19.267]             function(cond) {
[09:29:19.267]                 is_error <- inherits(cond, "error")
[09:29:19.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.267]                   NULL)
[09:29:19.267]                 if (is_error) {
[09:29:19.267]                   sessionInformation <- function() {
[09:29:19.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.267]                       search = base::search(), system = base::Sys.info())
[09:29:19.267]                   }
[09:29:19.267]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.267]                     cond$call), session = sessionInformation(), 
[09:29:19.267]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.267]                   signalCondition(cond)
[09:29:19.267]                 }
[09:29:19.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.267]                 "immediateCondition"))) {
[09:29:19.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.267]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.267]                   if (TRUE && !signal) {
[09:29:19.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.267]                     {
[09:29:19.267]                       inherits <- base::inherits
[09:29:19.267]                       invokeRestart <- base::invokeRestart
[09:29:19.267]                       is.null <- base::is.null
[09:29:19.267]                       muffled <- FALSE
[09:29:19.267]                       if (inherits(cond, "message")) {
[09:29:19.267]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.267]                         if (muffled) 
[09:29:19.267]                           invokeRestart("muffleMessage")
[09:29:19.267]                       }
[09:29:19.267]                       else if (inherits(cond, "warning")) {
[09:29:19.267]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.267]                         if (muffled) 
[09:29:19.267]                           invokeRestart("muffleWarning")
[09:29:19.267]                       }
[09:29:19.267]                       else if (inherits(cond, "condition")) {
[09:29:19.267]                         if (!is.null(pattern)) {
[09:29:19.267]                           computeRestarts <- base::computeRestarts
[09:29:19.267]                           grepl <- base::grepl
[09:29:19.267]                           restarts <- computeRestarts(cond)
[09:29:19.267]                           for (restart in restarts) {
[09:29:19.267]                             name <- restart$name
[09:29:19.267]                             if (is.null(name)) 
[09:29:19.267]                               next
[09:29:19.267]                             if (!grepl(pattern, name)) 
[09:29:19.267]                               next
[09:29:19.267]                             invokeRestart(restart)
[09:29:19.267]                             muffled <- TRUE
[09:29:19.267]                             break
[09:29:19.267]                           }
[09:29:19.267]                         }
[09:29:19.267]                       }
[09:29:19.267]                       invisible(muffled)
[09:29:19.267]                     }
[09:29:19.267]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.267]                   }
[09:29:19.267]                 }
[09:29:19.267]                 else {
[09:29:19.267]                   if (TRUE) {
[09:29:19.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.267]                     {
[09:29:19.267]                       inherits <- base::inherits
[09:29:19.267]                       invokeRestart <- base::invokeRestart
[09:29:19.267]                       is.null <- base::is.null
[09:29:19.267]                       muffled <- FALSE
[09:29:19.267]                       if (inherits(cond, "message")) {
[09:29:19.267]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.267]                         if (muffled) 
[09:29:19.267]                           invokeRestart("muffleMessage")
[09:29:19.267]                       }
[09:29:19.267]                       else if (inherits(cond, "warning")) {
[09:29:19.267]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.267]                         if (muffled) 
[09:29:19.267]                           invokeRestart("muffleWarning")
[09:29:19.267]                       }
[09:29:19.267]                       else if (inherits(cond, "condition")) {
[09:29:19.267]                         if (!is.null(pattern)) {
[09:29:19.267]                           computeRestarts <- base::computeRestarts
[09:29:19.267]                           grepl <- base::grepl
[09:29:19.267]                           restarts <- computeRestarts(cond)
[09:29:19.267]                           for (restart in restarts) {
[09:29:19.267]                             name <- restart$name
[09:29:19.267]                             if (is.null(name)) 
[09:29:19.267]                               next
[09:29:19.267]                             if (!grepl(pattern, name)) 
[09:29:19.267]                               next
[09:29:19.267]                             invokeRestart(restart)
[09:29:19.267]                             muffled <- TRUE
[09:29:19.267]                             break
[09:29:19.267]                           }
[09:29:19.267]                         }
[09:29:19.267]                       }
[09:29:19.267]                       invisible(muffled)
[09:29:19.267]                     }
[09:29:19.267]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.267]                   }
[09:29:19.267]                 }
[09:29:19.267]             }
[09:29:19.267]         }))
[09:29:19.267]     }, error = function(ex) {
[09:29:19.267]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.267]                 ...future.rng), started = ...future.startTime, 
[09:29:19.267]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.267]             version = "1.8"), class = "FutureResult")
[09:29:19.267]     }, finally = {
[09:29:19.267]         if (!identical(...future.workdir, getwd())) 
[09:29:19.267]             setwd(...future.workdir)
[09:29:19.267]         {
[09:29:19.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.267]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.267]             }
[09:29:19.267]             base::options(...future.oldOptions)
[09:29:19.267]             if (.Platform$OS.type == "windows") {
[09:29:19.267]                 old_names <- names(...future.oldEnvVars)
[09:29:19.267]                 envs <- base::Sys.getenv()
[09:29:19.267]                 names <- names(envs)
[09:29:19.267]                 common <- intersect(names, old_names)
[09:29:19.267]                 added <- setdiff(names, old_names)
[09:29:19.267]                 removed <- setdiff(old_names, names)
[09:29:19.267]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.267]                   envs[common]]
[09:29:19.267]                 NAMES <- toupper(changed)
[09:29:19.267]                 args <- list()
[09:29:19.267]                 for (kk in seq_along(NAMES)) {
[09:29:19.267]                   name <- changed[[kk]]
[09:29:19.267]                   NAME <- NAMES[[kk]]
[09:29:19.267]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.267]                     next
[09:29:19.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.267]                 }
[09:29:19.267]                 NAMES <- toupper(added)
[09:29:19.267]                 for (kk in seq_along(NAMES)) {
[09:29:19.267]                   name <- added[[kk]]
[09:29:19.267]                   NAME <- NAMES[[kk]]
[09:29:19.267]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.267]                     next
[09:29:19.267]                   args[[name]] <- ""
[09:29:19.267]                 }
[09:29:19.267]                 NAMES <- toupper(removed)
[09:29:19.267]                 for (kk in seq_along(NAMES)) {
[09:29:19.267]                   name <- removed[[kk]]
[09:29:19.267]                   NAME <- NAMES[[kk]]
[09:29:19.267]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.267]                     next
[09:29:19.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.267]                 }
[09:29:19.267]                 if (length(args) > 0) 
[09:29:19.267]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.267]             }
[09:29:19.267]             else {
[09:29:19.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.267]             }
[09:29:19.267]             {
[09:29:19.267]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.267]                   0L) {
[09:29:19.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.267]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.267]                   base::options(opts)
[09:29:19.267]                 }
[09:29:19.267]                 {
[09:29:19.267]                   {
[09:29:19.267]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.267]                     NULL
[09:29:19.267]                   }
[09:29:19.267]                   options(future.plan = NULL)
[09:29:19.267]                   if (is.na(NA_character_)) 
[09:29:19.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.267]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.267]                     .init = FALSE)
[09:29:19.267]                 }
[09:29:19.267]             }
[09:29:19.267]         }
[09:29:19.267]     })
[09:29:19.267]     if (TRUE) {
[09:29:19.267]         base::sink(type = "output", split = FALSE)
[09:29:19.267]         if (TRUE) {
[09:29:19.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.267]         }
[09:29:19.267]         else {
[09:29:19.267]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.267]         }
[09:29:19.267]         base::close(...future.stdout)
[09:29:19.267]         ...future.stdout <- NULL
[09:29:19.267]     }
[09:29:19.267]     ...future.result$conditions <- ...future.conditions
[09:29:19.267]     ...future.result$finished <- base::Sys.time()
[09:29:19.267]     ...future.result
[09:29:19.267] }
[09:29:19.269] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[09:29:19.269] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[09:29:19.270] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[09:29:19.270] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:19.270] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.270] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[09:29:19.271] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[09:29:19.271] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:19.271] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.271] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:19.271] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.271] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[09:29:19.272] MultisessionFuture started
[09:29:19.272] - Launch lazy future ... done
[09:29:19.272] run() for ‘MultisessionFuture’ ... done
[09:29:19.272] Created future:
[09:29:19.272] MultisessionFuture:
[09:29:19.272] Label: ‘future_mapply-2’
[09:29:19.272] Expression:
[09:29:19.272] {
[09:29:19.272]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.272]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.272]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.272]         on.exit(options(oopts), add = TRUE)
[09:29:19.272]     }
[09:29:19.272]     {
[09:29:19.272]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.272]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.272]         do.call(mapply, args = args)
[09:29:19.272]     }
[09:29:19.272] }
[09:29:19.272] Lazy evaluation: FALSE
[09:29:19.272] Asynchronous evaluation: TRUE
[09:29:19.272] Local evaluation: TRUE
[09:29:19.272] Environment: R_GlobalEnv
[09:29:19.272] Capture standard output: TRUE
[09:29:19.272] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.272] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.272] Packages: <none>
[09:29:19.272] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.272] Resolved: FALSE
[09:29:19.272] Value: <not collected>
[09:29:19.272] Conditions captured: <none>
[09:29:19.272] Early signaling: FALSE
[09:29:19.272] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.272] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.284] Chunk #2 of 5 ... DONE
[09:29:19.284] Chunk #3 of 5 ...
[09:29:19.284]  - Finding globals in '...' for chunk #3 ...
[09:29:19.284] getGlobalsAndPackages() ...
[09:29:19.284] Searching for globals...
[09:29:19.284] 
[09:29:19.285] Searching for globals ... DONE
[09:29:19.285] - globals: [0] <none>
[09:29:19.285] getGlobalsAndPackages() ... DONE
[09:29:19.285]    + additional globals found: [n=0] 
[09:29:19.285]    + additional namespaces needed: [n=0] 
[09:29:19.285]  - Finding globals in '...' for chunk #3 ... DONE
[09:29:19.285]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:19.285]  - seeds: <none>
[09:29:19.285]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.285] getGlobalsAndPackages() ...
[09:29:19.285] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.286] Resolving globals: FALSE
[09:29:19.286] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:19.286] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:19.286] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.287] 
[09:29:19.287] getGlobalsAndPackages() ... DONE
[09:29:19.287] run() for ‘Future’ ...
[09:29:19.287] - state: ‘created’
[09:29:19.287] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.301]   - Field: ‘node’
[09:29:19.301]   - Field: ‘label’
[09:29:19.301]   - Field: ‘local’
[09:29:19.301]   - Field: ‘owner’
[09:29:19.301]   - Field: ‘envir’
[09:29:19.301]   - Field: ‘workers’
[09:29:19.301]   - Field: ‘packages’
[09:29:19.301]   - Field: ‘gc’
[09:29:19.301]   - Field: ‘conditions’
[09:29:19.301]   - Field: ‘persistent’
[09:29:19.301]   - Field: ‘expr’
[09:29:19.302]   - Field: ‘uuid’
[09:29:19.302]   - Field: ‘seed’
[09:29:19.302]   - Field: ‘version’
[09:29:19.302]   - Field: ‘result’
[09:29:19.302]   - Field: ‘asynchronous’
[09:29:19.302]   - Field: ‘calls’
[09:29:19.302]   - Field: ‘globals’
[09:29:19.302]   - Field: ‘stdout’
[09:29:19.302]   - Field: ‘earlySignal’
[09:29:19.302]   - Field: ‘lazy’
[09:29:19.302]   - Field: ‘state’
[09:29:19.303] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.303] - Launch lazy future ...
[09:29:19.303] Packages needed by the future expression (n = 0): <none>
[09:29:19.303] Packages needed by future strategies (n = 0): <none>
[09:29:19.303] {
[09:29:19.303]     {
[09:29:19.303]         {
[09:29:19.303]             ...future.startTime <- base::Sys.time()
[09:29:19.303]             {
[09:29:19.303]                 {
[09:29:19.303]                   {
[09:29:19.303]                     {
[09:29:19.303]                       base::local({
[09:29:19.303]                         has_future <- base::requireNamespace("future", 
[09:29:19.303]                           quietly = TRUE)
[09:29:19.303]                         if (has_future) {
[09:29:19.303]                           ns <- base::getNamespace("future")
[09:29:19.303]                           version <- ns[[".package"]][["version"]]
[09:29:19.303]                           if (is.null(version)) 
[09:29:19.303]                             version <- utils::packageVersion("future")
[09:29:19.303]                         }
[09:29:19.303]                         else {
[09:29:19.303]                           version <- NULL
[09:29:19.303]                         }
[09:29:19.303]                         if (!has_future || version < "1.8.0") {
[09:29:19.303]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.303]                             "", base::R.version$version.string), 
[09:29:19.303]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.303]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.303]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.303]                               "release", "version")], collapse = " "), 
[09:29:19.303]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.303]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.303]                             info)
[09:29:19.303]                           info <- base::paste(info, collapse = "; ")
[09:29:19.303]                           if (!has_future) {
[09:29:19.303]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.303]                               info)
[09:29:19.303]                           }
[09:29:19.303]                           else {
[09:29:19.303]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.303]                               info, version)
[09:29:19.303]                           }
[09:29:19.303]                           base::stop(msg)
[09:29:19.303]                         }
[09:29:19.303]                       })
[09:29:19.303]                     }
[09:29:19.303]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.303]                     base::options(mc.cores = 1L)
[09:29:19.303]                   }
[09:29:19.303]                   ...future.strategy.old <- future::plan("list")
[09:29:19.303]                   options(future.plan = NULL)
[09:29:19.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.303]                 }
[09:29:19.303]                 ...future.workdir <- getwd()
[09:29:19.303]             }
[09:29:19.303]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.303]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.303]         }
[09:29:19.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.303]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:19.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.303]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.303]             base::names(...future.oldOptions))
[09:29:19.303]     }
[09:29:19.303]     if (FALSE) {
[09:29:19.303]     }
[09:29:19.303]     else {
[09:29:19.303]         if (TRUE) {
[09:29:19.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.303]                 open = "w")
[09:29:19.303]         }
[09:29:19.303]         else {
[09:29:19.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.303]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.303]         }
[09:29:19.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.303]             base::sink(type = "output", split = FALSE)
[09:29:19.303]             base::close(...future.stdout)
[09:29:19.303]         }, add = TRUE)
[09:29:19.303]     }
[09:29:19.303]     ...future.frame <- base::sys.nframe()
[09:29:19.303]     ...future.conditions <- base::list()
[09:29:19.303]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.303]     if (FALSE) {
[09:29:19.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.303]     }
[09:29:19.303]     ...future.result <- base::tryCatch({
[09:29:19.303]         base::withCallingHandlers({
[09:29:19.303]             ...future.value <- base::withVisible(base::local({
[09:29:19.303]                 ...future.makeSendCondition <- base::local({
[09:29:19.303]                   sendCondition <- NULL
[09:29:19.303]                   function(frame = 1L) {
[09:29:19.303]                     if (is.function(sendCondition)) 
[09:29:19.303]                       return(sendCondition)
[09:29:19.303]                     ns <- getNamespace("parallel")
[09:29:19.303]                     if (exists("sendData", mode = "function", 
[09:29:19.303]                       envir = ns)) {
[09:29:19.303]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.303]                         envir = ns)
[09:29:19.303]                       envir <- sys.frame(frame)
[09:29:19.303]                       master <- NULL
[09:29:19.303]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.303]                         !identical(envir, emptyenv())) {
[09:29:19.303]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.303]                           inherits = FALSE)) {
[09:29:19.303]                           master <- get("master", mode = "list", 
[09:29:19.303]                             envir = envir, inherits = FALSE)
[09:29:19.303]                           if (inherits(master, c("SOCKnode", 
[09:29:19.303]                             "SOCK0node"))) {
[09:29:19.303]                             sendCondition <<- function(cond) {
[09:29:19.303]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.303]                                 success = TRUE)
[09:29:19.303]                               parallel_sendData(master, data)
[09:29:19.303]                             }
[09:29:19.303]                             return(sendCondition)
[09:29:19.303]                           }
[09:29:19.303]                         }
[09:29:19.303]                         frame <- frame + 1L
[09:29:19.303]                         envir <- sys.frame(frame)
[09:29:19.303]                       }
[09:29:19.303]                     }
[09:29:19.303]                     sendCondition <<- function(cond) NULL
[09:29:19.303]                   }
[09:29:19.303]                 })
[09:29:19.303]                 withCallingHandlers({
[09:29:19.303]                   {
[09:29:19.303]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.303]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.303]                       ...future.globals.maxSize)) {
[09:29:19.303]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.303]                       on.exit(options(oopts), add = TRUE)
[09:29:19.303]                     }
[09:29:19.303]                     {
[09:29:19.303]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.303]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.303]                         USE.NAMES = FALSE)
[09:29:19.303]                       do.call(mapply, args = args)
[09:29:19.303]                     }
[09:29:19.303]                   }
[09:29:19.303]                 }, immediateCondition = function(cond) {
[09:29:19.303]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.303]                   sendCondition(cond)
[09:29:19.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.303]                   {
[09:29:19.303]                     inherits <- base::inherits
[09:29:19.303]                     invokeRestart <- base::invokeRestart
[09:29:19.303]                     is.null <- base::is.null
[09:29:19.303]                     muffled <- FALSE
[09:29:19.303]                     if (inherits(cond, "message")) {
[09:29:19.303]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.303]                       if (muffled) 
[09:29:19.303]                         invokeRestart("muffleMessage")
[09:29:19.303]                     }
[09:29:19.303]                     else if (inherits(cond, "warning")) {
[09:29:19.303]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.303]                       if (muffled) 
[09:29:19.303]                         invokeRestart("muffleWarning")
[09:29:19.303]                     }
[09:29:19.303]                     else if (inherits(cond, "condition")) {
[09:29:19.303]                       if (!is.null(pattern)) {
[09:29:19.303]                         computeRestarts <- base::computeRestarts
[09:29:19.303]                         grepl <- base::grepl
[09:29:19.303]                         restarts <- computeRestarts(cond)
[09:29:19.303]                         for (restart in restarts) {
[09:29:19.303]                           name <- restart$name
[09:29:19.303]                           if (is.null(name)) 
[09:29:19.303]                             next
[09:29:19.303]                           if (!grepl(pattern, name)) 
[09:29:19.303]                             next
[09:29:19.303]                           invokeRestart(restart)
[09:29:19.303]                           muffled <- TRUE
[09:29:19.303]                           break
[09:29:19.303]                         }
[09:29:19.303]                       }
[09:29:19.303]                     }
[09:29:19.303]                     invisible(muffled)
[09:29:19.303]                   }
[09:29:19.303]                   muffleCondition(cond)
[09:29:19.303]                 })
[09:29:19.303]             }))
[09:29:19.303]             future::FutureResult(value = ...future.value$value, 
[09:29:19.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.303]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.303]                     ...future.globalenv.names))
[09:29:19.303]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.303]         }, condition = base::local({
[09:29:19.303]             c <- base::c
[09:29:19.303]             inherits <- base::inherits
[09:29:19.303]             invokeRestart <- base::invokeRestart
[09:29:19.303]             length <- base::length
[09:29:19.303]             list <- base::list
[09:29:19.303]             seq.int <- base::seq.int
[09:29:19.303]             signalCondition <- base::signalCondition
[09:29:19.303]             sys.calls <- base::sys.calls
[09:29:19.303]             `[[` <- base::`[[`
[09:29:19.303]             `+` <- base::`+`
[09:29:19.303]             `<<-` <- base::`<<-`
[09:29:19.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.303]                   3L)]
[09:29:19.303]             }
[09:29:19.303]             function(cond) {
[09:29:19.303]                 is_error <- inherits(cond, "error")
[09:29:19.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.303]                   NULL)
[09:29:19.303]                 if (is_error) {
[09:29:19.303]                   sessionInformation <- function() {
[09:29:19.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.303]                       search = base::search(), system = base::Sys.info())
[09:29:19.303]                   }
[09:29:19.303]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.303]                     cond$call), session = sessionInformation(), 
[09:29:19.303]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.303]                   signalCondition(cond)
[09:29:19.303]                 }
[09:29:19.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.303]                 "immediateCondition"))) {
[09:29:19.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.303]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.303]                   if (TRUE && !signal) {
[09:29:19.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.303]                     {
[09:29:19.303]                       inherits <- base::inherits
[09:29:19.303]                       invokeRestart <- base::invokeRestart
[09:29:19.303]                       is.null <- base::is.null
[09:29:19.303]                       muffled <- FALSE
[09:29:19.303]                       if (inherits(cond, "message")) {
[09:29:19.303]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.303]                         if (muffled) 
[09:29:19.303]                           invokeRestart("muffleMessage")
[09:29:19.303]                       }
[09:29:19.303]                       else if (inherits(cond, "warning")) {
[09:29:19.303]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.303]                         if (muffled) 
[09:29:19.303]                           invokeRestart("muffleWarning")
[09:29:19.303]                       }
[09:29:19.303]                       else if (inherits(cond, "condition")) {
[09:29:19.303]                         if (!is.null(pattern)) {
[09:29:19.303]                           computeRestarts <- base::computeRestarts
[09:29:19.303]                           grepl <- base::grepl
[09:29:19.303]                           restarts <- computeRestarts(cond)
[09:29:19.303]                           for (restart in restarts) {
[09:29:19.303]                             name <- restart$name
[09:29:19.303]                             if (is.null(name)) 
[09:29:19.303]                               next
[09:29:19.303]                             if (!grepl(pattern, name)) 
[09:29:19.303]                               next
[09:29:19.303]                             invokeRestart(restart)
[09:29:19.303]                             muffled <- TRUE
[09:29:19.303]                             break
[09:29:19.303]                           }
[09:29:19.303]                         }
[09:29:19.303]                       }
[09:29:19.303]                       invisible(muffled)
[09:29:19.303]                     }
[09:29:19.303]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.303]                   }
[09:29:19.303]                 }
[09:29:19.303]                 else {
[09:29:19.303]                   if (TRUE) {
[09:29:19.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.303]                     {
[09:29:19.303]                       inherits <- base::inherits
[09:29:19.303]                       invokeRestart <- base::invokeRestart
[09:29:19.303]                       is.null <- base::is.null
[09:29:19.303]                       muffled <- FALSE
[09:29:19.303]                       if (inherits(cond, "message")) {
[09:29:19.303]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.303]                         if (muffled) 
[09:29:19.303]                           invokeRestart("muffleMessage")
[09:29:19.303]                       }
[09:29:19.303]                       else if (inherits(cond, "warning")) {
[09:29:19.303]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.303]                         if (muffled) 
[09:29:19.303]                           invokeRestart("muffleWarning")
[09:29:19.303]                       }
[09:29:19.303]                       else if (inherits(cond, "condition")) {
[09:29:19.303]                         if (!is.null(pattern)) {
[09:29:19.303]                           computeRestarts <- base::computeRestarts
[09:29:19.303]                           grepl <- base::grepl
[09:29:19.303]                           restarts <- computeRestarts(cond)
[09:29:19.303]                           for (restart in restarts) {
[09:29:19.303]                             name <- restart$name
[09:29:19.303]                             if (is.null(name)) 
[09:29:19.303]                               next
[09:29:19.303]                             if (!grepl(pattern, name)) 
[09:29:19.303]                               next
[09:29:19.303]                             invokeRestart(restart)
[09:29:19.303]                             muffled <- TRUE
[09:29:19.303]                             break
[09:29:19.303]                           }
[09:29:19.303]                         }
[09:29:19.303]                       }
[09:29:19.303]                       invisible(muffled)
[09:29:19.303]                     }
[09:29:19.303]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.303]                   }
[09:29:19.303]                 }
[09:29:19.303]             }
[09:29:19.303]         }))
[09:29:19.303]     }, error = function(ex) {
[09:29:19.303]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.303]                 ...future.rng), started = ...future.startTime, 
[09:29:19.303]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.303]             version = "1.8"), class = "FutureResult")
[09:29:19.303]     }, finally = {
[09:29:19.303]         if (!identical(...future.workdir, getwd())) 
[09:29:19.303]             setwd(...future.workdir)
[09:29:19.303]         {
[09:29:19.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.303]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.303]             }
[09:29:19.303]             base::options(...future.oldOptions)
[09:29:19.303]             if (.Platform$OS.type == "windows") {
[09:29:19.303]                 old_names <- names(...future.oldEnvVars)
[09:29:19.303]                 envs <- base::Sys.getenv()
[09:29:19.303]                 names <- names(envs)
[09:29:19.303]                 common <- intersect(names, old_names)
[09:29:19.303]                 added <- setdiff(names, old_names)
[09:29:19.303]                 removed <- setdiff(old_names, names)
[09:29:19.303]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.303]                   envs[common]]
[09:29:19.303]                 NAMES <- toupper(changed)
[09:29:19.303]                 args <- list()
[09:29:19.303]                 for (kk in seq_along(NAMES)) {
[09:29:19.303]                   name <- changed[[kk]]
[09:29:19.303]                   NAME <- NAMES[[kk]]
[09:29:19.303]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.303]                     next
[09:29:19.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.303]                 }
[09:29:19.303]                 NAMES <- toupper(added)
[09:29:19.303]                 for (kk in seq_along(NAMES)) {
[09:29:19.303]                   name <- added[[kk]]
[09:29:19.303]                   NAME <- NAMES[[kk]]
[09:29:19.303]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.303]                     next
[09:29:19.303]                   args[[name]] <- ""
[09:29:19.303]                 }
[09:29:19.303]                 NAMES <- toupper(removed)
[09:29:19.303]                 for (kk in seq_along(NAMES)) {
[09:29:19.303]                   name <- removed[[kk]]
[09:29:19.303]                   NAME <- NAMES[[kk]]
[09:29:19.303]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.303]                     next
[09:29:19.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.303]                 }
[09:29:19.303]                 if (length(args) > 0) 
[09:29:19.303]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.303]             }
[09:29:19.303]             else {
[09:29:19.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.303]             }
[09:29:19.303]             {
[09:29:19.303]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.303]                   0L) {
[09:29:19.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.303]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.303]                   base::options(opts)
[09:29:19.303]                 }
[09:29:19.303]                 {
[09:29:19.303]                   {
[09:29:19.303]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.303]                     NULL
[09:29:19.303]                   }
[09:29:19.303]                   options(future.plan = NULL)
[09:29:19.303]                   if (is.na(NA_character_)) 
[09:29:19.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.303]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.303]                     .init = FALSE)
[09:29:19.303]                 }
[09:29:19.303]             }
[09:29:19.303]         }
[09:29:19.303]     })
[09:29:19.303]     if (TRUE) {
[09:29:19.303]         base::sink(type = "output", split = FALSE)
[09:29:19.303]         if (TRUE) {
[09:29:19.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.303]         }
[09:29:19.303]         else {
[09:29:19.303]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.303]         }
[09:29:19.303]         base::close(...future.stdout)
[09:29:19.303]         ...future.stdout <- NULL
[09:29:19.303]     }
[09:29:19.303]     ...future.result$conditions <- ...future.conditions
[09:29:19.303]     ...future.result$finished <- base::Sys.time()
[09:29:19.303]     ...future.result
[09:29:19.303] }
[09:29:19.305] Poll #1 (0): usedNodes() = 2, workers = 2
[09:29:19.316] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.316] - Validating connection of MultisessionFuture
[09:29:19.316] - received message: FutureResult
[09:29:19.317] - Received FutureResult
[09:29:19.317] - Erased future from FutureRegistry
[09:29:19.317] result() for ClusterFuture ...
[09:29:19.317] - result already collected: FutureResult
[09:29:19.317] result() for ClusterFuture ... done
[09:29:19.317] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.317] result() for ClusterFuture ...
[09:29:19.317] - result already collected: FutureResult
[09:29:19.317] result() for ClusterFuture ... done
[09:29:19.317] result() for ClusterFuture ...
[09:29:19.317] - result already collected: FutureResult
[09:29:19.318] result() for ClusterFuture ... done
[09:29:19.318] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[09:29:19.318] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[09:29:19.319] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[09:29:19.319] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:19.319] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.319] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[09:29:19.319] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[09:29:19.320] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:19.320] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.320] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:19.320] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.320] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[09:29:19.321] MultisessionFuture started
[09:29:19.321] - Launch lazy future ... done
[09:29:19.321] run() for ‘MultisessionFuture’ ... done
[09:29:19.321] Created future:
[09:29:19.321] MultisessionFuture:
[09:29:19.321] Label: ‘future_mapply-3’
[09:29:19.321] Expression:
[09:29:19.321] {
[09:29:19.321]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.321]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.321]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.321]         on.exit(options(oopts), add = TRUE)
[09:29:19.321]     }
[09:29:19.321]     {
[09:29:19.321]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.321]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.321]         do.call(mapply, args = args)
[09:29:19.321]     }
[09:29:19.321] }
[09:29:19.321] Lazy evaluation: FALSE
[09:29:19.321] Asynchronous evaluation: TRUE
[09:29:19.321] Local evaluation: TRUE
[09:29:19.321] Environment: R_GlobalEnv
[09:29:19.321] Capture standard output: TRUE
[09:29:19.321] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.321] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.321] Packages: <none>
[09:29:19.321] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.321] Resolved: FALSE
[09:29:19.321] Value: <not collected>
[09:29:19.321] Conditions captured: <none>
[09:29:19.321] Early signaling: FALSE
[09:29:19.321] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.321] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.333] Chunk #3 of 5 ... DONE
[09:29:19.333] Chunk #4 of 5 ...
[09:29:19.333]  - Finding globals in '...' for chunk #4 ...
[09:29:19.333] getGlobalsAndPackages() ...
[09:29:19.333] Searching for globals...
[09:29:19.333] 
[09:29:19.333] Searching for globals ... DONE
[09:29:19.333] - globals: [0] <none>
[09:29:19.334] getGlobalsAndPackages() ... DONE
[09:29:19.334]    + additional globals found: [n=0] 
[09:29:19.334]    + additional namespaces needed: [n=0] 
[09:29:19.334]  - Finding globals in '...' for chunk #4 ... DONE
[09:29:19.334]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:19.334]  - seeds: <none>
[09:29:19.334]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.334] getGlobalsAndPackages() ...
[09:29:19.334] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.334] Resolving globals: FALSE
[09:29:19.335] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:19.335] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:19.335] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.335] 
[09:29:19.336] getGlobalsAndPackages() ... DONE
[09:29:19.336] run() for ‘Future’ ...
[09:29:19.336] - state: ‘created’
[09:29:19.336] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.349] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.349] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.349]   - Field: ‘node’
[09:29:19.349]   - Field: ‘label’
[09:29:19.350]   - Field: ‘local’
[09:29:19.350]   - Field: ‘owner’
[09:29:19.350]   - Field: ‘envir’
[09:29:19.350]   - Field: ‘workers’
[09:29:19.350]   - Field: ‘packages’
[09:29:19.350]   - Field: ‘gc’
[09:29:19.352]   - Field: ‘conditions’
[09:29:19.352]   - Field: ‘persistent’
[09:29:19.353]   - Field: ‘expr’
[09:29:19.353]   - Field: ‘uuid’
[09:29:19.353]   - Field: ‘seed’
[09:29:19.353]   - Field: ‘version’
[09:29:19.353]   - Field: ‘result’
[09:29:19.353]   - Field: ‘asynchronous’
[09:29:19.353]   - Field: ‘calls’
[09:29:19.353]   - Field: ‘globals’
[09:29:19.353]   - Field: ‘stdout’
[09:29:19.353]   - Field: ‘earlySignal’
[09:29:19.353]   - Field: ‘lazy’
[09:29:19.354]   - Field: ‘state’
[09:29:19.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.354] - Launch lazy future ...
[09:29:19.354] Packages needed by the future expression (n = 0): <none>
[09:29:19.354] Packages needed by future strategies (n = 0): <none>
[09:29:19.354] {
[09:29:19.354]     {
[09:29:19.354]         {
[09:29:19.354]             ...future.startTime <- base::Sys.time()
[09:29:19.354]             {
[09:29:19.354]                 {
[09:29:19.354]                   {
[09:29:19.354]                     {
[09:29:19.354]                       base::local({
[09:29:19.354]                         has_future <- base::requireNamespace("future", 
[09:29:19.354]                           quietly = TRUE)
[09:29:19.354]                         if (has_future) {
[09:29:19.354]                           ns <- base::getNamespace("future")
[09:29:19.354]                           version <- ns[[".package"]][["version"]]
[09:29:19.354]                           if (is.null(version)) 
[09:29:19.354]                             version <- utils::packageVersion("future")
[09:29:19.354]                         }
[09:29:19.354]                         else {
[09:29:19.354]                           version <- NULL
[09:29:19.354]                         }
[09:29:19.354]                         if (!has_future || version < "1.8.0") {
[09:29:19.354]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.354]                             "", base::R.version$version.string), 
[09:29:19.354]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.354]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.354]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.354]                               "release", "version")], collapse = " "), 
[09:29:19.354]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.354]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.354]                             info)
[09:29:19.354]                           info <- base::paste(info, collapse = "; ")
[09:29:19.354]                           if (!has_future) {
[09:29:19.354]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.354]                               info)
[09:29:19.354]                           }
[09:29:19.354]                           else {
[09:29:19.354]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.354]                               info, version)
[09:29:19.354]                           }
[09:29:19.354]                           base::stop(msg)
[09:29:19.354]                         }
[09:29:19.354]                       })
[09:29:19.354]                     }
[09:29:19.354]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.354]                     base::options(mc.cores = 1L)
[09:29:19.354]                   }
[09:29:19.354]                   ...future.strategy.old <- future::plan("list")
[09:29:19.354]                   options(future.plan = NULL)
[09:29:19.354]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.354]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.354]                 }
[09:29:19.354]                 ...future.workdir <- getwd()
[09:29:19.354]             }
[09:29:19.354]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.354]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.354]         }
[09:29:19.354]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.354]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:19.354]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.354]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.354]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.354]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.354]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.354]             base::names(...future.oldOptions))
[09:29:19.354]     }
[09:29:19.354]     if (FALSE) {
[09:29:19.354]     }
[09:29:19.354]     else {
[09:29:19.354]         if (TRUE) {
[09:29:19.354]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.354]                 open = "w")
[09:29:19.354]         }
[09:29:19.354]         else {
[09:29:19.354]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.354]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.354]         }
[09:29:19.354]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.354]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.354]             base::sink(type = "output", split = FALSE)
[09:29:19.354]             base::close(...future.stdout)
[09:29:19.354]         }, add = TRUE)
[09:29:19.354]     }
[09:29:19.354]     ...future.frame <- base::sys.nframe()
[09:29:19.354]     ...future.conditions <- base::list()
[09:29:19.354]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.354]     if (FALSE) {
[09:29:19.354]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.354]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.354]     }
[09:29:19.354]     ...future.result <- base::tryCatch({
[09:29:19.354]         base::withCallingHandlers({
[09:29:19.354]             ...future.value <- base::withVisible(base::local({
[09:29:19.354]                 ...future.makeSendCondition <- base::local({
[09:29:19.354]                   sendCondition <- NULL
[09:29:19.354]                   function(frame = 1L) {
[09:29:19.354]                     if (is.function(sendCondition)) 
[09:29:19.354]                       return(sendCondition)
[09:29:19.354]                     ns <- getNamespace("parallel")
[09:29:19.354]                     if (exists("sendData", mode = "function", 
[09:29:19.354]                       envir = ns)) {
[09:29:19.354]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.354]                         envir = ns)
[09:29:19.354]                       envir <- sys.frame(frame)
[09:29:19.354]                       master <- NULL
[09:29:19.354]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.354]                         !identical(envir, emptyenv())) {
[09:29:19.354]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.354]                           inherits = FALSE)) {
[09:29:19.354]                           master <- get("master", mode = "list", 
[09:29:19.354]                             envir = envir, inherits = FALSE)
[09:29:19.354]                           if (inherits(master, c("SOCKnode", 
[09:29:19.354]                             "SOCK0node"))) {
[09:29:19.354]                             sendCondition <<- function(cond) {
[09:29:19.354]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.354]                                 success = TRUE)
[09:29:19.354]                               parallel_sendData(master, data)
[09:29:19.354]                             }
[09:29:19.354]                             return(sendCondition)
[09:29:19.354]                           }
[09:29:19.354]                         }
[09:29:19.354]                         frame <- frame + 1L
[09:29:19.354]                         envir <- sys.frame(frame)
[09:29:19.354]                       }
[09:29:19.354]                     }
[09:29:19.354]                     sendCondition <<- function(cond) NULL
[09:29:19.354]                   }
[09:29:19.354]                 })
[09:29:19.354]                 withCallingHandlers({
[09:29:19.354]                   {
[09:29:19.354]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.354]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.354]                       ...future.globals.maxSize)) {
[09:29:19.354]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.354]                       on.exit(options(oopts), add = TRUE)
[09:29:19.354]                     }
[09:29:19.354]                     {
[09:29:19.354]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.354]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.354]                         USE.NAMES = FALSE)
[09:29:19.354]                       do.call(mapply, args = args)
[09:29:19.354]                     }
[09:29:19.354]                   }
[09:29:19.354]                 }, immediateCondition = function(cond) {
[09:29:19.354]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.354]                   sendCondition(cond)
[09:29:19.354]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.354]                   {
[09:29:19.354]                     inherits <- base::inherits
[09:29:19.354]                     invokeRestart <- base::invokeRestart
[09:29:19.354]                     is.null <- base::is.null
[09:29:19.354]                     muffled <- FALSE
[09:29:19.354]                     if (inherits(cond, "message")) {
[09:29:19.354]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.354]                       if (muffled) 
[09:29:19.354]                         invokeRestart("muffleMessage")
[09:29:19.354]                     }
[09:29:19.354]                     else if (inherits(cond, "warning")) {
[09:29:19.354]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.354]                       if (muffled) 
[09:29:19.354]                         invokeRestart("muffleWarning")
[09:29:19.354]                     }
[09:29:19.354]                     else if (inherits(cond, "condition")) {
[09:29:19.354]                       if (!is.null(pattern)) {
[09:29:19.354]                         computeRestarts <- base::computeRestarts
[09:29:19.354]                         grepl <- base::grepl
[09:29:19.354]                         restarts <- computeRestarts(cond)
[09:29:19.354]                         for (restart in restarts) {
[09:29:19.354]                           name <- restart$name
[09:29:19.354]                           if (is.null(name)) 
[09:29:19.354]                             next
[09:29:19.354]                           if (!grepl(pattern, name)) 
[09:29:19.354]                             next
[09:29:19.354]                           invokeRestart(restart)
[09:29:19.354]                           muffled <- TRUE
[09:29:19.354]                           break
[09:29:19.354]                         }
[09:29:19.354]                       }
[09:29:19.354]                     }
[09:29:19.354]                     invisible(muffled)
[09:29:19.354]                   }
[09:29:19.354]                   muffleCondition(cond)
[09:29:19.354]                 })
[09:29:19.354]             }))
[09:29:19.354]             future::FutureResult(value = ...future.value$value, 
[09:29:19.354]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.354]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.354]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.354]                     ...future.globalenv.names))
[09:29:19.354]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.354]         }, condition = base::local({
[09:29:19.354]             c <- base::c
[09:29:19.354]             inherits <- base::inherits
[09:29:19.354]             invokeRestart <- base::invokeRestart
[09:29:19.354]             length <- base::length
[09:29:19.354]             list <- base::list
[09:29:19.354]             seq.int <- base::seq.int
[09:29:19.354]             signalCondition <- base::signalCondition
[09:29:19.354]             sys.calls <- base::sys.calls
[09:29:19.354]             `[[` <- base::`[[`
[09:29:19.354]             `+` <- base::`+`
[09:29:19.354]             `<<-` <- base::`<<-`
[09:29:19.354]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.354]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.354]                   3L)]
[09:29:19.354]             }
[09:29:19.354]             function(cond) {
[09:29:19.354]                 is_error <- inherits(cond, "error")
[09:29:19.354]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.354]                   NULL)
[09:29:19.354]                 if (is_error) {
[09:29:19.354]                   sessionInformation <- function() {
[09:29:19.354]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.354]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.354]                       search = base::search(), system = base::Sys.info())
[09:29:19.354]                   }
[09:29:19.354]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.354]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.354]                     cond$call), session = sessionInformation(), 
[09:29:19.354]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.354]                   signalCondition(cond)
[09:29:19.354]                 }
[09:29:19.354]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.354]                 "immediateCondition"))) {
[09:29:19.354]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.354]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.354]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.354]                   if (TRUE && !signal) {
[09:29:19.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.354]                     {
[09:29:19.354]                       inherits <- base::inherits
[09:29:19.354]                       invokeRestart <- base::invokeRestart
[09:29:19.354]                       is.null <- base::is.null
[09:29:19.354]                       muffled <- FALSE
[09:29:19.354]                       if (inherits(cond, "message")) {
[09:29:19.354]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.354]                         if (muffled) 
[09:29:19.354]                           invokeRestart("muffleMessage")
[09:29:19.354]                       }
[09:29:19.354]                       else if (inherits(cond, "warning")) {
[09:29:19.354]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.354]                         if (muffled) 
[09:29:19.354]                           invokeRestart("muffleWarning")
[09:29:19.354]                       }
[09:29:19.354]                       else if (inherits(cond, "condition")) {
[09:29:19.354]                         if (!is.null(pattern)) {
[09:29:19.354]                           computeRestarts <- base::computeRestarts
[09:29:19.354]                           grepl <- base::grepl
[09:29:19.354]                           restarts <- computeRestarts(cond)
[09:29:19.354]                           for (restart in restarts) {
[09:29:19.354]                             name <- restart$name
[09:29:19.354]                             if (is.null(name)) 
[09:29:19.354]                               next
[09:29:19.354]                             if (!grepl(pattern, name)) 
[09:29:19.354]                               next
[09:29:19.354]                             invokeRestart(restart)
[09:29:19.354]                             muffled <- TRUE
[09:29:19.354]                             break
[09:29:19.354]                           }
[09:29:19.354]                         }
[09:29:19.354]                       }
[09:29:19.354]                       invisible(muffled)
[09:29:19.354]                     }
[09:29:19.354]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.354]                   }
[09:29:19.354]                 }
[09:29:19.354]                 else {
[09:29:19.354]                   if (TRUE) {
[09:29:19.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.354]                     {
[09:29:19.354]                       inherits <- base::inherits
[09:29:19.354]                       invokeRestart <- base::invokeRestart
[09:29:19.354]                       is.null <- base::is.null
[09:29:19.354]                       muffled <- FALSE
[09:29:19.354]                       if (inherits(cond, "message")) {
[09:29:19.354]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.354]                         if (muffled) 
[09:29:19.354]                           invokeRestart("muffleMessage")
[09:29:19.354]                       }
[09:29:19.354]                       else if (inherits(cond, "warning")) {
[09:29:19.354]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.354]                         if (muffled) 
[09:29:19.354]                           invokeRestart("muffleWarning")
[09:29:19.354]                       }
[09:29:19.354]                       else if (inherits(cond, "condition")) {
[09:29:19.354]                         if (!is.null(pattern)) {
[09:29:19.354]                           computeRestarts <- base::computeRestarts
[09:29:19.354]                           grepl <- base::grepl
[09:29:19.354]                           restarts <- computeRestarts(cond)
[09:29:19.354]                           for (restart in restarts) {
[09:29:19.354]                             name <- restart$name
[09:29:19.354]                             if (is.null(name)) 
[09:29:19.354]                               next
[09:29:19.354]                             if (!grepl(pattern, name)) 
[09:29:19.354]                               next
[09:29:19.354]                             invokeRestart(restart)
[09:29:19.354]                             muffled <- TRUE
[09:29:19.354]                             break
[09:29:19.354]                           }
[09:29:19.354]                         }
[09:29:19.354]                       }
[09:29:19.354]                       invisible(muffled)
[09:29:19.354]                     }
[09:29:19.354]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.354]                   }
[09:29:19.354]                 }
[09:29:19.354]             }
[09:29:19.354]         }))
[09:29:19.354]     }, error = function(ex) {
[09:29:19.354]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.354]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.354]                 ...future.rng), started = ...future.startTime, 
[09:29:19.354]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.354]             version = "1.8"), class = "FutureResult")
[09:29:19.354]     }, finally = {
[09:29:19.354]         if (!identical(...future.workdir, getwd())) 
[09:29:19.354]             setwd(...future.workdir)
[09:29:19.354]         {
[09:29:19.354]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.354]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.354]             }
[09:29:19.354]             base::options(...future.oldOptions)
[09:29:19.354]             if (.Platform$OS.type == "windows") {
[09:29:19.354]                 old_names <- names(...future.oldEnvVars)
[09:29:19.354]                 envs <- base::Sys.getenv()
[09:29:19.354]                 names <- names(envs)
[09:29:19.354]                 common <- intersect(names, old_names)
[09:29:19.354]                 added <- setdiff(names, old_names)
[09:29:19.354]                 removed <- setdiff(old_names, names)
[09:29:19.354]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.354]                   envs[common]]
[09:29:19.354]                 NAMES <- toupper(changed)
[09:29:19.354]                 args <- list()
[09:29:19.354]                 for (kk in seq_along(NAMES)) {
[09:29:19.354]                   name <- changed[[kk]]
[09:29:19.354]                   NAME <- NAMES[[kk]]
[09:29:19.354]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.354]                     next
[09:29:19.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.354]                 }
[09:29:19.354]                 NAMES <- toupper(added)
[09:29:19.354]                 for (kk in seq_along(NAMES)) {
[09:29:19.354]                   name <- added[[kk]]
[09:29:19.354]                   NAME <- NAMES[[kk]]
[09:29:19.354]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.354]                     next
[09:29:19.354]                   args[[name]] <- ""
[09:29:19.354]                 }
[09:29:19.354]                 NAMES <- toupper(removed)
[09:29:19.354]                 for (kk in seq_along(NAMES)) {
[09:29:19.354]                   name <- removed[[kk]]
[09:29:19.354]                   NAME <- NAMES[[kk]]
[09:29:19.354]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.354]                     next
[09:29:19.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.354]                 }
[09:29:19.354]                 if (length(args) > 0) 
[09:29:19.354]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.354]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.354]             }
[09:29:19.354]             else {
[09:29:19.354]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.354]             }
[09:29:19.354]             {
[09:29:19.354]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.354]                   0L) {
[09:29:19.354]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.354]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.354]                   base::options(opts)
[09:29:19.354]                 }
[09:29:19.354]                 {
[09:29:19.354]                   {
[09:29:19.354]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.354]                     NULL
[09:29:19.354]                   }
[09:29:19.354]                   options(future.plan = NULL)
[09:29:19.354]                   if (is.na(NA_character_)) 
[09:29:19.354]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.354]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.354]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.354]                     .init = FALSE)
[09:29:19.354]                 }
[09:29:19.354]             }
[09:29:19.354]         }
[09:29:19.354]     })
[09:29:19.354]     if (TRUE) {
[09:29:19.354]         base::sink(type = "output", split = FALSE)
[09:29:19.354]         if (TRUE) {
[09:29:19.354]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.354]         }
[09:29:19.354]         else {
[09:29:19.354]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.354]         }
[09:29:19.354]         base::close(...future.stdout)
[09:29:19.354]         ...future.stdout <- NULL
[09:29:19.354]     }
[09:29:19.354]     ...future.result$conditions <- ...future.conditions
[09:29:19.354]     ...future.result$finished <- base::Sys.time()
[09:29:19.354]     ...future.result
[09:29:19.354] }
[09:29:19.357] Poll #1 (0): usedNodes() = 2, workers = 2
[09:29:19.367] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.367] - Validating connection of MultisessionFuture
[09:29:19.367] - received message: FutureResult
[09:29:19.368] - Received FutureResult
[09:29:19.368] - Erased future from FutureRegistry
[09:29:19.368] result() for ClusterFuture ...
[09:29:19.368] - result already collected: FutureResult
[09:29:19.368] result() for ClusterFuture ... done
[09:29:19.368] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.368] result() for ClusterFuture ...
[09:29:19.368] - result already collected: FutureResult
[09:29:19.368] result() for ClusterFuture ... done
[09:29:19.368] result() for ClusterFuture ...
[09:29:19.369] - result already collected: FutureResult
[09:29:19.369] result() for ClusterFuture ... done
[09:29:19.369] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[09:29:19.369] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[09:29:19.370] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[09:29:19.370] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:19.370] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.370] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[09:29:19.370] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[09:29:19.371] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:19.371] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.371] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:19.371] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.371] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[09:29:19.372] MultisessionFuture started
[09:29:19.372] - Launch lazy future ... done
[09:29:19.372] run() for ‘MultisessionFuture’ ... done
[09:29:19.372] Created future:
[09:29:19.372] MultisessionFuture:
[09:29:19.372] Label: ‘future_mapply-4’
[09:29:19.372] Expression:
[09:29:19.372] {
[09:29:19.372]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.372]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.372]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.372]         on.exit(options(oopts), add = TRUE)
[09:29:19.372]     }
[09:29:19.372]     {
[09:29:19.372]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.372]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.372]         do.call(mapply, args = args)
[09:29:19.372]     }
[09:29:19.372] }
[09:29:19.372] Lazy evaluation: FALSE
[09:29:19.372] Asynchronous evaluation: TRUE
[09:29:19.372] Local evaluation: TRUE
[09:29:19.372] Environment: R_GlobalEnv
[09:29:19.372] Capture standard output: TRUE
[09:29:19.372] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.372] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.372] Packages: <none>
[09:29:19.372] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.372] Resolved: FALSE
[09:29:19.372] Value: <not collected>
[09:29:19.372] Conditions captured: <none>
[09:29:19.372] Early signaling: FALSE
[09:29:19.372] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.372] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.384] Chunk #4 of 5 ... DONE
[09:29:19.384] Chunk #5 of 5 ...
[09:29:19.384]  - Finding globals in '...' for chunk #5 ...
[09:29:19.384] getGlobalsAndPackages() ...
[09:29:19.384] Searching for globals...
[09:29:19.384] 
[09:29:19.385] Searching for globals ... DONE
[09:29:19.385] - globals: [0] <none>
[09:29:19.385] getGlobalsAndPackages() ... DONE
[09:29:19.385]    + additional globals found: [n=0] 
[09:29:19.385]    + additional namespaces needed: [n=0] 
[09:29:19.385]  - Finding globals in '...' for chunk #5 ... DONE
[09:29:19.385]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[09:29:19.385]  - seeds: <none>
[09:29:19.385]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.385] getGlobalsAndPackages() ...
[09:29:19.385] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.386] Resolving globals: FALSE
[09:29:19.386] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:19.386] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:19.386] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.387] 
[09:29:19.387] getGlobalsAndPackages() ... DONE
[09:29:19.387] run() for ‘Future’ ...
[09:29:19.387] - state: ‘created’
[09:29:19.387] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.401] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.401]   - Field: ‘node’
[09:29:19.402]   - Field: ‘label’
[09:29:19.402]   - Field: ‘local’
[09:29:19.402]   - Field: ‘owner’
[09:29:19.402]   - Field: ‘envir’
[09:29:19.402]   - Field: ‘workers’
[09:29:19.402]   - Field: ‘packages’
[09:29:19.402]   - Field: ‘gc’
[09:29:19.402]   - Field: ‘conditions’
[09:29:19.402]   - Field: ‘persistent’
[09:29:19.402]   - Field: ‘expr’
[09:29:19.402]   - Field: ‘uuid’
[09:29:19.402]   - Field: ‘seed’
[09:29:19.403]   - Field: ‘version’
[09:29:19.403]   - Field: ‘result’
[09:29:19.403]   - Field: ‘asynchronous’
[09:29:19.403]   - Field: ‘calls’
[09:29:19.403]   - Field: ‘globals’
[09:29:19.403]   - Field: ‘stdout’
[09:29:19.403]   - Field: ‘earlySignal’
[09:29:19.403]   - Field: ‘lazy’
[09:29:19.403]   - Field: ‘state’
[09:29:19.403] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.403] - Launch lazy future ...
[09:29:19.404] Packages needed by the future expression (n = 0): <none>
[09:29:19.404] Packages needed by future strategies (n = 0): <none>
[09:29:19.404] {
[09:29:19.404]     {
[09:29:19.404]         {
[09:29:19.404]             ...future.startTime <- base::Sys.time()
[09:29:19.404]             {
[09:29:19.404]                 {
[09:29:19.404]                   {
[09:29:19.404]                     {
[09:29:19.404]                       base::local({
[09:29:19.404]                         has_future <- base::requireNamespace("future", 
[09:29:19.404]                           quietly = TRUE)
[09:29:19.404]                         if (has_future) {
[09:29:19.404]                           ns <- base::getNamespace("future")
[09:29:19.404]                           version <- ns[[".package"]][["version"]]
[09:29:19.404]                           if (is.null(version)) 
[09:29:19.404]                             version <- utils::packageVersion("future")
[09:29:19.404]                         }
[09:29:19.404]                         else {
[09:29:19.404]                           version <- NULL
[09:29:19.404]                         }
[09:29:19.404]                         if (!has_future || version < "1.8.0") {
[09:29:19.404]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.404]                             "", base::R.version$version.string), 
[09:29:19.404]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.404]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.404]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.404]                               "release", "version")], collapse = " "), 
[09:29:19.404]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.404]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.404]                             info)
[09:29:19.404]                           info <- base::paste(info, collapse = "; ")
[09:29:19.404]                           if (!has_future) {
[09:29:19.404]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.404]                               info)
[09:29:19.404]                           }
[09:29:19.404]                           else {
[09:29:19.404]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.404]                               info, version)
[09:29:19.404]                           }
[09:29:19.404]                           base::stop(msg)
[09:29:19.404]                         }
[09:29:19.404]                       })
[09:29:19.404]                     }
[09:29:19.404]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.404]                     base::options(mc.cores = 1L)
[09:29:19.404]                   }
[09:29:19.404]                   ...future.strategy.old <- future::plan("list")
[09:29:19.404]                   options(future.plan = NULL)
[09:29:19.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.404]                 }
[09:29:19.404]                 ...future.workdir <- getwd()
[09:29:19.404]             }
[09:29:19.404]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.404]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.404]         }
[09:29:19.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.404]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[09:29:19.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.404]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.404]             base::names(...future.oldOptions))
[09:29:19.404]     }
[09:29:19.404]     if (FALSE) {
[09:29:19.404]     }
[09:29:19.404]     else {
[09:29:19.404]         if (TRUE) {
[09:29:19.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.404]                 open = "w")
[09:29:19.404]         }
[09:29:19.404]         else {
[09:29:19.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.404]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.404]         }
[09:29:19.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.404]             base::sink(type = "output", split = FALSE)
[09:29:19.404]             base::close(...future.stdout)
[09:29:19.404]         }, add = TRUE)
[09:29:19.404]     }
[09:29:19.404]     ...future.frame <- base::sys.nframe()
[09:29:19.404]     ...future.conditions <- base::list()
[09:29:19.404]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.404]     if (FALSE) {
[09:29:19.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.404]     }
[09:29:19.404]     ...future.result <- base::tryCatch({
[09:29:19.404]         base::withCallingHandlers({
[09:29:19.404]             ...future.value <- base::withVisible(base::local({
[09:29:19.404]                 ...future.makeSendCondition <- base::local({
[09:29:19.404]                   sendCondition <- NULL
[09:29:19.404]                   function(frame = 1L) {
[09:29:19.404]                     if (is.function(sendCondition)) 
[09:29:19.404]                       return(sendCondition)
[09:29:19.404]                     ns <- getNamespace("parallel")
[09:29:19.404]                     if (exists("sendData", mode = "function", 
[09:29:19.404]                       envir = ns)) {
[09:29:19.404]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.404]                         envir = ns)
[09:29:19.404]                       envir <- sys.frame(frame)
[09:29:19.404]                       master <- NULL
[09:29:19.404]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.404]                         !identical(envir, emptyenv())) {
[09:29:19.404]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.404]                           inherits = FALSE)) {
[09:29:19.404]                           master <- get("master", mode = "list", 
[09:29:19.404]                             envir = envir, inherits = FALSE)
[09:29:19.404]                           if (inherits(master, c("SOCKnode", 
[09:29:19.404]                             "SOCK0node"))) {
[09:29:19.404]                             sendCondition <<- function(cond) {
[09:29:19.404]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.404]                                 success = TRUE)
[09:29:19.404]                               parallel_sendData(master, data)
[09:29:19.404]                             }
[09:29:19.404]                             return(sendCondition)
[09:29:19.404]                           }
[09:29:19.404]                         }
[09:29:19.404]                         frame <- frame + 1L
[09:29:19.404]                         envir <- sys.frame(frame)
[09:29:19.404]                       }
[09:29:19.404]                     }
[09:29:19.404]                     sendCondition <<- function(cond) NULL
[09:29:19.404]                   }
[09:29:19.404]                 })
[09:29:19.404]                 withCallingHandlers({
[09:29:19.404]                   {
[09:29:19.404]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.404]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.404]                       ...future.globals.maxSize)) {
[09:29:19.404]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.404]                       on.exit(options(oopts), add = TRUE)
[09:29:19.404]                     }
[09:29:19.404]                     {
[09:29:19.404]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.404]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.404]                         USE.NAMES = FALSE)
[09:29:19.404]                       do.call(mapply, args = args)
[09:29:19.404]                     }
[09:29:19.404]                   }
[09:29:19.404]                 }, immediateCondition = function(cond) {
[09:29:19.404]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.404]                   sendCondition(cond)
[09:29:19.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.404]                   {
[09:29:19.404]                     inherits <- base::inherits
[09:29:19.404]                     invokeRestart <- base::invokeRestart
[09:29:19.404]                     is.null <- base::is.null
[09:29:19.404]                     muffled <- FALSE
[09:29:19.404]                     if (inherits(cond, "message")) {
[09:29:19.404]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.404]                       if (muffled) 
[09:29:19.404]                         invokeRestart("muffleMessage")
[09:29:19.404]                     }
[09:29:19.404]                     else if (inherits(cond, "warning")) {
[09:29:19.404]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.404]                       if (muffled) 
[09:29:19.404]                         invokeRestart("muffleWarning")
[09:29:19.404]                     }
[09:29:19.404]                     else if (inherits(cond, "condition")) {
[09:29:19.404]                       if (!is.null(pattern)) {
[09:29:19.404]                         computeRestarts <- base::computeRestarts
[09:29:19.404]                         grepl <- base::grepl
[09:29:19.404]                         restarts <- computeRestarts(cond)
[09:29:19.404]                         for (restart in restarts) {
[09:29:19.404]                           name <- restart$name
[09:29:19.404]                           if (is.null(name)) 
[09:29:19.404]                             next
[09:29:19.404]                           if (!grepl(pattern, name)) 
[09:29:19.404]                             next
[09:29:19.404]                           invokeRestart(restart)
[09:29:19.404]                           muffled <- TRUE
[09:29:19.404]                           break
[09:29:19.404]                         }
[09:29:19.404]                       }
[09:29:19.404]                     }
[09:29:19.404]                     invisible(muffled)
[09:29:19.404]                   }
[09:29:19.404]                   muffleCondition(cond)
[09:29:19.404]                 })
[09:29:19.404]             }))
[09:29:19.404]             future::FutureResult(value = ...future.value$value, 
[09:29:19.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.404]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.404]                     ...future.globalenv.names))
[09:29:19.404]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.404]         }, condition = base::local({
[09:29:19.404]             c <- base::c
[09:29:19.404]             inherits <- base::inherits
[09:29:19.404]             invokeRestart <- base::invokeRestart
[09:29:19.404]             length <- base::length
[09:29:19.404]             list <- base::list
[09:29:19.404]             seq.int <- base::seq.int
[09:29:19.404]             signalCondition <- base::signalCondition
[09:29:19.404]             sys.calls <- base::sys.calls
[09:29:19.404]             `[[` <- base::`[[`
[09:29:19.404]             `+` <- base::`+`
[09:29:19.404]             `<<-` <- base::`<<-`
[09:29:19.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.404]                   3L)]
[09:29:19.404]             }
[09:29:19.404]             function(cond) {
[09:29:19.404]                 is_error <- inherits(cond, "error")
[09:29:19.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.404]                   NULL)
[09:29:19.404]                 if (is_error) {
[09:29:19.404]                   sessionInformation <- function() {
[09:29:19.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.404]                       search = base::search(), system = base::Sys.info())
[09:29:19.404]                   }
[09:29:19.404]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.404]                     cond$call), session = sessionInformation(), 
[09:29:19.404]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.404]                   signalCondition(cond)
[09:29:19.404]                 }
[09:29:19.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.404]                 "immediateCondition"))) {
[09:29:19.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.404]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.404]                   if (TRUE && !signal) {
[09:29:19.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.404]                     {
[09:29:19.404]                       inherits <- base::inherits
[09:29:19.404]                       invokeRestart <- base::invokeRestart
[09:29:19.404]                       is.null <- base::is.null
[09:29:19.404]                       muffled <- FALSE
[09:29:19.404]                       if (inherits(cond, "message")) {
[09:29:19.404]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.404]                         if (muffled) 
[09:29:19.404]                           invokeRestart("muffleMessage")
[09:29:19.404]                       }
[09:29:19.404]                       else if (inherits(cond, "warning")) {
[09:29:19.404]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.404]                         if (muffled) 
[09:29:19.404]                           invokeRestart("muffleWarning")
[09:29:19.404]                       }
[09:29:19.404]                       else if (inherits(cond, "condition")) {
[09:29:19.404]                         if (!is.null(pattern)) {
[09:29:19.404]                           computeRestarts <- base::computeRestarts
[09:29:19.404]                           grepl <- base::grepl
[09:29:19.404]                           restarts <- computeRestarts(cond)
[09:29:19.404]                           for (restart in restarts) {
[09:29:19.404]                             name <- restart$name
[09:29:19.404]                             if (is.null(name)) 
[09:29:19.404]                               next
[09:29:19.404]                             if (!grepl(pattern, name)) 
[09:29:19.404]                               next
[09:29:19.404]                             invokeRestart(restart)
[09:29:19.404]                             muffled <- TRUE
[09:29:19.404]                             break
[09:29:19.404]                           }
[09:29:19.404]                         }
[09:29:19.404]                       }
[09:29:19.404]                       invisible(muffled)
[09:29:19.404]                     }
[09:29:19.404]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.404]                   }
[09:29:19.404]                 }
[09:29:19.404]                 else {
[09:29:19.404]                   if (TRUE) {
[09:29:19.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.404]                     {
[09:29:19.404]                       inherits <- base::inherits
[09:29:19.404]                       invokeRestart <- base::invokeRestart
[09:29:19.404]                       is.null <- base::is.null
[09:29:19.404]                       muffled <- FALSE
[09:29:19.404]                       if (inherits(cond, "message")) {
[09:29:19.404]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.404]                         if (muffled) 
[09:29:19.404]                           invokeRestart("muffleMessage")
[09:29:19.404]                       }
[09:29:19.404]                       else if (inherits(cond, "warning")) {
[09:29:19.404]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.404]                         if (muffled) 
[09:29:19.404]                           invokeRestart("muffleWarning")
[09:29:19.404]                       }
[09:29:19.404]                       else if (inherits(cond, "condition")) {
[09:29:19.404]                         if (!is.null(pattern)) {
[09:29:19.404]                           computeRestarts <- base::computeRestarts
[09:29:19.404]                           grepl <- base::grepl
[09:29:19.404]                           restarts <- computeRestarts(cond)
[09:29:19.404]                           for (restart in restarts) {
[09:29:19.404]                             name <- restart$name
[09:29:19.404]                             if (is.null(name)) 
[09:29:19.404]                               next
[09:29:19.404]                             if (!grepl(pattern, name)) 
[09:29:19.404]                               next
[09:29:19.404]                             invokeRestart(restart)
[09:29:19.404]                             muffled <- TRUE
[09:29:19.404]                             break
[09:29:19.404]                           }
[09:29:19.404]                         }
[09:29:19.404]                       }
[09:29:19.404]                       invisible(muffled)
[09:29:19.404]                     }
[09:29:19.404]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.404]                   }
[09:29:19.404]                 }
[09:29:19.404]             }
[09:29:19.404]         }))
[09:29:19.404]     }, error = function(ex) {
[09:29:19.404]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.404]                 ...future.rng), started = ...future.startTime, 
[09:29:19.404]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.404]             version = "1.8"), class = "FutureResult")
[09:29:19.404]     }, finally = {
[09:29:19.404]         if (!identical(...future.workdir, getwd())) 
[09:29:19.404]             setwd(...future.workdir)
[09:29:19.404]         {
[09:29:19.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.404]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.404]             }
[09:29:19.404]             base::options(...future.oldOptions)
[09:29:19.404]             if (.Platform$OS.type == "windows") {
[09:29:19.404]                 old_names <- names(...future.oldEnvVars)
[09:29:19.404]                 envs <- base::Sys.getenv()
[09:29:19.404]                 names <- names(envs)
[09:29:19.404]                 common <- intersect(names, old_names)
[09:29:19.404]                 added <- setdiff(names, old_names)
[09:29:19.404]                 removed <- setdiff(old_names, names)
[09:29:19.404]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.404]                   envs[common]]
[09:29:19.404]                 NAMES <- toupper(changed)
[09:29:19.404]                 args <- list()
[09:29:19.404]                 for (kk in seq_along(NAMES)) {
[09:29:19.404]                   name <- changed[[kk]]
[09:29:19.404]                   NAME <- NAMES[[kk]]
[09:29:19.404]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.404]                     next
[09:29:19.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.404]                 }
[09:29:19.404]                 NAMES <- toupper(added)
[09:29:19.404]                 for (kk in seq_along(NAMES)) {
[09:29:19.404]                   name <- added[[kk]]
[09:29:19.404]                   NAME <- NAMES[[kk]]
[09:29:19.404]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.404]                     next
[09:29:19.404]                   args[[name]] <- ""
[09:29:19.404]                 }
[09:29:19.404]                 NAMES <- toupper(removed)
[09:29:19.404]                 for (kk in seq_along(NAMES)) {
[09:29:19.404]                   name <- removed[[kk]]
[09:29:19.404]                   NAME <- NAMES[[kk]]
[09:29:19.404]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.404]                     next
[09:29:19.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.404]                 }
[09:29:19.404]                 if (length(args) > 0) 
[09:29:19.404]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.404]             }
[09:29:19.404]             else {
[09:29:19.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.404]             }
[09:29:19.404]             {
[09:29:19.404]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.404]                   0L) {
[09:29:19.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.404]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.404]                   base::options(opts)
[09:29:19.404]                 }
[09:29:19.404]                 {
[09:29:19.404]                   {
[09:29:19.404]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.404]                     NULL
[09:29:19.404]                   }
[09:29:19.404]                   options(future.plan = NULL)
[09:29:19.404]                   if (is.na(NA_character_)) 
[09:29:19.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.404]                     .init = FALSE)
[09:29:19.404]                 }
[09:29:19.404]             }
[09:29:19.404]         }
[09:29:19.404]     })
[09:29:19.404]     if (TRUE) {
[09:29:19.404]         base::sink(type = "output", split = FALSE)
[09:29:19.404]         if (TRUE) {
[09:29:19.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.404]         }
[09:29:19.404]         else {
[09:29:19.404]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.404]         }
[09:29:19.404]         base::close(...future.stdout)
[09:29:19.404]         ...future.stdout <- NULL
[09:29:19.404]     }
[09:29:19.404]     ...future.result$conditions <- ...future.conditions
[09:29:19.404]     ...future.result$finished <- base::Sys.time()
[09:29:19.404]     ...future.result
[09:29:19.404] }
[09:29:19.406] Poll #1 (0): usedNodes() = 2, workers = 2
[09:29:19.417] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.417] - Validating connection of MultisessionFuture
[09:29:19.417] - received message: FutureResult
[09:29:19.418] - Received FutureResult
[09:29:19.418] - Erased future from FutureRegistry
[09:29:19.418] result() for ClusterFuture ...
[09:29:19.418] - result already collected: FutureResult
[09:29:19.418] result() for ClusterFuture ... done
[09:29:19.418] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.418] result() for ClusterFuture ...
[09:29:19.418] - result already collected: FutureResult
[09:29:19.418] result() for ClusterFuture ... done
[09:29:19.418] result() for ClusterFuture ...
[09:29:19.418] - result already collected: FutureResult
[09:29:19.419] result() for ClusterFuture ... done
[09:29:19.419] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[09:29:19.419] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[09:29:19.420] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[09:29:19.420] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:19.420] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.420] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[09:29:19.421] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[09:29:19.421] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:19.421] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.421] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:19.421] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.422] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[09:29:19.422] MultisessionFuture started
[09:29:19.422] - Launch lazy future ... done
[09:29:19.422] run() for ‘MultisessionFuture’ ... done
[09:29:19.422] Created future:
[09:29:19.422] MultisessionFuture:
[09:29:19.422] Label: ‘future_mapply-5’
[09:29:19.422] Expression:
[09:29:19.422] {
[09:29:19.422]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.422]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.422]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.422]         on.exit(options(oopts), add = TRUE)
[09:29:19.422]     }
[09:29:19.422]     {
[09:29:19.422]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.422]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.422]         do.call(mapply, args = args)
[09:29:19.422]     }
[09:29:19.422] }
[09:29:19.422] Lazy evaluation: FALSE
[09:29:19.422] Asynchronous evaluation: TRUE
[09:29:19.422] Local evaluation: TRUE
[09:29:19.422] Environment: R_GlobalEnv
[09:29:19.422] Capture standard output: TRUE
[09:29:19.422] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.422] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.422] Packages: <none>
[09:29:19.422] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.422] Resolved: FALSE
[09:29:19.422] Value: <not collected>
[09:29:19.422] Conditions captured: <none>
[09:29:19.422] Early signaling: FALSE
[09:29:19.422] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.422] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.434] Chunk #5 of 5 ... DONE
[09:29:19.434] Launching 5 futures (chunks) ... DONE
[09:29:19.434] Resolving 5 futures (chunks) ...
[09:29:19.434] resolve() on list ...
[09:29:19.434]  recursive: 0
[09:29:19.434]  length: 5
[09:29:19.434] 
[09:29:19.434] Future #1
[09:29:19.435] result() for ClusterFuture ...
[09:29:19.435] - result already collected: FutureResult
[09:29:19.435] result() for ClusterFuture ... done
[09:29:19.435] result() for ClusterFuture ...
[09:29:19.435] - result already collected: FutureResult
[09:29:19.435] result() for ClusterFuture ... done
[09:29:19.435] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:19.435] - nx: 5
[09:29:19.435] - relay: TRUE
[09:29:19.435] - stdout: TRUE
[09:29:19.435] - signal: TRUE
[09:29:19.435] - resignal: FALSE
[09:29:19.436] - force: TRUE
[09:29:19.436] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[09:29:19.436] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[09:29:19.436]  - until=1
[09:29:19.436]  - relaying element #1
[09:29:19.436] result() for ClusterFuture ...
[09:29:19.436] - result already collected: FutureResult
[09:29:19.436] result() for ClusterFuture ... done
[09:29:19.436] result() for ClusterFuture ...
[09:29:19.436] - result already collected: FutureResult
[09:29:19.436] result() for ClusterFuture ... done
[09:29:19.437] result() for ClusterFuture ...
[09:29:19.437] - result already collected: FutureResult
[09:29:19.437] result() for ClusterFuture ... done
[09:29:19.437] result() for ClusterFuture ...
[09:29:19.437] - result already collected: FutureResult
[09:29:19.437] result() for ClusterFuture ... done
[09:29:19.437] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[09:29:19.437] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[09:29:19.437] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:19.437]  length: 4 (resolved future 1)
[09:29:19.437] Future #2
[09:29:19.438] result() for ClusterFuture ...
[09:29:19.438] - result already collected: FutureResult
[09:29:19.438] result() for ClusterFuture ... done
[09:29:19.438] result() for ClusterFuture ...
[09:29:19.438] - result already collected: FutureResult
[09:29:19.438] result() for ClusterFuture ... done
[09:29:19.438] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:19.438] - nx: 5
[09:29:19.438] - relay: TRUE
[09:29:19.438] - stdout: TRUE
[09:29:19.438] - signal: TRUE
[09:29:19.438] - resignal: FALSE
[09:29:19.439] - force: TRUE
[09:29:19.439] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[09:29:19.439] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[09:29:19.439]  - until=2
[09:29:19.439]  - relaying element #2
[09:29:19.439] result() for ClusterFuture ...
[09:29:19.439] - result already collected: FutureResult
[09:29:19.439] result() for ClusterFuture ... done
[09:29:19.439] result() for ClusterFuture ...
[09:29:19.439] - result already collected: FutureResult
[09:29:19.439] result() for ClusterFuture ... done
[09:29:19.439] result() for ClusterFuture ...
[09:29:19.440] - result already collected: FutureResult
[09:29:19.440] result() for ClusterFuture ... done
[09:29:19.440] result() for ClusterFuture ...
[09:29:19.440] - result already collected: FutureResult
[09:29:19.440] result() for ClusterFuture ... done
[09:29:19.440] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[09:29:19.440] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[09:29:19.440] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:19.440]  length: 3 (resolved future 2)
[09:29:19.440] Future #3
[09:29:19.440] result() for ClusterFuture ...
[09:29:19.441] - result already collected: FutureResult
[09:29:19.441] result() for ClusterFuture ... done
[09:29:19.441] result() for ClusterFuture ...
[09:29:19.441] - result already collected: FutureResult
[09:29:19.441] result() for ClusterFuture ... done
[09:29:19.441] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:29:19.441] - nx: 5
[09:29:19.441] - relay: TRUE
[09:29:19.441] - stdout: TRUE
[09:29:19.441] - signal: TRUE
[09:29:19.441] - resignal: FALSE
[09:29:19.441] - force: TRUE
[09:29:19.442] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[09:29:19.442] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[09:29:19.442]  - until=3
[09:29:19.442]  - relaying element #3
[09:29:19.442] result() for ClusterFuture ...
[09:29:19.442] - result already collected: FutureResult
[09:29:19.442] result() for ClusterFuture ... done
[09:29:19.442] result() for ClusterFuture ...
[09:29:19.442] - result already collected: FutureResult
[09:29:19.442] result() for ClusterFuture ... done
[09:29:19.442] result() for ClusterFuture ...
[09:29:19.442] - result already collected: FutureResult
[09:29:19.443] result() for ClusterFuture ... done
[09:29:19.443] result() for ClusterFuture ...
[09:29:19.443] - result already collected: FutureResult
[09:29:19.443] result() for ClusterFuture ... done
[09:29:19.443] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[09:29:19.443] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[09:29:19.443] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:29:19.443]  length: 2 (resolved future 3)
[09:29:19.444] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.444] - Validating connection of MultisessionFuture
[09:29:19.444] - received message: FutureResult
[09:29:19.444] - Received FutureResult
[09:29:19.444] - Erased future from FutureRegistry
[09:29:19.444] result() for ClusterFuture ...
[09:29:19.444] - result already collected: FutureResult
[09:29:19.444] result() for ClusterFuture ... done
[09:29:19.444] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.445] Future #4
[09:29:19.445] result() for ClusterFuture ...
[09:29:19.445] - result already collected: FutureResult
[09:29:19.445] result() for ClusterFuture ... done
[09:29:19.445] result() for ClusterFuture ...
[09:29:19.445] - result already collected: FutureResult
[09:29:19.445] result() for ClusterFuture ... done
[09:29:19.445] signalConditionsASAP(MultisessionFuture, pos=4) ...
[09:29:19.445] - nx: 5
[09:29:19.445] - relay: TRUE
[09:29:19.445] - stdout: TRUE
[09:29:19.445] - signal: TRUE
[09:29:19.446] - resignal: FALSE
[09:29:19.446] - force: TRUE
[09:29:19.446] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[09:29:19.446] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[09:29:19.446]  - until=4
[09:29:19.446]  - relaying element #4
[09:29:19.446] result() for ClusterFuture ...
[09:29:19.446] - result already collected: FutureResult
[09:29:19.446] result() for ClusterFuture ... done
[09:29:19.446] result() for ClusterFuture ...
[09:29:19.446] - result already collected: FutureResult
[09:29:19.446] result() for ClusterFuture ... done
[09:29:19.447] result() for ClusterFuture ...
[09:29:19.447] - result already collected: FutureResult
[09:29:19.447] result() for ClusterFuture ... done
[09:29:19.447] result() for ClusterFuture ...
[09:29:19.447] - result already collected: FutureResult
[09:29:19.447] result() for ClusterFuture ... done
[09:29:19.447] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[09:29:19.447] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[09:29:19.447] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[09:29:19.447]  length: 1 (resolved future 4)
[09:29:19.468] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.468] - Validating connection of MultisessionFuture
[09:29:19.469] - received message: FutureResult
[09:29:19.469] - Received FutureResult
[09:29:19.469] - Erased future from FutureRegistry
[09:29:19.469] result() for ClusterFuture ...
[09:29:19.469] - result already collected: FutureResult
[09:29:19.469] result() for ClusterFuture ... done
[09:29:19.469] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.469] Future #5
[09:29:19.469] result() for ClusterFuture ...
[09:29:19.469] - result already collected: FutureResult
[09:29:19.469] result() for ClusterFuture ... done
[09:29:19.470] result() for ClusterFuture ...
[09:29:19.470] - result already collected: FutureResult
[09:29:19.470] result() for ClusterFuture ... done
[09:29:19.470] signalConditionsASAP(MultisessionFuture, pos=5) ...
[09:29:19.470] - nx: 5
[09:29:19.470] - relay: TRUE
[09:29:19.470] - stdout: TRUE
[09:29:19.470] - signal: TRUE
[09:29:19.470] - resignal: FALSE
[09:29:19.470] - force: TRUE
[09:29:19.470] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[09:29:19.470] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[09:29:19.471]  - until=5
[09:29:19.471]  - relaying element #5
[09:29:19.471] result() for ClusterFuture ...
[09:29:19.471] - result already collected: FutureResult
[09:29:19.471] result() for ClusterFuture ... done
[09:29:19.471] result() for ClusterFuture ...
[09:29:19.471] - result already collected: FutureResult
[09:29:19.471] result() for ClusterFuture ... done
[09:29:19.471] result() for ClusterFuture ...
[09:29:19.471] - result already collected: FutureResult
[09:29:19.471] result() for ClusterFuture ... done
[09:29:19.472] result() for ClusterFuture ...
[09:29:19.472] - result already collected: FutureResult
[09:29:19.472] result() for ClusterFuture ... done
[09:29:19.472] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:19.472] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:19.472] signalConditionsASAP(MultisessionFuture, pos=5) ... done
[09:29:19.472]  length: 0 (resolved future 5)
[09:29:19.472] Relaying remaining futures
[09:29:19.472] signalConditionsASAP(NULL, pos=0) ...
[09:29:19.472] - nx: 5
[09:29:19.472] - relay: TRUE
[09:29:19.472] - stdout: TRUE
[09:29:19.473] - signal: TRUE
[09:29:19.473] - resignal: FALSE
[09:29:19.473] - force: TRUE
[09:29:19.473] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:19.473] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[09:29:19.473] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:19.473] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[09:29:19.473] signalConditionsASAP(NULL, pos=0) ... done
[09:29:19.473] resolve() on list ... DONE
[09:29:19.473] result() for ClusterFuture ...
[09:29:19.473] - result already collected: FutureResult
[09:29:19.474] result() for ClusterFuture ... done
[09:29:19.474] result() for ClusterFuture ...
[09:29:19.474] - result already collected: FutureResult
[09:29:19.474] result() for ClusterFuture ... done
[09:29:19.474] result() for ClusterFuture ...
[09:29:19.474] - result already collected: FutureResult
[09:29:19.474] result() for ClusterFuture ... done
[09:29:19.474] result() for ClusterFuture ...
[09:29:19.474] - result already collected: FutureResult
[09:29:19.474] result() for ClusterFuture ... done
[09:29:19.474] result() for ClusterFuture ...
[09:29:19.474] - result already collected: FutureResult
[09:29:19.475] result() for ClusterFuture ... done
[09:29:19.475] result() for ClusterFuture ...
[09:29:19.475] - result already collected: FutureResult
[09:29:19.475] result() for ClusterFuture ... done
[09:29:19.475] result() for ClusterFuture ...
[09:29:19.475] - result already collected: FutureResult
[09:29:19.475] result() for ClusterFuture ... done
[09:29:19.475] result() for ClusterFuture ...
[09:29:19.475] - result already collected: FutureResult
[09:29:19.475] result() for ClusterFuture ... done
[09:29:19.475] result() for ClusterFuture ...
[09:29:19.475] - result already collected: FutureResult
[09:29:19.476] result() for ClusterFuture ... done
[09:29:19.476] result() for ClusterFuture ...
[09:29:19.476] - result already collected: FutureResult
[09:29:19.476] result() for ClusterFuture ... done
[09:29:19.476]  - Number of value chunks collected: 5
[09:29:19.476] Resolving 5 futures (chunks) ... DONE
[09:29:19.476] Reducing values from 5 chunks ...
[09:29:19.476]  - Number of values collected after concatenation: 5
[09:29:19.476]  - Number of values expected: 5
[09:29:19.476] Reducing values from 5 chunks ... DONE
[09:29:19.476] future_mapply() ... DONE
[09:29:19.477] future_mapply() ...
[09:29:19.480] Number of chunks: 2
[09:29:19.480] getGlobalsAndPackagesXApply() ...
[09:29:19.480]  - future.globals: TRUE
[09:29:19.480] getGlobalsAndPackages() ...
[09:29:19.480] Searching for globals...
[09:29:19.482] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:19.482] Searching for globals ... DONE
[09:29:19.482] Resolving globals: FALSE
[09:29:19.482] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:19.482] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:19.483] - globals: [1] ‘FUN’
[09:29:19.483] 
[09:29:19.483] getGlobalsAndPackages() ... DONE
[09:29:19.483]  - globals found/used: [n=1] ‘FUN’
[09:29:19.483]  - needed namespaces: [n=0] 
[09:29:19.483] Finding globals ... DONE
[09:29:19.483] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:19.483] List of 2
[09:29:19.483]  $ ...future.FUN:function (C, k)  
[09:29:19.483]  $ MoreArgs     : list()
[09:29:19.483]  - attr(*, "where")=List of 2
[09:29:19.483]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:19.483]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:19.483]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:19.483]  - attr(*, "resolved")= logi FALSE
[09:29:19.483]  - attr(*, "total_size")= num NA
[09:29:19.486] Packages to be attached in all futures: [n=0] 
[09:29:19.486] getGlobalsAndPackagesXApply() ... DONE
[09:29:19.486] Number of futures (= number of chunks): 2
[09:29:19.486] Launching 2 futures (chunks) ...
[09:29:19.486] Chunk #1 of 2 ...
[09:29:19.486]  - Finding globals in '...' for chunk #1 ...
[09:29:19.486] getGlobalsAndPackages() ...
[09:29:19.486] Searching for globals...
[09:29:19.487] 
[09:29:19.487] Searching for globals ... DONE
[09:29:19.487] - globals: [0] <none>
[09:29:19.487] getGlobalsAndPackages() ... DONE
[09:29:19.487]    + additional globals found: [n=0] 
[09:29:19.487]    + additional namespaces needed: [n=0] 
[09:29:19.487]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:19.487]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:19.487]  - seeds: <none>
[09:29:19.488]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.488] getGlobalsAndPackages() ...
[09:29:19.488] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.488] Resolving globals: FALSE
[09:29:19.488] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:19.489] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:19.489] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.489] 
[09:29:19.489] getGlobalsAndPackages() ... DONE
[09:29:19.489] run() for ‘Future’ ...
[09:29:19.489] - state: ‘created’
[09:29:19.490] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.503] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.503] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.503]   - Field: ‘node’
[09:29:19.503]   - Field: ‘label’
[09:29:19.503]   - Field: ‘local’
[09:29:19.504]   - Field: ‘owner’
[09:29:19.504]   - Field: ‘envir’
[09:29:19.504]   - Field: ‘workers’
[09:29:19.504]   - Field: ‘packages’
[09:29:19.504]   - Field: ‘gc’
[09:29:19.504]   - Field: ‘conditions’
[09:29:19.504]   - Field: ‘persistent’
[09:29:19.504]   - Field: ‘expr’
[09:29:19.504]   - Field: ‘uuid’
[09:29:19.504]   - Field: ‘seed’
[09:29:19.504]   - Field: ‘version’
[09:29:19.505]   - Field: ‘result’
[09:29:19.505]   - Field: ‘asynchronous’
[09:29:19.505]   - Field: ‘calls’
[09:29:19.505]   - Field: ‘globals’
[09:29:19.505]   - Field: ‘stdout’
[09:29:19.505]   - Field: ‘earlySignal’
[09:29:19.505]   - Field: ‘lazy’
[09:29:19.505]   - Field: ‘state’
[09:29:19.505] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.505] - Launch lazy future ...
[09:29:19.506] Packages needed by the future expression (n = 0): <none>
[09:29:19.506] Packages needed by future strategies (n = 0): <none>
[09:29:19.506] {
[09:29:19.506]     {
[09:29:19.506]         {
[09:29:19.506]             ...future.startTime <- base::Sys.time()
[09:29:19.506]             {
[09:29:19.506]                 {
[09:29:19.506]                   {
[09:29:19.506]                     {
[09:29:19.506]                       base::local({
[09:29:19.506]                         has_future <- base::requireNamespace("future", 
[09:29:19.506]                           quietly = TRUE)
[09:29:19.506]                         if (has_future) {
[09:29:19.506]                           ns <- base::getNamespace("future")
[09:29:19.506]                           version <- ns[[".package"]][["version"]]
[09:29:19.506]                           if (is.null(version)) 
[09:29:19.506]                             version <- utils::packageVersion("future")
[09:29:19.506]                         }
[09:29:19.506]                         else {
[09:29:19.506]                           version <- NULL
[09:29:19.506]                         }
[09:29:19.506]                         if (!has_future || version < "1.8.0") {
[09:29:19.506]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.506]                             "", base::R.version$version.string), 
[09:29:19.506]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.506]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.506]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.506]                               "release", "version")], collapse = " "), 
[09:29:19.506]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.506]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.506]                             info)
[09:29:19.506]                           info <- base::paste(info, collapse = "; ")
[09:29:19.506]                           if (!has_future) {
[09:29:19.506]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.506]                               info)
[09:29:19.506]                           }
[09:29:19.506]                           else {
[09:29:19.506]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.506]                               info, version)
[09:29:19.506]                           }
[09:29:19.506]                           base::stop(msg)
[09:29:19.506]                         }
[09:29:19.506]                       })
[09:29:19.506]                     }
[09:29:19.506]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.506]                     base::options(mc.cores = 1L)
[09:29:19.506]                   }
[09:29:19.506]                   ...future.strategy.old <- future::plan("list")
[09:29:19.506]                   options(future.plan = NULL)
[09:29:19.506]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.506]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.506]                 }
[09:29:19.506]                 ...future.workdir <- getwd()
[09:29:19.506]             }
[09:29:19.506]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.506]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.506]         }
[09:29:19.506]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.506]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:19.506]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.506]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.506]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.506]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.506]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.506]             base::names(...future.oldOptions))
[09:29:19.506]     }
[09:29:19.506]     if (FALSE) {
[09:29:19.506]     }
[09:29:19.506]     else {
[09:29:19.506]         if (TRUE) {
[09:29:19.506]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.506]                 open = "w")
[09:29:19.506]         }
[09:29:19.506]         else {
[09:29:19.506]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.506]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.506]         }
[09:29:19.506]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.506]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.506]             base::sink(type = "output", split = FALSE)
[09:29:19.506]             base::close(...future.stdout)
[09:29:19.506]         }, add = TRUE)
[09:29:19.506]     }
[09:29:19.506]     ...future.frame <- base::sys.nframe()
[09:29:19.506]     ...future.conditions <- base::list()
[09:29:19.506]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.506]     if (FALSE) {
[09:29:19.506]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.506]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.506]     }
[09:29:19.506]     ...future.result <- base::tryCatch({
[09:29:19.506]         base::withCallingHandlers({
[09:29:19.506]             ...future.value <- base::withVisible(base::local({
[09:29:19.506]                 ...future.makeSendCondition <- base::local({
[09:29:19.506]                   sendCondition <- NULL
[09:29:19.506]                   function(frame = 1L) {
[09:29:19.506]                     if (is.function(sendCondition)) 
[09:29:19.506]                       return(sendCondition)
[09:29:19.506]                     ns <- getNamespace("parallel")
[09:29:19.506]                     if (exists("sendData", mode = "function", 
[09:29:19.506]                       envir = ns)) {
[09:29:19.506]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.506]                         envir = ns)
[09:29:19.506]                       envir <- sys.frame(frame)
[09:29:19.506]                       master <- NULL
[09:29:19.506]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.506]                         !identical(envir, emptyenv())) {
[09:29:19.506]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.506]                           inherits = FALSE)) {
[09:29:19.506]                           master <- get("master", mode = "list", 
[09:29:19.506]                             envir = envir, inherits = FALSE)
[09:29:19.506]                           if (inherits(master, c("SOCKnode", 
[09:29:19.506]                             "SOCK0node"))) {
[09:29:19.506]                             sendCondition <<- function(cond) {
[09:29:19.506]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.506]                                 success = TRUE)
[09:29:19.506]                               parallel_sendData(master, data)
[09:29:19.506]                             }
[09:29:19.506]                             return(sendCondition)
[09:29:19.506]                           }
[09:29:19.506]                         }
[09:29:19.506]                         frame <- frame + 1L
[09:29:19.506]                         envir <- sys.frame(frame)
[09:29:19.506]                       }
[09:29:19.506]                     }
[09:29:19.506]                     sendCondition <<- function(cond) NULL
[09:29:19.506]                   }
[09:29:19.506]                 })
[09:29:19.506]                 withCallingHandlers({
[09:29:19.506]                   {
[09:29:19.506]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.506]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.506]                       ...future.globals.maxSize)) {
[09:29:19.506]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.506]                       on.exit(options(oopts), add = TRUE)
[09:29:19.506]                     }
[09:29:19.506]                     {
[09:29:19.506]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.506]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.506]                         USE.NAMES = FALSE)
[09:29:19.506]                       do.call(mapply, args = args)
[09:29:19.506]                     }
[09:29:19.506]                   }
[09:29:19.506]                 }, immediateCondition = function(cond) {
[09:29:19.506]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.506]                   sendCondition(cond)
[09:29:19.506]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.506]                   {
[09:29:19.506]                     inherits <- base::inherits
[09:29:19.506]                     invokeRestart <- base::invokeRestart
[09:29:19.506]                     is.null <- base::is.null
[09:29:19.506]                     muffled <- FALSE
[09:29:19.506]                     if (inherits(cond, "message")) {
[09:29:19.506]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.506]                       if (muffled) 
[09:29:19.506]                         invokeRestart("muffleMessage")
[09:29:19.506]                     }
[09:29:19.506]                     else if (inherits(cond, "warning")) {
[09:29:19.506]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.506]                       if (muffled) 
[09:29:19.506]                         invokeRestart("muffleWarning")
[09:29:19.506]                     }
[09:29:19.506]                     else if (inherits(cond, "condition")) {
[09:29:19.506]                       if (!is.null(pattern)) {
[09:29:19.506]                         computeRestarts <- base::computeRestarts
[09:29:19.506]                         grepl <- base::grepl
[09:29:19.506]                         restarts <- computeRestarts(cond)
[09:29:19.506]                         for (restart in restarts) {
[09:29:19.506]                           name <- restart$name
[09:29:19.506]                           if (is.null(name)) 
[09:29:19.506]                             next
[09:29:19.506]                           if (!grepl(pattern, name)) 
[09:29:19.506]                             next
[09:29:19.506]                           invokeRestart(restart)
[09:29:19.506]                           muffled <- TRUE
[09:29:19.506]                           break
[09:29:19.506]                         }
[09:29:19.506]                       }
[09:29:19.506]                     }
[09:29:19.506]                     invisible(muffled)
[09:29:19.506]                   }
[09:29:19.506]                   muffleCondition(cond)
[09:29:19.506]                 })
[09:29:19.506]             }))
[09:29:19.506]             future::FutureResult(value = ...future.value$value, 
[09:29:19.506]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.506]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.506]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.506]                     ...future.globalenv.names))
[09:29:19.506]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.506]         }, condition = base::local({
[09:29:19.506]             c <- base::c
[09:29:19.506]             inherits <- base::inherits
[09:29:19.506]             invokeRestart <- base::invokeRestart
[09:29:19.506]             length <- base::length
[09:29:19.506]             list <- base::list
[09:29:19.506]             seq.int <- base::seq.int
[09:29:19.506]             signalCondition <- base::signalCondition
[09:29:19.506]             sys.calls <- base::sys.calls
[09:29:19.506]             `[[` <- base::`[[`
[09:29:19.506]             `+` <- base::`+`
[09:29:19.506]             `<<-` <- base::`<<-`
[09:29:19.506]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.506]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.506]                   3L)]
[09:29:19.506]             }
[09:29:19.506]             function(cond) {
[09:29:19.506]                 is_error <- inherits(cond, "error")
[09:29:19.506]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.506]                   NULL)
[09:29:19.506]                 if (is_error) {
[09:29:19.506]                   sessionInformation <- function() {
[09:29:19.506]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.506]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.506]                       search = base::search(), system = base::Sys.info())
[09:29:19.506]                   }
[09:29:19.506]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.506]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.506]                     cond$call), session = sessionInformation(), 
[09:29:19.506]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.506]                   signalCondition(cond)
[09:29:19.506]                 }
[09:29:19.506]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.506]                 "immediateCondition"))) {
[09:29:19.506]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.506]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.506]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.506]                   if (TRUE && !signal) {
[09:29:19.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.506]                     {
[09:29:19.506]                       inherits <- base::inherits
[09:29:19.506]                       invokeRestart <- base::invokeRestart
[09:29:19.506]                       is.null <- base::is.null
[09:29:19.506]                       muffled <- FALSE
[09:29:19.506]                       if (inherits(cond, "message")) {
[09:29:19.506]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.506]                         if (muffled) 
[09:29:19.506]                           invokeRestart("muffleMessage")
[09:29:19.506]                       }
[09:29:19.506]                       else if (inherits(cond, "warning")) {
[09:29:19.506]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.506]                         if (muffled) 
[09:29:19.506]                           invokeRestart("muffleWarning")
[09:29:19.506]                       }
[09:29:19.506]                       else if (inherits(cond, "condition")) {
[09:29:19.506]                         if (!is.null(pattern)) {
[09:29:19.506]                           computeRestarts <- base::computeRestarts
[09:29:19.506]                           grepl <- base::grepl
[09:29:19.506]                           restarts <- computeRestarts(cond)
[09:29:19.506]                           for (restart in restarts) {
[09:29:19.506]                             name <- restart$name
[09:29:19.506]                             if (is.null(name)) 
[09:29:19.506]                               next
[09:29:19.506]                             if (!grepl(pattern, name)) 
[09:29:19.506]                               next
[09:29:19.506]                             invokeRestart(restart)
[09:29:19.506]                             muffled <- TRUE
[09:29:19.506]                             break
[09:29:19.506]                           }
[09:29:19.506]                         }
[09:29:19.506]                       }
[09:29:19.506]                       invisible(muffled)
[09:29:19.506]                     }
[09:29:19.506]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.506]                   }
[09:29:19.506]                 }
[09:29:19.506]                 else {
[09:29:19.506]                   if (TRUE) {
[09:29:19.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.506]                     {
[09:29:19.506]                       inherits <- base::inherits
[09:29:19.506]                       invokeRestart <- base::invokeRestart
[09:29:19.506]                       is.null <- base::is.null
[09:29:19.506]                       muffled <- FALSE
[09:29:19.506]                       if (inherits(cond, "message")) {
[09:29:19.506]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.506]                         if (muffled) 
[09:29:19.506]                           invokeRestart("muffleMessage")
[09:29:19.506]                       }
[09:29:19.506]                       else if (inherits(cond, "warning")) {
[09:29:19.506]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.506]                         if (muffled) 
[09:29:19.506]                           invokeRestart("muffleWarning")
[09:29:19.506]                       }
[09:29:19.506]                       else if (inherits(cond, "condition")) {
[09:29:19.506]                         if (!is.null(pattern)) {
[09:29:19.506]                           computeRestarts <- base::computeRestarts
[09:29:19.506]                           grepl <- base::grepl
[09:29:19.506]                           restarts <- computeRestarts(cond)
[09:29:19.506]                           for (restart in restarts) {
[09:29:19.506]                             name <- restart$name
[09:29:19.506]                             if (is.null(name)) 
[09:29:19.506]                               next
[09:29:19.506]                             if (!grepl(pattern, name)) 
[09:29:19.506]                               next
[09:29:19.506]                             invokeRestart(restart)
[09:29:19.506]                             muffled <- TRUE
[09:29:19.506]                             break
[09:29:19.506]                           }
[09:29:19.506]                         }
[09:29:19.506]                       }
[09:29:19.506]                       invisible(muffled)
[09:29:19.506]                     }
[09:29:19.506]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.506]                   }
[09:29:19.506]                 }
[09:29:19.506]             }
[09:29:19.506]         }))
[09:29:19.506]     }, error = function(ex) {
[09:29:19.506]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.506]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.506]                 ...future.rng), started = ...future.startTime, 
[09:29:19.506]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.506]             version = "1.8"), class = "FutureResult")
[09:29:19.506]     }, finally = {
[09:29:19.506]         if (!identical(...future.workdir, getwd())) 
[09:29:19.506]             setwd(...future.workdir)
[09:29:19.506]         {
[09:29:19.506]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.506]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.506]             }
[09:29:19.506]             base::options(...future.oldOptions)
[09:29:19.506]             if (.Platform$OS.type == "windows") {
[09:29:19.506]                 old_names <- names(...future.oldEnvVars)
[09:29:19.506]                 envs <- base::Sys.getenv()
[09:29:19.506]                 names <- names(envs)
[09:29:19.506]                 common <- intersect(names, old_names)
[09:29:19.506]                 added <- setdiff(names, old_names)
[09:29:19.506]                 removed <- setdiff(old_names, names)
[09:29:19.506]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.506]                   envs[common]]
[09:29:19.506]                 NAMES <- toupper(changed)
[09:29:19.506]                 args <- list()
[09:29:19.506]                 for (kk in seq_along(NAMES)) {
[09:29:19.506]                   name <- changed[[kk]]
[09:29:19.506]                   NAME <- NAMES[[kk]]
[09:29:19.506]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.506]                     next
[09:29:19.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.506]                 }
[09:29:19.506]                 NAMES <- toupper(added)
[09:29:19.506]                 for (kk in seq_along(NAMES)) {
[09:29:19.506]                   name <- added[[kk]]
[09:29:19.506]                   NAME <- NAMES[[kk]]
[09:29:19.506]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.506]                     next
[09:29:19.506]                   args[[name]] <- ""
[09:29:19.506]                 }
[09:29:19.506]                 NAMES <- toupper(removed)
[09:29:19.506]                 for (kk in seq_along(NAMES)) {
[09:29:19.506]                   name <- removed[[kk]]
[09:29:19.506]                   NAME <- NAMES[[kk]]
[09:29:19.506]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.506]                     next
[09:29:19.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.506]                 }
[09:29:19.506]                 if (length(args) > 0) 
[09:29:19.506]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.506]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.506]             }
[09:29:19.506]             else {
[09:29:19.506]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.506]             }
[09:29:19.506]             {
[09:29:19.506]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.506]                   0L) {
[09:29:19.506]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.506]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.506]                   base::options(opts)
[09:29:19.506]                 }
[09:29:19.506]                 {
[09:29:19.506]                   {
[09:29:19.506]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.506]                     NULL
[09:29:19.506]                   }
[09:29:19.506]                   options(future.plan = NULL)
[09:29:19.506]                   if (is.na(NA_character_)) 
[09:29:19.506]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.506]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.506]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.506]                     .init = FALSE)
[09:29:19.506]                 }
[09:29:19.506]             }
[09:29:19.506]         }
[09:29:19.506]     })
[09:29:19.506]     if (TRUE) {
[09:29:19.506]         base::sink(type = "output", split = FALSE)
[09:29:19.506]         if (TRUE) {
[09:29:19.506]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.506]         }
[09:29:19.506]         else {
[09:29:19.506]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.506]         }
[09:29:19.506]         base::close(...future.stdout)
[09:29:19.506]         ...future.stdout <- NULL
[09:29:19.506]     }
[09:29:19.506]     ...future.result$conditions <- ...future.conditions
[09:29:19.506]     ...future.result$finished <- base::Sys.time()
[09:29:19.506]     ...future.result
[09:29:19.506] }
[09:29:19.509] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[09:29:19.509] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[09:29:19.509] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[09:29:19.509] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:19.510] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.510] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[09:29:19.510] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[09:29:19.510] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:19.511] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.511] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:19.511] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.511] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[09:29:19.512] MultisessionFuture started
[09:29:19.512] - Launch lazy future ... done
[09:29:19.512] run() for ‘MultisessionFuture’ ... done
[09:29:19.512] Created future:
[09:29:19.512] MultisessionFuture:
[09:29:19.512] Label: ‘future_.mapply-1’
[09:29:19.512] Expression:
[09:29:19.512] {
[09:29:19.512]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.512]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.512]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.512]         on.exit(options(oopts), add = TRUE)
[09:29:19.512]     }
[09:29:19.512]     {
[09:29:19.512]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.512]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.512]         do.call(mapply, args = args)
[09:29:19.512]     }
[09:29:19.512] }
[09:29:19.512] Lazy evaluation: FALSE
[09:29:19.512] Asynchronous evaluation: TRUE
[09:29:19.512] Local evaluation: TRUE
[09:29:19.512] Environment: R_GlobalEnv
[09:29:19.512] Capture standard output: TRUE
[09:29:19.512] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.512] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.512] Packages: <none>
[09:29:19.512] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.512] Resolved: FALSE
[09:29:19.512] Value: <not collected>
[09:29:19.512] Conditions captured: <none>
[09:29:19.512] Early signaling: FALSE
[09:29:19.512] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.512] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.524] Chunk #1 of 2 ... DONE
[09:29:19.524] Chunk #2 of 2 ...
[09:29:19.524]  - Finding globals in '...' for chunk #2 ...
[09:29:19.524] getGlobalsAndPackages() ...
[09:29:19.524] Searching for globals...
[09:29:19.525] 
[09:29:19.525] Searching for globals ... DONE
[09:29:19.525] - globals: [0] <none>
[09:29:19.525] getGlobalsAndPackages() ... DONE
[09:29:19.525]    + additional globals found: [n=0] 
[09:29:19.525]    + additional namespaces needed: [n=0] 
[09:29:19.525]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:19.525]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:19.525]  - seeds: <none>
[09:29:19.525]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.526] getGlobalsAndPackages() ...
[09:29:19.526] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.526] Resolving globals: FALSE
[09:29:19.526] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[09:29:19.527] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:19.527] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.527] 
[09:29:19.527] getGlobalsAndPackages() ... DONE
[09:29:19.527] run() for ‘Future’ ...
[09:29:19.527] - state: ‘created’
[09:29:19.527] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.543] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.543] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.543]   - Field: ‘node’
[09:29:19.543]   - Field: ‘label’
[09:29:19.543]   - Field: ‘local’
[09:29:19.544]   - Field: ‘owner’
[09:29:19.544]   - Field: ‘envir’
[09:29:19.544]   - Field: ‘workers’
[09:29:19.544]   - Field: ‘packages’
[09:29:19.544]   - Field: ‘gc’
[09:29:19.544]   - Field: ‘conditions’
[09:29:19.544]   - Field: ‘persistent’
[09:29:19.544]   - Field: ‘expr’
[09:29:19.544]   - Field: ‘uuid’
[09:29:19.544]   - Field: ‘seed’
[09:29:19.544]   - Field: ‘version’
[09:29:19.545]   - Field: ‘result’
[09:29:19.545]   - Field: ‘asynchronous’
[09:29:19.545]   - Field: ‘calls’
[09:29:19.545]   - Field: ‘globals’
[09:29:19.545]   - Field: ‘stdout’
[09:29:19.545]   - Field: ‘earlySignal’
[09:29:19.545]   - Field: ‘lazy’
[09:29:19.545]   - Field: ‘state’
[09:29:19.545] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.545] - Launch lazy future ...
[09:29:19.546] Packages needed by the future expression (n = 0): <none>
[09:29:19.546] Packages needed by future strategies (n = 0): <none>
[09:29:19.546] {
[09:29:19.546]     {
[09:29:19.546]         {
[09:29:19.546]             ...future.startTime <- base::Sys.time()
[09:29:19.546]             {
[09:29:19.546]                 {
[09:29:19.546]                   {
[09:29:19.546]                     {
[09:29:19.546]                       base::local({
[09:29:19.546]                         has_future <- base::requireNamespace("future", 
[09:29:19.546]                           quietly = TRUE)
[09:29:19.546]                         if (has_future) {
[09:29:19.546]                           ns <- base::getNamespace("future")
[09:29:19.546]                           version <- ns[[".package"]][["version"]]
[09:29:19.546]                           if (is.null(version)) 
[09:29:19.546]                             version <- utils::packageVersion("future")
[09:29:19.546]                         }
[09:29:19.546]                         else {
[09:29:19.546]                           version <- NULL
[09:29:19.546]                         }
[09:29:19.546]                         if (!has_future || version < "1.8.0") {
[09:29:19.546]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.546]                             "", base::R.version$version.string), 
[09:29:19.546]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.546]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.546]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.546]                               "release", "version")], collapse = " "), 
[09:29:19.546]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.546]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.546]                             info)
[09:29:19.546]                           info <- base::paste(info, collapse = "; ")
[09:29:19.546]                           if (!has_future) {
[09:29:19.546]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.546]                               info)
[09:29:19.546]                           }
[09:29:19.546]                           else {
[09:29:19.546]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.546]                               info, version)
[09:29:19.546]                           }
[09:29:19.546]                           base::stop(msg)
[09:29:19.546]                         }
[09:29:19.546]                       })
[09:29:19.546]                     }
[09:29:19.546]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.546]                     base::options(mc.cores = 1L)
[09:29:19.546]                   }
[09:29:19.546]                   ...future.strategy.old <- future::plan("list")
[09:29:19.546]                   options(future.plan = NULL)
[09:29:19.546]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.546]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.546]                 }
[09:29:19.546]                 ...future.workdir <- getwd()
[09:29:19.546]             }
[09:29:19.546]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.546]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.546]         }
[09:29:19.546]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.546]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:19.546]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.546]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.546]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.546]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.546]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.546]             base::names(...future.oldOptions))
[09:29:19.546]     }
[09:29:19.546]     if (FALSE) {
[09:29:19.546]     }
[09:29:19.546]     else {
[09:29:19.546]         if (TRUE) {
[09:29:19.546]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.546]                 open = "w")
[09:29:19.546]         }
[09:29:19.546]         else {
[09:29:19.546]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.546]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.546]         }
[09:29:19.546]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.546]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.546]             base::sink(type = "output", split = FALSE)
[09:29:19.546]             base::close(...future.stdout)
[09:29:19.546]         }, add = TRUE)
[09:29:19.546]     }
[09:29:19.546]     ...future.frame <- base::sys.nframe()
[09:29:19.546]     ...future.conditions <- base::list()
[09:29:19.546]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.546]     if (FALSE) {
[09:29:19.546]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.546]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.546]     }
[09:29:19.546]     ...future.result <- base::tryCatch({
[09:29:19.546]         base::withCallingHandlers({
[09:29:19.546]             ...future.value <- base::withVisible(base::local({
[09:29:19.546]                 ...future.makeSendCondition <- base::local({
[09:29:19.546]                   sendCondition <- NULL
[09:29:19.546]                   function(frame = 1L) {
[09:29:19.546]                     if (is.function(sendCondition)) 
[09:29:19.546]                       return(sendCondition)
[09:29:19.546]                     ns <- getNamespace("parallel")
[09:29:19.546]                     if (exists("sendData", mode = "function", 
[09:29:19.546]                       envir = ns)) {
[09:29:19.546]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.546]                         envir = ns)
[09:29:19.546]                       envir <- sys.frame(frame)
[09:29:19.546]                       master <- NULL
[09:29:19.546]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.546]                         !identical(envir, emptyenv())) {
[09:29:19.546]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.546]                           inherits = FALSE)) {
[09:29:19.546]                           master <- get("master", mode = "list", 
[09:29:19.546]                             envir = envir, inherits = FALSE)
[09:29:19.546]                           if (inherits(master, c("SOCKnode", 
[09:29:19.546]                             "SOCK0node"))) {
[09:29:19.546]                             sendCondition <<- function(cond) {
[09:29:19.546]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.546]                                 success = TRUE)
[09:29:19.546]                               parallel_sendData(master, data)
[09:29:19.546]                             }
[09:29:19.546]                             return(sendCondition)
[09:29:19.546]                           }
[09:29:19.546]                         }
[09:29:19.546]                         frame <- frame + 1L
[09:29:19.546]                         envir <- sys.frame(frame)
[09:29:19.546]                       }
[09:29:19.546]                     }
[09:29:19.546]                     sendCondition <<- function(cond) NULL
[09:29:19.546]                   }
[09:29:19.546]                 })
[09:29:19.546]                 withCallingHandlers({
[09:29:19.546]                   {
[09:29:19.546]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.546]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.546]                       ...future.globals.maxSize)) {
[09:29:19.546]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.546]                       on.exit(options(oopts), add = TRUE)
[09:29:19.546]                     }
[09:29:19.546]                     {
[09:29:19.546]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.546]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.546]                         USE.NAMES = FALSE)
[09:29:19.546]                       do.call(mapply, args = args)
[09:29:19.546]                     }
[09:29:19.546]                   }
[09:29:19.546]                 }, immediateCondition = function(cond) {
[09:29:19.546]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.546]                   sendCondition(cond)
[09:29:19.546]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.546]                   {
[09:29:19.546]                     inherits <- base::inherits
[09:29:19.546]                     invokeRestart <- base::invokeRestart
[09:29:19.546]                     is.null <- base::is.null
[09:29:19.546]                     muffled <- FALSE
[09:29:19.546]                     if (inherits(cond, "message")) {
[09:29:19.546]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.546]                       if (muffled) 
[09:29:19.546]                         invokeRestart("muffleMessage")
[09:29:19.546]                     }
[09:29:19.546]                     else if (inherits(cond, "warning")) {
[09:29:19.546]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.546]                       if (muffled) 
[09:29:19.546]                         invokeRestart("muffleWarning")
[09:29:19.546]                     }
[09:29:19.546]                     else if (inherits(cond, "condition")) {
[09:29:19.546]                       if (!is.null(pattern)) {
[09:29:19.546]                         computeRestarts <- base::computeRestarts
[09:29:19.546]                         grepl <- base::grepl
[09:29:19.546]                         restarts <- computeRestarts(cond)
[09:29:19.546]                         for (restart in restarts) {
[09:29:19.546]                           name <- restart$name
[09:29:19.546]                           if (is.null(name)) 
[09:29:19.546]                             next
[09:29:19.546]                           if (!grepl(pattern, name)) 
[09:29:19.546]                             next
[09:29:19.546]                           invokeRestart(restart)
[09:29:19.546]                           muffled <- TRUE
[09:29:19.546]                           break
[09:29:19.546]                         }
[09:29:19.546]                       }
[09:29:19.546]                     }
[09:29:19.546]                     invisible(muffled)
[09:29:19.546]                   }
[09:29:19.546]                   muffleCondition(cond)
[09:29:19.546]                 })
[09:29:19.546]             }))
[09:29:19.546]             future::FutureResult(value = ...future.value$value, 
[09:29:19.546]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.546]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.546]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.546]                     ...future.globalenv.names))
[09:29:19.546]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.546]         }, condition = base::local({
[09:29:19.546]             c <- base::c
[09:29:19.546]             inherits <- base::inherits
[09:29:19.546]             invokeRestart <- base::invokeRestart
[09:29:19.546]             length <- base::length
[09:29:19.546]             list <- base::list
[09:29:19.546]             seq.int <- base::seq.int
[09:29:19.546]             signalCondition <- base::signalCondition
[09:29:19.546]             sys.calls <- base::sys.calls
[09:29:19.546]             `[[` <- base::`[[`
[09:29:19.546]             `+` <- base::`+`
[09:29:19.546]             `<<-` <- base::`<<-`
[09:29:19.546]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.546]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.546]                   3L)]
[09:29:19.546]             }
[09:29:19.546]             function(cond) {
[09:29:19.546]                 is_error <- inherits(cond, "error")
[09:29:19.546]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.546]                   NULL)
[09:29:19.546]                 if (is_error) {
[09:29:19.546]                   sessionInformation <- function() {
[09:29:19.546]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.546]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.546]                       search = base::search(), system = base::Sys.info())
[09:29:19.546]                   }
[09:29:19.546]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.546]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.546]                     cond$call), session = sessionInformation(), 
[09:29:19.546]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.546]                   signalCondition(cond)
[09:29:19.546]                 }
[09:29:19.546]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.546]                 "immediateCondition"))) {
[09:29:19.546]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.546]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.546]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.546]                   if (TRUE && !signal) {
[09:29:19.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.546]                     {
[09:29:19.546]                       inherits <- base::inherits
[09:29:19.546]                       invokeRestart <- base::invokeRestart
[09:29:19.546]                       is.null <- base::is.null
[09:29:19.546]                       muffled <- FALSE
[09:29:19.546]                       if (inherits(cond, "message")) {
[09:29:19.546]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.546]                         if (muffled) 
[09:29:19.546]                           invokeRestart("muffleMessage")
[09:29:19.546]                       }
[09:29:19.546]                       else if (inherits(cond, "warning")) {
[09:29:19.546]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.546]                         if (muffled) 
[09:29:19.546]                           invokeRestart("muffleWarning")
[09:29:19.546]                       }
[09:29:19.546]                       else if (inherits(cond, "condition")) {
[09:29:19.546]                         if (!is.null(pattern)) {
[09:29:19.546]                           computeRestarts <- base::computeRestarts
[09:29:19.546]                           grepl <- base::grepl
[09:29:19.546]                           restarts <- computeRestarts(cond)
[09:29:19.546]                           for (restart in restarts) {
[09:29:19.546]                             name <- restart$name
[09:29:19.546]                             if (is.null(name)) 
[09:29:19.546]                               next
[09:29:19.546]                             if (!grepl(pattern, name)) 
[09:29:19.546]                               next
[09:29:19.546]                             invokeRestart(restart)
[09:29:19.546]                             muffled <- TRUE
[09:29:19.546]                             break
[09:29:19.546]                           }
[09:29:19.546]                         }
[09:29:19.546]                       }
[09:29:19.546]                       invisible(muffled)
[09:29:19.546]                     }
[09:29:19.546]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.546]                   }
[09:29:19.546]                 }
[09:29:19.546]                 else {
[09:29:19.546]                   if (TRUE) {
[09:29:19.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.546]                     {
[09:29:19.546]                       inherits <- base::inherits
[09:29:19.546]                       invokeRestart <- base::invokeRestart
[09:29:19.546]                       is.null <- base::is.null
[09:29:19.546]                       muffled <- FALSE
[09:29:19.546]                       if (inherits(cond, "message")) {
[09:29:19.546]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.546]                         if (muffled) 
[09:29:19.546]                           invokeRestart("muffleMessage")
[09:29:19.546]                       }
[09:29:19.546]                       else if (inherits(cond, "warning")) {
[09:29:19.546]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.546]                         if (muffled) 
[09:29:19.546]                           invokeRestart("muffleWarning")
[09:29:19.546]                       }
[09:29:19.546]                       else if (inherits(cond, "condition")) {
[09:29:19.546]                         if (!is.null(pattern)) {
[09:29:19.546]                           computeRestarts <- base::computeRestarts
[09:29:19.546]                           grepl <- base::grepl
[09:29:19.546]                           restarts <- computeRestarts(cond)
[09:29:19.546]                           for (restart in restarts) {
[09:29:19.546]                             name <- restart$name
[09:29:19.546]                             if (is.null(name)) 
[09:29:19.546]                               next
[09:29:19.546]                             if (!grepl(pattern, name)) 
[09:29:19.546]                               next
[09:29:19.546]                             invokeRestart(restart)
[09:29:19.546]                             muffled <- TRUE
[09:29:19.546]                             break
[09:29:19.546]                           }
[09:29:19.546]                         }
[09:29:19.546]                       }
[09:29:19.546]                       invisible(muffled)
[09:29:19.546]                     }
[09:29:19.546]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.546]                   }
[09:29:19.546]                 }
[09:29:19.546]             }
[09:29:19.546]         }))
[09:29:19.546]     }, error = function(ex) {
[09:29:19.546]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.546]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.546]                 ...future.rng), started = ...future.startTime, 
[09:29:19.546]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.546]             version = "1.8"), class = "FutureResult")
[09:29:19.546]     }, finally = {
[09:29:19.546]         if (!identical(...future.workdir, getwd())) 
[09:29:19.546]             setwd(...future.workdir)
[09:29:19.546]         {
[09:29:19.546]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.546]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.546]             }
[09:29:19.546]             base::options(...future.oldOptions)
[09:29:19.546]             if (.Platform$OS.type == "windows") {
[09:29:19.546]                 old_names <- names(...future.oldEnvVars)
[09:29:19.546]                 envs <- base::Sys.getenv()
[09:29:19.546]                 names <- names(envs)
[09:29:19.546]                 common <- intersect(names, old_names)
[09:29:19.546]                 added <- setdiff(names, old_names)
[09:29:19.546]                 removed <- setdiff(old_names, names)
[09:29:19.546]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.546]                   envs[common]]
[09:29:19.546]                 NAMES <- toupper(changed)
[09:29:19.546]                 args <- list()
[09:29:19.546]                 for (kk in seq_along(NAMES)) {
[09:29:19.546]                   name <- changed[[kk]]
[09:29:19.546]                   NAME <- NAMES[[kk]]
[09:29:19.546]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.546]                     next
[09:29:19.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.546]                 }
[09:29:19.546]                 NAMES <- toupper(added)
[09:29:19.546]                 for (kk in seq_along(NAMES)) {
[09:29:19.546]                   name <- added[[kk]]
[09:29:19.546]                   NAME <- NAMES[[kk]]
[09:29:19.546]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.546]                     next
[09:29:19.546]                   args[[name]] <- ""
[09:29:19.546]                 }
[09:29:19.546]                 NAMES <- toupper(removed)
[09:29:19.546]                 for (kk in seq_along(NAMES)) {
[09:29:19.546]                   name <- removed[[kk]]
[09:29:19.546]                   NAME <- NAMES[[kk]]
[09:29:19.546]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.546]                     next
[09:29:19.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.546]                 }
[09:29:19.546]                 if (length(args) > 0) 
[09:29:19.546]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.546]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.546]             }
[09:29:19.546]             else {
[09:29:19.546]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.546]             }
[09:29:19.546]             {
[09:29:19.546]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.546]                   0L) {
[09:29:19.546]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.546]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.546]                   base::options(opts)
[09:29:19.546]                 }
[09:29:19.546]                 {
[09:29:19.546]                   {
[09:29:19.546]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.546]                     NULL
[09:29:19.546]                   }
[09:29:19.546]                   options(future.plan = NULL)
[09:29:19.546]                   if (is.na(NA_character_)) 
[09:29:19.546]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.546]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.546]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.546]                     .init = FALSE)
[09:29:19.546]                 }
[09:29:19.546]             }
[09:29:19.546]         }
[09:29:19.546]     })
[09:29:19.546]     if (TRUE) {
[09:29:19.546]         base::sink(type = "output", split = FALSE)
[09:29:19.546]         if (TRUE) {
[09:29:19.546]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.546]         }
[09:29:19.546]         else {
[09:29:19.546]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.546]         }
[09:29:19.546]         base::close(...future.stdout)
[09:29:19.546]         ...future.stdout <- NULL
[09:29:19.546]     }
[09:29:19.546]     ...future.result$conditions <- ...future.conditions
[09:29:19.546]     ...future.result$finished <- base::Sys.time()
[09:29:19.546]     ...future.result
[09:29:19.546] }
[09:29:19.549] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[09:29:19.549] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[09:29:19.549] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[09:29:19.549] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:19.550] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.550] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[09:29:19.550] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[09:29:19.550] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:19.551] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.551] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:19.551] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.551] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[09:29:19.552] MultisessionFuture started
[09:29:19.552] - Launch lazy future ... done
[09:29:19.552] run() for ‘MultisessionFuture’ ... done
[09:29:19.552] Created future:
[09:29:19.552] MultisessionFuture:
[09:29:19.552] Label: ‘future_.mapply-2’
[09:29:19.552] Expression:
[09:29:19.552] {
[09:29:19.552]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.552]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.552]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.552]         on.exit(options(oopts), add = TRUE)
[09:29:19.552]     }
[09:29:19.552]     {
[09:29:19.552]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.552]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.552]         do.call(mapply, args = args)
[09:29:19.552]     }
[09:29:19.552] }
[09:29:19.552] Lazy evaluation: FALSE
[09:29:19.552] Asynchronous evaluation: TRUE
[09:29:19.552] Local evaluation: TRUE
[09:29:19.552] Environment: R_GlobalEnv
[09:29:19.552] Capture standard output: TRUE
[09:29:19.552] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.552] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.552] Packages: <none>
[09:29:19.552] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.552] Resolved: FALSE
[09:29:19.552] Value: <not collected>
[09:29:19.552] Conditions captured: <none>
[09:29:19.552] Early signaling: FALSE
[09:29:19.552] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.552] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.564] Chunk #2 of 2 ... DONE
[09:29:19.564] Launching 2 futures (chunks) ... DONE
[09:29:19.564] Resolving 2 futures (chunks) ...
[09:29:19.564] resolve() on list ...
[09:29:19.564]  recursive: 0
[09:29:19.564]  length: 2
[09:29:19.564] 
[09:29:19.565] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.565] - Validating connection of MultisessionFuture
[09:29:19.565] - received message: FutureResult
[09:29:19.565] - Received FutureResult
[09:29:19.565] - Erased future from FutureRegistry
[09:29:19.565] result() for ClusterFuture ...
[09:29:19.565] - result already collected: FutureResult
[09:29:19.566] result() for ClusterFuture ... done
[09:29:19.566] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.566] Future #1
[09:29:19.566] result() for ClusterFuture ...
[09:29:19.566] - result already collected: FutureResult
[09:29:19.566] result() for ClusterFuture ... done
[09:29:19.566] result() for ClusterFuture ...
[09:29:19.566] - result already collected: FutureResult
[09:29:19.566] result() for ClusterFuture ... done
[09:29:19.566] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:19.566] - nx: 2
[09:29:19.567] - relay: TRUE
[09:29:19.567] - stdout: TRUE
[09:29:19.567] - signal: TRUE
[09:29:19.567] - resignal: FALSE
[09:29:19.567] - force: TRUE
[09:29:19.567] - relayed: [n=2] FALSE, FALSE
[09:29:19.567] - queued futures: [n=2] FALSE, FALSE
[09:29:19.567]  - until=1
[09:29:19.567]  - relaying element #1
[09:29:19.567] result() for ClusterFuture ...
[09:29:19.567] - result already collected: FutureResult
[09:29:19.567] result() for ClusterFuture ... done
[09:29:19.567] result() for ClusterFuture ...
[09:29:19.568] - result already collected: FutureResult
[09:29:19.568] result() for ClusterFuture ... done
[09:29:19.568] result() for ClusterFuture ...
[09:29:19.568] - result already collected: FutureResult
[09:29:19.568] result() for ClusterFuture ... done
[09:29:19.568] result() for ClusterFuture ...
[09:29:19.568] - result already collected: FutureResult
[09:29:19.568] result() for ClusterFuture ... done
[09:29:19.568] - relayed: [n=2] TRUE, FALSE
[09:29:19.568] - queued futures: [n=2] TRUE, FALSE
[09:29:19.568] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:19.569]  length: 1 (resolved future 1)
[09:29:19.593] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.594] - Validating connection of MultisessionFuture
[09:29:19.594] - received message: FutureResult
[09:29:19.594] - Received FutureResult
[09:29:19.594] - Erased future from FutureRegistry
[09:29:19.594] result() for ClusterFuture ...
[09:29:19.594] - result already collected: FutureResult
[09:29:19.594] result() for ClusterFuture ... done
[09:29:19.594] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.594] Future #2
[09:29:19.594] result() for ClusterFuture ...
[09:29:19.595] - result already collected: FutureResult
[09:29:19.595] result() for ClusterFuture ... done
[09:29:19.595] result() for ClusterFuture ...
[09:29:19.595] - result already collected: FutureResult
[09:29:19.595] result() for ClusterFuture ... done
[09:29:19.595] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:19.595] - nx: 2
[09:29:19.595] - relay: TRUE
[09:29:19.595] - stdout: TRUE
[09:29:19.595] - signal: TRUE
[09:29:19.595] - resignal: FALSE
[09:29:19.595] - force: TRUE
[09:29:19.596] - relayed: [n=2] TRUE, FALSE
[09:29:19.596] - queued futures: [n=2] TRUE, FALSE
[09:29:19.596]  - until=2
[09:29:19.596]  - relaying element #2
[09:29:19.596] result() for ClusterFuture ...
[09:29:19.596] - result already collected: FutureResult
[09:29:19.596] result() for ClusterFuture ... done
[09:29:19.596] result() for ClusterFuture ...
[09:29:19.596] - result already collected: FutureResult
[09:29:19.596] result() for ClusterFuture ... done
[09:29:19.596] result() for ClusterFuture ...
[09:29:19.597] - result already collected: FutureResult
[09:29:19.597] result() for ClusterFuture ... done
[09:29:19.597] result() for ClusterFuture ...
[09:29:19.597] - result already collected: FutureResult
[09:29:19.597] result() for ClusterFuture ... done
[09:29:19.597] - relayed: [n=2] TRUE, TRUE
[09:29:19.597] - queued futures: [n=2] TRUE, TRUE
[09:29:19.597] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:19.597]  length: 0 (resolved future 2)
[09:29:19.597] Relaying remaining futures
[09:29:19.597] signalConditionsASAP(NULL, pos=0) ...
[09:29:19.597] - nx: 2
[09:29:19.598] - relay: TRUE
[09:29:19.598] - stdout: TRUE
[09:29:19.598] - signal: TRUE
[09:29:19.598] - resignal: FALSE
[09:29:19.598] - force: TRUE
[09:29:19.598] - relayed: [n=2] TRUE, TRUE
[09:29:19.598] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:19.598] - relayed: [n=2] TRUE, TRUE
[09:29:19.598] - queued futures: [n=2] TRUE, TRUE
[09:29:19.598] signalConditionsASAP(NULL, pos=0) ... done
[09:29:19.598] resolve() on list ... DONE
[09:29:19.599] result() for ClusterFuture ...
[09:29:19.599] - result already collected: FutureResult
[09:29:19.599] result() for ClusterFuture ... done
[09:29:19.599] result() for ClusterFuture ...
[09:29:19.599] - result already collected: FutureResult
[09:29:19.599] result() for ClusterFuture ... done
[09:29:19.599] result() for ClusterFuture ...
[09:29:19.599] - result already collected: FutureResult
[09:29:19.599] result() for ClusterFuture ... done
[09:29:19.599] result() for ClusterFuture ...
[09:29:19.599] - result already collected: FutureResult
[09:29:19.599] result() for ClusterFuture ... done
[09:29:19.600]  - Number of value chunks collected: 2
[09:29:19.600] Resolving 2 futures (chunks) ... DONE
[09:29:19.600] Reducing values from 2 chunks ...
[09:29:19.600]  - Number of values collected after concatenation: 5
[09:29:19.600]  - Number of values expected: 5
[09:29:19.600] Reducing values from 2 chunks ... DONE
[09:29:19.600] future_mapply() ... DONE
[09:29:19.600] future_mapply() ...
[09:29:19.604] Number of chunks: 3
[09:29:19.604] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 2, 3, 1
[09:29:19.604] getGlobalsAndPackagesXApply() ...
[09:29:19.604]  - future.globals: TRUE
[09:29:19.604] getGlobalsAndPackages() ...
[09:29:19.604] Searching for globals...
[09:29:19.605] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:19.605] Searching for globals ... DONE
[09:29:19.606] Resolving globals: FALSE
[09:29:19.606] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:19.606] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:19.606] - globals: [1] ‘FUN’
[09:29:19.606] 
[09:29:19.606] getGlobalsAndPackages() ... DONE
[09:29:19.607]  - globals found/used: [n=1] ‘FUN’
[09:29:19.607]  - needed namespaces: [n=0] 
[09:29:19.607] Finding globals ... DONE
[09:29:19.607] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:19.607] List of 2
[09:29:19.607]  $ ...future.FUN:function (C, k)  
[09:29:19.607]  $ MoreArgs     : NULL
[09:29:19.607]  - attr(*, "where")=List of 2
[09:29:19.607]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:19.607]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:19.607]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:19.607]  - attr(*, "resolved")= logi FALSE
[09:29:19.607]  - attr(*, "total_size")= num NA
[09:29:19.609] Packages to be attached in all futures: [n=0] 
[09:29:19.610] getGlobalsAndPackagesXApply() ... DONE
[09:29:19.610] Number of futures (= number of chunks): 3
[09:29:19.610] Launching 3 futures (chunks) ...
[09:29:19.610] Chunk #1 of 3 ...
[09:29:19.610]  - Finding globals in '...' for chunk #1 ...
[09:29:19.610] getGlobalsAndPackages() ...
[09:29:19.610] Searching for globals...
[09:29:19.611] 
[09:29:19.611] Searching for globals ... DONE
[09:29:19.611] - globals: [0] <none>
[09:29:19.611] getGlobalsAndPackages() ... DONE
[09:29:19.611]    + additional globals found: [n=0] 
[09:29:19.611]    + additional namespaces needed: [n=0] 
[09:29:19.611]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:19.611]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[09:29:19.611]  - seeds: <none>
[09:29:19.611]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.611] getGlobalsAndPackages() ...
[09:29:19.611] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.612] Resolving globals: FALSE
[09:29:19.612] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:19.613] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:19.613] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.613] 
[09:29:19.613] getGlobalsAndPackages() ... DONE
[09:29:19.613] run() for ‘Future’ ...
[09:29:19.613] - state: ‘created’
[09:29:19.613] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.627] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.627] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.627]   - Field: ‘node’
[09:29:19.627]   - Field: ‘label’
[09:29:19.627]   - Field: ‘local’
[09:29:19.628]   - Field: ‘owner’
[09:29:19.628]   - Field: ‘envir’
[09:29:19.628]   - Field: ‘workers’
[09:29:19.628]   - Field: ‘packages’
[09:29:19.628]   - Field: ‘gc’
[09:29:19.628]   - Field: ‘conditions’
[09:29:19.628]   - Field: ‘persistent’
[09:29:19.628]   - Field: ‘expr’
[09:29:19.628]   - Field: ‘uuid’
[09:29:19.628]   - Field: ‘seed’
[09:29:19.629]   - Field: ‘version’
[09:29:19.629]   - Field: ‘result’
[09:29:19.629]   - Field: ‘asynchronous’
[09:29:19.629]   - Field: ‘calls’
[09:29:19.629]   - Field: ‘globals’
[09:29:19.629]   - Field: ‘stdout’
[09:29:19.629]   - Field: ‘earlySignal’
[09:29:19.629]   - Field: ‘lazy’
[09:29:19.629]   - Field: ‘state’
[09:29:19.629] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.629] - Launch lazy future ...
[09:29:19.630] Packages needed by the future expression (n = 0): <none>
[09:29:19.630] Packages needed by future strategies (n = 0): <none>
[09:29:19.630] {
[09:29:19.630]     {
[09:29:19.630]         {
[09:29:19.630]             ...future.startTime <- base::Sys.time()
[09:29:19.630]             {
[09:29:19.630]                 {
[09:29:19.630]                   {
[09:29:19.630]                     {
[09:29:19.630]                       base::local({
[09:29:19.630]                         has_future <- base::requireNamespace("future", 
[09:29:19.630]                           quietly = TRUE)
[09:29:19.630]                         if (has_future) {
[09:29:19.630]                           ns <- base::getNamespace("future")
[09:29:19.630]                           version <- ns[[".package"]][["version"]]
[09:29:19.630]                           if (is.null(version)) 
[09:29:19.630]                             version <- utils::packageVersion("future")
[09:29:19.630]                         }
[09:29:19.630]                         else {
[09:29:19.630]                           version <- NULL
[09:29:19.630]                         }
[09:29:19.630]                         if (!has_future || version < "1.8.0") {
[09:29:19.630]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.630]                             "", base::R.version$version.string), 
[09:29:19.630]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.630]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.630]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.630]                               "release", "version")], collapse = " "), 
[09:29:19.630]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.630]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.630]                             info)
[09:29:19.630]                           info <- base::paste(info, collapse = "; ")
[09:29:19.630]                           if (!has_future) {
[09:29:19.630]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.630]                               info)
[09:29:19.630]                           }
[09:29:19.630]                           else {
[09:29:19.630]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.630]                               info, version)
[09:29:19.630]                           }
[09:29:19.630]                           base::stop(msg)
[09:29:19.630]                         }
[09:29:19.630]                       })
[09:29:19.630]                     }
[09:29:19.630]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.630]                     base::options(mc.cores = 1L)
[09:29:19.630]                   }
[09:29:19.630]                   ...future.strategy.old <- future::plan("list")
[09:29:19.630]                   options(future.plan = NULL)
[09:29:19.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.630]                 }
[09:29:19.630]                 ...future.workdir <- getwd()
[09:29:19.630]             }
[09:29:19.630]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.630]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.630]         }
[09:29:19.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.630]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[09:29:19.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.630]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.630]             base::names(...future.oldOptions))
[09:29:19.630]     }
[09:29:19.630]     if (FALSE) {
[09:29:19.630]     }
[09:29:19.630]     else {
[09:29:19.630]         if (TRUE) {
[09:29:19.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.630]                 open = "w")
[09:29:19.630]         }
[09:29:19.630]         else {
[09:29:19.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.630]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.630]         }
[09:29:19.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.630]             base::sink(type = "output", split = FALSE)
[09:29:19.630]             base::close(...future.stdout)
[09:29:19.630]         }, add = TRUE)
[09:29:19.630]     }
[09:29:19.630]     ...future.frame <- base::sys.nframe()
[09:29:19.630]     ...future.conditions <- base::list()
[09:29:19.630]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.630]     if (FALSE) {
[09:29:19.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.630]     }
[09:29:19.630]     ...future.result <- base::tryCatch({
[09:29:19.630]         base::withCallingHandlers({
[09:29:19.630]             ...future.value <- base::withVisible(base::local({
[09:29:19.630]                 ...future.makeSendCondition <- base::local({
[09:29:19.630]                   sendCondition <- NULL
[09:29:19.630]                   function(frame = 1L) {
[09:29:19.630]                     if (is.function(sendCondition)) 
[09:29:19.630]                       return(sendCondition)
[09:29:19.630]                     ns <- getNamespace("parallel")
[09:29:19.630]                     if (exists("sendData", mode = "function", 
[09:29:19.630]                       envir = ns)) {
[09:29:19.630]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.630]                         envir = ns)
[09:29:19.630]                       envir <- sys.frame(frame)
[09:29:19.630]                       master <- NULL
[09:29:19.630]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.630]                         !identical(envir, emptyenv())) {
[09:29:19.630]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.630]                           inherits = FALSE)) {
[09:29:19.630]                           master <- get("master", mode = "list", 
[09:29:19.630]                             envir = envir, inherits = FALSE)
[09:29:19.630]                           if (inherits(master, c("SOCKnode", 
[09:29:19.630]                             "SOCK0node"))) {
[09:29:19.630]                             sendCondition <<- function(cond) {
[09:29:19.630]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.630]                                 success = TRUE)
[09:29:19.630]                               parallel_sendData(master, data)
[09:29:19.630]                             }
[09:29:19.630]                             return(sendCondition)
[09:29:19.630]                           }
[09:29:19.630]                         }
[09:29:19.630]                         frame <- frame + 1L
[09:29:19.630]                         envir <- sys.frame(frame)
[09:29:19.630]                       }
[09:29:19.630]                     }
[09:29:19.630]                     sendCondition <<- function(cond) NULL
[09:29:19.630]                   }
[09:29:19.630]                 })
[09:29:19.630]                 withCallingHandlers({
[09:29:19.630]                   {
[09:29:19.630]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.630]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.630]                       ...future.globals.maxSize)) {
[09:29:19.630]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.630]                       on.exit(options(oopts), add = TRUE)
[09:29:19.630]                     }
[09:29:19.630]                     {
[09:29:19.630]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.630]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.630]                         USE.NAMES = FALSE)
[09:29:19.630]                       do.call(mapply, args = args)
[09:29:19.630]                     }
[09:29:19.630]                   }
[09:29:19.630]                 }, immediateCondition = function(cond) {
[09:29:19.630]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.630]                   sendCondition(cond)
[09:29:19.630]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.630]                   {
[09:29:19.630]                     inherits <- base::inherits
[09:29:19.630]                     invokeRestart <- base::invokeRestart
[09:29:19.630]                     is.null <- base::is.null
[09:29:19.630]                     muffled <- FALSE
[09:29:19.630]                     if (inherits(cond, "message")) {
[09:29:19.630]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.630]                       if (muffled) 
[09:29:19.630]                         invokeRestart("muffleMessage")
[09:29:19.630]                     }
[09:29:19.630]                     else if (inherits(cond, "warning")) {
[09:29:19.630]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.630]                       if (muffled) 
[09:29:19.630]                         invokeRestart("muffleWarning")
[09:29:19.630]                     }
[09:29:19.630]                     else if (inherits(cond, "condition")) {
[09:29:19.630]                       if (!is.null(pattern)) {
[09:29:19.630]                         computeRestarts <- base::computeRestarts
[09:29:19.630]                         grepl <- base::grepl
[09:29:19.630]                         restarts <- computeRestarts(cond)
[09:29:19.630]                         for (restart in restarts) {
[09:29:19.630]                           name <- restart$name
[09:29:19.630]                           if (is.null(name)) 
[09:29:19.630]                             next
[09:29:19.630]                           if (!grepl(pattern, name)) 
[09:29:19.630]                             next
[09:29:19.630]                           invokeRestart(restart)
[09:29:19.630]                           muffled <- TRUE
[09:29:19.630]                           break
[09:29:19.630]                         }
[09:29:19.630]                       }
[09:29:19.630]                     }
[09:29:19.630]                     invisible(muffled)
[09:29:19.630]                   }
[09:29:19.630]                   muffleCondition(cond)
[09:29:19.630]                 })
[09:29:19.630]             }))
[09:29:19.630]             future::FutureResult(value = ...future.value$value, 
[09:29:19.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.630]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.630]                     ...future.globalenv.names))
[09:29:19.630]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.630]         }, condition = base::local({
[09:29:19.630]             c <- base::c
[09:29:19.630]             inherits <- base::inherits
[09:29:19.630]             invokeRestart <- base::invokeRestart
[09:29:19.630]             length <- base::length
[09:29:19.630]             list <- base::list
[09:29:19.630]             seq.int <- base::seq.int
[09:29:19.630]             signalCondition <- base::signalCondition
[09:29:19.630]             sys.calls <- base::sys.calls
[09:29:19.630]             `[[` <- base::`[[`
[09:29:19.630]             `+` <- base::`+`
[09:29:19.630]             `<<-` <- base::`<<-`
[09:29:19.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.630]                   3L)]
[09:29:19.630]             }
[09:29:19.630]             function(cond) {
[09:29:19.630]                 is_error <- inherits(cond, "error")
[09:29:19.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.630]                   NULL)
[09:29:19.630]                 if (is_error) {
[09:29:19.630]                   sessionInformation <- function() {
[09:29:19.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.630]                       search = base::search(), system = base::Sys.info())
[09:29:19.630]                   }
[09:29:19.630]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.630]                     cond$call), session = sessionInformation(), 
[09:29:19.630]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.630]                   signalCondition(cond)
[09:29:19.630]                 }
[09:29:19.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.630]                 "immediateCondition"))) {
[09:29:19.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.630]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.630]                   if (TRUE && !signal) {
[09:29:19.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.630]                     {
[09:29:19.630]                       inherits <- base::inherits
[09:29:19.630]                       invokeRestart <- base::invokeRestart
[09:29:19.630]                       is.null <- base::is.null
[09:29:19.630]                       muffled <- FALSE
[09:29:19.630]                       if (inherits(cond, "message")) {
[09:29:19.630]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.630]                         if (muffled) 
[09:29:19.630]                           invokeRestart("muffleMessage")
[09:29:19.630]                       }
[09:29:19.630]                       else if (inherits(cond, "warning")) {
[09:29:19.630]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.630]                         if (muffled) 
[09:29:19.630]                           invokeRestart("muffleWarning")
[09:29:19.630]                       }
[09:29:19.630]                       else if (inherits(cond, "condition")) {
[09:29:19.630]                         if (!is.null(pattern)) {
[09:29:19.630]                           computeRestarts <- base::computeRestarts
[09:29:19.630]                           grepl <- base::grepl
[09:29:19.630]                           restarts <- computeRestarts(cond)
[09:29:19.630]                           for (restart in restarts) {
[09:29:19.630]                             name <- restart$name
[09:29:19.630]                             if (is.null(name)) 
[09:29:19.630]                               next
[09:29:19.630]                             if (!grepl(pattern, name)) 
[09:29:19.630]                               next
[09:29:19.630]                             invokeRestart(restart)
[09:29:19.630]                             muffled <- TRUE
[09:29:19.630]                             break
[09:29:19.630]                           }
[09:29:19.630]                         }
[09:29:19.630]                       }
[09:29:19.630]                       invisible(muffled)
[09:29:19.630]                     }
[09:29:19.630]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.630]                   }
[09:29:19.630]                 }
[09:29:19.630]                 else {
[09:29:19.630]                   if (TRUE) {
[09:29:19.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.630]                     {
[09:29:19.630]                       inherits <- base::inherits
[09:29:19.630]                       invokeRestart <- base::invokeRestart
[09:29:19.630]                       is.null <- base::is.null
[09:29:19.630]                       muffled <- FALSE
[09:29:19.630]                       if (inherits(cond, "message")) {
[09:29:19.630]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.630]                         if (muffled) 
[09:29:19.630]                           invokeRestart("muffleMessage")
[09:29:19.630]                       }
[09:29:19.630]                       else if (inherits(cond, "warning")) {
[09:29:19.630]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.630]                         if (muffled) 
[09:29:19.630]                           invokeRestart("muffleWarning")
[09:29:19.630]                       }
[09:29:19.630]                       else if (inherits(cond, "condition")) {
[09:29:19.630]                         if (!is.null(pattern)) {
[09:29:19.630]                           computeRestarts <- base::computeRestarts
[09:29:19.630]                           grepl <- base::grepl
[09:29:19.630]                           restarts <- computeRestarts(cond)
[09:29:19.630]                           for (restart in restarts) {
[09:29:19.630]                             name <- restart$name
[09:29:19.630]                             if (is.null(name)) 
[09:29:19.630]                               next
[09:29:19.630]                             if (!grepl(pattern, name)) 
[09:29:19.630]                               next
[09:29:19.630]                             invokeRestart(restart)
[09:29:19.630]                             muffled <- TRUE
[09:29:19.630]                             break
[09:29:19.630]                           }
[09:29:19.630]                         }
[09:29:19.630]                       }
[09:29:19.630]                       invisible(muffled)
[09:29:19.630]                     }
[09:29:19.630]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.630]                   }
[09:29:19.630]                 }
[09:29:19.630]             }
[09:29:19.630]         }))
[09:29:19.630]     }, error = function(ex) {
[09:29:19.630]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.630]                 ...future.rng), started = ...future.startTime, 
[09:29:19.630]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.630]             version = "1.8"), class = "FutureResult")
[09:29:19.630]     }, finally = {
[09:29:19.630]         if (!identical(...future.workdir, getwd())) 
[09:29:19.630]             setwd(...future.workdir)
[09:29:19.630]         {
[09:29:19.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.630]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.630]             }
[09:29:19.630]             base::options(...future.oldOptions)
[09:29:19.630]             if (.Platform$OS.type == "windows") {
[09:29:19.630]                 old_names <- names(...future.oldEnvVars)
[09:29:19.630]                 envs <- base::Sys.getenv()
[09:29:19.630]                 names <- names(envs)
[09:29:19.630]                 common <- intersect(names, old_names)
[09:29:19.630]                 added <- setdiff(names, old_names)
[09:29:19.630]                 removed <- setdiff(old_names, names)
[09:29:19.630]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.630]                   envs[common]]
[09:29:19.630]                 NAMES <- toupper(changed)
[09:29:19.630]                 args <- list()
[09:29:19.630]                 for (kk in seq_along(NAMES)) {
[09:29:19.630]                   name <- changed[[kk]]
[09:29:19.630]                   NAME <- NAMES[[kk]]
[09:29:19.630]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.630]                     next
[09:29:19.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.630]                 }
[09:29:19.630]                 NAMES <- toupper(added)
[09:29:19.630]                 for (kk in seq_along(NAMES)) {
[09:29:19.630]                   name <- added[[kk]]
[09:29:19.630]                   NAME <- NAMES[[kk]]
[09:29:19.630]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.630]                     next
[09:29:19.630]                   args[[name]] <- ""
[09:29:19.630]                 }
[09:29:19.630]                 NAMES <- toupper(removed)
[09:29:19.630]                 for (kk in seq_along(NAMES)) {
[09:29:19.630]                   name <- removed[[kk]]
[09:29:19.630]                   NAME <- NAMES[[kk]]
[09:29:19.630]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.630]                     next
[09:29:19.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.630]                 }
[09:29:19.630]                 if (length(args) > 0) 
[09:29:19.630]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.630]             }
[09:29:19.630]             else {
[09:29:19.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.630]             }
[09:29:19.630]             {
[09:29:19.630]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.630]                   0L) {
[09:29:19.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.630]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.630]                   base::options(opts)
[09:29:19.630]                 }
[09:29:19.630]                 {
[09:29:19.630]                   {
[09:29:19.630]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.630]                     NULL
[09:29:19.630]                   }
[09:29:19.630]                   options(future.plan = NULL)
[09:29:19.630]                   if (is.na(NA_character_)) 
[09:29:19.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.630]                     .init = FALSE)
[09:29:19.630]                 }
[09:29:19.630]             }
[09:29:19.630]         }
[09:29:19.630]     })
[09:29:19.630]     if (TRUE) {
[09:29:19.630]         base::sink(type = "output", split = FALSE)
[09:29:19.630]         if (TRUE) {
[09:29:19.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.630]         }
[09:29:19.630]         else {
[09:29:19.630]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.630]         }
[09:29:19.630]         base::close(...future.stdout)
[09:29:19.630]         ...future.stdout <- NULL
[09:29:19.630]     }
[09:29:19.630]     ...future.result$conditions <- ...future.conditions
[09:29:19.630]     ...future.result$finished <- base::Sys.time()
[09:29:19.630]     ...future.result
[09:29:19.630] }
[09:29:19.633] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[09:29:19.633] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[09:29:19.633] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[09:29:19.634] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:19.634] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.634] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[09:29:19.634] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[09:29:19.634] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:19.635] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.635] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:19.635] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.635] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[09:29:19.636] MultisessionFuture started
[09:29:19.636] - Launch lazy future ... done
[09:29:19.636] run() for ‘MultisessionFuture’ ... done
[09:29:19.636] Created future:
[09:29:19.636] MultisessionFuture:
[09:29:19.636] Label: ‘future_mapply-1’
[09:29:19.636] Expression:
[09:29:19.636] {
[09:29:19.636]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.636]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.636]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.636]         on.exit(options(oopts), add = TRUE)
[09:29:19.636]     }
[09:29:19.636]     {
[09:29:19.636]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.636]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.636]         do.call(mapply, args = args)
[09:29:19.636]     }
[09:29:19.636] }
[09:29:19.636] Lazy evaluation: FALSE
[09:29:19.636] Asynchronous evaluation: TRUE
[09:29:19.636] Local evaluation: TRUE
[09:29:19.636] Environment: R_GlobalEnv
[09:29:19.636] Capture standard output: TRUE
[09:29:19.636] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.636] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.636] Packages: <none>
[09:29:19.636] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.636] Resolved: FALSE
[09:29:19.636] Value: <not collected>
[09:29:19.636] Conditions captured: <none>
[09:29:19.636] Early signaling: FALSE
[09:29:19.636] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.636] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.647] Chunk #1 of 3 ... DONE
[09:29:19.648] Chunk #2 of 3 ...
[09:29:19.648]  - Finding globals in '...' for chunk #2 ...
[09:29:19.648] getGlobalsAndPackages() ...
[09:29:19.648] Searching for globals...
[09:29:19.648] 
[09:29:19.648] Searching for globals ... DONE
[09:29:19.648] - globals: [0] <none>
[09:29:19.649] getGlobalsAndPackages() ... DONE
[09:29:19.649]    + additional globals found: [n=0] 
[09:29:19.649]    + additional namespaces needed: [n=0] 
[09:29:19.649]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:19.649]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[09:29:19.649]  - seeds: <none>
[09:29:19.649]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.649] getGlobalsAndPackages() ...
[09:29:19.649] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.649] Resolving globals: FALSE
[09:29:19.650] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[09:29:19.650] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:19.650] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.651] 
[09:29:19.651] getGlobalsAndPackages() ... DONE
[09:29:19.651] run() for ‘Future’ ...
[09:29:19.651] - state: ‘created’
[09:29:19.651] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.664] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.665] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.665]   - Field: ‘node’
[09:29:19.665]   - Field: ‘label’
[09:29:19.665]   - Field: ‘local’
[09:29:19.665]   - Field: ‘owner’
[09:29:19.665]   - Field: ‘envir’
[09:29:19.665]   - Field: ‘workers’
[09:29:19.665]   - Field: ‘packages’
[09:29:19.665]   - Field: ‘gc’
[09:29:19.665]   - Field: ‘conditions’
[09:29:19.666]   - Field: ‘persistent’
[09:29:19.666]   - Field: ‘expr’
[09:29:19.666]   - Field: ‘uuid’
[09:29:19.666]   - Field: ‘seed’
[09:29:19.666]   - Field: ‘version’
[09:29:19.666]   - Field: ‘result’
[09:29:19.666]   - Field: ‘asynchronous’
[09:29:19.666]   - Field: ‘calls’
[09:29:19.666]   - Field: ‘globals’
[09:29:19.666]   - Field: ‘stdout’
[09:29:19.666]   - Field: ‘earlySignal’
[09:29:19.667]   - Field: ‘lazy’
[09:29:19.667]   - Field: ‘state’
[09:29:19.667] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.667] - Launch lazy future ...
[09:29:19.667] Packages needed by the future expression (n = 0): <none>
[09:29:19.667] Packages needed by future strategies (n = 0): <none>
[09:29:19.668] {
[09:29:19.668]     {
[09:29:19.668]         {
[09:29:19.668]             ...future.startTime <- base::Sys.time()
[09:29:19.668]             {
[09:29:19.668]                 {
[09:29:19.668]                   {
[09:29:19.668]                     {
[09:29:19.668]                       base::local({
[09:29:19.668]                         has_future <- base::requireNamespace("future", 
[09:29:19.668]                           quietly = TRUE)
[09:29:19.668]                         if (has_future) {
[09:29:19.668]                           ns <- base::getNamespace("future")
[09:29:19.668]                           version <- ns[[".package"]][["version"]]
[09:29:19.668]                           if (is.null(version)) 
[09:29:19.668]                             version <- utils::packageVersion("future")
[09:29:19.668]                         }
[09:29:19.668]                         else {
[09:29:19.668]                           version <- NULL
[09:29:19.668]                         }
[09:29:19.668]                         if (!has_future || version < "1.8.0") {
[09:29:19.668]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.668]                             "", base::R.version$version.string), 
[09:29:19.668]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.668]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.668]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.668]                               "release", "version")], collapse = " "), 
[09:29:19.668]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.668]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.668]                             info)
[09:29:19.668]                           info <- base::paste(info, collapse = "; ")
[09:29:19.668]                           if (!has_future) {
[09:29:19.668]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.668]                               info)
[09:29:19.668]                           }
[09:29:19.668]                           else {
[09:29:19.668]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.668]                               info, version)
[09:29:19.668]                           }
[09:29:19.668]                           base::stop(msg)
[09:29:19.668]                         }
[09:29:19.668]                       })
[09:29:19.668]                     }
[09:29:19.668]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.668]                     base::options(mc.cores = 1L)
[09:29:19.668]                   }
[09:29:19.668]                   ...future.strategy.old <- future::plan("list")
[09:29:19.668]                   options(future.plan = NULL)
[09:29:19.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.668]                 }
[09:29:19.668]                 ...future.workdir <- getwd()
[09:29:19.668]             }
[09:29:19.668]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.668]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.668]         }
[09:29:19.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.668]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[09:29:19.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.668]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.668]             base::names(...future.oldOptions))
[09:29:19.668]     }
[09:29:19.668]     if (FALSE) {
[09:29:19.668]     }
[09:29:19.668]     else {
[09:29:19.668]         if (TRUE) {
[09:29:19.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.668]                 open = "w")
[09:29:19.668]         }
[09:29:19.668]         else {
[09:29:19.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.668]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.668]         }
[09:29:19.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.668]             base::sink(type = "output", split = FALSE)
[09:29:19.668]             base::close(...future.stdout)
[09:29:19.668]         }, add = TRUE)
[09:29:19.668]     }
[09:29:19.668]     ...future.frame <- base::sys.nframe()
[09:29:19.668]     ...future.conditions <- base::list()
[09:29:19.668]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.668]     if (FALSE) {
[09:29:19.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.668]     }
[09:29:19.668]     ...future.result <- base::tryCatch({
[09:29:19.668]         base::withCallingHandlers({
[09:29:19.668]             ...future.value <- base::withVisible(base::local({
[09:29:19.668]                 ...future.makeSendCondition <- base::local({
[09:29:19.668]                   sendCondition <- NULL
[09:29:19.668]                   function(frame = 1L) {
[09:29:19.668]                     if (is.function(sendCondition)) 
[09:29:19.668]                       return(sendCondition)
[09:29:19.668]                     ns <- getNamespace("parallel")
[09:29:19.668]                     if (exists("sendData", mode = "function", 
[09:29:19.668]                       envir = ns)) {
[09:29:19.668]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.668]                         envir = ns)
[09:29:19.668]                       envir <- sys.frame(frame)
[09:29:19.668]                       master <- NULL
[09:29:19.668]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.668]                         !identical(envir, emptyenv())) {
[09:29:19.668]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.668]                           inherits = FALSE)) {
[09:29:19.668]                           master <- get("master", mode = "list", 
[09:29:19.668]                             envir = envir, inherits = FALSE)
[09:29:19.668]                           if (inherits(master, c("SOCKnode", 
[09:29:19.668]                             "SOCK0node"))) {
[09:29:19.668]                             sendCondition <<- function(cond) {
[09:29:19.668]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.668]                                 success = TRUE)
[09:29:19.668]                               parallel_sendData(master, data)
[09:29:19.668]                             }
[09:29:19.668]                             return(sendCondition)
[09:29:19.668]                           }
[09:29:19.668]                         }
[09:29:19.668]                         frame <- frame + 1L
[09:29:19.668]                         envir <- sys.frame(frame)
[09:29:19.668]                       }
[09:29:19.668]                     }
[09:29:19.668]                     sendCondition <<- function(cond) NULL
[09:29:19.668]                   }
[09:29:19.668]                 })
[09:29:19.668]                 withCallingHandlers({
[09:29:19.668]                   {
[09:29:19.668]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.668]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.668]                       ...future.globals.maxSize)) {
[09:29:19.668]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.668]                       on.exit(options(oopts), add = TRUE)
[09:29:19.668]                     }
[09:29:19.668]                     {
[09:29:19.668]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.668]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.668]                         USE.NAMES = FALSE)
[09:29:19.668]                       do.call(mapply, args = args)
[09:29:19.668]                     }
[09:29:19.668]                   }
[09:29:19.668]                 }, immediateCondition = function(cond) {
[09:29:19.668]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.668]                   sendCondition(cond)
[09:29:19.668]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.668]                   {
[09:29:19.668]                     inherits <- base::inherits
[09:29:19.668]                     invokeRestart <- base::invokeRestart
[09:29:19.668]                     is.null <- base::is.null
[09:29:19.668]                     muffled <- FALSE
[09:29:19.668]                     if (inherits(cond, "message")) {
[09:29:19.668]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.668]                       if (muffled) 
[09:29:19.668]                         invokeRestart("muffleMessage")
[09:29:19.668]                     }
[09:29:19.668]                     else if (inherits(cond, "warning")) {
[09:29:19.668]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.668]                       if (muffled) 
[09:29:19.668]                         invokeRestart("muffleWarning")
[09:29:19.668]                     }
[09:29:19.668]                     else if (inherits(cond, "condition")) {
[09:29:19.668]                       if (!is.null(pattern)) {
[09:29:19.668]                         computeRestarts <- base::computeRestarts
[09:29:19.668]                         grepl <- base::grepl
[09:29:19.668]                         restarts <- computeRestarts(cond)
[09:29:19.668]                         for (restart in restarts) {
[09:29:19.668]                           name <- restart$name
[09:29:19.668]                           if (is.null(name)) 
[09:29:19.668]                             next
[09:29:19.668]                           if (!grepl(pattern, name)) 
[09:29:19.668]                             next
[09:29:19.668]                           invokeRestart(restart)
[09:29:19.668]                           muffled <- TRUE
[09:29:19.668]                           break
[09:29:19.668]                         }
[09:29:19.668]                       }
[09:29:19.668]                     }
[09:29:19.668]                     invisible(muffled)
[09:29:19.668]                   }
[09:29:19.668]                   muffleCondition(cond)
[09:29:19.668]                 })
[09:29:19.668]             }))
[09:29:19.668]             future::FutureResult(value = ...future.value$value, 
[09:29:19.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.668]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.668]                     ...future.globalenv.names))
[09:29:19.668]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.668]         }, condition = base::local({
[09:29:19.668]             c <- base::c
[09:29:19.668]             inherits <- base::inherits
[09:29:19.668]             invokeRestart <- base::invokeRestart
[09:29:19.668]             length <- base::length
[09:29:19.668]             list <- base::list
[09:29:19.668]             seq.int <- base::seq.int
[09:29:19.668]             signalCondition <- base::signalCondition
[09:29:19.668]             sys.calls <- base::sys.calls
[09:29:19.668]             `[[` <- base::`[[`
[09:29:19.668]             `+` <- base::`+`
[09:29:19.668]             `<<-` <- base::`<<-`
[09:29:19.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.668]                   3L)]
[09:29:19.668]             }
[09:29:19.668]             function(cond) {
[09:29:19.668]                 is_error <- inherits(cond, "error")
[09:29:19.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.668]                   NULL)
[09:29:19.668]                 if (is_error) {
[09:29:19.668]                   sessionInformation <- function() {
[09:29:19.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.668]                       search = base::search(), system = base::Sys.info())
[09:29:19.668]                   }
[09:29:19.668]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.668]                     cond$call), session = sessionInformation(), 
[09:29:19.668]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.668]                   signalCondition(cond)
[09:29:19.668]                 }
[09:29:19.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.668]                 "immediateCondition"))) {
[09:29:19.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.668]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.668]                   if (TRUE && !signal) {
[09:29:19.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.668]                     {
[09:29:19.668]                       inherits <- base::inherits
[09:29:19.668]                       invokeRestart <- base::invokeRestart
[09:29:19.668]                       is.null <- base::is.null
[09:29:19.668]                       muffled <- FALSE
[09:29:19.668]                       if (inherits(cond, "message")) {
[09:29:19.668]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.668]                         if (muffled) 
[09:29:19.668]                           invokeRestart("muffleMessage")
[09:29:19.668]                       }
[09:29:19.668]                       else if (inherits(cond, "warning")) {
[09:29:19.668]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.668]                         if (muffled) 
[09:29:19.668]                           invokeRestart("muffleWarning")
[09:29:19.668]                       }
[09:29:19.668]                       else if (inherits(cond, "condition")) {
[09:29:19.668]                         if (!is.null(pattern)) {
[09:29:19.668]                           computeRestarts <- base::computeRestarts
[09:29:19.668]                           grepl <- base::grepl
[09:29:19.668]                           restarts <- computeRestarts(cond)
[09:29:19.668]                           for (restart in restarts) {
[09:29:19.668]                             name <- restart$name
[09:29:19.668]                             if (is.null(name)) 
[09:29:19.668]                               next
[09:29:19.668]                             if (!grepl(pattern, name)) 
[09:29:19.668]                               next
[09:29:19.668]                             invokeRestart(restart)
[09:29:19.668]                             muffled <- TRUE
[09:29:19.668]                             break
[09:29:19.668]                           }
[09:29:19.668]                         }
[09:29:19.668]                       }
[09:29:19.668]                       invisible(muffled)
[09:29:19.668]                     }
[09:29:19.668]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.668]                   }
[09:29:19.668]                 }
[09:29:19.668]                 else {
[09:29:19.668]                   if (TRUE) {
[09:29:19.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.668]                     {
[09:29:19.668]                       inherits <- base::inherits
[09:29:19.668]                       invokeRestart <- base::invokeRestart
[09:29:19.668]                       is.null <- base::is.null
[09:29:19.668]                       muffled <- FALSE
[09:29:19.668]                       if (inherits(cond, "message")) {
[09:29:19.668]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.668]                         if (muffled) 
[09:29:19.668]                           invokeRestart("muffleMessage")
[09:29:19.668]                       }
[09:29:19.668]                       else if (inherits(cond, "warning")) {
[09:29:19.668]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.668]                         if (muffled) 
[09:29:19.668]                           invokeRestart("muffleWarning")
[09:29:19.668]                       }
[09:29:19.668]                       else if (inherits(cond, "condition")) {
[09:29:19.668]                         if (!is.null(pattern)) {
[09:29:19.668]                           computeRestarts <- base::computeRestarts
[09:29:19.668]                           grepl <- base::grepl
[09:29:19.668]                           restarts <- computeRestarts(cond)
[09:29:19.668]                           for (restart in restarts) {
[09:29:19.668]                             name <- restart$name
[09:29:19.668]                             if (is.null(name)) 
[09:29:19.668]                               next
[09:29:19.668]                             if (!grepl(pattern, name)) 
[09:29:19.668]                               next
[09:29:19.668]                             invokeRestart(restart)
[09:29:19.668]                             muffled <- TRUE
[09:29:19.668]                             break
[09:29:19.668]                           }
[09:29:19.668]                         }
[09:29:19.668]                       }
[09:29:19.668]                       invisible(muffled)
[09:29:19.668]                     }
[09:29:19.668]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.668]                   }
[09:29:19.668]                 }
[09:29:19.668]             }
[09:29:19.668]         }))
[09:29:19.668]     }, error = function(ex) {
[09:29:19.668]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.668]                 ...future.rng), started = ...future.startTime, 
[09:29:19.668]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.668]             version = "1.8"), class = "FutureResult")
[09:29:19.668]     }, finally = {
[09:29:19.668]         if (!identical(...future.workdir, getwd())) 
[09:29:19.668]             setwd(...future.workdir)
[09:29:19.668]         {
[09:29:19.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.668]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.668]             }
[09:29:19.668]             base::options(...future.oldOptions)
[09:29:19.668]             if (.Platform$OS.type == "windows") {
[09:29:19.668]                 old_names <- names(...future.oldEnvVars)
[09:29:19.668]                 envs <- base::Sys.getenv()
[09:29:19.668]                 names <- names(envs)
[09:29:19.668]                 common <- intersect(names, old_names)
[09:29:19.668]                 added <- setdiff(names, old_names)
[09:29:19.668]                 removed <- setdiff(old_names, names)
[09:29:19.668]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.668]                   envs[common]]
[09:29:19.668]                 NAMES <- toupper(changed)
[09:29:19.668]                 args <- list()
[09:29:19.668]                 for (kk in seq_along(NAMES)) {
[09:29:19.668]                   name <- changed[[kk]]
[09:29:19.668]                   NAME <- NAMES[[kk]]
[09:29:19.668]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.668]                     next
[09:29:19.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.668]                 }
[09:29:19.668]                 NAMES <- toupper(added)
[09:29:19.668]                 for (kk in seq_along(NAMES)) {
[09:29:19.668]                   name <- added[[kk]]
[09:29:19.668]                   NAME <- NAMES[[kk]]
[09:29:19.668]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.668]                     next
[09:29:19.668]                   args[[name]] <- ""
[09:29:19.668]                 }
[09:29:19.668]                 NAMES <- toupper(removed)
[09:29:19.668]                 for (kk in seq_along(NAMES)) {
[09:29:19.668]                   name <- removed[[kk]]
[09:29:19.668]                   NAME <- NAMES[[kk]]
[09:29:19.668]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.668]                     next
[09:29:19.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.668]                 }
[09:29:19.668]                 if (length(args) > 0) 
[09:29:19.668]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.668]             }
[09:29:19.668]             else {
[09:29:19.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.668]             }
[09:29:19.668]             {
[09:29:19.668]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.668]                   0L) {
[09:29:19.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.668]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.668]                   base::options(opts)
[09:29:19.668]                 }
[09:29:19.668]                 {
[09:29:19.668]                   {
[09:29:19.668]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.668]                     NULL
[09:29:19.668]                   }
[09:29:19.668]                   options(future.plan = NULL)
[09:29:19.668]                   if (is.na(NA_character_)) 
[09:29:19.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.668]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.668]                     .init = FALSE)
[09:29:19.668]                 }
[09:29:19.668]             }
[09:29:19.668]         }
[09:29:19.668]     })
[09:29:19.668]     if (TRUE) {
[09:29:19.668]         base::sink(type = "output", split = FALSE)
[09:29:19.668]         if (TRUE) {
[09:29:19.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.668]         }
[09:29:19.668]         else {
[09:29:19.668]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.668]         }
[09:29:19.668]         base::close(...future.stdout)
[09:29:19.668]         ...future.stdout <- NULL
[09:29:19.668]     }
[09:29:19.668]     ...future.result$conditions <- ...future.conditions
[09:29:19.668]     ...future.result$finished <- base::Sys.time()
[09:29:19.668]     ...future.result
[09:29:19.668] }
[09:29:19.670] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[09:29:19.670] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[09:29:19.671] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[09:29:19.671] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:19.671] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.671] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[09:29:19.672] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[09:29:19.672] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:19.672] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.672] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:19.673] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.673] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[09:29:19.673] MultisessionFuture started
[09:29:19.673] - Launch lazy future ... done
[09:29:19.674] run() for ‘MultisessionFuture’ ... done
[09:29:19.674] Created future:
[09:29:19.674] MultisessionFuture:
[09:29:19.674] Label: ‘future_mapply-2’
[09:29:19.674] Expression:
[09:29:19.674] {
[09:29:19.674]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.674]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.674]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.674]         on.exit(options(oopts), add = TRUE)
[09:29:19.674]     }
[09:29:19.674]     {
[09:29:19.674]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.674]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.674]         do.call(mapply, args = args)
[09:29:19.674]     }
[09:29:19.674] }
[09:29:19.674] Lazy evaluation: FALSE
[09:29:19.674] Asynchronous evaluation: TRUE
[09:29:19.674] Local evaluation: TRUE
[09:29:19.674] Environment: R_GlobalEnv
[09:29:19.674] Capture standard output: TRUE
[09:29:19.674] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.674] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.674] Packages: <none>
[09:29:19.674] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.674] Resolved: FALSE
[09:29:19.674] Value: <not collected>
[09:29:19.674] Conditions captured: <none>
[09:29:19.674] Early signaling: FALSE
[09:29:19.674] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.674] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.685] Chunk #2 of 3 ... DONE
[09:29:19.685] Chunk #3 of 3 ...
[09:29:19.685]  - Finding globals in '...' for chunk #3 ...
[09:29:19.685] getGlobalsAndPackages() ...
[09:29:19.686] Searching for globals...
[09:29:19.686] 
[09:29:19.686] Searching for globals ... DONE
[09:29:19.686] - globals: [0] <none>
[09:29:19.686] getGlobalsAndPackages() ... DONE
[09:29:19.686]    + additional globals found: [n=0] 
[09:29:19.686]    + additional namespaces needed: [n=0] 
[09:29:19.686]  - Finding globals in '...' for chunk #3 ... DONE
[09:29:19.687]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[09:29:19.687]  - seeds: <none>
[09:29:19.687]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.687] getGlobalsAndPackages() ...
[09:29:19.687] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.687] Resolving globals: FALSE
[09:29:19.687] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:19.688] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:19.688] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.688] 
[09:29:19.688] getGlobalsAndPackages() ... DONE
[09:29:19.689] run() for ‘Future’ ...
[09:29:19.689] - state: ‘created’
[09:29:19.689] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.702] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.702]   - Field: ‘node’
[09:29:19.703]   - Field: ‘label’
[09:29:19.703]   - Field: ‘local’
[09:29:19.703]   - Field: ‘owner’
[09:29:19.703]   - Field: ‘envir’
[09:29:19.703]   - Field: ‘workers’
[09:29:19.703]   - Field: ‘packages’
[09:29:19.703]   - Field: ‘gc’
[09:29:19.703]   - Field: ‘conditions’
[09:29:19.703]   - Field: ‘persistent’
[09:29:19.703]   - Field: ‘expr’
[09:29:19.703]   - Field: ‘uuid’
[09:29:19.704]   - Field: ‘seed’
[09:29:19.704]   - Field: ‘version’
[09:29:19.704]   - Field: ‘result’
[09:29:19.704]   - Field: ‘asynchronous’
[09:29:19.704]   - Field: ‘calls’
[09:29:19.704]   - Field: ‘globals’
[09:29:19.704]   - Field: ‘stdout’
[09:29:19.704]   - Field: ‘earlySignal’
[09:29:19.704]   - Field: ‘lazy’
[09:29:19.704]   - Field: ‘state’
[09:29:19.704] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.705] - Launch lazy future ...
[09:29:19.705] Packages needed by the future expression (n = 0): <none>
[09:29:19.705] Packages needed by future strategies (n = 0): <none>
[09:29:19.705] {
[09:29:19.705]     {
[09:29:19.705]         {
[09:29:19.705]             ...future.startTime <- base::Sys.time()
[09:29:19.705]             {
[09:29:19.705]                 {
[09:29:19.705]                   {
[09:29:19.705]                     {
[09:29:19.705]                       base::local({
[09:29:19.705]                         has_future <- base::requireNamespace("future", 
[09:29:19.705]                           quietly = TRUE)
[09:29:19.705]                         if (has_future) {
[09:29:19.705]                           ns <- base::getNamespace("future")
[09:29:19.705]                           version <- ns[[".package"]][["version"]]
[09:29:19.705]                           if (is.null(version)) 
[09:29:19.705]                             version <- utils::packageVersion("future")
[09:29:19.705]                         }
[09:29:19.705]                         else {
[09:29:19.705]                           version <- NULL
[09:29:19.705]                         }
[09:29:19.705]                         if (!has_future || version < "1.8.0") {
[09:29:19.705]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.705]                             "", base::R.version$version.string), 
[09:29:19.705]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.705]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.705]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.705]                               "release", "version")], collapse = " "), 
[09:29:19.705]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.705]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.705]                             info)
[09:29:19.705]                           info <- base::paste(info, collapse = "; ")
[09:29:19.705]                           if (!has_future) {
[09:29:19.705]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.705]                               info)
[09:29:19.705]                           }
[09:29:19.705]                           else {
[09:29:19.705]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.705]                               info, version)
[09:29:19.705]                           }
[09:29:19.705]                           base::stop(msg)
[09:29:19.705]                         }
[09:29:19.705]                       })
[09:29:19.705]                     }
[09:29:19.705]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.705]                     base::options(mc.cores = 1L)
[09:29:19.705]                   }
[09:29:19.705]                   ...future.strategy.old <- future::plan("list")
[09:29:19.705]                   options(future.plan = NULL)
[09:29:19.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.705]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.705]                 }
[09:29:19.705]                 ...future.workdir <- getwd()
[09:29:19.705]             }
[09:29:19.705]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.705]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.705]         }
[09:29:19.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.705]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[09:29:19.705]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.705]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.705]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.705]             base::names(...future.oldOptions))
[09:29:19.705]     }
[09:29:19.705]     if (FALSE) {
[09:29:19.705]     }
[09:29:19.705]     else {
[09:29:19.705]         if (TRUE) {
[09:29:19.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.705]                 open = "w")
[09:29:19.705]         }
[09:29:19.705]         else {
[09:29:19.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.705]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.705]         }
[09:29:19.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.705]             base::sink(type = "output", split = FALSE)
[09:29:19.705]             base::close(...future.stdout)
[09:29:19.705]         }, add = TRUE)
[09:29:19.705]     }
[09:29:19.705]     ...future.frame <- base::sys.nframe()
[09:29:19.705]     ...future.conditions <- base::list()
[09:29:19.705]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.705]     if (FALSE) {
[09:29:19.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.705]     }
[09:29:19.705]     ...future.result <- base::tryCatch({
[09:29:19.705]         base::withCallingHandlers({
[09:29:19.705]             ...future.value <- base::withVisible(base::local({
[09:29:19.705]                 ...future.makeSendCondition <- base::local({
[09:29:19.705]                   sendCondition <- NULL
[09:29:19.705]                   function(frame = 1L) {
[09:29:19.705]                     if (is.function(sendCondition)) 
[09:29:19.705]                       return(sendCondition)
[09:29:19.705]                     ns <- getNamespace("parallel")
[09:29:19.705]                     if (exists("sendData", mode = "function", 
[09:29:19.705]                       envir = ns)) {
[09:29:19.705]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.705]                         envir = ns)
[09:29:19.705]                       envir <- sys.frame(frame)
[09:29:19.705]                       master <- NULL
[09:29:19.705]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.705]                         !identical(envir, emptyenv())) {
[09:29:19.705]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.705]                           inherits = FALSE)) {
[09:29:19.705]                           master <- get("master", mode = "list", 
[09:29:19.705]                             envir = envir, inherits = FALSE)
[09:29:19.705]                           if (inherits(master, c("SOCKnode", 
[09:29:19.705]                             "SOCK0node"))) {
[09:29:19.705]                             sendCondition <<- function(cond) {
[09:29:19.705]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.705]                                 success = TRUE)
[09:29:19.705]                               parallel_sendData(master, data)
[09:29:19.705]                             }
[09:29:19.705]                             return(sendCondition)
[09:29:19.705]                           }
[09:29:19.705]                         }
[09:29:19.705]                         frame <- frame + 1L
[09:29:19.705]                         envir <- sys.frame(frame)
[09:29:19.705]                       }
[09:29:19.705]                     }
[09:29:19.705]                     sendCondition <<- function(cond) NULL
[09:29:19.705]                   }
[09:29:19.705]                 })
[09:29:19.705]                 withCallingHandlers({
[09:29:19.705]                   {
[09:29:19.705]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.705]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.705]                       ...future.globals.maxSize)) {
[09:29:19.705]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.705]                       on.exit(options(oopts), add = TRUE)
[09:29:19.705]                     }
[09:29:19.705]                     {
[09:29:19.705]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.705]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.705]                         USE.NAMES = FALSE)
[09:29:19.705]                       do.call(mapply, args = args)
[09:29:19.705]                     }
[09:29:19.705]                   }
[09:29:19.705]                 }, immediateCondition = function(cond) {
[09:29:19.705]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.705]                   sendCondition(cond)
[09:29:19.705]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.705]                   {
[09:29:19.705]                     inherits <- base::inherits
[09:29:19.705]                     invokeRestart <- base::invokeRestart
[09:29:19.705]                     is.null <- base::is.null
[09:29:19.705]                     muffled <- FALSE
[09:29:19.705]                     if (inherits(cond, "message")) {
[09:29:19.705]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.705]                       if (muffled) 
[09:29:19.705]                         invokeRestart("muffleMessage")
[09:29:19.705]                     }
[09:29:19.705]                     else if (inherits(cond, "warning")) {
[09:29:19.705]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.705]                       if (muffled) 
[09:29:19.705]                         invokeRestart("muffleWarning")
[09:29:19.705]                     }
[09:29:19.705]                     else if (inherits(cond, "condition")) {
[09:29:19.705]                       if (!is.null(pattern)) {
[09:29:19.705]                         computeRestarts <- base::computeRestarts
[09:29:19.705]                         grepl <- base::grepl
[09:29:19.705]                         restarts <- computeRestarts(cond)
[09:29:19.705]                         for (restart in restarts) {
[09:29:19.705]                           name <- restart$name
[09:29:19.705]                           if (is.null(name)) 
[09:29:19.705]                             next
[09:29:19.705]                           if (!grepl(pattern, name)) 
[09:29:19.705]                             next
[09:29:19.705]                           invokeRestart(restart)
[09:29:19.705]                           muffled <- TRUE
[09:29:19.705]                           break
[09:29:19.705]                         }
[09:29:19.705]                       }
[09:29:19.705]                     }
[09:29:19.705]                     invisible(muffled)
[09:29:19.705]                   }
[09:29:19.705]                   muffleCondition(cond)
[09:29:19.705]                 })
[09:29:19.705]             }))
[09:29:19.705]             future::FutureResult(value = ...future.value$value, 
[09:29:19.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.705]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.705]                     ...future.globalenv.names))
[09:29:19.705]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.705]         }, condition = base::local({
[09:29:19.705]             c <- base::c
[09:29:19.705]             inherits <- base::inherits
[09:29:19.705]             invokeRestart <- base::invokeRestart
[09:29:19.705]             length <- base::length
[09:29:19.705]             list <- base::list
[09:29:19.705]             seq.int <- base::seq.int
[09:29:19.705]             signalCondition <- base::signalCondition
[09:29:19.705]             sys.calls <- base::sys.calls
[09:29:19.705]             `[[` <- base::`[[`
[09:29:19.705]             `+` <- base::`+`
[09:29:19.705]             `<<-` <- base::`<<-`
[09:29:19.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.705]                   3L)]
[09:29:19.705]             }
[09:29:19.705]             function(cond) {
[09:29:19.705]                 is_error <- inherits(cond, "error")
[09:29:19.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.705]                   NULL)
[09:29:19.705]                 if (is_error) {
[09:29:19.705]                   sessionInformation <- function() {
[09:29:19.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.705]                       search = base::search(), system = base::Sys.info())
[09:29:19.705]                   }
[09:29:19.705]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.705]                     cond$call), session = sessionInformation(), 
[09:29:19.705]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.705]                   signalCondition(cond)
[09:29:19.705]                 }
[09:29:19.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.705]                 "immediateCondition"))) {
[09:29:19.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.705]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.705]                   if (TRUE && !signal) {
[09:29:19.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.705]                     {
[09:29:19.705]                       inherits <- base::inherits
[09:29:19.705]                       invokeRestart <- base::invokeRestart
[09:29:19.705]                       is.null <- base::is.null
[09:29:19.705]                       muffled <- FALSE
[09:29:19.705]                       if (inherits(cond, "message")) {
[09:29:19.705]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.705]                         if (muffled) 
[09:29:19.705]                           invokeRestart("muffleMessage")
[09:29:19.705]                       }
[09:29:19.705]                       else if (inherits(cond, "warning")) {
[09:29:19.705]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.705]                         if (muffled) 
[09:29:19.705]                           invokeRestart("muffleWarning")
[09:29:19.705]                       }
[09:29:19.705]                       else if (inherits(cond, "condition")) {
[09:29:19.705]                         if (!is.null(pattern)) {
[09:29:19.705]                           computeRestarts <- base::computeRestarts
[09:29:19.705]                           grepl <- base::grepl
[09:29:19.705]                           restarts <- computeRestarts(cond)
[09:29:19.705]                           for (restart in restarts) {
[09:29:19.705]                             name <- restart$name
[09:29:19.705]                             if (is.null(name)) 
[09:29:19.705]                               next
[09:29:19.705]                             if (!grepl(pattern, name)) 
[09:29:19.705]                               next
[09:29:19.705]                             invokeRestart(restart)
[09:29:19.705]                             muffled <- TRUE
[09:29:19.705]                             break
[09:29:19.705]                           }
[09:29:19.705]                         }
[09:29:19.705]                       }
[09:29:19.705]                       invisible(muffled)
[09:29:19.705]                     }
[09:29:19.705]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.705]                   }
[09:29:19.705]                 }
[09:29:19.705]                 else {
[09:29:19.705]                   if (TRUE) {
[09:29:19.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.705]                     {
[09:29:19.705]                       inherits <- base::inherits
[09:29:19.705]                       invokeRestart <- base::invokeRestart
[09:29:19.705]                       is.null <- base::is.null
[09:29:19.705]                       muffled <- FALSE
[09:29:19.705]                       if (inherits(cond, "message")) {
[09:29:19.705]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.705]                         if (muffled) 
[09:29:19.705]                           invokeRestart("muffleMessage")
[09:29:19.705]                       }
[09:29:19.705]                       else if (inherits(cond, "warning")) {
[09:29:19.705]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.705]                         if (muffled) 
[09:29:19.705]                           invokeRestart("muffleWarning")
[09:29:19.705]                       }
[09:29:19.705]                       else if (inherits(cond, "condition")) {
[09:29:19.705]                         if (!is.null(pattern)) {
[09:29:19.705]                           computeRestarts <- base::computeRestarts
[09:29:19.705]                           grepl <- base::grepl
[09:29:19.705]                           restarts <- computeRestarts(cond)
[09:29:19.705]                           for (restart in restarts) {
[09:29:19.705]                             name <- restart$name
[09:29:19.705]                             if (is.null(name)) 
[09:29:19.705]                               next
[09:29:19.705]                             if (!grepl(pattern, name)) 
[09:29:19.705]                               next
[09:29:19.705]                             invokeRestart(restart)
[09:29:19.705]                             muffled <- TRUE
[09:29:19.705]                             break
[09:29:19.705]                           }
[09:29:19.705]                         }
[09:29:19.705]                       }
[09:29:19.705]                       invisible(muffled)
[09:29:19.705]                     }
[09:29:19.705]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.705]                   }
[09:29:19.705]                 }
[09:29:19.705]             }
[09:29:19.705]         }))
[09:29:19.705]     }, error = function(ex) {
[09:29:19.705]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.705]                 ...future.rng), started = ...future.startTime, 
[09:29:19.705]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.705]             version = "1.8"), class = "FutureResult")
[09:29:19.705]     }, finally = {
[09:29:19.705]         if (!identical(...future.workdir, getwd())) 
[09:29:19.705]             setwd(...future.workdir)
[09:29:19.705]         {
[09:29:19.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.705]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.705]             }
[09:29:19.705]             base::options(...future.oldOptions)
[09:29:19.705]             if (.Platform$OS.type == "windows") {
[09:29:19.705]                 old_names <- names(...future.oldEnvVars)
[09:29:19.705]                 envs <- base::Sys.getenv()
[09:29:19.705]                 names <- names(envs)
[09:29:19.705]                 common <- intersect(names, old_names)
[09:29:19.705]                 added <- setdiff(names, old_names)
[09:29:19.705]                 removed <- setdiff(old_names, names)
[09:29:19.705]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.705]                   envs[common]]
[09:29:19.705]                 NAMES <- toupper(changed)
[09:29:19.705]                 args <- list()
[09:29:19.705]                 for (kk in seq_along(NAMES)) {
[09:29:19.705]                   name <- changed[[kk]]
[09:29:19.705]                   NAME <- NAMES[[kk]]
[09:29:19.705]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.705]                     next
[09:29:19.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.705]                 }
[09:29:19.705]                 NAMES <- toupper(added)
[09:29:19.705]                 for (kk in seq_along(NAMES)) {
[09:29:19.705]                   name <- added[[kk]]
[09:29:19.705]                   NAME <- NAMES[[kk]]
[09:29:19.705]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.705]                     next
[09:29:19.705]                   args[[name]] <- ""
[09:29:19.705]                 }
[09:29:19.705]                 NAMES <- toupper(removed)
[09:29:19.705]                 for (kk in seq_along(NAMES)) {
[09:29:19.705]                   name <- removed[[kk]]
[09:29:19.705]                   NAME <- NAMES[[kk]]
[09:29:19.705]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.705]                     next
[09:29:19.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.705]                 }
[09:29:19.705]                 if (length(args) > 0) 
[09:29:19.705]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.705]             }
[09:29:19.705]             else {
[09:29:19.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.705]             }
[09:29:19.705]             {
[09:29:19.705]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.705]                   0L) {
[09:29:19.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.705]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.705]                   base::options(opts)
[09:29:19.705]                 }
[09:29:19.705]                 {
[09:29:19.705]                   {
[09:29:19.705]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.705]                     NULL
[09:29:19.705]                   }
[09:29:19.705]                   options(future.plan = NULL)
[09:29:19.705]                   if (is.na(NA_character_)) 
[09:29:19.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.705]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.705]                     .init = FALSE)
[09:29:19.705]                 }
[09:29:19.705]             }
[09:29:19.705]         }
[09:29:19.705]     })
[09:29:19.705]     if (TRUE) {
[09:29:19.705]         base::sink(type = "output", split = FALSE)
[09:29:19.705]         if (TRUE) {
[09:29:19.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.705]         }
[09:29:19.705]         else {
[09:29:19.705]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.705]         }
[09:29:19.705]         base::close(...future.stdout)
[09:29:19.705]         ...future.stdout <- NULL
[09:29:19.705]     }
[09:29:19.705]     ...future.result$conditions <- ...future.conditions
[09:29:19.705]     ...future.result$finished <- base::Sys.time()
[09:29:19.705]     ...future.result
[09:29:19.705] }
[09:29:19.707] Poll #1 (0): usedNodes() = 2, workers = 2
[09:29:19.718] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.718] - Validating connection of MultisessionFuture
[09:29:19.718] - received message: FutureResult
[09:29:19.718] - Received FutureResult
[09:29:19.719] - Erased future from FutureRegistry
[09:29:19.719] result() for ClusterFuture ...
[09:29:19.719] - result already collected: FutureResult
[09:29:19.719] result() for ClusterFuture ... done
[09:29:19.719] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.719] result() for ClusterFuture ...
[09:29:19.719] - result already collected: FutureResult
[09:29:19.719] result() for ClusterFuture ... done
[09:29:19.719] result() for ClusterFuture ...
[09:29:19.719] - result already collected: FutureResult
[09:29:19.719] result() for ClusterFuture ... done
[09:29:19.720] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[09:29:19.720] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[09:29:19.721] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[09:29:19.721] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:19.721] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.721] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[09:29:19.721] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[09:29:19.722] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:19.722] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.722] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:19.722] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.722] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[09:29:19.723] MultisessionFuture started
[09:29:19.723] - Launch lazy future ... done
[09:29:19.723] run() for ‘MultisessionFuture’ ... done
[09:29:19.723] Created future:
[09:29:19.723] MultisessionFuture:
[09:29:19.723] Label: ‘future_mapply-3’
[09:29:19.723] Expression:
[09:29:19.723] {
[09:29:19.723]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.723]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.723]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.723]         on.exit(options(oopts), add = TRUE)
[09:29:19.723]     }
[09:29:19.723]     {
[09:29:19.723]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.723]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.723]         do.call(mapply, args = args)
[09:29:19.723]     }
[09:29:19.723] }
[09:29:19.723] Lazy evaluation: FALSE
[09:29:19.723] Asynchronous evaluation: TRUE
[09:29:19.723] Local evaluation: TRUE
[09:29:19.723] Environment: R_GlobalEnv
[09:29:19.723] Capture standard output: TRUE
[09:29:19.723] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.723] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.723] Packages: <none>
[09:29:19.723] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.723] Resolved: FALSE
[09:29:19.723] Value: <not collected>
[09:29:19.723] Conditions captured: <none>
[09:29:19.723] Early signaling: FALSE
[09:29:19.723] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.723] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.735] Chunk #3 of 3 ... DONE
[09:29:19.735] Launching 3 futures (chunks) ... DONE
[09:29:19.735] Resolving 3 futures (chunks) ...
[09:29:19.737] resolve() on list ...
[09:29:19.737]  recursive: 0
[09:29:19.738]  length: 3
[09:29:19.738] 
[09:29:19.738] Future #1
[09:29:19.738] result() for ClusterFuture ...
[09:29:19.738] - result already collected: FutureResult
[09:29:19.738] result() for ClusterFuture ... done
[09:29:19.738] result() for ClusterFuture ...
[09:29:19.738] - result already collected: FutureResult
[09:29:19.738] result() for ClusterFuture ... done
[09:29:19.738] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:19.738] - nx: 3
[09:29:19.738] - relay: TRUE
[09:29:19.739] - stdout: TRUE
[09:29:19.739] - signal: TRUE
[09:29:19.739] - resignal: FALSE
[09:29:19.739] - force: TRUE
[09:29:19.739] - relayed: [n=3] FALSE, FALSE, FALSE
[09:29:19.739] - queued futures: [n=3] FALSE, FALSE, FALSE
[09:29:19.739]  - until=1
[09:29:19.739]  - relaying element #1
[09:29:19.739] result() for ClusterFuture ...
[09:29:19.739] - result already collected: FutureResult
[09:29:19.739] result() for ClusterFuture ... done
[09:29:19.739] result() for ClusterFuture ...
[09:29:19.740] - result already collected: FutureResult
[09:29:19.740] result() for ClusterFuture ... done
[09:29:19.740] result() for ClusterFuture ...
[09:29:19.740] - result already collected: FutureResult
[09:29:19.740] result() for ClusterFuture ... done
[09:29:19.740] result() for ClusterFuture ...
[09:29:19.740] - result already collected: FutureResult
[09:29:19.740] result() for ClusterFuture ... done
[09:29:19.740] - relayed: [n=3] TRUE, FALSE, FALSE
[09:29:19.740] - queued futures: [n=3] TRUE, FALSE, FALSE
[09:29:19.740] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:19.741]  length: 2 (resolved future 1)
[09:29:19.741] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.741] - Validating connection of MultisessionFuture
[09:29:19.741] - received message: FutureResult
[09:29:19.741] - Received FutureResult
[09:29:19.742] - Erased future from FutureRegistry
[09:29:19.742] result() for ClusterFuture ...
[09:29:19.742] - result already collected: FutureResult
[09:29:19.742] result() for ClusterFuture ... done
[09:29:19.742] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.742] Future #2
[09:29:19.742] result() for ClusterFuture ...
[09:29:19.742] - result already collected: FutureResult
[09:29:19.742] result() for ClusterFuture ... done
[09:29:19.742] result() for ClusterFuture ...
[09:29:19.742] - result already collected: FutureResult
[09:29:19.742] result() for ClusterFuture ... done
[09:29:19.743] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:19.743] - nx: 3
[09:29:19.743] - relay: TRUE
[09:29:19.743] - stdout: TRUE
[09:29:19.743] - signal: TRUE
[09:29:19.743] - resignal: FALSE
[09:29:19.743] - force: TRUE
[09:29:19.743] - relayed: [n=3] TRUE, FALSE, FALSE
[09:29:19.743] - queued futures: [n=3] TRUE, FALSE, FALSE
[09:29:19.743]  - until=2
[09:29:19.743]  - relaying element #2
[09:29:19.743] result() for ClusterFuture ...
[09:29:19.744] - result already collected: FutureResult
[09:29:19.744] result() for ClusterFuture ... done
[09:29:19.744] result() for ClusterFuture ...
[09:29:19.744] - result already collected: FutureResult
[09:29:19.744] result() for ClusterFuture ... done
[09:29:19.744] result() for ClusterFuture ...
[09:29:19.744] - result already collected: FutureResult
[09:29:19.744] result() for ClusterFuture ... done
[09:29:19.744] result() for ClusterFuture ...
[09:29:19.744] - result already collected: FutureResult
[09:29:19.744] result() for ClusterFuture ... done
[09:29:19.745] - relayed: [n=3] TRUE, TRUE, FALSE
[09:29:19.745] - queued futures: [n=3] TRUE, TRUE, FALSE
[09:29:19.745] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:19.745]  length: 1 (resolved future 2)
[09:29:19.766] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.766] - Validating connection of MultisessionFuture
[09:29:19.766] - received message: FutureResult
[09:29:19.766] - Received FutureResult
[09:29:19.766] - Erased future from FutureRegistry
[09:29:19.766] result() for ClusterFuture ...
[09:29:19.766] - result already collected: FutureResult
[09:29:19.766] result() for ClusterFuture ... done
[09:29:19.767] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.767] Future #3
[09:29:19.767] result() for ClusterFuture ...
[09:29:19.767] - result already collected: FutureResult
[09:29:19.767] result() for ClusterFuture ... done
[09:29:19.767] result() for ClusterFuture ...
[09:29:19.767] - result already collected: FutureResult
[09:29:19.767] result() for ClusterFuture ... done
[09:29:19.767] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:29:19.767] - nx: 3
[09:29:19.767] - relay: TRUE
[09:29:19.767] - stdout: TRUE
[09:29:19.768] - signal: TRUE
[09:29:19.768] - resignal: FALSE
[09:29:19.768] - force: TRUE
[09:29:19.768] - relayed: [n=3] TRUE, TRUE, FALSE
[09:29:19.768] - queued futures: [n=3] TRUE, TRUE, FALSE
[09:29:19.768]  - until=3
[09:29:19.768]  - relaying element #3
[09:29:19.768] result() for ClusterFuture ...
[09:29:19.768] - result already collected: FutureResult
[09:29:19.768] result() for ClusterFuture ... done
[09:29:19.768] result() for ClusterFuture ...
[09:29:19.769] - result already collected: FutureResult
[09:29:19.769] result() for ClusterFuture ... done
[09:29:19.769] result() for ClusterFuture ...
[09:29:19.769] - result already collected: FutureResult
[09:29:19.769] result() for ClusterFuture ... done
[09:29:19.769] result() for ClusterFuture ...
[09:29:19.769] - result already collected: FutureResult
[09:29:19.769] result() for ClusterFuture ... done
[09:29:19.769] - relayed: [n=3] TRUE, TRUE, TRUE
[09:29:19.769] - queued futures: [n=3] TRUE, TRUE, TRUE
[09:29:19.769] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:29:19.770]  length: 0 (resolved future 3)
[09:29:19.770] Relaying remaining futures
[09:29:19.770] signalConditionsASAP(NULL, pos=0) ...
[09:29:19.770] - nx: 3
[09:29:19.770] - relay: TRUE
[09:29:19.770] - stdout: TRUE
[09:29:19.770] - signal: TRUE
[09:29:19.770] - resignal: FALSE
[09:29:19.770] - force: TRUE
[09:29:19.770] - relayed: [n=3] TRUE, TRUE, TRUE
[09:29:19.770] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[09:29:19.770] - relayed: [n=3] TRUE, TRUE, TRUE
[09:29:19.771] - queued futures: [n=3] TRUE, TRUE, TRUE
[09:29:19.771] signalConditionsASAP(NULL, pos=0) ... done
[09:29:19.771] resolve() on list ... DONE
[09:29:19.771] result() for ClusterFuture ...
[09:29:19.771] - result already collected: FutureResult
[09:29:19.771] result() for ClusterFuture ... done
[09:29:19.771] result() for ClusterFuture ...
[09:29:19.771] - result already collected: FutureResult
[09:29:19.771] result() for ClusterFuture ... done
[09:29:19.771] result() for ClusterFuture ...
[09:29:19.771] - result already collected: FutureResult
[09:29:19.771] result() for ClusterFuture ... done
[09:29:19.772] result() for ClusterFuture ...
[09:29:19.772] - result already collected: FutureResult
[09:29:19.772] result() for ClusterFuture ... done
[09:29:19.772] result() for ClusterFuture ...
[09:29:19.772] - result already collected: FutureResult
[09:29:19.772] result() for ClusterFuture ... done
[09:29:19.772] result() for ClusterFuture ...
[09:29:19.772] - result already collected: FutureResult
[09:29:19.772] result() for ClusterFuture ... done
[09:29:19.772]  - Number of value chunks collected: 3
[09:29:19.772] Resolving 3 futures (chunks) ... DONE
[09:29:19.773] Reducing values from 3 chunks ...
[09:29:19.773]  - Number of values collected after concatenation: 5
[09:29:19.773]  - Number of values expected: 5
[09:29:19.773] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 3, 4, 2, 1
[09:29:19.773] Reducing values from 3 chunks ... DONE
[09:29:19.773] future_mapply() ... DONE
[09:29:19.773] future_mapply() ...
[09:29:19.777] Number of chunks: 2
[09:29:19.777] getGlobalsAndPackagesXApply() ...
[09:29:19.777]  - future.globals: TRUE
[09:29:19.777] getGlobalsAndPackages() ...
[09:29:19.777] Searching for globals...
[09:29:19.778] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:19.778] Searching for globals ... DONE
[09:29:19.778] Resolving globals: FALSE
[09:29:19.779] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:19.779] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:19.779] - globals: [1] ‘FUN’
[09:29:19.779] 
[09:29:19.779] getGlobalsAndPackages() ... DONE
[09:29:19.780]  - globals found/used: [n=1] ‘FUN’
[09:29:19.780]  - needed namespaces: [n=0] 
[09:29:19.780] Finding globals ... DONE
[09:29:19.780] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:19.780] List of 2
[09:29:19.780]  $ ...future.FUN:function (C, k)  
[09:29:19.780]  $ MoreArgs     : list()
[09:29:19.780]  - attr(*, "where")=List of 2
[09:29:19.780]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:19.780]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:19.780]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:19.780]  - attr(*, "resolved")= logi FALSE
[09:29:19.780]  - attr(*, "total_size")= num NA
[09:29:19.782] Packages to be attached in all futures: [n=0] 
[09:29:19.783] getGlobalsAndPackagesXApply() ... DONE
[09:29:19.783] Number of futures (= number of chunks): 2
[09:29:19.783] Launching 2 futures (chunks) ...
[09:29:19.783] Chunk #1 of 2 ...
[09:29:19.783]  - Finding globals in '...' for chunk #1 ...
[09:29:19.783] getGlobalsAndPackages() ...
[09:29:19.783] Searching for globals...
[09:29:19.784] 
[09:29:19.784] Searching for globals ... DONE
[09:29:19.784] - globals: [0] <none>
[09:29:19.784] getGlobalsAndPackages() ... DONE
[09:29:19.784]    + additional globals found: [n=0] 
[09:29:19.784]    + additional namespaces needed: [n=0] 
[09:29:19.784]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:19.784]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:19.784]  - seeds: <none>
[09:29:19.784]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.784] getGlobalsAndPackages() ...
[09:29:19.785] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.785] Resolving globals: FALSE
[09:29:19.785] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:19.786] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:19.786] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.786] 
[09:29:19.786] getGlobalsAndPackages() ... DONE
[09:29:19.786] run() for ‘Future’ ...
[09:29:19.786] - state: ‘created’
[09:29:19.786] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.800] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.800] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.800]   - Field: ‘node’
[09:29:19.800]   - Field: ‘label’
[09:29:19.800]   - Field: ‘local’
[09:29:19.800]   - Field: ‘owner’
[09:29:19.801]   - Field: ‘envir’
[09:29:19.801]   - Field: ‘workers’
[09:29:19.801]   - Field: ‘packages’
[09:29:19.801]   - Field: ‘gc’
[09:29:19.801]   - Field: ‘conditions’
[09:29:19.801]   - Field: ‘persistent’
[09:29:19.801]   - Field: ‘expr’
[09:29:19.801]   - Field: ‘uuid’
[09:29:19.801]   - Field: ‘seed’
[09:29:19.801]   - Field: ‘version’
[09:29:19.801]   - Field: ‘result’
[09:29:19.802]   - Field: ‘asynchronous’
[09:29:19.802]   - Field: ‘calls’
[09:29:19.802]   - Field: ‘globals’
[09:29:19.802]   - Field: ‘stdout’
[09:29:19.802]   - Field: ‘earlySignal’
[09:29:19.802]   - Field: ‘lazy’
[09:29:19.802]   - Field: ‘state’
[09:29:19.802] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.802] - Launch lazy future ...
[09:29:19.802] Packages needed by the future expression (n = 0): <none>
[09:29:19.803] Packages needed by future strategies (n = 0): <none>
[09:29:19.803] {
[09:29:19.803]     {
[09:29:19.803]         {
[09:29:19.803]             ...future.startTime <- base::Sys.time()
[09:29:19.803]             {
[09:29:19.803]                 {
[09:29:19.803]                   {
[09:29:19.803]                     {
[09:29:19.803]                       base::local({
[09:29:19.803]                         has_future <- base::requireNamespace("future", 
[09:29:19.803]                           quietly = TRUE)
[09:29:19.803]                         if (has_future) {
[09:29:19.803]                           ns <- base::getNamespace("future")
[09:29:19.803]                           version <- ns[[".package"]][["version"]]
[09:29:19.803]                           if (is.null(version)) 
[09:29:19.803]                             version <- utils::packageVersion("future")
[09:29:19.803]                         }
[09:29:19.803]                         else {
[09:29:19.803]                           version <- NULL
[09:29:19.803]                         }
[09:29:19.803]                         if (!has_future || version < "1.8.0") {
[09:29:19.803]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.803]                             "", base::R.version$version.string), 
[09:29:19.803]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.803]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.803]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.803]                               "release", "version")], collapse = " "), 
[09:29:19.803]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.803]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.803]                             info)
[09:29:19.803]                           info <- base::paste(info, collapse = "; ")
[09:29:19.803]                           if (!has_future) {
[09:29:19.803]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.803]                               info)
[09:29:19.803]                           }
[09:29:19.803]                           else {
[09:29:19.803]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.803]                               info, version)
[09:29:19.803]                           }
[09:29:19.803]                           base::stop(msg)
[09:29:19.803]                         }
[09:29:19.803]                       })
[09:29:19.803]                     }
[09:29:19.803]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.803]                     base::options(mc.cores = 1L)
[09:29:19.803]                   }
[09:29:19.803]                   ...future.strategy.old <- future::plan("list")
[09:29:19.803]                   options(future.plan = NULL)
[09:29:19.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.803]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.803]                 }
[09:29:19.803]                 ...future.workdir <- getwd()
[09:29:19.803]             }
[09:29:19.803]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.803]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.803]         }
[09:29:19.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.803]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:19.803]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.803]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.803]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.803]             base::names(...future.oldOptions))
[09:29:19.803]     }
[09:29:19.803]     if (FALSE) {
[09:29:19.803]     }
[09:29:19.803]     else {
[09:29:19.803]         if (TRUE) {
[09:29:19.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.803]                 open = "w")
[09:29:19.803]         }
[09:29:19.803]         else {
[09:29:19.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.803]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.803]         }
[09:29:19.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.803]             base::sink(type = "output", split = FALSE)
[09:29:19.803]             base::close(...future.stdout)
[09:29:19.803]         }, add = TRUE)
[09:29:19.803]     }
[09:29:19.803]     ...future.frame <- base::sys.nframe()
[09:29:19.803]     ...future.conditions <- base::list()
[09:29:19.803]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.803]     if (FALSE) {
[09:29:19.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.803]     }
[09:29:19.803]     ...future.result <- base::tryCatch({
[09:29:19.803]         base::withCallingHandlers({
[09:29:19.803]             ...future.value <- base::withVisible(base::local({
[09:29:19.803]                 ...future.makeSendCondition <- base::local({
[09:29:19.803]                   sendCondition <- NULL
[09:29:19.803]                   function(frame = 1L) {
[09:29:19.803]                     if (is.function(sendCondition)) 
[09:29:19.803]                       return(sendCondition)
[09:29:19.803]                     ns <- getNamespace("parallel")
[09:29:19.803]                     if (exists("sendData", mode = "function", 
[09:29:19.803]                       envir = ns)) {
[09:29:19.803]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.803]                         envir = ns)
[09:29:19.803]                       envir <- sys.frame(frame)
[09:29:19.803]                       master <- NULL
[09:29:19.803]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.803]                         !identical(envir, emptyenv())) {
[09:29:19.803]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.803]                           inherits = FALSE)) {
[09:29:19.803]                           master <- get("master", mode = "list", 
[09:29:19.803]                             envir = envir, inherits = FALSE)
[09:29:19.803]                           if (inherits(master, c("SOCKnode", 
[09:29:19.803]                             "SOCK0node"))) {
[09:29:19.803]                             sendCondition <<- function(cond) {
[09:29:19.803]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.803]                                 success = TRUE)
[09:29:19.803]                               parallel_sendData(master, data)
[09:29:19.803]                             }
[09:29:19.803]                             return(sendCondition)
[09:29:19.803]                           }
[09:29:19.803]                         }
[09:29:19.803]                         frame <- frame + 1L
[09:29:19.803]                         envir <- sys.frame(frame)
[09:29:19.803]                       }
[09:29:19.803]                     }
[09:29:19.803]                     sendCondition <<- function(cond) NULL
[09:29:19.803]                   }
[09:29:19.803]                 })
[09:29:19.803]                 withCallingHandlers({
[09:29:19.803]                   {
[09:29:19.803]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.803]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.803]                       ...future.globals.maxSize)) {
[09:29:19.803]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.803]                       on.exit(options(oopts), add = TRUE)
[09:29:19.803]                     }
[09:29:19.803]                     {
[09:29:19.803]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.803]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.803]                         USE.NAMES = FALSE)
[09:29:19.803]                       do.call(mapply, args = args)
[09:29:19.803]                     }
[09:29:19.803]                   }
[09:29:19.803]                 }, immediateCondition = function(cond) {
[09:29:19.803]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.803]                   sendCondition(cond)
[09:29:19.803]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.803]                   {
[09:29:19.803]                     inherits <- base::inherits
[09:29:19.803]                     invokeRestart <- base::invokeRestart
[09:29:19.803]                     is.null <- base::is.null
[09:29:19.803]                     muffled <- FALSE
[09:29:19.803]                     if (inherits(cond, "message")) {
[09:29:19.803]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.803]                       if (muffled) 
[09:29:19.803]                         invokeRestart("muffleMessage")
[09:29:19.803]                     }
[09:29:19.803]                     else if (inherits(cond, "warning")) {
[09:29:19.803]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.803]                       if (muffled) 
[09:29:19.803]                         invokeRestart("muffleWarning")
[09:29:19.803]                     }
[09:29:19.803]                     else if (inherits(cond, "condition")) {
[09:29:19.803]                       if (!is.null(pattern)) {
[09:29:19.803]                         computeRestarts <- base::computeRestarts
[09:29:19.803]                         grepl <- base::grepl
[09:29:19.803]                         restarts <- computeRestarts(cond)
[09:29:19.803]                         for (restart in restarts) {
[09:29:19.803]                           name <- restart$name
[09:29:19.803]                           if (is.null(name)) 
[09:29:19.803]                             next
[09:29:19.803]                           if (!grepl(pattern, name)) 
[09:29:19.803]                             next
[09:29:19.803]                           invokeRestart(restart)
[09:29:19.803]                           muffled <- TRUE
[09:29:19.803]                           break
[09:29:19.803]                         }
[09:29:19.803]                       }
[09:29:19.803]                     }
[09:29:19.803]                     invisible(muffled)
[09:29:19.803]                   }
[09:29:19.803]                   muffleCondition(cond)
[09:29:19.803]                 })
[09:29:19.803]             }))
[09:29:19.803]             future::FutureResult(value = ...future.value$value, 
[09:29:19.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.803]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.803]                     ...future.globalenv.names))
[09:29:19.803]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.803]         }, condition = base::local({
[09:29:19.803]             c <- base::c
[09:29:19.803]             inherits <- base::inherits
[09:29:19.803]             invokeRestart <- base::invokeRestart
[09:29:19.803]             length <- base::length
[09:29:19.803]             list <- base::list
[09:29:19.803]             seq.int <- base::seq.int
[09:29:19.803]             signalCondition <- base::signalCondition
[09:29:19.803]             sys.calls <- base::sys.calls
[09:29:19.803]             `[[` <- base::`[[`
[09:29:19.803]             `+` <- base::`+`
[09:29:19.803]             `<<-` <- base::`<<-`
[09:29:19.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.803]                   3L)]
[09:29:19.803]             }
[09:29:19.803]             function(cond) {
[09:29:19.803]                 is_error <- inherits(cond, "error")
[09:29:19.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.803]                   NULL)
[09:29:19.803]                 if (is_error) {
[09:29:19.803]                   sessionInformation <- function() {
[09:29:19.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.803]                       search = base::search(), system = base::Sys.info())
[09:29:19.803]                   }
[09:29:19.803]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.803]                     cond$call), session = sessionInformation(), 
[09:29:19.803]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.803]                   signalCondition(cond)
[09:29:19.803]                 }
[09:29:19.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.803]                 "immediateCondition"))) {
[09:29:19.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.803]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.803]                   if (TRUE && !signal) {
[09:29:19.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.803]                     {
[09:29:19.803]                       inherits <- base::inherits
[09:29:19.803]                       invokeRestart <- base::invokeRestart
[09:29:19.803]                       is.null <- base::is.null
[09:29:19.803]                       muffled <- FALSE
[09:29:19.803]                       if (inherits(cond, "message")) {
[09:29:19.803]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.803]                         if (muffled) 
[09:29:19.803]                           invokeRestart("muffleMessage")
[09:29:19.803]                       }
[09:29:19.803]                       else if (inherits(cond, "warning")) {
[09:29:19.803]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.803]                         if (muffled) 
[09:29:19.803]                           invokeRestart("muffleWarning")
[09:29:19.803]                       }
[09:29:19.803]                       else if (inherits(cond, "condition")) {
[09:29:19.803]                         if (!is.null(pattern)) {
[09:29:19.803]                           computeRestarts <- base::computeRestarts
[09:29:19.803]                           grepl <- base::grepl
[09:29:19.803]                           restarts <- computeRestarts(cond)
[09:29:19.803]                           for (restart in restarts) {
[09:29:19.803]                             name <- restart$name
[09:29:19.803]                             if (is.null(name)) 
[09:29:19.803]                               next
[09:29:19.803]                             if (!grepl(pattern, name)) 
[09:29:19.803]                               next
[09:29:19.803]                             invokeRestart(restart)
[09:29:19.803]                             muffled <- TRUE
[09:29:19.803]                             break
[09:29:19.803]                           }
[09:29:19.803]                         }
[09:29:19.803]                       }
[09:29:19.803]                       invisible(muffled)
[09:29:19.803]                     }
[09:29:19.803]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.803]                   }
[09:29:19.803]                 }
[09:29:19.803]                 else {
[09:29:19.803]                   if (TRUE) {
[09:29:19.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.803]                     {
[09:29:19.803]                       inherits <- base::inherits
[09:29:19.803]                       invokeRestart <- base::invokeRestart
[09:29:19.803]                       is.null <- base::is.null
[09:29:19.803]                       muffled <- FALSE
[09:29:19.803]                       if (inherits(cond, "message")) {
[09:29:19.803]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.803]                         if (muffled) 
[09:29:19.803]                           invokeRestart("muffleMessage")
[09:29:19.803]                       }
[09:29:19.803]                       else if (inherits(cond, "warning")) {
[09:29:19.803]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.803]                         if (muffled) 
[09:29:19.803]                           invokeRestart("muffleWarning")
[09:29:19.803]                       }
[09:29:19.803]                       else if (inherits(cond, "condition")) {
[09:29:19.803]                         if (!is.null(pattern)) {
[09:29:19.803]                           computeRestarts <- base::computeRestarts
[09:29:19.803]                           grepl <- base::grepl
[09:29:19.803]                           restarts <- computeRestarts(cond)
[09:29:19.803]                           for (restart in restarts) {
[09:29:19.803]                             name <- restart$name
[09:29:19.803]                             if (is.null(name)) 
[09:29:19.803]                               next
[09:29:19.803]                             if (!grepl(pattern, name)) 
[09:29:19.803]                               next
[09:29:19.803]                             invokeRestart(restart)
[09:29:19.803]                             muffled <- TRUE
[09:29:19.803]                             break
[09:29:19.803]                           }
[09:29:19.803]                         }
[09:29:19.803]                       }
[09:29:19.803]                       invisible(muffled)
[09:29:19.803]                     }
[09:29:19.803]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.803]                   }
[09:29:19.803]                 }
[09:29:19.803]             }
[09:29:19.803]         }))
[09:29:19.803]     }, error = function(ex) {
[09:29:19.803]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.803]                 ...future.rng), started = ...future.startTime, 
[09:29:19.803]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.803]             version = "1.8"), class = "FutureResult")
[09:29:19.803]     }, finally = {
[09:29:19.803]         if (!identical(...future.workdir, getwd())) 
[09:29:19.803]             setwd(...future.workdir)
[09:29:19.803]         {
[09:29:19.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.803]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.803]             }
[09:29:19.803]             base::options(...future.oldOptions)
[09:29:19.803]             if (.Platform$OS.type == "windows") {
[09:29:19.803]                 old_names <- names(...future.oldEnvVars)
[09:29:19.803]                 envs <- base::Sys.getenv()
[09:29:19.803]                 names <- names(envs)
[09:29:19.803]                 common <- intersect(names, old_names)
[09:29:19.803]                 added <- setdiff(names, old_names)
[09:29:19.803]                 removed <- setdiff(old_names, names)
[09:29:19.803]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.803]                   envs[common]]
[09:29:19.803]                 NAMES <- toupper(changed)
[09:29:19.803]                 args <- list()
[09:29:19.803]                 for (kk in seq_along(NAMES)) {
[09:29:19.803]                   name <- changed[[kk]]
[09:29:19.803]                   NAME <- NAMES[[kk]]
[09:29:19.803]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.803]                     next
[09:29:19.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.803]                 }
[09:29:19.803]                 NAMES <- toupper(added)
[09:29:19.803]                 for (kk in seq_along(NAMES)) {
[09:29:19.803]                   name <- added[[kk]]
[09:29:19.803]                   NAME <- NAMES[[kk]]
[09:29:19.803]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.803]                     next
[09:29:19.803]                   args[[name]] <- ""
[09:29:19.803]                 }
[09:29:19.803]                 NAMES <- toupper(removed)
[09:29:19.803]                 for (kk in seq_along(NAMES)) {
[09:29:19.803]                   name <- removed[[kk]]
[09:29:19.803]                   NAME <- NAMES[[kk]]
[09:29:19.803]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.803]                     next
[09:29:19.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.803]                 }
[09:29:19.803]                 if (length(args) > 0) 
[09:29:19.803]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.803]             }
[09:29:19.803]             else {
[09:29:19.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.803]             }
[09:29:19.803]             {
[09:29:19.803]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.803]                   0L) {
[09:29:19.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.803]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.803]                   base::options(opts)
[09:29:19.803]                 }
[09:29:19.803]                 {
[09:29:19.803]                   {
[09:29:19.803]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.803]                     NULL
[09:29:19.803]                   }
[09:29:19.803]                   options(future.plan = NULL)
[09:29:19.803]                   if (is.na(NA_character_)) 
[09:29:19.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.803]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.803]                     .init = FALSE)
[09:29:19.803]                 }
[09:29:19.803]             }
[09:29:19.803]         }
[09:29:19.803]     })
[09:29:19.803]     if (TRUE) {
[09:29:19.803]         base::sink(type = "output", split = FALSE)
[09:29:19.803]         if (TRUE) {
[09:29:19.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.803]         }
[09:29:19.803]         else {
[09:29:19.803]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.803]         }
[09:29:19.803]         base::close(...future.stdout)
[09:29:19.803]         ...future.stdout <- NULL
[09:29:19.803]     }
[09:29:19.803]     ...future.result$conditions <- ...future.conditions
[09:29:19.803]     ...future.result$finished <- base::Sys.time()
[09:29:19.803]     ...future.result
[09:29:19.803] }
[09:29:19.806] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[09:29:19.806] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[09:29:19.806] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[09:29:19.806] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:19.806] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.807] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[09:29:19.807] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[09:29:19.807] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:19.807] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.807] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:19.808] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.808] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[09:29:19.808] MultisessionFuture started
[09:29:19.808] - Launch lazy future ... done
[09:29:19.808] run() for ‘MultisessionFuture’ ... done
[09:29:19.809] Created future:
[09:29:19.809] MultisessionFuture:
[09:29:19.809] Label: ‘future_.mapply-1’
[09:29:19.809] Expression:
[09:29:19.809] {
[09:29:19.809]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.809]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.809]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.809]         on.exit(options(oopts), add = TRUE)
[09:29:19.809]     }
[09:29:19.809]     {
[09:29:19.809]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.809]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.809]         do.call(mapply, args = args)
[09:29:19.809]     }
[09:29:19.809] }
[09:29:19.809] Lazy evaluation: FALSE
[09:29:19.809] Asynchronous evaluation: TRUE
[09:29:19.809] Local evaluation: TRUE
[09:29:19.809] Environment: R_GlobalEnv
[09:29:19.809] Capture standard output: TRUE
[09:29:19.809] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.809] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.809] Packages: <none>
[09:29:19.809] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.809] Resolved: FALSE
[09:29:19.809] Value: <not collected>
[09:29:19.809] Conditions captured: <none>
[09:29:19.809] Early signaling: FALSE
[09:29:19.809] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.809] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.820] Chunk #1 of 2 ... DONE
[09:29:19.820] Chunk #2 of 2 ...
[09:29:19.820]  - Finding globals in '...' for chunk #2 ...
[09:29:19.820] getGlobalsAndPackages() ...
[09:29:19.820] Searching for globals...
[09:29:19.821] 
[09:29:19.821] Searching for globals ... DONE
[09:29:19.821] - globals: [0] <none>
[09:29:19.821] getGlobalsAndPackages() ... DONE
[09:29:19.821]    + additional globals found: [n=0] 
[09:29:19.821]    + additional namespaces needed: [n=0] 
[09:29:19.821]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:19.822]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:19.822]  - seeds: <none>
[09:29:19.822]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.822] getGlobalsAndPackages() ...
[09:29:19.822] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.822] Resolving globals: FALSE
[09:29:19.822] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[09:29:19.823] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:19.823] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.823] 
[09:29:19.823] getGlobalsAndPackages() ... DONE
[09:29:19.823] run() for ‘Future’ ...
[09:29:19.824] - state: ‘created’
[09:29:19.824] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.837] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.837] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.837]   - Field: ‘node’
[09:29:19.838]   - Field: ‘label’
[09:29:19.838]   - Field: ‘local’
[09:29:19.838]   - Field: ‘owner’
[09:29:19.838]   - Field: ‘envir’
[09:29:19.838]   - Field: ‘workers’
[09:29:19.838]   - Field: ‘packages’
[09:29:19.838]   - Field: ‘gc’
[09:29:19.838]   - Field: ‘conditions’
[09:29:19.838]   - Field: ‘persistent’
[09:29:19.838]   - Field: ‘expr’
[09:29:19.838]   - Field: ‘uuid’
[09:29:19.839]   - Field: ‘seed’
[09:29:19.839]   - Field: ‘version’
[09:29:19.839]   - Field: ‘result’
[09:29:19.839]   - Field: ‘asynchronous’
[09:29:19.839]   - Field: ‘calls’
[09:29:19.839]   - Field: ‘globals’
[09:29:19.839]   - Field: ‘stdout’
[09:29:19.839]   - Field: ‘earlySignal’
[09:29:19.839]   - Field: ‘lazy’
[09:29:19.839]   - Field: ‘state’
[09:29:19.839] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.840] - Launch lazy future ...
[09:29:19.840] Packages needed by the future expression (n = 0): <none>
[09:29:19.840] Packages needed by future strategies (n = 0): <none>
[09:29:19.840] {
[09:29:19.840]     {
[09:29:19.840]         {
[09:29:19.840]             ...future.startTime <- base::Sys.time()
[09:29:19.840]             {
[09:29:19.840]                 {
[09:29:19.840]                   {
[09:29:19.840]                     {
[09:29:19.840]                       base::local({
[09:29:19.840]                         has_future <- base::requireNamespace("future", 
[09:29:19.840]                           quietly = TRUE)
[09:29:19.840]                         if (has_future) {
[09:29:19.840]                           ns <- base::getNamespace("future")
[09:29:19.840]                           version <- ns[[".package"]][["version"]]
[09:29:19.840]                           if (is.null(version)) 
[09:29:19.840]                             version <- utils::packageVersion("future")
[09:29:19.840]                         }
[09:29:19.840]                         else {
[09:29:19.840]                           version <- NULL
[09:29:19.840]                         }
[09:29:19.840]                         if (!has_future || version < "1.8.0") {
[09:29:19.840]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.840]                             "", base::R.version$version.string), 
[09:29:19.840]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.840]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.840]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.840]                               "release", "version")], collapse = " "), 
[09:29:19.840]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.840]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.840]                             info)
[09:29:19.840]                           info <- base::paste(info, collapse = "; ")
[09:29:19.840]                           if (!has_future) {
[09:29:19.840]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.840]                               info)
[09:29:19.840]                           }
[09:29:19.840]                           else {
[09:29:19.840]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.840]                               info, version)
[09:29:19.840]                           }
[09:29:19.840]                           base::stop(msg)
[09:29:19.840]                         }
[09:29:19.840]                       })
[09:29:19.840]                     }
[09:29:19.840]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.840]                     base::options(mc.cores = 1L)
[09:29:19.840]                   }
[09:29:19.840]                   ...future.strategy.old <- future::plan("list")
[09:29:19.840]                   options(future.plan = NULL)
[09:29:19.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.840]                 }
[09:29:19.840]                 ...future.workdir <- getwd()
[09:29:19.840]             }
[09:29:19.840]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.840]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.840]         }
[09:29:19.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.840]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:19.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.840]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.840]             base::names(...future.oldOptions))
[09:29:19.840]     }
[09:29:19.840]     if (FALSE) {
[09:29:19.840]     }
[09:29:19.840]     else {
[09:29:19.840]         if (TRUE) {
[09:29:19.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.840]                 open = "w")
[09:29:19.840]         }
[09:29:19.840]         else {
[09:29:19.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.840]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.840]         }
[09:29:19.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.840]             base::sink(type = "output", split = FALSE)
[09:29:19.840]             base::close(...future.stdout)
[09:29:19.840]         }, add = TRUE)
[09:29:19.840]     }
[09:29:19.840]     ...future.frame <- base::sys.nframe()
[09:29:19.840]     ...future.conditions <- base::list()
[09:29:19.840]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.840]     if (FALSE) {
[09:29:19.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.840]     }
[09:29:19.840]     ...future.result <- base::tryCatch({
[09:29:19.840]         base::withCallingHandlers({
[09:29:19.840]             ...future.value <- base::withVisible(base::local({
[09:29:19.840]                 ...future.makeSendCondition <- base::local({
[09:29:19.840]                   sendCondition <- NULL
[09:29:19.840]                   function(frame = 1L) {
[09:29:19.840]                     if (is.function(sendCondition)) 
[09:29:19.840]                       return(sendCondition)
[09:29:19.840]                     ns <- getNamespace("parallel")
[09:29:19.840]                     if (exists("sendData", mode = "function", 
[09:29:19.840]                       envir = ns)) {
[09:29:19.840]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.840]                         envir = ns)
[09:29:19.840]                       envir <- sys.frame(frame)
[09:29:19.840]                       master <- NULL
[09:29:19.840]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.840]                         !identical(envir, emptyenv())) {
[09:29:19.840]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.840]                           inherits = FALSE)) {
[09:29:19.840]                           master <- get("master", mode = "list", 
[09:29:19.840]                             envir = envir, inherits = FALSE)
[09:29:19.840]                           if (inherits(master, c("SOCKnode", 
[09:29:19.840]                             "SOCK0node"))) {
[09:29:19.840]                             sendCondition <<- function(cond) {
[09:29:19.840]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.840]                                 success = TRUE)
[09:29:19.840]                               parallel_sendData(master, data)
[09:29:19.840]                             }
[09:29:19.840]                             return(sendCondition)
[09:29:19.840]                           }
[09:29:19.840]                         }
[09:29:19.840]                         frame <- frame + 1L
[09:29:19.840]                         envir <- sys.frame(frame)
[09:29:19.840]                       }
[09:29:19.840]                     }
[09:29:19.840]                     sendCondition <<- function(cond) NULL
[09:29:19.840]                   }
[09:29:19.840]                 })
[09:29:19.840]                 withCallingHandlers({
[09:29:19.840]                   {
[09:29:19.840]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.840]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.840]                       ...future.globals.maxSize)) {
[09:29:19.840]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.840]                       on.exit(options(oopts), add = TRUE)
[09:29:19.840]                     }
[09:29:19.840]                     {
[09:29:19.840]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.840]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.840]                         USE.NAMES = FALSE)
[09:29:19.840]                       do.call(mapply, args = args)
[09:29:19.840]                     }
[09:29:19.840]                   }
[09:29:19.840]                 }, immediateCondition = function(cond) {
[09:29:19.840]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.840]                   sendCondition(cond)
[09:29:19.840]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.840]                   {
[09:29:19.840]                     inherits <- base::inherits
[09:29:19.840]                     invokeRestart <- base::invokeRestart
[09:29:19.840]                     is.null <- base::is.null
[09:29:19.840]                     muffled <- FALSE
[09:29:19.840]                     if (inherits(cond, "message")) {
[09:29:19.840]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.840]                       if (muffled) 
[09:29:19.840]                         invokeRestart("muffleMessage")
[09:29:19.840]                     }
[09:29:19.840]                     else if (inherits(cond, "warning")) {
[09:29:19.840]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.840]                       if (muffled) 
[09:29:19.840]                         invokeRestart("muffleWarning")
[09:29:19.840]                     }
[09:29:19.840]                     else if (inherits(cond, "condition")) {
[09:29:19.840]                       if (!is.null(pattern)) {
[09:29:19.840]                         computeRestarts <- base::computeRestarts
[09:29:19.840]                         grepl <- base::grepl
[09:29:19.840]                         restarts <- computeRestarts(cond)
[09:29:19.840]                         for (restart in restarts) {
[09:29:19.840]                           name <- restart$name
[09:29:19.840]                           if (is.null(name)) 
[09:29:19.840]                             next
[09:29:19.840]                           if (!grepl(pattern, name)) 
[09:29:19.840]                             next
[09:29:19.840]                           invokeRestart(restart)
[09:29:19.840]                           muffled <- TRUE
[09:29:19.840]                           break
[09:29:19.840]                         }
[09:29:19.840]                       }
[09:29:19.840]                     }
[09:29:19.840]                     invisible(muffled)
[09:29:19.840]                   }
[09:29:19.840]                   muffleCondition(cond)
[09:29:19.840]                 })
[09:29:19.840]             }))
[09:29:19.840]             future::FutureResult(value = ...future.value$value, 
[09:29:19.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.840]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.840]                     ...future.globalenv.names))
[09:29:19.840]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.840]         }, condition = base::local({
[09:29:19.840]             c <- base::c
[09:29:19.840]             inherits <- base::inherits
[09:29:19.840]             invokeRestart <- base::invokeRestart
[09:29:19.840]             length <- base::length
[09:29:19.840]             list <- base::list
[09:29:19.840]             seq.int <- base::seq.int
[09:29:19.840]             signalCondition <- base::signalCondition
[09:29:19.840]             sys.calls <- base::sys.calls
[09:29:19.840]             `[[` <- base::`[[`
[09:29:19.840]             `+` <- base::`+`
[09:29:19.840]             `<<-` <- base::`<<-`
[09:29:19.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.840]                   3L)]
[09:29:19.840]             }
[09:29:19.840]             function(cond) {
[09:29:19.840]                 is_error <- inherits(cond, "error")
[09:29:19.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.840]                   NULL)
[09:29:19.840]                 if (is_error) {
[09:29:19.840]                   sessionInformation <- function() {
[09:29:19.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.840]                       search = base::search(), system = base::Sys.info())
[09:29:19.840]                   }
[09:29:19.840]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.840]                     cond$call), session = sessionInformation(), 
[09:29:19.840]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.840]                   signalCondition(cond)
[09:29:19.840]                 }
[09:29:19.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.840]                 "immediateCondition"))) {
[09:29:19.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.840]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.840]                   if (TRUE && !signal) {
[09:29:19.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.840]                     {
[09:29:19.840]                       inherits <- base::inherits
[09:29:19.840]                       invokeRestart <- base::invokeRestart
[09:29:19.840]                       is.null <- base::is.null
[09:29:19.840]                       muffled <- FALSE
[09:29:19.840]                       if (inherits(cond, "message")) {
[09:29:19.840]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.840]                         if (muffled) 
[09:29:19.840]                           invokeRestart("muffleMessage")
[09:29:19.840]                       }
[09:29:19.840]                       else if (inherits(cond, "warning")) {
[09:29:19.840]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.840]                         if (muffled) 
[09:29:19.840]                           invokeRestart("muffleWarning")
[09:29:19.840]                       }
[09:29:19.840]                       else if (inherits(cond, "condition")) {
[09:29:19.840]                         if (!is.null(pattern)) {
[09:29:19.840]                           computeRestarts <- base::computeRestarts
[09:29:19.840]                           grepl <- base::grepl
[09:29:19.840]                           restarts <- computeRestarts(cond)
[09:29:19.840]                           for (restart in restarts) {
[09:29:19.840]                             name <- restart$name
[09:29:19.840]                             if (is.null(name)) 
[09:29:19.840]                               next
[09:29:19.840]                             if (!grepl(pattern, name)) 
[09:29:19.840]                               next
[09:29:19.840]                             invokeRestart(restart)
[09:29:19.840]                             muffled <- TRUE
[09:29:19.840]                             break
[09:29:19.840]                           }
[09:29:19.840]                         }
[09:29:19.840]                       }
[09:29:19.840]                       invisible(muffled)
[09:29:19.840]                     }
[09:29:19.840]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.840]                   }
[09:29:19.840]                 }
[09:29:19.840]                 else {
[09:29:19.840]                   if (TRUE) {
[09:29:19.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.840]                     {
[09:29:19.840]                       inherits <- base::inherits
[09:29:19.840]                       invokeRestart <- base::invokeRestart
[09:29:19.840]                       is.null <- base::is.null
[09:29:19.840]                       muffled <- FALSE
[09:29:19.840]                       if (inherits(cond, "message")) {
[09:29:19.840]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.840]                         if (muffled) 
[09:29:19.840]                           invokeRestart("muffleMessage")
[09:29:19.840]                       }
[09:29:19.840]                       else if (inherits(cond, "warning")) {
[09:29:19.840]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.840]                         if (muffled) 
[09:29:19.840]                           invokeRestart("muffleWarning")
[09:29:19.840]                       }
[09:29:19.840]                       else if (inherits(cond, "condition")) {
[09:29:19.840]                         if (!is.null(pattern)) {
[09:29:19.840]                           computeRestarts <- base::computeRestarts
[09:29:19.840]                           grepl <- base::grepl
[09:29:19.840]                           restarts <- computeRestarts(cond)
[09:29:19.840]                           for (restart in restarts) {
[09:29:19.840]                             name <- restart$name
[09:29:19.840]                             if (is.null(name)) 
[09:29:19.840]                               next
[09:29:19.840]                             if (!grepl(pattern, name)) 
[09:29:19.840]                               next
[09:29:19.840]                             invokeRestart(restart)
[09:29:19.840]                             muffled <- TRUE
[09:29:19.840]                             break
[09:29:19.840]                           }
[09:29:19.840]                         }
[09:29:19.840]                       }
[09:29:19.840]                       invisible(muffled)
[09:29:19.840]                     }
[09:29:19.840]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.840]                   }
[09:29:19.840]                 }
[09:29:19.840]             }
[09:29:19.840]         }))
[09:29:19.840]     }, error = function(ex) {
[09:29:19.840]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.840]                 ...future.rng), started = ...future.startTime, 
[09:29:19.840]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.840]             version = "1.8"), class = "FutureResult")
[09:29:19.840]     }, finally = {
[09:29:19.840]         if (!identical(...future.workdir, getwd())) 
[09:29:19.840]             setwd(...future.workdir)
[09:29:19.840]         {
[09:29:19.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.840]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.840]             }
[09:29:19.840]             base::options(...future.oldOptions)
[09:29:19.840]             if (.Platform$OS.type == "windows") {
[09:29:19.840]                 old_names <- names(...future.oldEnvVars)
[09:29:19.840]                 envs <- base::Sys.getenv()
[09:29:19.840]                 names <- names(envs)
[09:29:19.840]                 common <- intersect(names, old_names)
[09:29:19.840]                 added <- setdiff(names, old_names)
[09:29:19.840]                 removed <- setdiff(old_names, names)
[09:29:19.840]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.840]                   envs[common]]
[09:29:19.840]                 NAMES <- toupper(changed)
[09:29:19.840]                 args <- list()
[09:29:19.840]                 for (kk in seq_along(NAMES)) {
[09:29:19.840]                   name <- changed[[kk]]
[09:29:19.840]                   NAME <- NAMES[[kk]]
[09:29:19.840]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.840]                     next
[09:29:19.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.840]                 }
[09:29:19.840]                 NAMES <- toupper(added)
[09:29:19.840]                 for (kk in seq_along(NAMES)) {
[09:29:19.840]                   name <- added[[kk]]
[09:29:19.840]                   NAME <- NAMES[[kk]]
[09:29:19.840]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.840]                     next
[09:29:19.840]                   args[[name]] <- ""
[09:29:19.840]                 }
[09:29:19.840]                 NAMES <- toupper(removed)
[09:29:19.840]                 for (kk in seq_along(NAMES)) {
[09:29:19.840]                   name <- removed[[kk]]
[09:29:19.840]                   NAME <- NAMES[[kk]]
[09:29:19.840]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.840]                     next
[09:29:19.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.840]                 }
[09:29:19.840]                 if (length(args) > 0) 
[09:29:19.840]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.840]             }
[09:29:19.840]             else {
[09:29:19.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.840]             }
[09:29:19.840]             {
[09:29:19.840]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.840]                   0L) {
[09:29:19.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.840]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.840]                   base::options(opts)
[09:29:19.840]                 }
[09:29:19.840]                 {
[09:29:19.840]                   {
[09:29:19.840]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.840]                     NULL
[09:29:19.840]                   }
[09:29:19.840]                   options(future.plan = NULL)
[09:29:19.840]                   if (is.na(NA_character_)) 
[09:29:19.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.840]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.840]                     .init = FALSE)
[09:29:19.840]                 }
[09:29:19.840]             }
[09:29:19.840]         }
[09:29:19.840]     })
[09:29:19.840]     if (TRUE) {
[09:29:19.840]         base::sink(type = "output", split = FALSE)
[09:29:19.840]         if (TRUE) {
[09:29:19.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.840]         }
[09:29:19.840]         else {
[09:29:19.840]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.840]         }
[09:29:19.840]         base::close(...future.stdout)
[09:29:19.840]         ...future.stdout <- NULL
[09:29:19.840]     }
[09:29:19.840]     ...future.result$conditions <- ...future.conditions
[09:29:19.840]     ...future.result$finished <- base::Sys.time()
[09:29:19.840]     ...future.result
[09:29:19.840] }
[09:29:19.843] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[09:29:19.843] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[09:29:19.843] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[09:29:19.844] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:19.844] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.844] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[09:29:19.844] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[09:29:19.845] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:19.845] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.845] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:19.845] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.845] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[09:29:19.846] MultisessionFuture started
[09:29:19.846] - Launch lazy future ... done
[09:29:19.846] run() for ‘MultisessionFuture’ ... done
[09:29:19.846] Created future:
[09:29:19.847] MultisessionFuture:
[09:29:19.847] Label: ‘future_.mapply-2’
[09:29:19.847] Expression:
[09:29:19.847] {
[09:29:19.847]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.847]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.847]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.847]         on.exit(options(oopts), add = TRUE)
[09:29:19.847]     }
[09:29:19.847]     {
[09:29:19.847]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.847]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.847]         do.call(mapply, args = args)
[09:29:19.847]     }
[09:29:19.847] }
[09:29:19.847] Lazy evaluation: FALSE
[09:29:19.847] Asynchronous evaluation: TRUE
[09:29:19.847] Local evaluation: TRUE
[09:29:19.847] Environment: R_GlobalEnv
[09:29:19.847] Capture standard output: TRUE
[09:29:19.847] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.847] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.847] Packages: <none>
[09:29:19.847] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.847] Resolved: FALSE
[09:29:19.847] Value: <not collected>
[09:29:19.847] Conditions captured: <none>
[09:29:19.847] Early signaling: FALSE
[09:29:19.847] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.847] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.858] Chunk #2 of 2 ... DONE
[09:29:19.858] Launching 2 futures (chunks) ... DONE
[09:29:19.858] Resolving 2 futures (chunks) ...
[09:29:19.858] resolve() on list ...
[09:29:19.858]  recursive: 0
[09:29:19.858]  length: 2
[09:29:19.858] 
[09:29:19.859] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.859] - Validating connection of MultisessionFuture
[09:29:19.859] - received message: FutureResult
[09:29:19.859] - Received FutureResult
[09:29:19.859] - Erased future from FutureRegistry
[09:29:19.859] result() for ClusterFuture ...
[09:29:19.859] - result already collected: FutureResult
[09:29:19.860] result() for ClusterFuture ... done
[09:29:19.860] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.860] Future #1
[09:29:19.860] result() for ClusterFuture ...
[09:29:19.860] - result already collected: FutureResult
[09:29:19.860] result() for ClusterFuture ... done
[09:29:19.860] result() for ClusterFuture ...
[09:29:19.860] - result already collected: FutureResult
[09:29:19.860] result() for ClusterFuture ... done
[09:29:19.860] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:19.860] - nx: 2
[09:29:19.861] - relay: TRUE
[09:29:19.861] - stdout: TRUE
[09:29:19.861] - signal: TRUE
[09:29:19.861] - resignal: FALSE
[09:29:19.861] - force: TRUE
[09:29:19.861] - relayed: [n=2] FALSE, FALSE
[09:29:19.861] - queued futures: [n=2] FALSE, FALSE
[09:29:19.861]  - until=1
[09:29:19.861]  - relaying element #1
[09:29:19.861] result() for ClusterFuture ...
[09:29:19.861] - result already collected: FutureResult
[09:29:19.861] result() for ClusterFuture ... done
[09:29:19.862] result() for ClusterFuture ...
[09:29:19.862] - result already collected: FutureResult
[09:29:19.862] result() for ClusterFuture ... done
[09:29:19.862] result() for ClusterFuture ...
[09:29:19.862] - result already collected: FutureResult
[09:29:19.862] result() for ClusterFuture ... done
[09:29:19.862] result() for ClusterFuture ...
[09:29:19.862] - result already collected: FutureResult
[09:29:19.862] result() for ClusterFuture ... done
[09:29:19.862] - relayed: [n=2] TRUE, FALSE
[09:29:19.862] - queued futures: [n=2] TRUE, FALSE
[09:29:19.862] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:19.863]  length: 1 (resolved future 1)
[09:29:19.889] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.889] - Validating connection of MultisessionFuture
[09:29:19.889] - received message: FutureResult
[09:29:19.890] - Received FutureResult
[09:29:19.890] - Erased future from FutureRegistry
[09:29:19.890] result() for ClusterFuture ...
[09:29:19.890] - result already collected: FutureResult
[09:29:19.890] result() for ClusterFuture ... done
[09:29:19.890] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.890] Future #2
[09:29:19.890] result() for ClusterFuture ...
[09:29:19.890] - result already collected: FutureResult
[09:29:19.890] result() for ClusterFuture ... done
[09:29:19.891] result() for ClusterFuture ...
[09:29:19.891] - result already collected: FutureResult
[09:29:19.891] result() for ClusterFuture ... done
[09:29:19.891] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:19.891] - nx: 2
[09:29:19.891] - relay: TRUE
[09:29:19.891] - stdout: TRUE
[09:29:19.891] - signal: TRUE
[09:29:19.891] - resignal: FALSE
[09:29:19.891] - force: TRUE
[09:29:19.891] - relayed: [n=2] TRUE, FALSE
[09:29:19.891] - queued futures: [n=2] TRUE, FALSE
[09:29:19.892]  - until=2
[09:29:19.892]  - relaying element #2
[09:29:19.892] result() for ClusterFuture ...
[09:29:19.892] - result already collected: FutureResult
[09:29:19.892] result() for ClusterFuture ... done
[09:29:19.892] result() for ClusterFuture ...
[09:29:19.892] - result already collected: FutureResult
[09:29:19.892] result() for ClusterFuture ... done
[09:29:19.892] result() for ClusterFuture ...
[09:29:19.892] - result already collected: FutureResult
[09:29:19.892] result() for ClusterFuture ... done
[09:29:19.893] result() for ClusterFuture ...
[09:29:19.893] - result already collected: FutureResult
[09:29:19.893] result() for ClusterFuture ... done
[09:29:19.893] - relayed: [n=2] TRUE, TRUE
[09:29:19.893] - queued futures: [n=2] TRUE, TRUE
[09:29:19.893] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:19.893]  length: 0 (resolved future 2)
[09:29:19.893] Relaying remaining futures
[09:29:19.893] signalConditionsASAP(NULL, pos=0) ...
[09:29:19.893] - nx: 2
[09:29:19.893] - relay: TRUE
[09:29:19.893] - stdout: TRUE
[09:29:19.894] - signal: TRUE
[09:29:19.894] - resignal: FALSE
[09:29:19.894] - force: TRUE
[09:29:19.894] - relayed: [n=2] TRUE, TRUE
[09:29:19.894] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:19.894] - relayed: [n=2] TRUE, TRUE
[09:29:19.894] - queued futures: [n=2] TRUE, TRUE
[09:29:19.894] signalConditionsASAP(NULL, pos=0) ... done
[09:29:19.894] resolve() on list ... DONE
[09:29:19.894] result() for ClusterFuture ...
[09:29:19.894] - result already collected: FutureResult
[09:29:19.894] result() for ClusterFuture ... done
[09:29:19.895] result() for ClusterFuture ...
[09:29:19.895] - result already collected: FutureResult
[09:29:19.895] result() for ClusterFuture ... done
[09:29:19.895] result() for ClusterFuture ...
[09:29:19.895] - result already collected: FutureResult
[09:29:19.895] result() for ClusterFuture ... done
[09:29:19.895] result() for ClusterFuture ...
[09:29:19.895] - result already collected: FutureResult
[09:29:19.895] result() for ClusterFuture ... done
[09:29:19.895]  - Number of value chunks collected: 2
[09:29:19.895] Resolving 2 futures (chunks) ... DONE
[09:29:19.896] Reducing values from 2 chunks ...
[09:29:19.896]  - Number of values collected after concatenation: 5
[09:29:19.896]  - Number of values expected: 5
[09:29:19.896] Reducing values from 2 chunks ... DONE
[09:29:19.896] future_mapply() ... DONE
[09:29:19.896] future_mapply() ...
[09:29:19.899] Number of chunks: 2
[09:29:19.900] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[09:29:19.900] getGlobalsAndPackagesXApply() ...
[09:29:19.900]  - future.globals: TRUE
[09:29:19.900] getGlobalsAndPackages() ...
[09:29:19.900] Searching for globals...
[09:29:19.901] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:19.901] Searching for globals ... DONE
[09:29:19.901] Resolving globals: FALSE
[09:29:19.902] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:19.902] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:19.902] - globals: [1] ‘FUN’
[09:29:19.902] 
[09:29:19.902] getGlobalsAndPackages() ... DONE
[09:29:19.902]  - globals found/used: [n=1] ‘FUN’
[09:29:19.903]  - needed namespaces: [n=0] 
[09:29:19.903] Finding globals ... DONE
[09:29:19.903] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:19.903] List of 2
[09:29:19.903]  $ ...future.FUN:function (C, k)  
[09:29:19.903]  $ MoreArgs     : NULL
[09:29:19.903]  - attr(*, "where")=List of 2
[09:29:19.903]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:19.903]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:19.903]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:19.903]  - attr(*, "resolved")= logi FALSE
[09:29:19.903]  - attr(*, "total_size")= num NA
[09:29:19.905] Packages to be attached in all futures: [n=0] 
[09:29:19.905] getGlobalsAndPackagesXApply() ... DONE
[09:29:19.906] Number of futures (= number of chunks): 2
[09:29:19.908] Launching 2 futures (chunks) ...
[09:29:19.908] Chunk #1 of 2 ...
[09:29:19.908]  - Finding globals in '...' for chunk #1 ...
[09:29:19.908] getGlobalsAndPackages() ...
[09:29:19.908] Searching for globals...
[09:29:19.909] 
[09:29:19.909] Searching for globals ... DONE
[09:29:19.909] - globals: [0] <none>
[09:29:19.909] getGlobalsAndPackages() ... DONE
[09:29:19.909]    + additional globals found: [n=0] 
[09:29:19.909]    + additional namespaces needed: [n=0] 
[09:29:19.909]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:19.909]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:19.910]  - seeds: <none>
[09:29:19.910]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.910] getGlobalsAndPackages() ...
[09:29:19.910] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.910] Resolving globals: FALSE
[09:29:19.910] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:19.911] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:19.911] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.911] 
[09:29:19.911] getGlobalsAndPackages() ... DONE
[09:29:19.911] run() for ‘Future’ ...
[09:29:19.911] - state: ‘created’
[09:29:19.912] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.927] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.927] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.927]   - Field: ‘node’
[09:29:19.927]   - Field: ‘label’
[09:29:19.927]   - Field: ‘local’
[09:29:19.927]   - Field: ‘owner’
[09:29:19.927]   - Field: ‘envir’
[09:29:19.927]   - Field: ‘workers’
[09:29:19.927]   - Field: ‘packages’
[09:29:19.927]   - Field: ‘gc’
[09:29:19.928]   - Field: ‘conditions’
[09:29:19.928]   - Field: ‘persistent’
[09:29:19.928]   - Field: ‘expr’
[09:29:19.928]   - Field: ‘uuid’
[09:29:19.928]   - Field: ‘seed’
[09:29:19.928]   - Field: ‘version’
[09:29:19.928]   - Field: ‘result’
[09:29:19.928]   - Field: ‘asynchronous’
[09:29:19.928]   - Field: ‘calls’
[09:29:19.928]   - Field: ‘globals’
[09:29:19.928]   - Field: ‘stdout’
[09:29:19.928]   - Field: ‘earlySignal’
[09:29:19.929]   - Field: ‘lazy’
[09:29:19.929]   - Field: ‘state’
[09:29:19.929] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.929] - Launch lazy future ...
[09:29:19.929] Packages needed by the future expression (n = 0): <none>
[09:29:19.929] Packages needed by future strategies (n = 0): <none>
[09:29:19.930] {
[09:29:19.930]     {
[09:29:19.930]         {
[09:29:19.930]             ...future.startTime <- base::Sys.time()
[09:29:19.930]             {
[09:29:19.930]                 {
[09:29:19.930]                   {
[09:29:19.930]                     {
[09:29:19.930]                       base::local({
[09:29:19.930]                         has_future <- base::requireNamespace("future", 
[09:29:19.930]                           quietly = TRUE)
[09:29:19.930]                         if (has_future) {
[09:29:19.930]                           ns <- base::getNamespace("future")
[09:29:19.930]                           version <- ns[[".package"]][["version"]]
[09:29:19.930]                           if (is.null(version)) 
[09:29:19.930]                             version <- utils::packageVersion("future")
[09:29:19.930]                         }
[09:29:19.930]                         else {
[09:29:19.930]                           version <- NULL
[09:29:19.930]                         }
[09:29:19.930]                         if (!has_future || version < "1.8.0") {
[09:29:19.930]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.930]                             "", base::R.version$version.string), 
[09:29:19.930]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.930]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.930]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.930]                               "release", "version")], collapse = " "), 
[09:29:19.930]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.930]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.930]                             info)
[09:29:19.930]                           info <- base::paste(info, collapse = "; ")
[09:29:19.930]                           if (!has_future) {
[09:29:19.930]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.930]                               info)
[09:29:19.930]                           }
[09:29:19.930]                           else {
[09:29:19.930]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.930]                               info, version)
[09:29:19.930]                           }
[09:29:19.930]                           base::stop(msg)
[09:29:19.930]                         }
[09:29:19.930]                       })
[09:29:19.930]                     }
[09:29:19.930]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.930]                     base::options(mc.cores = 1L)
[09:29:19.930]                   }
[09:29:19.930]                   ...future.strategy.old <- future::plan("list")
[09:29:19.930]                   options(future.plan = NULL)
[09:29:19.930]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.930]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.930]                 }
[09:29:19.930]                 ...future.workdir <- getwd()
[09:29:19.930]             }
[09:29:19.930]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.930]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.930]         }
[09:29:19.930]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.930]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:19.930]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.930]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.930]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.930]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.930]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.930]             base::names(...future.oldOptions))
[09:29:19.930]     }
[09:29:19.930]     if (FALSE) {
[09:29:19.930]     }
[09:29:19.930]     else {
[09:29:19.930]         if (TRUE) {
[09:29:19.930]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.930]                 open = "w")
[09:29:19.930]         }
[09:29:19.930]         else {
[09:29:19.930]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.930]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.930]         }
[09:29:19.930]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.930]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.930]             base::sink(type = "output", split = FALSE)
[09:29:19.930]             base::close(...future.stdout)
[09:29:19.930]         }, add = TRUE)
[09:29:19.930]     }
[09:29:19.930]     ...future.frame <- base::sys.nframe()
[09:29:19.930]     ...future.conditions <- base::list()
[09:29:19.930]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.930]     if (FALSE) {
[09:29:19.930]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.930]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.930]     }
[09:29:19.930]     ...future.result <- base::tryCatch({
[09:29:19.930]         base::withCallingHandlers({
[09:29:19.930]             ...future.value <- base::withVisible(base::local({
[09:29:19.930]                 ...future.makeSendCondition <- base::local({
[09:29:19.930]                   sendCondition <- NULL
[09:29:19.930]                   function(frame = 1L) {
[09:29:19.930]                     if (is.function(sendCondition)) 
[09:29:19.930]                       return(sendCondition)
[09:29:19.930]                     ns <- getNamespace("parallel")
[09:29:19.930]                     if (exists("sendData", mode = "function", 
[09:29:19.930]                       envir = ns)) {
[09:29:19.930]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.930]                         envir = ns)
[09:29:19.930]                       envir <- sys.frame(frame)
[09:29:19.930]                       master <- NULL
[09:29:19.930]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.930]                         !identical(envir, emptyenv())) {
[09:29:19.930]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.930]                           inherits = FALSE)) {
[09:29:19.930]                           master <- get("master", mode = "list", 
[09:29:19.930]                             envir = envir, inherits = FALSE)
[09:29:19.930]                           if (inherits(master, c("SOCKnode", 
[09:29:19.930]                             "SOCK0node"))) {
[09:29:19.930]                             sendCondition <<- function(cond) {
[09:29:19.930]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.930]                                 success = TRUE)
[09:29:19.930]                               parallel_sendData(master, data)
[09:29:19.930]                             }
[09:29:19.930]                             return(sendCondition)
[09:29:19.930]                           }
[09:29:19.930]                         }
[09:29:19.930]                         frame <- frame + 1L
[09:29:19.930]                         envir <- sys.frame(frame)
[09:29:19.930]                       }
[09:29:19.930]                     }
[09:29:19.930]                     sendCondition <<- function(cond) NULL
[09:29:19.930]                   }
[09:29:19.930]                 })
[09:29:19.930]                 withCallingHandlers({
[09:29:19.930]                   {
[09:29:19.930]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.930]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.930]                       ...future.globals.maxSize)) {
[09:29:19.930]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.930]                       on.exit(options(oopts), add = TRUE)
[09:29:19.930]                     }
[09:29:19.930]                     {
[09:29:19.930]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.930]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.930]                         USE.NAMES = FALSE)
[09:29:19.930]                       do.call(mapply, args = args)
[09:29:19.930]                     }
[09:29:19.930]                   }
[09:29:19.930]                 }, immediateCondition = function(cond) {
[09:29:19.930]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.930]                   sendCondition(cond)
[09:29:19.930]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.930]                   {
[09:29:19.930]                     inherits <- base::inherits
[09:29:19.930]                     invokeRestart <- base::invokeRestart
[09:29:19.930]                     is.null <- base::is.null
[09:29:19.930]                     muffled <- FALSE
[09:29:19.930]                     if (inherits(cond, "message")) {
[09:29:19.930]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.930]                       if (muffled) 
[09:29:19.930]                         invokeRestart("muffleMessage")
[09:29:19.930]                     }
[09:29:19.930]                     else if (inherits(cond, "warning")) {
[09:29:19.930]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.930]                       if (muffled) 
[09:29:19.930]                         invokeRestart("muffleWarning")
[09:29:19.930]                     }
[09:29:19.930]                     else if (inherits(cond, "condition")) {
[09:29:19.930]                       if (!is.null(pattern)) {
[09:29:19.930]                         computeRestarts <- base::computeRestarts
[09:29:19.930]                         grepl <- base::grepl
[09:29:19.930]                         restarts <- computeRestarts(cond)
[09:29:19.930]                         for (restart in restarts) {
[09:29:19.930]                           name <- restart$name
[09:29:19.930]                           if (is.null(name)) 
[09:29:19.930]                             next
[09:29:19.930]                           if (!grepl(pattern, name)) 
[09:29:19.930]                             next
[09:29:19.930]                           invokeRestart(restart)
[09:29:19.930]                           muffled <- TRUE
[09:29:19.930]                           break
[09:29:19.930]                         }
[09:29:19.930]                       }
[09:29:19.930]                     }
[09:29:19.930]                     invisible(muffled)
[09:29:19.930]                   }
[09:29:19.930]                   muffleCondition(cond)
[09:29:19.930]                 })
[09:29:19.930]             }))
[09:29:19.930]             future::FutureResult(value = ...future.value$value, 
[09:29:19.930]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.930]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.930]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.930]                     ...future.globalenv.names))
[09:29:19.930]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.930]         }, condition = base::local({
[09:29:19.930]             c <- base::c
[09:29:19.930]             inherits <- base::inherits
[09:29:19.930]             invokeRestart <- base::invokeRestart
[09:29:19.930]             length <- base::length
[09:29:19.930]             list <- base::list
[09:29:19.930]             seq.int <- base::seq.int
[09:29:19.930]             signalCondition <- base::signalCondition
[09:29:19.930]             sys.calls <- base::sys.calls
[09:29:19.930]             `[[` <- base::`[[`
[09:29:19.930]             `+` <- base::`+`
[09:29:19.930]             `<<-` <- base::`<<-`
[09:29:19.930]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.930]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.930]                   3L)]
[09:29:19.930]             }
[09:29:19.930]             function(cond) {
[09:29:19.930]                 is_error <- inherits(cond, "error")
[09:29:19.930]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.930]                   NULL)
[09:29:19.930]                 if (is_error) {
[09:29:19.930]                   sessionInformation <- function() {
[09:29:19.930]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.930]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.930]                       search = base::search(), system = base::Sys.info())
[09:29:19.930]                   }
[09:29:19.930]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.930]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.930]                     cond$call), session = sessionInformation(), 
[09:29:19.930]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.930]                   signalCondition(cond)
[09:29:19.930]                 }
[09:29:19.930]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.930]                 "immediateCondition"))) {
[09:29:19.930]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.930]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.930]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.930]                   if (TRUE && !signal) {
[09:29:19.930]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.930]                     {
[09:29:19.930]                       inherits <- base::inherits
[09:29:19.930]                       invokeRestart <- base::invokeRestart
[09:29:19.930]                       is.null <- base::is.null
[09:29:19.930]                       muffled <- FALSE
[09:29:19.930]                       if (inherits(cond, "message")) {
[09:29:19.930]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.930]                         if (muffled) 
[09:29:19.930]                           invokeRestart("muffleMessage")
[09:29:19.930]                       }
[09:29:19.930]                       else if (inherits(cond, "warning")) {
[09:29:19.930]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.930]                         if (muffled) 
[09:29:19.930]                           invokeRestart("muffleWarning")
[09:29:19.930]                       }
[09:29:19.930]                       else if (inherits(cond, "condition")) {
[09:29:19.930]                         if (!is.null(pattern)) {
[09:29:19.930]                           computeRestarts <- base::computeRestarts
[09:29:19.930]                           grepl <- base::grepl
[09:29:19.930]                           restarts <- computeRestarts(cond)
[09:29:19.930]                           for (restart in restarts) {
[09:29:19.930]                             name <- restart$name
[09:29:19.930]                             if (is.null(name)) 
[09:29:19.930]                               next
[09:29:19.930]                             if (!grepl(pattern, name)) 
[09:29:19.930]                               next
[09:29:19.930]                             invokeRestart(restart)
[09:29:19.930]                             muffled <- TRUE
[09:29:19.930]                             break
[09:29:19.930]                           }
[09:29:19.930]                         }
[09:29:19.930]                       }
[09:29:19.930]                       invisible(muffled)
[09:29:19.930]                     }
[09:29:19.930]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.930]                   }
[09:29:19.930]                 }
[09:29:19.930]                 else {
[09:29:19.930]                   if (TRUE) {
[09:29:19.930]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.930]                     {
[09:29:19.930]                       inherits <- base::inherits
[09:29:19.930]                       invokeRestart <- base::invokeRestart
[09:29:19.930]                       is.null <- base::is.null
[09:29:19.930]                       muffled <- FALSE
[09:29:19.930]                       if (inherits(cond, "message")) {
[09:29:19.930]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.930]                         if (muffled) 
[09:29:19.930]                           invokeRestart("muffleMessage")
[09:29:19.930]                       }
[09:29:19.930]                       else if (inherits(cond, "warning")) {
[09:29:19.930]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.930]                         if (muffled) 
[09:29:19.930]                           invokeRestart("muffleWarning")
[09:29:19.930]                       }
[09:29:19.930]                       else if (inherits(cond, "condition")) {
[09:29:19.930]                         if (!is.null(pattern)) {
[09:29:19.930]                           computeRestarts <- base::computeRestarts
[09:29:19.930]                           grepl <- base::grepl
[09:29:19.930]                           restarts <- computeRestarts(cond)
[09:29:19.930]                           for (restart in restarts) {
[09:29:19.930]                             name <- restart$name
[09:29:19.930]                             if (is.null(name)) 
[09:29:19.930]                               next
[09:29:19.930]                             if (!grepl(pattern, name)) 
[09:29:19.930]                               next
[09:29:19.930]                             invokeRestart(restart)
[09:29:19.930]                             muffled <- TRUE
[09:29:19.930]                             break
[09:29:19.930]                           }
[09:29:19.930]                         }
[09:29:19.930]                       }
[09:29:19.930]                       invisible(muffled)
[09:29:19.930]                     }
[09:29:19.930]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.930]                   }
[09:29:19.930]                 }
[09:29:19.930]             }
[09:29:19.930]         }))
[09:29:19.930]     }, error = function(ex) {
[09:29:19.930]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.930]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.930]                 ...future.rng), started = ...future.startTime, 
[09:29:19.930]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.930]             version = "1.8"), class = "FutureResult")
[09:29:19.930]     }, finally = {
[09:29:19.930]         if (!identical(...future.workdir, getwd())) 
[09:29:19.930]             setwd(...future.workdir)
[09:29:19.930]         {
[09:29:19.930]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.930]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.930]             }
[09:29:19.930]             base::options(...future.oldOptions)
[09:29:19.930]             if (.Platform$OS.type == "windows") {
[09:29:19.930]                 old_names <- names(...future.oldEnvVars)
[09:29:19.930]                 envs <- base::Sys.getenv()
[09:29:19.930]                 names <- names(envs)
[09:29:19.930]                 common <- intersect(names, old_names)
[09:29:19.930]                 added <- setdiff(names, old_names)
[09:29:19.930]                 removed <- setdiff(old_names, names)
[09:29:19.930]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.930]                   envs[common]]
[09:29:19.930]                 NAMES <- toupper(changed)
[09:29:19.930]                 args <- list()
[09:29:19.930]                 for (kk in seq_along(NAMES)) {
[09:29:19.930]                   name <- changed[[kk]]
[09:29:19.930]                   NAME <- NAMES[[kk]]
[09:29:19.930]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.930]                     next
[09:29:19.930]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.930]                 }
[09:29:19.930]                 NAMES <- toupper(added)
[09:29:19.930]                 for (kk in seq_along(NAMES)) {
[09:29:19.930]                   name <- added[[kk]]
[09:29:19.930]                   NAME <- NAMES[[kk]]
[09:29:19.930]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.930]                     next
[09:29:19.930]                   args[[name]] <- ""
[09:29:19.930]                 }
[09:29:19.930]                 NAMES <- toupper(removed)
[09:29:19.930]                 for (kk in seq_along(NAMES)) {
[09:29:19.930]                   name <- removed[[kk]]
[09:29:19.930]                   NAME <- NAMES[[kk]]
[09:29:19.930]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.930]                     next
[09:29:19.930]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.930]                 }
[09:29:19.930]                 if (length(args) > 0) 
[09:29:19.930]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.930]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.930]             }
[09:29:19.930]             else {
[09:29:19.930]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.930]             }
[09:29:19.930]             {
[09:29:19.930]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.930]                   0L) {
[09:29:19.930]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.930]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.930]                   base::options(opts)
[09:29:19.930]                 }
[09:29:19.930]                 {
[09:29:19.930]                   {
[09:29:19.930]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.930]                     NULL
[09:29:19.930]                   }
[09:29:19.930]                   options(future.plan = NULL)
[09:29:19.930]                   if (is.na(NA_character_)) 
[09:29:19.930]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.930]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.930]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.930]                     .init = FALSE)
[09:29:19.930]                 }
[09:29:19.930]             }
[09:29:19.930]         }
[09:29:19.930]     })
[09:29:19.930]     if (TRUE) {
[09:29:19.930]         base::sink(type = "output", split = FALSE)
[09:29:19.930]         if (TRUE) {
[09:29:19.930]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.930]         }
[09:29:19.930]         else {
[09:29:19.930]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.930]         }
[09:29:19.930]         base::close(...future.stdout)
[09:29:19.930]         ...future.stdout <- NULL
[09:29:19.930]     }
[09:29:19.930]     ...future.result$conditions <- ...future.conditions
[09:29:19.930]     ...future.result$finished <- base::Sys.time()
[09:29:19.930]     ...future.result
[09:29:19.930] }
[09:29:19.932] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[09:29:19.932] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[09:29:19.933] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[09:29:19.933] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:19.933] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.933] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[09:29:19.934] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[09:29:19.934] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:19.934] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.934] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:19.934] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:19.934] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[09:29:19.935] MultisessionFuture started
[09:29:19.935] - Launch lazy future ... done
[09:29:19.935] run() for ‘MultisessionFuture’ ... done
[09:29:19.935] Created future:
[09:29:19.935] MultisessionFuture:
[09:29:19.935] Label: ‘future_mapply-1’
[09:29:19.935] Expression:
[09:29:19.935] {
[09:29:19.935]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.935]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.935]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.935]         on.exit(options(oopts), add = TRUE)
[09:29:19.935]     }
[09:29:19.935]     {
[09:29:19.935]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.935]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.935]         do.call(mapply, args = args)
[09:29:19.935]     }
[09:29:19.935] }
[09:29:19.935] Lazy evaluation: FALSE
[09:29:19.935] Asynchronous evaluation: TRUE
[09:29:19.935] Local evaluation: TRUE
[09:29:19.935] Environment: R_GlobalEnv
[09:29:19.935] Capture standard output: TRUE
[09:29:19.935] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.935] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.935] Packages: <none>
[09:29:19.935] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.935] Resolved: FALSE
[09:29:19.935] Value: <not collected>
[09:29:19.935] Conditions captured: <none>
[09:29:19.935] Early signaling: FALSE
[09:29:19.935] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.935] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.947] Chunk #1 of 2 ... DONE
[09:29:19.947] Chunk #2 of 2 ...
[09:29:19.947]  - Finding globals in '...' for chunk #2 ...
[09:29:19.947] getGlobalsAndPackages() ...
[09:29:19.947] Searching for globals...
[09:29:19.947] 
[09:29:19.948] Searching for globals ... DONE
[09:29:19.948] - globals: [0] <none>
[09:29:19.948] getGlobalsAndPackages() ... DONE
[09:29:19.948]    + additional globals found: [n=0] 
[09:29:19.948]    + additional namespaces needed: [n=0] 
[09:29:19.948]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:19.948]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:19.948]  - seeds: <none>
[09:29:19.948]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.948] getGlobalsAndPackages() ...
[09:29:19.948] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.949] Resolving globals: FALSE
[09:29:19.949] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[09:29:19.949] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:19.950] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:19.950] 
[09:29:19.950] getGlobalsAndPackages() ... DONE
[09:29:19.950] run() for ‘Future’ ...
[09:29:19.950] - state: ‘created’
[09:29:19.950] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:19.964] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:19.965]   - Field: ‘node’
[09:29:19.965]   - Field: ‘label’
[09:29:19.965]   - Field: ‘local’
[09:29:19.965]   - Field: ‘owner’
[09:29:19.965]   - Field: ‘envir’
[09:29:19.965]   - Field: ‘workers’
[09:29:19.965]   - Field: ‘packages’
[09:29:19.965]   - Field: ‘gc’
[09:29:19.965]   - Field: ‘conditions’
[09:29:19.965]   - Field: ‘persistent’
[09:29:19.966]   - Field: ‘expr’
[09:29:19.966]   - Field: ‘uuid’
[09:29:19.966]   - Field: ‘seed’
[09:29:19.966]   - Field: ‘version’
[09:29:19.966]   - Field: ‘result’
[09:29:19.966]   - Field: ‘asynchronous’
[09:29:19.966]   - Field: ‘calls’
[09:29:19.966]   - Field: ‘globals’
[09:29:19.966]   - Field: ‘stdout’
[09:29:19.966]   - Field: ‘earlySignal’
[09:29:19.966]   - Field: ‘lazy’
[09:29:19.966]   - Field: ‘state’
[09:29:19.967] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:19.967] - Launch lazy future ...
[09:29:19.967] Packages needed by the future expression (n = 0): <none>
[09:29:19.967] Packages needed by future strategies (n = 0): <none>
[09:29:19.967] {
[09:29:19.967]     {
[09:29:19.967]         {
[09:29:19.967]             ...future.startTime <- base::Sys.time()
[09:29:19.967]             {
[09:29:19.967]                 {
[09:29:19.967]                   {
[09:29:19.967]                     {
[09:29:19.967]                       base::local({
[09:29:19.967]                         has_future <- base::requireNamespace("future", 
[09:29:19.967]                           quietly = TRUE)
[09:29:19.967]                         if (has_future) {
[09:29:19.967]                           ns <- base::getNamespace("future")
[09:29:19.967]                           version <- ns[[".package"]][["version"]]
[09:29:19.967]                           if (is.null(version)) 
[09:29:19.967]                             version <- utils::packageVersion("future")
[09:29:19.967]                         }
[09:29:19.967]                         else {
[09:29:19.967]                           version <- NULL
[09:29:19.967]                         }
[09:29:19.967]                         if (!has_future || version < "1.8.0") {
[09:29:19.967]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:19.967]                             "", base::R.version$version.string), 
[09:29:19.967]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:19.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:19.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:19.967]                               "release", "version")], collapse = " "), 
[09:29:19.967]                             hostname = base::Sys.info()[["nodename"]])
[09:29:19.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:19.967]                             info)
[09:29:19.967]                           info <- base::paste(info, collapse = "; ")
[09:29:19.967]                           if (!has_future) {
[09:29:19.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:19.967]                               info)
[09:29:19.967]                           }
[09:29:19.967]                           else {
[09:29:19.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:19.967]                               info, version)
[09:29:19.967]                           }
[09:29:19.967]                           base::stop(msg)
[09:29:19.967]                         }
[09:29:19.967]                       })
[09:29:19.967]                     }
[09:29:19.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:19.967]                     base::options(mc.cores = 1L)
[09:29:19.967]                   }
[09:29:19.967]                   ...future.strategy.old <- future::plan("list")
[09:29:19.967]                   options(future.plan = NULL)
[09:29:19.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:19.967]                 }
[09:29:19.967]                 ...future.workdir <- getwd()
[09:29:19.967]             }
[09:29:19.967]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:19.967]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:19.967]         }
[09:29:19.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:19.967]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:19.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:19.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:19.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:19.967]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:19.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:19.967]             base::names(...future.oldOptions))
[09:29:19.967]     }
[09:29:19.967]     if (FALSE) {
[09:29:19.967]     }
[09:29:19.967]     else {
[09:29:19.967]         if (TRUE) {
[09:29:19.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:19.967]                 open = "w")
[09:29:19.967]         }
[09:29:19.967]         else {
[09:29:19.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:19.967]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:19.967]         }
[09:29:19.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:19.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:19.967]             base::sink(type = "output", split = FALSE)
[09:29:19.967]             base::close(...future.stdout)
[09:29:19.967]         }, add = TRUE)
[09:29:19.967]     }
[09:29:19.967]     ...future.frame <- base::sys.nframe()
[09:29:19.967]     ...future.conditions <- base::list()
[09:29:19.967]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:19.967]     if (FALSE) {
[09:29:19.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:19.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:19.967]     }
[09:29:19.967]     ...future.result <- base::tryCatch({
[09:29:19.967]         base::withCallingHandlers({
[09:29:19.967]             ...future.value <- base::withVisible(base::local({
[09:29:19.967]                 ...future.makeSendCondition <- base::local({
[09:29:19.967]                   sendCondition <- NULL
[09:29:19.967]                   function(frame = 1L) {
[09:29:19.967]                     if (is.function(sendCondition)) 
[09:29:19.967]                       return(sendCondition)
[09:29:19.967]                     ns <- getNamespace("parallel")
[09:29:19.967]                     if (exists("sendData", mode = "function", 
[09:29:19.967]                       envir = ns)) {
[09:29:19.967]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:19.967]                         envir = ns)
[09:29:19.967]                       envir <- sys.frame(frame)
[09:29:19.967]                       master <- NULL
[09:29:19.967]                       while (!identical(envir, .GlobalEnv) && 
[09:29:19.967]                         !identical(envir, emptyenv())) {
[09:29:19.967]                         if (exists("master", mode = "list", envir = envir, 
[09:29:19.967]                           inherits = FALSE)) {
[09:29:19.967]                           master <- get("master", mode = "list", 
[09:29:19.967]                             envir = envir, inherits = FALSE)
[09:29:19.967]                           if (inherits(master, c("SOCKnode", 
[09:29:19.967]                             "SOCK0node"))) {
[09:29:19.967]                             sendCondition <<- function(cond) {
[09:29:19.967]                               data <- list(type = "VALUE", value = cond, 
[09:29:19.967]                                 success = TRUE)
[09:29:19.967]                               parallel_sendData(master, data)
[09:29:19.967]                             }
[09:29:19.967]                             return(sendCondition)
[09:29:19.967]                           }
[09:29:19.967]                         }
[09:29:19.967]                         frame <- frame + 1L
[09:29:19.967]                         envir <- sys.frame(frame)
[09:29:19.967]                       }
[09:29:19.967]                     }
[09:29:19.967]                     sendCondition <<- function(cond) NULL
[09:29:19.967]                   }
[09:29:19.967]                 })
[09:29:19.967]                 withCallingHandlers({
[09:29:19.967]                   {
[09:29:19.967]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.967]                     if (!identical(...future.globals.maxSize.org, 
[09:29:19.967]                       ...future.globals.maxSize)) {
[09:29:19.967]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.967]                       on.exit(options(oopts), add = TRUE)
[09:29:19.967]                     }
[09:29:19.967]                     {
[09:29:19.967]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.967]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:19.967]                         USE.NAMES = FALSE)
[09:29:19.967]                       do.call(mapply, args = args)
[09:29:19.967]                     }
[09:29:19.967]                   }
[09:29:19.967]                 }, immediateCondition = function(cond) {
[09:29:19.967]                   sendCondition <- ...future.makeSendCondition()
[09:29:19.967]                   sendCondition(cond)
[09:29:19.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.967]                   {
[09:29:19.967]                     inherits <- base::inherits
[09:29:19.967]                     invokeRestart <- base::invokeRestart
[09:29:19.967]                     is.null <- base::is.null
[09:29:19.967]                     muffled <- FALSE
[09:29:19.967]                     if (inherits(cond, "message")) {
[09:29:19.967]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:19.967]                       if (muffled) 
[09:29:19.967]                         invokeRestart("muffleMessage")
[09:29:19.967]                     }
[09:29:19.967]                     else if (inherits(cond, "warning")) {
[09:29:19.967]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:19.967]                       if (muffled) 
[09:29:19.967]                         invokeRestart("muffleWarning")
[09:29:19.967]                     }
[09:29:19.967]                     else if (inherits(cond, "condition")) {
[09:29:19.967]                       if (!is.null(pattern)) {
[09:29:19.967]                         computeRestarts <- base::computeRestarts
[09:29:19.967]                         grepl <- base::grepl
[09:29:19.967]                         restarts <- computeRestarts(cond)
[09:29:19.967]                         for (restart in restarts) {
[09:29:19.967]                           name <- restart$name
[09:29:19.967]                           if (is.null(name)) 
[09:29:19.967]                             next
[09:29:19.967]                           if (!grepl(pattern, name)) 
[09:29:19.967]                             next
[09:29:19.967]                           invokeRestart(restart)
[09:29:19.967]                           muffled <- TRUE
[09:29:19.967]                           break
[09:29:19.967]                         }
[09:29:19.967]                       }
[09:29:19.967]                     }
[09:29:19.967]                     invisible(muffled)
[09:29:19.967]                   }
[09:29:19.967]                   muffleCondition(cond)
[09:29:19.967]                 })
[09:29:19.967]             }))
[09:29:19.967]             future::FutureResult(value = ...future.value$value, 
[09:29:19.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.967]                   ...future.rng), globalenv = if (FALSE) 
[09:29:19.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:19.967]                     ...future.globalenv.names))
[09:29:19.967]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:19.967]         }, condition = base::local({
[09:29:19.967]             c <- base::c
[09:29:19.967]             inherits <- base::inherits
[09:29:19.967]             invokeRestart <- base::invokeRestart
[09:29:19.967]             length <- base::length
[09:29:19.967]             list <- base::list
[09:29:19.967]             seq.int <- base::seq.int
[09:29:19.967]             signalCondition <- base::signalCondition
[09:29:19.967]             sys.calls <- base::sys.calls
[09:29:19.967]             `[[` <- base::`[[`
[09:29:19.967]             `+` <- base::`+`
[09:29:19.967]             `<<-` <- base::`<<-`
[09:29:19.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:19.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:19.967]                   3L)]
[09:29:19.967]             }
[09:29:19.967]             function(cond) {
[09:29:19.967]                 is_error <- inherits(cond, "error")
[09:29:19.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:19.967]                   NULL)
[09:29:19.967]                 if (is_error) {
[09:29:19.967]                   sessionInformation <- function() {
[09:29:19.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:19.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:19.967]                       search = base::search(), system = base::Sys.info())
[09:29:19.967]                   }
[09:29:19.967]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:19.967]                     cond$call), session = sessionInformation(), 
[09:29:19.967]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:19.967]                   signalCondition(cond)
[09:29:19.967]                 }
[09:29:19.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:19.967]                 "immediateCondition"))) {
[09:29:19.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:19.967]                   ...future.conditions[[length(...future.conditions) + 
[09:29:19.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:19.967]                   if (TRUE && !signal) {
[09:29:19.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.967]                     {
[09:29:19.967]                       inherits <- base::inherits
[09:29:19.967]                       invokeRestart <- base::invokeRestart
[09:29:19.967]                       is.null <- base::is.null
[09:29:19.967]                       muffled <- FALSE
[09:29:19.967]                       if (inherits(cond, "message")) {
[09:29:19.967]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.967]                         if (muffled) 
[09:29:19.967]                           invokeRestart("muffleMessage")
[09:29:19.967]                       }
[09:29:19.967]                       else if (inherits(cond, "warning")) {
[09:29:19.967]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.967]                         if (muffled) 
[09:29:19.967]                           invokeRestart("muffleWarning")
[09:29:19.967]                       }
[09:29:19.967]                       else if (inherits(cond, "condition")) {
[09:29:19.967]                         if (!is.null(pattern)) {
[09:29:19.967]                           computeRestarts <- base::computeRestarts
[09:29:19.967]                           grepl <- base::grepl
[09:29:19.967]                           restarts <- computeRestarts(cond)
[09:29:19.967]                           for (restart in restarts) {
[09:29:19.967]                             name <- restart$name
[09:29:19.967]                             if (is.null(name)) 
[09:29:19.967]                               next
[09:29:19.967]                             if (!grepl(pattern, name)) 
[09:29:19.967]                               next
[09:29:19.967]                             invokeRestart(restart)
[09:29:19.967]                             muffled <- TRUE
[09:29:19.967]                             break
[09:29:19.967]                           }
[09:29:19.967]                         }
[09:29:19.967]                       }
[09:29:19.967]                       invisible(muffled)
[09:29:19.967]                     }
[09:29:19.967]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.967]                   }
[09:29:19.967]                 }
[09:29:19.967]                 else {
[09:29:19.967]                   if (TRUE) {
[09:29:19.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:19.967]                     {
[09:29:19.967]                       inherits <- base::inherits
[09:29:19.967]                       invokeRestart <- base::invokeRestart
[09:29:19.967]                       is.null <- base::is.null
[09:29:19.967]                       muffled <- FALSE
[09:29:19.967]                       if (inherits(cond, "message")) {
[09:29:19.967]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:19.967]                         if (muffled) 
[09:29:19.967]                           invokeRestart("muffleMessage")
[09:29:19.967]                       }
[09:29:19.967]                       else if (inherits(cond, "warning")) {
[09:29:19.967]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:19.967]                         if (muffled) 
[09:29:19.967]                           invokeRestart("muffleWarning")
[09:29:19.967]                       }
[09:29:19.967]                       else if (inherits(cond, "condition")) {
[09:29:19.967]                         if (!is.null(pattern)) {
[09:29:19.967]                           computeRestarts <- base::computeRestarts
[09:29:19.967]                           grepl <- base::grepl
[09:29:19.967]                           restarts <- computeRestarts(cond)
[09:29:19.967]                           for (restart in restarts) {
[09:29:19.967]                             name <- restart$name
[09:29:19.967]                             if (is.null(name)) 
[09:29:19.967]                               next
[09:29:19.967]                             if (!grepl(pattern, name)) 
[09:29:19.967]                               next
[09:29:19.967]                             invokeRestart(restart)
[09:29:19.967]                             muffled <- TRUE
[09:29:19.967]                             break
[09:29:19.967]                           }
[09:29:19.967]                         }
[09:29:19.967]                       }
[09:29:19.967]                       invisible(muffled)
[09:29:19.967]                     }
[09:29:19.967]                     muffleCondition(cond, pattern = "^muffle")
[09:29:19.967]                   }
[09:29:19.967]                 }
[09:29:19.967]             }
[09:29:19.967]         }))
[09:29:19.967]     }, error = function(ex) {
[09:29:19.967]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:19.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:19.967]                 ...future.rng), started = ...future.startTime, 
[09:29:19.967]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:19.967]             version = "1.8"), class = "FutureResult")
[09:29:19.967]     }, finally = {
[09:29:19.967]         if (!identical(...future.workdir, getwd())) 
[09:29:19.967]             setwd(...future.workdir)
[09:29:19.967]         {
[09:29:19.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:19.967]                 ...future.oldOptions$nwarnings <- NULL
[09:29:19.967]             }
[09:29:19.967]             base::options(...future.oldOptions)
[09:29:19.967]             if (.Platform$OS.type == "windows") {
[09:29:19.967]                 old_names <- names(...future.oldEnvVars)
[09:29:19.967]                 envs <- base::Sys.getenv()
[09:29:19.967]                 names <- names(envs)
[09:29:19.967]                 common <- intersect(names, old_names)
[09:29:19.967]                 added <- setdiff(names, old_names)
[09:29:19.967]                 removed <- setdiff(old_names, names)
[09:29:19.967]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:19.967]                   envs[common]]
[09:29:19.967]                 NAMES <- toupper(changed)
[09:29:19.967]                 args <- list()
[09:29:19.967]                 for (kk in seq_along(NAMES)) {
[09:29:19.967]                   name <- changed[[kk]]
[09:29:19.967]                   NAME <- NAMES[[kk]]
[09:29:19.967]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.967]                     next
[09:29:19.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.967]                 }
[09:29:19.967]                 NAMES <- toupper(added)
[09:29:19.967]                 for (kk in seq_along(NAMES)) {
[09:29:19.967]                   name <- added[[kk]]
[09:29:19.967]                   NAME <- NAMES[[kk]]
[09:29:19.967]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.967]                     next
[09:29:19.967]                   args[[name]] <- ""
[09:29:19.967]                 }
[09:29:19.967]                 NAMES <- toupper(removed)
[09:29:19.967]                 for (kk in seq_along(NAMES)) {
[09:29:19.967]                   name <- removed[[kk]]
[09:29:19.967]                   NAME <- NAMES[[kk]]
[09:29:19.967]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:19.967]                     next
[09:29:19.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:19.967]                 }
[09:29:19.967]                 if (length(args) > 0) 
[09:29:19.967]                   base::do.call(base::Sys.setenv, args = args)
[09:29:19.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:19.967]             }
[09:29:19.967]             else {
[09:29:19.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:19.967]             }
[09:29:19.967]             {
[09:29:19.967]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:19.967]                   0L) {
[09:29:19.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:19.967]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:19.967]                   base::options(opts)
[09:29:19.967]                 }
[09:29:19.967]                 {
[09:29:19.967]                   {
[09:29:19.967]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:19.967]                     NULL
[09:29:19.967]                   }
[09:29:19.967]                   options(future.plan = NULL)
[09:29:19.967]                   if (is.na(NA_character_)) 
[09:29:19.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:19.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:19.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:19.967]                     .init = FALSE)
[09:29:19.967]                 }
[09:29:19.967]             }
[09:29:19.967]         }
[09:29:19.967]     })
[09:29:19.967]     if (TRUE) {
[09:29:19.967]         base::sink(type = "output", split = FALSE)
[09:29:19.967]         if (TRUE) {
[09:29:19.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:19.967]         }
[09:29:19.967]         else {
[09:29:19.967]             ...future.result["stdout"] <- base::list(NULL)
[09:29:19.967]         }
[09:29:19.967]         base::close(...future.stdout)
[09:29:19.967]         ...future.stdout <- NULL
[09:29:19.967]     }
[09:29:19.967]     ...future.result$conditions <- ...future.conditions
[09:29:19.967]     ...future.result$finished <- base::Sys.time()
[09:29:19.967]     ...future.result
[09:29:19.967] }
[09:29:19.970] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[09:29:19.970] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[09:29:19.971] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[09:29:19.971] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:19.971] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.971] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[09:29:19.972] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[09:29:19.972] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:19.972] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.972] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:19.973] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:19.973] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[09:29:19.973] MultisessionFuture started
[09:29:19.973] - Launch lazy future ... done
[09:29:19.973] run() for ‘MultisessionFuture’ ... done
[09:29:19.974] Created future:
[09:29:19.974] MultisessionFuture:
[09:29:19.974] Label: ‘future_mapply-2’
[09:29:19.974] Expression:
[09:29:19.974] {
[09:29:19.974]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:19.974]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:19.974]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:19.974]         on.exit(options(oopts), add = TRUE)
[09:29:19.974]     }
[09:29:19.974]     {
[09:29:19.974]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:19.974]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:19.974]         do.call(mapply, args = args)
[09:29:19.974]     }
[09:29:19.974] }
[09:29:19.974] Lazy evaluation: FALSE
[09:29:19.974] Asynchronous evaluation: TRUE
[09:29:19.974] Local evaluation: TRUE
[09:29:19.974] Environment: R_GlobalEnv
[09:29:19.974] Capture standard output: TRUE
[09:29:19.974] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:19.974] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:19.974] Packages: <none>
[09:29:19.974] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:19.974] Resolved: FALSE
[09:29:19.974] Value: <not collected>
[09:29:19.974] Conditions captured: <none>
[09:29:19.974] Early signaling: FALSE
[09:29:19.974] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:19.974] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:19.985] Chunk #2 of 2 ... DONE
[09:29:19.985] Launching 2 futures (chunks) ... DONE
[09:29:19.985] Resolving 2 futures (chunks) ...
[09:29:19.985] resolve() on list ...
[09:29:19.985]  recursive: 0
[09:29:19.985]  length: 2
[09:29:19.986] 
[09:29:19.986] receiveMessageFromWorker() for ClusterFuture ...
[09:29:19.986] - Validating connection of MultisessionFuture
[09:29:19.986] - received message: FutureResult
[09:29:19.986] - Received FutureResult
[09:29:19.986] - Erased future from FutureRegistry
[09:29:19.987] result() for ClusterFuture ...
[09:29:19.987] - result already collected: FutureResult
[09:29:19.987] result() for ClusterFuture ... done
[09:29:19.987] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:19.987] Future #1
[09:29:19.987] result() for ClusterFuture ...
[09:29:19.987] - result already collected: FutureResult
[09:29:19.987] result() for ClusterFuture ... done
[09:29:19.987] result() for ClusterFuture ...
[09:29:19.987] - result already collected: FutureResult
[09:29:19.987] result() for ClusterFuture ... done
[09:29:19.988] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:19.988] - nx: 2
[09:29:19.988] - relay: TRUE
[09:29:19.988] - stdout: TRUE
[09:29:19.988] - signal: TRUE
[09:29:19.988] - resignal: FALSE
[09:29:19.988] - force: TRUE
[09:29:19.988] - relayed: [n=2] FALSE, FALSE
[09:29:19.988] - queued futures: [n=2] FALSE, FALSE
[09:29:19.988]  - until=1
[09:29:19.988]  - relaying element #1
[09:29:19.989] result() for ClusterFuture ...
[09:29:19.989] - result already collected: FutureResult
[09:29:19.989] result() for ClusterFuture ... done
[09:29:19.989] result() for ClusterFuture ...
[09:29:19.989] - result already collected: FutureResult
[09:29:19.989] result() for ClusterFuture ... done
[09:29:19.989] result() for ClusterFuture ...
[09:29:19.989] - result already collected: FutureResult
[09:29:19.989] result() for ClusterFuture ... done
[09:29:19.989] result() for ClusterFuture ...
[09:29:19.989] - result already collected: FutureResult
[09:29:19.990] result() for ClusterFuture ... done
[09:29:19.990] - relayed: [n=2] TRUE, FALSE
[09:29:19.990] - queued futures: [n=2] TRUE, FALSE
[09:29:19.990] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:19.990]  length: 1 (resolved future 1)
[09:29:20.017] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.017] - Validating connection of MultisessionFuture
[09:29:20.018] - received message: FutureResult
[09:29:20.018] - Received FutureResult
[09:29:20.018] - Erased future from FutureRegistry
[09:29:20.018] result() for ClusterFuture ...
[09:29:20.018] - result already collected: FutureResult
[09:29:20.018] result() for ClusterFuture ... done
[09:29:20.018] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.018] Future #2
[09:29:20.018] result() for ClusterFuture ...
[09:29:20.018] - result already collected: FutureResult
[09:29:20.018] result() for ClusterFuture ... done
[09:29:20.019] result() for ClusterFuture ...
[09:29:20.019] - result already collected: FutureResult
[09:29:20.019] result() for ClusterFuture ... done
[09:29:20.019] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:20.019] - nx: 2
[09:29:20.019] - relay: TRUE
[09:29:20.019] - stdout: TRUE
[09:29:20.019] - signal: TRUE
[09:29:20.019] - resignal: FALSE
[09:29:20.019] - force: TRUE
[09:29:20.019] - relayed: [n=2] TRUE, FALSE
[09:29:20.019] - queued futures: [n=2] TRUE, FALSE
[09:29:20.020]  - until=2
[09:29:20.020]  - relaying element #2
[09:29:20.020] result() for ClusterFuture ...
[09:29:20.020] - result already collected: FutureResult
[09:29:20.020] result() for ClusterFuture ... done
[09:29:20.020] result() for ClusterFuture ...
[09:29:20.020] - result already collected: FutureResult
[09:29:20.020] result() for ClusterFuture ... done
[09:29:20.020] result() for ClusterFuture ...
[09:29:20.020] - result already collected: FutureResult
[09:29:20.021] result() for ClusterFuture ... done
[09:29:20.021] result() for ClusterFuture ...
[09:29:20.021] - result already collected: FutureResult
[09:29:20.021] result() for ClusterFuture ... done
[09:29:20.021] - relayed: [n=2] TRUE, TRUE
[09:29:20.021] - queued futures: [n=2] TRUE, TRUE
[09:29:20.021] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:20.021]  length: 0 (resolved future 2)
[09:29:20.021] Relaying remaining futures
[09:29:20.021] signalConditionsASAP(NULL, pos=0) ...
[09:29:20.021] - nx: 2
[09:29:20.021] - relay: TRUE
[09:29:20.022] - stdout: TRUE
[09:29:20.022] - signal: TRUE
[09:29:20.022] - resignal: FALSE
[09:29:20.022] - force: TRUE
[09:29:20.022] - relayed: [n=2] TRUE, TRUE
[09:29:20.022] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:20.022] - relayed: [n=2] TRUE, TRUE
[09:29:20.022] - queued futures: [n=2] TRUE, TRUE
[09:29:20.022] signalConditionsASAP(NULL, pos=0) ... done
[09:29:20.022] resolve() on list ... DONE
[09:29:20.022] result() for ClusterFuture ...
[09:29:20.023] - result already collected: FutureResult
[09:29:20.023] result() for ClusterFuture ... done
[09:29:20.023] result() for ClusterFuture ...
[09:29:20.023] - result already collected: FutureResult
[09:29:20.023] result() for ClusterFuture ... done
[09:29:20.023] result() for ClusterFuture ...
[09:29:20.023] - result already collected: FutureResult
[09:29:20.023] result() for ClusterFuture ... done
[09:29:20.023] result() for ClusterFuture ...
[09:29:20.023] - result already collected: FutureResult
[09:29:20.023] result() for ClusterFuture ... done
[09:29:20.024]  - Number of value chunks collected: 2
[09:29:20.024] Resolving 2 futures (chunks) ... DONE
[09:29:20.024] Reducing values from 2 chunks ...
[09:29:20.024]  - Number of values collected after concatenation: 5
[09:29:20.024]  - Number of values expected: 5
[09:29:20.024] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[09:29:20.024] Reducing values from 2 chunks ... DONE
[09:29:20.024] future_mapply() ... DONE
[09:29:20.024] future_mapply() ...
[09:29:20.028] Number of chunks: 2
[09:29:20.028] getGlobalsAndPackagesXApply() ...
[09:29:20.028]  - future.globals: TRUE
[09:29:20.028] getGlobalsAndPackages() ...
[09:29:20.028] Searching for globals...
[09:29:20.029] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[09:29:20.030] Searching for globals ... DONE
[09:29:20.030] Resolving globals: FALSE
[09:29:20.030] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[09:29:20.030] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[09:29:20.030] - globals: [1] ‘FUN’
[09:29:20.031] 
[09:29:20.031] getGlobalsAndPackages() ... DONE
[09:29:20.031]  - globals found/used: [n=1] ‘FUN’
[09:29:20.031]  - needed namespaces: [n=0] 
[09:29:20.031] Finding globals ... DONE
[09:29:20.031] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:20.031] List of 2
[09:29:20.031]  $ ...future.FUN:function (C, k)  
[09:29:20.031]  $ MoreArgs     : list()
[09:29:20.031]  - attr(*, "where")=List of 2
[09:29:20.031]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:20.031]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:20.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:20.031]  - attr(*, "resolved")= logi FALSE
[09:29:20.031]  - attr(*, "total_size")= num NA
[09:29:20.034] Packages to be attached in all futures: [n=0] 
[09:29:20.034] getGlobalsAndPackagesXApply() ... DONE
[09:29:20.034] Number of futures (= number of chunks): 2
[09:29:20.034] Launching 2 futures (chunks) ...
[09:29:20.034] Chunk #1 of 2 ...
[09:29:20.034]  - Finding globals in '...' for chunk #1 ...
[09:29:20.034] getGlobalsAndPackages() ...
[09:29:20.034] Searching for globals...
[09:29:20.035] 
[09:29:20.035] Searching for globals ... DONE
[09:29:20.035] - globals: [0] <none>
[09:29:20.035] getGlobalsAndPackages() ... DONE
[09:29:20.035]    + additional globals found: [n=0] 
[09:29:20.035]    + additional namespaces needed: [n=0] 
[09:29:20.035]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:20.035]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:20.035]  - seeds: <none>
[09:29:20.035]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.036] getGlobalsAndPackages() ...
[09:29:20.036] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.036] Resolving globals: FALSE
[09:29:20.036] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[09:29:20.037] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:20.037] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.037] 
[09:29:20.037] getGlobalsAndPackages() ... DONE
[09:29:20.037] run() for ‘Future’ ...
[09:29:20.037] - state: ‘created’
[09:29:20.037] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.051] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.051] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.051]   - Field: ‘node’
[09:29:20.051]   - Field: ‘label’
[09:29:20.051]   - Field: ‘local’
[09:29:20.051]   - Field: ‘owner’
[09:29:20.051]   - Field: ‘envir’
[09:29:20.052]   - Field: ‘workers’
[09:29:20.052]   - Field: ‘packages’
[09:29:20.052]   - Field: ‘gc’
[09:29:20.052]   - Field: ‘conditions’
[09:29:20.052]   - Field: ‘persistent’
[09:29:20.052]   - Field: ‘expr’
[09:29:20.052]   - Field: ‘uuid’
[09:29:20.052]   - Field: ‘seed’
[09:29:20.052]   - Field: ‘version’
[09:29:20.052]   - Field: ‘result’
[09:29:20.052]   - Field: ‘asynchronous’
[09:29:20.053]   - Field: ‘calls’
[09:29:20.053]   - Field: ‘globals’
[09:29:20.053]   - Field: ‘stdout’
[09:29:20.053]   - Field: ‘earlySignal’
[09:29:20.053]   - Field: ‘lazy’
[09:29:20.053]   - Field: ‘state’
[09:29:20.053] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.053] - Launch lazy future ...
[09:29:20.053] Packages needed by the future expression (n = 0): <none>
[09:29:20.054] Packages needed by future strategies (n = 0): <none>
[09:29:20.054] {
[09:29:20.054]     {
[09:29:20.054]         {
[09:29:20.054]             ...future.startTime <- base::Sys.time()
[09:29:20.054]             {
[09:29:20.054]                 {
[09:29:20.054]                   {
[09:29:20.054]                     {
[09:29:20.054]                       base::local({
[09:29:20.054]                         has_future <- base::requireNamespace("future", 
[09:29:20.054]                           quietly = TRUE)
[09:29:20.054]                         if (has_future) {
[09:29:20.054]                           ns <- base::getNamespace("future")
[09:29:20.054]                           version <- ns[[".package"]][["version"]]
[09:29:20.054]                           if (is.null(version)) 
[09:29:20.054]                             version <- utils::packageVersion("future")
[09:29:20.054]                         }
[09:29:20.054]                         else {
[09:29:20.054]                           version <- NULL
[09:29:20.054]                         }
[09:29:20.054]                         if (!has_future || version < "1.8.0") {
[09:29:20.054]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.054]                             "", base::R.version$version.string), 
[09:29:20.054]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:20.054]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:20.054]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.054]                               "release", "version")], collapse = " "), 
[09:29:20.054]                             hostname = base::Sys.info()[["nodename"]])
[09:29:20.054]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.054]                             info)
[09:29:20.054]                           info <- base::paste(info, collapse = "; ")
[09:29:20.054]                           if (!has_future) {
[09:29:20.054]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.054]                               info)
[09:29:20.054]                           }
[09:29:20.054]                           else {
[09:29:20.054]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.054]                               info, version)
[09:29:20.054]                           }
[09:29:20.054]                           base::stop(msg)
[09:29:20.054]                         }
[09:29:20.054]                       })
[09:29:20.054]                     }
[09:29:20.054]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.054]                     base::options(mc.cores = 1L)
[09:29:20.054]                   }
[09:29:20.054]                   ...future.strategy.old <- future::plan("list")
[09:29:20.054]                   options(future.plan = NULL)
[09:29:20.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.054]                 }
[09:29:20.054]                 ...future.workdir <- getwd()
[09:29:20.054]             }
[09:29:20.054]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.054]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.054]         }
[09:29:20.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.054]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:20.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.054]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.054]             base::names(...future.oldOptions))
[09:29:20.054]     }
[09:29:20.054]     if (FALSE) {
[09:29:20.054]     }
[09:29:20.054]     else {
[09:29:20.054]         if (TRUE) {
[09:29:20.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.054]                 open = "w")
[09:29:20.054]         }
[09:29:20.054]         else {
[09:29:20.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.054]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.054]         }
[09:29:20.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.054]             base::sink(type = "output", split = FALSE)
[09:29:20.054]             base::close(...future.stdout)
[09:29:20.054]         }, add = TRUE)
[09:29:20.054]     }
[09:29:20.054]     ...future.frame <- base::sys.nframe()
[09:29:20.054]     ...future.conditions <- base::list()
[09:29:20.054]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.054]     if (FALSE) {
[09:29:20.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.054]     }
[09:29:20.054]     ...future.result <- base::tryCatch({
[09:29:20.054]         base::withCallingHandlers({
[09:29:20.054]             ...future.value <- base::withVisible(base::local({
[09:29:20.054]                 ...future.makeSendCondition <- base::local({
[09:29:20.054]                   sendCondition <- NULL
[09:29:20.054]                   function(frame = 1L) {
[09:29:20.054]                     if (is.function(sendCondition)) 
[09:29:20.054]                       return(sendCondition)
[09:29:20.054]                     ns <- getNamespace("parallel")
[09:29:20.054]                     if (exists("sendData", mode = "function", 
[09:29:20.054]                       envir = ns)) {
[09:29:20.054]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.054]                         envir = ns)
[09:29:20.054]                       envir <- sys.frame(frame)
[09:29:20.054]                       master <- NULL
[09:29:20.054]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.054]                         !identical(envir, emptyenv())) {
[09:29:20.054]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.054]                           inherits = FALSE)) {
[09:29:20.054]                           master <- get("master", mode = "list", 
[09:29:20.054]                             envir = envir, inherits = FALSE)
[09:29:20.054]                           if (inherits(master, c("SOCKnode", 
[09:29:20.054]                             "SOCK0node"))) {
[09:29:20.054]                             sendCondition <<- function(cond) {
[09:29:20.054]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.054]                                 success = TRUE)
[09:29:20.054]                               parallel_sendData(master, data)
[09:29:20.054]                             }
[09:29:20.054]                             return(sendCondition)
[09:29:20.054]                           }
[09:29:20.054]                         }
[09:29:20.054]                         frame <- frame + 1L
[09:29:20.054]                         envir <- sys.frame(frame)
[09:29:20.054]                       }
[09:29:20.054]                     }
[09:29:20.054]                     sendCondition <<- function(cond) NULL
[09:29:20.054]                   }
[09:29:20.054]                 })
[09:29:20.054]                 withCallingHandlers({
[09:29:20.054]                   {
[09:29:20.054]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.054]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.054]                       ...future.globals.maxSize)) {
[09:29:20.054]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.054]                       on.exit(options(oopts), add = TRUE)
[09:29:20.054]                     }
[09:29:20.054]                     {
[09:29:20.054]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.054]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.054]                         USE.NAMES = FALSE)
[09:29:20.054]                       do.call(mapply, args = args)
[09:29:20.054]                     }
[09:29:20.054]                   }
[09:29:20.054]                 }, immediateCondition = function(cond) {
[09:29:20.054]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.054]                   sendCondition(cond)
[09:29:20.054]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.054]                   {
[09:29:20.054]                     inherits <- base::inherits
[09:29:20.054]                     invokeRestart <- base::invokeRestart
[09:29:20.054]                     is.null <- base::is.null
[09:29:20.054]                     muffled <- FALSE
[09:29:20.054]                     if (inherits(cond, "message")) {
[09:29:20.054]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.054]                       if (muffled) 
[09:29:20.054]                         invokeRestart("muffleMessage")
[09:29:20.054]                     }
[09:29:20.054]                     else if (inherits(cond, "warning")) {
[09:29:20.054]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.054]                       if (muffled) 
[09:29:20.054]                         invokeRestart("muffleWarning")
[09:29:20.054]                     }
[09:29:20.054]                     else if (inherits(cond, "condition")) {
[09:29:20.054]                       if (!is.null(pattern)) {
[09:29:20.054]                         computeRestarts <- base::computeRestarts
[09:29:20.054]                         grepl <- base::grepl
[09:29:20.054]                         restarts <- computeRestarts(cond)
[09:29:20.054]                         for (restart in restarts) {
[09:29:20.054]                           name <- restart$name
[09:29:20.054]                           if (is.null(name)) 
[09:29:20.054]                             next
[09:29:20.054]                           if (!grepl(pattern, name)) 
[09:29:20.054]                             next
[09:29:20.054]                           invokeRestart(restart)
[09:29:20.054]                           muffled <- TRUE
[09:29:20.054]                           break
[09:29:20.054]                         }
[09:29:20.054]                       }
[09:29:20.054]                     }
[09:29:20.054]                     invisible(muffled)
[09:29:20.054]                   }
[09:29:20.054]                   muffleCondition(cond)
[09:29:20.054]                 })
[09:29:20.054]             }))
[09:29:20.054]             future::FutureResult(value = ...future.value$value, 
[09:29:20.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.054]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.054]                     ...future.globalenv.names))
[09:29:20.054]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.054]         }, condition = base::local({
[09:29:20.054]             c <- base::c
[09:29:20.054]             inherits <- base::inherits
[09:29:20.054]             invokeRestart <- base::invokeRestart
[09:29:20.054]             length <- base::length
[09:29:20.054]             list <- base::list
[09:29:20.054]             seq.int <- base::seq.int
[09:29:20.054]             signalCondition <- base::signalCondition
[09:29:20.054]             sys.calls <- base::sys.calls
[09:29:20.054]             `[[` <- base::`[[`
[09:29:20.054]             `+` <- base::`+`
[09:29:20.054]             `<<-` <- base::`<<-`
[09:29:20.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.054]                   3L)]
[09:29:20.054]             }
[09:29:20.054]             function(cond) {
[09:29:20.054]                 is_error <- inherits(cond, "error")
[09:29:20.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.054]                   NULL)
[09:29:20.054]                 if (is_error) {
[09:29:20.054]                   sessionInformation <- function() {
[09:29:20.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.054]                       search = base::search(), system = base::Sys.info())
[09:29:20.054]                   }
[09:29:20.054]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.054]                     cond$call), session = sessionInformation(), 
[09:29:20.054]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.054]                   signalCondition(cond)
[09:29:20.054]                 }
[09:29:20.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.054]                 "immediateCondition"))) {
[09:29:20.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.054]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.054]                   if (TRUE && !signal) {
[09:29:20.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.054]                     {
[09:29:20.054]                       inherits <- base::inherits
[09:29:20.054]                       invokeRestart <- base::invokeRestart
[09:29:20.054]                       is.null <- base::is.null
[09:29:20.054]                       muffled <- FALSE
[09:29:20.054]                       if (inherits(cond, "message")) {
[09:29:20.054]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.054]                         if (muffled) 
[09:29:20.054]                           invokeRestart("muffleMessage")
[09:29:20.054]                       }
[09:29:20.054]                       else if (inherits(cond, "warning")) {
[09:29:20.054]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.054]                         if (muffled) 
[09:29:20.054]                           invokeRestart("muffleWarning")
[09:29:20.054]                       }
[09:29:20.054]                       else if (inherits(cond, "condition")) {
[09:29:20.054]                         if (!is.null(pattern)) {
[09:29:20.054]                           computeRestarts <- base::computeRestarts
[09:29:20.054]                           grepl <- base::grepl
[09:29:20.054]                           restarts <- computeRestarts(cond)
[09:29:20.054]                           for (restart in restarts) {
[09:29:20.054]                             name <- restart$name
[09:29:20.054]                             if (is.null(name)) 
[09:29:20.054]                               next
[09:29:20.054]                             if (!grepl(pattern, name)) 
[09:29:20.054]                               next
[09:29:20.054]                             invokeRestart(restart)
[09:29:20.054]                             muffled <- TRUE
[09:29:20.054]                             break
[09:29:20.054]                           }
[09:29:20.054]                         }
[09:29:20.054]                       }
[09:29:20.054]                       invisible(muffled)
[09:29:20.054]                     }
[09:29:20.054]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.054]                   }
[09:29:20.054]                 }
[09:29:20.054]                 else {
[09:29:20.054]                   if (TRUE) {
[09:29:20.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.054]                     {
[09:29:20.054]                       inherits <- base::inherits
[09:29:20.054]                       invokeRestart <- base::invokeRestart
[09:29:20.054]                       is.null <- base::is.null
[09:29:20.054]                       muffled <- FALSE
[09:29:20.054]                       if (inherits(cond, "message")) {
[09:29:20.054]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.054]                         if (muffled) 
[09:29:20.054]                           invokeRestart("muffleMessage")
[09:29:20.054]                       }
[09:29:20.054]                       else if (inherits(cond, "warning")) {
[09:29:20.054]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.054]                         if (muffled) 
[09:29:20.054]                           invokeRestart("muffleWarning")
[09:29:20.054]                       }
[09:29:20.054]                       else if (inherits(cond, "condition")) {
[09:29:20.054]                         if (!is.null(pattern)) {
[09:29:20.054]                           computeRestarts <- base::computeRestarts
[09:29:20.054]                           grepl <- base::grepl
[09:29:20.054]                           restarts <- computeRestarts(cond)
[09:29:20.054]                           for (restart in restarts) {
[09:29:20.054]                             name <- restart$name
[09:29:20.054]                             if (is.null(name)) 
[09:29:20.054]                               next
[09:29:20.054]                             if (!grepl(pattern, name)) 
[09:29:20.054]                               next
[09:29:20.054]                             invokeRestart(restart)
[09:29:20.054]                             muffled <- TRUE
[09:29:20.054]                             break
[09:29:20.054]                           }
[09:29:20.054]                         }
[09:29:20.054]                       }
[09:29:20.054]                       invisible(muffled)
[09:29:20.054]                     }
[09:29:20.054]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.054]                   }
[09:29:20.054]                 }
[09:29:20.054]             }
[09:29:20.054]         }))
[09:29:20.054]     }, error = function(ex) {
[09:29:20.054]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.054]                 ...future.rng), started = ...future.startTime, 
[09:29:20.054]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.054]             version = "1.8"), class = "FutureResult")
[09:29:20.054]     }, finally = {
[09:29:20.054]         if (!identical(...future.workdir, getwd())) 
[09:29:20.054]             setwd(...future.workdir)
[09:29:20.054]         {
[09:29:20.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.054]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.054]             }
[09:29:20.054]             base::options(...future.oldOptions)
[09:29:20.054]             if (.Platform$OS.type == "windows") {
[09:29:20.054]                 old_names <- names(...future.oldEnvVars)
[09:29:20.054]                 envs <- base::Sys.getenv()
[09:29:20.054]                 names <- names(envs)
[09:29:20.054]                 common <- intersect(names, old_names)
[09:29:20.054]                 added <- setdiff(names, old_names)
[09:29:20.054]                 removed <- setdiff(old_names, names)
[09:29:20.054]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.054]                   envs[common]]
[09:29:20.054]                 NAMES <- toupper(changed)
[09:29:20.054]                 args <- list()
[09:29:20.054]                 for (kk in seq_along(NAMES)) {
[09:29:20.054]                   name <- changed[[kk]]
[09:29:20.054]                   NAME <- NAMES[[kk]]
[09:29:20.054]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.054]                     next
[09:29:20.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.054]                 }
[09:29:20.054]                 NAMES <- toupper(added)
[09:29:20.054]                 for (kk in seq_along(NAMES)) {
[09:29:20.054]                   name <- added[[kk]]
[09:29:20.054]                   NAME <- NAMES[[kk]]
[09:29:20.054]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.054]                     next
[09:29:20.054]                   args[[name]] <- ""
[09:29:20.054]                 }
[09:29:20.054]                 NAMES <- toupper(removed)
[09:29:20.054]                 for (kk in seq_along(NAMES)) {
[09:29:20.054]                   name <- removed[[kk]]
[09:29:20.054]                   NAME <- NAMES[[kk]]
[09:29:20.054]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.054]                     next
[09:29:20.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.054]                 }
[09:29:20.054]                 if (length(args) > 0) 
[09:29:20.054]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.054]             }
[09:29:20.054]             else {
[09:29:20.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.054]             }
[09:29:20.054]             {
[09:29:20.054]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.054]                   0L) {
[09:29:20.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.054]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.054]                   base::options(opts)
[09:29:20.054]                 }
[09:29:20.054]                 {
[09:29:20.054]                   {
[09:29:20.054]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.054]                     NULL
[09:29:20.054]                   }
[09:29:20.054]                   options(future.plan = NULL)
[09:29:20.054]                   if (is.na(NA_character_)) 
[09:29:20.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.054]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.054]                     .init = FALSE)
[09:29:20.054]                 }
[09:29:20.054]             }
[09:29:20.054]         }
[09:29:20.054]     })
[09:29:20.054]     if (TRUE) {
[09:29:20.054]         base::sink(type = "output", split = FALSE)
[09:29:20.054]         if (TRUE) {
[09:29:20.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.054]         }
[09:29:20.054]         else {
[09:29:20.054]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.054]         }
[09:29:20.054]         base::close(...future.stdout)
[09:29:20.054]         ...future.stdout <- NULL
[09:29:20.054]     }
[09:29:20.054]     ...future.result$conditions <- ...future.conditions
[09:29:20.054]     ...future.result$finished <- base::Sys.time()
[09:29:20.054]     ...future.result
[09:29:20.054] }
[09:29:20.056] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[09:29:20.057] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[09:29:20.057] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[09:29:20.057] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:20.057] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.057] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[09:29:20.058] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[09:29:20.058] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:20.058] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.058] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:20.059] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.059] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[09:29:20.059] MultisessionFuture started
[09:29:20.059] - Launch lazy future ... done
[09:29:20.059] run() for ‘MultisessionFuture’ ... done
[09:29:20.059] Created future:
[09:29:20.059] MultisessionFuture:
[09:29:20.059] Label: ‘future_.mapply-1’
[09:29:20.059] Expression:
[09:29:20.059] {
[09:29:20.059]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.059]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.059]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.059]         on.exit(options(oopts), add = TRUE)
[09:29:20.059]     }
[09:29:20.059]     {
[09:29:20.059]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.059]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.059]         do.call(mapply, args = args)
[09:29:20.059]     }
[09:29:20.059] }
[09:29:20.059] Lazy evaluation: FALSE
[09:29:20.059] Asynchronous evaluation: TRUE
[09:29:20.059] Local evaluation: TRUE
[09:29:20.059] Environment: R_GlobalEnv
[09:29:20.059] Capture standard output: TRUE
[09:29:20.059] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.059] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.059] Packages: <none>
[09:29:20.059] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:20.059] Resolved: FALSE
[09:29:20.059] Value: <not collected>
[09:29:20.059] Conditions captured: <none>
[09:29:20.059] Early signaling: FALSE
[09:29:20.059] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.059] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.071] Chunk #1 of 2 ... DONE
[09:29:20.071] Chunk #2 of 2 ...
[09:29:20.071]  - Finding globals in '...' for chunk #2 ...
[09:29:20.071] getGlobalsAndPackages() ...
[09:29:20.071] Searching for globals...
[09:29:20.072] 
[09:29:20.072] Searching for globals ... DONE
[09:29:20.072] - globals: [0] <none>
[09:29:20.072] getGlobalsAndPackages() ... DONE
[09:29:20.072]    + additional globals found: [n=0] 
[09:29:20.072]    + additional namespaces needed: [n=0] 
[09:29:20.072]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:20.072]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:20.072]  - seeds: <none>
[09:29:20.073]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.073] getGlobalsAndPackages() ...
[09:29:20.073] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.073] Resolving globals: FALSE
[09:29:20.073] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[09:29:20.074] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:20.074] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.074] 
[09:29:20.074] getGlobalsAndPackages() ... DONE
[09:29:20.074] run() for ‘Future’ ...
[09:29:20.074] - state: ‘created’
[09:29:20.075] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.088] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.088] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.088]   - Field: ‘node’
[09:29:20.088]   - Field: ‘label’
[09:29:20.088]   - Field: ‘local’
[09:29:20.088]   - Field: ‘owner’
[09:29:20.088]   - Field: ‘envir’
[09:29:20.089]   - Field: ‘workers’
[09:29:20.089]   - Field: ‘packages’
[09:29:20.089]   - Field: ‘gc’
[09:29:20.089]   - Field: ‘conditions’
[09:29:20.089]   - Field: ‘persistent’
[09:29:20.089]   - Field: ‘expr’
[09:29:20.089]   - Field: ‘uuid’
[09:29:20.089]   - Field: ‘seed’
[09:29:20.089]   - Field: ‘version’
[09:29:20.089]   - Field: ‘result’
[09:29:20.089]   - Field: ‘asynchronous’
[09:29:20.090]   - Field: ‘calls’
[09:29:20.090]   - Field: ‘globals’
[09:29:20.090]   - Field: ‘stdout’
[09:29:20.090]   - Field: ‘earlySignal’
[09:29:20.090]   - Field: ‘lazy’
[09:29:20.090]   - Field: ‘state’
[09:29:20.090] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.090] - Launch lazy future ...
[09:29:20.090] Packages needed by the future expression (n = 0): <none>
[09:29:20.091] Packages needed by future strategies (n = 0): <none>
[09:29:20.091] {
[09:29:20.091]     {
[09:29:20.091]         {
[09:29:20.091]             ...future.startTime <- base::Sys.time()
[09:29:20.091]             {
[09:29:20.091]                 {
[09:29:20.091]                   {
[09:29:20.091]                     {
[09:29:20.091]                       base::local({
[09:29:20.091]                         has_future <- base::requireNamespace("future", 
[09:29:20.091]                           quietly = TRUE)
[09:29:20.091]                         if (has_future) {
[09:29:20.091]                           ns <- base::getNamespace("future")
[09:29:20.091]                           version <- ns[[".package"]][["version"]]
[09:29:20.091]                           if (is.null(version)) 
[09:29:20.091]                             version <- utils::packageVersion("future")
[09:29:20.091]                         }
[09:29:20.091]                         else {
[09:29:20.091]                           version <- NULL
[09:29:20.091]                         }
[09:29:20.091]                         if (!has_future || version < "1.8.0") {
[09:29:20.091]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.091]                             "", base::R.version$version.string), 
[09:29:20.091]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:20.091]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:20.091]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.091]                               "release", "version")], collapse = " "), 
[09:29:20.091]                             hostname = base::Sys.info()[["nodename"]])
[09:29:20.091]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.091]                             info)
[09:29:20.091]                           info <- base::paste(info, collapse = "; ")
[09:29:20.091]                           if (!has_future) {
[09:29:20.091]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.091]                               info)
[09:29:20.091]                           }
[09:29:20.091]                           else {
[09:29:20.091]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.091]                               info, version)
[09:29:20.091]                           }
[09:29:20.091]                           base::stop(msg)
[09:29:20.091]                         }
[09:29:20.091]                       })
[09:29:20.091]                     }
[09:29:20.091]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.091]                     base::options(mc.cores = 1L)
[09:29:20.091]                   }
[09:29:20.091]                   ...future.strategy.old <- future::plan("list")
[09:29:20.091]                   options(future.plan = NULL)
[09:29:20.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.091]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.091]                 }
[09:29:20.091]                 ...future.workdir <- getwd()
[09:29:20.091]             }
[09:29:20.091]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.091]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.091]         }
[09:29:20.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.091]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:20.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.091]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.091]             base::names(...future.oldOptions))
[09:29:20.091]     }
[09:29:20.091]     if (FALSE) {
[09:29:20.091]     }
[09:29:20.091]     else {
[09:29:20.091]         if (TRUE) {
[09:29:20.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.091]                 open = "w")
[09:29:20.091]         }
[09:29:20.091]         else {
[09:29:20.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.091]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.091]         }
[09:29:20.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.091]             base::sink(type = "output", split = FALSE)
[09:29:20.091]             base::close(...future.stdout)
[09:29:20.091]         }, add = TRUE)
[09:29:20.091]     }
[09:29:20.091]     ...future.frame <- base::sys.nframe()
[09:29:20.091]     ...future.conditions <- base::list()
[09:29:20.091]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.091]     if (FALSE) {
[09:29:20.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.091]     }
[09:29:20.091]     ...future.result <- base::tryCatch({
[09:29:20.091]         base::withCallingHandlers({
[09:29:20.091]             ...future.value <- base::withVisible(base::local({
[09:29:20.091]                 ...future.makeSendCondition <- base::local({
[09:29:20.091]                   sendCondition <- NULL
[09:29:20.091]                   function(frame = 1L) {
[09:29:20.091]                     if (is.function(sendCondition)) 
[09:29:20.091]                       return(sendCondition)
[09:29:20.091]                     ns <- getNamespace("parallel")
[09:29:20.091]                     if (exists("sendData", mode = "function", 
[09:29:20.091]                       envir = ns)) {
[09:29:20.091]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.091]                         envir = ns)
[09:29:20.091]                       envir <- sys.frame(frame)
[09:29:20.091]                       master <- NULL
[09:29:20.091]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.091]                         !identical(envir, emptyenv())) {
[09:29:20.091]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.091]                           inherits = FALSE)) {
[09:29:20.091]                           master <- get("master", mode = "list", 
[09:29:20.091]                             envir = envir, inherits = FALSE)
[09:29:20.091]                           if (inherits(master, c("SOCKnode", 
[09:29:20.091]                             "SOCK0node"))) {
[09:29:20.091]                             sendCondition <<- function(cond) {
[09:29:20.091]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.091]                                 success = TRUE)
[09:29:20.091]                               parallel_sendData(master, data)
[09:29:20.091]                             }
[09:29:20.091]                             return(sendCondition)
[09:29:20.091]                           }
[09:29:20.091]                         }
[09:29:20.091]                         frame <- frame + 1L
[09:29:20.091]                         envir <- sys.frame(frame)
[09:29:20.091]                       }
[09:29:20.091]                     }
[09:29:20.091]                     sendCondition <<- function(cond) NULL
[09:29:20.091]                   }
[09:29:20.091]                 })
[09:29:20.091]                 withCallingHandlers({
[09:29:20.091]                   {
[09:29:20.091]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.091]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.091]                       ...future.globals.maxSize)) {
[09:29:20.091]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.091]                       on.exit(options(oopts), add = TRUE)
[09:29:20.091]                     }
[09:29:20.091]                     {
[09:29:20.091]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.091]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.091]                         USE.NAMES = FALSE)
[09:29:20.091]                       do.call(mapply, args = args)
[09:29:20.091]                     }
[09:29:20.091]                   }
[09:29:20.091]                 }, immediateCondition = function(cond) {
[09:29:20.091]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.091]                   sendCondition(cond)
[09:29:20.091]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.091]                   {
[09:29:20.091]                     inherits <- base::inherits
[09:29:20.091]                     invokeRestart <- base::invokeRestart
[09:29:20.091]                     is.null <- base::is.null
[09:29:20.091]                     muffled <- FALSE
[09:29:20.091]                     if (inherits(cond, "message")) {
[09:29:20.091]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.091]                       if (muffled) 
[09:29:20.091]                         invokeRestart("muffleMessage")
[09:29:20.091]                     }
[09:29:20.091]                     else if (inherits(cond, "warning")) {
[09:29:20.091]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.091]                       if (muffled) 
[09:29:20.091]                         invokeRestart("muffleWarning")
[09:29:20.091]                     }
[09:29:20.091]                     else if (inherits(cond, "condition")) {
[09:29:20.091]                       if (!is.null(pattern)) {
[09:29:20.091]                         computeRestarts <- base::computeRestarts
[09:29:20.091]                         grepl <- base::grepl
[09:29:20.091]                         restarts <- computeRestarts(cond)
[09:29:20.091]                         for (restart in restarts) {
[09:29:20.091]                           name <- restart$name
[09:29:20.091]                           if (is.null(name)) 
[09:29:20.091]                             next
[09:29:20.091]                           if (!grepl(pattern, name)) 
[09:29:20.091]                             next
[09:29:20.091]                           invokeRestart(restart)
[09:29:20.091]                           muffled <- TRUE
[09:29:20.091]                           break
[09:29:20.091]                         }
[09:29:20.091]                       }
[09:29:20.091]                     }
[09:29:20.091]                     invisible(muffled)
[09:29:20.091]                   }
[09:29:20.091]                   muffleCondition(cond)
[09:29:20.091]                 })
[09:29:20.091]             }))
[09:29:20.091]             future::FutureResult(value = ...future.value$value, 
[09:29:20.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.091]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.091]                     ...future.globalenv.names))
[09:29:20.091]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.091]         }, condition = base::local({
[09:29:20.091]             c <- base::c
[09:29:20.091]             inherits <- base::inherits
[09:29:20.091]             invokeRestart <- base::invokeRestart
[09:29:20.091]             length <- base::length
[09:29:20.091]             list <- base::list
[09:29:20.091]             seq.int <- base::seq.int
[09:29:20.091]             signalCondition <- base::signalCondition
[09:29:20.091]             sys.calls <- base::sys.calls
[09:29:20.091]             `[[` <- base::`[[`
[09:29:20.091]             `+` <- base::`+`
[09:29:20.091]             `<<-` <- base::`<<-`
[09:29:20.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.091]                   3L)]
[09:29:20.091]             }
[09:29:20.091]             function(cond) {
[09:29:20.091]                 is_error <- inherits(cond, "error")
[09:29:20.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.091]                   NULL)
[09:29:20.091]                 if (is_error) {
[09:29:20.091]                   sessionInformation <- function() {
[09:29:20.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.091]                       search = base::search(), system = base::Sys.info())
[09:29:20.091]                   }
[09:29:20.091]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.091]                     cond$call), session = sessionInformation(), 
[09:29:20.091]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.091]                   signalCondition(cond)
[09:29:20.091]                 }
[09:29:20.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.091]                 "immediateCondition"))) {
[09:29:20.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.091]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.091]                   if (TRUE && !signal) {
[09:29:20.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.091]                     {
[09:29:20.091]                       inherits <- base::inherits
[09:29:20.091]                       invokeRestart <- base::invokeRestart
[09:29:20.091]                       is.null <- base::is.null
[09:29:20.091]                       muffled <- FALSE
[09:29:20.091]                       if (inherits(cond, "message")) {
[09:29:20.091]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.091]                         if (muffled) 
[09:29:20.091]                           invokeRestart("muffleMessage")
[09:29:20.091]                       }
[09:29:20.091]                       else if (inherits(cond, "warning")) {
[09:29:20.091]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.091]                         if (muffled) 
[09:29:20.091]                           invokeRestart("muffleWarning")
[09:29:20.091]                       }
[09:29:20.091]                       else if (inherits(cond, "condition")) {
[09:29:20.091]                         if (!is.null(pattern)) {
[09:29:20.091]                           computeRestarts <- base::computeRestarts
[09:29:20.091]                           grepl <- base::grepl
[09:29:20.091]                           restarts <- computeRestarts(cond)
[09:29:20.091]                           for (restart in restarts) {
[09:29:20.091]                             name <- restart$name
[09:29:20.091]                             if (is.null(name)) 
[09:29:20.091]                               next
[09:29:20.091]                             if (!grepl(pattern, name)) 
[09:29:20.091]                               next
[09:29:20.091]                             invokeRestart(restart)
[09:29:20.091]                             muffled <- TRUE
[09:29:20.091]                             break
[09:29:20.091]                           }
[09:29:20.091]                         }
[09:29:20.091]                       }
[09:29:20.091]                       invisible(muffled)
[09:29:20.091]                     }
[09:29:20.091]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.091]                   }
[09:29:20.091]                 }
[09:29:20.091]                 else {
[09:29:20.091]                   if (TRUE) {
[09:29:20.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.091]                     {
[09:29:20.091]                       inherits <- base::inherits
[09:29:20.091]                       invokeRestart <- base::invokeRestart
[09:29:20.091]                       is.null <- base::is.null
[09:29:20.091]                       muffled <- FALSE
[09:29:20.091]                       if (inherits(cond, "message")) {
[09:29:20.091]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.091]                         if (muffled) 
[09:29:20.091]                           invokeRestart("muffleMessage")
[09:29:20.091]                       }
[09:29:20.091]                       else if (inherits(cond, "warning")) {
[09:29:20.091]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.091]                         if (muffled) 
[09:29:20.091]                           invokeRestart("muffleWarning")
[09:29:20.091]                       }
[09:29:20.091]                       else if (inherits(cond, "condition")) {
[09:29:20.091]                         if (!is.null(pattern)) {
[09:29:20.091]                           computeRestarts <- base::computeRestarts
[09:29:20.091]                           grepl <- base::grepl
[09:29:20.091]                           restarts <- computeRestarts(cond)
[09:29:20.091]                           for (restart in restarts) {
[09:29:20.091]                             name <- restart$name
[09:29:20.091]                             if (is.null(name)) 
[09:29:20.091]                               next
[09:29:20.091]                             if (!grepl(pattern, name)) 
[09:29:20.091]                               next
[09:29:20.091]                             invokeRestart(restart)
[09:29:20.091]                             muffled <- TRUE
[09:29:20.091]                             break
[09:29:20.091]                           }
[09:29:20.091]                         }
[09:29:20.091]                       }
[09:29:20.091]                       invisible(muffled)
[09:29:20.091]                     }
[09:29:20.091]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.091]                   }
[09:29:20.091]                 }
[09:29:20.091]             }
[09:29:20.091]         }))
[09:29:20.091]     }, error = function(ex) {
[09:29:20.091]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.091]                 ...future.rng), started = ...future.startTime, 
[09:29:20.091]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.091]             version = "1.8"), class = "FutureResult")
[09:29:20.091]     }, finally = {
[09:29:20.091]         if (!identical(...future.workdir, getwd())) 
[09:29:20.091]             setwd(...future.workdir)
[09:29:20.091]         {
[09:29:20.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.091]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.091]             }
[09:29:20.091]             base::options(...future.oldOptions)
[09:29:20.091]             if (.Platform$OS.type == "windows") {
[09:29:20.091]                 old_names <- names(...future.oldEnvVars)
[09:29:20.091]                 envs <- base::Sys.getenv()
[09:29:20.091]                 names <- names(envs)
[09:29:20.091]                 common <- intersect(names, old_names)
[09:29:20.091]                 added <- setdiff(names, old_names)
[09:29:20.091]                 removed <- setdiff(old_names, names)
[09:29:20.091]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.091]                   envs[common]]
[09:29:20.091]                 NAMES <- toupper(changed)
[09:29:20.091]                 args <- list()
[09:29:20.091]                 for (kk in seq_along(NAMES)) {
[09:29:20.091]                   name <- changed[[kk]]
[09:29:20.091]                   NAME <- NAMES[[kk]]
[09:29:20.091]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.091]                     next
[09:29:20.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.091]                 }
[09:29:20.091]                 NAMES <- toupper(added)
[09:29:20.091]                 for (kk in seq_along(NAMES)) {
[09:29:20.091]                   name <- added[[kk]]
[09:29:20.091]                   NAME <- NAMES[[kk]]
[09:29:20.091]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.091]                     next
[09:29:20.091]                   args[[name]] <- ""
[09:29:20.091]                 }
[09:29:20.091]                 NAMES <- toupper(removed)
[09:29:20.091]                 for (kk in seq_along(NAMES)) {
[09:29:20.091]                   name <- removed[[kk]]
[09:29:20.091]                   NAME <- NAMES[[kk]]
[09:29:20.091]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.091]                     next
[09:29:20.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.091]                 }
[09:29:20.091]                 if (length(args) > 0) 
[09:29:20.091]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.091]             }
[09:29:20.091]             else {
[09:29:20.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.091]             }
[09:29:20.091]             {
[09:29:20.091]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.091]                   0L) {
[09:29:20.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.091]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.091]                   base::options(opts)
[09:29:20.091]                 }
[09:29:20.091]                 {
[09:29:20.091]                   {
[09:29:20.091]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.091]                     NULL
[09:29:20.091]                   }
[09:29:20.091]                   options(future.plan = NULL)
[09:29:20.091]                   if (is.na(NA_character_)) 
[09:29:20.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.091]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.091]                     .init = FALSE)
[09:29:20.091]                 }
[09:29:20.091]             }
[09:29:20.091]         }
[09:29:20.091]     })
[09:29:20.091]     if (TRUE) {
[09:29:20.091]         base::sink(type = "output", split = FALSE)
[09:29:20.091]         if (TRUE) {
[09:29:20.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.091]         }
[09:29:20.091]         else {
[09:29:20.091]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.091]         }
[09:29:20.091]         base::close(...future.stdout)
[09:29:20.091]         ...future.stdout <- NULL
[09:29:20.091]     }
[09:29:20.091]     ...future.result$conditions <- ...future.conditions
[09:29:20.091]     ...future.result$finished <- base::Sys.time()
[09:29:20.091]     ...future.result
[09:29:20.091] }
[09:29:20.094] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[09:29:20.094] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[09:29:20.094] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[09:29:20.094] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:20.095] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:20.095] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[09:29:20.095] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[09:29:20.095] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:20.098] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:20.098] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:20.098] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:20.099] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[09:29:20.099] MultisessionFuture started
[09:29:20.099] - Launch lazy future ... done
[09:29:20.099] run() for ‘MultisessionFuture’ ... done
[09:29:20.099] Created future:
[09:29:20.099] MultisessionFuture:
[09:29:20.099] Label: ‘future_.mapply-2’
[09:29:20.099] Expression:
[09:29:20.099] {
[09:29:20.099]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.099]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.099]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.099]         on.exit(options(oopts), add = TRUE)
[09:29:20.099]     }
[09:29:20.099]     {
[09:29:20.099]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.099]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.099]         do.call(mapply, args = args)
[09:29:20.099]     }
[09:29:20.099] }
[09:29:20.099] Lazy evaluation: FALSE
[09:29:20.099] Asynchronous evaluation: TRUE
[09:29:20.099] Local evaluation: TRUE
[09:29:20.099] Environment: R_GlobalEnv
[09:29:20.099] Capture standard output: TRUE
[09:29:20.099] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.099] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.099] Packages: <none>
[09:29:20.099] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:20.099] Resolved: FALSE
[09:29:20.099] Value: <not collected>
[09:29:20.099] Conditions captured: <none>
[09:29:20.099] Early signaling: FALSE
[09:29:20.099] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.099] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.111] Chunk #2 of 2 ... DONE
[09:29:20.111] Launching 2 futures (chunks) ... DONE
[09:29:20.111] Resolving 2 futures (chunks) ...
[09:29:20.111] resolve() on list ...
[09:29:20.111]  recursive: 0
[09:29:20.111]  length: 2
[09:29:20.111] 
[09:29:20.112] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.112] - Validating connection of MultisessionFuture
[09:29:20.112] - received message: FutureResult
[09:29:20.112] - Received FutureResult
[09:29:20.112] - Erased future from FutureRegistry
[09:29:20.112] result() for ClusterFuture ...
[09:29:20.112] - result already collected: FutureResult
[09:29:20.113] result() for ClusterFuture ... done
[09:29:20.113] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.113] Future #1
[09:29:20.113] result() for ClusterFuture ...
[09:29:20.113] - result already collected: FutureResult
[09:29:20.113] result() for ClusterFuture ... done
[09:29:20.113] result() for ClusterFuture ...
[09:29:20.113] - result already collected: FutureResult
[09:29:20.113] result() for ClusterFuture ... done
[09:29:20.113] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:20.113] - nx: 2
[09:29:20.113] - relay: TRUE
[09:29:20.114] - stdout: TRUE
[09:29:20.114] - signal: TRUE
[09:29:20.114] - resignal: FALSE
[09:29:20.114] - force: TRUE
[09:29:20.114] - relayed: [n=2] FALSE, FALSE
[09:29:20.114] - queued futures: [n=2] FALSE, FALSE
[09:29:20.114]  - until=1
[09:29:20.114]  - relaying element #1
[09:29:20.114] result() for ClusterFuture ...
[09:29:20.114] - result already collected: FutureResult
[09:29:20.114] result() for ClusterFuture ... done
[09:29:20.115] result() for ClusterFuture ...
[09:29:20.115] - result already collected: FutureResult
[09:29:20.115] result() for ClusterFuture ... done
[09:29:20.115] result() for ClusterFuture ...
[09:29:20.115] - result already collected: FutureResult
[09:29:20.115] result() for ClusterFuture ... done
[09:29:20.115] result() for ClusterFuture ...
[09:29:20.115] - result already collected: FutureResult
[09:29:20.115] result() for ClusterFuture ... done
[09:29:20.115] - relayed: [n=2] TRUE, FALSE
[09:29:20.115] - queued futures: [n=2] TRUE, FALSE
[09:29:20.115] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:20.116]  length: 1 (resolved future 1)
[09:29:20.141] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.141] - Validating connection of MultisessionFuture
[09:29:20.142] - received message: FutureResult
[09:29:20.142] - Received FutureResult
[09:29:20.142] - Erased future from FutureRegistry
[09:29:20.142] result() for ClusterFuture ...
[09:29:20.142] - result already collected: FutureResult
[09:29:20.142] result() for ClusterFuture ... done
[09:29:20.142] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.142] Future #2
[09:29:20.142] result() for ClusterFuture ...
[09:29:20.143] - result already collected: FutureResult
[09:29:20.143] result() for ClusterFuture ... done
[09:29:20.143] result() for ClusterFuture ...
[09:29:20.143] - result already collected: FutureResult
[09:29:20.143] result() for ClusterFuture ... done
[09:29:20.143] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:20.143] - nx: 2
[09:29:20.143] - relay: TRUE
[09:29:20.143] - stdout: TRUE
[09:29:20.143] - signal: TRUE
[09:29:20.143] - resignal: FALSE
[09:29:20.144] - force: TRUE
[09:29:20.144] - relayed: [n=2] TRUE, FALSE
[09:29:20.144] - queued futures: [n=2] TRUE, FALSE
[09:29:20.144]  - until=2
[09:29:20.144]  - relaying element #2
[09:29:20.144] result() for ClusterFuture ...
[09:29:20.144] - result already collected: FutureResult
[09:29:20.144] result() for ClusterFuture ... done
[09:29:20.144] result() for ClusterFuture ...
[09:29:20.144] - result already collected: FutureResult
[09:29:20.144] result() for ClusterFuture ... done
[09:29:20.145] result() for ClusterFuture ...
[09:29:20.145] - result already collected: FutureResult
[09:29:20.145] result() for ClusterFuture ... done
[09:29:20.145] result() for ClusterFuture ...
[09:29:20.145] - result already collected: FutureResult
[09:29:20.145] result() for ClusterFuture ... done
[09:29:20.145] - relayed: [n=2] TRUE, TRUE
[09:29:20.145] - queued futures: [n=2] TRUE, TRUE
[09:29:20.145] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:20.145]  length: 0 (resolved future 2)
[09:29:20.145] Relaying remaining futures
[09:29:20.145] signalConditionsASAP(NULL, pos=0) ...
[09:29:20.146] - nx: 2
[09:29:20.146] - relay: TRUE
[09:29:20.146] - stdout: TRUE
[09:29:20.146] - signal: TRUE
[09:29:20.146] - resignal: FALSE
[09:29:20.146] - force: TRUE
[09:29:20.146] - relayed: [n=2] TRUE, TRUE
[09:29:20.146] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:20.146] - relayed: [n=2] TRUE, TRUE
[09:29:20.146] - queued futures: [n=2] TRUE, TRUE
[09:29:20.146] signalConditionsASAP(NULL, pos=0) ... done
[09:29:20.147] resolve() on list ... DONE
[09:29:20.147] result() for ClusterFuture ...
[09:29:20.147] - result already collected: FutureResult
[09:29:20.147] result() for ClusterFuture ... done
[09:29:20.147] result() for ClusterFuture ...
[09:29:20.147] - result already collected: FutureResult
[09:29:20.147] result() for ClusterFuture ... done
[09:29:20.147] result() for ClusterFuture ...
[09:29:20.147] - result already collected: FutureResult
[09:29:20.147] result() for ClusterFuture ... done
[09:29:20.147] result() for ClusterFuture ...
[09:29:20.147] - result already collected: FutureResult
[09:29:20.148] result() for ClusterFuture ... done
[09:29:20.148]  - Number of value chunks collected: 2
[09:29:20.148] Resolving 2 futures (chunks) ... DONE
[09:29:20.148] Reducing values from 2 chunks ...
[09:29:20.148]  - Number of values collected after concatenation: 5
[09:29:20.148]  - Number of values expected: 5
[09:29:20.148] Reducing values from 2 chunks ... DONE
[09:29:20.148] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[09:29:20.149] future_mapply() ...
[09:29:20.152] Number of chunks: 1
[09:29:20.152] getGlobalsAndPackagesXApply() ...
[09:29:20.152]  - future.globals: TRUE
[09:29:20.152] getGlobalsAndPackages() ...
[09:29:20.153] Searching for globals...
[09:29:20.154] - globals found: [1] ‘FUN’
[09:29:20.154] Searching for globals ... DONE
[09:29:20.154] Resolving globals: FALSE
[09:29:20.154] The total size of the 1 globals is 848 bytes (848 bytes)
[09:29:20.154] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:29:20.154] - globals: [1] ‘FUN’
[09:29:20.155] 
[09:29:20.155] getGlobalsAndPackages() ... DONE
[09:29:20.155]  - globals found/used: [n=1] ‘FUN’
[09:29:20.155]  - needed namespaces: [n=0] 
[09:29:20.155] Finding globals ... DONE
[09:29:20.155] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:20.155] List of 2
[09:29:20.155]  $ ...future.FUN:function (x)  
[09:29:20.155]  $ MoreArgs     : NULL
[09:29:20.155]  - attr(*, "where")=List of 2
[09:29:20.155]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:20.155]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:20.155]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:20.155]  - attr(*, "resolved")= logi FALSE
[09:29:20.155]  - attr(*, "total_size")= num NA
[09:29:20.158] Packages to be attached in all futures: [n=0] 
[09:29:20.158] getGlobalsAndPackagesXApply() ... DONE
[09:29:20.158] Number of futures (= number of chunks): 1
[09:29:20.158] Launching 1 futures (chunks) ...
[09:29:20.158] Chunk #1 of 1 ...
[09:29:20.158]  - Finding globals in '...' for chunk #1 ...
[09:29:20.158] getGlobalsAndPackages() ...
[09:29:20.158] Searching for globals...
[09:29:20.159] 
[09:29:20.159] Searching for globals ... DONE
[09:29:20.159] - globals: [0] <none>
[09:29:20.159] getGlobalsAndPackages() ... DONE
[09:29:20.159]    + additional globals found: [n=0] 
[09:29:20.159]    + additional namespaces needed: [n=0] 
[09:29:20.159]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:20.159]  - seeds: <none>
[09:29:20.159]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.160] getGlobalsAndPackages() ...
[09:29:20.160] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.160] Resolving globals: FALSE
[09:29:20.160] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[09:29:20.161] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:20.161] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.161] 
[09:29:20.161] getGlobalsAndPackages() ... DONE
[09:29:20.161] run() for ‘Future’ ...
[09:29:20.161] - state: ‘created’
[09:29:20.162] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.175] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.175] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.176]   - Field: ‘node’
[09:29:20.176]   - Field: ‘label’
[09:29:20.176]   - Field: ‘local’
[09:29:20.176]   - Field: ‘owner’
[09:29:20.176]   - Field: ‘envir’
[09:29:20.176]   - Field: ‘workers’
[09:29:20.176]   - Field: ‘packages’
[09:29:20.176]   - Field: ‘gc’
[09:29:20.176]   - Field: ‘conditions’
[09:29:20.176]   - Field: ‘persistent’
[09:29:20.177]   - Field: ‘expr’
[09:29:20.177]   - Field: ‘uuid’
[09:29:20.177]   - Field: ‘seed’
[09:29:20.177]   - Field: ‘version’
[09:29:20.177]   - Field: ‘result’
[09:29:20.177]   - Field: ‘asynchronous’
[09:29:20.177]   - Field: ‘calls’
[09:29:20.177]   - Field: ‘globals’
[09:29:20.177]   - Field: ‘stdout’
[09:29:20.177]   - Field: ‘earlySignal’
[09:29:20.177]   - Field: ‘lazy’
[09:29:20.178]   - Field: ‘state’
[09:29:20.178] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.178] - Launch lazy future ...
[09:29:20.178] Packages needed by the future expression (n = 0): <none>
[09:29:20.178] Packages needed by future strategies (n = 0): <none>
[09:29:20.179] {
[09:29:20.179]     {
[09:29:20.179]         {
[09:29:20.179]             ...future.startTime <- base::Sys.time()
[09:29:20.179]             {
[09:29:20.179]                 {
[09:29:20.179]                   {
[09:29:20.179]                     {
[09:29:20.179]                       base::local({
[09:29:20.179]                         has_future <- base::requireNamespace("future", 
[09:29:20.179]                           quietly = TRUE)
[09:29:20.179]                         if (has_future) {
[09:29:20.179]                           ns <- base::getNamespace("future")
[09:29:20.179]                           version <- ns[[".package"]][["version"]]
[09:29:20.179]                           if (is.null(version)) 
[09:29:20.179]                             version <- utils::packageVersion("future")
[09:29:20.179]                         }
[09:29:20.179]                         else {
[09:29:20.179]                           version <- NULL
[09:29:20.179]                         }
[09:29:20.179]                         if (!has_future || version < "1.8.0") {
[09:29:20.179]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.179]                             "", base::R.version$version.string), 
[09:29:20.179]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:20.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:20.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.179]                               "release", "version")], collapse = " "), 
[09:29:20.179]                             hostname = base::Sys.info()[["nodename"]])
[09:29:20.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.179]                             info)
[09:29:20.179]                           info <- base::paste(info, collapse = "; ")
[09:29:20.179]                           if (!has_future) {
[09:29:20.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.179]                               info)
[09:29:20.179]                           }
[09:29:20.179]                           else {
[09:29:20.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.179]                               info, version)
[09:29:20.179]                           }
[09:29:20.179]                           base::stop(msg)
[09:29:20.179]                         }
[09:29:20.179]                       })
[09:29:20.179]                     }
[09:29:20.179]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.179]                     base::options(mc.cores = 1L)
[09:29:20.179]                   }
[09:29:20.179]                   ...future.strategy.old <- future::plan("list")
[09:29:20.179]                   options(future.plan = NULL)
[09:29:20.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.179]                 }
[09:29:20.179]                 ...future.workdir <- getwd()
[09:29:20.179]             }
[09:29:20.179]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.179]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.179]         }
[09:29:20.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.179]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:20.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.179]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.179]             base::names(...future.oldOptions))
[09:29:20.179]     }
[09:29:20.179]     if (FALSE) {
[09:29:20.179]     }
[09:29:20.179]     else {
[09:29:20.179]         if (TRUE) {
[09:29:20.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.179]                 open = "w")
[09:29:20.179]         }
[09:29:20.179]         else {
[09:29:20.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.179]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.179]         }
[09:29:20.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.179]             base::sink(type = "output", split = FALSE)
[09:29:20.179]             base::close(...future.stdout)
[09:29:20.179]         }, add = TRUE)
[09:29:20.179]     }
[09:29:20.179]     ...future.frame <- base::sys.nframe()
[09:29:20.179]     ...future.conditions <- base::list()
[09:29:20.179]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.179]     if (FALSE) {
[09:29:20.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.179]     }
[09:29:20.179]     ...future.result <- base::tryCatch({
[09:29:20.179]         base::withCallingHandlers({
[09:29:20.179]             ...future.value <- base::withVisible(base::local({
[09:29:20.179]                 ...future.makeSendCondition <- base::local({
[09:29:20.179]                   sendCondition <- NULL
[09:29:20.179]                   function(frame = 1L) {
[09:29:20.179]                     if (is.function(sendCondition)) 
[09:29:20.179]                       return(sendCondition)
[09:29:20.179]                     ns <- getNamespace("parallel")
[09:29:20.179]                     if (exists("sendData", mode = "function", 
[09:29:20.179]                       envir = ns)) {
[09:29:20.179]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.179]                         envir = ns)
[09:29:20.179]                       envir <- sys.frame(frame)
[09:29:20.179]                       master <- NULL
[09:29:20.179]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.179]                         !identical(envir, emptyenv())) {
[09:29:20.179]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.179]                           inherits = FALSE)) {
[09:29:20.179]                           master <- get("master", mode = "list", 
[09:29:20.179]                             envir = envir, inherits = FALSE)
[09:29:20.179]                           if (inherits(master, c("SOCKnode", 
[09:29:20.179]                             "SOCK0node"))) {
[09:29:20.179]                             sendCondition <<- function(cond) {
[09:29:20.179]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.179]                                 success = TRUE)
[09:29:20.179]                               parallel_sendData(master, data)
[09:29:20.179]                             }
[09:29:20.179]                             return(sendCondition)
[09:29:20.179]                           }
[09:29:20.179]                         }
[09:29:20.179]                         frame <- frame + 1L
[09:29:20.179]                         envir <- sys.frame(frame)
[09:29:20.179]                       }
[09:29:20.179]                     }
[09:29:20.179]                     sendCondition <<- function(cond) NULL
[09:29:20.179]                   }
[09:29:20.179]                 })
[09:29:20.179]                 withCallingHandlers({
[09:29:20.179]                   {
[09:29:20.179]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.179]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.179]                       ...future.globals.maxSize)) {
[09:29:20.179]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.179]                       on.exit(options(oopts), add = TRUE)
[09:29:20.179]                     }
[09:29:20.179]                     {
[09:29:20.179]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.179]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.179]                         USE.NAMES = FALSE)
[09:29:20.179]                       do.call(mapply, args = args)
[09:29:20.179]                     }
[09:29:20.179]                   }
[09:29:20.179]                 }, immediateCondition = function(cond) {
[09:29:20.179]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.179]                   sendCondition(cond)
[09:29:20.179]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.179]                   {
[09:29:20.179]                     inherits <- base::inherits
[09:29:20.179]                     invokeRestart <- base::invokeRestart
[09:29:20.179]                     is.null <- base::is.null
[09:29:20.179]                     muffled <- FALSE
[09:29:20.179]                     if (inherits(cond, "message")) {
[09:29:20.179]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.179]                       if (muffled) 
[09:29:20.179]                         invokeRestart("muffleMessage")
[09:29:20.179]                     }
[09:29:20.179]                     else if (inherits(cond, "warning")) {
[09:29:20.179]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.179]                       if (muffled) 
[09:29:20.179]                         invokeRestart("muffleWarning")
[09:29:20.179]                     }
[09:29:20.179]                     else if (inherits(cond, "condition")) {
[09:29:20.179]                       if (!is.null(pattern)) {
[09:29:20.179]                         computeRestarts <- base::computeRestarts
[09:29:20.179]                         grepl <- base::grepl
[09:29:20.179]                         restarts <- computeRestarts(cond)
[09:29:20.179]                         for (restart in restarts) {
[09:29:20.179]                           name <- restart$name
[09:29:20.179]                           if (is.null(name)) 
[09:29:20.179]                             next
[09:29:20.179]                           if (!grepl(pattern, name)) 
[09:29:20.179]                             next
[09:29:20.179]                           invokeRestart(restart)
[09:29:20.179]                           muffled <- TRUE
[09:29:20.179]                           break
[09:29:20.179]                         }
[09:29:20.179]                       }
[09:29:20.179]                     }
[09:29:20.179]                     invisible(muffled)
[09:29:20.179]                   }
[09:29:20.179]                   muffleCondition(cond)
[09:29:20.179]                 })
[09:29:20.179]             }))
[09:29:20.179]             future::FutureResult(value = ...future.value$value, 
[09:29:20.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.179]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.179]                     ...future.globalenv.names))
[09:29:20.179]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.179]         }, condition = base::local({
[09:29:20.179]             c <- base::c
[09:29:20.179]             inherits <- base::inherits
[09:29:20.179]             invokeRestart <- base::invokeRestart
[09:29:20.179]             length <- base::length
[09:29:20.179]             list <- base::list
[09:29:20.179]             seq.int <- base::seq.int
[09:29:20.179]             signalCondition <- base::signalCondition
[09:29:20.179]             sys.calls <- base::sys.calls
[09:29:20.179]             `[[` <- base::`[[`
[09:29:20.179]             `+` <- base::`+`
[09:29:20.179]             `<<-` <- base::`<<-`
[09:29:20.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.179]                   3L)]
[09:29:20.179]             }
[09:29:20.179]             function(cond) {
[09:29:20.179]                 is_error <- inherits(cond, "error")
[09:29:20.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.179]                   NULL)
[09:29:20.179]                 if (is_error) {
[09:29:20.179]                   sessionInformation <- function() {
[09:29:20.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.179]                       search = base::search(), system = base::Sys.info())
[09:29:20.179]                   }
[09:29:20.179]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.179]                     cond$call), session = sessionInformation(), 
[09:29:20.179]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.179]                   signalCondition(cond)
[09:29:20.179]                 }
[09:29:20.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.179]                 "immediateCondition"))) {
[09:29:20.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.179]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.179]                   if (TRUE && !signal) {
[09:29:20.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.179]                     {
[09:29:20.179]                       inherits <- base::inherits
[09:29:20.179]                       invokeRestart <- base::invokeRestart
[09:29:20.179]                       is.null <- base::is.null
[09:29:20.179]                       muffled <- FALSE
[09:29:20.179]                       if (inherits(cond, "message")) {
[09:29:20.179]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.179]                         if (muffled) 
[09:29:20.179]                           invokeRestart("muffleMessage")
[09:29:20.179]                       }
[09:29:20.179]                       else if (inherits(cond, "warning")) {
[09:29:20.179]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.179]                         if (muffled) 
[09:29:20.179]                           invokeRestart("muffleWarning")
[09:29:20.179]                       }
[09:29:20.179]                       else if (inherits(cond, "condition")) {
[09:29:20.179]                         if (!is.null(pattern)) {
[09:29:20.179]                           computeRestarts <- base::computeRestarts
[09:29:20.179]                           grepl <- base::grepl
[09:29:20.179]                           restarts <- computeRestarts(cond)
[09:29:20.179]                           for (restart in restarts) {
[09:29:20.179]                             name <- restart$name
[09:29:20.179]                             if (is.null(name)) 
[09:29:20.179]                               next
[09:29:20.179]                             if (!grepl(pattern, name)) 
[09:29:20.179]                               next
[09:29:20.179]                             invokeRestart(restart)
[09:29:20.179]                             muffled <- TRUE
[09:29:20.179]                             break
[09:29:20.179]                           }
[09:29:20.179]                         }
[09:29:20.179]                       }
[09:29:20.179]                       invisible(muffled)
[09:29:20.179]                     }
[09:29:20.179]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.179]                   }
[09:29:20.179]                 }
[09:29:20.179]                 else {
[09:29:20.179]                   if (TRUE) {
[09:29:20.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.179]                     {
[09:29:20.179]                       inherits <- base::inherits
[09:29:20.179]                       invokeRestart <- base::invokeRestart
[09:29:20.179]                       is.null <- base::is.null
[09:29:20.179]                       muffled <- FALSE
[09:29:20.179]                       if (inherits(cond, "message")) {
[09:29:20.179]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.179]                         if (muffled) 
[09:29:20.179]                           invokeRestart("muffleMessage")
[09:29:20.179]                       }
[09:29:20.179]                       else if (inherits(cond, "warning")) {
[09:29:20.179]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.179]                         if (muffled) 
[09:29:20.179]                           invokeRestart("muffleWarning")
[09:29:20.179]                       }
[09:29:20.179]                       else if (inherits(cond, "condition")) {
[09:29:20.179]                         if (!is.null(pattern)) {
[09:29:20.179]                           computeRestarts <- base::computeRestarts
[09:29:20.179]                           grepl <- base::grepl
[09:29:20.179]                           restarts <- computeRestarts(cond)
[09:29:20.179]                           for (restart in restarts) {
[09:29:20.179]                             name <- restart$name
[09:29:20.179]                             if (is.null(name)) 
[09:29:20.179]                               next
[09:29:20.179]                             if (!grepl(pattern, name)) 
[09:29:20.179]                               next
[09:29:20.179]                             invokeRestart(restart)
[09:29:20.179]                             muffled <- TRUE
[09:29:20.179]                             break
[09:29:20.179]                           }
[09:29:20.179]                         }
[09:29:20.179]                       }
[09:29:20.179]                       invisible(muffled)
[09:29:20.179]                     }
[09:29:20.179]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.179]                   }
[09:29:20.179]                 }
[09:29:20.179]             }
[09:29:20.179]         }))
[09:29:20.179]     }, error = function(ex) {
[09:29:20.179]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.179]                 ...future.rng), started = ...future.startTime, 
[09:29:20.179]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.179]             version = "1.8"), class = "FutureResult")
[09:29:20.179]     }, finally = {
[09:29:20.179]         if (!identical(...future.workdir, getwd())) 
[09:29:20.179]             setwd(...future.workdir)
[09:29:20.179]         {
[09:29:20.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.179]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.179]             }
[09:29:20.179]             base::options(...future.oldOptions)
[09:29:20.179]             if (.Platform$OS.type == "windows") {
[09:29:20.179]                 old_names <- names(...future.oldEnvVars)
[09:29:20.179]                 envs <- base::Sys.getenv()
[09:29:20.179]                 names <- names(envs)
[09:29:20.179]                 common <- intersect(names, old_names)
[09:29:20.179]                 added <- setdiff(names, old_names)
[09:29:20.179]                 removed <- setdiff(old_names, names)
[09:29:20.179]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.179]                   envs[common]]
[09:29:20.179]                 NAMES <- toupper(changed)
[09:29:20.179]                 args <- list()
[09:29:20.179]                 for (kk in seq_along(NAMES)) {
[09:29:20.179]                   name <- changed[[kk]]
[09:29:20.179]                   NAME <- NAMES[[kk]]
[09:29:20.179]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.179]                     next
[09:29:20.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.179]                 }
[09:29:20.179]                 NAMES <- toupper(added)
[09:29:20.179]                 for (kk in seq_along(NAMES)) {
[09:29:20.179]                   name <- added[[kk]]
[09:29:20.179]                   NAME <- NAMES[[kk]]
[09:29:20.179]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.179]                     next
[09:29:20.179]                   args[[name]] <- ""
[09:29:20.179]                 }
[09:29:20.179]                 NAMES <- toupper(removed)
[09:29:20.179]                 for (kk in seq_along(NAMES)) {
[09:29:20.179]                   name <- removed[[kk]]
[09:29:20.179]                   NAME <- NAMES[[kk]]
[09:29:20.179]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.179]                     next
[09:29:20.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.179]                 }
[09:29:20.179]                 if (length(args) > 0) 
[09:29:20.179]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.179]             }
[09:29:20.179]             else {
[09:29:20.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.179]             }
[09:29:20.179]             {
[09:29:20.179]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.179]                   0L) {
[09:29:20.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.179]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.179]                   base::options(opts)
[09:29:20.179]                 }
[09:29:20.179]                 {
[09:29:20.179]                   {
[09:29:20.179]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.179]                     NULL
[09:29:20.179]                   }
[09:29:20.179]                   options(future.plan = NULL)
[09:29:20.179]                   if (is.na(NA_character_)) 
[09:29:20.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.179]                     .init = FALSE)
[09:29:20.179]                 }
[09:29:20.179]             }
[09:29:20.179]         }
[09:29:20.179]     })
[09:29:20.179]     if (TRUE) {
[09:29:20.179]         base::sink(type = "output", split = FALSE)
[09:29:20.179]         if (TRUE) {
[09:29:20.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.179]         }
[09:29:20.179]         else {
[09:29:20.179]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.179]         }
[09:29:20.179]         base::close(...future.stdout)
[09:29:20.179]         ...future.stdout <- NULL
[09:29:20.179]     }
[09:29:20.179]     ...future.result$conditions <- ...future.conditions
[09:29:20.179]     ...future.result$finished <- base::Sys.time()
[09:29:20.179]     ...future.result
[09:29:20.179] }
[09:29:20.181] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[09:29:20.181] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[09:29:20.182] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[09:29:20.182] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:20.182] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.182] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[09:29:20.182] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[09:29:20.183] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:20.183] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.183] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:20.183] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.183] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[09:29:20.184] MultisessionFuture started
[09:29:20.184] - Launch lazy future ... done
[09:29:20.184] run() for ‘MultisessionFuture’ ... done
[09:29:20.184] Created future:
[09:29:20.184] MultisessionFuture:
[09:29:20.184] Label: ‘future_mapply-1’
[09:29:20.184] Expression:
[09:29:20.184] {
[09:29:20.184]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.184]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.184]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.184]         on.exit(options(oopts), add = TRUE)
[09:29:20.184]     }
[09:29:20.184]     {
[09:29:20.184]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.184]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.184]         do.call(mapply, args = args)
[09:29:20.184]     }
[09:29:20.184] }
[09:29:20.184] Lazy evaluation: FALSE
[09:29:20.184] Asynchronous evaluation: TRUE
[09:29:20.184] Local evaluation: TRUE
[09:29:20.184] Environment: R_GlobalEnv
[09:29:20.184] Capture standard output: TRUE
[09:29:20.184] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.184] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.184] Packages: <none>
[09:29:20.184] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:20.184] Resolved: FALSE
[09:29:20.184] Value: <not collected>
[09:29:20.184] Conditions captured: <none>
[09:29:20.184] Early signaling: FALSE
[09:29:20.184] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.184] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.196] Chunk #1 of 1 ... DONE
[09:29:20.196] Launching 1 futures (chunks) ... DONE
[09:29:20.196] Resolving 1 futures (chunks) ...
[09:29:20.196] resolve() on list ...
[09:29:20.196]  recursive: 0
[09:29:20.196]  length: 1
[09:29:20.196] 
[09:29:20.238] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.238] - Validating connection of MultisessionFuture
[09:29:20.238] - received message: FutureResult
[09:29:20.238] - Received FutureResult
[09:29:20.238] - Erased future from FutureRegistry
[09:29:20.239] result() for ClusterFuture ...
[09:29:20.239] - result already collected: FutureResult
[09:29:20.239] result() for ClusterFuture ... done
[09:29:20.239] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.239] Future #1
[09:29:20.239] result() for ClusterFuture ...
[09:29:20.239] - result already collected: FutureResult
[09:29:20.239] result() for ClusterFuture ... done
[09:29:20.239] result() for ClusterFuture ...
[09:29:20.239] - result already collected: FutureResult
[09:29:20.239] result() for ClusterFuture ... done
[09:29:20.240] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:20.240] - nx: 1
[09:29:20.240] - relay: TRUE
[09:29:20.240] - stdout: TRUE
[09:29:20.240] - signal: TRUE
[09:29:20.240] - resignal: FALSE
[09:29:20.240] - force: TRUE
[09:29:20.240] - relayed: [n=1] FALSE
[09:29:20.240] - queued futures: [n=1] FALSE
[09:29:20.240]  - until=1
[09:29:20.240]  - relaying element #1
[09:29:20.241] result() for ClusterFuture ...
[09:29:20.241] - result already collected: FutureResult
[09:29:20.241] result() for ClusterFuture ... done
[09:29:20.241] result() for ClusterFuture ...
[09:29:20.241] - result already collected: FutureResult
[09:29:20.241] result() for ClusterFuture ... done
[09:29:20.241] result() for ClusterFuture ...
[09:29:20.241] - result already collected: FutureResult
[09:29:20.241] result() for ClusterFuture ... done
[09:29:20.241] result() for ClusterFuture ...
[09:29:20.241] - result already collected: FutureResult
[09:29:20.241] result() for ClusterFuture ... done
[09:29:20.242] - relayed: [n=1] TRUE
[09:29:20.242] - queued futures: [n=1] TRUE
[09:29:20.242] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:20.242]  length: 0 (resolved future 1)
[09:29:20.242] Relaying remaining futures
[09:29:20.242] signalConditionsASAP(NULL, pos=0) ...
[09:29:20.242] - nx: 1
[09:29:20.242] - relay: TRUE
[09:29:20.242] - stdout: TRUE
[09:29:20.242] - signal: TRUE
[09:29:20.242] - resignal: FALSE
[09:29:20.242] - force: TRUE
[09:29:20.243] - relayed: [n=1] TRUE
[09:29:20.243] - queued futures: [n=1] TRUE
 - flush all
[09:29:20.243] - relayed: [n=1] TRUE
[09:29:20.243] - queued futures: [n=1] TRUE
[09:29:20.243] signalConditionsASAP(NULL, pos=0) ... done
[09:29:20.243] resolve() on list ... DONE
[09:29:20.243] result() for ClusterFuture ...
[09:29:20.243] - result already collected: FutureResult
[09:29:20.243] result() for ClusterFuture ... done
[09:29:20.243] result() for ClusterFuture ...
[09:29:20.243] - result already collected: FutureResult
[09:29:20.244] result() for ClusterFuture ... done
[09:29:20.244]  - Number of value chunks collected: 1
[09:29:20.244] Resolving 1 futures (chunks) ... DONE
[09:29:20.244] Reducing values from 1 chunks ...
[09:29:20.244]  - Number of values collected after concatenation: 1
[09:29:20.244]  - Number of values expected: 1
[09:29:20.244] Reducing values from 1 chunks ... DONE
[09:29:20.244] future_mapply() ... DONE
[09:29:20.244] future_mapply() ...
[09:29:20.248] Number of chunks: 1
[09:29:20.248] getGlobalsAndPackagesXApply() ...
[09:29:20.248]  - future.globals: TRUE
[09:29:20.248] getGlobalsAndPackages() ...
[09:29:20.248] Searching for globals...
[09:29:20.249] - globals found: [1] ‘FUN’
[09:29:20.249] Searching for globals ... DONE
[09:29:20.249] Resolving globals: FALSE
[09:29:20.249] The total size of the 1 globals is 848 bytes (848 bytes)
[09:29:20.250] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:29:20.250] - globals: [1] ‘FUN’
[09:29:20.250] 
[09:29:20.250] getGlobalsAndPackages() ... DONE
[09:29:20.250]  - globals found/used: [n=1] ‘FUN’
[09:29:20.250]  - needed namespaces: [n=0] 
[09:29:20.250] Finding globals ... DONE
[09:29:20.251] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:20.251] List of 2
[09:29:20.251]  $ ...future.FUN:function (x)  
[09:29:20.251]  $ MoreArgs     : list()
[09:29:20.251]  - attr(*, "where")=List of 2
[09:29:20.251]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:20.251]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:20.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:20.251]  - attr(*, "resolved")= logi FALSE
[09:29:20.251]  - attr(*, "total_size")= num NA
[09:29:20.253] Packages to be attached in all futures: [n=0] 
[09:29:20.253] getGlobalsAndPackagesXApply() ... DONE
[09:29:20.253] Number of futures (= number of chunks): 1
[09:29:20.253] Launching 1 futures (chunks) ...
[09:29:20.253] Chunk #1 of 1 ...
[09:29:20.254]  - Finding globals in '...' for chunk #1 ...
[09:29:20.254] getGlobalsAndPackages() ...
[09:29:20.254] Searching for globals...
[09:29:20.254] 
[09:29:20.254] Searching for globals ... DONE
[09:29:20.254] - globals: [0] <none>
[09:29:20.254] getGlobalsAndPackages() ... DONE
[09:29:20.254]    + additional globals found: [n=0] 
[09:29:20.254]    + additional namespaces needed: [n=0] 
[09:29:20.255]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:20.255]  - seeds: <none>
[09:29:20.255]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.255] getGlobalsAndPackages() ...
[09:29:20.255] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.255] Resolving globals: FALSE
[09:29:20.255] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[09:29:20.256] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[09:29:20.256] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.256] 
[09:29:20.256] getGlobalsAndPackages() ... DONE
[09:29:20.256] run() for ‘Future’ ...
[09:29:20.257] - state: ‘created’
[09:29:20.257] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.270] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.270] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.270]   - Field: ‘node’
[09:29:20.270]   - Field: ‘label’
[09:29:20.270]   - Field: ‘local’
[09:29:20.271]   - Field: ‘owner’
[09:29:20.271]   - Field: ‘envir’
[09:29:20.271]   - Field: ‘workers’
[09:29:20.271]   - Field: ‘packages’
[09:29:20.271]   - Field: ‘gc’
[09:29:20.271]   - Field: ‘conditions’
[09:29:20.271]   - Field: ‘persistent’
[09:29:20.271]   - Field: ‘expr’
[09:29:20.271]   - Field: ‘uuid’
[09:29:20.271]   - Field: ‘seed’
[09:29:20.271]   - Field: ‘version’
[09:29:20.272]   - Field: ‘result’
[09:29:20.272]   - Field: ‘asynchronous’
[09:29:20.272]   - Field: ‘calls’
[09:29:20.272]   - Field: ‘globals’
[09:29:20.272]   - Field: ‘stdout’
[09:29:20.272]   - Field: ‘earlySignal’
[09:29:20.272]   - Field: ‘lazy’
[09:29:20.272]   - Field: ‘state’
[09:29:20.272] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.272] - Launch lazy future ...
[09:29:20.273] Packages needed by the future expression (n = 0): <none>
[09:29:20.273] Packages needed by future strategies (n = 0): <none>
[09:29:20.273] {
[09:29:20.273]     {
[09:29:20.273]         {
[09:29:20.273]             ...future.startTime <- base::Sys.time()
[09:29:20.273]             {
[09:29:20.273]                 {
[09:29:20.273]                   {
[09:29:20.273]                     {
[09:29:20.273]                       base::local({
[09:29:20.273]                         has_future <- base::requireNamespace("future", 
[09:29:20.273]                           quietly = TRUE)
[09:29:20.273]                         if (has_future) {
[09:29:20.273]                           ns <- base::getNamespace("future")
[09:29:20.273]                           version <- ns[[".package"]][["version"]]
[09:29:20.273]                           if (is.null(version)) 
[09:29:20.273]                             version <- utils::packageVersion("future")
[09:29:20.273]                         }
[09:29:20.273]                         else {
[09:29:20.273]                           version <- NULL
[09:29:20.273]                         }
[09:29:20.273]                         if (!has_future || version < "1.8.0") {
[09:29:20.273]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.273]                             "", base::R.version$version.string), 
[09:29:20.273]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:20.273]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:20.273]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.273]                               "release", "version")], collapse = " "), 
[09:29:20.273]                             hostname = base::Sys.info()[["nodename"]])
[09:29:20.273]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.273]                             info)
[09:29:20.273]                           info <- base::paste(info, collapse = "; ")
[09:29:20.273]                           if (!has_future) {
[09:29:20.273]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.273]                               info)
[09:29:20.273]                           }
[09:29:20.273]                           else {
[09:29:20.273]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.273]                               info, version)
[09:29:20.273]                           }
[09:29:20.273]                           base::stop(msg)
[09:29:20.273]                         }
[09:29:20.273]                       })
[09:29:20.273]                     }
[09:29:20.273]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.273]                     base::options(mc.cores = 1L)
[09:29:20.273]                   }
[09:29:20.273]                   ...future.strategy.old <- future::plan("list")
[09:29:20.273]                   options(future.plan = NULL)
[09:29:20.273]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.273]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.273]                 }
[09:29:20.273]                 ...future.workdir <- getwd()
[09:29:20.273]             }
[09:29:20.273]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.273]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.273]         }
[09:29:20.273]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.273]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:20.273]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.273]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.273]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.273]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.273]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.273]             base::names(...future.oldOptions))
[09:29:20.273]     }
[09:29:20.273]     if (FALSE) {
[09:29:20.273]     }
[09:29:20.273]     else {
[09:29:20.273]         if (TRUE) {
[09:29:20.273]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.273]                 open = "w")
[09:29:20.273]         }
[09:29:20.273]         else {
[09:29:20.273]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.273]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.273]         }
[09:29:20.273]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.273]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.273]             base::sink(type = "output", split = FALSE)
[09:29:20.273]             base::close(...future.stdout)
[09:29:20.273]         }, add = TRUE)
[09:29:20.273]     }
[09:29:20.273]     ...future.frame <- base::sys.nframe()
[09:29:20.273]     ...future.conditions <- base::list()
[09:29:20.273]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.273]     if (FALSE) {
[09:29:20.273]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.273]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.273]     }
[09:29:20.273]     ...future.result <- base::tryCatch({
[09:29:20.273]         base::withCallingHandlers({
[09:29:20.273]             ...future.value <- base::withVisible(base::local({
[09:29:20.273]                 ...future.makeSendCondition <- base::local({
[09:29:20.273]                   sendCondition <- NULL
[09:29:20.273]                   function(frame = 1L) {
[09:29:20.273]                     if (is.function(sendCondition)) 
[09:29:20.273]                       return(sendCondition)
[09:29:20.273]                     ns <- getNamespace("parallel")
[09:29:20.273]                     if (exists("sendData", mode = "function", 
[09:29:20.273]                       envir = ns)) {
[09:29:20.273]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.273]                         envir = ns)
[09:29:20.273]                       envir <- sys.frame(frame)
[09:29:20.273]                       master <- NULL
[09:29:20.273]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.273]                         !identical(envir, emptyenv())) {
[09:29:20.273]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.273]                           inherits = FALSE)) {
[09:29:20.273]                           master <- get("master", mode = "list", 
[09:29:20.273]                             envir = envir, inherits = FALSE)
[09:29:20.273]                           if (inherits(master, c("SOCKnode", 
[09:29:20.273]                             "SOCK0node"))) {
[09:29:20.273]                             sendCondition <<- function(cond) {
[09:29:20.273]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.273]                                 success = TRUE)
[09:29:20.273]                               parallel_sendData(master, data)
[09:29:20.273]                             }
[09:29:20.273]                             return(sendCondition)
[09:29:20.273]                           }
[09:29:20.273]                         }
[09:29:20.273]                         frame <- frame + 1L
[09:29:20.273]                         envir <- sys.frame(frame)
[09:29:20.273]                       }
[09:29:20.273]                     }
[09:29:20.273]                     sendCondition <<- function(cond) NULL
[09:29:20.273]                   }
[09:29:20.273]                 })
[09:29:20.273]                 withCallingHandlers({
[09:29:20.273]                   {
[09:29:20.273]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.273]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.273]                       ...future.globals.maxSize)) {
[09:29:20.273]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.273]                       on.exit(options(oopts), add = TRUE)
[09:29:20.273]                     }
[09:29:20.273]                     {
[09:29:20.273]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.273]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.273]                         USE.NAMES = FALSE)
[09:29:20.273]                       do.call(mapply, args = args)
[09:29:20.273]                     }
[09:29:20.273]                   }
[09:29:20.273]                 }, immediateCondition = function(cond) {
[09:29:20.273]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.273]                   sendCondition(cond)
[09:29:20.273]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.273]                   {
[09:29:20.273]                     inherits <- base::inherits
[09:29:20.273]                     invokeRestart <- base::invokeRestart
[09:29:20.273]                     is.null <- base::is.null
[09:29:20.273]                     muffled <- FALSE
[09:29:20.273]                     if (inherits(cond, "message")) {
[09:29:20.273]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.273]                       if (muffled) 
[09:29:20.273]                         invokeRestart("muffleMessage")
[09:29:20.273]                     }
[09:29:20.273]                     else if (inherits(cond, "warning")) {
[09:29:20.273]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.273]                       if (muffled) 
[09:29:20.273]                         invokeRestart("muffleWarning")
[09:29:20.273]                     }
[09:29:20.273]                     else if (inherits(cond, "condition")) {
[09:29:20.273]                       if (!is.null(pattern)) {
[09:29:20.273]                         computeRestarts <- base::computeRestarts
[09:29:20.273]                         grepl <- base::grepl
[09:29:20.273]                         restarts <- computeRestarts(cond)
[09:29:20.273]                         for (restart in restarts) {
[09:29:20.273]                           name <- restart$name
[09:29:20.273]                           if (is.null(name)) 
[09:29:20.273]                             next
[09:29:20.273]                           if (!grepl(pattern, name)) 
[09:29:20.273]                             next
[09:29:20.273]                           invokeRestart(restart)
[09:29:20.273]                           muffled <- TRUE
[09:29:20.273]                           break
[09:29:20.273]                         }
[09:29:20.273]                       }
[09:29:20.273]                     }
[09:29:20.273]                     invisible(muffled)
[09:29:20.273]                   }
[09:29:20.273]                   muffleCondition(cond)
[09:29:20.273]                 })
[09:29:20.273]             }))
[09:29:20.273]             future::FutureResult(value = ...future.value$value, 
[09:29:20.273]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.273]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.273]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.273]                     ...future.globalenv.names))
[09:29:20.273]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.273]         }, condition = base::local({
[09:29:20.273]             c <- base::c
[09:29:20.273]             inherits <- base::inherits
[09:29:20.273]             invokeRestart <- base::invokeRestart
[09:29:20.273]             length <- base::length
[09:29:20.273]             list <- base::list
[09:29:20.273]             seq.int <- base::seq.int
[09:29:20.273]             signalCondition <- base::signalCondition
[09:29:20.273]             sys.calls <- base::sys.calls
[09:29:20.273]             `[[` <- base::`[[`
[09:29:20.273]             `+` <- base::`+`
[09:29:20.273]             `<<-` <- base::`<<-`
[09:29:20.273]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.273]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.273]                   3L)]
[09:29:20.273]             }
[09:29:20.273]             function(cond) {
[09:29:20.273]                 is_error <- inherits(cond, "error")
[09:29:20.273]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.273]                   NULL)
[09:29:20.273]                 if (is_error) {
[09:29:20.273]                   sessionInformation <- function() {
[09:29:20.273]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.273]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.273]                       search = base::search(), system = base::Sys.info())
[09:29:20.273]                   }
[09:29:20.273]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.273]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.273]                     cond$call), session = sessionInformation(), 
[09:29:20.273]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.273]                   signalCondition(cond)
[09:29:20.273]                 }
[09:29:20.273]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.273]                 "immediateCondition"))) {
[09:29:20.273]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.273]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.273]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.273]                   if (TRUE && !signal) {
[09:29:20.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.273]                     {
[09:29:20.273]                       inherits <- base::inherits
[09:29:20.273]                       invokeRestart <- base::invokeRestart
[09:29:20.273]                       is.null <- base::is.null
[09:29:20.273]                       muffled <- FALSE
[09:29:20.273]                       if (inherits(cond, "message")) {
[09:29:20.273]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.273]                         if (muffled) 
[09:29:20.273]                           invokeRestart("muffleMessage")
[09:29:20.273]                       }
[09:29:20.273]                       else if (inherits(cond, "warning")) {
[09:29:20.273]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.273]                         if (muffled) 
[09:29:20.273]                           invokeRestart("muffleWarning")
[09:29:20.273]                       }
[09:29:20.273]                       else if (inherits(cond, "condition")) {
[09:29:20.273]                         if (!is.null(pattern)) {
[09:29:20.273]                           computeRestarts <- base::computeRestarts
[09:29:20.273]                           grepl <- base::grepl
[09:29:20.273]                           restarts <- computeRestarts(cond)
[09:29:20.273]                           for (restart in restarts) {
[09:29:20.273]                             name <- restart$name
[09:29:20.273]                             if (is.null(name)) 
[09:29:20.273]                               next
[09:29:20.273]                             if (!grepl(pattern, name)) 
[09:29:20.273]                               next
[09:29:20.273]                             invokeRestart(restart)
[09:29:20.273]                             muffled <- TRUE
[09:29:20.273]                             break
[09:29:20.273]                           }
[09:29:20.273]                         }
[09:29:20.273]                       }
[09:29:20.273]                       invisible(muffled)
[09:29:20.273]                     }
[09:29:20.273]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.273]                   }
[09:29:20.273]                 }
[09:29:20.273]                 else {
[09:29:20.273]                   if (TRUE) {
[09:29:20.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.273]                     {
[09:29:20.273]                       inherits <- base::inherits
[09:29:20.273]                       invokeRestart <- base::invokeRestart
[09:29:20.273]                       is.null <- base::is.null
[09:29:20.273]                       muffled <- FALSE
[09:29:20.273]                       if (inherits(cond, "message")) {
[09:29:20.273]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.273]                         if (muffled) 
[09:29:20.273]                           invokeRestart("muffleMessage")
[09:29:20.273]                       }
[09:29:20.273]                       else if (inherits(cond, "warning")) {
[09:29:20.273]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.273]                         if (muffled) 
[09:29:20.273]                           invokeRestart("muffleWarning")
[09:29:20.273]                       }
[09:29:20.273]                       else if (inherits(cond, "condition")) {
[09:29:20.273]                         if (!is.null(pattern)) {
[09:29:20.273]                           computeRestarts <- base::computeRestarts
[09:29:20.273]                           grepl <- base::grepl
[09:29:20.273]                           restarts <- computeRestarts(cond)
[09:29:20.273]                           for (restart in restarts) {
[09:29:20.273]                             name <- restart$name
[09:29:20.273]                             if (is.null(name)) 
[09:29:20.273]                               next
[09:29:20.273]                             if (!grepl(pattern, name)) 
[09:29:20.273]                               next
[09:29:20.273]                             invokeRestart(restart)
[09:29:20.273]                             muffled <- TRUE
[09:29:20.273]                             break
[09:29:20.273]                           }
[09:29:20.273]                         }
[09:29:20.273]                       }
[09:29:20.273]                       invisible(muffled)
[09:29:20.273]                     }
[09:29:20.273]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.273]                   }
[09:29:20.273]                 }
[09:29:20.273]             }
[09:29:20.273]         }))
[09:29:20.273]     }, error = function(ex) {
[09:29:20.273]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.273]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.273]                 ...future.rng), started = ...future.startTime, 
[09:29:20.273]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.273]             version = "1.8"), class = "FutureResult")
[09:29:20.273]     }, finally = {
[09:29:20.273]         if (!identical(...future.workdir, getwd())) 
[09:29:20.273]             setwd(...future.workdir)
[09:29:20.273]         {
[09:29:20.273]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.273]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.273]             }
[09:29:20.273]             base::options(...future.oldOptions)
[09:29:20.273]             if (.Platform$OS.type == "windows") {
[09:29:20.273]                 old_names <- names(...future.oldEnvVars)
[09:29:20.273]                 envs <- base::Sys.getenv()
[09:29:20.273]                 names <- names(envs)
[09:29:20.273]                 common <- intersect(names, old_names)
[09:29:20.273]                 added <- setdiff(names, old_names)
[09:29:20.273]                 removed <- setdiff(old_names, names)
[09:29:20.273]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.273]                   envs[common]]
[09:29:20.273]                 NAMES <- toupper(changed)
[09:29:20.273]                 args <- list()
[09:29:20.273]                 for (kk in seq_along(NAMES)) {
[09:29:20.273]                   name <- changed[[kk]]
[09:29:20.273]                   NAME <- NAMES[[kk]]
[09:29:20.273]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.273]                     next
[09:29:20.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.273]                 }
[09:29:20.273]                 NAMES <- toupper(added)
[09:29:20.273]                 for (kk in seq_along(NAMES)) {
[09:29:20.273]                   name <- added[[kk]]
[09:29:20.273]                   NAME <- NAMES[[kk]]
[09:29:20.273]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.273]                     next
[09:29:20.273]                   args[[name]] <- ""
[09:29:20.273]                 }
[09:29:20.273]                 NAMES <- toupper(removed)
[09:29:20.273]                 for (kk in seq_along(NAMES)) {
[09:29:20.273]                   name <- removed[[kk]]
[09:29:20.273]                   NAME <- NAMES[[kk]]
[09:29:20.273]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.273]                     next
[09:29:20.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.273]                 }
[09:29:20.273]                 if (length(args) > 0) 
[09:29:20.273]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.273]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.273]             }
[09:29:20.273]             else {
[09:29:20.273]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.273]             }
[09:29:20.273]             {
[09:29:20.273]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.273]                   0L) {
[09:29:20.273]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.273]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.273]                   base::options(opts)
[09:29:20.273]                 }
[09:29:20.273]                 {
[09:29:20.273]                   {
[09:29:20.273]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.273]                     NULL
[09:29:20.273]                   }
[09:29:20.273]                   options(future.plan = NULL)
[09:29:20.273]                   if (is.na(NA_character_)) 
[09:29:20.273]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.273]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.273]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.273]                     .init = FALSE)
[09:29:20.273]                 }
[09:29:20.273]             }
[09:29:20.273]         }
[09:29:20.273]     })
[09:29:20.273]     if (TRUE) {
[09:29:20.273]         base::sink(type = "output", split = FALSE)
[09:29:20.273]         if (TRUE) {
[09:29:20.273]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.273]         }
[09:29:20.273]         else {
[09:29:20.273]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.273]         }
[09:29:20.273]         base::close(...future.stdout)
[09:29:20.273]         ...future.stdout <- NULL
[09:29:20.273]     }
[09:29:20.273]     ...future.result$conditions <- ...future.conditions
[09:29:20.273]     ...future.result$finished <- base::Sys.time()
[09:29:20.273]     ...future.result
[09:29:20.273] }
[09:29:20.276] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[09:29:20.276] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[09:29:20.276] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[09:29:20.276] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:20.277] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.277] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[09:29:20.277] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[09:29:20.277] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:20.277] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.278] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:20.278] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.278] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[09:29:20.278] MultisessionFuture started
[09:29:20.278] - Launch lazy future ... done
[09:29:20.279] run() for ‘MultisessionFuture’ ... done
[09:29:20.279] Created future:
[09:29:20.279] MultisessionFuture:
[09:29:20.279] Label: ‘future_.mapply-1’
[09:29:20.279] Expression:
[09:29:20.279] {
[09:29:20.279]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.279]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.279]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.279]         on.exit(options(oopts), add = TRUE)
[09:29:20.279]     }
[09:29:20.279]     {
[09:29:20.279]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.279]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.279]         do.call(mapply, args = args)
[09:29:20.279]     }
[09:29:20.279] }
[09:29:20.279] Lazy evaluation: FALSE
[09:29:20.279] Asynchronous evaluation: TRUE
[09:29:20.279] Local evaluation: TRUE
[09:29:20.279] Environment: R_GlobalEnv
[09:29:20.279] Capture standard output: TRUE
[09:29:20.279] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.279] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.279] Packages: <none>
[09:29:20.279] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:20.279] Resolved: FALSE
[09:29:20.279] Value: <not collected>
[09:29:20.279] Conditions captured: <none>
[09:29:20.279] Early signaling: FALSE
[09:29:20.279] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.279] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.290] Chunk #1 of 1 ... DONE
[09:29:20.290] Launching 1 futures (chunks) ... DONE
[09:29:20.290] Resolving 1 futures (chunks) ...
[09:29:20.290] resolve() on list ...
[09:29:20.291]  recursive: 0
[09:29:20.291]  length: 1
[09:29:20.291] 
[09:29:20.321] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.321] - Validating connection of MultisessionFuture
[09:29:20.321] - received message: FutureResult
[09:29:20.322] - Received FutureResult
[09:29:20.322] - Erased future from FutureRegistry
[09:29:20.322] result() for ClusterFuture ...
[09:29:20.322] - result already collected: FutureResult
[09:29:20.322] result() for ClusterFuture ... done
[09:29:20.322] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.322] Future #1
[09:29:20.322] result() for ClusterFuture ...
[09:29:20.322] - result already collected: FutureResult
[09:29:20.322] result() for ClusterFuture ... done
[09:29:20.322] result() for ClusterFuture ...
[09:29:20.322] - result already collected: FutureResult
[09:29:20.323] result() for ClusterFuture ... done
[09:29:20.323] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:20.323] - nx: 1
[09:29:20.323] - relay: TRUE
[09:29:20.323] - stdout: TRUE
[09:29:20.323] - signal: TRUE
[09:29:20.323] - resignal: FALSE
[09:29:20.323] - force: TRUE
[09:29:20.323] - relayed: [n=1] FALSE
[09:29:20.323] - queued futures: [n=1] FALSE
[09:29:20.323]  - until=1
[09:29:20.323]  - relaying element #1
[09:29:20.324] result() for ClusterFuture ...
[09:29:20.324] - result already collected: FutureResult
[09:29:20.324] result() for ClusterFuture ... done
[09:29:20.324] result() for ClusterFuture ...
[09:29:20.324] - result already collected: FutureResult
[09:29:20.324] result() for ClusterFuture ... done
[09:29:20.324] result() for ClusterFuture ...
[09:29:20.324] - result already collected: FutureResult
[09:29:20.324] result() for ClusterFuture ... done
[09:29:20.324] result() for ClusterFuture ...
[09:29:20.324] - result already collected: FutureResult
[09:29:20.325] result() for ClusterFuture ... done
[09:29:20.325] - relayed: [n=1] TRUE
[09:29:20.325] - queued futures: [n=1] TRUE
[09:29:20.325] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:20.325]  length: 0 (resolved future 1)
[09:29:20.325] Relaying remaining futures
[09:29:20.325] signalConditionsASAP(NULL, pos=0) ...
[09:29:20.325] - nx: 1
[09:29:20.325] - relay: TRUE
[09:29:20.325] - stdout: TRUE
[09:29:20.325] - signal: TRUE
[09:29:20.325] - resignal: FALSE
[09:29:20.326] - force: TRUE
[09:29:20.326] - relayed: [n=1] TRUE
[09:29:20.326] - queued futures: [n=1] TRUE
 - flush all
[09:29:20.326] - relayed: [n=1] TRUE
[09:29:20.326] - queued futures: [n=1] TRUE
[09:29:20.326] signalConditionsASAP(NULL, pos=0) ... done
[09:29:20.326] resolve() on list ... DONE
[09:29:20.326] result() for ClusterFuture ...
[09:29:20.326] - result already collected: FutureResult
[09:29:20.326] result() for ClusterFuture ... done
[09:29:20.326] result() for ClusterFuture ...
[09:29:20.327] - result already collected: FutureResult
[09:29:20.327] result() for ClusterFuture ... done
[09:29:20.327]  - Number of value chunks collected: 1
[09:29:20.327] Resolving 1 futures (chunks) ... DONE
[09:29:20.329] Reducing values from 1 chunks ...
[09:29:20.329]  - Number of values collected after concatenation: 1
[09:29:20.329]  - Number of values expected: 1
[09:29:20.330] Reducing values from 1 chunks ... DONE
[09:29:20.330] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[09:29:20.330] future_mapply() ...
[09:29:20.333] Number of chunks: 2
[09:29:20.333] getGlobalsAndPackagesXApply() ...
[09:29:20.333]  - future.globals: TRUE
[09:29:20.334] getGlobalsAndPackages() ...
[09:29:20.334] Searching for globals...
[09:29:20.335] - globals found: [1] ‘FUN’
[09:29:20.335] Searching for globals ... DONE
[09:29:20.335] Resolving globals: FALSE
[09:29:20.335] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[09:29:20.335] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[09:29:20.335] - globals: [1] ‘FUN’
[09:29:20.336] 
[09:29:20.336] getGlobalsAndPackages() ... DONE
[09:29:20.336]  - globals found/used: [n=1] ‘FUN’
[09:29:20.336]  - needed namespaces: [n=0] 
[09:29:20.336] Finding globals ... DONE
[09:29:20.336] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:20.336] List of 2
[09:29:20.336]  $ ...future.FUN:function (x, y)  
[09:29:20.336]  $ MoreArgs     :List of 1
[09:29:20.336]   ..$ y: int [1:2] 3 4
[09:29:20.336]  - attr(*, "where")=List of 2
[09:29:20.336]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:20.336]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:20.336]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:20.336]  - attr(*, "resolved")= logi FALSE
[09:29:20.336]  - attr(*, "total_size")= num NA
[09:29:20.339] Packages to be attached in all futures: [n=0] 
[09:29:20.339] getGlobalsAndPackagesXApply() ... DONE
[09:29:20.339] Number of futures (= number of chunks): 2
[09:29:20.339] Launching 2 futures (chunks) ...
[09:29:20.339] Chunk #1 of 2 ...
[09:29:20.339]  - Finding globals in '...' for chunk #1 ...
[09:29:20.340] getGlobalsAndPackages() ...
[09:29:20.340] Searching for globals...
[09:29:20.340] 
[09:29:20.340] Searching for globals ... DONE
[09:29:20.340] - globals: [0] <none>
[09:29:20.340] getGlobalsAndPackages() ... DONE
[09:29:20.340]    + additional globals found: [n=0] 
[09:29:20.340]    + additional namespaces needed: [n=0] 
[09:29:20.340]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:20.341]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:20.341]  - seeds: <none>
[09:29:20.341]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.341] getGlobalsAndPackages() ...
[09:29:20.341] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.341] Resolving globals: FALSE
[09:29:20.341] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[09:29:20.342] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[09:29:20.342] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.342] 
[09:29:20.342] getGlobalsAndPackages() ... DONE
[09:29:20.342] run() for ‘Future’ ...
[09:29:20.342] - state: ‘created’
[09:29:20.343] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.357] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.357] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.357]   - Field: ‘node’
[09:29:20.357]   - Field: ‘label’
[09:29:20.357]   - Field: ‘local’
[09:29:20.357]   - Field: ‘owner’
[09:29:20.357]   - Field: ‘envir’
[09:29:20.357]   - Field: ‘workers’
[09:29:20.357]   - Field: ‘packages’
[09:29:20.357]   - Field: ‘gc’
[09:29:20.358]   - Field: ‘conditions’
[09:29:20.358]   - Field: ‘persistent’
[09:29:20.358]   - Field: ‘expr’
[09:29:20.358]   - Field: ‘uuid’
[09:29:20.358]   - Field: ‘seed’
[09:29:20.358]   - Field: ‘version’
[09:29:20.358]   - Field: ‘result’
[09:29:20.358]   - Field: ‘asynchronous’
[09:29:20.358]   - Field: ‘calls’
[09:29:20.358]   - Field: ‘globals’
[09:29:20.358]   - Field: ‘stdout’
[09:29:20.358]   - Field: ‘earlySignal’
[09:29:20.359]   - Field: ‘lazy’
[09:29:20.359]   - Field: ‘state’
[09:29:20.359] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.359] - Launch lazy future ...
[09:29:20.359] Packages needed by the future expression (n = 0): <none>
[09:29:20.359] Packages needed by future strategies (n = 0): <none>
[09:29:20.360] {
[09:29:20.360]     {
[09:29:20.360]         {
[09:29:20.360]             ...future.startTime <- base::Sys.time()
[09:29:20.360]             {
[09:29:20.360]                 {
[09:29:20.360]                   {
[09:29:20.360]                     {
[09:29:20.360]                       base::local({
[09:29:20.360]                         has_future <- base::requireNamespace("future", 
[09:29:20.360]                           quietly = TRUE)
[09:29:20.360]                         if (has_future) {
[09:29:20.360]                           ns <- base::getNamespace("future")
[09:29:20.360]                           version <- ns[[".package"]][["version"]]
[09:29:20.360]                           if (is.null(version)) 
[09:29:20.360]                             version <- utils::packageVersion("future")
[09:29:20.360]                         }
[09:29:20.360]                         else {
[09:29:20.360]                           version <- NULL
[09:29:20.360]                         }
[09:29:20.360]                         if (!has_future || version < "1.8.0") {
[09:29:20.360]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.360]                             "", base::R.version$version.string), 
[09:29:20.360]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:20.360]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:20.360]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.360]                               "release", "version")], collapse = " "), 
[09:29:20.360]                             hostname = base::Sys.info()[["nodename"]])
[09:29:20.360]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.360]                             info)
[09:29:20.360]                           info <- base::paste(info, collapse = "; ")
[09:29:20.360]                           if (!has_future) {
[09:29:20.360]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.360]                               info)
[09:29:20.360]                           }
[09:29:20.360]                           else {
[09:29:20.360]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.360]                               info, version)
[09:29:20.360]                           }
[09:29:20.360]                           base::stop(msg)
[09:29:20.360]                         }
[09:29:20.360]                       })
[09:29:20.360]                     }
[09:29:20.360]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.360]                     base::options(mc.cores = 1L)
[09:29:20.360]                   }
[09:29:20.360]                   ...future.strategy.old <- future::plan("list")
[09:29:20.360]                   options(future.plan = NULL)
[09:29:20.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.360]                 }
[09:29:20.360]                 ...future.workdir <- getwd()
[09:29:20.360]             }
[09:29:20.360]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.360]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.360]         }
[09:29:20.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.360]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:20.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.360]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.360]             base::names(...future.oldOptions))
[09:29:20.360]     }
[09:29:20.360]     if (FALSE) {
[09:29:20.360]     }
[09:29:20.360]     else {
[09:29:20.360]         if (TRUE) {
[09:29:20.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.360]                 open = "w")
[09:29:20.360]         }
[09:29:20.360]         else {
[09:29:20.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.360]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.360]         }
[09:29:20.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.360]             base::sink(type = "output", split = FALSE)
[09:29:20.360]             base::close(...future.stdout)
[09:29:20.360]         }, add = TRUE)
[09:29:20.360]     }
[09:29:20.360]     ...future.frame <- base::sys.nframe()
[09:29:20.360]     ...future.conditions <- base::list()
[09:29:20.360]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.360]     if (FALSE) {
[09:29:20.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.360]     }
[09:29:20.360]     ...future.result <- base::tryCatch({
[09:29:20.360]         base::withCallingHandlers({
[09:29:20.360]             ...future.value <- base::withVisible(base::local({
[09:29:20.360]                 ...future.makeSendCondition <- base::local({
[09:29:20.360]                   sendCondition <- NULL
[09:29:20.360]                   function(frame = 1L) {
[09:29:20.360]                     if (is.function(sendCondition)) 
[09:29:20.360]                       return(sendCondition)
[09:29:20.360]                     ns <- getNamespace("parallel")
[09:29:20.360]                     if (exists("sendData", mode = "function", 
[09:29:20.360]                       envir = ns)) {
[09:29:20.360]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.360]                         envir = ns)
[09:29:20.360]                       envir <- sys.frame(frame)
[09:29:20.360]                       master <- NULL
[09:29:20.360]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.360]                         !identical(envir, emptyenv())) {
[09:29:20.360]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.360]                           inherits = FALSE)) {
[09:29:20.360]                           master <- get("master", mode = "list", 
[09:29:20.360]                             envir = envir, inherits = FALSE)
[09:29:20.360]                           if (inherits(master, c("SOCKnode", 
[09:29:20.360]                             "SOCK0node"))) {
[09:29:20.360]                             sendCondition <<- function(cond) {
[09:29:20.360]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.360]                                 success = TRUE)
[09:29:20.360]                               parallel_sendData(master, data)
[09:29:20.360]                             }
[09:29:20.360]                             return(sendCondition)
[09:29:20.360]                           }
[09:29:20.360]                         }
[09:29:20.360]                         frame <- frame + 1L
[09:29:20.360]                         envir <- sys.frame(frame)
[09:29:20.360]                       }
[09:29:20.360]                     }
[09:29:20.360]                     sendCondition <<- function(cond) NULL
[09:29:20.360]                   }
[09:29:20.360]                 })
[09:29:20.360]                 withCallingHandlers({
[09:29:20.360]                   {
[09:29:20.360]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.360]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.360]                       ...future.globals.maxSize)) {
[09:29:20.360]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.360]                       on.exit(options(oopts), add = TRUE)
[09:29:20.360]                     }
[09:29:20.360]                     {
[09:29:20.360]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.360]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.360]                         USE.NAMES = FALSE)
[09:29:20.360]                       do.call(mapply, args = args)
[09:29:20.360]                     }
[09:29:20.360]                   }
[09:29:20.360]                 }, immediateCondition = function(cond) {
[09:29:20.360]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.360]                   sendCondition(cond)
[09:29:20.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.360]                   {
[09:29:20.360]                     inherits <- base::inherits
[09:29:20.360]                     invokeRestart <- base::invokeRestart
[09:29:20.360]                     is.null <- base::is.null
[09:29:20.360]                     muffled <- FALSE
[09:29:20.360]                     if (inherits(cond, "message")) {
[09:29:20.360]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.360]                       if (muffled) 
[09:29:20.360]                         invokeRestart("muffleMessage")
[09:29:20.360]                     }
[09:29:20.360]                     else if (inherits(cond, "warning")) {
[09:29:20.360]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.360]                       if (muffled) 
[09:29:20.360]                         invokeRestart("muffleWarning")
[09:29:20.360]                     }
[09:29:20.360]                     else if (inherits(cond, "condition")) {
[09:29:20.360]                       if (!is.null(pattern)) {
[09:29:20.360]                         computeRestarts <- base::computeRestarts
[09:29:20.360]                         grepl <- base::grepl
[09:29:20.360]                         restarts <- computeRestarts(cond)
[09:29:20.360]                         for (restart in restarts) {
[09:29:20.360]                           name <- restart$name
[09:29:20.360]                           if (is.null(name)) 
[09:29:20.360]                             next
[09:29:20.360]                           if (!grepl(pattern, name)) 
[09:29:20.360]                             next
[09:29:20.360]                           invokeRestart(restart)
[09:29:20.360]                           muffled <- TRUE
[09:29:20.360]                           break
[09:29:20.360]                         }
[09:29:20.360]                       }
[09:29:20.360]                     }
[09:29:20.360]                     invisible(muffled)
[09:29:20.360]                   }
[09:29:20.360]                   muffleCondition(cond)
[09:29:20.360]                 })
[09:29:20.360]             }))
[09:29:20.360]             future::FutureResult(value = ...future.value$value, 
[09:29:20.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.360]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.360]                     ...future.globalenv.names))
[09:29:20.360]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.360]         }, condition = base::local({
[09:29:20.360]             c <- base::c
[09:29:20.360]             inherits <- base::inherits
[09:29:20.360]             invokeRestart <- base::invokeRestart
[09:29:20.360]             length <- base::length
[09:29:20.360]             list <- base::list
[09:29:20.360]             seq.int <- base::seq.int
[09:29:20.360]             signalCondition <- base::signalCondition
[09:29:20.360]             sys.calls <- base::sys.calls
[09:29:20.360]             `[[` <- base::`[[`
[09:29:20.360]             `+` <- base::`+`
[09:29:20.360]             `<<-` <- base::`<<-`
[09:29:20.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.360]                   3L)]
[09:29:20.360]             }
[09:29:20.360]             function(cond) {
[09:29:20.360]                 is_error <- inherits(cond, "error")
[09:29:20.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.360]                   NULL)
[09:29:20.360]                 if (is_error) {
[09:29:20.360]                   sessionInformation <- function() {
[09:29:20.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.360]                       search = base::search(), system = base::Sys.info())
[09:29:20.360]                   }
[09:29:20.360]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.360]                     cond$call), session = sessionInformation(), 
[09:29:20.360]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.360]                   signalCondition(cond)
[09:29:20.360]                 }
[09:29:20.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.360]                 "immediateCondition"))) {
[09:29:20.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.360]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.360]                   if (TRUE && !signal) {
[09:29:20.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.360]                     {
[09:29:20.360]                       inherits <- base::inherits
[09:29:20.360]                       invokeRestart <- base::invokeRestart
[09:29:20.360]                       is.null <- base::is.null
[09:29:20.360]                       muffled <- FALSE
[09:29:20.360]                       if (inherits(cond, "message")) {
[09:29:20.360]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.360]                         if (muffled) 
[09:29:20.360]                           invokeRestart("muffleMessage")
[09:29:20.360]                       }
[09:29:20.360]                       else if (inherits(cond, "warning")) {
[09:29:20.360]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.360]                         if (muffled) 
[09:29:20.360]                           invokeRestart("muffleWarning")
[09:29:20.360]                       }
[09:29:20.360]                       else if (inherits(cond, "condition")) {
[09:29:20.360]                         if (!is.null(pattern)) {
[09:29:20.360]                           computeRestarts <- base::computeRestarts
[09:29:20.360]                           grepl <- base::grepl
[09:29:20.360]                           restarts <- computeRestarts(cond)
[09:29:20.360]                           for (restart in restarts) {
[09:29:20.360]                             name <- restart$name
[09:29:20.360]                             if (is.null(name)) 
[09:29:20.360]                               next
[09:29:20.360]                             if (!grepl(pattern, name)) 
[09:29:20.360]                               next
[09:29:20.360]                             invokeRestart(restart)
[09:29:20.360]                             muffled <- TRUE
[09:29:20.360]                             break
[09:29:20.360]                           }
[09:29:20.360]                         }
[09:29:20.360]                       }
[09:29:20.360]                       invisible(muffled)
[09:29:20.360]                     }
[09:29:20.360]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.360]                   }
[09:29:20.360]                 }
[09:29:20.360]                 else {
[09:29:20.360]                   if (TRUE) {
[09:29:20.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.360]                     {
[09:29:20.360]                       inherits <- base::inherits
[09:29:20.360]                       invokeRestart <- base::invokeRestart
[09:29:20.360]                       is.null <- base::is.null
[09:29:20.360]                       muffled <- FALSE
[09:29:20.360]                       if (inherits(cond, "message")) {
[09:29:20.360]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.360]                         if (muffled) 
[09:29:20.360]                           invokeRestart("muffleMessage")
[09:29:20.360]                       }
[09:29:20.360]                       else if (inherits(cond, "warning")) {
[09:29:20.360]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.360]                         if (muffled) 
[09:29:20.360]                           invokeRestart("muffleWarning")
[09:29:20.360]                       }
[09:29:20.360]                       else if (inherits(cond, "condition")) {
[09:29:20.360]                         if (!is.null(pattern)) {
[09:29:20.360]                           computeRestarts <- base::computeRestarts
[09:29:20.360]                           grepl <- base::grepl
[09:29:20.360]                           restarts <- computeRestarts(cond)
[09:29:20.360]                           for (restart in restarts) {
[09:29:20.360]                             name <- restart$name
[09:29:20.360]                             if (is.null(name)) 
[09:29:20.360]                               next
[09:29:20.360]                             if (!grepl(pattern, name)) 
[09:29:20.360]                               next
[09:29:20.360]                             invokeRestart(restart)
[09:29:20.360]                             muffled <- TRUE
[09:29:20.360]                             break
[09:29:20.360]                           }
[09:29:20.360]                         }
[09:29:20.360]                       }
[09:29:20.360]                       invisible(muffled)
[09:29:20.360]                     }
[09:29:20.360]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.360]                   }
[09:29:20.360]                 }
[09:29:20.360]             }
[09:29:20.360]         }))
[09:29:20.360]     }, error = function(ex) {
[09:29:20.360]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.360]                 ...future.rng), started = ...future.startTime, 
[09:29:20.360]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.360]             version = "1.8"), class = "FutureResult")
[09:29:20.360]     }, finally = {
[09:29:20.360]         if (!identical(...future.workdir, getwd())) 
[09:29:20.360]             setwd(...future.workdir)
[09:29:20.360]         {
[09:29:20.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.360]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.360]             }
[09:29:20.360]             base::options(...future.oldOptions)
[09:29:20.360]             if (.Platform$OS.type == "windows") {
[09:29:20.360]                 old_names <- names(...future.oldEnvVars)
[09:29:20.360]                 envs <- base::Sys.getenv()
[09:29:20.360]                 names <- names(envs)
[09:29:20.360]                 common <- intersect(names, old_names)
[09:29:20.360]                 added <- setdiff(names, old_names)
[09:29:20.360]                 removed <- setdiff(old_names, names)
[09:29:20.360]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.360]                   envs[common]]
[09:29:20.360]                 NAMES <- toupper(changed)
[09:29:20.360]                 args <- list()
[09:29:20.360]                 for (kk in seq_along(NAMES)) {
[09:29:20.360]                   name <- changed[[kk]]
[09:29:20.360]                   NAME <- NAMES[[kk]]
[09:29:20.360]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.360]                     next
[09:29:20.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.360]                 }
[09:29:20.360]                 NAMES <- toupper(added)
[09:29:20.360]                 for (kk in seq_along(NAMES)) {
[09:29:20.360]                   name <- added[[kk]]
[09:29:20.360]                   NAME <- NAMES[[kk]]
[09:29:20.360]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.360]                     next
[09:29:20.360]                   args[[name]] <- ""
[09:29:20.360]                 }
[09:29:20.360]                 NAMES <- toupper(removed)
[09:29:20.360]                 for (kk in seq_along(NAMES)) {
[09:29:20.360]                   name <- removed[[kk]]
[09:29:20.360]                   NAME <- NAMES[[kk]]
[09:29:20.360]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.360]                     next
[09:29:20.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.360]                 }
[09:29:20.360]                 if (length(args) > 0) 
[09:29:20.360]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.360]             }
[09:29:20.360]             else {
[09:29:20.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.360]             }
[09:29:20.360]             {
[09:29:20.360]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.360]                   0L) {
[09:29:20.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.360]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.360]                   base::options(opts)
[09:29:20.360]                 }
[09:29:20.360]                 {
[09:29:20.360]                   {
[09:29:20.360]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.360]                     NULL
[09:29:20.360]                   }
[09:29:20.360]                   options(future.plan = NULL)
[09:29:20.360]                   if (is.na(NA_character_)) 
[09:29:20.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.360]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.360]                     .init = FALSE)
[09:29:20.360]                 }
[09:29:20.360]             }
[09:29:20.360]         }
[09:29:20.360]     })
[09:29:20.360]     if (TRUE) {
[09:29:20.360]         base::sink(type = "output", split = FALSE)
[09:29:20.360]         if (TRUE) {
[09:29:20.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.360]         }
[09:29:20.360]         else {
[09:29:20.360]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.360]         }
[09:29:20.360]         base::close(...future.stdout)
[09:29:20.360]         ...future.stdout <- NULL
[09:29:20.360]     }
[09:29:20.360]     ...future.result$conditions <- ...future.conditions
[09:29:20.360]     ...future.result$finished <- base::Sys.time()
[09:29:20.360]     ...future.result
[09:29:20.360] }
[09:29:20.362] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[09:29:20.362] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[09:29:20.363] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[09:29:20.363] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[09:29:20.363] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[09:29:20.363] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[09:29:20.364] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[09:29:20.364] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:20.364] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.364] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:20.364] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.364] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[09:29:20.365] MultisessionFuture started
[09:29:20.365] - Launch lazy future ... done
[09:29:20.365] run() for ‘MultisessionFuture’ ... done
[09:29:20.365] Created future:
[09:29:20.365] MultisessionFuture:
[09:29:20.365] Label: ‘future_mapply-1’
[09:29:20.365] Expression:
[09:29:20.365] {
[09:29:20.365]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.365]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.365]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.365]         on.exit(options(oopts), add = TRUE)
[09:29:20.365]     }
[09:29:20.365]     {
[09:29:20.365]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.365]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.365]         do.call(mapply, args = args)
[09:29:20.365]     }
[09:29:20.365] }
[09:29:20.365] Lazy evaluation: FALSE
[09:29:20.365] Asynchronous evaluation: TRUE
[09:29:20.365] Local evaluation: TRUE
[09:29:20.365] Environment: R_GlobalEnv
[09:29:20.365] Capture standard output: TRUE
[09:29:20.365] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.365] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.365] Packages: <none>
[09:29:20.365] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:20.365] Resolved: FALSE
[09:29:20.365] Value: <not collected>
[09:29:20.365] Conditions captured: <none>
[09:29:20.365] Early signaling: FALSE
[09:29:20.365] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.365] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.377] Chunk #1 of 2 ... DONE
[09:29:20.377] Chunk #2 of 2 ...
[09:29:20.377]  - Finding globals in '...' for chunk #2 ...
[09:29:20.377] getGlobalsAndPackages() ...
[09:29:20.377] Searching for globals...
[09:29:20.377] 
[09:29:20.377] Searching for globals ... DONE
[09:29:20.378] - globals: [0] <none>
[09:29:20.378] getGlobalsAndPackages() ... DONE
[09:29:20.378]    + additional globals found: [n=0] 
[09:29:20.378]    + additional namespaces needed: [n=0] 
[09:29:20.378]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:20.378]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:20.378]  - seeds: <none>
[09:29:20.378]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.378] getGlobalsAndPackages() ...
[09:29:20.378] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.378] Resolving globals: FALSE
[09:29:20.379] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[09:29:20.379] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[09:29:20.379] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.380] 
[09:29:20.380] getGlobalsAndPackages() ... DONE
[09:29:20.380] run() for ‘Future’ ...
[09:29:20.380] - state: ‘created’
[09:29:20.380] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.393] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.394] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.394]   - Field: ‘node’
[09:29:20.394]   - Field: ‘label’
[09:29:20.394]   - Field: ‘local’
[09:29:20.394]   - Field: ‘owner’
[09:29:20.394]   - Field: ‘envir’
[09:29:20.394]   - Field: ‘workers’
[09:29:20.394]   - Field: ‘packages’
[09:29:20.394]   - Field: ‘gc’
[09:29:20.394]   - Field: ‘conditions’
[09:29:20.394]   - Field: ‘persistent’
[09:29:20.395]   - Field: ‘expr’
[09:29:20.395]   - Field: ‘uuid’
[09:29:20.395]   - Field: ‘seed’
[09:29:20.395]   - Field: ‘version’
[09:29:20.395]   - Field: ‘result’
[09:29:20.395]   - Field: ‘asynchronous’
[09:29:20.395]   - Field: ‘calls’
[09:29:20.395]   - Field: ‘globals’
[09:29:20.395]   - Field: ‘stdout’
[09:29:20.395]   - Field: ‘earlySignal’
[09:29:20.395]   - Field: ‘lazy’
[09:29:20.396]   - Field: ‘state’
[09:29:20.396] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.396] - Launch lazy future ...
[09:29:20.396] Packages needed by the future expression (n = 0): <none>
[09:29:20.396] Packages needed by future strategies (n = 0): <none>
[09:29:20.397] {
[09:29:20.397]     {
[09:29:20.397]         {
[09:29:20.397]             ...future.startTime <- base::Sys.time()
[09:29:20.397]             {
[09:29:20.397]                 {
[09:29:20.397]                   {
[09:29:20.397]                     {
[09:29:20.397]                       base::local({
[09:29:20.397]                         has_future <- base::requireNamespace("future", 
[09:29:20.397]                           quietly = TRUE)
[09:29:20.397]                         if (has_future) {
[09:29:20.397]                           ns <- base::getNamespace("future")
[09:29:20.397]                           version <- ns[[".package"]][["version"]]
[09:29:20.397]                           if (is.null(version)) 
[09:29:20.397]                             version <- utils::packageVersion("future")
[09:29:20.397]                         }
[09:29:20.397]                         else {
[09:29:20.397]                           version <- NULL
[09:29:20.397]                         }
[09:29:20.397]                         if (!has_future || version < "1.8.0") {
[09:29:20.397]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.397]                             "", base::R.version$version.string), 
[09:29:20.397]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:20.397]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:20.397]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.397]                               "release", "version")], collapse = " "), 
[09:29:20.397]                             hostname = base::Sys.info()[["nodename"]])
[09:29:20.397]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.397]                             info)
[09:29:20.397]                           info <- base::paste(info, collapse = "; ")
[09:29:20.397]                           if (!has_future) {
[09:29:20.397]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.397]                               info)
[09:29:20.397]                           }
[09:29:20.397]                           else {
[09:29:20.397]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.397]                               info, version)
[09:29:20.397]                           }
[09:29:20.397]                           base::stop(msg)
[09:29:20.397]                         }
[09:29:20.397]                       })
[09:29:20.397]                     }
[09:29:20.397]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.397]                     base::options(mc.cores = 1L)
[09:29:20.397]                   }
[09:29:20.397]                   ...future.strategy.old <- future::plan("list")
[09:29:20.397]                   options(future.plan = NULL)
[09:29:20.397]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.397]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.397]                 }
[09:29:20.397]                 ...future.workdir <- getwd()
[09:29:20.397]             }
[09:29:20.397]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.397]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.397]         }
[09:29:20.397]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.397]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:20.397]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.397]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.397]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.397]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.397]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.397]             base::names(...future.oldOptions))
[09:29:20.397]     }
[09:29:20.397]     if (FALSE) {
[09:29:20.397]     }
[09:29:20.397]     else {
[09:29:20.397]         if (TRUE) {
[09:29:20.397]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.397]                 open = "w")
[09:29:20.397]         }
[09:29:20.397]         else {
[09:29:20.397]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.397]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.397]         }
[09:29:20.397]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.397]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.397]             base::sink(type = "output", split = FALSE)
[09:29:20.397]             base::close(...future.stdout)
[09:29:20.397]         }, add = TRUE)
[09:29:20.397]     }
[09:29:20.397]     ...future.frame <- base::sys.nframe()
[09:29:20.397]     ...future.conditions <- base::list()
[09:29:20.397]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.397]     if (FALSE) {
[09:29:20.397]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.397]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.397]     }
[09:29:20.397]     ...future.result <- base::tryCatch({
[09:29:20.397]         base::withCallingHandlers({
[09:29:20.397]             ...future.value <- base::withVisible(base::local({
[09:29:20.397]                 ...future.makeSendCondition <- base::local({
[09:29:20.397]                   sendCondition <- NULL
[09:29:20.397]                   function(frame = 1L) {
[09:29:20.397]                     if (is.function(sendCondition)) 
[09:29:20.397]                       return(sendCondition)
[09:29:20.397]                     ns <- getNamespace("parallel")
[09:29:20.397]                     if (exists("sendData", mode = "function", 
[09:29:20.397]                       envir = ns)) {
[09:29:20.397]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.397]                         envir = ns)
[09:29:20.397]                       envir <- sys.frame(frame)
[09:29:20.397]                       master <- NULL
[09:29:20.397]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.397]                         !identical(envir, emptyenv())) {
[09:29:20.397]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.397]                           inherits = FALSE)) {
[09:29:20.397]                           master <- get("master", mode = "list", 
[09:29:20.397]                             envir = envir, inherits = FALSE)
[09:29:20.397]                           if (inherits(master, c("SOCKnode", 
[09:29:20.397]                             "SOCK0node"))) {
[09:29:20.397]                             sendCondition <<- function(cond) {
[09:29:20.397]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.397]                                 success = TRUE)
[09:29:20.397]                               parallel_sendData(master, data)
[09:29:20.397]                             }
[09:29:20.397]                             return(sendCondition)
[09:29:20.397]                           }
[09:29:20.397]                         }
[09:29:20.397]                         frame <- frame + 1L
[09:29:20.397]                         envir <- sys.frame(frame)
[09:29:20.397]                       }
[09:29:20.397]                     }
[09:29:20.397]                     sendCondition <<- function(cond) NULL
[09:29:20.397]                   }
[09:29:20.397]                 })
[09:29:20.397]                 withCallingHandlers({
[09:29:20.397]                   {
[09:29:20.397]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.397]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.397]                       ...future.globals.maxSize)) {
[09:29:20.397]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.397]                       on.exit(options(oopts), add = TRUE)
[09:29:20.397]                     }
[09:29:20.397]                     {
[09:29:20.397]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.397]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.397]                         USE.NAMES = FALSE)
[09:29:20.397]                       do.call(mapply, args = args)
[09:29:20.397]                     }
[09:29:20.397]                   }
[09:29:20.397]                 }, immediateCondition = function(cond) {
[09:29:20.397]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.397]                   sendCondition(cond)
[09:29:20.397]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.397]                   {
[09:29:20.397]                     inherits <- base::inherits
[09:29:20.397]                     invokeRestart <- base::invokeRestart
[09:29:20.397]                     is.null <- base::is.null
[09:29:20.397]                     muffled <- FALSE
[09:29:20.397]                     if (inherits(cond, "message")) {
[09:29:20.397]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.397]                       if (muffled) 
[09:29:20.397]                         invokeRestart("muffleMessage")
[09:29:20.397]                     }
[09:29:20.397]                     else if (inherits(cond, "warning")) {
[09:29:20.397]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.397]                       if (muffled) 
[09:29:20.397]                         invokeRestart("muffleWarning")
[09:29:20.397]                     }
[09:29:20.397]                     else if (inherits(cond, "condition")) {
[09:29:20.397]                       if (!is.null(pattern)) {
[09:29:20.397]                         computeRestarts <- base::computeRestarts
[09:29:20.397]                         grepl <- base::grepl
[09:29:20.397]                         restarts <- computeRestarts(cond)
[09:29:20.397]                         for (restart in restarts) {
[09:29:20.397]                           name <- restart$name
[09:29:20.397]                           if (is.null(name)) 
[09:29:20.397]                             next
[09:29:20.397]                           if (!grepl(pattern, name)) 
[09:29:20.397]                             next
[09:29:20.397]                           invokeRestart(restart)
[09:29:20.397]                           muffled <- TRUE
[09:29:20.397]                           break
[09:29:20.397]                         }
[09:29:20.397]                       }
[09:29:20.397]                     }
[09:29:20.397]                     invisible(muffled)
[09:29:20.397]                   }
[09:29:20.397]                   muffleCondition(cond)
[09:29:20.397]                 })
[09:29:20.397]             }))
[09:29:20.397]             future::FutureResult(value = ...future.value$value, 
[09:29:20.397]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.397]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.397]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.397]                     ...future.globalenv.names))
[09:29:20.397]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.397]         }, condition = base::local({
[09:29:20.397]             c <- base::c
[09:29:20.397]             inherits <- base::inherits
[09:29:20.397]             invokeRestart <- base::invokeRestart
[09:29:20.397]             length <- base::length
[09:29:20.397]             list <- base::list
[09:29:20.397]             seq.int <- base::seq.int
[09:29:20.397]             signalCondition <- base::signalCondition
[09:29:20.397]             sys.calls <- base::sys.calls
[09:29:20.397]             `[[` <- base::`[[`
[09:29:20.397]             `+` <- base::`+`
[09:29:20.397]             `<<-` <- base::`<<-`
[09:29:20.397]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.397]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.397]                   3L)]
[09:29:20.397]             }
[09:29:20.397]             function(cond) {
[09:29:20.397]                 is_error <- inherits(cond, "error")
[09:29:20.397]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.397]                   NULL)
[09:29:20.397]                 if (is_error) {
[09:29:20.397]                   sessionInformation <- function() {
[09:29:20.397]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.397]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.397]                       search = base::search(), system = base::Sys.info())
[09:29:20.397]                   }
[09:29:20.397]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.397]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.397]                     cond$call), session = sessionInformation(), 
[09:29:20.397]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.397]                   signalCondition(cond)
[09:29:20.397]                 }
[09:29:20.397]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.397]                 "immediateCondition"))) {
[09:29:20.397]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.397]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.397]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.397]                   if (TRUE && !signal) {
[09:29:20.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.397]                     {
[09:29:20.397]                       inherits <- base::inherits
[09:29:20.397]                       invokeRestart <- base::invokeRestart
[09:29:20.397]                       is.null <- base::is.null
[09:29:20.397]                       muffled <- FALSE
[09:29:20.397]                       if (inherits(cond, "message")) {
[09:29:20.397]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.397]                         if (muffled) 
[09:29:20.397]                           invokeRestart("muffleMessage")
[09:29:20.397]                       }
[09:29:20.397]                       else if (inherits(cond, "warning")) {
[09:29:20.397]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.397]                         if (muffled) 
[09:29:20.397]                           invokeRestart("muffleWarning")
[09:29:20.397]                       }
[09:29:20.397]                       else if (inherits(cond, "condition")) {
[09:29:20.397]                         if (!is.null(pattern)) {
[09:29:20.397]                           computeRestarts <- base::computeRestarts
[09:29:20.397]                           grepl <- base::grepl
[09:29:20.397]                           restarts <- computeRestarts(cond)
[09:29:20.397]                           for (restart in restarts) {
[09:29:20.397]                             name <- restart$name
[09:29:20.397]                             if (is.null(name)) 
[09:29:20.397]                               next
[09:29:20.397]                             if (!grepl(pattern, name)) 
[09:29:20.397]                               next
[09:29:20.397]                             invokeRestart(restart)
[09:29:20.397]                             muffled <- TRUE
[09:29:20.397]                             break
[09:29:20.397]                           }
[09:29:20.397]                         }
[09:29:20.397]                       }
[09:29:20.397]                       invisible(muffled)
[09:29:20.397]                     }
[09:29:20.397]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.397]                   }
[09:29:20.397]                 }
[09:29:20.397]                 else {
[09:29:20.397]                   if (TRUE) {
[09:29:20.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.397]                     {
[09:29:20.397]                       inherits <- base::inherits
[09:29:20.397]                       invokeRestart <- base::invokeRestart
[09:29:20.397]                       is.null <- base::is.null
[09:29:20.397]                       muffled <- FALSE
[09:29:20.397]                       if (inherits(cond, "message")) {
[09:29:20.397]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.397]                         if (muffled) 
[09:29:20.397]                           invokeRestart("muffleMessage")
[09:29:20.397]                       }
[09:29:20.397]                       else if (inherits(cond, "warning")) {
[09:29:20.397]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.397]                         if (muffled) 
[09:29:20.397]                           invokeRestart("muffleWarning")
[09:29:20.397]                       }
[09:29:20.397]                       else if (inherits(cond, "condition")) {
[09:29:20.397]                         if (!is.null(pattern)) {
[09:29:20.397]                           computeRestarts <- base::computeRestarts
[09:29:20.397]                           grepl <- base::grepl
[09:29:20.397]                           restarts <- computeRestarts(cond)
[09:29:20.397]                           for (restart in restarts) {
[09:29:20.397]                             name <- restart$name
[09:29:20.397]                             if (is.null(name)) 
[09:29:20.397]                               next
[09:29:20.397]                             if (!grepl(pattern, name)) 
[09:29:20.397]                               next
[09:29:20.397]                             invokeRestart(restart)
[09:29:20.397]                             muffled <- TRUE
[09:29:20.397]                             break
[09:29:20.397]                           }
[09:29:20.397]                         }
[09:29:20.397]                       }
[09:29:20.397]                       invisible(muffled)
[09:29:20.397]                     }
[09:29:20.397]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.397]                   }
[09:29:20.397]                 }
[09:29:20.397]             }
[09:29:20.397]         }))
[09:29:20.397]     }, error = function(ex) {
[09:29:20.397]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.397]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.397]                 ...future.rng), started = ...future.startTime, 
[09:29:20.397]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.397]             version = "1.8"), class = "FutureResult")
[09:29:20.397]     }, finally = {
[09:29:20.397]         if (!identical(...future.workdir, getwd())) 
[09:29:20.397]             setwd(...future.workdir)
[09:29:20.397]         {
[09:29:20.397]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.397]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.397]             }
[09:29:20.397]             base::options(...future.oldOptions)
[09:29:20.397]             if (.Platform$OS.type == "windows") {
[09:29:20.397]                 old_names <- names(...future.oldEnvVars)
[09:29:20.397]                 envs <- base::Sys.getenv()
[09:29:20.397]                 names <- names(envs)
[09:29:20.397]                 common <- intersect(names, old_names)
[09:29:20.397]                 added <- setdiff(names, old_names)
[09:29:20.397]                 removed <- setdiff(old_names, names)
[09:29:20.397]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.397]                   envs[common]]
[09:29:20.397]                 NAMES <- toupper(changed)
[09:29:20.397]                 args <- list()
[09:29:20.397]                 for (kk in seq_along(NAMES)) {
[09:29:20.397]                   name <- changed[[kk]]
[09:29:20.397]                   NAME <- NAMES[[kk]]
[09:29:20.397]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.397]                     next
[09:29:20.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.397]                 }
[09:29:20.397]                 NAMES <- toupper(added)
[09:29:20.397]                 for (kk in seq_along(NAMES)) {
[09:29:20.397]                   name <- added[[kk]]
[09:29:20.397]                   NAME <- NAMES[[kk]]
[09:29:20.397]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.397]                     next
[09:29:20.397]                   args[[name]] <- ""
[09:29:20.397]                 }
[09:29:20.397]                 NAMES <- toupper(removed)
[09:29:20.397]                 for (kk in seq_along(NAMES)) {
[09:29:20.397]                   name <- removed[[kk]]
[09:29:20.397]                   NAME <- NAMES[[kk]]
[09:29:20.397]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.397]                     next
[09:29:20.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.397]                 }
[09:29:20.397]                 if (length(args) > 0) 
[09:29:20.397]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.397]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.397]             }
[09:29:20.397]             else {
[09:29:20.397]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.397]             }
[09:29:20.397]             {
[09:29:20.397]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.397]                   0L) {
[09:29:20.397]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.397]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.397]                   base::options(opts)
[09:29:20.397]                 }
[09:29:20.397]                 {
[09:29:20.397]                   {
[09:29:20.397]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.397]                     NULL
[09:29:20.397]                   }
[09:29:20.397]                   options(future.plan = NULL)
[09:29:20.397]                   if (is.na(NA_character_)) 
[09:29:20.397]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.397]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.397]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.397]                     .init = FALSE)
[09:29:20.397]                 }
[09:29:20.397]             }
[09:29:20.397]         }
[09:29:20.397]     })
[09:29:20.397]     if (TRUE) {
[09:29:20.397]         base::sink(type = "output", split = FALSE)
[09:29:20.397]         if (TRUE) {
[09:29:20.397]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.397]         }
[09:29:20.397]         else {
[09:29:20.397]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.397]         }
[09:29:20.397]         base::close(...future.stdout)
[09:29:20.397]         ...future.stdout <- NULL
[09:29:20.397]     }
[09:29:20.397]     ...future.result$conditions <- ...future.conditions
[09:29:20.397]     ...future.result$finished <- base::Sys.time()
[09:29:20.397]     ...future.result
[09:29:20.397] }
[09:29:20.399] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[09:29:20.399] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[09:29:20.400] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[09:29:20.400] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[09:29:20.400] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[09:29:20.400] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[09:29:20.401] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[09:29:20.401] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:20.401] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:20.401] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:20.402] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:20.402] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[09:29:20.402] MultisessionFuture started
[09:29:20.402] - Launch lazy future ... done
[09:29:20.403] run() for ‘MultisessionFuture’ ... done
[09:29:20.403] Created future:
[09:29:20.403] MultisessionFuture:
[09:29:20.403] Label: ‘future_mapply-2’
[09:29:20.403] Expression:
[09:29:20.403] {
[09:29:20.403]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.403]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.403]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.403]         on.exit(options(oopts), add = TRUE)
[09:29:20.403]     }
[09:29:20.403]     {
[09:29:20.403]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.403]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.403]         do.call(mapply, args = args)
[09:29:20.403]     }
[09:29:20.403] }
[09:29:20.403] Lazy evaluation: FALSE
[09:29:20.403] Asynchronous evaluation: TRUE
[09:29:20.403] Local evaluation: TRUE
[09:29:20.403] Environment: R_GlobalEnv
[09:29:20.403] Capture standard output: TRUE
[09:29:20.403] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.403] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.403] Packages: <none>
[09:29:20.403] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:20.403] Resolved: FALSE
[09:29:20.403] Value: <not collected>
[09:29:20.403] Conditions captured: <none>
[09:29:20.403] Early signaling: FALSE
[09:29:20.403] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.403] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.414] Chunk #2 of 2 ... DONE
[09:29:20.414] Launching 2 futures (chunks) ... DONE
[09:29:20.414] Resolving 2 futures (chunks) ...
[09:29:20.414] resolve() on list ...
[09:29:20.414]  recursive: 0
[09:29:20.415]  length: 2
[09:29:20.415] 
[09:29:20.415] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.415] - Validating connection of MultisessionFuture
[09:29:20.415] - received message: FutureResult
[09:29:20.415] - Received FutureResult
[09:29:20.416] - Erased future from FutureRegistry
[09:29:20.416] result() for ClusterFuture ...
[09:29:20.416] - result already collected: FutureResult
[09:29:20.416] result() for ClusterFuture ... done
[09:29:20.416] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.416] Future #1
[09:29:20.416] result() for ClusterFuture ...
[09:29:20.416] - result already collected: FutureResult
[09:29:20.416] result() for ClusterFuture ... done
[09:29:20.416] result() for ClusterFuture ...
[09:29:20.417] - result already collected: FutureResult
[09:29:20.417] result() for ClusterFuture ... done
[09:29:20.417] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:20.417] - nx: 2
[09:29:20.417] - relay: TRUE
[09:29:20.417] - stdout: TRUE
[09:29:20.417] - signal: TRUE
[09:29:20.417] - resignal: FALSE
[09:29:20.417] - force: TRUE
[09:29:20.417] - relayed: [n=2] FALSE, FALSE
[09:29:20.417] - queued futures: [n=2] FALSE, FALSE
[09:29:20.417]  - until=1
[09:29:20.418]  - relaying element #1
[09:29:20.418] result() for ClusterFuture ...
[09:29:20.418] - result already collected: FutureResult
[09:29:20.418] result() for ClusterFuture ... done
[09:29:20.418] result() for ClusterFuture ...
[09:29:20.418] - result already collected: FutureResult
[09:29:20.418] result() for ClusterFuture ... done
[09:29:20.418] result() for ClusterFuture ...
[09:29:20.418] - result already collected: FutureResult
[09:29:20.418] result() for ClusterFuture ... done
[09:29:20.418] result() for ClusterFuture ...
[09:29:20.419] - result already collected: FutureResult
[09:29:20.419] result() for ClusterFuture ... done
[09:29:20.419] - relayed: [n=2] TRUE, FALSE
[09:29:20.419] - queued futures: [n=2] TRUE, FALSE
[09:29:20.419] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:20.419]  length: 1 (resolved future 1)
[09:29:20.445] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.445] - Validating connection of MultisessionFuture
[09:29:20.446] - received message: FutureResult
[09:29:20.446] - Received FutureResult
[09:29:20.446] - Erased future from FutureRegistry
[09:29:20.446] result() for ClusterFuture ...
[09:29:20.446] - result already collected: FutureResult
[09:29:20.446] result() for ClusterFuture ... done
[09:29:20.446] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.446] Future #2
[09:29:20.446] result() for ClusterFuture ...
[09:29:20.446] - result already collected: FutureResult
[09:29:20.446] result() for ClusterFuture ... done
[09:29:20.447] result() for ClusterFuture ...
[09:29:20.447] - result already collected: FutureResult
[09:29:20.447] result() for ClusterFuture ... done
[09:29:20.447] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:20.447] - nx: 2
[09:29:20.447] - relay: TRUE
[09:29:20.447] - stdout: TRUE
[09:29:20.447] - signal: TRUE
[09:29:20.447] - resignal: FALSE
[09:29:20.447] - force: TRUE
[09:29:20.447] - relayed: [n=2] TRUE, FALSE
[09:29:20.447] - queued futures: [n=2] TRUE, FALSE
[09:29:20.448]  - until=2
[09:29:20.448]  - relaying element #2
[09:29:20.448] result() for ClusterFuture ...
[09:29:20.448] - result already collected: FutureResult
[09:29:20.448] result() for ClusterFuture ... done
[09:29:20.448] result() for ClusterFuture ...
[09:29:20.448] - result already collected: FutureResult
[09:29:20.448] result() for ClusterFuture ... done
[09:29:20.448] result() for ClusterFuture ...
[09:29:20.448] - result already collected: FutureResult
[09:29:20.448] result() for ClusterFuture ... done
[09:29:20.449] result() for ClusterFuture ...
[09:29:20.449] - result already collected: FutureResult
[09:29:20.449] result() for ClusterFuture ... done
[09:29:20.449] - relayed: [n=2] TRUE, TRUE
[09:29:20.449] - queued futures: [n=2] TRUE, TRUE
[09:29:20.449] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:20.449]  length: 0 (resolved future 2)
[09:29:20.449] Relaying remaining futures
[09:29:20.449] signalConditionsASAP(NULL, pos=0) ...
[09:29:20.449] - nx: 2
[09:29:20.449] - relay: TRUE
[09:29:20.449] - stdout: TRUE
[09:29:20.450] - signal: TRUE
[09:29:20.450] - resignal: FALSE
[09:29:20.450] - force: TRUE
[09:29:20.450] - relayed: [n=2] TRUE, TRUE
[09:29:20.450] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:20.450] - relayed: [n=2] TRUE, TRUE
[09:29:20.450] - queued futures: [n=2] TRUE, TRUE
[09:29:20.450] signalConditionsASAP(NULL, pos=0) ... done
[09:29:20.450] resolve() on list ... DONE
[09:29:20.450] result() for ClusterFuture ...
[09:29:20.450] - result already collected: FutureResult
[09:29:20.451] result() for ClusterFuture ... done
[09:29:20.451] result() for ClusterFuture ...
[09:29:20.451] - result already collected: FutureResult
[09:29:20.451] result() for ClusterFuture ... done
[09:29:20.451] result() for ClusterFuture ...
[09:29:20.451] - result already collected: FutureResult
[09:29:20.451] result() for ClusterFuture ... done
[09:29:20.451] result() for ClusterFuture ...
[09:29:20.451] - result already collected: FutureResult
[09:29:20.451] result() for ClusterFuture ... done
[09:29:20.451]  - Number of value chunks collected: 2
[09:29:20.452] Resolving 2 futures (chunks) ... DONE
[09:29:20.452] Reducing values from 2 chunks ...
[09:29:20.452]  - Number of values collected after concatenation: 2
[09:29:20.452]  - Number of values expected: 2
[09:29:20.452] Reducing values from 2 chunks ... DONE
[09:29:20.452] future_mapply() ... DONE
[09:29:20.452] future_mapply() ...
[09:29:20.452] Generating random seeds ...
[09:29:20.452] Generating random seed streams for 2 elements ...
[09:29:20.452] Generating random seed streams for 2 elements ... DONE
[09:29:20.453] Generating random seeds ... DONE
[09:29:20.453] Will set RNG state on exit: 10407, 759227591, 757336532, -1026619238, -802806221, -275984655, 1540976279
[09:29:20.456] Number of chunks: 2
[09:29:20.456] getGlobalsAndPackagesXApply() ...
[09:29:20.456]  - future.globals: TRUE
[09:29:20.456] getGlobalsAndPackages() ...
[09:29:20.456] Searching for globals...
[09:29:20.457] - globals found: [1] ‘FUN’
[09:29:20.458] Searching for globals ... DONE
[09:29:20.458] Resolving globals: FALSE
[09:29:20.458] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[09:29:20.458] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[09:29:20.458] - globals: [1] ‘FUN’
[09:29:20.459] 
[09:29:20.459] getGlobalsAndPackages() ... DONE
[09:29:20.459]  - globals found/used: [n=1] ‘FUN’
[09:29:20.459]  - needed namespaces: [n=0] 
[09:29:20.459] Finding globals ... DONE
[09:29:20.459] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:20.459] List of 2
[09:29:20.459]  $ ...future.FUN:function (x, y)  
[09:29:20.459]  $ MoreArgs     :List of 1
[09:29:20.459]   ..$ y: int [1:2] 3 4
[09:29:20.459]  - attr(*, "where")=List of 2
[09:29:20.459]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:20.459]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:20.459]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:20.459]  - attr(*, "resolved")= logi FALSE
[09:29:20.459]  - attr(*, "total_size")= num NA
[09:29:20.462] Packages to be attached in all futures: [n=0] 
[09:29:20.462] getGlobalsAndPackagesXApply() ... DONE
[09:29:20.462] Number of futures (= number of chunks): 2
[09:29:20.462] Launching 2 futures (chunks) ...
[09:29:20.462] Chunk #1 of 2 ...
[09:29:20.463]  - Finding globals in '...' for chunk #1 ...
[09:29:20.463] getGlobalsAndPackages() ...
[09:29:20.463] Searching for globals...
[09:29:20.463] 
[09:29:20.463] Searching for globals ... DONE
[09:29:20.463] - globals: [0] <none>
[09:29:20.463] getGlobalsAndPackages() ... DONE
[09:29:20.463]    + additional globals found: [n=0] 
[09:29:20.463]    + additional namespaces needed: [n=0] 
[09:29:20.463]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:20.464]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:20.464]  - seeds: [1] <seeds>
[09:29:20.464]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.464] getGlobalsAndPackages() ...
[09:29:20.464] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.464] Resolving globals: FALSE
[09:29:20.465] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[09:29:20.465] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[09:29:20.465] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.465] 
[09:29:20.465] getGlobalsAndPackages() ... DONE
[09:29:20.466] run() for ‘Future’ ...
[09:29:20.466] - state: ‘created’
[09:29:20.466] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.479] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.479] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.479]   - Field: ‘node’
[09:29:20.480]   - Field: ‘label’
[09:29:20.480]   - Field: ‘local’
[09:29:20.480]   - Field: ‘owner’
[09:29:20.480]   - Field: ‘envir’
[09:29:20.480]   - Field: ‘workers’
[09:29:20.480]   - Field: ‘packages’
[09:29:20.480]   - Field: ‘gc’
[09:29:20.480]   - Field: ‘conditions’
[09:29:20.480]   - Field: ‘persistent’
[09:29:20.480]   - Field: ‘expr’
[09:29:20.481]   - Field: ‘uuid’
[09:29:20.481]   - Field: ‘seed’
[09:29:20.481]   - Field: ‘version’
[09:29:20.481]   - Field: ‘result’
[09:29:20.481]   - Field: ‘asynchronous’
[09:29:20.481]   - Field: ‘calls’
[09:29:20.481]   - Field: ‘globals’
[09:29:20.481]   - Field: ‘stdout’
[09:29:20.481]   - Field: ‘earlySignal’
[09:29:20.481]   - Field: ‘lazy’
[09:29:20.481]   - Field: ‘state’
[09:29:20.481] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.482] - Launch lazy future ...
[09:29:20.482] Packages needed by the future expression (n = 0): <none>
[09:29:20.482] Packages needed by future strategies (n = 0): <none>
[09:29:20.482] {
[09:29:20.482]     {
[09:29:20.482]         {
[09:29:20.482]             ...future.startTime <- base::Sys.time()
[09:29:20.482]             {
[09:29:20.482]                 {
[09:29:20.482]                   {
[09:29:20.482]                     {
[09:29:20.482]                       base::local({
[09:29:20.482]                         has_future <- base::requireNamespace("future", 
[09:29:20.482]                           quietly = TRUE)
[09:29:20.482]                         if (has_future) {
[09:29:20.482]                           ns <- base::getNamespace("future")
[09:29:20.482]                           version <- ns[[".package"]][["version"]]
[09:29:20.482]                           if (is.null(version)) 
[09:29:20.482]                             version <- utils::packageVersion("future")
[09:29:20.482]                         }
[09:29:20.482]                         else {
[09:29:20.482]                           version <- NULL
[09:29:20.482]                         }
[09:29:20.482]                         if (!has_future || version < "1.8.0") {
[09:29:20.482]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.482]                             "", base::R.version$version.string), 
[09:29:20.482]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:20.482]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:20.482]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.482]                               "release", "version")], collapse = " "), 
[09:29:20.482]                             hostname = base::Sys.info()[["nodename"]])
[09:29:20.482]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.482]                             info)
[09:29:20.482]                           info <- base::paste(info, collapse = "; ")
[09:29:20.482]                           if (!has_future) {
[09:29:20.482]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.482]                               info)
[09:29:20.482]                           }
[09:29:20.482]                           else {
[09:29:20.482]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.482]                               info, version)
[09:29:20.482]                           }
[09:29:20.482]                           base::stop(msg)
[09:29:20.482]                         }
[09:29:20.482]                       })
[09:29:20.482]                     }
[09:29:20.482]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.482]                     base::options(mc.cores = 1L)
[09:29:20.482]                   }
[09:29:20.482]                   ...future.strategy.old <- future::plan("list")
[09:29:20.482]                   options(future.plan = NULL)
[09:29:20.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.482]                 }
[09:29:20.482]                 ...future.workdir <- getwd()
[09:29:20.482]             }
[09:29:20.482]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.482]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.482]         }
[09:29:20.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.482]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:20.482]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.482]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.482]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.482]             base::names(...future.oldOptions))
[09:29:20.482]     }
[09:29:20.482]     if (FALSE) {
[09:29:20.482]     }
[09:29:20.482]     else {
[09:29:20.482]         if (TRUE) {
[09:29:20.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.482]                 open = "w")
[09:29:20.482]         }
[09:29:20.482]         else {
[09:29:20.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.482]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.482]         }
[09:29:20.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.482]             base::sink(type = "output", split = FALSE)
[09:29:20.482]             base::close(...future.stdout)
[09:29:20.482]         }, add = TRUE)
[09:29:20.482]     }
[09:29:20.482]     ...future.frame <- base::sys.nframe()
[09:29:20.482]     ...future.conditions <- base::list()
[09:29:20.482]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.482]     if (FALSE) {
[09:29:20.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.482]     }
[09:29:20.482]     ...future.result <- base::tryCatch({
[09:29:20.482]         base::withCallingHandlers({
[09:29:20.482]             ...future.value <- base::withVisible(base::local({
[09:29:20.482]                 ...future.makeSendCondition <- base::local({
[09:29:20.482]                   sendCondition <- NULL
[09:29:20.482]                   function(frame = 1L) {
[09:29:20.482]                     if (is.function(sendCondition)) 
[09:29:20.482]                       return(sendCondition)
[09:29:20.482]                     ns <- getNamespace("parallel")
[09:29:20.482]                     if (exists("sendData", mode = "function", 
[09:29:20.482]                       envir = ns)) {
[09:29:20.482]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.482]                         envir = ns)
[09:29:20.482]                       envir <- sys.frame(frame)
[09:29:20.482]                       master <- NULL
[09:29:20.482]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.482]                         !identical(envir, emptyenv())) {
[09:29:20.482]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.482]                           inherits = FALSE)) {
[09:29:20.482]                           master <- get("master", mode = "list", 
[09:29:20.482]                             envir = envir, inherits = FALSE)
[09:29:20.482]                           if (inherits(master, c("SOCKnode", 
[09:29:20.482]                             "SOCK0node"))) {
[09:29:20.482]                             sendCondition <<- function(cond) {
[09:29:20.482]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.482]                                 success = TRUE)
[09:29:20.482]                               parallel_sendData(master, data)
[09:29:20.482]                             }
[09:29:20.482]                             return(sendCondition)
[09:29:20.482]                           }
[09:29:20.482]                         }
[09:29:20.482]                         frame <- frame + 1L
[09:29:20.482]                         envir <- sys.frame(frame)
[09:29:20.482]                       }
[09:29:20.482]                     }
[09:29:20.482]                     sendCondition <<- function(cond) NULL
[09:29:20.482]                   }
[09:29:20.482]                 })
[09:29:20.482]                 withCallingHandlers({
[09:29:20.482]                   {
[09:29:20.482]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.482]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.482]                       ...future.globals.maxSize)) {
[09:29:20.482]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.482]                       on.exit(options(oopts), add = TRUE)
[09:29:20.482]                     }
[09:29:20.482]                     {
[09:29:20.482]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:20.482]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[09:29:20.482]                           envir = globalenv(), inherits = FALSE)
[09:29:20.482]                         ...future.FUN(...)
[09:29:20.482]                       }
[09:29:20.482]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:20.482]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:20.482]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.482]                         USE.NAMES = FALSE)
[09:29:20.482]                       do.call(mapply, args = args)
[09:29:20.482]                     }
[09:29:20.482]                   }
[09:29:20.482]                 }, immediateCondition = function(cond) {
[09:29:20.482]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.482]                   sendCondition(cond)
[09:29:20.482]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.482]                   {
[09:29:20.482]                     inherits <- base::inherits
[09:29:20.482]                     invokeRestart <- base::invokeRestart
[09:29:20.482]                     is.null <- base::is.null
[09:29:20.482]                     muffled <- FALSE
[09:29:20.482]                     if (inherits(cond, "message")) {
[09:29:20.482]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.482]                       if (muffled) 
[09:29:20.482]                         invokeRestart("muffleMessage")
[09:29:20.482]                     }
[09:29:20.482]                     else if (inherits(cond, "warning")) {
[09:29:20.482]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.482]                       if (muffled) 
[09:29:20.482]                         invokeRestart("muffleWarning")
[09:29:20.482]                     }
[09:29:20.482]                     else if (inherits(cond, "condition")) {
[09:29:20.482]                       if (!is.null(pattern)) {
[09:29:20.482]                         computeRestarts <- base::computeRestarts
[09:29:20.482]                         grepl <- base::grepl
[09:29:20.482]                         restarts <- computeRestarts(cond)
[09:29:20.482]                         for (restart in restarts) {
[09:29:20.482]                           name <- restart$name
[09:29:20.482]                           if (is.null(name)) 
[09:29:20.482]                             next
[09:29:20.482]                           if (!grepl(pattern, name)) 
[09:29:20.482]                             next
[09:29:20.482]                           invokeRestart(restart)
[09:29:20.482]                           muffled <- TRUE
[09:29:20.482]                           break
[09:29:20.482]                         }
[09:29:20.482]                       }
[09:29:20.482]                     }
[09:29:20.482]                     invisible(muffled)
[09:29:20.482]                   }
[09:29:20.482]                   muffleCondition(cond)
[09:29:20.482]                 })
[09:29:20.482]             }))
[09:29:20.482]             future::FutureResult(value = ...future.value$value, 
[09:29:20.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.482]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.482]                     ...future.globalenv.names))
[09:29:20.482]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.482]         }, condition = base::local({
[09:29:20.482]             c <- base::c
[09:29:20.482]             inherits <- base::inherits
[09:29:20.482]             invokeRestart <- base::invokeRestart
[09:29:20.482]             length <- base::length
[09:29:20.482]             list <- base::list
[09:29:20.482]             seq.int <- base::seq.int
[09:29:20.482]             signalCondition <- base::signalCondition
[09:29:20.482]             sys.calls <- base::sys.calls
[09:29:20.482]             `[[` <- base::`[[`
[09:29:20.482]             `+` <- base::`+`
[09:29:20.482]             `<<-` <- base::`<<-`
[09:29:20.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.482]                   3L)]
[09:29:20.482]             }
[09:29:20.482]             function(cond) {
[09:29:20.482]                 is_error <- inherits(cond, "error")
[09:29:20.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.482]                   NULL)
[09:29:20.482]                 if (is_error) {
[09:29:20.482]                   sessionInformation <- function() {
[09:29:20.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.482]                       search = base::search(), system = base::Sys.info())
[09:29:20.482]                   }
[09:29:20.482]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.482]                     cond$call), session = sessionInformation(), 
[09:29:20.482]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.482]                   signalCondition(cond)
[09:29:20.482]                 }
[09:29:20.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.482]                 "immediateCondition"))) {
[09:29:20.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.482]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.482]                   if (TRUE && !signal) {
[09:29:20.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.482]                     {
[09:29:20.482]                       inherits <- base::inherits
[09:29:20.482]                       invokeRestart <- base::invokeRestart
[09:29:20.482]                       is.null <- base::is.null
[09:29:20.482]                       muffled <- FALSE
[09:29:20.482]                       if (inherits(cond, "message")) {
[09:29:20.482]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.482]                         if (muffled) 
[09:29:20.482]                           invokeRestart("muffleMessage")
[09:29:20.482]                       }
[09:29:20.482]                       else if (inherits(cond, "warning")) {
[09:29:20.482]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.482]                         if (muffled) 
[09:29:20.482]                           invokeRestart("muffleWarning")
[09:29:20.482]                       }
[09:29:20.482]                       else if (inherits(cond, "condition")) {
[09:29:20.482]                         if (!is.null(pattern)) {
[09:29:20.482]                           computeRestarts <- base::computeRestarts
[09:29:20.482]                           grepl <- base::grepl
[09:29:20.482]                           restarts <- computeRestarts(cond)
[09:29:20.482]                           for (restart in restarts) {
[09:29:20.482]                             name <- restart$name
[09:29:20.482]                             if (is.null(name)) 
[09:29:20.482]                               next
[09:29:20.482]                             if (!grepl(pattern, name)) 
[09:29:20.482]                               next
[09:29:20.482]                             invokeRestart(restart)
[09:29:20.482]                             muffled <- TRUE
[09:29:20.482]                             break
[09:29:20.482]                           }
[09:29:20.482]                         }
[09:29:20.482]                       }
[09:29:20.482]                       invisible(muffled)
[09:29:20.482]                     }
[09:29:20.482]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.482]                   }
[09:29:20.482]                 }
[09:29:20.482]                 else {
[09:29:20.482]                   if (TRUE) {
[09:29:20.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.482]                     {
[09:29:20.482]                       inherits <- base::inherits
[09:29:20.482]                       invokeRestart <- base::invokeRestart
[09:29:20.482]                       is.null <- base::is.null
[09:29:20.482]                       muffled <- FALSE
[09:29:20.482]                       if (inherits(cond, "message")) {
[09:29:20.482]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.482]                         if (muffled) 
[09:29:20.482]                           invokeRestart("muffleMessage")
[09:29:20.482]                       }
[09:29:20.482]                       else if (inherits(cond, "warning")) {
[09:29:20.482]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.482]                         if (muffled) 
[09:29:20.482]                           invokeRestart("muffleWarning")
[09:29:20.482]                       }
[09:29:20.482]                       else if (inherits(cond, "condition")) {
[09:29:20.482]                         if (!is.null(pattern)) {
[09:29:20.482]                           computeRestarts <- base::computeRestarts
[09:29:20.482]                           grepl <- base::grepl
[09:29:20.482]                           restarts <- computeRestarts(cond)
[09:29:20.482]                           for (restart in restarts) {
[09:29:20.482]                             name <- restart$name
[09:29:20.482]                             if (is.null(name)) 
[09:29:20.482]                               next
[09:29:20.482]                             if (!grepl(pattern, name)) 
[09:29:20.482]                               next
[09:29:20.482]                             invokeRestart(restart)
[09:29:20.482]                             muffled <- TRUE
[09:29:20.482]                             break
[09:29:20.482]                           }
[09:29:20.482]                         }
[09:29:20.482]                       }
[09:29:20.482]                       invisible(muffled)
[09:29:20.482]                     }
[09:29:20.482]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.482]                   }
[09:29:20.482]                 }
[09:29:20.482]             }
[09:29:20.482]         }))
[09:29:20.482]     }, error = function(ex) {
[09:29:20.482]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.482]                 ...future.rng), started = ...future.startTime, 
[09:29:20.482]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.482]             version = "1.8"), class = "FutureResult")
[09:29:20.482]     }, finally = {
[09:29:20.482]         if (!identical(...future.workdir, getwd())) 
[09:29:20.482]             setwd(...future.workdir)
[09:29:20.482]         {
[09:29:20.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.482]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.482]             }
[09:29:20.482]             base::options(...future.oldOptions)
[09:29:20.482]             if (.Platform$OS.type == "windows") {
[09:29:20.482]                 old_names <- names(...future.oldEnvVars)
[09:29:20.482]                 envs <- base::Sys.getenv()
[09:29:20.482]                 names <- names(envs)
[09:29:20.482]                 common <- intersect(names, old_names)
[09:29:20.482]                 added <- setdiff(names, old_names)
[09:29:20.482]                 removed <- setdiff(old_names, names)
[09:29:20.482]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.482]                   envs[common]]
[09:29:20.482]                 NAMES <- toupper(changed)
[09:29:20.482]                 args <- list()
[09:29:20.482]                 for (kk in seq_along(NAMES)) {
[09:29:20.482]                   name <- changed[[kk]]
[09:29:20.482]                   NAME <- NAMES[[kk]]
[09:29:20.482]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.482]                     next
[09:29:20.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.482]                 }
[09:29:20.482]                 NAMES <- toupper(added)
[09:29:20.482]                 for (kk in seq_along(NAMES)) {
[09:29:20.482]                   name <- added[[kk]]
[09:29:20.482]                   NAME <- NAMES[[kk]]
[09:29:20.482]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.482]                     next
[09:29:20.482]                   args[[name]] <- ""
[09:29:20.482]                 }
[09:29:20.482]                 NAMES <- toupper(removed)
[09:29:20.482]                 for (kk in seq_along(NAMES)) {
[09:29:20.482]                   name <- removed[[kk]]
[09:29:20.482]                   NAME <- NAMES[[kk]]
[09:29:20.482]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.482]                     next
[09:29:20.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.482]                 }
[09:29:20.482]                 if (length(args) > 0) 
[09:29:20.482]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.482]             }
[09:29:20.482]             else {
[09:29:20.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.482]             }
[09:29:20.482]             {
[09:29:20.482]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.482]                   0L) {
[09:29:20.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.482]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.482]                   base::options(opts)
[09:29:20.482]                 }
[09:29:20.482]                 {
[09:29:20.482]                   {
[09:29:20.482]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.482]                     NULL
[09:29:20.482]                   }
[09:29:20.482]                   options(future.plan = NULL)
[09:29:20.482]                   if (is.na(NA_character_)) 
[09:29:20.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.482]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.482]                     .init = FALSE)
[09:29:20.482]                 }
[09:29:20.482]             }
[09:29:20.482]         }
[09:29:20.482]     })
[09:29:20.482]     if (TRUE) {
[09:29:20.482]         base::sink(type = "output", split = FALSE)
[09:29:20.482]         if (TRUE) {
[09:29:20.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.482]         }
[09:29:20.482]         else {
[09:29:20.482]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.482]         }
[09:29:20.482]         base::close(...future.stdout)
[09:29:20.482]         ...future.stdout <- NULL
[09:29:20.482]     }
[09:29:20.482]     ...future.result$conditions <- ...future.conditions
[09:29:20.482]     ...future.result$finished <- base::Sys.time()
[09:29:20.482]     ...future.result
[09:29:20.482] }
[09:29:20.485] Exporting 5 global objects (1.85 KiB) to cluster node #1 ...
[09:29:20.485] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[09:29:20.485] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[09:29:20.486] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[09:29:20.486] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[09:29:20.486] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[09:29:20.486] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[09:29:20.486] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[09:29:20.487] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[09:29:20.487] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:20.487] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.487] Exporting 5 global objects (1.85 KiB) to cluster node #1 ... DONE
[09:29:20.488] MultisessionFuture started
[09:29:20.488] - Launch lazy future ... done
[09:29:20.488] run() for ‘MultisessionFuture’ ... done
[09:29:20.488] Created future:
[09:29:20.488] MultisessionFuture:
[09:29:20.488] Label: ‘future_mapply-1’
[09:29:20.488] Expression:
[09:29:20.488] {
[09:29:20.488]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.488]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.488]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.488]         on.exit(options(oopts), add = TRUE)
[09:29:20.488]     }
[09:29:20.488]     {
[09:29:20.488]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:20.488]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[09:29:20.488]                 inherits = FALSE)
[09:29:20.488]             ...future.FUN(...)
[09:29:20.488]         }
[09:29:20.488]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:20.488]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:20.488]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.488]         do.call(mapply, args = args)
[09:29:20.488]     }
[09:29:20.488] }
[09:29:20.488] Lazy evaluation: FALSE
[09:29:20.488] Asynchronous evaluation: TRUE
[09:29:20.488] Local evaluation: TRUE
[09:29:20.488] Environment: R_GlobalEnv
[09:29:20.488] Capture standard output: TRUE
[09:29:20.488] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.488] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.488] Packages: <none>
[09:29:20.488] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:29:20.488] Resolved: FALSE
[09:29:20.488] Value: <not collected>
[09:29:20.488] Conditions captured: <none>
[09:29:20.488] Early signaling: FALSE
[09:29:20.488] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.488] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.499] Chunk #1 of 2 ... DONE
[09:29:20.499] Chunk #2 of 2 ...
[09:29:20.500]  - Finding globals in '...' for chunk #2 ...
[09:29:20.500] getGlobalsAndPackages() ...
[09:29:20.500] Searching for globals...
[09:29:20.500] 
[09:29:20.500] Searching for globals ... DONE
[09:29:20.500] - globals: [0] <none>
[09:29:20.500] getGlobalsAndPackages() ... DONE
[09:29:20.501]    + additional globals found: [n=0] 
[09:29:20.501]    + additional namespaces needed: [n=0] 
[09:29:20.501]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:20.501]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:20.501]  - seeds: [1] <seeds>
[09:29:20.501]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.501] getGlobalsAndPackages() ...
[09:29:20.501] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.501] Resolving globals: FALSE
[09:29:20.502] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[09:29:20.505] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[09:29:20.505] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.505] 
[09:29:20.505] getGlobalsAndPackages() ... DONE
[09:29:20.505] run() for ‘Future’ ...
[09:29:20.505] - state: ‘created’
[09:29:20.506] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.520] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.520] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.520]   - Field: ‘node’
[09:29:20.520]   - Field: ‘label’
[09:29:20.520]   - Field: ‘local’
[09:29:20.521]   - Field: ‘owner’
[09:29:20.521]   - Field: ‘envir’
[09:29:20.521]   - Field: ‘workers’
[09:29:20.521]   - Field: ‘packages’
[09:29:20.521]   - Field: ‘gc’
[09:29:20.521]   - Field: ‘conditions’
[09:29:20.521]   - Field: ‘persistent’
[09:29:20.521]   - Field: ‘expr’
[09:29:20.521]   - Field: ‘uuid’
[09:29:20.521]   - Field: ‘seed’
[09:29:20.521]   - Field: ‘version’
[09:29:20.522]   - Field: ‘result’
[09:29:20.522]   - Field: ‘asynchronous’
[09:29:20.522]   - Field: ‘calls’
[09:29:20.522]   - Field: ‘globals’
[09:29:20.522]   - Field: ‘stdout’
[09:29:20.522]   - Field: ‘earlySignal’
[09:29:20.522]   - Field: ‘lazy’
[09:29:20.522]   - Field: ‘state’
[09:29:20.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.522] - Launch lazy future ...
[09:29:20.523] Packages needed by the future expression (n = 0): <none>
[09:29:20.523] Packages needed by future strategies (n = 0): <none>
[09:29:20.523] {
[09:29:20.523]     {
[09:29:20.523]         {
[09:29:20.523]             ...future.startTime <- base::Sys.time()
[09:29:20.523]             {
[09:29:20.523]                 {
[09:29:20.523]                   {
[09:29:20.523]                     {
[09:29:20.523]                       base::local({
[09:29:20.523]                         has_future <- base::requireNamespace("future", 
[09:29:20.523]                           quietly = TRUE)
[09:29:20.523]                         if (has_future) {
[09:29:20.523]                           ns <- base::getNamespace("future")
[09:29:20.523]                           version <- ns[[".package"]][["version"]]
[09:29:20.523]                           if (is.null(version)) 
[09:29:20.523]                             version <- utils::packageVersion("future")
[09:29:20.523]                         }
[09:29:20.523]                         else {
[09:29:20.523]                           version <- NULL
[09:29:20.523]                         }
[09:29:20.523]                         if (!has_future || version < "1.8.0") {
[09:29:20.523]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.523]                             "", base::R.version$version.string), 
[09:29:20.523]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:20.523]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:20.523]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.523]                               "release", "version")], collapse = " "), 
[09:29:20.523]                             hostname = base::Sys.info()[["nodename"]])
[09:29:20.523]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.523]                             info)
[09:29:20.523]                           info <- base::paste(info, collapse = "; ")
[09:29:20.523]                           if (!has_future) {
[09:29:20.523]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.523]                               info)
[09:29:20.523]                           }
[09:29:20.523]                           else {
[09:29:20.523]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.523]                               info, version)
[09:29:20.523]                           }
[09:29:20.523]                           base::stop(msg)
[09:29:20.523]                         }
[09:29:20.523]                       })
[09:29:20.523]                     }
[09:29:20.523]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.523]                     base::options(mc.cores = 1L)
[09:29:20.523]                   }
[09:29:20.523]                   ...future.strategy.old <- future::plan("list")
[09:29:20.523]                   options(future.plan = NULL)
[09:29:20.523]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.523]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.523]                 }
[09:29:20.523]                 ...future.workdir <- getwd()
[09:29:20.523]             }
[09:29:20.523]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.523]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.523]         }
[09:29:20.523]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.523]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:20.523]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.523]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.523]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.523]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.523]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.523]             base::names(...future.oldOptions))
[09:29:20.523]     }
[09:29:20.523]     if (FALSE) {
[09:29:20.523]     }
[09:29:20.523]     else {
[09:29:20.523]         if (TRUE) {
[09:29:20.523]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.523]                 open = "w")
[09:29:20.523]         }
[09:29:20.523]         else {
[09:29:20.523]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.523]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.523]         }
[09:29:20.523]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.523]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.523]             base::sink(type = "output", split = FALSE)
[09:29:20.523]             base::close(...future.stdout)
[09:29:20.523]         }, add = TRUE)
[09:29:20.523]     }
[09:29:20.523]     ...future.frame <- base::sys.nframe()
[09:29:20.523]     ...future.conditions <- base::list()
[09:29:20.523]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.523]     if (FALSE) {
[09:29:20.523]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.523]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.523]     }
[09:29:20.523]     ...future.result <- base::tryCatch({
[09:29:20.523]         base::withCallingHandlers({
[09:29:20.523]             ...future.value <- base::withVisible(base::local({
[09:29:20.523]                 ...future.makeSendCondition <- base::local({
[09:29:20.523]                   sendCondition <- NULL
[09:29:20.523]                   function(frame = 1L) {
[09:29:20.523]                     if (is.function(sendCondition)) 
[09:29:20.523]                       return(sendCondition)
[09:29:20.523]                     ns <- getNamespace("parallel")
[09:29:20.523]                     if (exists("sendData", mode = "function", 
[09:29:20.523]                       envir = ns)) {
[09:29:20.523]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.523]                         envir = ns)
[09:29:20.523]                       envir <- sys.frame(frame)
[09:29:20.523]                       master <- NULL
[09:29:20.523]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.523]                         !identical(envir, emptyenv())) {
[09:29:20.523]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.523]                           inherits = FALSE)) {
[09:29:20.523]                           master <- get("master", mode = "list", 
[09:29:20.523]                             envir = envir, inherits = FALSE)
[09:29:20.523]                           if (inherits(master, c("SOCKnode", 
[09:29:20.523]                             "SOCK0node"))) {
[09:29:20.523]                             sendCondition <<- function(cond) {
[09:29:20.523]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.523]                                 success = TRUE)
[09:29:20.523]                               parallel_sendData(master, data)
[09:29:20.523]                             }
[09:29:20.523]                             return(sendCondition)
[09:29:20.523]                           }
[09:29:20.523]                         }
[09:29:20.523]                         frame <- frame + 1L
[09:29:20.523]                         envir <- sys.frame(frame)
[09:29:20.523]                       }
[09:29:20.523]                     }
[09:29:20.523]                     sendCondition <<- function(cond) NULL
[09:29:20.523]                   }
[09:29:20.523]                 })
[09:29:20.523]                 withCallingHandlers({
[09:29:20.523]                   {
[09:29:20.523]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.523]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.523]                       ...future.globals.maxSize)) {
[09:29:20.523]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.523]                       on.exit(options(oopts), add = TRUE)
[09:29:20.523]                     }
[09:29:20.523]                     {
[09:29:20.523]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:20.523]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[09:29:20.523]                           envir = globalenv(), inherits = FALSE)
[09:29:20.523]                         ...future.FUN(...)
[09:29:20.523]                       }
[09:29:20.523]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:20.523]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:20.523]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.523]                         USE.NAMES = FALSE)
[09:29:20.523]                       do.call(mapply, args = args)
[09:29:20.523]                     }
[09:29:20.523]                   }
[09:29:20.523]                 }, immediateCondition = function(cond) {
[09:29:20.523]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.523]                   sendCondition(cond)
[09:29:20.523]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.523]                   {
[09:29:20.523]                     inherits <- base::inherits
[09:29:20.523]                     invokeRestart <- base::invokeRestart
[09:29:20.523]                     is.null <- base::is.null
[09:29:20.523]                     muffled <- FALSE
[09:29:20.523]                     if (inherits(cond, "message")) {
[09:29:20.523]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.523]                       if (muffled) 
[09:29:20.523]                         invokeRestart("muffleMessage")
[09:29:20.523]                     }
[09:29:20.523]                     else if (inherits(cond, "warning")) {
[09:29:20.523]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.523]                       if (muffled) 
[09:29:20.523]                         invokeRestart("muffleWarning")
[09:29:20.523]                     }
[09:29:20.523]                     else if (inherits(cond, "condition")) {
[09:29:20.523]                       if (!is.null(pattern)) {
[09:29:20.523]                         computeRestarts <- base::computeRestarts
[09:29:20.523]                         grepl <- base::grepl
[09:29:20.523]                         restarts <- computeRestarts(cond)
[09:29:20.523]                         for (restart in restarts) {
[09:29:20.523]                           name <- restart$name
[09:29:20.523]                           if (is.null(name)) 
[09:29:20.523]                             next
[09:29:20.523]                           if (!grepl(pattern, name)) 
[09:29:20.523]                             next
[09:29:20.523]                           invokeRestart(restart)
[09:29:20.523]                           muffled <- TRUE
[09:29:20.523]                           break
[09:29:20.523]                         }
[09:29:20.523]                       }
[09:29:20.523]                     }
[09:29:20.523]                     invisible(muffled)
[09:29:20.523]                   }
[09:29:20.523]                   muffleCondition(cond)
[09:29:20.523]                 })
[09:29:20.523]             }))
[09:29:20.523]             future::FutureResult(value = ...future.value$value, 
[09:29:20.523]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.523]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.523]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.523]                     ...future.globalenv.names))
[09:29:20.523]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.523]         }, condition = base::local({
[09:29:20.523]             c <- base::c
[09:29:20.523]             inherits <- base::inherits
[09:29:20.523]             invokeRestart <- base::invokeRestart
[09:29:20.523]             length <- base::length
[09:29:20.523]             list <- base::list
[09:29:20.523]             seq.int <- base::seq.int
[09:29:20.523]             signalCondition <- base::signalCondition
[09:29:20.523]             sys.calls <- base::sys.calls
[09:29:20.523]             `[[` <- base::`[[`
[09:29:20.523]             `+` <- base::`+`
[09:29:20.523]             `<<-` <- base::`<<-`
[09:29:20.523]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.523]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.523]                   3L)]
[09:29:20.523]             }
[09:29:20.523]             function(cond) {
[09:29:20.523]                 is_error <- inherits(cond, "error")
[09:29:20.523]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.523]                   NULL)
[09:29:20.523]                 if (is_error) {
[09:29:20.523]                   sessionInformation <- function() {
[09:29:20.523]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.523]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.523]                       search = base::search(), system = base::Sys.info())
[09:29:20.523]                   }
[09:29:20.523]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.523]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.523]                     cond$call), session = sessionInformation(), 
[09:29:20.523]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.523]                   signalCondition(cond)
[09:29:20.523]                 }
[09:29:20.523]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.523]                 "immediateCondition"))) {
[09:29:20.523]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.523]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.523]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.523]                   if (TRUE && !signal) {
[09:29:20.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.523]                     {
[09:29:20.523]                       inherits <- base::inherits
[09:29:20.523]                       invokeRestart <- base::invokeRestart
[09:29:20.523]                       is.null <- base::is.null
[09:29:20.523]                       muffled <- FALSE
[09:29:20.523]                       if (inherits(cond, "message")) {
[09:29:20.523]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.523]                         if (muffled) 
[09:29:20.523]                           invokeRestart("muffleMessage")
[09:29:20.523]                       }
[09:29:20.523]                       else if (inherits(cond, "warning")) {
[09:29:20.523]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.523]                         if (muffled) 
[09:29:20.523]                           invokeRestart("muffleWarning")
[09:29:20.523]                       }
[09:29:20.523]                       else if (inherits(cond, "condition")) {
[09:29:20.523]                         if (!is.null(pattern)) {
[09:29:20.523]                           computeRestarts <- base::computeRestarts
[09:29:20.523]                           grepl <- base::grepl
[09:29:20.523]                           restarts <- computeRestarts(cond)
[09:29:20.523]                           for (restart in restarts) {
[09:29:20.523]                             name <- restart$name
[09:29:20.523]                             if (is.null(name)) 
[09:29:20.523]                               next
[09:29:20.523]                             if (!grepl(pattern, name)) 
[09:29:20.523]                               next
[09:29:20.523]                             invokeRestart(restart)
[09:29:20.523]                             muffled <- TRUE
[09:29:20.523]                             break
[09:29:20.523]                           }
[09:29:20.523]                         }
[09:29:20.523]                       }
[09:29:20.523]                       invisible(muffled)
[09:29:20.523]                     }
[09:29:20.523]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.523]                   }
[09:29:20.523]                 }
[09:29:20.523]                 else {
[09:29:20.523]                   if (TRUE) {
[09:29:20.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.523]                     {
[09:29:20.523]                       inherits <- base::inherits
[09:29:20.523]                       invokeRestart <- base::invokeRestart
[09:29:20.523]                       is.null <- base::is.null
[09:29:20.523]                       muffled <- FALSE
[09:29:20.523]                       if (inherits(cond, "message")) {
[09:29:20.523]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.523]                         if (muffled) 
[09:29:20.523]                           invokeRestart("muffleMessage")
[09:29:20.523]                       }
[09:29:20.523]                       else if (inherits(cond, "warning")) {
[09:29:20.523]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.523]                         if (muffled) 
[09:29:20.523]                           invokeRestart("muffleWarning")
[09:29:20.523]                       }
[09:29:20.523]                       else if (inherits(cond, "condition")) {
[09:29:20.523]                         if (!is.null(pattern)) {
[09:29:20.523]                           computeRestarts <- base::computeRestarts
[09:29:20.523]                           grepl <- base::grepl
[09:29:20.523]                           restarts <- computeRestarts(cond)
[09:29:20.523]                           for (restart in restarts) {
[09:29:20.523]                             name <- restart$name
[09:29:20.523]                             if (is.null(name)) 
[09:29:20.523]                               next
[09:29:20.523]                             if (!grepl(pattern, name)) 
[09:29:20.523]                               next
[09:29:20.523]                             invokeRestart(restart)
[09:29:20.523]                             muffled <- TRUE
[09:29:20.523]                             break
[09:29:20.523]                           }
[09:29:20.523]                         }
[09:29:20.523]                       }
[09:29:20.523]                       invisible(muffled)
[09:29:20.523]                     }
[09:29:20.523]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.523]                   }
[09:29:20.523]                 }
[09:29:20.523]             }
[09:29:20.523]         }))
[09:29:20.523]     }, error = function(ex) {
[09:29:20.523]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.523]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.523]                 ...future.rng), started = ...future.startTime, 
[09:29:20.523]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.523]             version = "1.8"), class = "FutureResult")
[09:29:20.523]     }, finally = {
[09:29:20.523]         if (!identical(...future.workdir, getwd())) 
[09:29:20.523]             setwd(...future.workdir)
[09:29:20.523]         {
[09:29:20.523]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.523]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.523]             }
[09:29:20.523]             base::options(...future.oldOptions)
[09:29:20.523]             if (.Platform$OS.type == "windows") {
[09:29:20.523]                 old_names <- names(...future.oldEnvVars)
[09:29:20.523]                 envs <- base::Sys.getenv()
[09:29:20.523]                 names <- names(envs)
[09:29:20.523]                 common <- intersect(names, old_names)
[09:29:20.523]                 added <- setdiff(names, old_names)
[09:29:20.523]                 removed <- setdiff(old_names, names)
[09:29:20.523]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.523]                   envs[common]]
[09:29:20.523]                 NAMES <- toupper(changed)
[09:29:20.523]                 args <- list()
[09:29:20.523]                 for (kk in seq_along(NAMES)) {
[09:29:20.523]                   name <- changed[[kk]]
[09:29:20.523]                   NAME <- NAMES[[kk]]
[09:29:20.523]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.523]                     next
[09:29:20.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.523]                 }
[09:29:20.523]                 NAMES <- toupper(added)
[09:29:20.523]                 for (kk in seq_along(NAMES)) {
[09:29:20.523]                   name <- added[[kk]]
[09:29:20.523]                   NAME <- NAMES[[kk]]
[09:29:20.523]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.523]                     next
[09:29:20.523]                   args[[name]] <- ""
[09:29:20.523]                 }
[09:29:20.523]                 NAMES <- toupper(removed)
[09:29:20.523]                 for (kk in seq_along(NAMES)) {
[09:29:20.523]                   name <- removed[[kk]]
[09:29:20.523]                   NAME <- NAMES[[kk]]
[09:29:20.523]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.523]                     next
[09:29:20.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.523]                 }
[09:29:20.523]                 if (length(args) > 0) 
[09:29:20.523]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.523]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.523]             }
[09:29:20.523]             else {
[09:29:20.523]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.523]             }
[09:29:20.523]             {
[09:29:20.523]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.523]                   0L) {
[09:29:20.523]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.523]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.523]                   base::options(opts)
[09:29:20.523]                 }
[09:29:20.523]                 {
[09:29:20.523]                   {
[09:29:20.523]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.523]                     NULL
[09:29:20.523]                   }
[09:29:20.523]                   options(future.plan = NULL)
[09:29:20.523]                   if (is.na(NA_character_)) 
[09:29:20.523]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.523]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.523]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.523]                     .init = FALSE)
[09:29:20.523]                 }
[09:29:20.523]             }
[09:29:20.523]         }
[09:29:20.523]     })
[09:29:20.523]     if (TRUE) {
[09:29:20.523]         base::sink(type = "output", split = FALSE)
[09:29:20.523]         if (TRUE) {
[09:29:20.523]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.523]         }
[09:29:20.523]         else {
[09:29:20.523]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.523]         }
[09:29:20.523]         base::close(...future.stdout)
[09:29:20.523]         ...future.stdout <- NULL
[09:29:20.523]     }
[09:29:20.523]     ...future.result$conditions <- ...future.conditions
[09:29:20.523]     ...future.result$finished <- base::Sys.time()
[09:29:20.523]     ...future.result
[09:29:20.523] }
[09:29:20.526] Exporting 5 global objects (1.85 KiB) to cluster node #2 ...
[09:29:20.526] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[09:29:20.526] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[09:29:20.526] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[09:29:20.527] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[09:29:20.527] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[09:29:20.527] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[09:29:20.527] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[09:29:20.528] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[09:29:20.528] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:20.528] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:20.528] Exporting 5 global objects (1.85 KiB) to cluster node #2 ... DONE
[09:29:20.529] MultisessionFuture started
[09:29:20.529] - Launch lazy future ... done
[09:29:20.529] run() for ‘MultisessionFuture’ ... done
[09:29:20.529] Created future:
[09:29:20.529] MultisessionFuture:
[09:29:20.529] Label: ‘future_mapply-2’
[09:29:20.529] Expression:
[09:29:20.529] {
[09:29:20.529]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.529]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.529]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.529]         on.exit(options(oopts), add = TRUE)
[09:29:20.529]     }
[09:29:20.529]     {
[09:29:20.529]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:20.529]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[09:29:20.529]                 inherits = FALSE)
[09:29:20.529]             ...future.FUN(...)
[09:29:20.529]         }
[09:29:20.529]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:20.529]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:20.529]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.529]         do.call(mapply, args = args)
[09:29:20.529]     }
[09:29:20.529] }
[09:29:20.529] Lazy evaluation: FALSE
[09:29:20.529] Asynchronous evaluation: TRUE
[09:29:20.529] Local evaluation: TRUE
[09:29:20.529] Environment: R_GlobalEnv
[09:29:20.529] Capture standard output: TRUE
[09:29:20.529] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.529] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.529] Packages: <none>
[09:29:20.529] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:29:20.529] Resolved: FALSE
[09:29:20.529] Value: <not collected>
[09:29:20.529] Conditions captured: <none>
[09:29:20.529] Early signaling: FALSE
[09:29:20.529] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.529] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.541] Chunk #2 of 2 ... DONE
[09:29:20.541] Launching 2 futures (chunks) ... DONE
[09:29:20.541] Resolving 2 futures (chunks) ...
[09:29:20.541] resolve() on list ...
[09:29:20.541]  recursive: 0
[09:29:20.541]  length: 2
[09:29:20.541] 
[09:29:20.542] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.542] - Validating connection of MultisessionFuture
[09:29:20.542] - received message: FutureResult
[09:29:20.542] - Received FutureResult
[09:29:20.542] - Erased future from FutureRegistry
[09:29:20.542] result() for ClusterFuture ...
[09:29:20.542] - result already collected: FutureResult
[09:29:20.542] result() for ClusterFuture ... done
[09:29:20.542] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.543] Future #1
[09:29:20.543] result() for ClusterFuture ...
[09:29:20.543] - result already collected: FutureResult
[09:29:20.543] result() for ClusterFuture ... done
[09:29:20.543] result() for ClusterFuture ...
[09:29:20.543] - result already collected: FutureResult
[09:29:20.543] result() for ClusterFuture ... done
[09:29:20.543] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:20.543] - nx: 2
[09:29:20.543] - relay: TRUE
[09:29:20.543] - stdout: TRUE
[09:29:20.543] - signal: TRUE
[09:29:20.544] - resignal: FALSE
[09:29:20.544] - force: TRUE
[09:29:20.544] - relayed: [n=2] FALSE, FALSE
[09:29:20.544] - queued futures: [n=2] FALSE, FALSE
[09:29:20.544]  - until=1
[09:29:20.544]  - relaying element #1
[09:29:20.544] result() for ClusterFuture ...
[09:29:20.544] - result already collected: FutureResult
[09:29:20.544] result() for ClusterFuture ... done
[09:29:20.544] result() for ClusterFuture ...
[09:29:20.544] - result already collected: FutureResult
[09:29:20.545] result() for ClusterFuture ... done
[09:29:20.545] result() for ClusterFuture ...
[09:29:20.545] - result already collected: FutureResult
[09:29:20.545] result() for ClusterFuture ... done
[09:29:20.545] result() for ClusterFuture ...
[09:29:20.545] - result already collected: FutureResult
[09:29:20.545] result() for ClusterFuture ... done
[09:29:20.545] - relayed: [n=2] TRUE, FALSE
[09:29:20.545] - queued futures: [n=2] TRUE, FALSE
[09:29:20.545] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:20.545]  length: 1 (resolved future 1)
[09:29:20.573] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.573] - Validating connection of MultisessionFuture
[09:29:20.574] - received message: FutureResult
[09:29:20.574] - Received FutureResult
[09:29:20.574] - Erased future from FutureRegistry
[09:29:20.574] result() for ClusterFuture ...
[09:29:20.574] - result already collected: FutureResult
[09:29:20.574] result() for ClusterFuture ... done
[09:29:20.574] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.574] Future #2
[09:29:20.574] result() for ClusterFuture ...
[09:29:20.574] - result already collected: FutureResult
[09:29:20.574] result() for ClusterFuture ... done
[09:29:20.575] result() for ClusterFuture ...
[09:29:20.575] - result already collected: FutureResult
[09:29:20.575] result() for ClusterFuture ... done
[09:29:20.575] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:20.575] - nx: 2
[09:29:20.575] - relay: TRUE
[09:29:20.575] - stdout: TRUE
[09:29:20.575] - signal: TRUE
[09:29:20.575] - resignal: FALSE
[09:29:20.575] - force: TRUE
[09:29:20.575] - relayed: [n=2] TRUE, FALSE
[09:29:20.575] - queued futures: [n=2] TRUE, FALSE
[09:29:20.576]  - until=2
[09:29:20.576]  - relaying element #2
[09:29:20.576] result() for ClusterFuture ...
[09:29:20.576] - result already collected: FutureResult
[09:29:20.576] result() for ClusterFuture ... done
[09:29:20.576] result() for ClusterFuture ...
[09:29:20.576] - result already collected: FutureResult
[09:29:20.576] result() for ClusterFuture ... done
[09:29:20.576] result() for ClusterFuture ...
[09:29:20.576] - result already collected: FutureResult
[09:29:20.577] result() for ClusterFuture ... done
[09:29:20.577] result() for ClusterFuture ...
[09:29:20.577] - result already collected: FutureResult
[09:29:20.577] result() for ClusterFuture ... done
[09:29:20.577] - relayed: [n=2] TRUE, TRUE
[09:29:20.577] - queued futures: [n=2] TRUE, TRUE
[09:29:20.577] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:20.577]  length: 0 (resolved future 2)
[09:29:20.577] Relaying remaining futures
[09:29:20.577] signalConditionsASAP(NULL, pos=0) ...
[09:29:20.577] - nx: 2
[09:29:20.577] - relay: TRUE
[09:29:20.578] - stdout: TRUE
[09:29:20.578] - signal: TRUE
[09:29:20.578] - resignal: FALSE
[09:29:20.578] - force: TRUE
[09:29:20.578] - relayed: [n=2] TRUE, TRUE
[09:29:20.578] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:20.578] - relayed: [n=2] TRUE, TRUE
[09:29:20.578] - queued futures: [n=2] TRUE, TRUE
[09:29:20.578] signalConditionsASAP(NULL, pos=0) ... done
[09:29:20.578] resolve() on list ... DONE
[09:29:20.578] result() for ClusterFuture ...
[09:29:20.579] - result already collected: FutureResult
[09:29:20.579] result() for ClusterFuture ... done
[09:29:20.579] result() for ClusterFuture ...
[09:29:20.579] - result already collected: FutureResult
[09:29:20.579] result() for ClusterFuture ... done
[09:29:20.579] result() for ClusterFuture ...
[09:29:20.579] - result already collected: FutureResult
[09:29:20.579] result() for ClusterFuture ... done
[09:29:20.579] result() for ClusterFuture ...
[09:29:20.579] - result already collected: FutureResult
[09:29:20.579] result() for ClusterFuture ... done
[09:29:20.579]  - Number of value chunks collected: 2
[09:29:20.580] Resolving 2 futures (chunks) ... DONE
[09:29:20.580] Reducing values from 2 chunks ...
[09:29:20.580]  - Number of values collected after concatenation: 2
[09:29:20.580]  - Number of values expected: 2
[09:29:20.580] Reducing values from 2 chunks ... DONE
[09:29:20.580] future_mapply() ... DONE
[09:29:20.580] future_mapply() ...
[09:29:20.583] Number of chunks: 2
[09:29:20.584] getGlobalsAndPackagesXApply() ...
[09:29:20.584]  - future.globals: TRUE
[09:29:20.584] getGlobalsAndPackages() ...
[09:29:20.584] Searching for globals...
[09:29:20.585] - globals found: [1] ‘FUN’
[09:29:20.585] Searching for globals ... DONE
[09:29:20.585] Resolving globals: FALSE
[09:29:20.585] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[09:29:20.586] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[09:29:20.586] - globals: [1] ‘FUN’
[09:29:20.586] 
[09:29:20.586] getGlobalsAndPackages() ... DONE
[09:29:20.586]  - globals found/used: [n=1] ‘FUN’
[09:29:20.586]  - needed namespaces: [n=0] 
[09:29:20.586] Finding globals ... DONE
[09:29:20.586] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:20.586] List of 2
[09:29:20.586]  $ ...future.FUN:function (x, y)  
[09:29:20.586]  $ MoreArgs     :List of 1
[09:29:20.586]   ..$ y: int [1:2] 3 4
[09:29:20.586]  - attr(*, "where")=List of 2
[09:29:20.586]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:20.586]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:20.586]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:20.586]  - attr(*, "resolved")= logi FALSE
[09:29:20.586]  - attr(*, "total_size")= num NA
[09:29:20.589] Packages to be attached in all futures: [n=0] 
[09:29:20.589] getGlobalsAndPackagesXApply() ... DONE
[09:29:20.590] Number of futures (= number of chunks): 2
[09:29:20.590] Launching 2 futures (chunks) ...
[09:29:20.590] Chunk #1 of 2 ...
[09:29:20.590]  - Finding globals in '...' for chunk #1 ...
[09:29:20.590] getGlobalsAndPackages() ...
[09:29:20.590] Searching for globals...
[09:29:20.590] 
[09:29:20.590] Searching for globals ... DONE
[09:29:20.590] - globals: [0] <none>
[09:29:20.591] getGlobalsAndPackages() ... DONE
[09:29:20.591]    + additional globals found: [n=0] 
[09:29:20.591]    + additional namespaces needed: [n=0] 
[09:29:20.591]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:20.591]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:20.591]  - seeds: <none>
[09:29:20.591]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.591] getGlobalsAndPackages() ...
[09:29:20.591] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.591] Resolving globals: FALSE
[09:29:20.592] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[09:29:20.592] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[09:29:20.592] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.592] 
[09:29:20.593] getGlobalsAndPackages() ... DONE
[09:29:20.593] run() for ‘Future’ ...
[09:29:20.593] - state: ‘created’
[09:29:20.593] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.606] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.607] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.607]   - Field: ‘node’
[09:29:20.607]   - Field: ‘label’
[09:29:20.607]   - Field: ‘local’
[09:29:20.607]   - Field: ‘owner’
[09:29:20.607]   - Field: ‘envir’
[09:29:20.607]   - Field: ‘workers’
[09:29:20.607]   - Field: ‘packages’
[09:29:20.607]   - Field: ‘gc’
[09:29:20.607]   - Field: ‘conditions’
[09:29:20.608]   - Field: ‘persistent’
[09:29:20.608]   - Field: ‘expr’
[09:29:20.608]   - Field: ‘uuid’
[09:29:20.608]   - Field: ‘seed’
[09:29:20.608]   - Field: ‘version’
[09:29:20.608]   - Field: ‘result’
[09:29:20.608]   - Field: ‘asynchronous’
[09:29:20.608]   - Field: ‘calls’
[09:29:20.608]   - Field: ‘globals’
[09:29:20.608]   - Field: ‘stdout’
[09:29:20.609]   - Field: ‘earlySignal’
[09:29:20.609]   - Field: ‘lazy’
[09:29:20.609]   - Field: ‘state’
[09:29:20.609] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.609] - Launch lazy future ...
[09:29:20.609] Packages needed by the future expression (n = 0): <none>
[09:29:20.609] Packages needed by future strategies (n = 0): <none>
[09:29:20.610] {
[09:29:20.610]     {
[09:29:20.610]         {
[09:29:20.610]             ...future.startTime <- base::Sys.time()
[09:29:20.610]             {
[09:29:20.610]                 {
[09:29:20.610]                   {
[09:29:20.610]                     {
[09:29:20.610]                       base::local({
[09:29:20.610]                         has_future <- base::requireNamespace("future", 
[09:29:20.610]                           quietly = TRUE)
[09:29:20.610]                         if (has_future) {
[09:29:20.610]                           ns <- base::getNamespace("future")
[09:29:20.610]                           version <- ns[[".package"]][["version"]]
[09:29:20.610]                           if (is.null(version)) 
[09:29:20.610]                             version <- utils::packageVersion("future")
[09:29:20.610]                         }
[09:29:20.610]                         else {
[09:29:20.610]                           version <- NULL
[09:29:20.610]                         }
[09:29:20.610]                         if (!has_future || version < "1.8.0") {
[09:29:20.610]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.610]                             "", base::R.version$version.string), 
[09:29:20.610]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:20.610]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:20.610]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.610]                               "release", "version")], collapse = " "), 
[09:29:20.610]                             hostname = base::Sys.info()[["nodename"]])
[09:29:20.610]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.610]                             info)
[09:29:20.610]                           info <- base::paste(info, collapse = "; ")
[09:29:20.610]                           if (!has_future) {
[09:29:20.610]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.610]                               info)
[09:29:20.610]                           }
[09:29:20.610]                           else {
[09:29:20.610]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.610]                               info, version)
[09:29:20.610]                           }
[09:29:20.610]                           base::stop(msg)
[09:29:20.610]                         }
[09:29:20.610]                       })
[09:29:20.610]                     }
[09:29:20.610]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.610]                     base::options(mc.cores = 1L)
[09:29:20.610]                   }
[09:29:20.610]                   ...future.strategy.old <- future::plan("list")
[09:29:20.610]                   options(future.plan = NULL)
[09:29:20.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.610]                 }
[09:29:20.610]                 ...future.workdir <- getwd()
[09:29:20.610]             }
[09:29:20.610]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.610]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.610]         }
[09:29:20.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.610]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:20.610]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.610]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.610]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.610]             base::names(...future.oldOptions))
[09:29:20.610]     }
[09:29:20.610]     if (FALSE) {
[09:29:20.610]     }
[09:29:20.610]     else {
[09:29:20.610]         if (TRUE) {
[09:29:20.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.610]                 open = "w")
[09:29:20.610]         }
[09:29:20.610]         else {
[09:29:20.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.610]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.610]         }
[09:29:20.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.610]             base::sink(type = "output", split = FALSE)
[09:29:20.610]             base::close(...future.stdout)
[09:29:20.610]         }, add = TRUE)
[09:29:20.610]     }
[09:29:20.610]     ...future.frame <- base::sys.nframe()
[09:29:20.610]     ...future.conditions <- base::list()
[09:29:20.610]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.610]     if (FALSE) {
[09:29:20.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.610]     }
[09:29:20.610]     ...future.result <- base::tryCatch({
[09:29:20.610]         base::withCallingHandlers({
[09:29:20.610]             ...future.value <- base::withVisible(base::local({
[09:29:20.610]                 ...future.makeSendCondition <- base::local({
[09:29:20.610]                   sendCondition <- NULL
[09:29:20.610]                   function(frame = 1L) {
[09:29:20.610]                     if (is.function(sendCondition)) 
[09:29:20.610]                       return(sendCondition)
[09:29:20.610]                     ns <- getNamespace("parallel")
[09:29:20.610]                     if (exists("sendData", mode = "function", 
[09:29:20.610]                       envir = ns)) {
[09:29:20.610]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.610]                         envir = ns)
[09:29:20.610]                       envir <- sys.frame(frame)
[09:29:20.610]                       master <- NULL
[09:29:20.610]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.610]                         !identical(envir, emptyenv())) {
[09:29:20.610]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.610]                           inherits = FALSE)) {
[09:29:20.610]                           master <- get("master", mode = "list", 
[09:29:20.610]                             envir = envir, inherits = FALSE)
[09:29:20.610]                           if (inherits(master, c("SOCKnode", 
[09:29:20.610]                             "SOCK0node"))) {
[09:29:20.610]                             sendCondition <<- function(cond) {
[09:29:20.610]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.610]                                 success = TRUE)
[09:29:20.610]                               parallel_sendData(master, data)
[09:29:20.610]                             }
[09:29:20.610]                             return(sendCondition)
[09:29:20.610]                           }
[09:29:20.610]                         }
[09:29:20.610]                         frame <- frame + 1L
[09:29:20.610]                         envir <- sys.frame(frame)
[09:29:20.610]                       }
[09:29:20.610]                     }
[09:29:20.610]                     sendCondition <<- function(cond) NULL
[09:29:20.610]                   }
[09:29:20.610]                 })
[09:29:20.610]                 withCallingHandlers({
[09:29:20.610]                   {
[09:29:20.610]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.610]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.610]                       ...future.globals.maxSize)) {
[09:29:20.610]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.610]                       on.exit(options(oopts), add = TRUE)
[09:29:20.610]                     }
[09:29:20.610]                     {
[09:29:20.610]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.610]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.610]                         USE.NAMES = FALSE)
[09:29:20.610]                       do.call(mapply, args = args)
[09:29:20.610]                     }
[09:29:20.610]                   }
[09:29:20.610]                 }, immediateCondition = function(cond) {
[09:29:20.610]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.610]                   sendCondition(cond)
[09:29:20.610]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.610]                   {
[09:29:20.610]                     inherits <- base::inherits
[09:29:20.610]                     invokeRestart <- base::invokeRestart
[09:29:20.610]                     is.null <- base::is.null
[09:29:20.610]                     muffled <- FALSE
[09:29:20.610]                     if (inherits(cond, "message")) {
[09:29:20.610]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.610]                       if (muffled) 
[09:29:20.610]                         invokeRestart("muffleMessage")
[09:29:20.610]                     }
[09:29:20.610]                     else if (inherits(cond, "warning")) {
[09:29:20.610]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.610]                       if (muffled) 
[09:29:20.610]                         invokeRestart("muffleWarning")
[09:29:20.610]                     }
[09:29:20.610]                     else if (inherits(cond, "condition")) {
[09:29:20.610]                       if (!is.null(pattern)) {
[09:29:20.610]                         computeRestarts <- base::computeRestarts
[09:29:20.610]                         grepl <- base::grepl
[09:29:20.610]                         restarts <- computeRestarts(cond)
[09:29:20.610]                         for (restart in restarts) {
[09:29:20.610]                           name <- restart$name
[09:29:20.610]                           if (is.null(name)) 
[09:29:20.610]                             next
[09:29:20.610]                           if (!grepl(pattern, name)) 
[09:29:20.610]                             next
[09:29:20.610]                           invokeRestart(restart)
[09:29:20.610]                           muffled <- TRUE
[09:29:20.610]                           break
[09:29:20.610]                         }
[09:29:20.610]                       }
[09:29:20.610]                     }
[09:29:20.610]                     invisible(muffled)
[09:29:20.610]                   }
[09:29:20.610]                   muffleCondition(cond)
[09:29:20.610]                 })
[09:29:20.610]             }))
[09:29:20.610]             future::FutureResult(value = ...future.value$value, 
[09:29:20.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.610]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.610]                     ...future.globalenv.names))
[09:29:20.610]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.610]         }, condition = base::local({
[09:29:20.610]             c <- base::c
[09:29:20.610]             inherits <- base::inherits
[09:29:20.610]             invokeRestart <- base::invokeRestart
[09:29:20.610]             length <- base::length
[09:29:20.610]             list <- base::list
[09:29:20.610]             seq.int <- base::seq.int
[09:29:20.610]             signalCondition <- base::signalCondition
[09:29:20.610]             sys.calls <- base::sys.calls
[09:29:20.610]             `[[` <- base::`[[`
[09:29:20.610]             `+` <- base::`+`
[09:29:20.610]             `<<-` <- base::`<<-`
[09:29:20.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.610]                   3L)]
[09:29:20.610]             }
[09:29:20.610]             function(cond) {
[09:29:20.610]                 is_error <- inherits(cond, "error")
[09:29:20.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.610]                   NULL)
[09:29:20.610]                 if (is_error) {
[09:29:20.610]                   sessionInformation <- function() {
[09:29:20.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.610]                       search = base::search(), system = base::Sys.info())
[09:29:20.610]                   }
[09:29:20.610]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.610]                     cond$call), session = sessionInformation(), 
[09:29:20.610]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.610]                   signalCondition(cond)
[09:29:20.610]                 }
[09:29:20.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.610]                 "immediateCondition"))) {
[09:29:20.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.610]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.610]                   if (TRUE && !signal) {
[09:29:20.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.610]                     {
[09:29:20.610]                       inherits <- base::inherits
[09:29:20.610]                       invokeRestart <- base::invokeRestart
[09:29:20.610]                       is.null <- base::is.null
[09:29:20.610]                       muffled <- FALSE
[09:29:20.610]                       if (inherits(cond, "message")) {
[09:29:20.610]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.610]                         if (muffled) 
[09:29:20.610]                           invokeRestart("muffleMessage")
[09:29:20.610]                       }
[09:29:20.610]                       else if (inherits(cond, "warning")) {
[09:29:20.610]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.610]                         if (muffled) 
[09:29:20.610]                           invokeRestart("muffleWarning")
[09:29:20.610]                       }
[09:29:20.610]                       else if (inherits(cond, "condition")) {
[09:29:20.610]                         if (!is.null(pattern)) {
[09:29:20.610]                           computeRestarts <- base::computeRestarts
[09:29:20.610]                           grepl <- base::grepl
[09:29:20.610]                           restarts <- computeRestarts(cond)
[09:29:20.610]                           for (restart in restarts) {
[09:29:20.610]                             name <- restart$name
[09:29:20.610]                             if (is.null(name)) 
[09:29:20.610]                               next
[09:29:20.610]                             if (!grepl(pattern, name)) 
[09:29:20.610]                               next
[09:29:20.610]                             invokeRestart(restart)
[09:29:20.610]                             muffled <- TRUE
[09:29:20.610]                             break
[09:29:20.610]                           }
[09:29:20.610]                         }
[09:29:20.610]                       }
[09:29:20.610]                       invisible(muffled)
[09:29:20.610]                     }
[09:29:20.610]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.610]                   }
[09:29:20.610]                 }
[09:29:20.610]                 else {
[09:29:20.610]                   if (TRUE) {
[09:29:20.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.610]                     {
[09:29:20.610]                       inherits <- base::inherits
[09:29:20.610]                       invokeRestart <- base::invokeRestart
[09:29:20.610]                       is.null <- base::is.null
[09:29:20.610]                       muffled <- FALSE
[09:29:20.610]                       if (inherits(cond, "message")) {
[09:29:20.610]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.610]                         if (muffled) 
[09:29:20.610]                           invokeRestart("muffleMessage")
[09:29:20.610]                       }
[09:29:20.610]                       else if (inherits(cond, "warning")) {
[09:29:20.610]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.610]                         if (muffled) 
[09:29:20.610]                           invokeRestart("muffleWarning")
[09:29:20.610]                       }
[09:29:20.610]                       else if (inherits(cond, "condition")) {
[09:29:20.610]                         if (!is.null(pattern)) {
[09:29:20.610]                           computeRestarts <- base::computeRestarts
[09:29:20.610]                           grepl <- base::grepl
[09:29:20.610]                           restarts <- computeRestarts(cond)
[09:29:20.610]                           for (restart in restarts) {
[09:29:20.610]                             name <- restart$name
[09:29:20.610]                             if (is.null(name)) 
[09:29:20.610]                               next
[09:29:20.610]                             if (!grepl(pattern, name)) 
[09:29:20.610]                               next
[09:29:20.610]                             invokeRestart(restart)
[09:29:20.610]                             muffled <- TRUE
[09:29:20.610]                             break
[09:29:20.610]                           }
[09:29:20.610]                         }
[09:29:20.610]                       }
[09:29:20.610]                       invisible(muffled)
[09:29:20.610]                     }
[09:29:20.610]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.610]                   }
[09:29:20.610]                 }
[09:29:20.610]             }
[09:29:20.610]         }))
[09:29:20.610]     }, error = function(ex) {
[09:29:20.610]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.610]                 ...future.rng), started = ...future.startTime, 
[09:29:20.610]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.610]             version = "1.8"), class = "FutureResult")
[09:29:20.610]     }, finally = {
[09:29:20.610]         if (!identical(...future.workdir, getwd())) 
[09:29:20.610]             setwd(...future.workdir)
[09:29:20.610]         {
[09:29:20.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.610]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.610]             }
[09:29:20.610]             base::options(...future.oldOptions)
[09:29:20.610]             if (.Platform$OS.type == "windows") {
[09:29:20.610]                 old_names <- names(...future.oldEnvVars)
[09:29:20.610]                 envs <- base::Sys.getenv()
[09:29:20.610]                 names <- names(envs)
[09:29:20.610]                 common <- intersect(names, old_names)
[09:29:20.610]                 added <- setdiff(names, old_names)
[09:29:20.610]                 removed <- setdiff(old_names, names)
[09:29:20.610]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.610]                   envs[common]]
[09:29:20.610]                 NAMES <- toupper(changed)
[09:29:20.610]                 args <- list()
[09:29:20.610]                 for (kk in seq_along(NAMES)) {
[09:29:20.610]                   name <- changed[[kk]]
[09:29:20.610]                   NAME <- NAMES[[kk]]
[09:29:20.610]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.610]                     next
[09:29:20.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.610]                 }
[09:29:20.610]                 NAMES <- toupper(added)
[09:29:20.610]                 for (kk in seq_along(NAMES)) {
[09:29:20.610]                   name <- added[[kk]]
[09:29:20.610]                   NAME <- NAMES[[kk]]
[09:29:20.610]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.610]                     next
[09:29:20.610]                   args[[name]] <- ""
[09:29:20.610]                 }
[09:29:20.610]                 NAMES <- toupper(removed)
[09:29:20.610]                 for (kk in seq_along(NAMES)) {
[09:29:20.610]                   name <- removed[[kk]]
[09:29:20.610]                   NAME <- NAMES[[kk]]
[09:29:20.610]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.610]                     next
[09:29:20.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.610]                 }
[09:29:20.610]                 if (length(args) > 0) 
[09:29:20.610]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.610]             }
[09:29:20.610]             else {
[09:29:20.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.610]             }
[09:29:20.610]             {
[09:29:20.610]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.610]                   0L) {
[09:29:20.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.610]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.610]                   base::options(opts)
[09:29:20.610]                 }
[09:29:20.610]                 {
[09:29:20.610]                   {
[09:29:20.610]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.610]                     NULL
[09:29:20.610]                   }
[09:29:20.610]                   options(future.plan = NULL)
[09:29:20.610]                   if (is.na(NA_character_)) 
[09:29:20.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.610]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.610]                     .init = FALSE)
[09:29:20.610]                 }
[09:29:20.610]             }
[09:29:20.610]         }
[09:29:20.610]     })
[09:29:20.610]     if (TRUE) {
[09:29:20.610]         base::sink(type = "output", split = FALSE)
[09:29:20.610]         if (TRUE) {
[09:29:20.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.610]         }
[09:29:20.610]         else {
[09:29:20.610]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.610]         }
[09:29:20.610]         base::close(...future.stdout)
[09:29:20.610]         ...future.stdout <- NULL
[09:29:20.610]     }
[09:29:20.610]     ...future.result$conditions <- ...future.conditions
[09:29:20.610]     ...future.result$finished <- base::Sys.time()
[09:29:20.610]     ...future.result
[09:29:20.610] }
[09:29:20.612] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[09:29:20.612] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[09:29:20.613] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[09:29:20.613] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[09:29:20.613] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[09:29:20.613] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[09:29:20.614] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[09:29:20.614] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:20.614] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.614] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:20.614] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.614] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[09:29:20.615] MultisessionFuture started
[09:29:20.615] - Launch lazy future ... done
[09:29:20.615] run() for ‘MultisessionFuture’ ... done
[09:29:20.615] Created future:
[09:29:20.615] MultisessionFuture:
[09:29:20.615] Label: ‘future_.mapply-1’
[09:29:20.615] Expression:
[09:29:20.615] {
[09:29:20.615]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.615]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.615]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.615]         on.exit(options(oopts), add = TRUE)
[09:29:20.615]     }
[09:29:20.615]     {
[09:29:20.615]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.615]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.615]         do.call(mapply, args = args)
[09:29:20.615]     }
[09:29:20.615] }
[09:29:20.615] Lazy evaluation: FALSE
[09:29:20.615] Asynchronous evaluation: TRUE
[09:29:20.615] Local evaluation: TRUE
[09:29:20.615] Environment: R_GlobalEnv
[09:29:20.615] Capture standard output: TRUE
[09:29:20.615] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.615] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.615] Packages: <none>
[09:29:20.615] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:20.615] Resolved: FALSE
[09:29:20.615] Value: <not collected>
[09:29:20.615] Conditions captured: <none>
[09:29:20.615] Early signaling: FALSE
[09:29:20.615] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.615] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.627] Chunk #1 of 2 ... DONE
[09:29:20.627] Chunk #2 of 2 ...
[09:29:20.627]  - Finding globals in '...' for chunk #2 ...
[09:29:20.627] getGlobalsAndPackages() ...
[09:29:20.627] Searching for globals...
[09:29:20.627] 
[09:29:20.628] Searching for globals ... DONE
[09:29:20.628] - globals: [0] <none>
[09:29:20.628] getGlobalsAndPackages() ... DONE
[09:29:20.628]    + additional globals found: [n=0] 
[09:29:20.628]    + additional namespaces needed: [n=0] 
[09:29:20.628]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:20.628]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:20.628]  - seeds: <none>
[09:29:20.628]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.628] getGlobalsAndPackages() ...
[09:29:20.629] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.629] Resolving globals: FALSE
[09:29:20.629] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[09:29:20.630] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[09:29:20.630] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.630] 
[09:29:20.630] getGlobalsAndPackages() ... DONE
[09:29:20.630] run() for ‘Future’ ...
[09:29:20.630] - state: ‘created’
[09:29:20.630] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.644] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.644] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.644]   - Field: ‘node’
[09:29:20.644]   - Field: ‘label’
[09:29:20.644]   - Field: ‘local’
[09:29:20.644]   - Field: ‘owner’
[09:29:20.645]   - Field: ‘envir’
[09:29:20.645]   - Field: ‘workers’
[09:29:20.645]   - Field: ‘packages’
[09:29:20.645]   - Field: ‘gc’
[09:29:20.645]   - Field: ‘conditions’
[09:29:20.645]   - Field: ‘persistent’
[09:29:20.645]   - Field: ‘expr’
[09:29:20.645]   - Field: ‘uuid’
[09:29:20.645]   - Field: ‘seed’
[09:29:20.645]   - Field: ‘version’
[09:29:20.645]   - Field: ‘result’
[09:29:20.646]   - Field: ‘asynchronous’
[09:29:20.646]   - Field: ‘calls’
[09:29:20.646]   - Field: ‘globals’
[09:29:20.646]   - Field: ‘stdout’
[09:29:20.646]   - Field: ‘earlySignal’
[09:29:20.646]   - Field: ‘lazy’
[09:29:20.646]   - Field: ‘state’
[09:29:20.646] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.646] - Launch lazy future ...
[09:29:20.647] Packages needed by the future expression (n = 0): <none>
[09:29:20.647] Packages needed by future strategies (n = 0): <none>
[09:29:20.647] {
[09:29:20.647]     {
[09:29:20.647]         {
[09:29:20.647]             ...future.startTime <- base::Sys.time()
[09:29:20.647]             {
[09:29:20.647]                 {
[09:29:20.647]                   {
[09:29:20.647]                     {
[09:29:20.647]                       base::local({
[09:29:20.647]                         has_future <- base::requireNamespace("future", 
[09:29:20.647]                           quietly = TRUE)
[09:29:20.647]                         if (has_future) {
[09:29:20.647]                           ns <- base::getNamespace("future")
[09:29:20.647]                           version <- ns[[".package"]][["version"]]
[09:29:20.647]                           if (is.null(version)) 
[09:29:20.647]                             version <- utils::packageVersion("future")
[09:29:20.647]                         }
[09:29:20.647]                         else {
[09:29:20.647]                           version <- NULL
[09:29:20.647]                         }
[09:29:20.647]                         if (!has_future || version < "1.8.0") {
[09:29:20.647]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.647]                             "", base::R.version$version.string), 
[09:29:20.647]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:20.647]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:20.647]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.647]                               "release", "version")], collapse = " "), 
[09:29:20.647]                             hostname = base::Sys.info()[["nodename"]])
[09:29:20.647]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.647]                             info)
[09:29:20.647]                           info <- base::paste(info, collapse = "; ")
[09:29:20.647]                           if (!has_future) {
[09:29:20.647]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.647]                               info)
[09:29:20.647]                           }
[09:29:20.647]                           else {
[09:29:20.647]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.647]                               info, version)
[09:29:20.647]                           }
[09:29:20.647]                           base::stop(msg)
[09:29:20.647]                         }
[09:29:20.647]                       })
[09:29:20.647]                     }
[09:29:20.647]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.647]                     base::options(mc.cores = 1L)
[09:29:20.647]                   }
[09:29:20.647]                   ...future.strategy.old <- future::plan("list")
[09:29:20.647]                   options(future.plan = NULL)
[09:29:20.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.647]                 }
[09:29:20.647]                 ...future.workdir <- getwd()
[09:29:20.647]             }
[09:29:20.647]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.647]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.647]         }
[09:29:20.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.647]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:20.647]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.647]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.647]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.647]             base::names(...future.oldOptions))
[09:29:20.647]     }
[09:29:20.647]     if (FALSE) {
[09:29:20.647]     }
[09:29:20.647]     else {
[09:29:20.647]         if (TRUE) {
[09:29:20.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.647]                 open = "w")
[09:29:20.647]         }
[09:29:20.647]         else {
[09:29:20.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.647]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.647]         }
[09:29:20.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.647]             base::sink(type = "output", split = FALSE)
[09:29:20.647]             base::close(...future.stdout)
[09:29:20.647]         }, add = TRUE)
[09:29:20.647]     }
[09:29:20.647]     ...future.frame <- base::sys.nframe()
[09:29:20.647]     ...future.conditions <- base::list()
[09:29:20.647]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.647]     if (FALSE) {
[09:29:20.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.647]     }
[09:29:20.647]     ...future.result <- base::tryCatch({
[09:29:20.647]         base::withCallingHandlers({
[09:29:20.647]             ...future.value <- base::withVisible(base::local({
[09:29:20.647]                 ...future.makeSendCondition <- base::local({
[09:29:20.647]                   sendCondition <- NULL
[09:29:20.647]                   function(frame = 1L) {
[09:29:20.647]                     if (is.function(sendCondition)) 
[09:29:20.647]                       return(sendCondition)
[09:29:20.647]                     ns <- getNamespace("parallel")
[09:29:20.647]                     if (exists("sendData", mode = "function", 
[09:29:20.647]                       envir = ns)) {
[09:29:20.647]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.647]                         envir = ns)
[09:29:20.647]                       envir <- sys.frame(frame)
[09:29:20.647]                       master <- NULL
[09:29:20.647]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.647]                         !identical(envir, emptyenv())) {
[09:29:20.647]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.647]                           inherits = FALSE)) {
[09:29:20.647]                           master <- get("master", mode = "list", 
[09:29:20.647]                             envir = envir, inherits = FALSE)
[09:29:20.647]                           if (inherits(master, c("SOCKnode", 
[09:29:20.647]                             "SOCK0node"))) {
[09:29:20.647]                             sendCondition <<- function(cond) {
[09:29:20.647]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.647]                                 success = TRUE)
[09:29:20.647]                               parallel_sendData(master, data)
[09:29:20.647]                             }
[09:29:20.647]                             return(sendCondition)
[09:29:20.647]                           }
[09:29:20.647]                         }
[09:29:20.647]                         frame <- frame + 1L
[09:29:20.647]                         envir <- sys.frame(frame)
[09:29:20.647]                       }
[09:29:20.647]                     }
[09:29:20.647]                     sendCondition <<- function(cond) NULL
[09:29:20.647]                   }
[09:29:20.647]                 })
[09:29:20.647]                 withCallingHandlers({
[09:29:20.647]                   {
[09:29:20.647]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.647]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.647]                       ...future.globals.maxSize)) {
[09:29:20.647]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.647]                       on.exit(options(oopts), add = TRUE)
[09:29:20.647]                     }
[09:29:20.647]                     {
[09:29:20.647]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.647]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.647]                         USE.NAMES = FALSE)
[09:29:20.647]                       do.call(mapply, args = args)
[09:29:20.647]                     }
[09:29:20.647]                   }
[09:29:20.647]                 }, immediateCondition = function(cond) {
[09:29:20.647]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.647]                   sendCondition(cond)
[09:29:20.647]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.647]                   {
[09:29:20.647]                     inherits <- base::inherits
[09:29:20.647]                     invokeRestart <- base::invokeRestart
[09:29:20.647]                     is.null <- base::is.null
[09:29:20.647]                     muffled <- FALSE
[09:29:20.647]                     if (inherits(cond, "message")) {
[09:29:20.647]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.647]                       if (muffled) 
[09:29:20.647]                         invokeRestart("muffleMessage")
[09:29:20.647]                     }
[09:29:20.647]                     else if (inherits(cond, "warning")) {
[09:29:20.647]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.647]                       if (muffled) 
[09:29:20.647]                         invokeRestart("muffleWarning")
[09:29:20.647]                     }
[09:29:20.647]                     else if (inherits(cond, "condition")) {
[09:29:20.647]                       if (!is.null(pattern)) {
[09:29:20.647]                         computeRestarts <- base::computeRestarts
[09:29:20.647]                         grepl <- base::grepl
[09:29:20.647]                         restarts <- computeRestarts(cond)
[09:29:20.647]                         for (restart in restarts) {
[09:29:20.647]                           name <- restart$name
[09:29:20.647]                           if (is.null(name)) 
[09:29:20.647]                             next
[09:29:20.647]                           if (!grepl(pattern, name)) 
[09:29:20.647]                             next
[09:29:20.647]                           invokeRestart(restart)
[09:29:20.647]                           muffled <- TRUE
[09:29:20.647]                           break
[09:29:20.647]                         }
[09:29:20.647]                       }
[09:29:20.647]                     }
[09:29:20.647]                     invisible(muffled)
[09:29:20.647]                   }
[09:29:20.647]                   muffleCondition(cond)
[09:29:20.647]                 })
[09:29:20.647]             }))
[09:29:20.647]             future::FutureResult(value = ...future.value$value, 
[09:29:20.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.647]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.647]                     ...future.globalenv.names))
[09:29:20.647]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.647]         }, condition = base::local({
[09:29:20.647]             c <- base::c
[09:29:20.647]             inherits <- base::inherits
[09:29:20.647]             invokeRestart <- base::invokeRestart
[09:29:20.647]             length <- base::length
[09:29:20.647]             list <- base::list
[09:29:20.647]             seq.int <- base::seq.int
[09:29:20.647]             signalCondition <- base::signalCondition
[09:29:20.647]             sys.calls <- base::sys.calls
[09:29:20.647]             `[[` <- base::`[[`
[09:29:20.647]             `+` <- base::`+`
[09:29:20.647]             `<<-` <- base::`<<-`
[09:29:20.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.647]                   3L)]
[09:29:20.647]             }
[09:29:20.647]             function(cond) {
[09:29:20.647]                 is_error <- inherits(cond, "error")
[09:29:20.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.647]                   NULL)
[09:29:20.647]                 if (is_error) {
[09:29:20.647]                   sessionInformation <- function() {
[09:29:20.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.647]                       search = base::search(), system = base::Sys.info())
[09:29:20.647]                   }
[09:29:20.647]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.647]                     cond$call), session = sessionInformation(), 
[09:29:20.647]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.647]                   signalCondition(cond)
[09:29:20.647]                 }
[09:29:20.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.647]                 "immediateCondition"))) {
[09:29:20.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.647]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.647]                   if (TRUE && !signal) {
[09:29:20.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.647]                     {
[09:29:20.647]                       inherits <- base::inherits
[09:29:20.647]                       invokeRestart <- base::invokeRestart
[09:29:20.647]                       is.null <- base::is.null
[09:29:20.647]                       muffled <- FALSE
[09:29:20.647]                       if (inherits(cond, "message")) {
[09:29:20.647]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.647]                         if (muffled) 
[09:29:20.647]                           invokeRestart("muffleMessage")
[09:29:20.647]                       }
[09:29:20.647]                       else if (inherits(cond, "warning")) {
[09:29:20.647]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.647]                         if (muffled) 
[09:29:20.647]                           invokeRestart("muffleWarning")
[09:29:20.647]                       }
[09:29:20.647]                       else if (inherits(cond, "condition")) {
[09:29:20.647]                         if (!is.null(pattern)) {
[09:29:20.647]                           computeRestarts <- base::computeRestarts
[09:29:20.647]                           grepl <- base::grepl
[09:29:20.647]                           restarts <- computeRestarts(cond)
[09:29:20.647]                           for (restart in restarts) {
[09:29:20.647]                             name <- restart$name
[09:29:20.647]                             if (is.null(name)) 
[09:29:20.647]                               next
[09:29:20.647]                             if (!grepl(pattern, name)) 
[09:29:20.647]                               next
[09:29:20.647]                             invokeRestart(restart)
[09:29:20.647]                             muffled <- TRUE
[09:29:20.647]                             break
[09:29:20.647]                           }
[09:29:20.647]                         }
[09:29:20.647]                       }
[09:29:20.647]                       invisible(muffled)
[09:29:20.647]                     }
[09:29:20.647]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.647]                   }
[09:29:20.647]                 }
[09:29:20.647]                 else {
[09:29:20.647]                   if (TRUE) {
[09:29:20.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.647]                     {
[09:29:20.647]                       inherits <- base::inherits
[09:29:20.647]                       invokeRestart <- base::invokeRestart
[09:29:20.647]                       is.null <- base::is.null
[09:29:20.647]                       muffled <- FALSE
[09:29:20.647]                       if (inherits(cond, "message")) {
[09:29:20.647]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.647]                         if (muffled) 
[09:29:20.647]                           invokeRestart("muffleMessage")
[09:29:20.647]                       }
[09:29:20.647]                       else if (inherits(cond, "warning")) {
[09:29:20.647]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.647]                         if (muffled) 
[09:29:20.647]                           invokeRestart("muffleWarning")
[09:29:20.647]                       }
[09:29:20.647]                       else if (inherits(cond, "condition")) {
[09:29:20.647]                         if (!is.null(pattern)) {
[09:29:20.647]                           computeRestarts <- base::computeRestarts
[09:29:20.647]                           grepl <- base::grepl
[09:29:20.647]                           restarts <- computeRestarts(cond)
[09:29:20.647]                           for (restart in restarts) {
[09:29:20.647]                             name <- restart$name
[09:29:20.647]                             if (is.null(name)) 
[09:29:20.647]                               next
[09:29:20.647]                             if (!grepl(pattern, name)) 
[09:29:20.647]                               next
[09:29:20.647]                             invokeRestart(restart)
[09:29:20.647]                             muffled <- TRUE
[09:29:20.647]                             break
[09:29:20.647]                           }
[09:29:20.647]                         }
[09:29:20.647]                       }
[09:29:20.647]                       invisible(muffled)
[09:29:20.647]                     }
[09:29:20.647]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.647]                   }
[09:29:20.647]                 }
[09:29:20.647]             }
[09:29:20.647]         }))
[09:29:20.647]     }, error = function(ex) {
[09:29:20.647]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.647]                 ...future.rng), started = ...future.startTime, 
[09:29:20.647]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.647]             version = "1.8"), class = "FutureResult")
[09:29:20.647]     }, finally = {
[09:29:20.647]         if (!identical(...future.workdir, getwd())) 
[09:29:20.647]             setwd(...future.workdir)
[09:29:20.647]         {
[09:29:20.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.647]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.647]             }
[09:29:20.647]             base::options(...future.oldOptions)
[09:29:20.647]             if (.Platform$OS.type == "windows") {
[09:29:20.647]                 old_names <- names(...future.oldEnvVars)
[09:29:20.647]                 envs <- base::Sys.getenv()
[09:29:20.647]                 names <- names(envs)
[09:29:20.647]                 common <- intersect(names, old_names)
[09:29:20.647]                 added <- setdiff(names, old_names)
[09:29:20.647]                 removed <- setdiff(old_names, names)
[09:29:20.647]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.647]                   envs[common]]
[09:29:20.647]                 NAMES <- toupper(changed)
[09:29:20.647]                 args <- list()
[09:29:20.647]                 for (kk in seq_along(NAMES)) {
[09:29:20.647]                   name <- changed[[kk]]
[09:29:20.647]                   NAME <- NAMES[[kk]]
[09:29:20.647]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.647]                     next
[09:29:20.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.647]                 }
[09:29:20.647]                 NAMES <- toupper(added)
[09:29:20.647]                 for (kk in seq_along(NAMES)) {
[09:29:20.647]                   name <- added[[kk]]
[09:29:20.647]                   NAME <- NAMES[[kk]]
[09:29:20.647]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.647]                     next
[09:29:20.647]                   args[[name]] <- ""
[09:29:20.647]                 }
[09:29:20.647]                 NAMES <- toupper(removed)
[09:29:20.647]                 for (kk in seq_along(NAMES)) {
[09:29:20.647]                   name <- removed[[kk]]
[09:29:20.647]                   NAME <- NAMES[[kk]]
[09:29:20.647]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.647]                     next
[09:29:20.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.647]                 }
[09:29:20.647]                 if (length(args) > 0) 
[09:29:20.647]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.647]             }
[09:29:20.647]             else {
[09:29:20.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.647]             }
[09:29:20.647]             {
[09:29:20.647]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.647]                   0L) {
[09:29:20.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.647]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.647]                   base::options(opts)
[09:29:20.647]                 }
[09:29:20.647]                 {
[09:29:20.647]                   {
[09:29:20.647]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.647]                     NULL
[09:29:20.647]                   }
[09:29:20.647]                   options(future.plan = NULL)
[09:29:20.647]                   if (is.na(NA_character_)) 
[09:29:20.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.647]                     .init = FALSE)
[09:29:20.647]                 }
[09:29:20.647]             }
[09:29:20.647]         }
[09:29:20.647]     })
[09:29:20.647]     if (TRUE) {
[09:29:20.647]         base::sink(type = "output", split = FALSE)
[09:29:20.647]         if (TRUE) {
[09:29:20.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.647]         }
[09:29:20.647]         else {
[09:29:20.647]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.647]         }
[09:29:20.647]         base::close(...future.stdout)
[09:29:20.647]         ...future.stdout <- NULL
[09:29:20.647]     }
[09:29:20.647]     ...future.result$conditions <- ...future.conditions
[09:29:20.647]     ...future.result$finished <- base::Sys.time()
[09:29:20.647]     ...future.result
[09:29:20.647] }
[09:29:20.650] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[09:29:20.650] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[09:29:20.650] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[09:29:20.650] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[09:29:20.651] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[09:29:20.651] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[09:29:20.651] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[09:29:20.651] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:20.651] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:20.652] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:20.652] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:20.652] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[09:29:20.652] MultisessionFuture started
[09:29:20.652] - Launch lazy future ... done
[09:29:20.653] run() for ‘MultisessionFuture’ ... done
[09:29:20.653] Created future:
[09:29:20.653] MultisessionFuture:
[09:29:20.653] Label: ‘future_.mapply-2’
[09:29:20.653] Expression:
[09:29:20.653] {
[09:29:20.653]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.653]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.653]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.653]         on.exit(options(oopts), add = TRUE)
[09:29:20.653]     }
[09:29:20.653]     {
[09:29:20.653]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.653]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.653]         do.call(mapply, args = args)
[09:29:20.653]     }
[09:29:20.653] }
[09:29:20.653] Lazy evaluation: FALSE
[09:29:20.653] Asynchronous evaluation: TRUE
[09:29:20.653] Local evaluation: TRUE
[09:29:20.653] Environment: R_GlobalEnv
[09:29:20.653] Capture standard output: TRUE
[09:29:20.653] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.653] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.653] Packages: <none>
[09:29:20.653] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:20.653] Resolved: FALSE
[09:29:20.653] Value: <not collected>
[09:29:20.653] Conditions captured: <none>
[09:29:20.653] Early signaling: FALSE
[09:29:20.653] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.653] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.664] Chunk #2 of 2 ... DONE
[09:29:20.664] Launching 2 futures (chunks) ... DONE
[09:29:20.664] Resolving 2 futures (chunks) ...
[09:29:20.664] resolve() on list ...
[09:29:20.665]  recursive: 0
[09:29:20.665]  length: 2
[09:29:20.665] 
[09:29:20.665] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.665] - Validating connection of MultisessionFuture
[09:29:20.665] - received message: FutureResult
[09:29:20.666] - Received FutureResult
[09:29:20.666] - Erased future from FutureRegistry
[09:29:20.666] result() for ClusterFuture ...
[09:29:20.666] - result already collected: FutureResult
[09:29:20.666] result() for ClusterFuture ... done
[09:29:20.666] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.666] Future #1
[09:29:20.666] result() for ClusterFuture ...
[09:29:20.666] - result already collected: FutureResult
[09:29:20.666] result() for ClusterFuture ... done
[09:29:20.666] result() for ClusterFuture ...
[09:29:20.667] - result already collected: FutureResult
[09:29:20.667] result() for ClusterFuture ... done
[09:29:20.667] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:20.667] - nx: 2
[09:29:20.667] - relay: TRUE
[09:29:20.667] - stdout: TRUE
[09:29:20.667] - signal: TRUE
[09:29:20.667] - resignal: FALSE
[09:29:20.667] - force: TRUE
[09:29:20.667] - relayed: [n=2] FALSE, FALSE
[09:29:20.667] - queued futures: [n=2] FALSE, FALSE
[09:29:20.667]  - until=1
[09:29:20.668]  - relaying element #1
[09:29:20.668] result() for ClusterFuture ...
[09:29:20.668] - result already collected: FutureResult
[09:29:20.668] result() for ClusterFuture ... done
[09:29:20.668] result() for ClusterFuture ...
[09:29:20.668] - result already collected: FutureResult
[09:29:20.668] result() for ClusterFuture ... done
[09:29:20.668] result() for ClusterFuture ...
[09:29:20.668] - result already collected: FutureResult
[09:29:20.668] result() for ClusterFuture ... done
[09:29:20.668] result() for ClusterFuture ...
[09:29:20.669] - result already collected: FutureResult
[09:29:20.669] result() for ClusterFuture ... done
[09:29:20.669] - relayed: [n=2] TRUE, FALSE
[09:29:20.669] - queued futures: [n=2] TRUE, FALSE
[09:29:20.669] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:20.669]  length: 1 (resolved future 1)
[09:29:20.697] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.697] - Validating connection of MultisessionFuture
[09:29:20.697] - received message: FutureResult
[09:29:20.698] - Received FutureResult
[09:29:20.698] - Erased future from FutureRegistry
[09:29:20.698] result() for ClusterFuture ...
[09:29:20.698] - result already collected: FutureResult
[09:29:20.698] result() for ClusterFuture ... done
[09:29:20.698] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.698] Future #2
[09:29:20.698] result() for ClusterFuture ...
[09:29:20.698] - result already collected: FutureResult
[09:29:20.698] result() for ClusterFuture ... done
[09:29:20.698] result() for ClusterFuture ...
[09:29:20.699] - result already collected: FutureResult
[09:29:20.699] result() for ClusterFuture ... done
[09:29:20.699] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:20.699] - nx: 2
[09:29:20.699] - relay: TRUE
[09:29:20.699] - stdout: TRUE
[09:29:20.699] - signal: TRUE
[09:29:20.699] - resignal: FALSE
[09:29:20.699] - force: TRUE
[09:29:20.699] - relayed: [n=2] TRUE, FALSE
[09:29:20.699] - queued futures: [n=2] TRUE, FALSE
[09:29:20.700]  - until=2
[09:29:20.700]  - relaying element #2
[09:29:20.700] result() for ClusterFuture ...
[09:29:20.700] - result already collected: FutureResult
[09:29:20.700] result() for ClusterFuture ... done
[09:29:20.700] result() for ClusterFuture ...
[09:29:20.700] - result already collected: FutureResult
[09:29:20.700] result() for ClusterFuture ... done
[09:29:20.700] result() for ClusterFuture ...
[09:29:20.700] - result already collected: FutureResult
[09:29:20.700] result() for ClusterFuture ... done
[09:29:20.701] result() for ClusterFuture ...
[09:29:20.701] - result already collected: FutureResult
[09:29:20.701] result() for ClusterFuture ... done
[09:29:20.701] - relayed: [n=2] TRUE, TRUE
[09:29:20.701] - queued futures: [n=2] TRUE, TRUE
[09:29:20.701] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:20.701]  length: 0 (resolved future 2)
[09:29:20.701] Relaying remaining futures
[09:29:20.701] signalConditionsASAP(NULL, pos=0) ...
[09:29:20.701] - nx: 2
[09:29:20.701] - relay: TRUE
[09:29:20.701] - stdout: TRUE
[09:29:20.701] - signal: TRUE
[09:29:20.702] - resignal: FALSE
[09:29:20.702] - force: TRUE
[09:29:20.702] - relayed: [n=2] TRUE, TRUE
[09:29:20.702] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:20.702] - relayed: [n=2] TRUE, TRUE
[09:29:20.702] - queued futures: [n=2] TRUE, TRUE
[09:29:20.702] signalConditionsASAP(NULL, pos=0) ... done
[09:29:20.702] resolve() on list ... DONE
[09:29:20.702] result() for ClusterFuture ...
[09:29:20.702] - result already collected: FutureResult
[09:29:20.702] result() for ClusterFuture ... done
[09:29:20.703] result() for ClusterFuture ...
[09:29:20.703] - result already collected: FutureResult
[09:29:20.703] result() for ClusterFuture ... done
[09:29:20.703] result() for ClusterFuture ...
[09:29:20.703] - result already collected: FutureResult
[09:29:20.703] result() for ClusterFuture ... done
[09:29:20.703] result() for ClusterFuture ...
[09:29:20.703] - result already collected: FutureResult
[09:29:20.703] result() for ClusterFuture ... done
[09:29:20.703]  - Number of value chunks collected: 2
[09:29:20.703] Resolving 2 futures (chunks) ... DONE
[09:29:20.704] Reducing values from 2 chunks ...
[09:29:20.704]  - Number of values collected after concatenation: 2
[09:29:20.704]  - Number of values expected: 2
[09:29:20.704] Reducing values from 2 chunks ... DONE
[09:29:20.704] future_mapply() ... DONE
- Recycle arguments to same length ...
[09:29:20.707] future_mapply() ...
[09:29:20.710] Number of chunks: 2
[09:29:20.710] getGlobalsAndPackagesXApply() ...
[09:29:20.710]  - future.globals: TRUE
[09:29:20.710] getGlobalsAndPackages() ...
[09:29:20.711] Searching for globals...
[09:29:20.711] - globals found: [1] ‘FUN’
[09:29:20.711] Searching for globals ... DONE
[09:29:20.711] Resolving globals: FALSE
[09:29:20.712] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:20.712] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:20.712] - globals: [1] ‘FUN’
[09:29:20.712] 
[09:29:20.712] getGlobalsAndPackages() ... DONE
[09:29:20.712]  - globals found/used: [n=1] ‘FUN’
[09:29:20.712]  - needed namespaces: [n=0] 
[09:29:20.713] Finding globals ... DONE
[09:29:20.713] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:20.713] List of 2
[09:29:20.713]  $ ...future.FUN:function (x, ...)  
[09:29:20.713]  $ MoreArgs     : NULL
[09:29:20.713]  - attr(*, "where")=List of 2
[09:29:20.713]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:20.713]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:20.713]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:20.713]  - attr(*, "resolved")= logi FALSE
[09:29:20.713]  - attr(*, "total_size")= num NA
[09:29:20.715] Packages to be attached in all futures: [n=0] 
[09:29:20.715] getGlobalsAndPackagesXApply() ... DONE
[09:29:20.715] Number of futures (= number of chunks): 2
[09:29:20.716] Launching 2 futures (chunks) ...
[09:29:20.716] Chunk #1 of 2 ...
[09:29:20.716]  - Finding globals in '...' for chunk #1 ...
[09:29:20.716] getGlobalsAndPackages() ...
[09:29:20.716] Searching for globals...
[09:29:20.716] 
[09:29:20.716] Searching for globals ... DONE
[09:29:20.716] - globals: [0] <none>
[09:29:20.717] getGlobalsAndPackages() ... DONE
[09:29:20.717]    + additional globals found: [n=0] 
[09:29:20.717]    + additional namespaces needed: [n=0] 
[09:29:20.717]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:20.717]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:20.717]  - seeds: <none>
[09:29:20.717]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.717] getGlobalsAndPackages() ...
[09:29:20.717] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.717] Resolving globals: FALSE
[09:29:20.718] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:20.718] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:20.718] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.718] 
[09:29:20.719] getGlobalsAndPackages() ... DONE
[09:29:20.719] run() for ‘Future’ ...
[09:29:20.719] - state: ‘created’
[09:29:20.719] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.733] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.733] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.733]   - Field: ‘node’
[09:29:20.733]   - Field: ‘label’
[09:29:20.733]   - Field: ‘local’
[09:29:20.733]   - Field: ‘owner’
[09:29:20.733]   - Field: ‘envir’
[09:29:20.733]   - Field: ‘workers’
[09:29:20.733]   - Field: ‘packages’
[09:29:20.734]   - Field: ‘gc’
[09:29:20.734]   - Field: ‘conditions’
[09:29:20.734]   - Field: ‘persistent’
[09:29:20.734]   - Field: ‘expr’
[09:29:20.734]   - Field: ‘uuid’
[09:29:20.734]   - Field: ‘seed’
[09:29:20.734]   - Field: ‘version’
[09:29:20.734]   - Field: ‘result’
[09:29:20.734]   - Field: ‘asynchronous’
[09:29:20.734]   - Field: ‘calls’
[09:29:20.734]   - Field: ‘globals’
[09:29:20.734]   - Field: ‘stdout’
[09:29:20.735]   - Field: ‘earlySignal’
[09:29:20.735]   - Field: ‘lazy’
[09:29:20.735]   - Field: ‘state’
[09:29:20.735] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.735] - Launch lazy future ...
[09:29:20.735] Packages needed by the future expression (n = 0): <none>
[09:29:20.735] Packages needed by future strategies (n = 0): <none>
[09:29:20.736] {
[09:29:20.736]     {
[09:29:20.736]         {
[09:29:20.736]             ...future.startTime <- base::Sys.time()
[09:29:20.736]             {
[09:29:20.736]                 {
[09:29:20.736]                   {
[09:29:20.736]                     {
[09:29:20.736]                       base::local({
[09:29:20.736]                         has_future <- base::requireNamespace("future", 
[09:29:20.736]                           quietly = TRUE)
[09:29:20.736]                         if (has_future) {
[09:29:20.736]                           ns <- base::getNamespace("future")
[09:29:20.736]                           version <- ns[[".package"]][["version"]]
[09:29:20.736]                           if (is.null(version)) 
[09:29:20.736]                             version <- utils::packageVersion("future")
[09:29:20.736]                         }
[09:29:20.736]                         else {
[09:29:20.736]                           version <- NULL
[09:29:20.736]                         }
[09:29:20.736]                         if (!has_future || version < "1.8.0") {
[09:29:20.736]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.736]                             "", base::R.version$version.string), 
[09:29:20.736]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:20.736]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:20.736]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.736]                               "release", "version")], collapse = " "), 
[09:29:20.736]                             hostname = base::Sys.info()[["nodename"]])
[09:29:20.736]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.736]                             info)
[09:29:20.736]                           info <- base::paste(info, collapse = "; ")
[09:29:20.736]                           if (!has_future) {
[09:29:20.736]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.736]                               info)
[09:29:20.736]                           }
[09:29:20.736]                           else {
[09:29:20.736]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.736]                               info, version)
[09:29:20.736]                           }
[09:29:20.736]                           base::stop(msg)
[09:29:20.736]                         }
[09:29:20.736]                       })
[09:29:20.736]                     }
[09:29:20.736]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.736]                     base::options(mc.cores = 1L)
[09:29:20.736]                   }
[09:29:20.736]                   ...future.strategy.old <- future::plan("list")
[09:29:20.736]                   options(future.plan = NULL)
[09:29:20.736]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.736]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.736]                 }
[09:29:20.736]                 ...future.workdir <- getwd()
[09:29:20.736]             }
[09:29:20.736]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.736]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.736]         }
[09:29:20.736]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.736]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:20.736]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.736]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.736]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.736]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.736]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.736]             base::names(...future.oldOptions))
[09:29:20.736]     }
[09:29:20.736]     if (FALSE) {
[09:29:20.736]     }
[09:29:20.736]     else {
[09:29:20.736]         if (TRUE) {
[09:29:20.736]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.736]                 open = "w")
[09:29:20.736]         }
[09:29:20.736]         else {
[09:29:20.736]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.736]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.736]         }
[09:29:20.736]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.736]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.736]             base::sink(type = "output", split = FALSE)
[09:29:20.736]             base::close(...future.stdout)
[09:29:20.736]         }, add = TRUE)
[09:29:20.736]     }
[09:29:20.736]     ...future.frame <- base::sys.nframe()
[09:29:20.736]     ...future.conditions <- base::list()
[09:29:20.736]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.736]     if (FALSE) {
[09:29:20.736]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.736]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.736]     }
[09:29:20.736]     ...future.result <- base::tryCatch({
[09:29:20.736]         base::withCallingHandlers({
[09:29:20.736]             ...future.value <- base::withVisible(base::local({
[09:29:20.736]                 ...future.makeSendCondition <- base::local({
[09:29:20.736]                   sendCondition <- NULL
[09:29:20.736]                   function(frame = 1L) {
[09:29:20.736]                     if (is.function(sendCondition)) 
[09:29:20.736]                       return(sendCondition)
[09:29:20.736]                     ns <- getNamespace("parallel")
[09:29:20.736]                     if (exists("sendData", mode = "function", 
[09:29:20.736]                       envir = ns)) {
[09:29:20.736]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.736]                         envir = ns)
[09:29:20.736]                       envir <- sys.frame(frame)
[09:29:20.736]                       master <- NULL
[09:29:20.736]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.736]                         !identical(envir, emptyenv())) {
[09:29:20.736]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.736]                           inherits = FALSE)) {
[09:29:20.736]                           master <- get("master", mode = "list", 
[09:29:20.736]                             envir = envir, inherits = FALSE)
[09:29:20.736]                           if (inherits(master, c("SOCKnode", 
[09:29:20.736]                             "SOCK0node"))) {
[09:29:20.736]                             sendCondition <<- function(cond) {
[09:29:20.736]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.736]                                 success = TRUE)
[09:29:20.736]                               parallel_sendData(master, data)
[09:29:20.736]                             }
[09:29:20.736]                             return(sendCondition)
[09:29:20.736]                           }
[09:29:20.736]                         }
[09:29:20.736]                         frame <- frame + 1L
[09:29:20.736]                         envir <- sys.frame(frame)
[09:29:20.736]                       }
[09:29:20.736]                     }
[09:29:20.736]                     sendCondition <<- function(cond) NULL
[09:29:20.736]                   }
[09:29:20.736]                 })
[09:29:20.736]                 withCallingHandlers({
[09:29:20.736]                   {
[09:29:20.736]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.736]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.736]                       ...future.globals.maxSize)) {
[09:29:20.736]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.736]                       on.exit(options(oopts), add = TRUE)
[09:29:20.736]                     }
[09:29:20.736]                     {
[09:29:20.736]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.736]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.736]                         USE.NAMES = FALSE)
[09:29:20.736]                       do.call(mapply, args = args)
[09:29:20.736]                     }
[09:29:20.736]                   }
[09:29:20.736]                 }, immediateCondition = function(cond) {
[09:29:20.736]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.736]                   sendCondition(cond)
[09:29:20.736]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.736]                   {
[09:29:20.736]                     inherits <- base::inherits
[09:29:20.736]                     invokeRestart <- base::invokeRestart
[09:29:20.736]                     is.null <- base::is.null
[09:29:20.736]                     muffled <- FALSE
[09:29:20.736]                     if (inherits(cond, "message")) {
[09:29:20.736]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.736]                       if (muffled) 
[09:29:20.736]                         invokeRestart("muffleMessage")
[09:29:20.736]                     }
[09:29:20.736]                     else if (inherits(cond, "warning")) {
[09:29:20.736]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.736]                       if (muffled) 
[09:29:20.736]                         invokeRestart("muffleWarning")
[09:29:20.736]                     }
[09:29:20.736]                     else if (inherits(cond, "condition")) {
[09:29:20.736]                       if (!is.null(pattern)) {
[09:29:20.736]                         computeRestarts <- base::computeRestarts
[09:29:20.736]                         grepl <- base::grepl
[09:29:20.736]                         restarts <- computeRestarts(cond)
[09:29:20.736]                         for (restart in restarts) {
[09:29:20.736]                           name <- restart$name
[09:29:20.736]                           if (is.null(name)) 
[09:29:20.736]                             next
[09:29:20.736]                           if (!grepl(pattern, name)) 
[09:29:20.736]                             next
[09:29:20.736]                           invokeRestart(restart)
[09:29:20.736]                           muffled <- TRUE
[09:29:20.736]                           break
[09:29:20.736]                         }
[09:29:20.736]                       }
[09:29:20.736]                     }
[09:29:20.736]                     invisible(muffled)
[09:29:20.736]                   }
[09:29:20.736]                   muffleCondition(cond)
[09:29:20.736]                 })
[09:29:20.736]             }))
[09:29:20.736]             future::FutureResult(value = ...future.value$value, 
[09:29:20.736]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.736]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.736]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.736]                     ...future.globalenv.names))
[09:29:20.736]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.736]         }, condition = base::local({
[09:29:20.736]             c <- base::c
[09:29:20.736]             inherits <- base::inherits
[09:29:20.736]             invokeRestart <- base::invokeRestart
[09:29:20.736]             length <- base::length
[09:29:20.736]             list <- base::list
[09:29:20.736]             seq.int <- base::seq.int
[09:29:20.736]             signalCondition <- base::signalCondition
[09:29:20.736]             sys.calls <- base::sys.calls
[09:29:20.736]             `[[` <- base::`[[`
[09:29:20.736]             `+` <- base::`+`
[09:29:20.736]             `<<-` <- base::`<<-`
[09:29:20.736]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.736]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.736]                   3L)]
[09:29:20.736]             }
[09:29:20.736]             function(cond) {
[09:29:20.736]                 is_error <- inherits(cond, "error")
[09:29:20.736]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.736]                   NULL)
[09:29:20.736]                 if (is_error) {
[09:29:20.736]                   sessionInformation <- function() {
[09:29:20.736]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.736]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.736]                       search = base::search(), system = base::Sys.info())
[09:29:20.736]                   }
[09:29:20.736]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.736]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.736]                     cond$call), session = sessionInformation(), 
[09:29:20.736]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.736]                   signalCondition(cond)
[09:29:20.736]                 }
[09:29:20.736]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.736]                 "immediateCondition"))) {
[09:29:20.736]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.736]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.736]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.736]                   if (TRUE && !signal) {
[09:29:20.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.736]                     {
[09:29:20.736]                       inherits <- base::inherits
[09:29:20.736]                       invokeRestart <- base::invokeRestart
[09:29:20.736]                       is.null <- base::is.null
[09:29:20.736]                       muffled <- FALSE
[09:29:20.736]                       if (inherits(cond, "message")) {
[09:29:20.736]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.736]                         if (muffled) 
[09:29:20.736]                           invokeRestart("muffleMessage")
[09:29:20.736]                       }
[09:29:20.736]                       else if (inherits(cond, "warning")) {
[09:29:20.736]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.736]                         if (muffled) 
[09:29:20.736]                           invokeRestart("muffleWarning")
[09:29:20.736]                       }
[09:29:20.736]                       else if (inherits(cond, "condition")) {
[09:29:20.736]                         if (!is.null(pattern)) {
[09:29:20.736]                           computeRestarts <- base::computeRestarts
[09:29:20.736]                           grepl <- base::grepl
[09:29:20.736]                           restarts <- computeRestarts(cond)
[09:29:20.736]                           for (restart in restarts) {
[09:29:20.736]                             name <- restart$name
[09:29:20.736]                             if (is.null(name)) 
[09:29:20.736]                               next
[09:29:20.736]                             if (!grepl(pattern, name)) 
[09:29:20.736]                               next
[09:29:20.736]                             invokeRestart(restart)
[09:29:20.736]                             muffled <- TRUE
[09:29:20.736]                             break
[09:29:20.736]                           }
[09:29:20.736]                         }
[09:29:20.736]                       }
[09:29:20.736]                       invisible(muffled)
[09:29:20.736]                     }
[09:29:20.736]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.736]                   }
[09:29:20.736]                 }
[09:29:20.736]                 else {
[09:29:20.736]                   if (TRUE) {
[09:29:20.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.736]                     {
[09:29:20.736]                       inherits <- base::inherits
[09:29:20.736]                       invokeRestart <- base::invokeRestart
[09:29:20.736]                       is.null <- base::is.null
[09:29:20.736]                       muffled <- FALSE
[09:29:20.736]                       if (inherits(cond, "message")) {
[09:29:20.736]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.736]                         if (muffled) 
[09:29:20.736]                           invokeRestart("muffleMessage")
[09:29:20.736]                       }
[09:29:20.736]                       else if (inherits(cond, "warning")) {
[09:29:20.736]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.736]                         if (muffled) 
[09:29:20.736]                           invokeRestart("muffleWarning")
[09:29:20.736]                       }
[09:29:20.736]                       else if (inherits(cond, "condition")) {
[09:29:20.736]                         if (!is.null(pattern)) {
[09:29:20.736]                           computeRestarts <- base::computeRestarts
[09:29:20.736]                           grepl <- base::grepl
[09:29:20.736]                           restarts <- computeRestarts(cond)
[09:29:20.736]                           for (restart in restarts) {
[09:29:20.736]                             name <- restart$name
[09:29:20.736]                             if (is.null(name)) 
[09:29:20.736]                               next
[09:29:20.736]                             if (!grepl(pattern, name)) 
[09:29:20.736]                               next
[09:29:20.736]                             invokeRestart(restart)
[09:29:20.736]                             muffled <- TRUE
[09:29:20.736]                             break
[09:29:20.736]                           }
[09:29:20.736]                         }
[09:29:20.736]                       }
[09:29:20.736]                       invisible(muffled)
[09:29:20.736]                     }
[09:29:20.736]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.736]                   }
[09:29:20.736]                 }
[09:29:20.736]             }
[09:29:20.736]         }))
[09:29:20.736]     }, error = function(ex) {
[09:29:20.736]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.736]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.736]                 ...future.rng), started = ...future.startTime, 
[09:29:20.736]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.736]             version = "1.8"), class = "FutureResult")
[09:29:20.736]     }, finally = {
[09:29:20.736]         if (!identical(...future.workdir, getwd())) 
[09:29:20.736]             setwd(...future.workdir)
[09:29:20.736]         {
[09:29:20.736]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.736]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.736]             }
[09:29:20.736]             base::options(...future.oldOptions)
[09:29:20.736]             if (.Platform$OS.type == "windows") {
[09:29:20.736]                 old_names <- names(...future.oldEnvVars)
[09:29:20.736]                 envs <- base::Sys.getenv()
[09:29:20.736]                 names <- names(envs)
[09:29:20.736]                 common <- intersect(names, old_names)
[09:29:20.736]                 added <- setdiff(names, old_names)
[09:29:20.736]                 removed <- setdiff(old_names, names)
[09:29:20.736]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.736]                   envs[common]]
[09:29:20.736]                 NAMES <- toupper(changed)
[09:29:20.736]                 args <- list()
[09:29:20.736]                 for (kk in seq_along(NAMES)) {
[09:29:20.736]                   name <- changed[[kk]]
[09:29:20.736]                   NAME <- NAMES[[kk]]
[09:29:20.736]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.736]                     next
[09:29:20.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.736]                 }
[09:29:20.736]                 NAMES <- toupper(added)
[09:29:20.736]                 for (kk in seq_along(NAMES)) {
[09:29:20.736]                   name <- added[[kk]]
[09:29:20.736]                   NAME <- NAMES[[kk]]
[09:29:20.736]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.736]                     next
[09:29:20.736]                   args[[name]] <- ""
[09:29:20.736]                 }
[09:29:20.736]                 NAMES <- toupper(removed)
[09:29:20.736]                 for (kk in seq_along(NAMES)) {
[09:29:20.736]                   name <- removed[[kk]]
[09:29:20.736]                   NAME <- NAMES[[kk]]
[09:29:20.736]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.736]                     next
[09:29:20.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.736]                 }
[09:29:20.736]                 if (length(args) > 0) 
[09:29:20.736]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.736]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.736]             }
[09:29:20.736]             else {
[09:29:20.736]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.736]             }
[09:29:20.736]             {
[09:29:20.736]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.736]                   0L) {
[09:29:20.736]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.736]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.736]                   base::options(opts)
[09:29:20.736]                 }
[09:29:20.736]                 {
[09:29:20.736]                   {
[09:29:20.736]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.736]                     NULL
[09:29:20.736]                   }
[09:29:20.736]                   options(future.plan = NULL)
[09:29:20.736]                   if (is.na(NA_character_)) 
[09:29:20.736]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.736]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.736]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.736]                     .init = FALSE)
[09:29:20.736]                 }
[09:29:20.736]             }
[09:29:20.736]         }
[09:29:20.736]     })
[09:29:20.736]     if (TRUE) {
[09:29:20.736]         base::sink(type = "output", split = FALSE)
[09:29:20.736]         if (TRUE) {
[09:29:20.736]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.736]         }
[09:29:20.736]         else {
[09:29:20.736]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.736]         }
[09:29:20.736]         base::close(...future.stdout)
[09:29:20.736]         ...future.stdout <- NULL
[09:29:20.736]     }
[09:29:20.736]     ...future.result$conditions <- ...future.conditions
[09:29:20.736]     ...future.result$finished <- base::Sys.time()
[09:29:20.736]     ...future.result
[09:29:20.736] }
[09:29:20.738] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[09:29:20.738] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[09:29:20.739] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[09:29:20.739] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:20.739] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.739] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[09:29:20.740] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[09:29:20.740] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:20.740] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.741] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:20.741] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.741] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[09:29:20.741] MultisessionFuture started
[09:29:20.742] - Launch lazy future ... done
[09:29:20.742] run() for ‘MultisessionFuture’ ... done
[09:29:20.742] Created future:
[09:29:20.742] MultisessionFuture:
[09:29:20.742] Label: ‘future_mapply-1’
[09:29:20.742] Expression:
[09:29:20.742] {
[09:29:20.742]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.742]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.742]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.742]         on.exit(options(oopts), add = TRUE)
[09:29:20.742]     }
[09:29:20.742]     {
[09:29:20.742]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.742]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.742]         do.call(mapply, args = args)
[09:29:20.742]     }
[09:29:20.742] }
[09:29:20.742] Lazy evaluation: FALSE
[09:29:20.742] Asynchronous evaluation: TRUE
[09:29:20.742] Local evaluation: TRUE
[09:29:20.742] Environment: R_GlobalEnv
[09:29:20.742] Capture standard output: TRUE
[09:29:20.742] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.742] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.742] Packages: <none>
[09:29:20.742] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:20.742] Resolved: FALSE
[09:29:20.742] Value: <not collected>
[09:29:20.742] Conditions captured: <none>
[09:29:20.742] Early signaling: FALSE
[09:29:20.742] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.742] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.753] Chunk #1 of 2 ... DONE
[09:29:20.753] Chunk #2 of 2 ...
[09:29:20.753]  - Finding globals in '...' for chunk #2 ...
[09:29:20.754] getGlobalsAndPackages() ...
[09:29:20.754] Searching for globals...
[09:29:20.754] 
[09:29:20.754] Searching for globals ... DONE
[09:29:20.754] - globals: [0] <none>
[09:29:20.754] getGlobalsAndPackages() ... DONE
[09:29:20.754]    + additional globals found: [n=0] 
[09:29:20.754]    + additional namespaces needed: [n=0] 
[09:29:20.755]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:20.755]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:20.755]  - seeds: <none>
[09:29:20.755]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.755] getGlobalsAndPackages() ...
[09:29:20.755] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.755] Resolving globals: FALSE
[09:29:20.756] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:20.756] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:20.756] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.756] 
[09:29:20.757] getGlobalsAndPackages() ... DONE
[09:29:20.757] run() for ‘Future’ ...
[09:29:20.757] - state: ‘created’
[09:29:20.757] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.771] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.771] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.771]   - Field: ‘node’
[09:29:20.771]   - Field: ‘label’
[09:29:20.771]   - Field: ‘local’
[09:29:20.771]   - Field: ‘owner’
[09:29:20.771]   - Field: ‘envir’
[09:29:20.771]   - Field: ‘workers’
[09:29:20.771]   - Field: ‘packages’
[09:29:20.772]   - Field: ‘gc’
[09:29:20.772]   - Field: ‘conditions’
[09:29:20.772]   - Field: ‘persistent’
[09:29:20.772]   - Field: ‘expr’
[09:29:20.772]   - Field: ‘uuid’
[09:29:20.772]   - Field: ‘seed’
[09:29:20.772]   - Field: ‘version’
[09:29:20.772]   - Field: ‘result’
[09:29:20.772]   - Field: ‘asynchronous’
[09:29:20.772]   - Field: ‘calls’
[09:29:20.773]   - Field: ‘globals’
[09:29:20.773]   - Field: ‘stdout’
[09:29:20.773]   - Field: ‘earlySignal’
[09:29:20.773]   - Field: ‘lazy’
[09:29:20.773]   - Field: ‘state’
[09:29:20.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.773] - Launch lazy future ...
[09:29:20.773] Packages needed by the future expression (n = 0): <none>
[09:29:20.773] Packages needed by future strategies (n = 0): <none>
[09:29:20.774] {
[09:29:20.774]     {
[09:29:20.774]         {
[09:29:20.774]             ...future.startTime <- base::Sys.time()
[09:29:20.774]             {
[09:29:20.774]                 {
[09:29:20.774]                   {
[09:29:20.774]                     {
[09:29:20.774]                       base::local({
[09:29:20.774]                         has_future <- base::requireNamespace("future", 
[09:29:20.774]                           quietly = TRUE)
[09:29:20.774]                         if (has_future) {
[09:29:20.774]                           ns <- base::getNamespace("future")
[09:29:20.774]                           version <- ns[[".package"]][["version"]]
[09:29:20.774]                           if (is.null(version)) 
[09:29:20.774]                             version <- utils::packageVersion("future")
[09:29:20.774]                         }
[09:29:20.774]                         else {
[09:29:20.774]                           version <- NULL
[09:29:20.774]                         }
[09:29:20.774]                         if (!has_future || version < "1.8.0") {
[09:29:20.774]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.774]                             "", base::R.version$version.string), 
[09:29:20.774]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:20.774]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:20.774]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.774]                               "release", "version")], collapse = " "), 
[09:29:20.774]                             hostname = base::Sys.info()[["nodename"]])
[09:29:20.774]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.774]                             info)
[09:29:20.774]                           info <- base::paste(info, collapse = "; ")
[09:29:20.774]                           if (!has_future) {
[09:29:20.774]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.774]                               info)
[09:29:20.774]                           }
[09:29:20.774]                           else {
[09:29:20.774]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.774]                               info, version)
[09:29:20.774]                           }
[09:29:20.774]                           base::stop(msg)
[09:29:20.774]                         }
[09:29:20.774]                       })
[09:29:20.774]                     }
[09:29:20.774]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.774]                     base::options(mc.cores = 1L)
[09:29:20.774]                   }
[09:29:20.774]                   ...future.strategy.old <- future::plan("list")
[09:29:20.774]                   options(future.plan = NULL)
[09:29:20.774]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.774]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.774]                 }
[09:29:20.774]                 ...future.workdir <- getwd()
[09:29:20.774]             }
[09:29:20.774]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.774]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.774]         }
[09:29:20.774]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.774]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:20.774]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.774]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.774]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.774]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.774]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.774]             base::names(...future.oldOptions))
[09:29:20.774]     }
[09:29:20.774]     if (FALSE) {
[09:29:20.774]     }
[09:29:20.774]     else {
[09:29:20.774]         if (TRUE) {
[09:29:20.774]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.774]                 open = "w")
[09:29:20.774]         }
[09:29:20.774]         else {
[09:29:20.774]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.774]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.774]         }
[09:29:20.774]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.774]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.774]             base::sink(type = "output", split = FALSE)
[09:29:20.774]             base::close(...future.stdout)
[09:29:20.774]         }, add = TRUE)
[09:29:20.774]     }
[09:29:20.774]     ...future.frame <- base::sys.nframe()
[09:29:20.774]     ...future.conditions <- base::list()
[09:29:20.774]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.774]     if (FALSE) {
[09:29:20.774]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.774]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.774]     }
[09:29:20.774]     ...future.result <- base::tryCatch({
[09:29:20.774]         base::withCallingHandlers({
[09:29:20.774]             ...future.value <- base::withVisible(base::local({
[09:29:20.774]                 ...future.makeSendCondition <- base::local({
[09:29:20.774]                   sendCondition <- NULL
[09:29:20.774]                   function(frame = 1L) {
[09:29:20.774]                     if (is.function(sendCondition)) 
[09:29:20.774]                       return(sendCondition)
[09:29:20.774]                     ns <- getNamespace("parallel")
[09:29:20.774]                     if (exists("sendData", mode = "function", 
[09:29:20.774]                       envir = ns)) {
[09:29:20.774]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.774]                         envir = ns)
[09:29:20.774]                       envir <- sys.frame(frame)
[09:29:20.774]                       master <- NULL
[09:29:20.774]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.774]                         !identical(envir, emptyenv())) {
[09:29:20.774]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.774]                           inherits = FALSE)) {
[09:29:20.774]                           master <- get("master", mode = "list", 
[09:29:20.774]                             envir = envir, inherits = FALSE)
[09:29:20.774]                           if (inherits(master, c("SOCKnode", 
[09:29:20.774]                             "SOCK0node"))) {
[09:29:20.774]                             sendCondition <<- function(cond) {
[09:29:20.774]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.774]                                 success = TRUE)
[09:29:20.774]                               parallel_sendData(master, data)
[09:29:20.774]                             }
[09:29:20.774]                             return(sendCondition)
[09:29:20.774]                           }
[09:29:20.774]                         }
[09:29:20.774]                         frame <- frame + 1L
[09:29:20.774]                         envir <- sys.frame(frame)
[09:29:20.774]                       }
[09:29:20.774]                     }
[09:29:20.774]                     sendCondition <<- function(cond) NULL
[09:29:20.774]                   }
[09:29:20.774]                 })
[09:29:20.774]                 withCallingHandlers({
[09:29:20.774]                   {
[09:29:20.774]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.774]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.774]                       ...future.globals.maxSize)) {
[09:29:20.774]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.774]                       on.exit(options(oopts), add = TRUE)
[09:29:20.774]                     }
[09:29:20.774]                     {
[09:29:20.774]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.774]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.774]                         USE.NAMES = FALSE)
[09:29:20.774]                       do.call(mapply, args = args)
[09:29:20.774]                     }
[09:29:20.774]                   }
[09:29:20.774]                 }, immediateCondition = function(cond) {
[09:29:20.774]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.774]                   sendCondition(cond)
[09:29:20.774]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.774]                   {
[09:29:20.774]                     inherits <- base::inherits
[09:29:20.774]                     invokeRestart <- base::invokeRestart
[09:29:20.774]                     is.null <- base::is.null
[09:29:20.774]                     muffled <- FALSE
[09:29:20.774]                     if (inherits(cond, "message")) {
[09:29:20.774]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.774]                       if (muffled) 
[09:29:20.774]                         invokeRestart("muffleMessage")
[09:29:20.774]                     }
[09:29:20.774]                     else if (inherits(cond, "warning")) {
[09:29:20.774]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.774]                       if (muffled) 
[09:29:20.774]                         invokeRestart("muffleWarning")
[09:29:20.774]                     }
[09:29:20.774]                     else if (inherits(cond, "condition")) {
[09:29:20.774]                       if (!is.null(pattern)) {
[09:29:20.774]                         computeRestarts <- base::computeRestarts
[09:29:20.774]                         grepl <- base::grepl
[09:29:20.774]                         restarts <- computeRestarts(cond)
[09:29:20.774]                         for (restart in restarts) {
[09:29:20.774]                           name <- restart$name
[09:29:20.774]                           if (is.null(name)) 
[09:29:20.774]                             next
[09:29:20.774]                           if (!grepl(pattern, name)) 
[09:29:20.774]                             next
[09:29:20.774]                           invokeRestart(restart)
[09:29:20.774]                           muffled <- TRUE
[09:29:20.774]                           break
[09:29:20.774]                         }
[09:29:20.774]                       }
[09:29:20.774]                     }
[09:29:20.774]                     invisible(muffled)
[09:29:20.774]                   }
[09:29:20.774]                   muffleCondition(cond)
[09:29:20.774]                 })
[09:29:20.774]             }))
[09:29:20.774]             future::FutureResult(value = ...future.value$value, 
[09:29:20.774]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.774]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.774]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.774]                     ...future.globalenv.names))
[09:29:20.774]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.774]         }, condition = base::local({
[09:29:20.774]             c <- base::c
[09:29:20.774]             inherits <- base::inherits
[09:29:20.774]             invokeRestart <- base::invokeRestart
[09:29:20.774]             length <- base::length
[09:29:20.774]             list <- base::list
[09:29:20.774]             seq.int <- base::seq.int
[09:29:20.774]             signalCondition <- base::signalCondition
[09:29:20.774]             sys.calls <- base::sys.calls
[09:29:20.774]             `[[` <- base::`[[`
[09:29:20.774]             `+` <- base::`+`
[09:29:20.774]             `<<-` <- base::`<<-`
[09:29:20.774]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.774]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.774]                   3L)]
[09:29:20.774]             }
[09:29:20.774]             function(cond) {
[09:29:20.774]                 is_error <- inherits(cond, "error")
[09:29:20.774]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.774]                   NULL)
[09:29:20.774]                 if (is_error) {
[09:29:20.774]                   sessionInformation <- function() {
[09:29:20.774]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.774]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.774]                       search = base::search(), system = base::Sys.info())
[09:29:20.774]                   }
[09:29:20.774]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.774]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.774]                     cond$call), session = sessionInformation(), 
[09:29:20.774]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.774]                   signalCondition(cond)
[09:29:20.774]                 }
[09:29:20.774]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.774]                 "immediateCondition"))) {
[09:29:20.774]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.774]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.774]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.774]                   if (TRUE && !signal) {
[09:29:20.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.774]                     {
[09:29:20.774]                       inherits <- base::inherits
[09:29:20.774]                       invokeRestart <- base::invokeRestart
[09:29:20.774]                       is.null <- base::is.null
[09:29:20.774]                       muffled <- FALSE
[09:29:20.774]                       if (inherits(cond, "message")) {
[09:29:20.774]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.774]                         if (muffled) 
[09:29:20.774]                           invokeRestart("muffleMessage")
[09:29:20.774]                       }
[09:29:20.774]                       else if (inherits(cond, "warning")) {
[09:29:20.774]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.774]                         if (muffled) 
[09:29:20.774]                           invokeRestart("muffleWarning")
[09:29:20.774]                       }
[09:29:20.774]                       else if (inherits(cond, "condition")) {
[09:29:20.774]                         if (!is.null(pattern)) {
[09:29:20.774]                           computeRestarts <- base::computeRestarts
[09:29:20.774]                           grepl <- base::grepl
[09:29:20.774]                           restarts <- computeRestarts(cond)
[09:29:20.774]                           for (restart in restarts) {
[09:29:20.774]                             name <- restart$name
[09:29:20.774]                             if (is.null(name)) 
[09:29:20.774]                               next
[09:29:20.774]                             if (!grepl(pattern, name)) 
[09:29:20.774]                               next
[09:29:20.774]                             invokeRestart(restart)
[09:29:20.774]                             muffled <- TRUE
[09:29:20.774]                             break
[09:29:20.774]                           }
[09:29:20.774]                         }
[09:29:20.774]                       }
[09:29:20.774]                       invisible(muffled)
[09:29:20.774]                     }
[09:29:20.774]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.774]                   }
[09:29:20.774]                 }
[09:29:20.774]                 else {
[09:29:20.774]                   if (TRUE) {
[09:29:20.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.774]                     {
[09:29:20.774]                       inherits <- base::inherits
[09:29:20.774]                       invokeRestart <- base::invokeRestart
[09:29:20.774]                       is.null <- base::is.null
[09:29:20.774]                       muffled <- FALSE
[09:29:20.774]                       if (inherits(cond, "message")) {
[09:29:20.774]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.774]                         if (muffled) 
[09:29:20.774]                           invokeRestart("muffleMessage")
[09:29:20.774]                       }
[09:29:20.774]                       else if (inherits(cond, "warning")) {
[09:29:20.774]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.774]                         if (muffled) 
[09:29:20.774]                           invokeRestart("muffleWarning")
[09:29:20.774]                       }
[09:29:20.774]                       else if (inherits(cond, "condition")) {
[09:29:20.774]                         if (!is.null(pattern)) {
[09:29:20.774]                           computeRestarts <- base::computeRestarts
[09:29:20.774]                           grepl <- base::grepl
[09:29:20.774]                           restarts <- computeRestarts(cond)
[09:29:20.774]                           for (restart in restarts) {
[09:29:20.774]                             name <- restart$name
[09:29:20.774]                             if (is.null(name)) 
[09:29:20.774]                               next
[09:29:20.774]                             if (!grepl(pattern, name)) 
[09:29:20.774]                               next
[09:29:20.774]                             invokeRestart(restart)
[09:29:20.774]                             muffled <- TRUE
[09:29:20.774]                             break
[09:29:20.774]                           }
[09:29:20.774]                         }
[09:29:20.774]                       }
[09:29:20.774]                       invisible(muffled)
[09:29:20.774]                     }
[09:29:20.774]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.774]                   }
[09:29:20.774]                 }
[09:29:20.774]             }
[09:29:20.774]         }))
[09:29:20.774]     }, error = function(ex) {
[09:29:20.774]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.774]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.774]                 ...future.rng), started = ...future.startTime, 
[09:29:20.774]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.774]             version = "1.8"), class = "FutureResult")
[09:29:20.774]     }, finally = {
[09:29:20.774]         if (!identical(...future.workdir, getwd())) 
[09:29:20.774]             setwd(...future.workdir)
[09:29:20.774]         {
[09:29:20.774]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.774]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.774]             }
[09:29:20.774]             base::options(...future.oldOptions)
[09:29:20.774]             if (.Platform$OS.type == "windows") {
[09:29:20.774]                 old_names <- names(...future.oldEnvVars)
[09:29:20.774]                 envs <- base::Sys.getenv()
[09:29:20.774]                 names <- names(envs)
[09:29:20.774]                 common <- intersect(names, old_names)
[09:29:20.774]                 added <- setdiff(names, old_names)
[09:29:20.774]                 removed <- setdiff(old_names, names)
[09:29:20.774]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.774]                   envs[common]]
[09:29:20.774]                 NAMES <- toupper(changed)
[09:29:20.774]                 args <- list()
[09:29:20.774]                 for (kk in seq_along(NAMES)) {
[09:29:20.774]                   name <- changed[[kk]]
[09:29:20.774]                   NAME <- NAMES[[kk]]
[09:29:20.774]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.774]                     next
[09:29:20.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.774]                 }
[09:29:20.774]                 NAMES <- toupper(added)
[09:29:20.774]                 for (kk in seq_along(NAMES)) {
[09:29:20.774]                   name <- added[[kk]]
[09:29:20.774]                   NAME <- NAMES[[kk]]
[09:29:20.774]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.774]                     next
[09:29:20.774]                   args[[name]] <- ""
[09:29:20.774]                 }
[09:29:20.774]                 NAMES <- toupper(removed)
[09:29:20.774]                 for (kk in seq_along(NAMES)) {
[09:29:20.774]                   name <- removed[[kk]]
[09:29:20.774]                   NAME <- NAMES[[kk]]
[09:29:20.774]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.774]                     next
[09:29:20.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.774]                 }
[09:29:20.774]                 if (length(args) > 0) 
[09:29:20.774]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.774]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.774]             }
[09:29:20.774]             else {
[09:29:20.774]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.774]             }
[09:29:20.774]             {
[09:29:20.774]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.774]                   0L) {
[09:29:20.774]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.774]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.774]                   base::options(opts)
[09:29:20.774]                 }
[09:29:20.774]                 {
[09:29:20.774]                   {
[09:29:20.774]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.774]                     NULL
[09:29:20.774]                   }
[09:29:20.774]                   options(future.plan = NULL)
[09:29:20.774]                   if (is.na(NA_character_)) 
[09:29:20.774]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.774]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.774]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.774]                     .init = FALSE)
[09:29:20.774]                 }
[09:29:20.774]             }
[09:29:20.774]         }
[09:29:20.774]     })
[09:29:20.774]     if (TRUE) {
[09:29:20.774]         base::sink(type = "output", split = FALSE)
[09:29:20.774]         if (TRUE) {
[09:29:20.774]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.774]         }
[09:29:20.774]         else {
[09:29:20.774]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.774]         }
[09:29:20.774]         base::close(...future.stdout)
[09:29:20.774]         ...future.stdout <- NULL
[09:29:20.774]     }
[09:29:20.774]     ...future.result$conditions <- ...future.conditions
[09:29:20.774]     ...future.result$finished <- base::Sys.time()
[09:29:20.774]     ...future.result
[09:29:20.774] }
[09:29:20.776] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[09:29:20.777] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[09:29:20.777] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[09:29:20.777] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:20.777] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:20.778] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[09:29:20.778] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[09:29:20.778] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:20.779] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:20.779] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:20.779] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:20.779] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[09:29:20.780] MultisessionFuture started
[09:29:20.780] - Launch lazy future ... done
[09:29:20.780] run() for ‘MultisessionFuture’ ... done
[09:29:20.780] Created future:
[09:29:20.780] MultisessionFuture:
[09:29:20.780] Label: ‘future_mapply-2’
[09:29:20.780] Expression:
[09:29:20.780] {
[09:29:20.780]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.780]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.780]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.780]         on.exit(options(oopts), add = TRUE)
[09:29:20.780]     }
[09:29:20.780]     {
[09:29:20.780]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.780]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.780]         do.call(mapply, args = args)
[09:29:20.780]     }
[09:29:20.780] }
[09:29:20.780] Lazy evaluation: FALSE
[09:29:20.780] Asynchronous evaluation: TRUE
[09:29:20.780] Local evaluation: TRUE
[09:29:20.780] Environment: R_GlobalEnv
[09:29:20.780] Capture standard output: TRUE
[09:29:20.780] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.780] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.780] Packages: <none>
[09:29:20.780] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:20.780] Resolved: FALSE
[09:29:20.780] Value: <not collected>
[09:29:20.780] Conditions captured: <none>
[09:29:20.780] Early signaling: FALSE
[09:29:20.780] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.780] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.792] Chunk #2 of 2 ... DONE
[09:29:20.792] Launching 2 futures (chunks) ... DONE
[09:29:20.792] Resolving 2 futures (chunks) ...
[09:29:20.792] resolve() on list ...
[09:29:20.792]  recursive: 0
[09:29:20.792]  length: 2
[09:29:20.792] 
[09:29:20.793] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.793] - Validating connection of MultisessionFuture
[09:29:20.793] - received message: FutureResult
[09:29:20.793] - Received FutureResult
[09:29:20.793] - Erased future from FutureRegistry
[09:29:20.793] result() for ClusterFuture ...
[09:29:20.793] - result already collected: FutureResult
[09:29:20.793] result() for ClusterFuture ... done
[09:29:20.794] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.794] Future #1
[09:29:20.794] result() for ClusterFuture ...
[09:29:20.794] - result already collected: FutureResult
[09:29:20.794] result() for ClusterFuture ... done
[09:29:20.794] result() for ClusterFuture ...
[09:29:20.794] - result already collected: FutureResult
[09:29:20.794] result() for ClusterFuture ... done
[09:29:20.794] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:20.794] - nx: 2
[09:29:20.794] - relay: TRUE
[09:29:20.795] - stdout: TRUE
[09:29:20.795] - signal: TRUE
[09:29:20.795] - resignal: FALSE
[09:29:20.795] - force: TRUE
[09:29:20.795] - relayed: [n=2] FALSE, FALSE
[09:29:20.795] - queued futures: [n=2] FALSE, FALSE
[09:29:20.795]  - until=1
[09:29:20.795]  - relaying element #1
[09:29:20.795] result() for ClusterFuture ...
[09:29:20.795] - result already collected: FutureResult
[09:29:20.795] result() for ClusterFuture ... done
[09:29:20.795] result() for ClusterFuture ...
[09:29:20.796] - result already collected: FutureResult
[09:29:20.796] result() for ClusterFuture ... done
[09:29:20.796] result() for ClusterFuture ...
[09:29:20.796] - result already collected: FutureResult
[09:29:20.796] result() for ClusterFuture ... done
[09:29:20.796] result() for ClusterFuture ...
[09:29:20.796] - result already collected: FutureResult
[09:29:20.796] result() for ClusterFuture ... done
[09:29:20.796] - relayed: [n=2] TRUE, FALSE
[09:29:20.796] - queued futures: [n=2] TRUE, FALSE
[09:29:20.796] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:20.797]  length: 1 (resolved future 1)
[09:29:20.821] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.821] - Validating connection of MultisessionFuture
[09:29:20.822] - received message: FutureResult
[09:29:20.822] - Received FutureResult
[09:29:20.822] - Erased future from FutureRegistry
[09:29:20.822] result() for ClusterFuture ...
[09:29:20.822] - result already collected: FutureResult
[09:29:20.822] result() for ClusterFuture ... done
[09:29:20.822] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.822] Future #2
[09:29:20.822] result() for ClusterFuture ...
[09:29:20.822] - result already collected: FutureResult
[09:29:20.822] result() for ClusterFuture ... done
[09:29:20.823] result() for ClusterFuture ...
[09:29:20.823] - result already collected: FutureResult
[09:29:20.823] result() for ClusterFuture ... done
[09:29:20.823] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:20.823] - nx: 2
[09:29:20.823] - relay: TRUE
[09:29:20.823] - stdout: TRUE
[09:29:20.823] - signal: TRUE
[09:29:20.823] - resignal: FALSE
[09:29:20.823] - force: TRUE
[09:29:20.823] - relayed: [n=2] TRUE, FALSE
[09:29:20.824] - queued futures: [n=2] TRUE, FALSE
[09:29:20.824]  - until=2
[09:29:20.824]  - relaying element #2
[09:29:20.824] result() for ClusterFuture ...
[09:29:20.824] - result already collected: FutureResult
[09:29:20.824] result() for ClusterFuture ... done
[09:29:20.824] result() for ClusterFuture ...
[09:29:20.824] - result already collected: FutureResult
[09:29:20.824] result() for ClusterFuture ... done
[09:29:20.824] result() for ClusterFuture ...
[09:29:20.825] - result already collected: FutureResult
[09:29:20.825] result() for ClusterFuture ... done
[09:29:20.825] result() for ClusterFuture ...
[09:29:20.825] - result already collected: FutureResult
[09:29:20.825] result() for ClusterFuture ... done
[09:29:20.825] - relayed: [n=2] TRUE, TRUE
[09:29:20.825] - queued futures: [n=2] TRUE, TRUE
[09:29:20.825] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:20.825]  length: 0 (resolved future 2)
[09:29:20.825] Relaying remaining futures
[09:29:20.825] signalConditionsASAP(NULL, pos=0) ...
[09:29:20.825] - nx: 2
[09:29:20.826] - relay: TRUE
[09:29:20.826] - stdout: TRUE
[09:29:20.826] - signal: TRUE
[09:29:20.826] - resignal: FALSE
[09:29:20.826] - force: TRUE
[09:29:20.826] - relayed: [n=2] TRUE, TRUE
[09:29:20.826] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:20.826] - relayed: [n=2] TRUE, TRUE
[09:29:20.826] - queued futures: [n=2] TRUE, TRUE
[09:29:20.826] signalConditionsASAP(NULL, pos=0) ... done
[09:29:20.826] resolve() on list ... DONE
[09:29:20.826] result() for ClusterFuture ...
[09:29:20.827] - result already collected: FutureResult
[09:29:20.827] result() for ClusterFuture ... done
[09:29:20.827] result() for ClusterFuture ...
[09:29:20.827] - result already collected: FutureResult
[09:29:20.827] result() for ClusterFuture ... done
[09:29:20.827] result() for ClusterFuture ...
[09:29:20.827] - result already collected: FutureResult
[09:29:20.827] result() for ClusterFuture ... done
[09:29:20.827] result() for ClusterFuture ...
[09:29:20.827] - result already collected: FutureResult
[09:29:20.827] result() for ClusterFuture ... done
[09:29:20.828]  - Number of value chunks collected: 2
[09:29:20.828] Resolving 2 futures (chunks) ... DONE
[09:29:20.828] Reducing values from 2 chunks ...
[09:29:20.828]  - Number of values collected after concatenation: 4
[09:29:20.828]  - Number of values expected: 4
[09:29:20.828] Reducing values from 2 chunks ... DONE
[09:29:20.828] future_mapply() ... DONE
- Parallel RNG ...
[09:29:20.828] future_mapply() ...
[09:29:20.828] Generating random seeds ...
[09:29:20.829] Generating random seed streams for 4 elements ...
[09:29:20.829] Generating random seed streams for 4 elements ... DONE
[09:29:20.829] Generating random seeds ... DONE
[09:29:20.829] Will set RNG state on exit: 10407, -1026619238, 1377097565, -275930001, 1540976279, -1105244322, 1015081551
[09:29:20.832] Number of chunks: 2
[09:29:20.832] getGlobalsAndPackagesXApply() ...
[09:29:20.833]  - future.globals: TRUE
[09:29:20.833] getGlobalsAndPackages() ...
[09:29:20.833] Searching for globals...
[09:29:20.834] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[09:29:20.834] Searching for globals ... DONE
[09:29:20.834] Resolving globals: FALSE
[09:29:20.835] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[09:29:20.835] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[09:29:20.835] - globals: [1] ‘FUN’
[09:29:20.835] - packages: [1] ‘stats’
[09:29:20.835] getGlobalsAndPackages() ... DONE
[09:29:20.835]  - globals found/used: [n=1] ‘FUN’
[09:29:20.835]  - needed namespaces: [n=1] ‘stats’
[09:29:20.836] Finding globals ... DONE
[09:29:20.836] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:20.836] List of 2
[09:29:20.836]  $ ...future.FUN:function (n, min = 0, max = 1)  
[09:29:20.836]  $ MoreArgs     :List of 1
[09:29:20.836]   ..$ min: num 1
[09:29:20.836]  - attr(*, "where")=List of 2
[09:29:20.836]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:20.836]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:20.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:20.836]  - attr(*, "resolved")= logi FALSE
[09:29:20.836]  - attr(*, "total_size")= num NA
[09:29:20.839] Packages to be attached in all futures: [n=1] ‘stats’
[09:29:20.839] getGlobalsAndPackagesXApply() ... DONE
[09:29:20.839] Number of futures (= number of chunks): 2
[09:29:20.839] Launching 2 futures (chunks) ...
[09:29:20.839] Chunk #1 of 2 ...
[09:29:20.839]  - Finding globals in '...' for chunk #1 ...
[09:29:20.839] getGlobalsAndPackages() ...
[09:29:20.839] Searching for globals...
[09:29:20.840] 
[09:29:20.840] Searching for globals ... DONE
[09:29:20.840] - globals: [0] <none>
[09:29:20.840] getGlobalsAndPackages() ... DONE
[09:29:20.840]    + additional globals found: [n=0] 
[09:29:20.840]    + additional namespaces needed: [n=0] 
[09:29:20.840]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:20.840]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:20.840]  - seeds: [2] <seeds>
[09:29:20.841]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.841] getGlobalsAndPackages() ...
[09:29:20.841] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.841] Resolving globals: FALSE
[09:29:20.841] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[09:29:20.842] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[09:29:20.842] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.842] - packages: [1] ‘stats’
[09:29:20.842] getGlobalsAndPackages() ... DONE
[09:29:20.842] run() for ‘Future’ ...
[09:29:20.842] - state: ‘created’
[09:29:20.843] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.856] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.856] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.856]   - Field: ‘node’
[09:29:20.857]   - Field: ‘label’
[09:29:20.857]   - Field: ‘local’
[09:29:20.857]   - Field: ‘owner’
[09:29:20.857]   - Field: ‘envir’
[09:29:20.857]   - Field: ‘workers’
[09:29:20.857]   - Field: ‘packages’
[09:29:20.857]   - Field: ‘gc’
[09:29:20.857]   - Field: ‘conditions’
[09:29:20.857]   - Field: ‘persistent’
[09:29:20.857]   - Field: ‘expr’
[09:29:20.857]   - Field: ‘uuid’
[09:29:20.857]   - Field: ‘seed’
[09:29:20.858]   - Field: ‘version’
[09:29:20.858]   - Field: ‘result’
[09:29:20.858]   - Field: ‘asynchronous’
[09:29:20.858]   - Field: ‘calls’
[09:29:20.858]   - Field: ‘globals’
[09:29:20.858]   - Field: ‘stdout’
[09:29:20.858]   - Field: ‘earlySignal’
[09:29:20.858]   - Field: ‘lazy’
[09:29:20.858]   - Field: ‘state’
[09:29:20.858] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.858] - Launch lazy future ...
[09:29:20.859] Packages needed by the future expression (n = 1): ‘stats’
[09:29:20.859] Packages needed by future strategies (n = 0): <none>
[09:29:20.859] {
[09:29:20.859]     {
[09:29:20.859]         {
[09:29:20.859]             ...future.startTime <- base::Sys.time()
[09:29:20.859]             {
[09:29:20.859]                 {
[09:29:20.859]                   {
[09:29:20.859]                     {
[09:29:20.859]                       {
[09:29:20.859]                         base::local({
[09:29:20.859]                           has_future <- base::requireNamespace("future", 
[09:29:20.859]                             quietly = TRUE)
[09:29:20.859]                           if (has_future) {
[09:29:20.859]                             ns <- base::getNamespace("future")
[09:29:20.859]                             version <- ns[[".package"]][["version"]]
[09:29:20.859]                             if (is.null(version)) 
[09:29:20.859]                               version <- utils::packageVersion("future")
[09:29:20.859]                           }
[09:29:20.859]                           else {
[09:29:20.859]                             version <- NULL
[09:29:20.859]                           }
[09:29:20.859]                           if (!has_future || version < "1.8.0") {
[09:29:20.859]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.859]                               "", base::R.version$version.string), 
[09:29:20.859]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:20.859]                                 base::R.version$platform, 8 * 
[09:29:20.859]                                   base::.Machine$sizeof.pointer), 
[09:29:20.859]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.859]                                 "release", "version")], collapse = " "), 
[09:29:20.859]                               hostname = base::Sys.info()[["nodename"]])
[09:29:20.859]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.859]                               info)
[09:29:20.859]                             info <- base::paste(info, collapse = "; ")
[09:29:20.859]                             if (!has_future) {
[09:29:20.859]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.859]                                 info)
[09:29:20.859]                             }
[09:29:20.859]                             else {
[09:29:20.859]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.859]                                 info, version)
[09:29:20.859]                             }
[09:29:20.859]                             base::stop(msg)
[09:29:20.859]                           }
[09:29:20.859]                         })
[09:29:20.859]                       }
[09:29:20.859]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.859]                       base::options(mc.cores = 1L)
[09:29:20.859]                     }
[09:29:20.859]                     base::local({
[09:29:20.859]                       for (pkg in "stats") {
[09:29:20.859]                         base::loadNamespace(pkg)
[09:29:20.859]                         base::library(pkg, character.only = TRUE)
[09:29:20.859]                       }
[09:29:20.859]                     })
[09:29:20.859]                   }
[09:29:20.859]                   ...future.strategy.old <- future::plan("list")
[09:29:20.859]                   options(future.plan = NULL)
[09:29:20.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.859]                 }
[09:29:20.859]                 ...future.workdir <- getwd()
[09:29:20.859]             }
[09:29:20.859]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.859]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.859]         }
[09:29:20.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.859]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:20.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.859]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.859]             base::names(...future.oldOptions))
[09:29:20.859]     }
[09:29:20.859]     if (FALSE) {
[09:29:20.859]     }
[09:29:20.859]     else {
[09:29:20.859]         if (TRUE) {
[09:29:20.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.859]                 open = "w")
[09:29:20.859]         }
[09:29:20.859]         else {
[09:29:20.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.859]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.859]         }
[09:29:20.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.859]             base::sink(type = "output", split = FALSE)
[09:29:20.859]             base::close(...future.stdout)
[09:29:20.859]         }, add = TRUE)
[09:29:20.859]     }
[09:29:20.859]     ...future.frame <- base::sys.nframe()
[09:29:20.859]     ...future.conditions <- base::list()
[09:29:20.859]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.859]     if (FALSE) {
[09:29:20.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.859]     }
[09:29:20.859]     ...future.result <- base::tryCatch({
[09:29:20.859]         base::withCallingHandlers({
[09:29:20.859]             ...future.value <- base::withVisible(base::local({
[09:29:20.859]                 ...future.makeSendCondition <- base::local({
[09:29:20.859]                   sendCondition <- NULL
[09:29:20.859]                   function(frame = 1L) {
[09:29:20.859]                     if (is.function(sendCondition)) 
[09:29:20.859]                       return(sendCondition)
[09:29:20.859]                     ns <- getNamespace("parallel")
[09:29:20.859]                     if (exists("sendData", mode = "function", 
[09:29:20.859]                       envir = ns)) {
[09:29:20.859]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.859]                         envir = ns)
[09:29:20.859]                       envir <- sys.frame(frame)
[09:29:20.859]                       master <- NULL
[09:29:20.859]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.859]                         !identical(envir, emptyenv())) {
[09:29:20.859]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.859]                           inherits = FALSE)) {
[09:29:20.859]                           master <- get("master", mode = "list", 
[09:29:20.859]                             envir = envir, inherits = FALSE)
[09:29:20.859]                           if (inherits(master, c("SOCKnode", 
[09:29:20.859]                             "SOCK0node"))) {
[09:29:20.859]                             sendCondition <<- function(cond) {
[09:29:20.859]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.859]                                 success = TRUE)
[09:29:20.859]                               parallel_sendData(master, data)
[09:29:20.859]                             }
[09:29:20.859]                             return(sendCondition)
[09:29:20.859]                           }
[09:29:20.859]                         }
[09:29:20.859]                         frame <- frame + 1L
[09:29:20.859]                         envir <- sys.frame(frame)
[09:29:20.859]                       }
[09:29:20.859]                     }
[09:29:20.859]                     sendCondition <<- function(cond) NULL
[09:29:20.859]                   }
[09:29:20.859]                 })
[09:29:20.859]                 withCallingHandlers({
[09:29:20.859]                   {
[09:29:20.859]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.859]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.859]                       ...future.globals.maxSize)) {
[09:29:20.859]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.859]                       on.exit(options(oopts), add = TRUE)
[09:29:20.859]                     }
[09:29:20.859]                     {
[09:29:20.859]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:20.859]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[09:29:20.859]                           envir = globalenv(), inherits = FALSE)
[09:29:20.859]                         ...future.FUN(...)
[09:29:20.859]                       }
[09:29:20.859]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:20.859]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:20.859]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.859]                         USE.NAMES = FALSE)
[09:29:20.859]                       do.call(mapply, args = args)
[09:29:20.859]                     }
[09:29:20.859]                   }
[09:29:20.859]                 }, immediateCondition = function(cond) {
[09:29:20.859]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.859]                   sendCondition(cond)
[09:29:20.859]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.859]                   {
[09:29:20.859]                     inherits <- base::inherits
[09:29:20.859]                     invokeRestart <- base::invokeRestart
[09:29:20.859]                     is.null <- base::is.null
[09:29:20.859]                     muffled <- FALSE
[09:29:20.859]                     if (inherits(cond, "message")) {
[09:29:20.859]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.859]                       if (muffled) 
[09:29:20.859]                         invokeRestart("muffleMessage")
[09:29:20.859]                     }
[09:29:20.859]                     else if (inherits(cond, "warning")) {
[09:29:20.859]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.859]                       if (muffled) 
[09:29:20.859]                         invokeRestart("muffleWarning")
[09:29:20.859]                     }
[09:29:20.859]                     else if (inherits(cond, "condition")) {
[09:29:20.859]                       if (!is.null(pattern)) {
[09:29:20.859]                         computeRestarts <- base::computeRestarts
[09:29:20.859]                         grepl <- base::grepl
[09:29:20.859]                         restarts <- computeRestarts(cond)
[09:29:20.859]                         for (restart in restarts) {
[09:29:20.859]                           name <- restart$name
[09:29:20.859]                           if (is.null(name)) 
[09:29:20.859]                             next
[09:29:20.859]                           if (!grepl(pattern, name)) 
[09:29:20.859]                             next
[09:29:20.859]                           invokeRestart(restart)
[09:29:20.859]                           muffled <- TRUE
[09:29:20.859]                           break
[09:29:20.859]                         }
[09:29:20.859]                       }
[09:29:20.859]                     }
[09:29:20.859]                     invisible(muffled)
[09:29:20.859]                   }
[09:29:20.859]                   muffleCondition(cond)
[09:29:20.859]                 })
[09:29:20.859]             }))
[09:29:20.859]             future::FutureResult(value = ...future.value$value, 
[09:29:20.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.859]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.859]                     ...future.globalenv.names))
[09:29:20.859]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.859]         }, condition = base::local({
[09:29:20.859]             c <- base::c
[09:29:20.859]             inherits <- base::inherits
[09:29:20.859]             invokeRestart <- base::invokeRestart
[09:29:20.859]             length <- base::length
[09:29:20.859]             list <- base::list
[09:29:20.859]             seq.int <- base::seq.int
[09:29:20.859]             signalCondition <- base::signalCondition
[09:29:20.859]             sys.calls <- base::sys.calls
[09:29:20.859]             `[[` <- base::`[[`
[09:29:20.859]             `+` <- base::`+`
[09:29:20.859]             `<<-` <- base::`<<-`
[09:29:20.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.859]                   3L)]
[09:29:20.859]             }
[09:29:20.859]             function(cond) {
[09:29:20.859]                 is_error <- inherits(cond, "error")
[09:29:20.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.859]                   NULL)
[09:29:20.859]                 if (is_error) {
[09:29:20.859]                   sessionInformation <- function() {
[09:29:20.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.859]                       search = base::search(), system = base::Sys.info())
[09:29:20.859]                   }
[09:29:20.859]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.859]                     cond$call), session = sessionInformation(), 
[09:29:20.859]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.859]                   signalCondition(cond)
[09:29:20.859]                 }
[09:29:20.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.859]                 "immediateCondition"))) {
[09:29:20.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.859]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.859]                   if (TRUE && !signal) {
[09:29:20.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.859]                     {
[09:29:20.859]                       inherits <- base::inherits
[09:29:20.859]                       invokeRestart <- base::invokeRestart
[09:29:20.859]                       is.null <- base::is.null
[09:29:20.859]                       muffled <- FALSE
[09:29:20.859]                       if (inherits(cond, "message")) {
[09:29:20.859]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.859]                         if (muffled) 
[09:29:20.859]                           invokeRestart("muffleMessage")
[09:29:20.859]                       }
[09:29:20.859]                       else if (inherits(cond, "warning")) {
[09:29:20.859]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.859]                         if (muffled) 
[09:29:20.859]                           invokeRestart("muffleWarning")
[09:29:20.859]                       }
[09:29:20.859]                       else if (inherits(cond, "condition")) {
[09:29:20.859]                         if (!is.null(pattern)) {
[09:29:20.859]                           computeRestarts <- base::computeRestarts
[09:29:20.859]                           grepl <- base::grepl
[09:29:20.859]                           restarts <- computeRestarts(cond)
[09:29:20.859]                           for (restart in restarts) {
[09:29:20.859]                             name <- restart$name
[09:29:20.859]                             if (is.null(name)) 
[09:29:20.859]                               next
[09:29:20.859]                             if (!grepl(pattern, name)) 
[09:29:20.859]                               next
[09:29:20.859]                             invokeRestart(restart)
[09:29:20.859]                             muffled <- TRUE
[09:29:20.859]                             break
[09:29:20.859]                           }
[09:29:20.859]                         }
[09:29:20.859]                       }
[09:29:20.859]                       invisible(muffled)
[09:29:20.859]                     }
[09:29:20.859]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.859]                   }
[09:29:20.859]                 }
[09:29:20.859]                 else {
[09:29:20.859]                   if (TRUE) {
[09:29:20.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.859]                     {
[09:29:20.859]                       inherits <- base::inherits
[09:29:20.859]                       invokeRestart <- base::invokeRestart
[09:29:20.859]                       is.null <- base::is.null
[09:29:20.859]                       muffled <- FALSE
[09:29:20.859]                       if (inherits(cond, "message")) {
[09:29:20.859]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.859]                         if (muffled) 
[09:29:20.859]                           invokeRestart("muffleMessage")
[09:29:20.859]                       }
[09:29:20.859]                       else if (inherits(cond, "warning")) {
[09:29:20.859]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.859]                         if (muffled) 
[09:29:20.859]                           invokeRestart("muffleWarning")
[09:29:20.859]                       }
[09:29:20.859]                       else if (inherits(cond, "condition")) {
[09:29:20.859]                         if (!is.null(pattern)) {
[09:29:20.859]                           computeRestarts <- base::computeRestarts
[09:29:20.859]                           grepl <- base::grepl
[09:29:20.859]                           restarts <- computeRestarts(cond)
[09:29:20.859]                           for (restart in restarts) {
[09:29:20.859]                             name <- restart$name
[09:29:20.859]                             if (is.null(name)) 
[09:29:20.859]                               next
[09:29:20.859]                             if (!grepl(pattern, name)) 
[09:29:20.859]                               next
[09:29:20.859]                             invokeRestart(restart)
[09:29:20.859]                             muffled <- TRUE
[09:29:20.859]                             break
[09:29:20.859]                           }
[09:29:20.859]                         }
[09:29:20.859]                       }
[09:29:20.859]                       invisible(muffled)
[09:29:20.859]                     }
[09:29:20.859]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.859]                   }
[09:29:20.859]                 }
[09:29:20.859]             }
[09:29:20.859]         }))
[09:29:20.859]     }, error = function(ex) {
[09:29:20.859]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.859]                 ...future.rng), started = ...future.startTime, 
[09:29:20.859]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.859]             version = "1.8"), class = "FutureResult")
[09:29:20.859]     }, finally = {
[09:29:20.859]         if (!identical(...future.workdir, getwd())) 
[09:29:20.859]             setwd(...future.workdir)
[09:29:20.859]         {
[09:29:20.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.859]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.859]             }
[09:29:20.859]             base::options(...future.oldOptions)
[09:29:20.859]             if (.Platform$OS.type == "windows") {
[09:29:20.859]                 old_names <- names(...future.oldEnvVars)
[09:29:20.859]                 envs <- base::Sys.getenv()
[09:29:20.859]                 names <- names(envs)
[09:29:20.859]                 common <- intersect(names, old_names)
[09:29:20.859]                 added <- setdiff(names, old_names)
[09:29:20.859]                 removed <- setdiff(old_names, names)
[09:29:20.859]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.859]                   envs[common]]
[09:29:20.859]                 NAMES <- toupper(changed)
[09:29:20.859]                 args <- list()
[09:29:20.859]                 for (kk in seq_along(NAMES)) {
[09:29:20.859]                   name <- changed[[kk]]
[09:29:20.859]                   NAME <- NAMES[[kk]]
[09:29:20.859]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.859]                     next
[09:29:20.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.859]                 }
[09:29:20.859]                 NAMES <- toupper(added)
[09:29:20.859]                 for (kk in seq_along(NAMES)) {
[09:29:20.859]                   name <- added[[kk]]
[09:29:20.859]                   NAME <- NAMES[[kk]]
[09:29:20.859]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.859]                     next
[09:29:20.859]                   args[[name]] <- ""
[09:29:20.859]                 }
[09:29:20.859]                 NAMES <- toupper(removed)
[09:29:20.859]                 for (kk in seq_along(NAMES)) {
[09:29:20.859]                   name <- removed[[kk]]
[09:29:20.859]                   NAME <- NAMES[[kk]]
[09:29:20.859]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.859]                     next
[09:29:20.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.859]                 }
[09:29:20.859]                 if (length(args) > 0) 
[09:29:20.859]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.859]             }
[09:29:20.859]             else {
[09:29:20.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.859]             }
[09:29:20.859]             {
[09:29:20.859]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.859]                   0L) {
[09:29:20.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.859]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.859]                   base::options(opts)
[09:29:20.859]                 }
[09:29:20.859]                 {
[09:29:20.859]                   {
[09:29:20.859]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.859]                     NULL
[09:29:20.859]                   }
[09:29:20.859]                   options(future.plan = NULL)
[09:29:20.859]                   if (is.na(NA_character_)) 
[09:29:20.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.859]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.859]                     .init = FALSE)
[09:29:20.859]                 }
[09:29:20.859]             }
[09:29:20.859]         }
[09:29:20.859]     })
[09:29:20.859]     if (TRUE) {
[09:29:20.859]         base::sink(type = "output", split = FALSE)
[09:29:20.859]         if (TRUE) {
[09:29:20.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.859]         }
[09:29:20.859]         else {
[09:29:20.859]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.859]         }
[09:29:20.859]         base::close(...future.stdout)
[09:29:20.859]         ...future.stdout <- NULL
[09:29:20.859]     }
[09:29:20.859]     ...future.result$conditions <- ...future.conditions
[09:29:20.859]     ...future.result$finished <- base::Sys.time()
[09:29:20.859]     ...future.result
[09:29:20.859] }
[09:29:20.862] Exporting 5 global objects (2.47 KiB) to cluster node #1 ...
[09:29:20.862] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ...
[09:29:20.862] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ... DONE
[09:29:20.863] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[09:29:20.863] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[09:29:20.863] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[09:29:20.863] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[09:29:20.863] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ...
[09:29:20.864] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ... DONE
[09:29:20.864] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:20.864] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.864] Exporting 5 global objects (2.47 KiB) to cluster node #1 ... DONE
[09:29:20.865] MultisessionFuture started
[09:29:20.865] - Launch lazy future ... done
[09:29:20.865] run() for ‘MultisessionFuture’ ... done
[09:29:20.865] Created future:
[09:29:20.865] MultisessionFuture:
[09:29:20.865] Label: ‘future_mapply-1’
[09:29:20.865] Expression:
[09:29:20.865] {
[09:29:20.865]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.865]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.865]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.865]         on.exit(options(oopts), add = TRUE)
[09:29:20.865]     }
[09:29:20.865]     {
[09:29:20.865]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:20.865]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[09:29:20.865]                 inherits = FALSE)
[09:29:20.865]             ...future.FUN(...)
[09:29:20.865]         }
[09:29:20.865]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:20.865]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:20.865]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.865]         do.call(mapply, args = args)
[09:29:20.865]     }
[09:29:20.865] }
[09:29:20.865] Lazy evaluation: FALSE
[09:29:20.865] Asynchronous evaluation: TRUE
[09:29:20.865] Local evaluation: TRUE
[09:29:20.865] Environment: R_GlobalEnv
[09:29:20.865] Capture standard output: TRUE
[09:29:20.865] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.865] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.865] Packages: 1 packages (‘stats’)
[09:29:20.865] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:29:20.865] Resolved: FALSE
[09:29:20.865] Value: <not collected>
[09:29:20.865] Conditions captured: <none>
[09:29:20.865] Early signaling: FALSE
[09:29:20.865] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.865] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.876] Chunk #1 of 2 ... DONE
[09:29:20.877] Chunk #2 of 2 ...
[09:29:20.877]  - Finding globals in '...' for chunk #2 ...
[09:29:20.877] getGlobalsAndPackages() ...
[09:29:20.877] Searching for globals...
[09:29:20.877] 
[09:29:20.877] Searching for globals ... DONE
[09:29:20.878] - globals: [0] <none>
[09:29:20.878] getGlobalsAndPackages() ... DONE
[09:29:20.878]    + additional globals found: [n=0] 
[09:29:20.878]    + additional namespaces needed: [n=0] 
[09:29:20.878]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:20.878]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:20.878]  - seeds: [2] <seeds>
[09:29:20.878]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.878] getGlobalsAndPackages() ...
[09:29:20.878] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.878] Resolving globals: FALSE
[09:29:20.882] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[09:29:20.882] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[09:29:20.882] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.882] - packages: [1] ‘stats’
[09:29:20.882] getGlobalsAndPackages() ... DONE
[09:29:20.883] run() for ‘Future’ ...
[09:29:20.883] - state: ‘created’
[09:29:20.883] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.897] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.897] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.897]   - Field: ‘node’
[09:29:20.898]   - Field: ‘label’
[09:29:20.898]   - Field: ‘local’
[09:29:20.898]   - Field: ‘owner’
[09:29:20.898]   - Field: ‘envir’
[09:29:20.898]   - Field: ‘workers’
[09:29:20.898]   - Field: ‘packages’
[09:29:20.898]   - Field: ‘gc’
[09:29:20.898]   - Field: ‘conditions’
[09:29:20.898]   - Field: ‘persistent’
[09:29:20.898]   - Field: ‘expr’
[09:29:20.898]   - Field: ‘uuid’
[09:29:20.899]   - Field: ‘seed’
[09:29:20.899]   - Field: ‘version’
[09:29:20.899]   - Field: ‘result’
[09:29:20.899]   - Field: ‘asynchronous’
[09:29:20.899]   - Field: ‘calls’
[09:29:20.899]   - Field: ‘globals’
[09:29:20.899]   - Field: ‘stdout’
[09:29:20.899]   - Field: ‘earlySignal’
[09:29:20.899]   - Field: ‘lazy’
[09:29:20.899]   - Field: ‘state’
[09:29:20.899] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.899] - Launch lazy future ...
[09:29:20.900] Packages needed by the future expression (n = 1): ‘stats’
[09:29:20.900] Packages needed by future strategies (n = 0): <none>
[09:29:20.900] {
[09:29:20.900]     {
[09:29:20.900]         {
[09:29:20.900]             ...future.startTime <- base::Sys.time()
[09:29:20.900]             {
[09:29:20.900]                 {
[09:29:20.900]                   {
[09:29:20.900]                     {
[09:29:20.900]                       {
[09:29:20.900]                         base::local({
[09:29:20.900]                           has_future <- base::requireNamespace("future", 
[09:29:20.900]                             quietly = TRUE)
[09:29:20.900]                           if (has_future) {
[09:29:20.900]                             ns <- base::getNamespace("future")
[09:29:20.900]                             version <- ns[[".package"]][["version"]]
[09:29:20.900]                             if (is.null(version)) 
[09:29:20.900]                               version <- utils::packageVersion("future")
[09:29:20.900]                           }
[09:29:20.900]                           else {
[09:29:20.900]                             version <- NULL
[09:29:20.900]                           }
[09:29:20.900]                           if (!has_future || version < "1.8.0") {
[09:29:20.900]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.900]                               "", base::R.version$version.string), 
[09:29:20.900]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:20.900]                                 base::R.version$platform, 8 * 
[09:29:20.900]                                   base::.Machine$sizeof.pointer), 
[09:29:20.900]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.900]                                 "release", "version")], collapse = " "), 
[09:29:20.900]                               hostname = base::Sys.info()[["nodename"]])
[09:29:20.900]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.900]                               info)
[09:29:20.900]                             info <- base::paste(info, collapse = "; ")
[09:29:20.900]                             if (!has_future) {
[09:29:20.900]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.900]                                 info)
[09:29:20.900]                             }
[09:29:20.900]                             else {
[09:29:20.900]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.900]                                 info, version)
[09:29:20.900]                             }
[09:29:20.900]                             base::stop(msg)
[09:29:20.900]                           }
[09:29:20.900]                         })
[09:29:20.900]                       }
[09:29:20.900]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.900]                       base::options(mc.cores = 1L)
[09:29:20.900]                     }
[09:29:20.900]                     base::local({
[09:29:20.900]                       for (pkg in "stats") {
[09:29:20.900]                         base::loadNamespace(pkg)
[09:29:20.900]                         base::library(pkg, character.only = TRUE)
[09:29:20.900]                       }
[09:29:20.900]                     })
[09:29:20.900]                   }
[09:29:20.900]                   ...future.strategy.old <- future::plan("list")
[09:29:20.900]                   options(future.plan = NULL)
[09:29:20.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.900]                 }
[09:29:20.900]                 ...future.workdir <- getwd()
[09:29:20.900]             }
[09:29:20.900]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.900]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.900]         }
[09:29:20.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.900]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:20.900]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.900]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.900]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.900]             base::names(...future.oldOptions))
[09:29:20.900]     }
[09:29:20.900]     if (FALSE) {
[09:29:20.900]     }
[09:29:20.900]     else {
[09:29:20.900]         if (TRUE) {
[09:29:20.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.900]                 open = "w")
[09:29:20.900]         }
[09:29:20.900]         else {
[09:29:20.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.900]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.900]         }
[09:29:20.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.900]             base::sink(type = "output", split = FALSE)
[09:29:20.900]             base::close(...future.stdout)
[09:29:20.900]         }, add = TRUE)
[09:29:20.900]     }
[09:29:20.900]     ...future.frame <- base::sys.nframe()
[09:29:20.900]     ...future.conditions <- base::list()
[09:29:20.900]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.900]     if (FALSE) {
[09:29:20.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.900]     }
[09:29:20.900]     ...future.result <- base::tryCatch({
[09:29:20.900]         base::withCallingHandlers({
[09:29:20.900]             ...future.value <- base::withVisible(base::local({
[09:29:20.900]                 ...future.makeSendCondition <- base::local({
[09:29:20.900]                   sendCondition <- NULL
[09:29:20.900]                   function(frame = 1L) {
[09:29:20.900]                     if (is.function(sendCondition)) 
[09:29:20.900]                       return(sendCondition)
[09:29:20.900]                     ns <- getNamespace("parallel")
[09:29:20.900]                     if (exists("sendData", mode = "function", 
[09:29:20.900]                       envir = ns)) {
[09:29:20.900]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.900]                         envir = ns)
[09:29:20.900]                       envir <- sys.frame(frame)
[09:29:20.900]                       master <- NULL
[09:29:20.900]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.900]                         !identical(envir, emptyenv())) {
[09:29:20.900]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.900]                           inherits = FALSE)) {
[09:29:20.900]                           master <- get("master", mode = "list", 
[09:29:20.900]                             envir = envir, inherits = FALSE)
[09:29:20.900]                           if (inherits(master, c("SOCKnode", 
[09:29:20.900]                             "SOCK0node"))) {
[09:29:20.900]                             sendCondition <<- function(cond) {
[09:29:20.900]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.900]                                 success = TRUE)
[09:29:20.900]                               parallel_sendData(master, data)
[09:29:20.900]                             }
[09:29:20.900]                             return(sendCondition)
[09:29:20.900]                           }
[09:29:20.900]                         }
[09:29:20.900]                         frame <- frame + 1L
[09:29:20.900]                         envir <- sys.frame(frame)
[09:29:20.900]                       }
[09:29:20.900]                     }
[09:29:20.900]                     sendCondition <<- function(cond) NULL
[09:29:20.900]                   }
[09:29:20.900]                 })
[09:29:20.900]                 withCallingHandlers({
[09:29:20.900]                   {
[09:29:20.900]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.900]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.900]                       ...future.globals.maxSize)) {
[09:29:20.900]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.900]                       on.exit(options(oopts), add = TRUE)
[09:29:20.900]                     }
[09:29:20.900]                     {
[09:29:20.900]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:20.900]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[09:29:20.900]                           envir = globalenv(), inherits = FALSE)
[09:29:20.900]                         ...future.FUN(...)
[09:29:20.900]                       }
[09:29:20.900]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:20.900]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:20.900]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.900]                         USE.NAMES = FALSE)
[09:29:20.900]                       do.call(mapply, args = args)
[09:29:20.900]                     }
[09:29:20.900]                   }
[09:29:20.900]                 }, immediateCondition = function(cond) {
[09:29:20.900]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.900]                   sendCondition(cond)
[09:29:20.900]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.900]                   {
[09:29:20.900]                     inherits <- base::inherits
[09:29:20.900]                     invokeRestart <- base::invokeRestart
[09:29:20.900]                     is.null <- base::is.null
[09:29:20.900]                     muffled <- FALSE
[09:29:20.900]                     if (inherits(cond, "message")) {
[09:29:20.900]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.900]                       if (muffled) 
[09:29:20.900]                         invokeRestart("muffleMessage")
[09:29:20.900]                     }
[09:29:20.900]                     else if (inherits(cond, "warning")) {
[09:29:20.900]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.900]                       if (muffled) 
[09:29:20.900]                         invokeRestart("muffleWarning")
[09:29:20.900]                     }
[09:29:20.900]                     else if (inherits(cond, "condition")) {
[09:29:20.900]                       if (!is.null(pattern)) {
[09:29:20.900]                         computeRestarts <- base::computeRestarts
[09:29:20.900]                         grepl <- base::grepl
[09:29:20.900]                         restarts <- computeRestarts(cond)
[09:29:20.900]                         for (restart in restarts) {
[09:29:20.900]                           name <- restart$name
[09:29:20.900]                           if (is.null(name)) 
[09:29:20.900]                             next
[09:29:20.900]                           if (!grepl(pattern, name)) 
[09:29:20.900]                             next
[09:29:20.900]                           invokeRestart(restart)
[09:29:20.900]                           muffled <- TRUE
[09:29:20.900]                           break
[09:29:20.900]                         }
[09:29:20.900]                       }
[09:29:20.900]                     }
[09:29:20.900]                     invisible(muffled)
[09:29:20.900]                   }
[09:29:20.900]                   muffleCondition(cond)
[09:29:20.900]                 })
[09:29:20.900]             }))
[09:29:20.900]             future::FutureResult(value = ...future.value$value, 
[09:29:20.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.900]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.900]                     ...future.globalenv.names))
[09:29:20.900]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.900]         }, condition = base::local({
[09:29:20.900]             c <- base::c
[09:29:20.900]             inherits <- base::inherits
[09:29:20.900]             invokeRestart <- base::invokeRestart
[09:29:20.900]             length <- base::length
[09:29:20.900]             list <- base::list
[09:29:20.900]             seq.int <- base::seq.int
[09:29:20.900]             signalCondition <- base::signalCondition
[09:29:20.900]             sys.calls <- base::sys.calls
[09:29:20.900]             `[[` <- base::`[[`
[09:29:20.900]             `+` <- base::`+`
[09:29:20.900]             `<<-` <- base::`<<-`
[09:29:20.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.900]                   3L)]
[09:29:20.900]             }
[09:29:20.900]             function(cond) {
[09:29:20.900]                 is_error <- inherits(cond, "error")
[09:29:20.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.900]                   NULL)
[09:29:20.900]                 if (is_error) {
[09:29:20.900]                   sessionInformation <- function() {
[09:29:20.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.900]                       search = base::search(), system = base::Sys.info())
[09:29:20.900]                   }
[09:29:20.900]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.900]                     cond$call), session = sessionInformation(), 
[09:29:20.900]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.900]                   signalCondition(cond)
[09:29:20.900]                 }
[09:29:20.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.900]                 "immediateCondition"))) {
[09:29:20.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.900]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.900]                   if (TRUE && !signal) {
[09:29:20.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.900]                     {
[09:29:20.900]                       inherits <- base::inherits
[09:29:20.900]                       invokeRestart <- base::invokeRestart
[09:29:20.900]                       is.null <- base::is.null
[09:29:20.900]                       muffled <- FALSE
[09:29:20.900]                       if (inherits(cond, "message")) {
[09:29:20.900]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.900]                         if (muffled) 
[09:29:20.900]                           invokeRestart("muffleMessage")
[09:29:20.900]                       }
[09:29:20.900]                       else if (inherits(cond, "warning")) {
[09:29:20.900]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.900]                         if (muffled) 
[09:29:20.900]                           invokeRestart("muffleWarning")
[09:29:20.900]                       }
[09:29:20.900]                       else if (inherits(cond, "condition")) {
[09:29:20.900]                         if (!is.null(pattern)) {
[09:29:20.900]                           computeRestarts <- base::computeRestarts
[09:29:20.900]                           grepl <- base::grepl
[09:29:20.900]                           restarts <- computeRestarts(cond)
[09:29:20.900]                           for (restart in restarts) {
[09:29:20.900]                             name <- restart$name
[09:29:20.900]                             if (is.null(name)) 
[09:29:20.900]                               next
[09:29:20.900]                             if (!grepl(pattern, name)) 
[09:29:20.900]                               next
[09:29:20.900]                             invokeRestart(restart)
[09:29:20.900]                             muffled <- TRUE
[09:29:20.900]                             break
[09:29:20.900]                           }
[09:29:20.900]                         }
[09:29:20.900]                       }
[09:29:20.900]                       invisible(muffled)
[09:29:20.900]                     }
[09:29:20.900]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.900]                   }
[09:29:20.900]                 }
[09:29:20.900]                 else {
[09:29:20.900]                   if (TRUE) {
[09:29:20.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.900]                     {
[09:29:20.900]                       inherits <- base::inherits
[09:29:20.900]                       invokeRestart <- base::invokeRestart
[09:29:20.900]                       is.null <- base::is.null
[09:29:20.900]                       muffled <- FALSE
[09:29:20.900]                       if (inherits(cond, "message")) {
[09:29:20.900]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.900]                         if (muffled) 
[09:29:20.900]                           invokeRestart("muffleMessage")
[09:29:20.900]                       }
[09:29:20.900]                       else if (inherits(cond, "warning")) {
[09:29:20.900]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.900]                         if (muffled) 
[09:29:20.900]                           invokeRestart("muffleWarning")
[09:29:20.900]                       }
[09:29:20.900]                       else if (inherits(cond, "condition")) {
[09:29:20.900]                         if (!is.null(pattern)) {
[09:29:20.900]                           computeRestarts <- base::computeRestarts
[09:29:20.900]                           grepl <- base::grepl
[09:29:20.900]                           restarts <- computeRestarts(cond)
[09:29:20.900]                           for (restart in restarts) {
[09:29:20.900]                             name <- restart$name
[09:29:20.900]                             if (is.null(name)) 
[09:29:20.900]                               next
[09:29:20.900]                             if (!grepl(pattern, name)) 
[09:29:20.900]                               next
[09:29:20.900]                             invokeRestart(restart)
[09:29:20.900]                             muffled <- TRUE
[09:29:20.900]                             break
[09:29:20.900]                           }
[09:29:20.900]                         }
[09:29:20.900]                       }
[09:29:20.900]                       invisible(muffled)
[09:29:20.900]                     }
[09:29:20.900]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.900]                   }
[09:29:20.900]                 }
[09:29:20.900]             }
[09:29:20.900]         }))
[09:29:20.900]     }, error = function(ex) {
[09:29:20.900]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.900]                 ...future.rng), started = ...future.startTime, 
[09:29:20.900]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.900]             version = "1.8"), class = "FutureResult")
[09:29:20.900]     }, finally = {
[09:29:20.900]         if (!identical(...future.workdir, getwd())) 
[09:29:20.900]             setwd(...future.workdir)
[09:29:20.900]         {
[09:29:20.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.900]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.900]             }
[09:29:20.900]             base::options(...future.oldOptions)
[09:29:20.900]             if (.Platform$OS.type == "windows") {
[09:29:20.900]                 old_names <- names(...future.oldEnvVars)
[09:29:20.900]                 envs <- base::Sys.getenv()
[09:29:20.900]                 names <- names(envs)
[09:29:20.900]                 common <- intersect(names, old_names)
[09:29:20.900]                 added <- setdiff(names, old_names)
[09:29:20.900]                 removed <- setdiff(old_names, names)
[09:29:20.900]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.900]                   envs[common]]
[09:29:20.900]                 NAMES <- toupper(changed)
[09:29:20.900]                 args <- list()
[09:29:20.900]                 for (kk in seq_along(NAMES)) {
[09:29:20.900]                   name <- changed[[kk]]
[09:29:20.900]                   NAME <- NAMES[[kk]]
[09:29:20.900]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.900]                     next
[09:29:20.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.900]                 }
[09:29:20.900]                 NAMES <- toupper(added)
[09:29:20.900]                 for (kk in seq_along(NAMES)) {
[09:29:20.900]                   name <- added[[kk]]
[09:29:20.900]                   NAME <- NAMES[[kk]]
[09:29:20.900]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.900]                     next
[09:29:20.900]                   args[[name]] <- ""
[09:29:20.900]                 }
[09:29:20.900]                 NAMES <- toupper(removed)
[09:29:20.900]                 for (kk in seq_along(NAMES)) {
[09:29:20.900]                   name <- removed[[kk]]
[09:29:20.900]                   NAME <- NAMES[[kk]]
[09:29:20.900]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.900]                     next
[09:29:20.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.900]                 }
[09:29:20.900]                 if (length(args) > 0) 
[09:29:20.900]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.900]             }
[09:29:20.900]             else {
[09:29:20.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.900]             }
[09:29:20.900]             {
[09:29:20.900]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.900]                   0L) {
[09:29:20.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.900]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.900]                   base::options(opts)
[09:29:20.900]                 }
[09:29:20.900]                 {
[09:29:20.900]                   {
[09:29:20.900]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.900]                     NULL
[09:29:20.900]                   }
[09:29:20.900]                   options(future.plan = NULL)
[09:29:20.900]                   if (is.na(NA_character_)) 
[09:29:20.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.900]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.900]                     .init = FALSE)
[09:29:20.900]                 }
[09:29:20.900]             }
[09:29:20.900]         }
[09:29:20.900]     })
[09:29:20.900]     if (TRUE) {
[09:29:20.900]         base::sink(type = "output", split = FALSE)
[09:29:20.900]         if (TRUE) {
[09:29:20.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.900]         }
[09:29:20.900]         else {
[09:29:20.900]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.900]         }
[09:29:20.900]         base::close(...future.stdout)
[09:29:20.900]         ...future.stdout <- NULL
[09:29:20.900]     }
[09:29:20.900]     ...future.result$conditions <- ...future.conditions
[09:29:20.900]     ...future.result$finished <- base::Sys.time()
[09:29:20.900]     ...future.result
[09:29:20.900] }
[09:29:20.903] Exporting 5 global objects (2.47 KiB) to cluster node #2 ...
[09:29:20.903] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ...
[09:29:20.903] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ... DONE
[09:29:20.904] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[09:29:20.904] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[09:29:20.904] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[09:29:20.905] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[09:29:20.905] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ...
[09:29:20.905] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ... DONE
[09:29:20.905] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:20.906] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:20.906] Exporting 5 global objects (2.47 KiB) to cluster node #2 ... DONE
[09:29:20.906] MultisessionFuture started
[09:29:20.906] - Launch lazy future ... done
[09:29:20.906] run() for ‘MultisessionFuture’ ... done
[09:29:20.907] Created future:
[09:29:20.907] MultisessionFuture:
[09:29:20.907] Label: ‘future_mapply-2’
[09:29:20.907] Expression:
[09:29:20.907] {
[09:29:20.907]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.907]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.907]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.907]         on.exit(options(oopts), add = TRUE)
[09:29:20.907]     }
[09:29:20.907]     {
[09:29:20.907]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[09:29:20.907]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[09:29:20.907]                 inherits = FALSE)
[09:29:20.907]             ...future.FUN(...)
[09:29:20.907]         }
[09:29:20.907]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[09:29:20.907]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[09:29:20.907]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.907]         do.call(mapply, args = args)
[09:29:20.907]     }
[09:29:20.907] }
[09:29:20.907] Lazy evaluation: FALSE
[09:29:20.907] Asynchronous evaluation: TRUE
[09:29:20.907] Local evaluation: TRUE
[09:29:20.907] Environment: R_GlobalEnv
[09:29:20.907] Capture standard output: TRUE
[09:29:20.907] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.907] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.907] Packages: 1 packages (‘stats’)
[09:29:20.907] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:29:20.907] Resolved: FALSE
[09:29:20.907] Value: <not collected>
[09:29:20.907] Conditions captured: <none>
[09:29:20.907] Early signaling: FALSE
[09:29:20.907] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.907] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.918] Chunk #2 of 2 ... DONE
[09:29:20.918] Launching 2 futures (chunks) ... DONE
[09:29:20.918] Resolving 2 futures (chunks) ...
[09:29:20.918] resolve() on list ...
[09:29:20.919]  recursive: 0
[09:29:20.919]  length: 2
[09:29:20.919] 
[09:29:20.919] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.919] - Validating connection of MultisessionFuture
[09:29:20.920] - received message: FutureResult
[09:29:20.920] - Received FutureResult
[09:29:20.920] - Erased future from FutureRegistry
[09:29:20.920] result() for ClusterFuture ...
[09:29:20.920] - result already collected: FutureResult
[09:29:20.920] result() for ClusterFuture ... done
[09:29:20.920] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.920] Future #1
[09:29:20.920] result() for ClusterFuture ...
[09:29:20.920] - result already collected: FutureResult
[09:29:20.921] result() for ClusterFuture ... done
[09:29:20.921] result() for ClusterFuture ...
[09:29:20.921] - result already collected: FutureResult
[09:29:20.921] result() for ClusterFuture ... done
[09:29:20.921] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:20.921] - nx: 2
[09:29:20.921] - relay: TRUE
[09:29:20.921] - stdout: TRUE
[09:29:20.921] - signal: TRUE
[09:29:20.921] - resignal: FALSE
[09:29:20.921] - force: TRUE
[09:29:20.921] - relayed: [n=2] FALSE, FALSE
[09:29:20.922] - queued futures: [n=2] FALSE, FALSE
[09:29:20.922]  - until=1
[09:29:20.922]  - relaying element #1
[09:29:20.922] result() for ClusterFuture ...
[09:29:20.922] - result already collected: FutureResult
[09:29:20.922] result() for ClusterFuture ... done
[09:29:20.922] result() for ClusterFuture ...
[09:29:20.922] - result already collected: FutureResult
[09:29:20.922] result() for ClusterFuture ... done
[09:29:20.922] result() for ClusterFuture ...
[09:29:20.922] - result already collected: FutureResult
[09:29:20.923] result() for ClusterFuture ... done
[09:29:20.923] result() for ClusterFuture ...
[09:29:20.923] - result already collected: FutureResult
[09:29:20.923] result() for ClusterFuture ... done
[09:29:20.923] - relayed: [n=2] TRUE, FALSE
[09:29:20.923] - queued futures: [n=2] TRUE, FALSE
[09:29:20.923] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:20.923]  length: 1 (resolved future 1)
[09:29:20.950] receiveMessageFromWorker() for ClusterFuture ...
[09:29:20.950] - Validating connection of MultisessionFuture
[09:29:20.950] - received message: FutureResult
[09:29:20.950] - Received FutureResult
[09:29:20.950] - Erased future from FutureRegistry
[09:29:20.950] result() for ClusterFuture ...
[09:29:20.950] - result already collected: FutureResult
[09:29:20.950] result() for ClusterFuture ... done
[09:29:20.950] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:20.950] Future #2
[09:29:20.951] result() for ClusterFuture ...
[09:29:20.951] - result already collected: FutureResult
[09:29:20.951] result() for ClusterFuture ... done
[09:29:20.951] result() for ClusterFuture ...
[09:29:20.951] - result already collected: FutureResult
[09:29:20.951] result() for ClusterFuture ... done
[09:29:20.951] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:20.951] - nx: 2
[09:29:20.951] - relay: TRUE
[09:29:20.951] - stdout: TRUE
[09:29:20.951] - signal: TRUE
[09:29:20.952] - resignal: FALSE
[09:29:20.952] - force: TRUE
[09:29:20.952] - relayed: [n=2] TRUE, FALSE
[09:29:20.952] - queued futures: [n=2] TRUE, FALSE
[09:29:20.952]  - until=2
[09:29:20.952]  - relaying element #2
[09:29:20.952] result() for ClusterFuture ...
[09:29:20.952] - result already collected: FutureResult
[09:29:20.952] result() for ClusterFuture ... done
[09:29:20.952] result() for ClusterFuture ...
[09:29:20.952] - result already collected: FutureResult
[09:29:20.953] result() for ClusterFuture ... done
[09:29:20.953] result() for ClusterFuture ...
[09:29:20.953] - result already collected: FutureResult
[09:29:20.953] result() for ClusterFuture ... done
[09:29:20.953] result() for ClusterFuture ...
[09:29:20.953] - result already collected: FutureResult
[09:29:20.953] result() for ClusterFuture ... done
[09:29:20.953] - relayed: [n=2] TRUE, TRUE
[09:29:20.953] - queued futures: [n=2] TRUE, TRUE
[09:29:20.953] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:20.953]  length: 0 (resolved future 2)
[09:29:20.954] Relaying remaining futures
[09:29:20.954] signalConditionsASAP(NULL, pos=0) ...
[09:29:20.954] - nx: 2
[09:29:20.954] - relay: TRUE
[09:29:20.954] - stdout: TRUE
[09:29:20.954] - signal: TRUE
[09:29:20.954] - resignal: FALSE
[09:29:20.954] - force: TRUE
[09:29:20.954] - relayed: [n=2] TRUE, TRUE
[09:29:20.954] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:20.954] - relayed: [n=2] TRUE, TRUE
[09:29:20.954] - queued futures: [n=2] TRUE, TRUE
[09:29:20.955] signalConditionsASAP(NULL, pos=0) ... done
[09:29:20.955] resolve() on list ... DONE
[09:29:20.955] result() for ClusterFuture ...
[09:29:20.955] - result already collected: FutureResult
[09:29:20.955] result() for ClusterFuture ... done
[09:29:20.955] result() for ClusterFuture ...
[09:29:20.955] - result already collected: FutureResult
[09:29:20.955] result() for ClusterFuture ... done
[09:29:20.955] result() for ClusterFuture ...
[09:29:20.955] - result already collected: FutureResult
[09:29:20.955] result() for ClusterFuture ... done
[09:29:20.956] result() for ClusterFuture ...
[09:29:20.956] - result already collected: FutureResult
[09:29:20.956] result() for ClusterFuture ... done
[09:29:20.956]  - Number of value chunks collected: 2
[09:29:20.956] Resolving 2 futures (chunks) ... DONE
[09:29:20.956] Reducing values from 2 chunks ...
[09:29:20.956]  - Number of values collected after concatenation: 4
[09:29:20.956]  - Number of values expected: 4
[09:29:20.956] Reducing values from 2 chunks ... DONE
[09:29:20.956] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[09:29:20.957] future_mapply() ...
[09:29:20.960] Number of chunks: 2
[09:29:20.960] getGlobalsAndPackagesXApply() ...
[09:29:20.961]  - future.globals: TRUE
[09:29:20.961] getGlobalsAndPackages() ...
[09:29:20.961] Searching for globals...
[09:29:20.962] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:29:20.962] Searching for globals ... DONE
[09:29:20.962] Resolving globals: FALSE
[09:29:20.962] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[09:29:20.963] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[09:29:20.963] - globals: [1] ‘FUN’
[09:29:20.963] - packages: [1] ‘stats’
[09:29:20.963] getGlobalsAndPackages() ... DONE
[09:29:20.963]  - globals found/used: [n=1] ‘FUN’
[09:29:20.963]  - needed namespaces: [n=1] ‘stats’
[09:29:20.963] Finding globals ... DONE
[09:29:20.963] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:20.964] List of 2
[09:29:20.964]  $ ...future.FUN:function (x, w, ...)  
[09:29:20.964]  $ MoreArgs     : NULL
[09:29:20.964]  - attr(*, "where")=List of 2
[09:29:20.964]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:20.964]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:20.964]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:20.964]  - attr(*, "resolved")= logi FALSE
[09:29:20.964]  - attr(*, "total_size")= num NA
[09:29:20.966] Packages to be attached in all futures: [n=1] ‘stats’
[09:29:20.966] getGlobalsAndPackagesXApply() ... DONE
[09:29:20.966] Number of futures (= number of chunks): 2
[09:29:20.966] Launching 2 futures (chunks) ...
[09:29:20.966] Chunk #1 of 2 ...
[09:29:20.967]  - Finding globals in '...' for chunk #1 ...
[09:29:20.967] getGlobalsAndPackages() ...
[09:29:20.967] Searching for globals...
[09:29:20.967] 
[09:29:20.967] Searching for globals ... DONE
[09:29:20.967] - globals: [0] <none>
[09:29:20.967] getGlobalsAndPackages() ... DONE
[09:29:20.967]    + additional globals found: [n=0] 
[09:29:20.968]    + additional namespaces needed: [n=0] 
[09:29:20.968]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:20.968]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:20.968]  - seeds: <none>
[09:29:20.968]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.968] getGlobalsAndPackages() ...
[09:29:20.968] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.968] Resolving globals: FALSE
[09:29:20.969] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[09:29:20.969] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:20.969] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:20.969] - packages: [1] ‘stats’
[09:29:20.969] getGlobalsAndPackages() ... DONE
[09:29:20.970] run() for ‘Future’ ...
[09:29:20.970] - state: ‘created’
[09:29:20.970] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:20.983] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:20.984] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:20.984]   - Field: ‘node’
[09:29:20.984]   - Field: ‘label’
[09:29:20.984]   - Field: ‘local’
[09:29:20.984]   - Field: ‘owner’
[09:29:20.984]   - Field: ‘envir’
[09:29:20.984]   - Field: ‘workers’
[09:29:20.984]   - Field: ‘packages’
[09:29:20.984]   - Field: ‘gc’
[09:29:20.985]   - Field: ‘conditions’
[09:29:20.985]   - Field: ‘persistent’
[09:29:20.985]   - Field: ‘expr’
[09:29:20.985]   - Field: ‘uuid’
[09:29:20.985]   - Field: ‘seed’
[09:29:20.985]   - Field: ‘version’
[09:29:20.985]   - Field: ‘result’
[09:29:20.985]   - Field: ‘asynchronous’
[09:29:20.985]   - Field: ‘calls’
[09:29:20.985]   - Field: ‘globals’
[09:29:20.985]   - Field: ‘stdout’
[09:29:20.986]   - Field: ‘earlySignal’
[09:29:20.986]   - Field: ‘lazy’
[09:29:20.986]   - Field: ‘state’
[09:29:20.986] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:20.986] - Launch lazy future ...
[09:29:20.986] Packages needed by the future expression (n = 1): ‘stats’
[09:29:20.986] Packages needed by future strategies (n = 0): <none>
[09:29:20.987] {
[09:29:20.987]     {
[09:29:20.987]         {
[09:29:20.987]             ...future.startTime <- base::Sys.time()
[09:29:20.987]             {
[09:29:20.987]                 {
[09:29:20.987]                   {
[09:29:20.987]                     {
[09:29:20.987]                       {
[09:29:20.987]                         base::local({
[09:29:20.987]                           has_future <- base::requireNamespace("future", 
[09:29:20.987]                             quietly = TRUE)
[09:29:20.987]                           if (has_future) {
[09:29:20.987]                             ns <- base::getNamespace("future")
[09:29:20.987]                             version <- ns[[".package"]][["version"]]
[09:29:20.987]                             if (is.null(version)) 
[09:29:20.987]                               version <- utils::packageVersion("future")
[09:29:20.987]                           }
[09:29:20.987]                           else {
[09:29:20.987]                             version <- NULL
[09:29:20.987]                           }
[09:29:20.987]                           if (!has_future || version < "1.8.0") {
[09:29:20.987]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:20.987]                               "", base::R.version$version.string), 
[09:29:20.987]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:20.987]                                 base::R.version$platform, 8 * 
[09:29:20.987]                                   base::.Machine$sizeof.pointer), 
[09:29:20.987]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:20.987]                                 "release", "version")], collapse = " "), 
[09:29:20.987]                               hostname = base::Sys.info()[["nodename"]])
[09:29:20.987]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:20.987]                               info)
[09:29:20.987]                             info <- base::paste(info, collapse = "; ")
[09:29:20.987]                             if (!has_future) {
[09:29:20.987]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:20.987]                                 info)
[09:29:20.987]                             }
[09:29:20.987]                             else {
[09:29:20.987]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:20.987]                                 info, version)
[09:29:20.987]                             }
[09:29:20.987]                             base::stop(msg)
[09:29:20.987]                           }
[09:29:20.987]                         })
[09:29:20.987]                       }
[09:29:20.987]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:20.987]                       base::options(mc.cores = 1L)
[09:29:20.987]                     }
[09:29:20.987]                     base::local({
[09:29:20.987]                       for (pkg in "stats") {
[09:29:20.987]                         base::loadNamespace(pkg)
[09:29:20.987]                         base::library(pkg, character.only = TRUE)
[09:29:20.987]                       }
[09:29:20.987]                     })
[09:29:20.987]                   }
[09:29:20.987]                   ...future.strategy.old <- future::plan("list")
[09:29:20.987]                   options(future.plan = NULL)
[09:29:20.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:20.987]                 }
[09:29:20.987]                 ...future.workdir <- getwd()
[09:29:20.987]             }
[09:29:20.987]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:20.987]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:20.987]         }
[09:29:20.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:20.987]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:20.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:20.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:20.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:20.987]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:20.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:20.987]             base::names(...future.oldOptions))
[09:29:20.987]     }
[09:29:20.987]     if (FALSE) {
[09:29:20.987]     }
[09:29:20.987]     else {
[09:29:20.987]         if (TRUE) {
[09:29:20.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:20.987]                 open = "w")
[09:29:20.987]         }
[09:29:20.987]         else {
[09:29:20.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:20.987]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:20.987]         }
[09:29:20.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:20.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:20.987]             base::sink(type = "output", split = FALSE)
[09:29:20.987]             base::close(...future.stdout)
[09:29:20.987]         }, add = TRUE)
[09:29:20.987]     }
[09:29:20.987]     ...future.frame <- base::sys.nframe()
[09:29:20.987]     ...future.conditions <- base::list()
[09:29:20.987]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:20.987]     if (FALSE) {
[09:29:20.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:20.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:20.987]     }
[09:29:20.987]     ...future.result <- base::tryCatch({
[09:29:20.987]         base::withCallingHandlers({
[09:29:20.987]             ...future.value <- base::withVisible(base::local({
[09:29:20.987]                 ...future.makeSendCondition <- base::local({
[09:29:20.987]                   sendCondition <- NULL
[09:29:20.987]                   function(frame = 1L) {
[09:29:20.987]                     if (is.function(sendCondition)) 
[09:29:20.987]                       return(sendCondition)
[09:29:20.987]                     ns <- getNamespace("parallel")
[09:29:20.987]                     if (exists("sendData", mode = "function", 
[09:29:20.987]                       envir = ns)) {
[09:29:20.987]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:20.987]                         envir = ns)
[09:29:20.987]                       envir <- sys.frame(frame)
[09:29:20.987]                       master <- NULL
[09:29:20.987]                       while (!identical(envir, .GlobalEnv) && 
[09:29:20.987]                         !identical(envir, emptyenv())) {
[09:29:20.987]                         if (exists("master", mode = "list", envir = envir, 
[09:29:20.987]                           inherits = FALSE)) {
[09:29:20.987]                           master <- get("master", mode = "list", 
[09:29:20.987]                             envir = envir, inherits = FALSE)
[09:29:20.987]                           if (inherits(master, c("SOCKnode", 
[09:29:20.987]                             "SOCK0node"))) {
[09:29:20.987]                             sendCondition <<- function(cond) {
[09:29:20.987]                               data <- list(type = "VALUE", value = cond, 
[09:29:20.987]                                 success = TRUE)
[09:29:20.987]                               parallel_sendData(master, data)
[09:29:20.987]                             }
[09:29:20.987]                             return(sendCondition)
[09:29:20.987]                           }
[09:29:20.987]                         }
[09:29:20.987]                         frame <- frame + 1L
[09:29:20.987]                         envir <- sys.frame(frame)
[09:29:20.987]                       }
[09:29:20.987]                     }
[09:29:20.987]                     sendCondition <<- function(cond) NULL
[09:29:20.987]                   }
[09:29:20.987]                 })
[09:29:20.987]                 withCallingHandlers({
[09:29:20.987]                   {
[09:29:20.987]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.987]                     if (!identical(...future.globals.maxSize.org, 
[09:29:20.987]                       ...future.globals.maxSize)) {
[09:29:20.987]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.987]                       on.exit(options(oopts), add = TRUE)
[09:29:20.987]                     }
[09:29:20.987]                     {
[09:29:20.987]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.987]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:20.987]                         USE.NAMES = FALSE)
[09:29:20.987]                       do.call(mapply, args = args)
[09:29:20.987]                     }
[09:29:20.987]                   }
[09:29:20.987]                 }, immediateCondition = function(cond) {
[09:29:20.987]                   sendCondition <- ...future.makeSendCondition()
[09:29:20.987]                   sendCondition(cond)
[09:29:20.987]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.987]                   {
[09:29:20.987]                     inherits <- base::inherits
[09:29:20.987]                     invokeRestart <- base::invokeRestart
[09:29:20.987]                     is.null <- base::is.null
[09:29:20.987]                     muffled <- FALSE
[09:29:20.987]                     if (inherits(cond, "message")) {
[09:29:20.987]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:20.987]                       if (muffled) 
[09:29:20.987]                         invokeRestart("muffleMessage")
[09:29:20.987]                     }
[09:29:20.987]                     else if (inherits(cond, "warning")) {
[09:29:20.987]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:20.987]                       if (muffled) 
[09:29:20.987]                         invokeRestart("muffleWarning")
[09:29:20.987]                     }
[09:29:20.987]                     else if (inherits(cond, "condition")) {
[09:29:20.987]                       if (!is.null(pattern)) {
[09:29:20.987]                         computeRestarts <- base::computeRestarts
[09:29:20.987]                         grepl <- base::grepl
[09:29:20.987]                         restarts <- computeRestarts(cond)
[09:29:20.987]                         for (restart in restarts) {
[09:29:20.987]                           name <- restart$name
[09:29:20.987]                           if (is.null(name)) 
[09:29:20.987]                             next
[09:29:20.987]                           if (!grepl(pattern, name)) 
[09:29:20.987]                             next
[09:29:20.987]                           invokeRestart(restart)
[09:29:20.987]                           muffled <- TRUE
[09:29:20.987]                           break
[09:29:20.987]                         }
[09:29:20.987]                       }
[09:29:20.987]                     }
[09:29:20.987]                     invisible(muffled)
[09:29:20.987]                   }
[09:29:20.987]                   muffleCondition(cond)
[09:29:20.987]                 })
[09:29:20.987]             }))
[09:29:20.987]             future::FutureResult(value = ...future.value$value, 
[09:29:20.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.987]                   ...future.rng), globalenv = if (FALSE) 
[09:29:20.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:20.987]                     ...future.globalenv.names))
[09:29:20.987]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:20.987]         }, condition = base::local({
[09:29:20.987]             c <- base::c
[09:29:20.987]             inherits <- base::inherits
[09:29:20.987]             invokeRestart <- base::invokeRestart
[09:29:20.987]             length <- base::length
[09:29:20.987]             list <- base::list
[09:29:20.987]             seq.int <- base::seq.int
[09:29:20.987]             signalCondition <- base::signalCondition
[09:29:20.987]             sys.calls <- base::sys.calls
[09:29:20.987]             `[[` <- base::`[[`
[09:29:20.987]             `+` <- base::`+`
[09:29:20.987]             `<<-` <- base::`<<-`
[09:29:20.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:20.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:20.987]                   3L)]
[09:29:20.987]             }
[09:29:20.987]             function(cond) {
[09:29:20.987]                 is_error <- inherits(cond, "error")
[09:29:20.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:20.987]                   NULL)
[09:29:20.987]                 if (is_error) {
[09:29:20.987]                   sessionInformation <- function() {
[09:29:20.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:20.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:20.987]                       search = base::search(), system = base::Sys.info())
[09:29:20.987]                   }
[09:29:20.987]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:20.987]                     cond$call), session = sessionInformation(), 
[09:29:20.987]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:20.987]                   signalCondition(cond)
[09:29:20.987]                 }
[09:29:20.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:20.987]                 "immediateCondition"))) {
[09:29:20.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:20.987]                   ...future.conditions[[length(...future.conditions) + 
[09:29:20.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:20.987]                   if (TRUE && !signal) {
[09:29:20.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.987]                     {
[09:29:20.987]                       inherits <- base::inherits
[09:29:20.987]                       invokeRestart <- base::invokeRestart
[09:29:20.987]                       is.null <- base::is.null
[09:29:20.987]                       muffled <- FALSE
[09:29:20.987]                       if (inherits(cond, "message")) {
[09:29:20.987]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.987]                         if (muffled) 
[09:29:20.987]                           invokeRestart("muffleMessage")
[09:29:20.987]                       }
[09:29:20.987]                       else if (inherits(cond, "warning")) {
[09:29:20.987]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.987]                         if (muffled) 
[09:29:20.987]                           invokeRestart("muffleWarning")
[09:29:20.987]                       }
[09:29:20.987]                       else if (inherits(cond, "condition")) {
[09:29:20.987]                         if (!is.null(pattern)) {
[09:29:20.987]                           computeRestarts <- base::computeRestarts
[09:29:20.987]                           grepl <- base::grepl
[09:29:20.987]                           restarts <- computeRestarts(cond)
[09:29:20.987]                           for (restart in restarts) {
[09:29:20.987]                             name <- restart$name
[09:29:20.987]                             if (is.null(name)) 
[09:29:20.987]                               next
[09:29:20.987]                             if (!grepl(pattern, name)) 
[09:29:20.987]                               next
[09:29:20.987]                             invokeRestart(restart)
[09:29:20.987]                             muffled <- TRUE
[09:29:20.987]                             break
[09:29:20.987]                           }
[09:29:20.987]                         }
[09:29:20.987]                       }
[09:29:20.987]                       invisible(muffled)
[09:29:20.987]                     }
[09:29:20.987]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.987]                   }
[09:29:20.987]                 }
[09:29:20.987]                 else {
[09:29:20.987]                   if (TRUE) {
[09:29:20.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:20.987]                     {
[09:29:20.987]                       inherits <- base::inherits
[09:29:20.987]                       invokeRestart <- base::invokeRestart
[09:29:20.987]                       is.null <- base::is.null
[09:29:20.987]                       muffled <- FALSE
[09:29:20.987]                       if (inherits(cond, "message")) {
[09:29:20.987]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:20.987]                         if (muffled) 
[09:29:20.987]                           invokeRestart("muffleMessage")
[09:29:20.987]                       }
[09:29:20.987]                       else if (inherits(cond, "warning")) {
[09:29:20.987]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:20.987]                         if (muffled) 
[09:29:20.987]                           invokeRestart("muffleWarning")
[09:29:20.987]                       }
[09:29:20.987]                       else if (inherits(cond, "condition")) {
[09:29:20.987]                         if (!is.null(pattern)) {
[09:29:20.987]                           computeRestarts <- base::computeRestarts
[09:29:20.987]                           grepl <- base::grepl
[09:29:20.987]                           restarts <- computeRestarts(cond)
[09:29:20.987]                           for (restart in restarts) {
[09:29:20.987]                             name <- restart$name
[09:29:20.987]                             if (is.null(name)) 
[09:29:20.987]                               next
[09:29:20.987]                             if (!grepl(pattern, name)) 
[09:29:20.987]                               next
[09:29:20.987]                             invokeRestart(restart)
[09:29:20.987]                             muffled <- TRUE
[09:29:20.987]                             break
[09:29:20.987]                           }
[09:29:20.987]                         }
[09:29:20.987]                       }
[09:29:20.987]                       invisible(muffled)
[09:29:20.987]                     }
[09:29:20.987]                     muffleCondition(cond, pattern = "^muffle")
[09:29:20.987]                   }
[09:29:20.987]                 }
[09:29:20.987]             }
[09:29:20.987]         }))
[09:29:20.987]     }, error = function(ex) {
[09:29:20.987]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:20.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:20.987]                 ...future.rng), started = ...future.startTime, 
[09:29:20.987]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:20.987]             version = "1.8"), class = "FutureResult")
[09:29:20.987]     }, finally = {
[09:29:20.987]         if (!identical(...future.workdir, getwd())) 
[09:29:20.987]             setwd(...future.workdir)
[09:29:20.987]         {
[09:29:20.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:20.987]                 ...future.oldOptions$nwarnings <- NULL
[09:29:20.987]             }
[09:29:20.987]             base::options(...future.oldOptions)
[09:29:20.987]             if (.Platform$OS.type == "windows") {
[09:29:20.987]                 old_names <- names(...future.oldEnvVars)
[09:29:20.987]                 envs <- base::Sys.getenv()
[09:29:20.987]                 names <- names(envs)
[09:29:20.987]                 common <- intersect(names, old_names)
[09:29:20.987]                 added <- setdiff(names, old_names)
[09:29:20.987]                 removed <- setdiff(old_names, names)
[09:29:20.987]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:20.987]                   envs[common]]
[09:29:20.987]                 NAMES <- toupper(changed)
[09:29:20.987]                 args <- list()
[09:29:20.987]                 for (kk in seq_along(NAMES)) {
[09:29:20.987]                   name <- changed[[kk]]
[09:29:20.987]                   NAME <- NAMES[[kk]]
[09:29:20.987]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.987]                     next
[09:29:20.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.987]                 }
[09:29:20.987]                 NAMES <- toupper(added)
[09:29:20.987]                 for (kk in seq_along(NAMES)) {
[09:29:20.987]                   name <- added[[kk]]
[09:29:20.987]                   NAME <- NAMES[[kk]]
[09:29:20.987]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.987]                     next
[09:29:20.987]                   args[[name]] <- ""
[09:29:20.987]                 }
[09:29:20.987]                 NAMES <- toupper(removed)
[09:29:20.987]                 for (kk in seq_along(NAMES)) {
[09:29:20.987]                   name <- removed[[kk]]
[09:29:20.987]                   NAME <- NAMES[[kk]]
[09:29:20.987]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:20.987]                     next
[09:29:20.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:20.987]                 }
[09:29:20.987]                 if (length(args) > 0) 
[09:29:20.987]                   base::do.call(base::Sys.setenv, args = args)
[09:29:20.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:20.987]             }
[09:29:20.987]             else {
[09:29:20.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:20.987]             }
[09:29:20.987]             {
[09:29:20.987]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:20.987]                   0L) {
[09:29:20.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:20.987]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:20.987]                   base::options(opts)
[09:29:20.987]                 }
[09:29:20.987]                 {
[09:29:20.987]                   {
[09:29:20.987]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:20.987]                     NULL
[09:29:20.987]                   }
[09:29:20.987]                   options(future.plan = NULL)
[09:29:20.987]                   if (is.na(NA_character_)) 
[09:29:20.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:20.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:20.987]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:20.987]                     .init = FALSE)
[09:29:20.987]                 }
[09:29:20.987]             }
[09:29:20.987]         }
[09:29:20.987]     })
[09:29:20.987]     if (TRUE) {
[09:29:20.987]         base::sink(type = "output", split = FALSE)
[09:29:20.987]         if (TRUE) {
[09:29:20.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:20.987]         }
[09:29:20.987]         else {
[09:29:20.987]             ...future.result["stdout"] <- base::list(NULL)
[09:29:20.987]         }
[09:29:20.987]         base::close(...future.stdout)
[09:29:20.987]         ...future.stdout <- NULL
[09:29:20.987]     }
[09:29:20.987]     ...future.result$conditions <- ...future.conditions
[09:29:20.987]     ...future.result$finished <- base::Sys.time()
[09:29:20.987]     ...future.result
[09:29:20.987] }
[09:29:20.989] Exporting 5 global objects (2.07 KiB) to cluster node #1 ...
[09:29:20.990] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ...
[09:29:20.990] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ... DONE
[09:29:20.990] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:20.990] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.990] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ...
[09:29:20.991] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ... DONE
[09:29:20.991] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:20.991] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.991] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:20.992] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:20.992] Exporting 5 global objects (2.07 KiB) to cluster node #1 ... DONE
[09:29:20.992] MultisessionFuture started
[09:29:20.992] - Launch lazy future ... done
[09:29:20.992] run() for ‘MultisessionFuture’ ... done
[09:29:20.992] Created future:
[09:29:20.993] MultisessionFuture:
[09:29:20.993] Label: ‘future_Map-1’
[09:29:20.993] Expression:
[09:29:20.993] {
[09:29:20.993]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:20.993]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:20.993]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:20.993]         on.exit(options(oopts), add = TRUE)
[09:29:20.993]     }
[09:29:20.993]     {
[09:29:20.993]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:20.993]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:20.993]         do.call(mapply, args = args)
[09:29:20.993]     }
[09:29:20.993] }
[09:29:20.993] Lazy evaluation: FALSE
[09:29:20.993] Asynchronous evaluation: TRUE
[09:29:20.993] Local evaluation: TRUE
[09:29:20.993] Environment: R_GlobalEnv
[09:29:20.993] Capture standard output: TRUE
[09:29:20.993] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:20.993] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:20.993] Packages: 1 packages (‘stats’)
[09:29:20.993] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:20.993] Resolved: FALSE
[09:29:20.993] Value: <not collected>
[09:29:20.993] Conditions captured: <none>
[09:29:20.993] Early signaling: FALSE
[09:29:20.993] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:20.993] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:21.004] Chunk #1 of 2 ... DONE
[09:29:21.004] Chunk #2 of 2 ...
[09:29:21.004]  - Finding globals in '...' for chunk #2 ...
[09:29:21.004] getGlobalsAndPackages() ...
[09:29:21.004] Searching for globals...
[09:29:21.005] 
[09:29:21.005] Searching for globals ... DONE
[09:29:21.005] - globals: [0] <none>
[09:29:21.005] getGlobalsAndPackages() ... DONE
[09:29:21.005]    + additional globals found: [n=0] 
[09:29:21.005]    + additional namespaces needed: [n=0] 
[09:29:21.005]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:21.005]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:21.005]  - seeds: <none>
[09:29:21.005]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.006] getGlobalsAndPackages() ...
[09:29:21.006] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.006] Resolving globals: FALSE
[09:29:21.006] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[09:29:21.007] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:21.007] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.007] - packages: [1] ‘stats’
[09:29:21.007] getGlobalsAndPackages() ... DONE
[09:29:21.007] run() for ‘Future’ ...
[09:29:21.007] - state: ‘created’
[09:29:21.008] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:21.021] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:21.021] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:21.021]   - Field: ‘node’
[09:29:21.021]   - Field: ‘label’
[09:29:21.022]   - Field: ‘local’
[09:29:21.022]   - Field: ‘owner’
[09:29:21.022]   - Field: ‘envir’
[09:29:21.022]   - Field: ‘workers’
[09:29:21.022]   - Field: ‘packages’
[09:29:21.022]   - Field: ‘gc’
[09:29:21.022]   - Field: ‘conditions’
[09:29:21.022]   - Field: ‘persistent’
[09:29:21.022]   - Field: ‘expr’
[09:29:21.022]   - Field: ‘uuid’
[09:29:21.022]   - Field: ‘seed’
[09:29:21.023]   - Field: ‘version’
[09:29:21.023]   - Field: ‘result’
[09:29:21.023]   - Field: ‘asynchronous’
[09:29:21.023]   - Field: ‘calls’
[09:29:21.023]   - Field: ‘globals’
[09:29:21.023]   - Field: ‘stdout’
[09:29:21.023]   - Field: ‘earlySignal’
[09:29:21.023]   - Field: ‘lazy’
[09:29:21.023]   - Field: ‘state’
[09:29:21.023] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:21.024] - Launch lazy future ...
[09:29:21.024] Packages needed by the future expression (n = 1): ‘stats’
[09:29:21.024] Packages needed by future strategies (n = 0): <none>
[09:29:21.024] {
[09:29:21.024]     {
[09:29:21.024]         {
[09:29:21.024]             ...future.startTime <- base::Sys.time()
[09:29:21.024]             {
[09:29:21.024]                 {
[09:29:21.024]                   {
[09:29:21.024]                     {
[09:29:21.024]                       {
[09:29:21.024]                         base::local({
[09:29:21.024]                           has_future <- base::requireNamespace("future", 
[09:29:21.024]                             quietly = TRUE)
[09:29:21.024]                           if (has_future) {
[09:29:21.024]                             ns <- base::getNamespace("future")
[09:29:21.024]                             version <- ns[[".package"]][["version"]]
[09:29:21.024]                             if (is.null(version)) 
[09:29:21.024]                               version <- utils::packageVersion("future")
[09:29:21.024]                           }
[09:29:21.024]                           else {
[09:29:21.024]                             version <- NULL
[09:29:21.024]                           }
[09:29:21.024]                           if (!has_future || version < "1.8.0") {
[09:29:21.024]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:21.024]                               "", base::R.version$version.string), 
[09:29:21.024]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:21.024]                                 base::R.version$platform, 8 * 
[09:29:21.024]                                   base::.Machine$sizeof.pointer), 
[09:29:21.024]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:21.024]                                 "release", "version")], collapse = " "), 
[09:29:21.024]                               hostname = base::Sys.info()[["nodename"]])
[09:29:21.024]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:21.024]                               info)
[09:29:21.024]                             info <- base::paste(info, collapse = "; ")
[09:29:21.024]                             if (!has_future) {
[09:29:21.024]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:21.024]                                 info)
[09:29:21.024]                             }
[09:29:21.024]                             else {
[09:29:21.024]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:21.024]                                 info, version)
[09:29:21.024]                             }
[09:29:21.024]                             base::stop(msg)
[09:29:21.024]                           }
[09:29:21.024]                         })
[09:29:21.024]                       }
[09:29:21.024]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:21.024]                       base::options(mc.cores = 1L)
[09:29:21.024]                     }
[09:29:21.024]                     base::local({
[09:29:21.024]                       for (pkg in "stats") {
[09:29:21.024]                         base::loadNamespace(pkg)
[09:29:21.024]                         base::library(pkg, character.only = TRUE)
[09:29:21.024]                       }
[09:29:21.024]                     })
[09:29:21.024]                   }
[09:29:21.024]                   ...future.strategy.old <- future::plan("list")
[09:29:21.024]                   options(future.plan = NULL)
[09:29:21.024]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:21.024]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:21.024]                 }
[09:29:21.024]                 ...future.workdir <- getwd()
[09:29:21.024]             }
[09:29:21.024]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:21.024]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:21.024]         }
[09:29:21.024]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:21.024]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:21.024]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:21.024]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:21.024]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:21.024]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:21.024]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:21.024]             base::names(...future.oldOptions))
[09:29:21.024]     }
[09:29:21.024]     if (FALSE) {
[09:29:21.024]     }
[09:29:21.024]     else {
[09:29:21.024]         if (TRUE) {
[09:29:21.024]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:21.024]                 open = "w")
[09:29:21.024]         }
[09:29:21.024]         else {
[09:29:21.024]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:21.024]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:21.024]         }
[09:29:21.024]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:21.024]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:21.024]             base::sink(type = "output", split = FALSE)
[09:29:21.024]             base::close(...future.stdout)
[09:29:21.024]         }, add = TRUE)
[09:29:21.024]     }
[09:29:21.024]     ...future.frame <- base::sys.nframe()
[09:29:21.024]     ...future.conditions <- base::list()
[09:29:21.024]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:21.024]     if (FALSE) {
[09:29:21.024]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:21.024]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:21.024]     }
[09:29:21.024]     ...future.result <- base::tryCatch({
[09:29:21.024]         base::withCallingHandlers({
[09:29:21.024]             ...future.value <- base::withVisible(base::local({
[09:29:21.024]                 ...future.makeSendCondition <- base::local({
[09:29:21.024]                   sendCondition <- NULL
[09:29:21.024]                   function(frame = 1L) {
[09:29:21.024]                     if (is.function(sendCondition)) 
[09:29:21.024]                       return(sendCondition)
[09:29:21.024]                     ns <- getNamespace("parallel")
[09:29:21.024]                     if (exists("sendData", mode = "function", 
[09:29:21.024]                       envir = ns)) {
[09:29:21.024]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:21.024]                         envir = ns)
[09:29:21.024]                       envir <- sys.frame(frame)
[09:29:21.024]                       master <- NULL
[09:29:21.024]                       while (!identical(envir, .GlobalEnv) && 
[09:29:21.024]                         !identical(envir, emptyenv())) {
[09:29:21.024]                         if (exists("master", mode = "list", envir = envir, 
[09:29:21.024]                           inherits = FALSE)) {
[09:29:21.024]                           master <- get("master", mode = "list", 
[09:29:21.024]                             envir = envir, inherits = FALSE)
[09:29:21.024]                           if (inherits(master, c("SOCKnode", 
[09:29:21.024]                             "SOCK0node"))) {
[09:29:21.024]                             sendCondition <<- function(cond) {
[09:29:21.024]                               data <- list(type = "VALUE", value = cond, 
[09:29:21.024]                                 success = TRUE)
[09:29:21.024]                               parallel_sendData(master, data)
[09:29:21.024]                             }
[09:29:21.024]                             return(sendCondition)
[09:29:21.024]                           }
[09:29:21.024]                         }
[09:29:21.024]                         frame <- frame + 1L
[09:29:21.024]                         envir <- sys.frame(frame)
[09:29:21.024]                       }
[09:29:21.024]                     }
[09:29:21.024]                     sendCondition <<- function(cond) NULL
[09:29:21.024]                   }
[09:29:21.024]                 })
[09:29:21.024]                 withCallingHandlers({
[09:29:21.024]                   {
[09:29:21.024]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:21.024]                     if (!identical(...future.globals.maxSize.org, 
[09:29:21.024]                       ...future.globals.maxSize)) {
[09:29:21.024]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:21.024]                       on.exit(options(oopts), add = TRUE)
[09:29:21.024]                     }
[09:29:21.024]                     {
[09:29:21.024]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:21.024]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:21.024]                         USE.NAMES = FALSE)
[09:29:21.024]                       do.call(mapply, args = args)
[09:29:21.024]                     }
[09:29:21.024]                   }
[09:29:21.024]                 }, immediateCondition = function(cond) {
[09:29:21.024]                   sendCondition <- ...future.makeSendCondition()
[09:29:21.024]                   sendCondition(cond)
[09:29:21.024]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.024]                   {
[09:29:21.024]                     inherits <- base::inherits
[09:29:21.024]                     invokeRestart <- base::invokeRestart
[09:29:21.024]                     is.null <- base::is.null
[09:29:21.024]                     muffled <- FALSE
[09:29:21.024]                     if (inherits(cond, "message")) {
[09:29:21.024]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:21.024]                       if (muffled) 
[09:29:21.024]                         invokeRestart("muffleMessage")
[09:29:21.024]                     }
[09:29:21.024]                     else if (inherits(cond, "warning")) {
[09:29:21.024]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:21.024]                       if (muffled) 
[09:29:21.024]                         invokeRestart("muffleWarning")
[09:29:21.024]                     }
[09:29:21.024]                     else if (inherits(cond, "condition")) {
[09:29:21.024]                       if (!is.null(pattern)) {
[09:29:21.024]                         computeRestarts <- base::computeRestarts
[09:29:21.024]                         grepl <- base::grepl
[09:29:21.024]                         restarts <- computeRestarts(cond)
[09:29:21.024]                         for (restart in restarts) {
[09:29:21.024]                           name <- restart$name
[09:29:21.024]                           if (is.null(name)) 
[09:29:21.024]                             next
[09:29:21.024]                           if (!grepl(pattern, name)) 
[09:29:21.024]                             next
[09:29:21.024]                           invokeRestart(restart)
[09:29:21.024]                           muffled <- TRUE
[09:29:21.024]                           break
[09:29:21.024]                         }
[09:29:21.024]                       }
[09:29:21.024]                     }
[09:29:21.024]                     invisible(muffled)
[09:29:21.024]                   }
[09:29:21.024]                   muffleCondition(cond)
[09:29:21.024]                 })
[09:29:21.024]             }))
[09:29:21.024]             future::FutureResult(value = ...future.value$value, 
[09:29:21.024]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:21.024]                   ...future.rng), globalenv = if (FALSE) 
[09:29:21.024]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:21.024]                     ...future.globalenv.names))
[09:29:21.024]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:21.024]         }, condition = base::local({
[09:29:21.024]             c <- base::c
[09:29:21.024]             inherits <- base::inherits
[09:29:21.024]             invokeRestart <- base::invokeRestart
[09:29:21.024]             length <- base::length
[09:29:21.024]             list <- base::list
[09:29:21.024]             seq.int <- base::seq.int
[09:29:21.024]             signalCondition <- base::signalCondition
[09:29:21.024]             sys.calls <- base::sys.calls
[09:29:21.024]             `[[` <- base::`[[`
[09:29:21.024]             `+` <- base::`+`
[09:29:21.024]             `<<-` <- base::`<<-`
[09:29:21.024]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:21.024]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:21.024]                   3L)]
[09:29:21.024]             }
[09:29:21.024]             function(cond) {
[09:29:21.024]                 is_error <- inherits(cond, "error")
[09:29:21.024]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:21.024]                   NULL)
[09:29:21.024]                 if (is_error) {
[09:29:21.024]                   sessionInformation <- function() {
[09:29:21.024]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:21.024]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:21.024]                       search = base::search(), system = base::Sys.info())
[09:29:21.024]                   }
[09:29:21.024]                   ...future.conditions[[length(...future.conditions) + 
[09:29:21.024]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:21.024]                     cond$call), session = sessionInformation(), 
[09:29:21.024]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:21.024]                   signalCondition(cond)
[09:29:21.024]                 }
[09:29:21.024]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:21.024]                 "immediateCondition"))) {
[09:29:21.024]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:21.024]                   ...future.conditions[[length(...future.conditions) + 
[09:29:21.024]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:21.024]                   if (TRUE && !signal) {
[09:29:21.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.024]                     {
[09:29:21.024]                       inherits <- base::inherits
[09:29:21.024]                       invokeRestart <- base::invokeRestart
[09:29:21.024]                       is.null <- base::is.null
[09:29:21.024]                       muffled <- FALSE
[09:29:21.024]                       if (inherits(cond, "message")) {
[09:29:21.024]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:21.024]                         if (muffled) 
[09:29:21.024]                           invokeRestart("muffleMessage")
[09:29:21.024]                       }
[09:29:21.024]                       else if (inherits(cond, "warning")) {
[09:29:21.024]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:21.024]                         if (muffled) 
[09:29:21.024]                           invokeRestart("muffleWarning")
[09:29:21.024]                       }
[09:29:21.024]                       else if (inherits(cond, "condition")) {
[09:29:21.024]                         if (!is.null(pattern)) {
[09:29:21.024]                           computeRestarts <- base::computeRestarts
[09:29:21.024]                           grepl <- base::grepl
[09:29:21.024]                           restarts <- computeRestarts(cond)
[09:29:21.024]                           for (restart in restarts) {
[09:29:21.024]                             name <- restart$name
[09:29:21.024]                             if (is.null(name)) 
[09:29:21.024]                               next
[09:29:21.024]                             if (!grepl(pattern, name)) 
[09:29:21.024]                               next
[09:29:21.024]                             invokeRestart(restart)
[09:29:21.024]                             muffled <- TRUE
[09:29:21.024]                             break
[09:29:21.024]                           }
[09:29:21.024]                         }
[09:29:21.024]                       }
[09:29:21.024]                       invisible(muffled)
[09:29:21.024]                     }
[09:29:21.024]                     muffleCondition(cond, pattern = "^muffle")
[09:29:21.024]                   }
[09:29:21.024]                 }
[09:29:21.024]                 else {
[09:29:21.024]                   if (TRUE) {
[09:29:21.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.024]                     {
[09:29:21.024]                       inherits <- base::inherits
[09:29:21.024]                       invokeRestart <- base::invokeRestart
[09:29:21.024]                       is.null <- base::is.null
[09:29:21.024]                       muffled <- FALSE
[09:29:21.024]                       if (inherits(cond, "message")) {
[09:29:21.024]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:21.024]                         if (muffled) 
[09:29:21.024]                           invokeRestart("muffleMessage")
[09:29:21.024]                       }
[09:29:21.024]                       else if (inherits(cond, "warning")) {
[09:29:21.024]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:21.024]                         if (muffled) 
[09:29:21.024]                           invokeRestart("muffleWarning")
[09:29:21.024]                       }
[09:29:21.024]                       else if (inherits(cond, "condition")) {
[09:29:21.024]                         if (!is.null(pattern)) {
[09:29:21.024]                           computeRestarts <- base::computeRestarts
[09:29:21.024]                           grepl <- base::grepl
[09:29:21.024]                           restarts <- computeRestarts(cond)
[09:29:21.024]                           for (restart in restarts) {
[09:29:21.024]                             name <- restart$name
[09:29:21.024]                             if (is.null(name)) 
[09:29:21.024]                               next
[09:29:21.024]                             if (!grepl(pattern, name)) 
[09:29:21.024]                               next
[09:29:21.024]                             invokeRestart(restart)
[09:29:21.024]                             muffled <- TRUE
[09:29:21.024]                             break
[09:29:21.024]                           }
[09:29:21.024]                         }
[09:29:21.024]                       }
[09:29:21.024]                       invisible(muffled)
[09:29:21.024]                     }
[09:29:21.024]                     muffleCondition(cond, pattern = "^muffle")
[09:29:21.024]                   }
[09:29:21.024]                 }
[09:29:21.024]             }
[09:29:21.024]         }))
[09:29:21.024]     }, error = function(ex) {
[09:29:21.024]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:21.024]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:21.024]                 ...future.rng), started = ...future.startTime, 
[09:29:21.024]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:21.024]             version = "1.8"), class = "FutureResult")
[09:29:21.024]     }, finally = {
[09:29:21.024]         if (!identical(...future.workdir, getwd())) 
[09:29:21.024]             setwd(...future.workdir)
[09:29:21.024]         {
[09:29:21.024]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:21.024]                 ...future.oldOptions$nwarnings <- NULL
[09:29:21.024]             }
[09:29:21.024]             base::options(...future.oldOptions)
[09:29:21.024]             if (.Platform$OS.type == "windows") {
[09:29:21.024]                 old_names <- names(...future.oldEnvVars)
[09:29:21.024]                 envs <- base::Sys.getenv()
[09:29:21.024]                 names <- names(envs)
[09:29:21.024]                 common <- intersect(names, old_names)
[09:29:21.024]                 added <- setdiff(names, old_names)
[09:29:21.024]                 removed <- setdiff(old_names, names)
[09:29:21.024]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:21.024]                   envs[common]]
[09:29:21.024]                 NAMES <- toupper(changed)
[09:29:21.024]                 args <- list()
[09:29:21.024]                 for (kk in seq_along(NAMES)) {
[09:29:21.024]                   name <- changed[[kk]]
[09:29:21.024]                   NAME <- NAMES[[kk]]
[09:29:21.024]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.024]                     next
[09:29:21.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:21.024]                 }
[09:29:21.024]                 NAMES <- toupper(added)
[09:29:21.024]                 for (kk in seq_along(NAMES)) {
[09:29:21.024]                   name <- added[[kk]]
[09:29:21.024]                   NAME <- NAMES[[kk]]
[09:29:21.024]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.024]                     next
[09:29:21.024]                   args[[name]] <- ""
[09:29:21.024]                 }
[09:29:21.024]                 NAMES <- toupper(removed)
[09:29:21.024]                 for (kk in seq_along(NAMES)) {
[09:29:21.024]                   name <- removed[[kk]]
[09:29:21.024]                   NAME <- NAMES[[kk]]
[09:29:21.024]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.024]                     next
[09:29:21.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:21.024]                 }
[09:29:21.024]                 if (length(args) > 0) 
[09:29:21.024]                   base::do.call(base::Sys.setenv, args = args)
[09:29:21.024]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:21.024]             }
[09:29:21.024]             else {
[09:29:21.024]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:21.024]             }
[09:29:21.024]             {
[09:29:21.024]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:21.024]                   0L) {
[09:29:21.024]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:21.024]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:21.024]                   base::options(opts)
[09:29:21.024]                 }
[09:29:21.024]                 {
[09:29:21.024]                   {
[09:29:21.024]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:21.024]                     NULL
[09:29:21.024]                   }
[09:29:21.024]                   options(future.plan = NULL)
[09:29:21.024]                   if (is.na(NA_character_)) 
[09:29:21.024]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:21.024]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:21.024]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:21.024]                     .init = FALSE)
[09:29:21.024]                 }
[09:29:21.024]             }
[09:29:21.024]         }
[09:29:21.024]     })
[09:29:21.024]     if (TRUE) {
[09:29:21.024]         base::sink(type = "output", split = FALSE)
[09:29:21.024]         if (TRUE) {
[09:29:21.024]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:21.024]         }
[09:29:21.024]         else {
[09:29:21.024]             ...future.result["stdout"] <- base::list(NULL)
[09:29:21.024]         }
[09:29:21.024]         base::close(...future.stdout)
[09:29:21.024]         ...future.stdout <- NULL
[09:29:21.024]     }
[09:29:21.024]     ...future.result$conditions <- ...future.conditions
[09:29:21.024]     ...future.result$finished <- base::Sys.time()
[09:29:21.024]     ...future.result
[09:29:21.024] }
[09:29:21.027] Exporting 5 global objects (2.41 KiB) to cluster node #2 ...
[09:29:21.027] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ...
[09:29:21.028] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ... DONE
[09:29:21.028] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:21.028] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:21.028] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ...
[09:29:21.029] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ... DONE
[09:29:21.029] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:21.029] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:21.029] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:21.029] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:21.030] Exporting 5 global objects (2.41 KiB) to cluster node #2 ... DONE
[09:29:21.030] MultisessionFuture started
[09:29:21.030] - Launch lazy future ... done
[09:29:21.030] run() for ‘MultisessionFuture’ ... done
[09:29:21.030] Created future:
[09:29:21.030] MultisessionFuture:
[09:29:21.030] Label: ‘future_Map-2’
[09:29:21.030] Expression:
[09:29:21.030] {
[09:29:21.030]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:21.030]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:21.030]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:21.030]         on.exit(options(oopts), add = TRUE)
[09:29:21.030]     }
[09:29:21.030]     {
[09:29:21.030]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:21.030]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:21.030]         do.call(mapply, args = args)
[09:29:21.030]     }
[09:29:21.030] }
[09:29:21.030] Lazy evaluation: FALSE
[09:29:21.030] Asynchronous evaluation: TRUE
[09:29:21.030] Local evaluation: TRUE
[09:29:21.030] Environment: R_GlobalEnv
[09:29:21.030] Capture standard output: TRUE
[09:29:21.030] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:21.030] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:21.030] Packages: 1 packages (‘stats’)
[09:29:21.030] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:21.030] Resolved: FALSE
[09:29:21.030] Value: <not collected>
[09:29:21.030] Conditions captured: <none>
[09:29:21.030] Early signaling: FALSE
[09:29:21.030] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:21.030] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:21.042] Chunk #2 of 2 ... DONE
[09:29:21.042] Launching 2 futures (chunks) ... DONE
[09:29:21.042] Resolving 2 futures (chunks) ...
[09:29:21.042] resolve() on list ...
[09:29:21.042]  recursive: 0
[09:29:21.042]  length: 2
[09:29:21.043] 
[09:29:21.043] receiveMessageFromWorker() for ClusterFuture ...
[09:29:21.043] - Validating connection of MultisessionFuture
[09:29:21.043] - received message: FutureResult
[09:29:21.043] - Received FutureResult
[09:29:21.044] - Erased future from FutureRegistry
[09:29:21.044] result() for ClusterFuture ...
[09:29:21.044] - result already collected: FutureResult
[09:29:21.044] result() for ClusterFuture ... done
[09:29:21.044] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:21.044] Future #1
[09:29:21.044] result() for ClusterFuture ...
[09:29:21.044] - result already collected: FutureResult
[09:29:21.044] result() for ClusterFuture ... done
[09:29:21.044] result() for ClusterFuture ...
[09:29:21.044] - result already collected: FutureResult
[09:29:21.045] result() for ClusterFuture ... done
[09:29:21.045] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:21.045] - nx: 2
[09:29:21.045] - relay: TRUE
[09:29:21.045] - stdout: TRUE
[09:29:21.045] - signal: TRUE
[09:29:21.045] - resignal: FALSE
[09:29:21.045] - force: TRUE
[09:29:21.045] - relayed: [n=2] FALSE, FALSE
[09:29:21.045] - queued futures: [n=2] FALSE, FALSE
[09:29:21.045]  - until=1
[09:29:21.046]  - relaying element #1
[09:29:21.046] result() for ClusterFuture ...
[09:29:21.046] - result already collected: FutureResult
[09:29:21.046] result() for ClusterFuture ... done
[09:29:21.046] result() for ClusterFuture ...
[09:29:21.046] - result already collected: FutureResult
[09:29:21.046] result() for ClusterFuture ... done
[09:29:21.046] result() for ClusterFuture ...
[09:29:21.046] - result already collected: FutureResult
[09:29:21.046] result() for ClusterFuture ... done
[09:29:21.046] result() for ClusterFuture ...
[09:29:21.046] - result already collected: FutureResult
[09:29:21.047] result() for ClusterFuture ... done
[09:29:21.047] - relayed: [n=2] TRUE, FALSE
[09:29:21.047] - queued futures: [n=2] TRUE, FALSE
[09:29:21.047] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:21.047]  length: 1 (resolved future 1)
[09:29:21.073] receiveMessageFromWorker() for ClusterFuture ...
[09:29:21.074] - Validating connection of MultisessionFuture
[09:29:21.074] - received message: FutureResult
[09:29:21.074] - Received FutureResult
[09:29:21.074] - Erased future from FutureRegistry
[09:29:21.074] result() for ClusterFuture ...
[09:29:21.074] - result already collected: FutureResult
[09:29:21.074] result() for ClusterFuture ... done
[09:29:21.074] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:21.075] Future #2
[09:29:21.075] result() for ClusterFuture ...
[09:29:21.075] - result already collected: FutureResult
[09:29:21.075] result() for ClusterFuture ... done
[09:29:21.075] result() for ClusterFuture ...
[09:29:21.075] - result already collected: FutureResult
[09:29:21.075] result() for ClusterFuture ... done
[09:29:21.075] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:21.075] - nx: 2
[09:29:21.075] - relay: TRUE
[09:29:21.075] - stdout: TRUE
[09:29:21.075] - signal: TRUE
[09:29:21.076] - resignal: FALSE
[09:29:21.076] - force: TRUE
[09:29:21.076] - relayed: [n=2] TRUE, FALSE
[09:29:21.076] - queued futures: [n=2] TRUE, FALSE
[09:29:21.076]  - until=2
[09:29:21.076]  - relaying element #2
[09:29:21.076] result() for ClusterFuture ...
[09:29:21.076] - result already collected: FutureResult
[09:29:21.076] result() for ClusterFuture ... done
[09:29:21.076] result() for ClusterFuture ...
[09:29:21.076] - result already collected: FutureResult
[09:29:21.077] result() for ClusterFuture ... done
[09:29:21.077] result() for ClusterFuture ...
[09:29:21.077] - result already collected: FutureResult
[09:29:21.077] result() for ClusterFuture ... done
[09:29:21.077] result() for ClusterFuture ...
[09:29:21.077] - result already collected: FutureResult
[09:29:21.077] result() for ClusterFuture ... done
[09:29:21.077] - relayed: [n=2] TRUE, TRUE
[09:29:21.077] - queued futures: [n=2] TRUE, TRUE
[09:29:21.077] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:21.077]  length: 0 (resolved future 2)
[09:29:21.078] Relaying remaining futures
[09:29:21.078] signalConditionsASAP(NULL, pos=0) ...
[09:29:21.078] - nx: 2
[09:29:21.078] - relay: TRUE
[09:29:21.078] - stdout: TRUE
[09:29:21.078] - signal: TRUE
[09:29:21.078] - resignal: FALSE
[09:29:21.078] - force: TRUE
[09:29:21.078] - relayed: [n=2] TRUE, TRUE
[09:29:21.078] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:21.078] - relayed: [n=2] TRUE, TRUE
[09:29:21.078] - queued futures: [n=2] TRUE, TRUE
[09:29:21.079] signalConditionsASAP(NULL, pos=0) ... done
[09:29:21.079] resolve() on list ... DONE
[09:29:21.079] result() for ClusterFuture ...
[09:29:21.082] - result already collected: FutureResult
[09:29:21.082] result() for ClusterFuture ... done
[09:29:21.082] result() for ClusterFuture ...
[09:29:21.082] - result already collected: FutureResult
[09:29:21.082] result() for ClusterFuture ... done
[09:29:21.082] result() for ClusterFuture ...
[09:29:21.082] - result already collected: FutureResult
[09:29:21.082] result() for ClusterFuture ... done
[09:29:21.082] result() for ClusterFuture ...
[09:29:21.083] - result already collected: FutureResult
[09:29:21.083] result() for ClusterFuture ... done
[09:29:21.083]  - Number of value chunks collected: 2
[09:29:21.083] Resolving 2 futures (chunks) ... DONE
[09:29:21.083] Reducing values from 2 chunks ...
[09:29:21.083]  - Number of values collected after concatenation: 5
[09:29:21.083]  - Number of values expected: 5
[09:29:21.083] Reducing values from 2 chunks ... DONE
[09:29:21.083] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[09:29:21.085] future_mapply() ...
[09:29:21.088] Number of chunks: 2
[09:29:21.089] getGlobalsAndPackagesXApply() ...
[09:29:21.089]  - future.globals: TRUE
[09:29:21.089] getGlobalsAndPackages() ...
[09:29:21.089] Searching for globals...
[09:29:21.090] - globals found: [1] ‘FUN’
[09:29:21.090] Searching for globals ... DONE
[09:29:21.090] Resolving globals: FALSE
[09:29:21.090] The total size of the 1 globals is 56 bytes (56 bytes)
[09:29:21.090] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[09:29:21.090] - globals: [1] ‘FUN’
[09:29:21.091] 
[09:29:21.091] getGlobalsAndPackages() ... DONE
[09:29:21.091]  - globals found/used: [n=1] ‘FUN’
[09:29:21.091]  - needed namespaces: [n=0] 
[09:29:21.091] Finding globals ... DONE
[09:29:21.091] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:21.091] List of 2
[09:29:21.091]  $ ...future.FUN:function (e1, e2)  
[09:29:21.091]  $ MoreArgs     : NULL
[09:29:21.091]  - attr(*, "where")=List of 2
[09:29:21.091]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:21.091]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:21.091]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:21.091]  - attr(*, "resolved")= logi FALSE
[09:29:21.091]  - attr(*, "total_size")= num NA
[09:29:21.094] Packages to be attached in all futures: [n=0] 
[09:29:21.094] getGlobalsAndPackagesXApply() ... DONE
[09:29:21.094] Number of futures (= number of chunks): 2
[09:29:21.094] Launching 2 futures (chunks) ...
[09:29:21.094] Chunk #1 of 2 ...
[09:29:21.094]  - Finding globals in '...' for chunk #1 ...
[09:29:21.094] getGlobalsAndPackages() ...
[09:29:21.094] Searching for globals...
[09:29:21.095] 
[09:29:21.095] Searching for globals ... DONE
[09:29:21.095] - globals: [0] <none>
[09:29:21.095] getGlobalsAndPackages() ... DONE
[09:29:21.095]    + additional globals found: [n=0] 
[09:29:21.095]    + additional namespaces needed: [n=0] 
[09:29:21.095]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:21.095]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:21.095]  - seeds: <none>
[09:29:21.095]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.096] getGlobalsAndPackages() ...
[09:29:21.096] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.096] Resolving globals: FALSE
[09:29:21.096] The total size of the 5 globals is 168 bytes (168 bytes)
[09:29:21.097] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:21.097] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.097] 
[09:29:21.097] getGlobalsAndPackages() ... DONE
[09:29:21.097] run() for ‘Future’ ...
[09:29:21.097] - state: ‘created’
[09:29:21.098] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:21.111] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:21.111] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:21.112]   - Field: ‘node’
[09:29:21.112]   - Field: ‘label’
[09:29:21.112]   - Field: ‘local’
[09:29:21.112]   - Field: ‘owner’
[09:29:21.112]   - Field: ‘envir’
[09:29:21.112]   - Field: ‘workers’
[09:29:21.112]   - Field: ‘packages’
[09:29:21.112]   - Field: ‘gc’
[09:29:21.112]   - Field: ‘conditions’
[09:29:21.113]   - Field: ‘persistent’
[09:29:21.113]   - Field: ‘expr’
[09:29:21.113]   - Field: ‘uuid’
[09:29:21.113]   - Field: ‘seed’
[09:29:21.113]   - Field: ‘version’
[09:29:21.113]   - Field: ‘result’
[09:29:21.113]   - Field: ‘asynchronous’
[09:29:21.113]   - Field: ‘calls’
[09:29:21.113]   - Field: ‘globals’
[09:29:21.113]   - Field: ‘stdout’
[09:29:21.113]   - Field: ‘earlySignal’
[09:29:21.114]   - Field: ‘lazy’
[09:29:21.114]   - Field: ‘state’
[09:29:21.114] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:21.114] - Launch lazy future ...
[09:29:21.114] Packages needed by the future expression (n = 0): <none>
[09:29:21.114] Packages needed by future strategies (n = 0): <none>
[09:29:21.115] {
[09:29:21.115]     {
[09:29:21.115]         {
[09:29:21.115]             ...future.startTime <- base::Sys.time()
[09:29:21.115]             {
[09:29:21.115]                 {
[09:29:21.115]                   {
[09:29:21.115]                     {
[09:29:21.115]                       base::local({
[09:29:21.115]                         has_future <- base::requireNamespace("future", 
[09:29:21.115]                           quietly = TRUE)
[09:29:21.115]                         if (has_future) {
[09:29:21.115]                           ns <- base::getNamespace("future")
[09:29:21.115]                           version <- ns[[".package"]][["version"]]
[09:29:21.115]                           if (is.null(version)) 
[09:29:21.115]                             version <- utils::packageVersion("future")
[09:29:21.115]                         }
[09:29:21.115]                         else {
[09:29:21.115]                           version <- NULL
[09:29:21.115]                         }
[09:29:21.115]                         if (!has_future || version < "1.8.0") {
[09:29:21.115]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:21.115]                             "", base::R.version$version.string), 
[09:29:21.115]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:21.115]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:21.115]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:21.115]                               "release", "version")], collapse = " "), 
[09:29:21.115]                             hostname = base::Sys.info()[["nodename"]])
[09:29:21.115]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:21.115]                             info)
[09:29:21.115]                           info <- base::paste(info, collapse = "; ")
[09:29:21.115]                           if (!has_future) {
[09:29:21.115]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:21.115]                               info)
[09:29:21.115]                           }
[09:29:21.115]                           else {
[09:29:21.115]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:21.115]                               info, version)
[09:29:21.115]                           }
[09:29:21.115]                           base::stop(msg)
[09:29:21.115]                         }
[09:29:21.115]                       })
[09:29:21.115]                     }
[09:29:21.115]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:21.115]                     base::options(mc.cores = 1L)
[09:29:21.115]                   }
[09:29:21.115]                   ...future.strategy.old <- future::plan("list")
[09:29:21.115]                   options(future.plan = NULL)
[09:29:21.115]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:21.115]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:21.115]                 }
[09:29:21.115]                 ...future.workdir <- getwd()
[09:29:21.115]             }
[09:29:21.115]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:21.115]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:21.115]         }
[09:29:21.115]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:21.115]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:21.115]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:21.115]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:21.115]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:21.115]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:21.115]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:21.115]             base::names(...future.oldOptions))
[09:29:21.115]     }
[09:29:21.115]     if (FALSE) {
[09:29:21.115]     }
[09:29:21.115]     else {
[09:29:21.115]         if (TRUE) {
[09:29:21.115]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:21.115]                 open = "w")
[09:29:21.115]         }
[09:29:21.115]         else {
[09:29:21.115]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:21.115]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:21.115]         }
[09:29:21.115]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:21.115]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:21.115]             base::sink(type = "output", split = FALSE)
[09:29:21.115]             base::close(...future.stdout)
[09:29:21.115]         }, add = TRUE)
[09:29:21.115]     }
[09:29:21.115]     ...future.frame <- base::sys.nframe()
[09:29:21.115]     ...future.conditions <- base::list()
[09:29:21.115]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:21.115]     if (FALSE) {
[09:29:21.115]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:21.115]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:21.115]     }
[09:29:21.115]     ...future.result <- base::tryCatch({
[09:29:21.115]         base::withCallingHandlers({
[09:29:21.115]             ...future.value <- base::withVisible(base::local({
[09:29:21.115]                 ...future.makeSendCondition <- base::local({
[09:29:21.115]                   sendCondition <- NULL
[09:29:21.115]                   function(frame = 1L) {
[09:29:21.115]                     if (is.function(sendCondition)) 
[09:29:21.115]                       return(sendCondition)
[09:29:21.115]                     ns <- getNamespace("parallel")
[09:29:21.115]                     if (exists("sendData", mode = "function", 
[09:29:21.115]                       envir = ns)) {
[09:29:21.115]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:21.115]                         envir = ns)
[09:29:21.115]                       envir <- sys.frame(frame)
[09:29:21.115]                       master <- NULL
[09:29:21.115]                       while (!identical(envir, .GlobalEnv) && 
[09:29:21.115]                         !identical(envir, emptyenv())) {
[09:29:21.115]                         if (exists("master", mode = "list", envir = envir, 
[09:29:21.115]                           inherits = FALSE)) {
[09:29:21.115]                           master <- get("master", mode = "list", 
[09:29:21.115]                             envir = envir, inherits = FALSE)
[09:29:21.115]                           if (inherits(master, c("SOCKnode", 
[09:29:21.115]                             "SOCK0node"))) {
[09:29:21.115]                             sendCondition <<- function(cond) {
[09:29:21.115]                               data <- list(type = "VALUE", value = cond, 
[09:29:21.115]                                 success = TRUE)
[09:29:21.115]                               parallel_sendData(master, data)
[09:29:21.115]                             }
[09:29:21.115]                             return(sendCondition)
[09:29:21.115]                           }
[09:29:21.115]                         }
[09:29:21.115]                         frame <- frame + 1L
[09:29:21.115]                         envir <- sys.frame(frame)
[09:29:21.115]                       }
[09:29:21.115]                     }
[09:29:21.115]                     sendCondition <<- function(cond) NULL
[09:29:21.115]                   }
[09:29:21.115]                 })
[09:29:21.115]                 withCallingHandlers({
[09:29:21.115]                   {
[09:29:21.115]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:21.115]                     if (!identical(...future.globals.maxSize.org, 
[09:29:21.115]                       ...future.globals.maxSize)) {
[09:29:21.115]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:21.115]                       on.exit(options(oopts), add = TRUE)
[09:29:21.115]                     }
[09:29:21.115]                     {
[09:29:21.115]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:21.115]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:21.115]                         USE.NAMES = FALSE)
[09:29:21.115]                       do.call(mapply, args = args)
[09:29:21.115]                     }
[09:29:21.115]                   }
[09:29:21.115]                 }, immediateCondition = function(cond) {
[09:29:21.115]                   sendCondition <- ...future.makeSendCondition()
[09:29:21.115]                   sendCondition(cond)
[09:29:21.115]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.115]                   {
[09:29:21.115]                     inherits <- base::inherits
[09:29:21.115]                     invokeRestart <- base::invokeRestart
[09:29:21.115]                     is.null <- base::is.null
[09:29:21.115]                     muffled <- FALSE
[09:29:21.115]                     if (inherits(cond, "message")) {
[09:29:21.115]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:21.115]                       if (muffled) 
[09:29:21.115]                         invokeRestart("muffleMessage")
[09:29:21.115]                     }
[09:29:21.115]                     else if (inherits(cond, "warning")) {
[09:29:21.115]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:21.115]                       if (muffled) 
[09:29:21.115]                         invokeRestart("muffleWarning")
[09:29:21.115]                     }
[09:29:21.115]                     else if (inherits(cond, "condition")) {
[09:29:21.115]                       if (!is.null(pattern)) {
[09:29:21.115]                         computeRestarts <- base::computeRestarts
[09:29:21.115]                         grepl <- base::grepl
[09:29:21.115]                         restarts <- computeRestarts(cond)
[09:29:21.115]                         for (restart in restarts) {
[09:29:21.115]                           name <- restart$name
[09:29:21.115]                           if (is.null(name)) 
[09:29:21.115]                             next
[09:29:21.115]                           if (!grepl(pattern, name)) 
[09:29:21.115]                             next
[09:29:21.115]                           invokeRestart(restart)
[09:29:21.115]                           muffled <- TRUE
[09:29:21.115]                           break
[09:29:21.115]                         }
[09:29:21.115]                       }
[09:29:21.115]                     }
[09:29:21.115]                     invisible(muffled)
[09:29:21.115]                   }
[09:29:21.115]                   muffleCondition(cond)
[09:29:21.115]                 })
[09:29:21.115]             }))
[09:29:21.115]             future::FutureResult(value = ...future.value$value, 
[09:29:21.115]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:21.115]                   ...future.rng), globalenv = if (FALSE) 
[09:29:21.115]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:21.115]                     ...future.globalenv.names))
[09:29:21.115]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:21.115]         }, condition = base::local({
[09:29:21.115]             c <- base::c
[09:29:21.115]             inherits <- base::inherits
[09:29:21.115]             invokeRestart <- base::invokeRestart
[09:29:21.115]             length <- base::length
[09:29:21.115]             list <- base::list
[09:29:21.115]             seq.int <- base::seq.int
[09:29:21.115]             signalCondition <- base::signalCondition
[09:29:21.115]             sys.calls <- base::sys.calls
[09:29:21.115]             `[[` <- base::`[[`
[09:29:21.115]             `+` <- base::`+`
[09:29:21.115]             `<<-` <- base::`<<-`
[09:29:21.115]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:21.115]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:21.115]                   3L)]
[09:29:21.115]             }
[09:29:21.115]             function(cond) {
[09:29:21.115]                 is_error <- inherits(cond, "error")
[09:29:21.115]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:21.115]                   NULL)
[09:29:21.115]                 if (is_error) {
[09:29:21.115]                   sessionInformation <- function() {
[09:29:21.115]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:21.115]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:21.115]                       search = base::search(), system = base::Sys.info())
[09:29:21.115]                   }
[09:29:21.115]                   ...future.conditions[[length(...future.conditions) + 
[09:29:21.115]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:21.115]                     cond$call), session = sessionInformation(), 
[09:29:21.115]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:21.115]                   signalCondition(cond)
[09:29:21.115]                 }
[09:29:21.115]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:21.115]                 "immediateCondition"))) {
[09:29:21.115]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:21.115]                   ...future.conditions[[length(...future.conditions) + 
[09:29:21.115]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:21.115]                   if (TRUE && !signal) {
[09:29:21.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.115]                     {
[09:29:21.115]                       inherits <- base::inherits
[09:29:21.115]                       invokeRestart <- base::invokeRestart
[09:29:21.115]                       is.null <- base::is.null
[09:29:21.115]                       muffled <- FALSE
[09:29:21.115]                       if (inherits(cond, "message")) {
[09:29:21.115]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:21.115]                         if (muffled) 
[09:29:21.115]                           invokeRestart("muffleMessage")
[09:29:21.115]                       }
[09:29:21.115]                       else if (inherits(cond, "warning")) {
[09:29:21.115]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:21.115]                         if (muffled) 
[09:29:21.115]                           invokeRestart("muffleWarning")
[09:29:21.115]                       }
[09:29:21.115]                       else if (inherits(cond, "condition")) {
[09:29:21.115]                         if (!is.null(pattern)) {
[09:29:21.115]                           computeRestarts <- base::computeRestarts
[09:29:21.115]                           grepl <- base::grepl
[09:29:21.115]                           restarts <- computeRestarts(cond)
[09:29:21.115]                           for (restart in restarts) {
[09:29:21.115]                             name <- restart$name
[09:29:21.115]                             if (is.null(name)) 
[09:29:21.115]                               next
[09:29:21.115]                             if (!grepl(pattern, name)) 
[09:29:21.115]                               next
[09:29:21.115]                             invokeRestart(restart)
[09:29:21.115]                             muffled <- TRUE
[09:29:21.115]                             break
[09:29:21.115]                           }
[09:29:21.115]                         }
[09:29:21.115]                       }
[09:29:21.115]                       invisible(muffled)
[09:29:21.115]                     }
[09:29:21.115]                     muffleCondition(cond, pattern = "^muffle")
[09:29:21.115]                   }
[09:29:21.115]                 }
[09:29:21.115]                 else {
[09:29:21.115]                   if (TRUE) {
[09:29:21.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.115]                     {
[09:29:21.115]                       inherits <- base::inherits
[09:29:21.115]                       invokeRestart <- base::invokeRestart
[09:29:21.115]                       is.null <- base::is.null
[09:29:21.115]                       muffled <- FALSE
[09:29:21.115]                       if (inherits(cond, "message")) {
[09:29:21.115]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:21.115]                         if (muffled) 
[09:29:21.115]                           invokeRestart("muffleMessage")
[09:29:21.115]                       }
[09:29:21.115]                       else if (inherits(cond, "warning")) {
[09:29:21.115]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:21.115]                         if (muffled) 
[09:29:21.115]                           invokeRestart("muffleWarning")
[09:29:21.115]                       }
[09:29:21.115]                       else if (inherits(cond, "condition")) {
[09:29:21.115]                         if (!is.null(pattern)) {
[09:29:21.115]                           computeRestarts <- base::computeRestarts
[09:29:21.115]                           grepl <- base::grepl
[09:29:21.115]                           restarts <- computeRestarts(cond)
[09:29:21.115]                           for (restart in restarts) {
[09:29:21.115]                             name <- restart$name
[09:29:21.115]                             if (is.null(name)) 
[09:29:21.115]                               next
[09:29:21.115]                             if (!grepl(pattern, name)) 
[09:29:21.115]                               next
[09:29:21.115]                             invokeRestart(restart)
[09:29:21.115]                             muffled <- TRUE
[09:29:21.115]                             break
[09:29:21.115]                           }
[09:29:21.115]                         }
[09:29:21.115]                       }
[09:29:21.115]                       invisible(muffled)
[09:29:21.115]                     }
[09:29:21.115]                     muffleCondition(cond, pattern = "^muffle")
[09:29:21.115]                   }
[09:29:21.115]                 }
[09:29:21.115]             }
[09:29:21.115]         }))
[09:29:21.115]     }, error = function(ex) {
[09:29:21.115]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:21.115]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:21.115]                 ...future.rng), started = ...future.startTime, 
[09:29:21.115]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:21.115]             version = "1.8"), class = "FutureResult")
[09:29:21.115]     }, finally = {
[09:29:21.115]         if (!identical(...future.workdir, getwd())) 
[09:29:21.115]             setwd(...future.workdir)
[09:29:21.115]         {
[09:29:21.115]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:21.115]                 ...future.oldOptions$nwarnings <- NULL
[09:29:21.115]             }
[09:29:21.115]             base::options(...future.oldOptions)
[09:29:21.115]             if (.Platform$OS.type == "windows") {
[09:29:21.115]                 old_names <- names(...future.oldEnvVars)
[09:29:21.115]                 envs <- base::Sys.getenv()
[09:29:21.115]                 names <- names(envs)
[09:29:21.115]                 common <- intersect(names, old_names)
[09:29:21.115]                 added <- setdiff(names, old_names)
[09:29:21.115]                 removed <- setdiff(old_names, names)
[09:29:21.115]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:21.115]                   envs[common]]
[09:29:21.115]                 NAMES <- toupper(changed)
[09:29:21.115]                 args <- list()
[09:29:21.115]                 for (kk in seq_along(NAMES)) {
[09:29:21.115]                   name <- changed[[kk]]
[09:29:21.115]                   NAME <- NAMES[[kk]]
[09:29:21.115]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.115]                     next
[09:29:21.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:21.115]                 }
[09:29:21.115]                 NAMES <- toupper(added)
[09:29:21.115]                 for (kk in seq_along(NAMES)) {
[09:29:21.115]                   name <- added[[kk]]
[09:29:21.115]                   NAME <- NAMES[[kk]]
[09:29:21.115]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.115]                     next
[09:29:21.115]                   args[[name]] <- ""
[09:29:21.115]                 }
[09:29:21.115]                 NAMES <- toupper(removed)
[09:29:21.115]                 for (kk in seq_along(NAMES)) {
[09:29:21.115]                   name <- removed[[kk]]
[09:29:21.115]                   NAME <- NAMES[[kk]]
[09:29:21.115]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.115]                     next
[09:29:21.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:21.115]                 }
[09:29:21.115]                 if (length(args) > 0) 
[09:29:21.115]                   base::do.call(base::Sys.setenv, args = args)
[09:29:21.115]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:21.115]             }
[09:29:21.115]             else {
[09:29:21.115]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:21.115]             }
[09:29:21.115]             {
[09:29:21.115]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:21.115]                   0L) {
[09:29:21.115]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:21.115]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:21.115]                   base::options(opts)
[09:29:21.115]                 }
[09:29:21.115]                 {
[09:29:21.115]                   {
[09:29:21.115]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:21.115]                     NULL
[09:29:21.115]                   }
[09:29:21.115]                   options(future.plan = NULL)
[09:29:21.115]                   if (is.na(NA_character_)) 
[09:29:21.115]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:21.115]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:21.115]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:21.115]                     .init = FALSE)
[09:29:21.115]                 }
[09:29:21.115]             }
[09:29:21.115]         }
[09:29:21.115]     })
[09:29:21.115]     if (TRUE) {
[09:29:21.115]         base::sink(type = "output", split = FALSE)
[09:29:21.115]         if (TRUE) {
[09:29:21.115]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:21.115]         }
[09:29:21.115]         else {
[09:29:21.115]             ...future.result["stdout"] <- base::list(NULL)
[09:29:21.115]         }
[09:29:21.115]         base::close(...future.stdout)
[09:29:21.115]         ...future.stdout <- NULL
[09:29:21.115]     }
[09:29:21.115]     ...future.result$conditions <- ...future.conditions
[09:29:21.115]     ...future.result$finished <- base::Sys.time()
[09:29:21.115]     ...future.result
[09:29:21.115] }
[09:29:21.117] Exporting 5 global objects (168 bytes) to cluster node #1 ...
[09:29:21.117] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[09:29:21.118] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[09:29:21.118] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:21.118] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:21.118] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[09:29:21.119] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[09:29:21.119] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:21.119] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:21.119] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:21.119] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:21.120] Exporting 5 global objects (168 bytes) to cluster node #1 ... DONE
[09:29:21.120] MultisessionFuture started
[09:29:21.120] - Launch lazy future ... done
[09:29:21.120] run() for ‘MultisessionFuture’ ... done
[09:29:21.120] Created future:
[09:29:21.120] MultisessionFuture:
[09:29:21.120] Label: ‘future_Map-1’
[09:29:21.120] Expression:
[09:29:21.120] {
[09:29:21.120]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:21.120]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:21.120]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:21.120]         on.exit(options(oopts), add = TRUE)
[09:29:21.120]     }
[09:29:21.120]     {
[09:29:21.120]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:21.120]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:21.120]         do.call(mapply, args = args)
[09:29:21.120]     }
[09:29:21.120] }
[09:29:21.120] Lazy evaluation: FALSE
[09:29:21.120] Asynchronous evaluation: TRUE
[09:29:21.120] Local evaluation: TRUE
[09:29:21.120] Environment: R_GlobalEnv
[09:29:21.120] Capture standard output: TRUE
[09:29:21.120] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:21.120] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:21.120] Packages: <none>
[09:29:21.120] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:21.120] Resolved: FALSE
[09:29:21.120] Value: <not collected>
[09:29:21.120] Conditions captured: <none>
[09:29:21.120] Early signaling: FALSE
[09:29:21.120] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:21.120] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:21.132] Chunk #1 of 2 ... DONE
[09:29:21.132] Chunk #2 of 2 ...
[09:29:21.132]  - Finding globals in '...' for chunk #2 ...
[09:29:21.132] getGlobalsAndPackages() ...
[09:29:21.132] Searching for globals...
[09:29:21.133] 
[09:29:21.133] Searching for globals ... DONE
[09:29:21.133] - globals: [0] <none>
[09:29:21.133] getGlobalsAndPackages() ... DONE
[09:29:21.133]    + additional globals found: [n=0] 
[09:29:21.133]    + additional namespaces needed: [n=0] 
[09:29:21.133]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:21.133]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:21.134]  - seeds: <none>
[09:29:21.134]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.134] getGlobalsAndPackages() ...
[09:29:21.134] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.134] Resolving globals: FALSE
[09:29:21.134] The total size of the 5 globals is 280 bytes (280 bytes)
[09:29:21.135] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:21.135] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.135] 
[09:29:21.135] getGlobalsAndPackages() ... DONE
[09:29:21.135] run() for ‘Future’ ...
[09:29:21.135] - state: ‘created’
[09:29:21.136] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:21.150] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:21.150] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:21.150]   - Field: ‘node’
[09:29:21.150]   - Field: ‘label’
[09:29:21.150]   - Field: ‘local’
[09:29:21.150]   - Field: ‘owner’
[09:29:21.150]   - Field: ‘envir’
[09:29:21.150]   - Field: ‘workers’
[09:29:21.150]   - Field: ‘packages’
[09:29:21.151]   - Field: ‘gc’
[09:29:21.151]   - Field: ‘conditions’
[09:29:21.151]   - Field: ‘persistent’
[09:29:21.151]   - Field: ‘expr’
[09:29:21.151]   - Field: ‘uuid’
[09:29:21.151]   - Field: ‘seed’
[09:29:21.151]   - Field: ‘version’
[09:29:21.151]   - Field: ‘result’
[09:29:21.151]   - Field: ‘asynchronous’
[09:29:21.151]   - Field: ‘calls’
[09:29:21.151]   - Field: ‘globals’
[09:29:21.152]   - Field: ‘stdout’
[09:29:21.152]   - Field: ‘earlySignal’
[09:29:21.152]   - Field: ‘lazy’
[09:29:21.152]   - Field: ‘state’
[09:29:21.152] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:21.152] - Launch lazy future ...
[09:29:21.152] Packages needed by the future expression (n = 0): <none>
[09:29:21.152] Packages needed by future strategies (n = 0): <none>
[09:29:21.153] {
[09:29:21.153]     {
[09:29:21.153]         {
[09:29:21.153]             ...future.startTime <- base::Sys.time()
[09:29:21.153]             {
[09:29:21.153]                 {
[09:29:21.153]                   {
[09:29:21.153]                     {
[09:29:21.153]                       base::local({
[09:29:21.153]                         has_future <- base::requireNamespace("future", 
[09:29:21.153]                           quietly = TRUE)
[09:29:21.153]                         if (has_future) {
[09:29:21.153]                           ns <- base::getNamespace("future")
[09:29:21.153]                           version <- ns[[".package"]][["version"]]
[09:29:21.153]                           if (is.null(version)) 
[09:29:21.153]                             version <- utils::packageVersion("future")
[09:29:21.153]                         }
[09:29:21.153]                         else {
[09:29:21.153]                           version <- NULL
[09:29:21.153]                         }
[09:29:21.153]                         if (!has_future || version < "1.8.0") {
[09:29:21.153]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:21.153]                             "", base::R.version$version.string), 
[09:29:21.153]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:21.153]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:21.153]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:21.153]                               "release", "version")], collapse = " "), 
[09:29:21.153]                             hostname = base::Sys.info()[["nodename"]])
[09:29:21.153]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:21.153]                             info)
[09:29:21.153]                           info <- base::paste(info, collapse = "; ")
[09:29:21.153]                           if (!has_future) {
[09:29:21.153]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:21.153]                               info)
[09:29:21.153]                           }
[09:29:21.153]                           else {
[09:29:21.153]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:21.153]                               info, version)
[09:29:21.153]                           }
[09:29:21.153]                           base::stop(msg)
[09:29:21.153]                         }
[09:29:21.153]                       })
[09:29:21.153]                     }
[09:29:21.153]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:21.153]                     base::options(mc.cores = 1L)
[09:29:21.153]                   }
[09:29:21.153]                   ...future.strategy.old <- future::plan("list")
[09:29:21.153]                   options(future.plan = NULL)
[09:29:21.153]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:21.153]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:21.153]                 }
[09:29:21.153]                 ...future.workdir <- getwd()
[09:29:21.153]             }
[09:29:21.153]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:21.153]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:21.153]         }
[09:29:21.153]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:21.153]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:21.153]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:21.153]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:21.153]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:21.153]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:21.153]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:21.153]             base::names(...future.oldOptions))
[09:29:21.153]     }
[09:29:21.153]     if (FALSE) {
[09:29:21.153]     }
[09:29:21.153]     else {
[09:29:21.153]         if (TRUE) {
[09:29:21.153]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:21.153]                 open = "w")
[09:29:21.153]         }
[09:29:21.153]         else {
[09:29:21.153]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:21.153]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:21.153]         }
[09:29:21.153]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:21.153]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:21.153]             base::sink(type = "output", split = FALSE)
[09:29:21.153]             base::close(...future.stdout)
[09:29:21.153]         }, add = TRUE)
[09:29:21.153]     }
[09:29:21.153]     ...future.frame <- base::sys.nframe()
[09:29:21.153]     ...future.conditions <- base::list()
[09:29:21.153]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:21.153]     if (FALSE) {
[09:29:21.153]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:21.153]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:21.153]     }
[09:29:21.153]     ...future.result <- base::tryCatch({
[09:29:21.153]         base::withCallingHandlers({
[09:29:21.153]             ...future.value <- base::withVisible(base::local({
[09:29:21.153]                 ...future.makeSendCondition <- base::local({
[09:29:21.153]                   sendCondition <- NULL
[09:29:21.153]                   function(frame = 1L) {
[09:29:21.153]                     if (is.function(sendCondition)) 
[09:29:21.153]                       return(sendCondition)
[09:29:21.153]                     ns <- getNamespace("parallel")
[09:29:21.153]                     if (exists("sendData", mode = "function", 
[09:29:21.153]                       envir = ns)) {
[09:29:21.153]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:21.153]                         envir = ns)
[09:29:21.153]                       envir <- sys.frame(frame)
[09:29:21.153]                       master <- NULL
[09:29:21.153]                       while (!identical(envir, .GlobalEnv) && 
[09:29:21.153]                         !identical(envir, emptyenv())) {
[09:29:21.153]                         if (exists("master", mode = "list", envir = envir, 
[09:29:21.153]                           inherits = FALSE)) {
[09:29:21.153]                           master <- get("master", mode = "list", 
[09:29:21.153]                             envir = envir, inherits = FALSE)
[09:29:21.153]                           if (inherits(master, c("SOCKnode", 
[09:29:21.153]                             "SOCK0node"))) {
[09:29:21.153]                             sendCondition <<- function(cond) {
[09:29:21.153]                               data <- list(type = "VALUE", value = cond, 
[09:29:21.153]                                 success = TRUE)
[09:29:21.153]                               parallel_sendData(master, data)
[09:29:21.153]                             }
[09:29:21.153]                             return(sendCondition)
[09:29:21.153]                           }
[09:29:21.153]                         }
[09:29:21.153]                         frame <- frame + 1L
[09:29:21.153]                         envir <- sys.frame(frame)
[09:29:21.153]                       }
[09:29:21.153]                     }
[09:29:21.153]                     sendCondition <<- function(cond) NULL
[09:29:21.153]                   }
[09:29:21.153]                 })
[09:29:21.153]                 withCallingHandlers({
[09:29:21.153]                   {
[09:29:21.153]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:21.153]                     if (!identical(...future.globals.maxSize.org, 
[09:29:21.153]                       ...future.globals.maxSize)) {
[09:29:21.153]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:21.153]                       on.exit(options(oopts), add = TRUE)
[09:29:21.153]                     }
[09:29:21.153]                     {
[09:29:21.153]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:21.153]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:21.153]                         USE.NAMES = FALSE)
[09:29:21.153]                       do.call(mapply, args = args)
[09:29:21.153]                     }
[09:29:21.153]                   }
[09:29:21.153]                 }, immediateCondition = function(cond) {
[09:29:21.153]                   sendCondition <- ...future.makeSendCondition()
[09:29:21.153]                   sendCondition(cond)
[09:29:21.153]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.153]                   {
[09:29:21.153]                     inherits <- base::inherits
[09:29:21.153]                     invokeRestart <- base::invokeRestart
[09:29:21.153]                     is.null <- base::is.null
[09:29:21.153]                     muffled <- FALSE
[09:29:21.153]                     if (inherits(cond, "message")) {
[09:29:21.153]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:21.153]                       if (muffled) 
[09:29:21.153]                         invokeRestart("muffleMessage")
[09:29:21.153]                     }
[09:29:21.153]                     else if (inherits(cond, "warning")) {
[09:29:21.153]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:21.153]                       if (muffled) 
[09:29:21.153]                         invokeRestart("muffleWarning")
[09:29:21.153]                     }
[09:29:21.153]                     else if (inherits(cond, "condition")) {
[09:29:21.153]                       if (!is.null(pattern)) {
[09:29:21.153]                         computeRestarts <- base::computeRestarts
[09:29:21.153]                         grepl <- base::grepl
[09:29:21.153]                         restarts <- computeRestarts(cond)
[09:29:21.153]                         for (restart in restarts) {
[09:29:21.153]                           name <- restart$name
[09:29:21.153]                           if (is.null(name)) 
[09:29:21.153]                             next
[09:29:21.153]                           if (!grepl(pattern, name)) 
[09:29:21.153]                             next
[09:29:21.153]                           invokeRestart(restart)
[09:29:21.153]                           muffled <- TRUE
[09:29:21.153]                           break
[09:29:21.153]                         }
[09:29:21.153]                       }
[09:29:21.153]                     }
[09:29:21.153]                     invisible(muffled)
[09:29:21.153]                   }
[09:29:21.153]                   muffleCondition(cond)
[09:29:21.153]                 })
[09:29:21.153]             }))
[09:29:21.153]             future::FutureResult(value = ...future.value$value, 
[09:29:21.153]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:21.153]                   ...future.rng), globalenv = if (FALSE) 
[09:29:21.153]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:21.153]                     ...future.globalenv.names))
[09:29:21.153]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:21.153]         }, condition = base::local({
[09:29:21.153]             c <- base::c
[09:29:21.153]             inherits <- base::inherits
[09:29:21.153]             invokeRestart <- base::invokeRestart
[09:29:21.153]             length <- base::length
[09:29:21.153]             list <- base::list
[09:29:21.153]             seq.int <- base::seq.int
[09:29:21.153]             signalCondition <- base::signalCondition
[09:29:21.153]             sys.calls <- base::sys.calls
[09:29:21.153]             `[[` <- base::`[[`
[09:29:21.153]             `+` <- base::`+`
[09:29:21.153]             `<<-` <- base::`<<-`
[09:29:21.153]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:21.153]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:21.153]                   3L)]
[09:29:21.153]             }
[09:29:21.153]             function(cond) {
[09:29:21.153]                 is_error <- inherits(cond, "error")
[09:29:21.153]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:21.153]                   NULL)
[09:29:21.153]                 if (is_error) {
[09:29:21.153]                   sessionInformation <- function() {
[09:29:21.153]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:21.153]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:21.153]                       search = base::search(), system = base::Sys.info())
[09:29:21.153]                   }
[09:29:21.153]                   ...future.conditions[[length(...future.conditions) + 
[09:29:21.153]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:21.153]                     cond$call), session = sessionInformation(), 
[09:29:21.153]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:21.153]                   signalCondition(cond)
[09:29:21.153]                 }
[09:29:21.153]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:21.153]                 "immediateCondition"))) {
[09:29:21.153]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:21.153]                   ...future.conditions[[length(...future.conditions) + 
[09:29:21.153]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:21.153]                   if (TRUE && !signal) {
[09:29:21.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.153]                     {
[09:29:21.153]                       inherits <- base::inherits
[09:29:21.153]                       invokeRestart <- base::invokeRestart
[09:29:21.153]                       is.null <- base::is.null
[09:29:21.153]                       muffled <- FALSE
[09:29:21.153]                       if (inherits(cond, "message")) {
[09:29:21.153]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:21.153]                         if (muffled) 
[09:29:21.153]                           invokeRestart("muffleMessage")
[09:29:21.153]                       }
[09:29:21.153]                       else if (inherits(cond, "warning")) {
[09:29:21.153]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:21.153]                         if (muffled) 
[09:29:21.153]                           invokeRestart("muffleWarning")
[09:29:21.153]                       }
[09:29:21.153]                       else if (inherits(cond, "condition")) {
[09:29:21.153]                         if (!is.null(pattern)) {
[09:29:21.153]                           computeRestarts <- base::computeRestarts
[09:29:21.153]                           grepl <- base::grepl
[09:29:21.153]                           restarts <- computeRestarts(cond)
[09:29:21.153]                           for (restart in restarts) {
[09:29:21.153]                             name <- restart$name
[09:29:21.153]                             if (is.null(name)) 
[09:29:21.153]                               next
[09:29:21.153]                             if (!grepl(pattern, name)) 
[09:29:21.153]                               next
[09:29:21.153]                             invokeRestart(restart)
[09:29:21.153]                             muffled <- TRUE
[09:29:21.153]                             break
[09:29:21.153]                           }
[09:29:21.153]                         }
[09:29:21.153]                       }
[09:29:21.153]                       invisible(muffled)
[09:29:21.153]                     }
[09:29:21.153]                     muffleCondition(cond, pattern = "^muffle")
[09:29:21.153]                   }
[09:29:21.153]                 }
[09:29:21.153]                 else {
[09:29:21.153]                   if (TRUE) {
[09:29:21.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.153]                     {
[09:29:21.153]                       inherits <- base::inherits
[09:29:21.153]                       invokeRestart <- base::invokeRestart
[09:29:21.153]                       is.null <- base::is.null
[09:29:21.153]                       muffled <- FALSE
[09:29:21.153]                       if (inherits(cond, "message")) {
[09:29:21.153]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:21.153]                         if (muffled) 
[09:29:21.153]                           invokeRestart("muffleMessage")
[09:29:21.153]                       }
[09:29:21.153]                       else if (inherits(cond, "warning")) {
[09:29:21.153]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:21.153]                         if (muffled) 
[09:29:21.153]                           invokeRestart("muffleWarning")
[09:29:21.153]                       }
[09:29:21.153]                       else if (inherits(cond, "condition")) {
[09:29:21.153]                         if (!is.null(pattern)) {
[09:29:21.153]                           computeRestarts <- base::computeRestarts
[09:29:21.153]                           grepl <- base::grepl
[09:29:21.153]                           restarts <- computeRestarts(cond)
[09:29:21.153]                           for (restart in restarts) {
[09:29:21.153]                             name <- restart$name
[09:29:21.153]                             if (is.null(name)) 
[09:29:21.153]                               next
[09:29:21.153]                             if (!grepl(pattern, name)) 
[09:29:21.153]                               next
[09:29:21.153]                             invokeRestart(restart)
[09:29:21.153]                             muffled <- TRUE
[09:29:21.153]                             break
[09:29:21.153]                           }
[09:29:21.153]                         }
[09:29:21.153]                       }
[09:29:21.153]                       invisible(muffled)
[09:29:21.153]                     }
[09:29:21.153]                     muffleCondition(cond, pattern = "^muffle")
[09:29:21.153]                   }
[09:29:21.153]                 }
[09:29:21.153]             }
[09:29:21.153]         }))
[09:29:21.153]     }, error = function(ex) {
[09:29:21.153]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:21.153]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:21.153]                 ...future.rng), started = ...future.startTime, 
[09:29:21.153]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:21.153]             version = "1.8"), class = "FutureResult")
[09:29:21.153]     }, finally = {
[09:29:21.153]         if (!identical(...future.workdir, getwd())) 
[09:29:21.153]             setwd(...future.workdir)
[09:29:21.153]         {
[09:29:21.153]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:21.153]                 ...future.oldOptions$nwarnings <- NULL
[09:29:21.153]             }
[09:29:21.153]             base::options(...future.oldOptions)
[09:29:21.153]             if (.Platform$OS.type == "windows") {
[09:29:21.153]                 old_names <- names(...future.oldEnvVars)
[09:29:21.153]                 envs <- base::Sys.getenv()
[09:29:21.153]                 names <- names(envs)
[09:29:21.153]                 common <- intersect(names, old_names)
[09:29:21.153]                 added <- setdiff(names, old_names)
[09:29:21.153]                 removed <- setdiff(old_names, names)
[09:29:21.153]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:21.153]                   envs[common]]
[09:29:21.153]                 NAMES <- toupper(changed)
[09:29:21.153]                 args <- list()
[09:29:21.153]                 for (kk in seq_along(NAMES)) {
[09:29:21.153]                   name <- changed[[kk]]
[09:29:21.153]                   NAME <- NAMES[[kk]]
[09:29:21.153]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.153]                     next
[09:29:21.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:21.153]                 }
[09:29:21.153]                 NAMES <- toupper(added)
[09:29:21.153]                 for (kk in seq_along(NAMES)) {
[09:29:21.153]                   name <- added[[kk]]
[09:29:21.153]                   NAME <- NAMES[[kk]]
[09:29:21.153]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.153]                     next
[09:29:21.153]                   args[[name]] <- ""
[09:29:21.153]                 }
[09:29:21.153]                 NAMES <- toupper(removed)
[09:29:21.153]                 for (kk in seq_along(NAMES)) {
[09:29:21.153]                   name <- removed[[kk]]
[09:29:21.153]                   NAME <- NAMES[[kk]]
[09:29:21.153]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.153]                     next
[09:29:21.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:21.153]                 }
[09:29:21.153]                 if (length(args) > 0) 
[09:29:21.153]                   base::do.call(base::Sys.setenv, args = args)
[09:29:21.153]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:21.153]             }
[09:29:21.153]             else {
[09:29:21.153]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:21.153]             }
[09:29:21.153]             {
[09:29:21.153]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:21.153]                   0L) {
[09:29:21.153]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:21.153]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:21.153]                   base::options(opts)
[09:29:21.153]                 }
[09:29:21.153]                 {
[09:29:21.153]                   {
[09:29:21.153]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:21.153]                     NULL
[09:29:21.153]                   }
[09:29:21.153]                   options(future.plan = NULL)
[09:29:21.153]                   if (is.na(NA_character_)) 
[09:29:21.153]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:21.153]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:21.153]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:21.153]                     .init = FALSE)
[09:29:21.153]                 }
[09:29:21.153]             }
[09:29:21.153]         }
[09:29:21.153]     })
[09:29:21.153]     if (TRUE) {
[09:29:21.153]         base::sink(type = "output", split = FALSE)
[09:29:21.153]         if (TRUE) {
[09:29:21.153]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:21.153]         }
[09:29:21.153]         else {
[09:29:21.153]             ...future.result["stdout"] <- base::list(NULL)
[09:29:21.153]         }
[09:29:21.153]         base::close(...future.stdout)
[09:29:21.153]         ...future.stdout <- NULL
[09:29:21.153]     }
[09:29:21.153]     ...future.result$conditions <- ...future.conditions
[09:29:21.153]     ...future.result$finished <- base::Sys.time()
[09:29:21.153]     ...future.result
[09:29:21.153] }
[09:29:21.155] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[09:29:21.155] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[09:29:21.156] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[09:29:21.156] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:21.156] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:21.156] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[09:29:21.157] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[09:29:21.157] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:21.157] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:21.157] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:21.158] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:21.158] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[09:29:21.158] MultisessionFuture started
[09:29:21.158] - Launch lazy future ... done
[09:29:21.158] run() for ‘MultisessionFuture’ ... done
[09:29:21.158] Created future:
[09:29:21.158] MultisessionFuture:
[09:29:21.158] Label: ‘future_Map-2’
[09:29:21.158] Expression:
[09:29:21.158] {
[09:29:21.158]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:21.158]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:21.158]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:21.158]         on.exit(options(oopts), add = TRUE)
[09:29:21.158]     }
[09:29:21.158]     {
[09:29:21.158]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:21.158]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:21.158]         do.call(mapply, args = args)
[09:29:21.158]     }
[09:29:21.158] }
[09:29:21.158] Lazy evaluation: FALSE
[09:29:21.158] Asynchronous evaluation: TRUE
[09:29:21.158] Local evaluation: TRUE
[09:29:21.158] Environment: R_GlobalEnv
[09:29:21.158] Capture standard output: TRUE
[09:29:21.158] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:21.158] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:21.158] Packages: <none>
[09:29:21.158] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:21.158] Resolved: FALSE
[09:29:21.158] Value: <not collected>
[09:29:21.158] Conditions captured: <none>
[09:29:21.158] Early signaling: FALSE
[09:29:21.158] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:21.158] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:21.170] Chunk #2 of 2 ... DONE
[09:29:21.170] Launching 2 futures (chunks) ... DONE
[09:29:21.170] Resolving 2 futures (chunks) ...
[09:29:21.170] resolve() on list ...
[09:29:21.170]  recursive: 0
[09:29:21.170]  length: 2
[09:29:21.171] 
[09:29:21.171] receiveMessageFromWorker() for ClusterFuture ...
[09:29:21.171] - Validating connection of MultisessionFuture
[09:29:21.171] - received message: FutureResult
[09:29:21.171] - Received FutureResult
[09:29:21.171] - Erased future from FutureRegistry
[09:29:21.172] result() for ClusterFuture ...
[09:29:21.172] - result already collected: FutureResult
[09:29:21.172] result() for ClusterFuture ... done
[09:29:21.172] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:21.172] Future #1
[09:29:21.172] result() for ClusterFuture ...
[09:29:21.172] - result already collected: FutureResult
[09:29:21.172] result() for ClusterFuture ... done
[09:29:21.172] result() for ClusterFuture ...
[09:29:21.172] - result already collected: FutureResult
[09:29:21.172] result() for ClusterFuture ... done
[09:29:21.173] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:21.173] - nx: 2
[09:29:21.173] - relay: TRUE
[09:29:21.173] - stdout: TRUE
[09:29:21.173] - signal: TRUE
[09:29:21.173] - resignal: FALSE
[09:29:21.173] - force: TRUE
[09:29:21.173] - relayed: [n=2] FALSE, FALSE
[09:29:21.173] - queued futures: [n=2] FALSE, FALSE
[09:29:21.173]  - until=1
[09:29:21.173]  - relaying element #1
[09:29:21.174] result() for ClusterFuture ...
[09:29:21.174] - result already collected: FutureResult
[09:29:21.174] result() for ClusterFuture ... done
[09:29:21.174] result() for ClusterFuture ...
[09:29:21.174] - result already collected: FutureResult
[09:29:21.174] result() for ClusterFuture ... done
[09:29:21.174] result() for ClusterFuture ...
[09:29:21.174] - result already collected: FutureResult
[09:29:21.174] result() for ClusterFuture ... done
[09:29:21.174] result() for ClusterFuture ...
[09:29:21.174] - result already collected: FutureResult
[09:29:21.174] result() for ClusterFuture ... done
[09:29:21.175] - relayed: [n=2] TRUE, FALSE
[09:29:21.175] - queued futures: [n=2] TRUE, FALSE
[09:29:21.175] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:21.175]  length: 1 (resolved future 1)
[09:29:21.201] receiveMessageFromWorker() for ClusterFuture ...
[09:29:21.201] - Validating connection of MultisessionFuture
[09:29:21.201] - received message: FutureResult
[09:29:21.202] - Received FutureResult
[09:29:21.202] - Erased future from FutureRegistry
[09:29:21.202] result() for ClusterFuture ...
[09:29:21.202] - result already collected: FutureResult
[09:29:21.202] result() for ClusterFuture ... done
[09:29:21.202] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:21.202] Future #2
[09:29:21.202] result() for ClusterFuture ...
[09:29:21.202] - result already collected: FutureResult
[09:29:21.202] result() for ClusterFuture ... done
[09:29:21.202] result() for ClusterFuture ...
[09:29:21.203] - result already collected: FutureResult
[09:29:21.203] result() for ClusterFuture ... done
[09:29:21.203] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:21.203] - nx: 2
[09:29:21.203] - relay: TRUE
[09:29:21.203] - stdout: TRUE
[09:29:21.203] - signal: TRUE
[09:29:21.203] - resignal: FALSE
[09:29:21.203] - force: TRUE
[09:29:21.203] - relayed: [n=2] TRUE, FALSE
[09:29:21.203] - queued futures: [n=2] TRUE, FALSE
[09:29:21.203]  - until=2
[09:29:21.204]  - relaying element #2
[09:29:21.204] result() for ClusterFuture ...
[09:29:21.204] - result already collected: FutureResult
[09:29:21.204] result() for ClusterFuture ... done
[09:29:21.204] result() for ClusterFuture ...
[09:29:21.204] - result already collected: FutureResult
[09:29:21.204] result() for ClusterFuture ... done
[09:29:21.204] result() for ClusterFuture ...
[09:29:21.204] - result already collected: FutureResult
[09:29:21.204] result() for ClusterFuture ... done
[09:29:21.205] result() for ClusterFuture ...
[09:29:21.205] - result already collected: FutureResult
[09:29:21.205] result() for ClusterFuture ... done
[09:29:21.205] - relayed: [n=2] TRUE, TRUE
[09:29:21.205] - queued futures: [n=2] TRUE, TRUE
[09:29:21.205] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:21.205]  length: 0 (resolved future 2)
[09:29:21.205] Relaying remaining futures
[09:29:21.205] signalConditionsASAP(NULL, pos=0) ...
[09:29:21.205] - nx: 2
[09:29:21.205] - relay: TRUE
[09:29:21.205] - stdout: TRUE
[09:29:21.206] - signal: TRUE
[09:29:21.206] - resignal: FALSE
[09:29:21.206] - force: TRUE
[09:29:21.206] - relayed: [n=2] TRUE, TRUE
[09:29:21.206] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:21.206] - relayed: [n=2] TRUE, TRUE
[09:29:21.206] - queued futures: [n=2] TRUE, TRUE
[09:29:21.206] signalConditionsASAP(NULL, pos=0) ... done
[09:29:21.206] resolve() on list ... DONE
[09:29:21.206] result() for ClusterFuture ...
[09:29:21.206] - result already collected: FutureResult
[09:29:21.207] result() for ClusterFuture ... done
[09:29:21.207] result() for ClusterFuture ...
[09:29:21.207] - result already collected: FutureResult
[09:29:21.207] result() for ClusterFuture ... done
[09:29:21.207] result() for ClusterFuture ...
[09:29:21.207] - result already collected: FutureResult
[09:29:21.207] result() for ClusterFuture ... done
[09:29:21.207] result() for ClusterFuture ...
[09:29:21.207] - result already collected: FutureResult
[09:29:21.207] result() for ClusterFuture ... done
[09:29:21.207]  - Number of value chunks collected: 2
[09:29:21.208] Resolving 2 futures (chunks) ... DONE
[09:29:21.208] Reducing values from 2 chunks ...
[09:29:21.208]  - Number of values collected after concatenation: 3
[09:29:21.208]  - Number of values expected: 3
[09:29:21.208] Reducing values from 2 chunks ... DONE
[09:29:21.208] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[09:29:21.208] future_mapply() ...
[09:29:21.212] Number of chunks: 2
[09:29:21.212] getGlobalsAndPackagesXApply() ...
[09:29:21.212]  - future.globals: TRUE
[09:29:21.212] getGlobalsAndPackages() ...
[09:29:21.212] Searching for globals...
[09:29:21.213] - globals found: [1] ‘FUN’
[09:29:21.213] Searching for globals ... DONE
[09:29:21.213] Resolving globals: FALSE
[09:29:21.214] The total size of the 1 globals is 848 bytes (848 bytes)
[09:29:21.214] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:29:21.214] - globals: [1] ‘FUN’
[09:29:21.214] 
[09:29:21.214] getGlobalsAndPackages() ... DONE
[09:29:21.214]  - globals found/used: [n=1] ‘FUN’
[09:29:21.214]  - needed namespaces: [n=0] 
[09:29:21.214] Finding globals ... DONE
[09:29:21.215] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[09:29:21.215] List of 2
[09:29:21.215]  $ ...future.FUN:function (x)  
[09:29:21.215]  $ MoreArgs     : NULL
[09:29:21.215]  - attr(*, "where")=List of 2
[09:29:21.215]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:21.215]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[09:29:21.215]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:21.215]  - attr(*, "resolved")= logi FALSE
[09:29:21.215]  - attr(*, "total_size")= num NA
[09:29:21.217] Packages to be attached in all futures: [n=0] 
[09:29:21.217] getGlobalsAndPackagesXApply() ... DONE
[09:29:21.217] Number of futures (= number of chunks): 2
[09:29:21.218] Launching 2 futures (chunks) ...
[09:29:21.218] Chunk #1 of 2 ...
[09:29:21.218]  - Finding globals in '...' for chunk #1 ...
[09:29:21.218] getGlobalsAndPackages() ...
[09:29:21.218] Searching for globals...
[09:29:21.218] 
[09:29:21.218] Searching for globals ... DONE
[09:29:21.218] - globals: [0] <none>
[09:29:21.218] getGlobalsAndPackages() ... DONE
[09:29:21.219]    + additional globals found: [n=0] 
[09:29:21.219]    + additional namespaces needed: [n=0] 
[09:29:21.219]  - Finding globals in '...' for chunk #1 ... DONE
[09:29:21.219]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:21.219]  - seeds: <none>
[09:29:21.219]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.219] getGlobalsAndPackages() ...
[09:29:21.219] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.219] Resolving globals: FALSE
[09:29:21.220] The total size of the 5 globals is 904 bytes (904 bytes)
[09:29:21.220] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:21.220] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.220] 
[09:29:21.221] getGlobalsAndPackages() ... DONE
[09:29:21.221] run() for ‘Future’ ...
[09:29:21.221] - state: ‘created’
[09:29:21.221] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:21.235] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:21.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:21.235]   - Field: ‘node’
[09:29:21.235]   - Field: ‘label’
[09:29:21.235]   - Field: ‘local’
[09:29:21.236]   - Field: ‘owner’
[09:29:21.236]   - Field: ‘envir’
[09:29:21.236]   - Field: ‘workers’
[09:29:21.236]   - Field: ‘packages’
[09:29:21.236]   - Field: ‘gc’
[09:29:21.236]   - Field: ‘conditions’
[09:29:21.236]   - Field: ‘persistent’
[09:29:21.236]   - Field: ‘expr’
[09:29:21.236]   - Field: ‘uuid’
[09:29:21.236]   - Field: ‘seed’
[09:29:21.237]   - Field: ‘version’
[09:29:21.237]   - Field: ‘result’
[09:29:21.237]   - Field: ‘asynchronous’
[09:29:21.237]   - Field: ‘calls’
[09:29:21.237]   - Field: ‘globals’
[09:29:21.237]   - Field: ‘stdout’
[09:29:21.237]   - Field: ‘earlySignal’
[09:29:21.237]   - Field: ‘lazy’
[09:29:21.237]   - Field: ‘state’
[09:29:21.237] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:21.237] - Launch lazy future ...
[09:29:21.238] Packages needed by the future expression (n = 0): <none>
[09:29:21.238] Packages needed by future strategies (n = 0): <none>
[09:29:21.238] {
[09:29:21.238]     {
[09:29:21.238]         {
[09:29:21.238]             ...future.startTime <- base::Sys.time()
[09:29:21.238]             {
[09:29:21.238]                 {
[09:29:21.238]                   {
[09:29:21.238]                     {
[09:29:21.238]                       base::local({
[09:29:21.238]                         has_future <- base::requireNamespace("future", 
[09:29:21.238]                           quietly = TRUE)
[09:29:21.238]                         if (has_future) {
[09:29:21.238]                           ns <- base::getNamespace("future")
[09:29:21.238]                           version <- ns[[".package"]][["version"]]
[09:29:21.238]                           if (is.null(version)) 
[09:29:21.238]                             version <- utils::packageVersion("future")
[09:29:21.238]                         }
[09:29:21.238]                         else {
[09:29:21.238]                           version <- NULL
[09:29:21.238]                         }
[09:29:21.238]                         if (!has_future || version < "1.8.0") {
[09:29:21.238]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:21.238]                             "", base::R.version$version.string), 
[09:29:21.238]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:21.238]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:21.238]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:21.238]                               "release", "version")], collapse = " "), 
[09:29:21.238]                             hostname = base::Sys.info()[["nodename"]])
[09:29:21.238]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:21.238]                             info)
[09:29:21.238]                           info <- base::paste(info, collapse = "; ")
[09:29:21.238]                           if (!has_future) {
[09:29:21.238]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:21.238]                               info)
[09:29:21.238]                           }
[09:29:21.238]                           else {
[09:29:21.238]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:21.238]                               info, version)
[09:29:21.238]                           }
[09:29:21.238]                           base::stop(msg)
[09:29:21.238]                         }
[09:29:21.238]                       })
[09:29:21.238]                     }
[09:29:21.238]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:21.238]                     base::options(mc.cores = 1L)
[09:29:21.238]                   }
[09:29:21.238]                   ...future.strategy.old <- future::plan("list")
[09:29:21.238]                   options(future.plan = NULL)
[09:29:21.238]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:21.238]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:21.238]                 }
[09:29:21.238]                 ...future.workdir <- getwd()
[09:29:21.238]             }
[09:29:21.238]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:21.238]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:21.238]         }
[09:29:21.238]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:21.238]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:21.238]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:21.238]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:21.238]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:21.238]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:21.238]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:21.238]             base::names(...future.oldOptions))
[09:29:21.238]     }
[09:29:21.238]     if (FALSE) {
[09:29:21.238]     }
[09:29:21.238]     else {
[09:29:21.238]         if (TRUE) {
[09:29:21.238]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:21.238]                 open = "w")
[09:29:21.238]         }
[09:29:21.238]         else {
[09:29:21.238]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:21.238]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:21.238]         }
[09:29:21.238]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:21.238]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:21.238]             base::sink(type = "output", split = FALSE)
[09:29:21.238]             base::close(...future.stdout)
[09:29:21.238]         }, add = TRUE)
[09:29:21.238]     }
[09:29:21.238]     ...future.frame <- base::sys.nframe()
[09:29:21.238]     ...future.conditions <- base::list()
[09:29:21.238]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:21.238]     if (FALSE) {
[09:29:21.238]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:21.238]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:21.238]     }
[09:29:21.238]     ...future.result <- base::tryCatch({
[09:29:21.238]         base::withCallingHandlers({
[09:29:21.238]             ...future.value <- base::withVisible(base::local({
[09:29:21.238]                 ...future.makeSendCondition <- base::local({
[09:29:21.238]                   sendCondition <- NULL
[09:29:21.238]                   function(frame = 1L) {
[09:29:21.238]                     if (is.function(sendCondition)) 
[09:29:21.238]                       return(sendCondition)
[09:29:21.238]                     ns <- getNamespace("parallel")
[09:29:21.238]                     if (exists("sendData", mode = "function", 
[09:29:21.238]                       envir = ns)) {
[09:29:21.238]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:21.238]                         envir = ns)
[09:29:21.238]                       envir <- sys.frame(frame)
[09:29:21.238]                       master <- NULL
[09:29:21.238]                       while (!identical(envir, .GlobalEnv) && 
[09:29:21.238]                         !identical(envir, emptyenv())) {
[09:29:21.238]                         if (exists("master", mode = "list", envir = envir, 
[09:29:21.238]                           inherits = FALSE)) {
[09:29:21.238]                           master <- get("master", mode = "list", 
[09:29:21.238]                             envir = envir, inherits = FALSE)
[09:29:21.238]                           if (inherits(master, c("SOCKnode", 
[09:29:21.238]                             "SOCK0node"))) {
[09:29:21.238]                             sendCondition <<- function(cond) {
[09:29:21.238]                               data <- list(type = "VALUE", value = cond, 
[09:29:21.238]                                 success = TRUE)
[09:29:21.238]                               parallel_sendData(master, data)
[09:29:21.238]                             }
[09:29:21.238]                             return(sendCondition)
[09:29:21.238]                           }
[09:29:21.238]                         }
[09:29:21.238]                         frame <- frame + 1L
[09:29:21.238]                         envir <- sys.frame(frame)
[09:29:21.238]                       }
[09:29:21.238]                     }
[09:29:21.238]                     sendCondition <<- function(cond) NULL
[09:29:21.238]                   }
[09:29:21.238]                 })
[09:29:21.238]                 withCallingHandlers({
[09:29:21.238]                   {
[09:29:21.238]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:21.238]                     if (!identical(...future.globals.maxSize.org, 
[09:29:21.238]                       ...future.globals.maxSize)) {
[09:29:21.238]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:21.238]                       on.exit(options(oopts), add = TRUE)
[09:29:21.238]                     }
[09:29:21.238]                     {
[09:29:21.238]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:21.238]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:21.238]                         USE.NAMES = FALSE)
[09:29:21.238]                       do.call(mapply, args = args)
[09:29:21.238]                     }
[09:29:21.238]                   }
[09:29:21.238]                 }, immediateCondition = function(cond) {
[09:29:21.238]                   sendCondition <- ...future.makeSendCondition()
[09:29:21.238]                   sendCondition(cond)
[09:29:21.238]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.238]                   {
[09:29:21.238]                     inherits <- base::inherits
[09:29:21.238]                     invokeRestart <- base::invokeRestart
[09:29:21.238]                     is.null <- base::is.null
[09:29:21.238]                     muffled <- FALSE
[09:29:21.238]                     if (inherits(cond, "message")) {
[09:29:21.238]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:21.238]                       if (muffled) 
[09:29:21.238]                         invokeRestart("muffleMessage")
[09:29:21.238]                     }
[09:29:21.238]                     else if (inherits(cond, "warning")) {
[09:29:21.238]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:21.238]                       if (muffled) 
[09:29:21.238]                         invokeRestart("muffleWarning")
[09:29:21.238]                     }
[09:29:21.238]                     else if (inherits(cond, "condition")) {
[09:29:21.238]                       if (!is.null(pattern)) {
[09:29:21.238]                         computeRestarts <- base::computeRestarts
[09:29:21.238]                         grepl <- base::grepl
[09:29:21.238]                         restarts <- computeRestarts(cond)
[09:29:21.238]                         for (restart in restarts) {
[09:29:21.238]                           name <- restart$name
[09:29:21.238]                           if (is.null(name)) 
[09:29:21.238]                             next
[09:29:21.238]                           if (!grepl(pattern, name)) 
[09:29:21.238]                             next
[09:29:21.238]                           invokeRestart(restart)
[09:29:21.238]                           muffled <- TRUE
[09:29:21.238]                           break
[09:29:21.238]                         }
[09:29:21.238]                       }
[09:29:21.238]                     }
[09:29:21.238]                     invisible(muffled)
[09:29:21.238]                   }
[09:29:21.238]                   muffleCondition(cond)
[09:29:21.238]                 })
[09:29:21.238]             }))
[09:29:21.238]             future::FutureResult(value = ...future.value$value, 
[09:29:21.238]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:21.238]                   ...future.rng), globalenv = if (FALSE) 
[09:29:21.238]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:21.238]                     ...future.globalenv.names))
[09:29:21.238]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:21.238]         }, condition = base::local({
[09:29:21.238]             c <- base::c
[09:29:21.238]             inherits <- base::inherits
[09:29:21.238]             invokeRestart <- base::invokeRestart
[09:29:21.238]             length <- base::length
[09:29:21.238]             list <- base::list
[09:29:21.238]             seq.int <- base::seq.int
[09:29:21.238]             signalCondition <- base::signalCondition
[09:29:21.238]             sys.calls <- base::sys.calls
[09:29:21.238]             `[[` <- base::`[[`
[09:29:21.238]             `+` <- base::`+`
[09:29:21.238]             `<<-` <- base::`<<-`
[09:29:21.238]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:21.238]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:21.238]                   3L)]
[09:29:21.238]             }
[09:29:21.238]             function(cond) {
[09:29:21.238]                 is_error <- inherits(cond, "error")
[09:29:21.238]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:21.238]                   NULL)
[09:29:21.238]                 if (is_error) {
[09:29:21.238]                   sessionInformation <- function() {
[09:29:21.238]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:21.238]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:21.238]                       search = base::search(), system = base::Sys.info())
[09:29:21.238]                   }
[09:29:21.238]                   ...future.conditions[[length(...future.conditions) + 
[09:29:21.238]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:21.238]                     cond$call), session = sessionInformation(), 
[09:29:21.238]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:21.238]                   signalCondition(cond)
[09:29:21.238]                 }
[09:29:21.238]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:21.238]                 "immediateCondition"))) {
[09:29:21.238]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:21.238]                   ...future.conditions[[length(...future.conditions) + 
[09:29:21.238]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:21.238]                   if (TRUE && !signal) {
[09:29:21.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.238]                     {
[09:29:21.238]                       inherits <- base::inherits
[09:29:21.238]                       invokeRestart <- base::invokeRestart
[09:29:21.238]                       is.null <- base::is.null
[09:29:21.238]                       muffled <- FALSE
[09:29:21.238]                       if (inherits(cond, "message")) {
[09:29:21.238]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:21.238]                         if (muffled) 
[09:29:21.238]                           invokeRestart("muffleMessage")
[09:29:21.238]                       }
[09:29:21.238]                       else if (inherits(cond, "warning")) {
[09:29:21.238]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:21.238]                         if (muffled) 
[09:29:21.238]                           invokeRestart("muffleWarning")
[09:29:21.238]                       }
[09:29:21.238]                       else if (inherits(cond, "condition")) {
[09:29:21.238]                         if (!is.null(pattern)) {
[09:29:21.238]                           computeRestarts <- base::computeRestarts
[09:29:21.238]                           grepl <- base::grepl
[09:29:21.238]                           restarts <- computeRestarts(cond)
[09:29:21.238]                           for (restart in restarts) {
[09:29:21.238]                             name <- restart$name
[09:29:21.238]                             if (is.null(name)) 
[09:29:21.238]                               next
[09:29:21.238]                             if (!grepl(pattern, name)) 
[09:29:21.238]                               next
[09:29:21.238]                             invokeRestart(restart)
[09:29:21.238]                             muffled <- TRUE
[09:29:21.238]                             break
[09:29:21.238]                           }
[09:29:21.238]                         }
[09:29:21.238]                       }
[09:29:21.238]                       invisible(muffled)
[09:29:21.238]                     }
[09:29:21.238]                     muffleCondition(cond, pattern = "^muffle")
[09:29:21.238]                   }
[09:29:21.238]                 }
[09:29:21.238]                 else {
[09:29:21.238]                   if (TRUE) {
[09:29:21.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.238]                     {
[09:29:21.238]                       inherits <- base::inherits
[09:29:21.238]                       invokeRestart <- base::invokeRestart
[09:29:21.238]                       is.null <- base::is.null
[09:29:21.238]                       muffled <- FALSE
[09:29:21.238]                       if (inherits(cond, "message")) {
[09:29:21.238]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:21.238]                         if (muffled) 
[09:29:21.238]                           invokeRestart("muffleMessage")
[09:29:21.238]                       }
[09:29:21.238]                       else if (inherits(cond, "warning")) {
[09:29:21.238]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:21.238]                         if (muffled) 
[09:29:21.238]                           invokeRestart("muffleWarning")
[09:29:21.238]                       }
[09:29:21.238]                       else if (inherits(cond, "condition")) {
[09:29:21.238]                         if (!is.null(pattern)) {
[09:29:21.238]                           computeRestarts <- base::computeRestarts
[09:29:21.238]                           grepl <- base::grepl
[09:29:21.238]                           restarts <- computeRestarts(cond)
[09:29:21.238]                           for (restart in restarts) {
[09:29:21.238]                             name <- restart$name
[09:29:21.238]                             if (is.null(name)) 
[09:29:21.238]                               next
[09:29:21.238]                             if (!grepl(pattern, name)) 
[09:29:21.238]                               next
[09:29:21.238]                             invokeRestart(restart)
[09:29:21.238]                             muffled <- TRUE
[09:29:21.238]                             break
[09:29:21.238]                           }
[09:29:21.238]                         }
[09:29:21.238]                       }
[09:29:21.238]                       invisible(muffled)
[09:29:21.238]                     }
[09:29:21.238]                     muffleCondition(cond, pattern = "^muffle")
[09:29:21.238]                   }
[09:29:21.238]                 }
[09:29:21.238]             }
[09:29:21.238]         }))
[09:29:21.238]     }, error = function(ex) {
[09:29:21.238]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:21.238]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:21.238]                 ...future.rng), started = ...future.startTime, 
[09:29:21.238]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:21.238]             version = "1.8"), class = "FutureResult")
[09:29:21.238]     }, finally = {
[09:29:21.238]         if (!identical(...future.workdir, getwd())) 
[09:29:21.238]             setwd(...future.workdir)
[09:29:21.238]         {
[09:29:21.238]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:21.238]                 ...future.oldOptions$nwarnings <- NULL
[09:29:21.238]             }
[09:29:21.238]             base::options(...future.oldOptions)
[09:29:21.238]             if (.Platform$OS.type == "windows") {
[09:29:21.238]                 old_names <- names(...future.oldEnvVars)
[09:29:21.238]                 envs <- base::Sys.getenv()
[09:29:21.238]                 names <- names(envs)
[09:29:21.238]                 common <- intersect(names, old_names)
[09:29:21.238]                 added <- setdiff(names, old_names)
[09:29:21.238]                 removed <- setdiff(old_names, names)
[09:29:21.238]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:21.238]                   envs[common]]
[09:29:21.238]                 NAMES <- toupper(changed)
[09:29:21.238]                 args <- list()
[09:29:21.238]                 for (kk in seq_along(NAMES)) {
[09:29:21.238]                   name <- changed[[kk]]
[09:29:21.238]                   NAME <- NAMES[[kk]]
[09:29:21.238]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.238]                     next
[09:29:21.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:21.238]                 }
[09:29:21.238]                 NAMES <- toupper(added)
[09:29:21.238]                 for (kk in seq_along(NAMES)) {
[09:29:21.238]                   name <- added[[kk]]
[09:29:21.238]                   NAME <- NAMES[[kk]]
[09:29:21.238]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.238]                     next
[09:29:21.238]                   args[[name]] <- ""
[09:29:21.238]                 }
[09:29:21.238]                 NAMES <- toupper(removed)
[09:29:21.238]                 for (kk in seq_along(NAMES)) {
[09:29:21.238]                   name <- removed[[kk]]
[09:29:21.238]                   NAME <- NAMES[[kk]]
[09:29:21.238]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.238]                     next
[09:29:21.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:21.238]                 }
[09:29:21.238]                 if (length(args) > 0) 
[09:29:21.238]                   base::do.call(base::Sys.setenv, args = args)
[09:29:21.238]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:21.238]             }
[09:29:21.238]             else {
[09:29:21.238]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:21.238]             }
[09:29:21.238]             {
[09:29:21.238]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:21.238]                   0L) {
[09:29:21.238]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:21.238]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:21.238]                   base::options(opts)
[09:29:21.238]                 }
[09:29:21.238]                 {
[09:29:21.238]                   {
[09:29:21.238]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:21.238]                     NULL
[09:29:21.238]                   }
[09:29:21.238]                   options(future.plan = NULL)
[09:29:21.238]                   if (is.na(NA_character_)) 
[09:29:21.238]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:21.238]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:21.238]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:21.238]                     .init = FALSE)
[09:29:21.238]                 }
[09:29:21.238]             }
[09:29:21.238]         }
[09:29:21.238]     })
[09:29:21.238]     if (TRUE) {
[09:29:21.238]         base::sink(type = "output", split = FALSE)
[09:29:21.238]         if (TRUE) {
[09:29:21.238]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:21.238]         }
[09:29:21.238]         else {
[09:29:21.238]             ...future.result["stdout"] <- base::list(NULL)
[09:29:21.238]         }
[09:29:21.238]         base::close(...future.stdout)
[09:29:21.238]         ...future.stdout <- NULL
[09:29:21.238]     }
[09:29:21.238]     ...future.result$conditions <- ...future.conditions
[09:29:21.238]     ...future.result$finished <- base::Sys.time()
[09:29:21.238]     ...future.result
[09:29:21.238] }
[09:29:21.241] Exporting 5 global objects (904 bytes) to cluster node #1 ...
[09:29:21.241] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[09:29:21.241] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[09:29:21.241] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[09:29:21.242] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[09:29:21.242] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[09:29:21.242] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[09:29:21.242] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:21.243] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:21.243] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:21.243] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:21.243] Exporting 5 global objects (904 bytes) to cluster node #1 ... DONE
[09:29:21.243] MultisessionFuture started
[09:29:21.244] - Launch lazy future ... done
[09:29:21.244] run() for ‘MultisessionFuture’ ... done
[09:29:21.244] Created future:
[09:29:21.244] MultisessionFuture:
[09:29:21.244] Label: ‘future_mapply-1’
[09:29:21.244] Expression:
[09:29:21.244] {
[09:29:21.244]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:21.244]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:21.244]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:21.244]         on.exit(options(oopts), add = TRUE)
[09:29:21.244]     }
[09:29:21.244]     {
[09:29:21.244]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:21.244]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:21.244]         do.call(mapply, args = args)
[09:29:21.244]     }
[09:29:21.244] }
[09:29:21.244] Lazy evaluation: FALSE
[09:29:21.244] Asynchronous evaluation: TRUE
[09:29:21.244] Local evaluation: TRUE
[09:29:21.244] Environment: R_GlobalEnv
[09:29:21.244] Capture standard output: TRUE
[09:29:21.244] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:21.244] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:21.244] Packages: <none>
[09:29:21.244] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:21.244] Resolved: FALSE
[09:29:21.244] Value: <not collected>
[09:29:21.244] Conditions captured: <none>
[09:29:21.244] Early signaling: FALSE
[09:29:21.244] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:21.244] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:21.258] Chunk #1 of 2 ... DONE
[09:29:21.258] Chunk #2 of 2 ...
[09:29:21.258]  - Finding globals in '...' for chunk #2 ...
[09:29:21.258] getGlobalsAndPackages() ...
[09:29:21.259] Searching for globals...
[09:29:21.259] 
[09:29:21.259] Searching for globals ... DONE
[09:29:21.259] - globals: [0] <none>
[09:29:21.259] getGlobalsAndPackages() ... DONE
[09:29:21.259]    + additional globals found: [n=0] 
[09:29:21.259]    + additional namespaces needed: [n=0] 
[09:29:21.259]  - Finding globals in '...' for chunk #2 ... DONE
[09:29:21.259]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:21.260]  - seeds: <none>
[09:29:21.260]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.260] getGlobalsAndPackages() ...
[09:29:21.260] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.260] Resolving globals: FALSE
[09:29:21.260] The total size of the 5 globals is 904 bytes (904 bytes)
[09:29:21.261] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[09:29:21.261] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:21.261] 
[09:29:21.261] getGlobalsAndPackages() ... DONE
[09:29:21.261] run() for ‘Future’ ...
[09:29:21.261] - state: ‘created’
[09:29:21.262] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:21.276] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:21.276] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:21.276]   - Field: ‘node’
[09:29:21.276]   - Field: ‘label’
[09:29:21.276]   - Field: ‘local’
[09:29:21.277]   - Field: ‘owner’
[09:29:21.277]   - Field: ‘envir’
[09:29:21.277]   - Field: ‘workers’
[09:29:21.277]   - Field: ‘packages’
[09:29:21.277]   - Field: ‘gc’
[09:29:21.277]   - Field: ‘conditions’
[09:29:21.277]   - Field: ‘persistent’
[09:29:21.277]   - Field: ‘expr’
[09:29:21.277]   - Field: ‘uuid’
[09:29:21.277]   - Field: ‘seed’
[09:29:21.277]   - Field: ‘version’
[09:29:21.277]   - Field: ‘result’
[09:29:21.278]   - Field: ‘asynchronous’
[09:29:21.278]   - Field: ‘calls’
[09:29:21.278]   - Field: ‘globals’
[09:29:21.278]   - Field: ‘stdout’
[09:29:21.278]   - Field: ‘earlySignal’
[09:29:21.278]   - Field: ‘lazy’
[09:29:21.278]   - Field: ‘state’
[09:29:21.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:21.278] - Launch lazy future ...
[09:29:21.279] Packages needed by the future expression (n = 0): <none>
[09:29:21.279] Packages needed by future strategies (n = 0): <none>
[09:29:21.279] {
[09:29:21.279]     {
[09:29:21.279]         {
[09:29:21.279]             ...future.startTime <- base::Sys.time()
[09:29:21.279]             {
[09:29:21.279]                 {
[09:29:21.279]                   {
[09:29:21.279]                     {
[09:29:21.279]                       base::local({
[09:29:21.279]                         has_future <- base::requireNamespace("future", 
[09:29:21.279]                           quietly = TRUE)
[09:29:21.279]                         if (has_future) {
[09:29:21.279]                           ns <- base::getNamespace("future")
[09:29:21.279]                           version <- ns[[".package"]][["version"]]
[09:29:21.279]                           if (is.null(version)) 
[09:29:21.279]                             version <- utils::packageVersion("future")
[09:29:21.279]                         }
[09:29:21.279]                         else {
[09:29:21.279]                           version <- NULL
[09:29:21.279]                         }
[09:29:21.279]                         if (!has_future || version < "1.8.0") {
[09:29:21.279]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:21.279]                             "", base::R.version$version.string), 
[09:29:21.279]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:21.279]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:21.279]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:21.279]                               "release", "version")], collapse = " "), 
[09:29:21.279]                             hostname = base::Sys.info()[["nodename"]])
[09:29:21.279]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:21.279]                             info)
[09:29:21.279]                           info <- base::paste(info, collapse = "; ")
[09:29:21.279]                           if (!has_future) {
[09:29:21.279]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:21.279]                               info)
[09:29:21.279]                           }
[09:29:21.279]                           else {
[09:29:21.279]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:21.279]                               info, version)
[09:29:21.279]                           }
[09:29:21.279]                           base::stop(msg)
[09:29:21.279]                         }
[09:29:21.279]                       })
[09:29:21.279]                     }
[09:29:21.279]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:21.279]                     base::options(mc.cores = 1L)
[09:29:21.279]                   }
[09:29:21.279]                   ...future.strategy.old <- future::plan("list")
[09:29:21.279]                   options(future.plan = NULL)
[09:29:21.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:21.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:21.279]                 }
[09:29:21.279]                 ...future.workdir <- getwd()
[09:29:21.279]             }
[09:29:21.279]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:21.279]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:21.279]         }
[09:29:21.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:21.279]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:21.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:21.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:21.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:21.279]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:21.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:21.279]             base::names(...future.oldOptions))
[09:29:21.279]     }
[09:29:21.279]     if (FALSE) {
[09:29:21.279]     }
[09:29:21.279]     else {
[09:29:21.279]         if (TRUE) {
[09:29:21.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:21.279]                 open = "w")
[09:29:21.279]         }
[09:29:21.279]         else {
[09:29:21.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:21.279]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:21.279]         }
[09:29:21.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:21.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:21.279]             base::sink(type = "output", split = FALSE)
[09:29:21.279]             base::close(...future.stdout)
[09:29:21.279]         }, add = TRUE)
[09:29:21.279]     }
[09:29:21.279]     ...future.frame <- base::sys.nframe()
[09:29:21.279]     ...future.conditions <- base::list()
[09:29:21.279]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:21.279]     if (FALSE) {
[09:29:21.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:21.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:21.279]     }
[09:29:21.279]     ...future.result <- base::tryCatch({
[09:29:21.279]         base::withCallingHandlers({
[09:29:21.279]             ...future.value <- base::withVisible(base::local({
[09:29:21.279]                 ...future.makeSendCondition <- base::local({
[09:29:21.279]                   sendCondition <- NULL
[09:29:21.279]                   function(frame = 1L) {
[09:29:21.279]                     if (is.function(sendCondition)) 
[09:29:21.279]                       return(sendCondition)
[09:29:21.279]                     ns <- getNamespace("parallel")
[09:29:21.279]                     if (exists("sendData", mode = "function", 
[09:29:21.279]                       envir = ns)) {
[09:29:21.279]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:21.279]                         envir = ns)
[09:29:21.279]                       envir <- sys.frame(frame)
[09:29:21.279]                       master <- NULL
[09:29:21.279]                       while (!identical(envir, .GlobalEnv) && 
[09:29:21.279]                         !identical(envir, emptyenv())) {
[09:29:21.279]                         if (exists("master", mode = "list", envir = envir, 
[09:29:21.279]                           inherits = FALSE)) {
[09:29:21.279]                           master <- get("master", mode = "list", 
[09:29:21.279]                             envir = envir, inherits = FALSE)
[09:29:21.279]                           if (inherits(master, c("SOCKnode", 
[09:29:21.279]                             "SOCK0node"))) {
[09:29:21.279]                             sendCondition <<- function(cond) {
[09:29:21.279]                               data <- list(type = "VALUE", value = cond, 
[09:29:21.279]                                 success = TRUE)
[09:29:21.279]                               parallel_sendData(master, data)
[09:29:21.279]                             }
[09:29:21.279]                             return(sendCondition)
[09:29:21.279]                           }
[09:29:21.279]                         }
[09:29:21.279]                         frame <- frame + 1L
[09:29:21.279]                         envir <- sys.frame(frame)
[09:29:21.279]                       }
[09:29:21.279]                     }
[09:29:21.279]                     sendCondition <<- function(cond) NULL
[09:29:21.279]                   }
[09:29:21.279]                 })
[09:29:21.279]                 withCallingHandlers({
[09:29:21.279]                   {
[09:29:21.279]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:21.279]                     if (!identical(...future.globals.maxSize.org, 
[09:29:21.279]                       ...future.globals.maxSize)) {
[09:29:21.279]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:21.279]                       on.exit(options(oopts), add = TRUE)
[09:29:21.279]                     }
[09:29:21.279]                     {
[09:29:21.279]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:21.279]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[09:29:21.279]                         USE.NAMES = FALSE)
[09:29:21.279]                       do.call(mapply, args = args)
[09:29:21.279]                     }
[09:29:21.279]                   }
[09:29:21.279]                 }, immediateCondition = function(cond) {
[09:29:21.279]                   sendCondition <- ...future.makeSendCondition()
[09:29:21.279]                   sendCondition(cond)
[09:29:21.279]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.279]                   {
[09:29:21.279]                     inherits <- base::inherits
[09:29:21.279]                     invokeRestart <- base::invokeRestart
[09:29:21.279]                     is.null <- base::is.null
[09:29:21.279]                     muffled <- FALSE
[09:29:21.279]                     if (inherits(cond, "message")) {
[09:29:21.279]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:21.279]                       if (muffled) 
[09:29:21.279]                         invokeRestart("muffleMessage")
[09:29:21.279]                     }
[09:29:21.279]                     else if (inherits(cond, "warning")) {
[09:29:21.279]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:21.279]                       if (muffled) 
[09:29:21.279]                         invokeRestart("muffleWarning")
[09:29:21.279]                     }
[09:29:21.279]                     else if (inherits(cond, "condition")) {
[09:29:21.279]                       if (!is.null(pattern)) {
[09:29:21.279]                         computeRestarts <- base::computeRestarts
[09:29:21.279]                         grepl <- base::grepl
[09:29:21.279]                         restarts <- computeRestarts(cond)
[09:29:21.279]                         for (restart in restarts) {
[09:29:21.279]                           name <- restart$name
[09:29:21.279]                           if (is.null(name)) 
[09:29:21.279]                             next
[09:29:21.279]                           if (!grepl(pattern, name)) 
[09:29:21.279]                             next
[09:29:21.279]                           invokeRestart(restart)
[09:29:21.279]                           muffled <- TRUE
[09:29:21.279]                           break
[09:29:21.279]                         }
[09:29:21.279]                       }
[09:29:21.279]                     }
[09:29:21.279]                     invisible(muffled)
[09:29:21.279]                   }
[09:29:21.279]                   muffleCondition(cond)
[09:29:21.279]                 })
[09:29:21.279]             }))
[09:29:21.279]             future::FutureResult(value = ...future.value$value, 
[09:29:21.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:21.279]                   ...future.rng), globalenv = if (FALSE) 
[09:29:21.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:21.279]                     ...future.globalenv.names))
[09:29:21.279]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:21.279]         }, condition = base::local({
[09:29:21.279]             c <- base::c
[09:29:21.279]             inherits <- base::inherits
[09:29:21.279]             invokeRestart <- base::invokeRestart
[09:29:21.279]             length <- base::length
[09:29:21.279]             list <- base::list
[09:29:21.279]             seq.int <- base::seq.int
[09:29:21.279]             signalCondition <- base::signalCondition
[09:29:21.279]             sys.calls <- base::sys.calls
[09:29:21.279]             `[[` <- base::`[[`
[09:29:21.279]             `+` <- base::`+`
[09:29:21.279]             `<<-` <- base::`<<-`
[09:29:21.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:21.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:21.279]                   3L)]
[09:29:21.279]             }
[09:29:21.279]             function(cond) {
[09:29:21.279]                 is_error <- inherits(cond, "error")
[09:29:21.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:21.279]                   NULL)
[09:29:21.279]                 if (is_error) {
[09:29:21.279]                   sessionInformation <- function() {
[09:29:21.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:21.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:21.279]                       search = base::search(), system = base::Sys.info())
[09:29:21.279]                   }
[09:29:21.279]                   ...future.conditions[[length(...future.conditions) + 
[09:29:21.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:21.279]                     cond$call), session = sessionInformation(), 
[09:29:21.279]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:21.279]                   signalCondition(cond)
[09:29:21.279]                 }
[09:29:21.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:21.279]                 "immediateCondition"))) {
[09:29:21.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:21.279]                   ...future.conditions[[length(...future.conditions) + 
[09:29:21.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:21.279]                   if (TRUE && !signal) {
[09:29:21.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.279]                     {
[09:29:21.279]                       inherits <- base::inherits
[09:29:21.279]                       invokeRestart <- base::invokeRestart
[09:29:21.279]                       is.null <- base::is.null
[09:29:21.279]                       muffled <- FALSE
[09:29:21.279]                       if (inherits(cond, "message")) {
[09:29:21.279]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:21.279]                         if (muffled) 
[09:29:21.279]                           invokeRestart("muffleMessage")
[09:29:21.279]                       }
[09:29:21.279]                       else if (inherits(cond, "warning")) {
[09:29:21.279]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:21.279]                         if (muffled) 
[09:29:21.279]                           invokeRestart("muffleWarning")
[09:29:21.279]                       }
[09:29:21.279]                       else if (inherits(cond, "condition")) {
[09:29:21.279]                         if (!is.null(pattern)) {
[09:29:21.279]                           computeRestarts <- base::computeRestarts
[09:29:21.279]                           grepl <- base::grepl
[09:29:21.279]                           restarts <- computeRestarts(cond)
[09:29:21.279]                           for (restart in restarts) {
[09:29:21.279]                             name <- restart$name
[09:29:21.279]                             if (is.null(name)) 
[09:29:21.279]                               next
[09:29:21.279]                             if (!grepl(pattern, name)) 
[09:29:21.279]                               next
[09:29:21.279]                             invokeRestart(restart)
[09:29:21.279]                             muffled <- TRUE
[09:29:21.279]                             break
[09:29:21.279]                           }
[09:29:21.279]                         }
[09:29:21.279]                       }
[09:29:21.279]                       invisible(muffled)
[09:29:21.279]                     }
[09:29:21.279]                     muffleCondition(cond, pattern = "^muffle")
[09:29:21.279]                   }
[09:29:21.279]                 }
[09:29:21.279]                 else {
[09:29:21.279]                   if (TRUE) {
[09:29:21.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:21.279]                     {
[09:29:21.279]                       inherits <- base::inherits
[09:29:21.279]                       invokeRestart <- base::invokeRestart
[09:29:21.279]                       is.null <- base::is.null
[09:29:21.279]                       muffled <- FALSE
[09:29:21.279]                       if (inherits(cond, "message")) {
[09:29:21.279]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:21.279]                         if (muffled) 
[09:29:21.279]                           invokeRestart("muffleMessage")
[09:29:21.279]                       }
[09:29:21.279]                       else if (inherits(cond, "warning")) {
[09:29:21.279]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:21.279]                         if (muffled) 
[09:29:21.279]                           invokeRestart("muffleWarning")
[09:29:21.279]                       }
[09:29:21.279]                       else if (inherits(cond, "condition")) {
[09:29:21.279]                         if (!is.null(pattern)) {
[09:29:21.279]                           computeRestarts <- base::computeRestarts
[09:29:21.279]                           grepl <- base::grepl
[09:29:21.279]                           restarts <- computeRestarts(cond)
[09:29:21.279]                           for (restart in restarts) {
[09:29:21.279]                             name <- restart$name
[09:29:21.279]                             if (is.null(name)) 
[09:29:21.279]                               next
[09:29:21.279]                             if (!grepl(pattern, name)) 
[09:29:21.279]                               next
[09:29:21.279]                             invokeRestart(restart)
[09:29:21.279]                             muffled <- TRUE
[09:29:21.279]                             break
[09:29:21.279]                           }
[09:29:21.279]                         }
[09:29:21.279]                       }
[09:29:21.279]                       invisible(muffled)
[09:29:21.279]                     }
[09:29:21.279]                     muffleCondition(cond, pattern = "^muffle")
[09:29:21.279]                   }
[09:29:21.279]                 }
[09:29:21.279]             }
[09:29:21.279]         }))
[09:29:21.279]     }, error = function(ex) {
[09:29:21.279]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:21.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:21.279]                 ...future.rng), started = ...future.startTime, 
[09:29:21.279]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:21.279]             version = "1.8"), class = "FutureResult")
[09:29:21.279]     }, finally = {
[09:29:21.279]         if (!identical(...future.workdir, getwd())) 
[09:29:21.279]             setwd(...future.workdir)
[09:29:21.279]         {
[09:29:21.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:21.279]                 ...future.oldOptions$nwarnings <- NULL
[09:29:21.279]             }
[09:29:21.279]             base::options(...future.oldOptions)
[09:29:21.279]             if (.Platform$OS.type == "windows") {
[09:29:21.279]                 old_names <- names(...future.oldEnvVars)
[09:29:21.279]                 envs <- base::Sys.getenv()
[09:29:21.279]                 names <- names(envs)
[09:29:21.279]                 common <- intersect(names, old_names)
[09:29:21.279]                 added <- setdiff(names, old_names)
[09:29:21.279]                 removed <- setdiff(old_names, names)
[09:29:21.279]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:21.279]                   envs[common]]
[09:29:21.279]                 NAMES <- toupper(changed)
[09:29:21.279]                 args <- list()
[09:29:21.279]                 for (kk in seq_along(NAMES)) {
[09:29:21.279]                   name <- changed[[kk]]
[09:29:21.279]                   NAME <- NAMES[[kk]]
[09:29:21.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.279]                     next
[09:29:21.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:21.279]                 }
[09:29:21.279]                 NAMES <- toupper(added)
[09:29:21.279]                 for (kk in seq_along(NAMES)) {
[09:29:21.279]                   name <- added[[kk]]
[09:29:21.279]                   NAME <- NAMES[[kk]]
[09:29:21.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.279]                     next
[09:29:21.279]                   args[[name]] <- ""
[09:29:21.279]                 }
[09:29:21.279]                 NAMES <- toupper(removed)
[09:29:21.279]                 for (kk in seq_along(NAMES)) {
[09:29:21.279]                   name <- removed[[kk]]
[09:29:21.279]                   NAME <- NAMES[[kk]]
[09:29:21.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:21.279]                     next
[09:29:21.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:21.279]                 }
[09:29:21.279]                 if (length(args) > 0) 
[09:29:21.279]                   base::do.call(base::Sys.setenv, args = args)
[09:29:21.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:21.279]             }
[09:29:21.279]             else {
[09:29:21.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:21.279]             }
[09:29:21.279]             {
[09:29:21.279]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:21.279]                   0L) {
[09:29:21.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:21.279]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:21.279]                   base::options(opts)
[09:29:21.279]                 }
[09:29:21.279]                 {
[09:29:21.279]                   {
[09:29:21.279]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:21.279]                     NULL
[09:29:21.279]                   }
[09:29:21.279]                   options(future.plan = NULL)
[09:29:21.279]                   if (is.na(NA_character_)) 
[09:29:21.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:21.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:21.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:21.279]                     .init = FALSE)
[09:29:21.279]                 }
[09:29:21.279]             }
[09:29:21.279]         }
[09:29:21.279]     })
[09:29:21.279]     if (TRUE) {
[09:29:21.279]         base::sink(type = "output", split = FALSE)
[09:29:21.279]         if (TRUE) {
[09:29:21.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:21.279]         }
[09:29:21.279]         else {
[09:29:21.279]             ...future.result["stdout"] <- base::list(NULL)
[09:29:21.279]         }
[09:29:21.279]         base::close(...future.stdout)
[09:29:21.279]         ...future.stdout <- NULL
[09:29:21.279]     }
[09:29:21.279]     ...future.result$conditions <- ...future.conditions
[09:29:21.279]     ...future.result$finished <- base::Sys.time()
[09:29:21.279]     ...future.result
[09:29:21.279] }
[09:29:21.282] Exporting 5 global objects (904 bytes) to cluster node #2 ...
[09:29:21.282] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[09:29:21.282] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[09:29:21.282] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[09:29:21.283] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[09:29:21.283] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[09:29:21.283] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[09:29:21.283] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:21.283] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:21.284] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:21.284] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:21.284] Exporting 5 global objects (904 bytes) to cluster node #2 ... DONE
[09:29:21.284] MultisessionFuture started
[09:29:21.285] - Launch lazy future ... done
[09:29:21.285] run() for ‘MultisessionFuture’ ... done
[09:29:21.285] Created future:
[09:29:21.286] receiveMessageFromWorker() for ClusterFuture ...
[09:29:21.286] - Validating connection of MultisessionFuture
[09:29:21.287] - received message: FutureResult
[09:29:21.287] - Received FutureResult
[09:29:21.287] - Erased future from FutureRegistry
[09:29:21.287] result() for ClusterFuture ...
[09:29:21.287] - result already collected: FutureResult
[09:29:21.287] result() for ClusterFuture ... done
[09:29:21.287] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:21.285] MultisessionFuture:
[09:29:21.285] Label: ‘future_mapply-2’
[09:29:21.285] Expression:
[09:29:21.285] {
[09:29:21.285]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:21.285]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:21.285]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:21.285]         on.exit(options(oopts), add = TRUE)
[09:29:21.285]     }
[09:29:21.285]     {
[09:29:21.285]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[09:29:21.285]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[09:29:21.285]         do.call(mapply, args = args)
[09:29:21.285]     }
[09:29:21.285] }
[09:29:21.285] Lazy evaluation: FALSE
[09:29:21.285] Asynchronous evaluation: TRUE
[09:29:21.285] Local evaluation: TRUE
[09:29:21.285] Environment: R_GlobalEnv
[09:29:21.285] Capture standard output: TRUE
[09:29:21.285] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:21.285] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:21.285] Packages: <none>
[09:29:21.285] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:21.285] Resolved: TRUE
[09:29:21.285] Value: <not collected>
[09:29:21.285] Conditions captured: <none>
[09:29:21.285] Early signaling: FALSE
[09:29:21.285] Owner process: 799cb277-931e-3bb8-3626-bac429e13596
[09:29:21.285] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:21.287] Chunk #2 of 2 ... DONE
[09:29:21.288] Launching 2 futures (chunks) ... DONE
[09:29:21.288] Resolving 2 futures (chunks) ...
[09:29:21.288] resolve() on list ...
[09:29:21.288]  recursive: 0
[09:29:21.288]  length: 2
[09:29:21.288] 
[09:29:21.288] receiveMessageFromWorker() for ClusterFuture ...
[09:29:21.289] - Validating connection of MultisessionFuture
[09:29:21.289] - received message: FutureResult
[09:29:21.289] - Received FutureResult
[09:29:21.289] - Erased future from FutureRegistry
[09:29:21.289] result() for ClusterFuture ...
[09:29:21.289] - result already collected: FutureResult
[09:29:21.289] result() for ClusterFuture ... done
[09:29:21.289] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:21.289] Future #1
[09:29:21.289] result() for ClusterFuture ...
[09:29:21.290] - result already collected: FutureResult
[09:29:21.290] result() for ClusterFuture ... done
[09:29:21.290] result() for ClusterFuture ...
[09:29:21.290] - result already collected: FutureResult
[09:29:21.290] result() for ClusterFuture ... done
[09:29:21.290] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:21.290] - nx: 2
[09:29:21.290] - relay: TRUE
[09:29:21.290] - stdout: TRUE
[09:29:21.290] - signal: TRUE
[09:29:21.290] - resignal: FALSE
[09:29:21.290] - force: TRUE
[09:29:21.291] - relayed: [n=2] FALSE, FALSE
[09:29:21.291] - queued futures: [n=2] FALSE, FALSE
[09:29:21.291]  - until=1
[09:29:21.291]  - relaying element #1
[09:29:21.291] result() for ClusterFuture ...
[09:29:21.291] - result already collected: FutureResult
[09:29:21.291] result() for ClusterFuture ... done
[09:29:21.291] result() for ClusterFuture ...
[09:29:21.291] - result already collected: FutureResult
[09:29:21.291] result() for ClusterFuture ... done
[09:29:21.292] result() for ClusterFuture ...
[09:29:21.292] - result already collected: FutureResult
[09:29:21.292] result() for ClusterFuture ... done
[09:29:21.292] result() for ClusterFuture ...
[09:29:21.292] - result already collected: FutureResult
[09:29:21.292] result() for ClusterFuture ... done
[09:29:21.292] - relayed: [n=2] TRUE, FALSE
[09:29:21.292] - queued futures: [n=2] TRUE, FALSE
[09:29:21.292] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:21.292]  length: 1 (resolved future 1)
[09:29:21.292] Future #2
[09:29:21.293] result() for ClusterFuture ...
[09:29:21.293] - result already collected: FutureResult
[09:29:21.293] result() for ClusterFuture ... done
[09:29:21.293] result() for ClusterFuture ...
[09:29:21.293] - result already collected: FutureResult
[09:29:21.293] result() for ClusterFuture ... done
[09:29:21.293] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:21.293] - nx: 2
[09:29:21.293] - relay: TRUE
[09:29:21.293] - stdout: TRUE
[09:29:21.293] - signal: TRUE
[09:29:21.293] - resignal: FALSE
[09:29:21.294] - force: TRUE
[09:29:21.294] - relayed: [n=2] TRUE, FALSE
[09:29:21.294] - queued futures: [n=2] TRUE, FALSE
[09:29:21.294]  - until=2
[09:29:21.294]  - relaying element #2
[09:29:21.294] result() for ClusterFuture ...
[09:29:21.294] - result already collected: FutureResult
[09:29:21.294] result() for ClusterFuture ... done
[09:29:21.294] result() for ClusterFuture ...
[09:29:21.294] - result already collected: FutureResult
[09:29:21.294] result() for ClusterFuture ... done
[09:29:21.295] result() for ClusterFuture ...
[09:29:21.295] - result already collected: FutureResult
[09:29:21.295] result() for ClusterFuture ... done
[09:29:21.295] result() for ClusterFuture ...
[09:29:21.295] - result already collected: FutureResult
[09:29:21.295] result() for ClusterFuture ... done
[09:29:21.295] - relayed: [n=2] TRUE, TRUE
[09:29:21.295] - queued futures: [n=2] TRUE, TRUE
[09:29:21.295] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:21.295]  length: 0 (resolved future 2)
[09:29:21.295] Relaying remaining futures
[09:29:21.295] signalConditionsASAP(NULL, pos=0) ...
[09:29:21.296] - nx: 2
[09:29:21.296] - relay: TRUE
[09:29:21.296] - stdout: TRUE
[09:29:21.296] - signal: TRUE
[09:29:21.296] - resignal: FALSE
[09:29:21.296] - force: TRUE
[09:29:21.296] - relayed: [n=2] TRUE, TRUE
[09:29:21.296] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:21.296] - relayed: [n=2] TRUE, TRUE
[09:29:21.296] - queued futures: [n=2] TRUE, TRUE
[09:29:21.297] signalConditionsASAP(NULL, pos=0) ... done
[09:29:21.297] resolve() on list ... DONE
[09:29:21.297] result() for ClusterFuture ...
[09:29:21.297] - result already collected: FutureResult
[09:29:21.297] result() for ClusterFuture ... done
[09:29:21.297] result() for ClusterFuture ...
[09:29:21.297] - result already collected: FutureResult
[09:29:21.297] result() for ClusterFuture ... done
[09:29:21.297] result() for ClusterFuture ...
[09:29:21.297] - result already collected: FutureResult
[09:29:21.297] result() for ClusterFuture ... done
[09:29:21.298] result() for ClusterFuture ...
[09:29:21.298] - result already collected: FutureResult
[09:29:21.298] result() for ClusterFuture ... done
[09:29:21.298]  - Number of value chunks collected: 2
[09:29:21.298] Resolving 2 futures (chunks) ... DONE
[09:29:21.298] Reducing values from 2 chunks ...
[09:29:21.298]  - Number of values collected after concatenation: 2
[09:29:21.298]  - Number of values expected: 2
[09:29:21.298] Reducing values from 2 chunks ... DONE
[09:29:21.298] future_mapply() ... DONE
[09:29:21.298] plan(): Setting new future strategy stack:
[09:29:21.299] List of future strategies:
[09:29:21.299] 1. sequential:
[09:29:21.299]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:21.299]    - tweaked: FALSE
[09:29:21.299]    - call: plan(sequential)
[09:29:21.299] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("- Empty input [non parallel] ...")
- Empty input [non parallel] ...
> y0 <- mapply(search)
> y1 <- future_mapply(search)
> stopifnot(identical(y1, y0))
> 
> y0 <- mapply(list, integer(0L))
> y1 <- future_mapply(list, integer(0L))
> stopifnot(identical(y1, y0))
> 
> message("*** future_mapply() - special cases ...")
*** future_mapply() - special cases ...
> 
> X <- list()
> names(X) <- character(0L)
> 
> y <- future_mapply(FUN = identity, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> y <- future_mapply(FUN = identity, X, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> message("*** future_mapply() - special cases ... DONE")
*** future_mapply() - special cases ... DONE
> 
> message("*** future_mapply() ... DONE")
*** future_mapply() ... DONE
> 
> source("incl/end.R")
[09:29:21.301] plan(): Setting new future strategy stack:
[09:29:21.301] List of future strategies:
[09:29:21.301] 1. FutureStrategy:
[09:29:21.301]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:21.301]    - tweaked: FALSE
[09:29:21.301]    - call: future::plan(oplan)
[09:29:21.302] plan(): nbrOfWorkers() = 1
> 
